--- DATE: 8.1.2026, 21:19:00 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
    Architektur: 4-Layer (Eric Evans).
    Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
    Regeln:
    1. Begründe kurz jeden Fund.
    4. Gruppiere nach Datei (mit Pfad). 
    2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
    3. Keine Code-Wiederholung, nur Referenzen.
    5. Wenn fertig, schreibe "ENDE".



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Address.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import jakarta.persistence.Embeddable;
import jakarta.persistence.Embedded;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

@Embeddable
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
@Getter
public class Address implements thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType {
    private String street;
    private String city;
    @Embedded
    private ZipCode zipCode;

    @Override
    public String getStreet() {
        return street;
    }

    @Override
    public String getCity() {
        return city;
    }

    @Override
    public ZipCodeType getZipCode() {
        return zipCode;
    }


    public static Address of(String street, String city, ZipCodeType zipCode) {
        if (street == null || street.isEmpty()) throw new ShopException("street is null or empty");

        if (city == null || city.isEmpty()) throw new ShopException("city is null or empty");

        if (zipCode == null) throw new ShopException("zipCode is null");

        return new Address(street, city, (ZipCode) zipCode);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Currency.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import jakarta.persistence.Embeddable;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

import java.text.NumberFormat;
import java.util.Locale;

@Embeddable
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
@Getter
public class Currency implements CurrencyType {

    private Float quantity;
    private CurrencyEnum currencyUnit;

    @Override
    public Float getQuantity() {
        return quantity;
    }

    @Override
    public String getCurrencyUnit() {
        return currencyUnit.name();
    }


    @Override
    public String toString() {
        String currencySymbol = "€";
        if (currencyUnit.name().equals("CHF")) {
            currencySymbol = "CHF";
        }

        NumberFormat format = NumberFormat.getNumberInstance(Locale.getDefault());
        format.setMinimumFractionDigits(2);
        format.setMaximumFractionDigits(2);
        format.setGroupingUsed(false);

        String formatted = format.format(getQuantity());
        return formatted + " " + currencySymbol;
    }

    @Override
    public CurrencyType add(CurrencyType otherCurrency) {
        if (otherCurrency == null) throw new ShopException("otherCurrency is null");
        if(this.currencyUnit.name().equals(otherCurrency.getCurrencyUnit()) == false) {
            throw new ShopException("Currency units do not match");
        }
        return Currency.of(otherCurrency.getQuantity() + this.getQuantity(), this.getCurrencyUnit());
    }

    /**
     * @param otherCurrency
     * @return this - otherCurrency, as a new object
     * @throws ShopException if ...
     *                       - otherCurrency is null
     *                       - otherCurrency.currencyUnit != this.currencyUnit
     *                       - otherCurrency > this
     */
    @Override
    public CurrencyType subtract(CurrencyType otherCurrency) {
        if (otherCurrency == null) throw new ShopException("otherCurrency is null");
        if(this.currencyUnit.name().equals(otherCurrency.getCurrencyUnit()) == false) {
            throw new ShopException("Currency units do not match");
        }
        if(otherCurrency.getQuantity() > this.getQuantity()) {
            throw new ShopException("Currency quantity is less than 0");
        }
        float newQuantity = this.getQuantity() - otherCurrency.getQuantity();

        return Currency.of(newQuantity, this.getCurrencyUnit());

    }

    /**
     * @param factor
     * @return this * factor, as a new object
     * @throws ShopException if ...
     *                       - factor < 0
     */
    @Override
    public CurrencyType multiplyBy(int factor) {
        if(factor < 0) throw new ShopException("factor is negative");
        return Currency.of(this.getQuantity() * factor, this.getCurrencyUnit());
    }

    /**
     * @param otherCurrency
     * @return true, if this > otherCurrency
     * @throws ShopException if ...
     *                       - otherCurrency is null
     *                       - otherCurrency.currencyUnit != this.currencyUnit
     */
    @Override
    public boolean largerThan(CurrencyType otherCurrency) {
        if(otherCurrency == null) throw new ShopException("otherCurrency is null");
        if(this.currencyUnit.name().equals(otherCurrency.getCurrencyUnit()) == false) {
            throw new ShopException("Currency units do not match");
        }
        return this.getQuantity() > otherCurrency.getQuantity();
    }

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates a currency object from an quantity and a currency unit (as string).
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param quantity     the quantity of currency (must be >= 0)
     * @param currencyUnit the currency unit of the currency (allowed values: "EUR", "CHF")
     * @return a new Currency object with the given quantity and currency unit
     * @throws ShopException if ...
     *                       - quantity is null
     *                       - quantity < 0
     *                       - currency unit is null
     *                       - currency unit is not one of the allowed values
     */
    public static CurrencyType of(Float quantity, String currencyUnit) {
        if(quantity == null) {
            throw new ShopException("quantity is null");
        }
        if(quantity < 0) {
            throw new ShopException("quantity is less than 0");
        }
        if(currencyUnit == null) {
            throw new ShopException("currencyUnit is null");
        }
        if(isValidCurrency(currencyUnit) == false) {
            throw new ShopException("currencyUnit is not valid");
        }

        return new Currency(quantity, CurrencyEnum.valueOf(currencyUnit));
    }

    private static boolean isValidCurrency(String currencyUnit) {
        try {
            CurrencyEnum.valueOf(currencyUnit);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\CurrencyEnum.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

public enum CurrencyEnum {
    EUR, CHF
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Email.java ---
package thkoeln.archilab.ecommerce.domainprimitives;
import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.Embeddable;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

@Embeddable
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
@Getter
public class Email implements EmailType {

    @JsonProperty("emailString")
    private String email;

    public String toString() {
        return email;
    }
    /**
     * A special kind of "copy constructor": Returns a new email object with
     * the same identifyer (the substring left of the "@" sign) as the current one, but
     * with a new domain substring (right of the "@" sign).
     *
     * @param domainString - the new domain for the copied email
     * @return the new email
     * @throws ShopException if ...
     *                       - domainString is null
     *                       - the new email would not be valid (see `of(...)` method)
     */
    @Override
    public EmailType sameIdentifyerDifferentDomain(String domainString) {
        if(domainString == null) throw new ShopException("domainString is null");

        String newMail = email.substring(0, email.indexOf("@")) + "@" + domainString;
        try{
            return Email.of(newMail);
        } catch (Exception e) {
            throw new ShopException("new email is not valid");
        }
    }

    /**
     * Another special kind of "copy constructor": Returns a new email object
     * with the same domain (the substring right of the "@" sign) as the current one, but
     * with a new identifyer substring (left of the "@" sign).
     *
     * @param identifyerString - the new identifyer for the copied email
     * @return the new email
     * @throws ShopException if ...
     *                       - identifyerString is null
     *                       - the new email would not be valid (see `of(...)` method)
     */
    @Override
    public EmailType sameDomainDifferentIdentifyer(String identifyerString) {
        String newMail = identifyerString + email.substring(email.indexOf("@"));
        try {
            return Email.of(newMail);
        } catch (ShopException e) {
            throw new ShopException("new email is not valid");
        }
    }


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an email, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param emailAsString - the email as a string.
     *      We will use a much simplified validation method to check if the email is valid:
     *      - it must contain exactly one '@' character.
     *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
     *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
     *      - the substrings before and after the '@' may contain one or several '.' as separators
     *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
     *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
     *        (for simplicity we do not allow any other domains)
     * @return a new EmailType object matching the given email
     * @throws ShopException if ...
     *      - emailAsString is null
     *      - emailAsString is not a valid email (see above)
     */
    public static EmailType of( String emailAsString ) {
        if (emailAsString == null) {
            throw new ShopException("Email cannot be null");
        }

        // Check for exactly one '@'
        int atIndex = emailAsString.indexOf('@');
        if (atIndex == -1 || atIndex != emailAsString.lastIndexOf('@')) {
            throw new ShopException("Email must contain exactly one '@'");
        }

        String localPart = emailAsString.substring(0, atIndex);
        String domainPart = emailAsString.substring(atIndex + 1);

        // Basic non-empty checks
        if (localPart.isEmpty() || domainPart.isEmpty()) {
            throw new ShopException("Local or domain part is empty");
        }

        // Check for allowed characters (A-Z, a-z, 0-9, .) and no whitespace
        String validCharsRegex = "^[A-Za-z0-9]+(\\.?[A-Za-z0-9]+)*$";
        if (!localPart.matches(validCharsRegex) || !domainPart.matches(validCharsRegex)) {
            throw new ShopException("Email parts must contain only A-Z, a-z, 0-9 and dots, and no whitespace");
        }

        // No consecutive dots
        if (emailAsString.contains("..")) {
            throw new ShopException("Email must not contain consecutive dots");
        }

        // Domain must end with allowed TLDs
        if (!domainPart.matches(".*\\.(de|at|ch|com|org)$")) {
            throw new ShopException("Invalid top-level domain");
        }
        if (emailAsString.matches("^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$") && !emailAsString.matches(".*\\.\\.{2,}.*")) {
            return new Email( emailAsString );
        } else {
            throw new ShopException( "emailAsString is not a valid email" );
        }


    }



}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\ConflictException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;
@ResponseStatus(code = HttpStatus.CONFLICT)
public class ConflictException extends ShopException {
    public ConflictException(String message) {
        super(message);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\InsufficientInventoryException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
@ResponseStatus(code = HttpStatus.CONFLICT)
public class InsufficientInventoryException extends thkoeln.archilab.ecommerce.InsufficientInventoryException {
    public InsufficientInventoryException(String message) {
        super(message);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\MethodNotAllowedException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(HttpStatus.METHOD_NOT_ALLOWED)
public class MethodNotAllowedException extends ShopException {
    public MethodNotAllowedException(String message) {
        super(message);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\NotFoundException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Entity not found")
public class NotFoundException extends ShopException {
    public NotFoundException(String message){
        super(message);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\UnprocessableEntityException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY, reason="Entity or data is invalid")
public class UnprocessableEntityException extends ShopException {
    public UnprocessableEntityException(String message){
        super(message);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.Embeddable;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import static java.lang.Math.abs;

@Embeddable
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
@Getter
public class ZipCode implements ZipCodeType {
    @JsonProperty("zipCodeString")
    private String zipCode;

    public String toString() {
        return zipCode;
    }



    /***
    * - The return value is 0 if both zip codes are the same
     * - If not:
     *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
     *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
     *        So, 56733 and 56734 have the same difference as 56733 and 56739.
     *      - The difference grows if more digits (counted from the right side) differ.
     *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
     *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
     *        53876 and 54876 have the same difference as 53876 and 57261.
     *      - However, the difference between 5abcd and 6rstu must be smaller than the one
     *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
     *        one between 5abcd and 9rstu.
     *      - This last condition reflects the fact the first digits of a zip code marks a region
     *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
     *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
     *        other.
     */
    public int difference(ZipCodeType otherZipCode) {
        if (otherZipCode == null) throw new ShopException("otherZipCode is null");

        if(this.zipCode.equals(otherZipCode.toString())) return 0;

        int firstDigitOfThisZipCode = Character.getNumericValue(this.zipCode.charAt(0));
        int firstDigitOfOtherZipCode = Character.getNumericValue(otherZipCode.toString().charAt(0));
        int diff = Math.abs(firstDigitOfThisZipCode - firstDigitOfOtherZipCode);
        int zirkularDifference = Math.min(diff, 10 - diff );
        String difference = String.valueOf(zirkularDifference);

        for (int i = 1; i < this.zipCode.length(); i++) {
            if (this.zipCode.charAt(i) != otherZipCode.toString().charAt(i)) {
                difference += "1";
                for(int j = i + 1; j < this.zipCode.length(); j++) {
                    difference += "0";}
                break;
            } else difference += "0";
        }
        return Integer.parseInt(difference);
    }


    public Integer getFirstDigitZipCode() {
        return Character.getNumericValue(this.zipCode.charAt(0));
    }


    public static ZipCodeType of(String zipCodeAsString) {
        if (zipCodeAsString == null) {
            throw new ShopException("zipCodeAsString is null");
        }
        if (isZipCodeValid(zipCodeAsString) == false) {
            throw new ShopException("zipCodeAsString is not a valid zip code");
        }
        return new ZipCode(zipCodeAsString);
    }

    public static Boolean isZipCodeValid(String zipCode) {
        if (zipCode.matches("^[0-9]{5}$") == false) {
            return false;
        }
        if (zipCode.substring(1).equals("0000")) {
            return false;
        }
        return true;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */
package thkoeln.archilab.ecommerce;

import jakarta.persistence.Column;
import jakarta.persistence.MappedSuperclass;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

import java.io.Serializable;
import java.util.UUID;

@MappedSuperclass
@Getter
@EqualsAndHashCode(of = "id")
@ToString(of = "id")
public abstract class GenericId implements Serializable {
    @Column(nullable = false, updatable = false)
    private final UUID id;

    protected GenericId() {
        this( UUID.randomUUID() );
    }

    protected GenericId( UUID id ) {
        this.id = id;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */
package thkoeln.archilab.ecommerce;

import jakarta.persistence.AttributeConverter;

import java.util.UUID;
import java.util.function.Function;


public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
    private final Function<UUID, T> factory;

    protected GenericIdConverter( Function<UUID, T> factory ) {
        this.factory = factory;
    }

    @Override
    public UUID convertToDatabaseColumn( T attribute ) {
        return attribute == null ? null : attribute.getId();
    }

    @Override
    public T convertToEntityAttribute( UUID dbData ) {
        return dbData == null ? null : factory.apply( dbData );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\InsufficientInventoryException.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */
package thkoeln.archilab.ecommerce;

/**
 * Exception is thrown if the item's inventory level is not sufficient to serve the order.
 */
public class InsufficientInventoryException extends ShopException {
    public InsufficientInventoryException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */
package thkoeln.archilab.ecommerce;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class ProjectApplication {

	/**
	 * Entry method
	 * @param args
	 */
	public static void main(String[] args) {
		SpringApplication.run(ProjectApplication.class, args);
	}
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */
package thkoeln.archilab.ecommerce;

public class ShopException extends RuntimeException {
    public ShopException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\InventoryLevelDeletionInterface.java ---
package thkoeln.archilab.ecommerce.solution.item.application;

import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;

public interface InventoryLevelDeletionInterface {
     Boolean existsInAnyInventoryLevel(ItemId itemId);
     void deleteAllInventoryLevels();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ItemAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.item.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

import java.util.UUID;

@Service
public class ItemAdapterService implements ItemCatalogUseCases {
    private final ItemService itemService;

    @Autowired
    public ItemAdapterService(ItemService itemService) {
        this.itemService = itemService;
    }

    @Override
    public UUID addItemToCatalog(String name, String descriptOf, Float size, CurrencyType buyingPrice, CurrencyType sellingPrice) {
        return itemService.addItemToCatalog(name, descriptOf, size, (Currency) buyingPrice, (Currency) sellingPrice).getId();
    }

    @Override
    public void removeItemFromCatalog(UUID itemId) {
        itemService.removeItemFromCatalog(new ItemId(itemId));
    }

    @Override
    public CurrencyType getSellingPrice(UUID itemId) {
        return itemService.getSellingPrice(new ItemId(itemId));
    }

    @Override
    public void deleteItemCatalog() {
        itemService.deleteItemCatalog();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ItemService.java ---
package thkoeln.archilab.ecommerce.solution.item.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.ConflictException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.NotFoundException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
import thkoeln.archilab.ecommerce.solution.item.domain.Item;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemRepository;


@Service
public class ItemService {

    private final ItemRepository itemRepository;
    private final InventoryLevelDeletionInterface inventoryLevelDeletionInterface;
    private final ShoppingCartDeletionInterface shoppingCartDeletionInterface;
    private final OrderDeletionInterface orderDeletionInterface;

    @Autowired
    public ItemService(ItemRepository itemRepository,
                       ShoppingCartDeletionInterface shoppingCartDeletionInterface,
                       OrderDeletionInterface orderDeletionInterface,
                       InventoryLevelDeletionInterface inventoryLevelDeletionService) {
        this.itemRepository = itemRepository;
        this.inventoryLevelDeletionInterface = inventoryLevelDeletionService;
        this.shoppingCartDeletionInterface = shoppingCartDeletionInterface;
        this.orderDeletionInterface = orderDeletionInterface;
    }
    /**
     * Adds a new item to the shop catalog
     * @param name
     * @param descriptOf
     * @param size
     * @param buyingPrice
     * @param sellingPrice
     * @return the id of the new item
     * @throws ShopException if ...
     *         - name or description are null or empty,
     *         - the size is <= 0 (but can be null!),
     *         - the buying price is null or <= 0,
     *         - the selling price is null or <= 0,
     *         - the selling price is lower than the buying price
     */

    public ItemId addItemToCatalog(String name, String descriptOf, Float size, Currency buyingPrice, Currency sellingPrice) {

        if(name == null || descriptOf == null || buyingPrice == null || sellingPrice == null) {
            throw new UnprocessableEntityException("Argument cannot be null");
        }
        if(name.isEmpty() || descriptOf.isEmpty()) {
            throw new UnprocessableEntityException("Name or description cannot be empty");
        }
        if(size != null && size <= 0) {
            throw new UnprocessableEntityException("Size must be greater than 0");
        }
        if(buyingPrice.getQuantity() <= 0) {
            throw new UnprocessableEntityException("Price must be greater than 0");
        }
        if(sellingPrice.getQuantity() <= 0) {
            throw new UnprocessableEntityException("Price must be greater than 0");
        }
        if(sellingPrice.getQuantity() < buyingPrice.getQuantity()) {
            throw new UnprocessableEntityException("Selling price must be greater than buying price");
        }

        Item item = new Item(name, descriptOf, size, buyingPrice, sellingPrice);
        itemRepository.save(item);

        return item.getId();
    }

    /**
     * Removes a item from the shop catalog
     * @param itemId
     * @throws ShopException if
     *      - the item id does not exist
     *      - the item is still in inventory
     *      - the item is still in a shopping cart, or referenced by a completed order
     */


    public void removeItemFromCatalog(ItemId itemId) {

        if(!itemRepository.existsById(itemId)) {
            throw new NotFoundException("Item not found");
        }
        if(inventoryLevelDeletionInterface.existsInAnyInventoryLevel(itemId)) {
            throw new ConflictException("Item is still in inventory");
        }
        if(shoppingCartDeletionInterface.existsInAnyShoppingCart(itemId)){
            throw new ConflictException("Item is still in a shopping cart");
        }
        if(orderDeletionInterface.existsInAnyOrder(itemId)){
            throw new ConflictException("Item is still in an order");
        }
        itemRepository.deleteById(itemId);
    }
    /**
     * Get the selling price of a given item
     * @param itemId
     * @return the selling price
     * @throws ShopException if the item id does not exist
     */

    public Currency getSellingPrice(ItemId itemId) {

        if(itemRepository.findById(itemId).isPresent()) {
            return itemRepository.findById(itemId).get().getSellingPrice();
        } else {
            throw new NotFoundException("Item not found");
        }
    }


    /**
     * Clears the item catalog, i.e. removes all items from the catalog, including all the inventory,
     * all the reservations and all the orders.
     */
    public void deleteItemCatalog() {
        inventoryLevelDeletionInterface.deleteAllInventoryLevels();
        shoppingCartDeletionInterface.deleteAll();
        orderDeletionInterface.deleteAll();
        itemRepository.deleteAll();
    }

    public Item getItemById(ItemId itemId) {
        if (itemIdNotExisting(itemId))
            return null;
        else
            return itemRepository.findById(itemId).get();
    }

    public Boolean itemIdNotExisting(ItemId itemId) {
        return !(itemId != null && itemRepository.existsById(itemId));
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\OrderDeletionInterface.java ---
package thkoeln.archilab.ecommerce.solution.item.application;

import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;

public interface OrderDeletionInterface {
    Boolean existsInAnyOrder(ItemId itemId);
    void deleteAll();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ShoppingCartDeletionInterface.java ---
package thkoeln.archilab.ecommerce.solution.item.application;

import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;

public interface ShoppingCartDeletionInterface {
    Boolean existsInAnyShoppingCart(ItemId itemId);
    void deleteAll();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\Item.java ---
package thkoeln.archilab.ecommerce.solution.item.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;

@Entity
@Setter
@Getter
@NoArgsConstructor
public class Item {

    @Setter(AccessLevel.PRIVATE)    // only for JPA
    @EmbeddedId
    private ItemId id;

    private String name;
    private String description;
    private Float size ;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "quantity", column = @Column(name = "buying_price_quantity")),
            @AttributeOverride(name = "currencyUnit", column = @Column(name = "buying_price_currency"))
    })
    private Currency buyingPrice;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "quantity", column = @Column(name = "selling_price_quantity")),
            @AttributeOverride(name = "currencyUnit", column = @Column(name = "selling_price_currency"))
    })
    private Currency sellingPrice;


    public Item(String name, String description, Float size, Currency buyingPrice, Currency sellingPrice) {
        this.id = new ItemId();
        this.name = name;
        this.description = description;
        this.size = size;
        this.buyingPrice = buyingPrice;
        this.sellingPrice = sellingPrice;
    }



}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemId.java ---
package thkoeln.archilab.ecommerce.solution.item.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "item_id"))
public class ItemId extends GenericId {
    public ItemId(UUID id ) {
        super( id );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.item.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ItemIdConverter extends GenericIdConverter<ItemId> {
    public ItemIdConverter() {
        super(ItemId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemRepository.java ---
package thkoeln.archilab.ecommerce.solution.item.domain;


import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;


@Repository
public interface ItemRepository extends CrudRepository<Item, ItemId> {

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\dto\OrderDTO.java ---
package thkoeln.archilab.ecommerce.solution.order.application.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.List;
import java.util.UUID;


@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
public class OrderDTO {
    private UUID orderId;
    private String userName;
    private UUID storageUnitId;
    private List<OrderPositionDTO> positions;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\dto\OrderDTOHelper.java ---
package thkoeln.archilab.ecommerce.solution.order.application.dto;

import thkoeln.archilab.ecommerce.solution.order.domain.Order;

import java.util.List;

public class OrderDTOHelper {
    public static OrderDTO entityToOrderDto(Order order, List<OrderPositionDTO> orderPositionDTOList, String userName){
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(order.getId().getId());
        orderDTO.setPositions(orderPositionDTOList);
        orderDTO.setUserName(userName);
        orderDTO.setStorageUnitId(order.getStorageUnitId().getId());

        return orderDTO;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\dto\OrderPositionDTO.java ---
package thkoeln.archilab.ecommerce.solution.order.application.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.UUID;

@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
public class OrderPositionDTO {
    private UUID itemId;
    private Integer quantity;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\dto\OrderPositionDTOHelper.java ---
package thkoeln.archilab.ecommerce.solution.order.application.dto;

import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;

import java.util.ArrayList;
import java.util.List;

public class OrderPositionDTOHelper {

    public static OrderPositionDTO fromOrderPosition(OrderPosition orderPosition){
            return new OrderPositionDTO(orderPosition.getItemId().getId(), orderPosition.getQuantity());
    }

    public static List<OrderPositionDTO> fromListOfOrderPositions(List<OrderPosition> orderPositions){
        List<OrderPositionDTO> orderPositionDTOList = new ArrayList<>();
        for(OrderPosition each : orderPositions){
            orderPositionDTOList.add(fromOrderPosition(each));
        }
        return orderPositionDTOList;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.order.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.usecases.OrderUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class OrderAdapterService implements OrderUseCases {

    private final OrderService orderService;
    @Autowired
    public OrderAdapterService(OrderService orderService) {
        this.orderService = orderService;
    }


    @Override
    public Map<UUID, Integer> getOrderHistory(EmailType userEmail) {
        Map<ItemId, Integer> orderHistory = orderService.getOrderHistory((Email) userEmail);
        return orderHistory.entrySet().stream()
                .collect(Collectors.toMap(entry -> entry.getKey().getId(), Map.Entry::getValue));

    }


    @Override
    public Integer getOrderQuantityOfItem(UUID orderId, UUID itemId) {
        return orderService.getOrderQuantityOfItem(orderId,itemId);
    }


    @Override
    public UUID getStorageUnitIdForOrder(UUID orderId) {
        return orderService.getStorageUnitIdForOrder(orderId);
    }

    @Override
    public void deleteAllOrders() {
        orderService.deleteAllOrders();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderDeletionService.java ---
package thkoeln.archilab.ecommerce.solution.order.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.item.application.OrderDeletionInterface;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderPositionRepository;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;

@Service
public class OrderDeletionService implements OrderDeletionInterface {

    private final OrderPositionRepository orderPositionRepository;
    private final OrderRepository orderRepository;

    @Autowired
    public OrderDeletionService(OrderPositionRepository orderPositionRepository, OrderRepository orderRepository) {
        this.orderPositionRepository = orderPositionRepository;
        this.orderRepository = orderRepository;
    }

    public Boolean existsInAnyOrder(ItemId itemId) {
        return orderPositionRepository.existsByItemId(itemId);
    }

    @Override
    public void deleteAll() {
        orderRepository.deleteAll();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderService.java ---
package thkoeln.archilab.ecommerce.solution.order.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.NotFoundException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
import thkoeln.archilab.ecommerce.solution.storageunit.application.StorageUnitService;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
import thkoeln.archilab.ecommerce.solution.user.application.UserService;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class OrderService  {

    private final OrderRepository orderRepository;
    private final UserService userService;
    private final OrderDeletionService orderDeletionService;
    private final StorageUnitService storageUnitService;


    @Autowired
    public OrderService(
            OrderRepository orderRepository,
            UserService userService,
            OrderDeletionService orderDeletionService,
            StorageUnitService storageUnitService
    ) {
        this.orderRepository = orderRepository;
        this.userService = userService;
        this.orderDeletionService = orderDeletionService;
        this.storageUnitService = storageUnitService;
    }
    /**
     * Returns a map showing which items have been ordered by a user and how many of each item
     *
     * @param userEmail
     * @return the order history of the user (map is empty if the user has not ordered anything yet)
     * @throws ShopException if
     *                       - userEmail is null or empty
     *                       - the user with the given email does not exist
     */

    public Map<ItemId, Integer> getOrderHistory(Email userEmail) {

        if (userEmail == null || userEmail.toString().isEmpty()) throw new UnprocessableEntityException("User email cannot be null or empty");
        UserId userId = userService.getUserIdOrNullByEmail(userEmail);
        if(userId == null) throw new NotFoundException("User with email does not exist");

        return getOrderHistory(userId);
    }

    public Map<ItemId, Integer> getOrderHistory(UserId userId){
        return orderRepository.findAllByUserId(userId).get().stream()
                .flatMap(order -> order.getOrderPositions().stream())
                .collect(Collectors.toMap(
                        OrderPosition::getItemId,
                        OrderPosition::getQuantity,
                        Integer::sum // falls mehrfach das gleiche itemId vorkommt
                ));
    }



    public Integer getOrderQuantityOfItem(UUID orderId, UUID itemId) {
        if (orderId == null || itemId == null) throw new UnprocessableEntityException("OrderID or ItemId should not be null");

        Optional<Order> order = orderRepository.findById(new OrderId(orderId));
        if (order.isEmpty()) throw new NotFoundException("Order is not found");

        Integer quantity = null;
        for (OrderPosition orderPosition : order.get().getOrderPositions()) {
            if (orderPosition.getItemId().equals(new ItemId(itemId))) {
                quantity = orderPosition.getQuantity();
            }
        }
        return quantity;
    }

    public Order getOrderOrNull(OrderId orderId){
        Optional<Order> order = orderRepository.findById(orderId);
        return order.orElse(null);
    }

    public UUID getStorageUnitIdForOrder(UUID orderId) {
        Optional<Order> order = orderRepository.findById(new OrderId(orderId));
        if(order.isEmpty()) throw new NotFoundException("Order is not found");
        return order.get().getStorageUnitId().getId();
    }

    public void deleteAllOrders() { orderDeletionService.deleteAll();}

    public OrderId createOrder(Map<ItemId, Integer> map, StorageUnitId storageUnitId, UserId userId){

        Order order = new Order(userId, storageUnitId);

        for(Map.Entry<ItemId, Integer> each : map.entrySet()){
            order.addToOrderPosition(new OrderPosition(each.getValue(), each.getKey()));
            storageUnitService.removeFromInventory(storageUnitId, each.getKey(), each.getValue());
        }
        orderRepository.save(order);
        return order.getId();
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;


import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "orders")
@Getter
@NoArgsConstructor
public class Order {
    @Setter(AccessLevel.PRIVATE)    // only for JPA
    @EmbeddedId
    private OrderId id;

    @OneToMany (cascade= CascadeType.ALL, fetch= FetchType.EAGER, orphanRemoval = true)
    private List<OrderPosition> orderPositions;

    @Embedded
    private UserId userId;

    @Embedded
    private StorageUnitId storageUnitId;

    public Order(UserId userId, StorageUnitId storageUnitId) {
        this.id = new OrderId();
        this.userId = userId;
        this.orderPositions = new ArrayList<>();
        this.storageUnitId = storageUnitId;
    }

    public void addToOrderPosition(OrderPosition orderPosition) {
        this.orderPositions.add(orderPosition);
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderId.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "order_id"))
public class OrderId extends GenericId {
    public OrderId(UUID id ) {
        super( id );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class OrderIdConverter extends GenericIdConverter<OrderId> {
    public OrderIdConverter() {
        super(OrderId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPosition.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.Embedded;
import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;


@Entity
@Getter
@NoArgsConstructor
public class OrderPosition {
    @Setter(AccessLevel.PRIVATE)    // only for JPA
    @EmbeddedId
    private OrderPositionId id;
    private Integer quantity;

    @Embedded
    private ItemId itemId;

    public OrderPosition(Integer quantity, ItemId itemId) {
        this.id = new OrderPositionId();
        setQuantity(quantity);
        this.itemId = itemId;
    }

    public void setQuantity(Integer quantity) {
        if (quantity <= 0) {
            throw new UnprocessableEntityException("Quantity cannot be negative");
        }
        this.quantity = quantity;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionId.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "orderPosition_id"))
public class OrderPositionId extends GenericId {
    public OrderPositionId(UUID id ) {
        super( id );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class OrderPositionIdConverter extends GenericIdConverter<OrderPositionId> {
    public OrderPositionIdConverter() {
        super(OrderPositionId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionRepository.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;

@Repository
public interface OrderPositionRepository extends CrudRepository<OrderPosition, OrderPositionId> {
    Boolean existsByItemId(ItemId itemId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderRepository.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.List;
import java.util.Optional;

@Repository
public interface OrderRepository extends CrudRepository<Order, OrderRepository> {
    Optional<List<Order>> findAllByUserId(UserId userId);
    Optional<Order> findById(OrderId id);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\dto\ShoppingCartDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.application.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.List;
import java.util.UUID;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ShoppingCartDTO {

    private UUID id;

    private String totalSellingPrice;

    private List<ShoppingCartPositionDTO> positions;


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\dto\ShoppingCartDTOHelper.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.application.dto;

import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartId;

import java.util.List;


public class ShoppingCartDTOHelper {


    public static ShoppingCartDTO fromEntityToDTO(ShoppingCartId shoppingCartId, Currency totalValue, List<ShoppingCartPositionDTO> shoppingCartPositions) {
        ShoppingCartDTO shoppingCartDTO = new ShoppingCartDTO();
        shoppingCartDTO.setId(shoppingCartId.getId());
        shoppingCartDTO.setTotalSellingPrice(totalValue.toString().strip());
        shoppingCartDTO.setPositions(shoppingCartPositions);
        return shoppingCartDTO;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\dto\ShoppingCartPositionDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.application.dto;


import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.util.UUID;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ShoppingCartPositionDTO {
    private UUID itemId;
    private Integer quantity;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\dto\ShoppingCartPositionDTOHelper.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.application.dto;

import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartPosition;

import java.util.ArrayList;
import java.util.List;

public class ShoppingCartPositionDTOHelper {

    public static ShoppingCartPositionDTO fromShoppingCartPosition(ShoppingCartPosition shoppingCartPosition){
        return new ShoppingCartPositionDTO(shoppingCartPosition.getItemId().getId(), shoppingCartPosition.getQuantity());
    }

    public static List<ShoppingCartPositionDTO> fromListOfShoppingCartPositions(List<ShoppingCartPosition> shoppingCartPositions){
        List<ShoppingCartPositionDTO> shoppingCartPositionDTOList = new ArrayList<>();
        for(ShoppingCartPosition each : shoppingCartPositions){
            shoppingCartPositionDTOList.add(fromShoppingCartPosition(each));
        }
        return shoppingCartPositionDTOList;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class ShoppingCartAdapterService implements ShoppingCartUseCases {

    private final ShoppingCartService shoppingCartService;
    @Autowired
    public ShoppingCartAdapterService(ShoppingCartService shoppingCartService) {
        this.shoppingCartService = shoppingCartService;
    }

    @Override
    public void addItemToShoppingCart(EmailType userEmail, UUID itemId, int quantityOf) {
        shoppingCartService.addItemToShoppingCart((Email) userEmail, new ItemId(itemId), quantityOf);
    }

    @Override
    public void removeItemFromShoppingCart(EmailType userEmail, UUID itemId, int quantityOf) {
        shoppingCartService.removeItemFromShoppingCart((Email) userEmail, new ItemId(itemId), quantityOf);
    }

    @Override
    public Map<UUID, Integer> getShoppingCartAsMap(EmailType userEmail) {
        Map<ItemId, Integer> shoppingCartAsMap = shoppingCartService.getShoppingCartAsMap((Email) userEmail);
        return shoppingCartAsMap.entrySet().stream()
                .collect(Collectors.toMap(entry -> entry.getKey().getId(), Map.Entry::getValue));

    }

    @Override
    public CurrencyType getShoppingCartAsCurrencyValue(EmailType userEmail) {
        return shoppingCartService.getShoppingCartAsCurrencyValue((Email) userEmail);
    }

    @Override
    public Set<UUID> checkout(EmailType userEmail) {
        return shoppingCartService.checkout((Email) userEmail);
    }

    @Override
    public void emptyAllShoppingCarts() {
        shoppingCartService.emptyAllShoppingCarts();
    }

    public ShoppingCart getShoppingCart(EmailType email){
        return shoppingCartService.getShoppingCart((Email) email);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartController.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.MethodNotAllowedException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.NotFoundException;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.order.application.OrderService;
import thkoeln.archilab.ecommerce.solution.order.application.dto.OrderDTO;
import thkoeln.archilab.ecommerce.solution.order.application.dto.OrderDTOHelper;
import thkoeln.archilab.ecommerce.solution.order.application.dto.OrderPositionDTOHelper;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
import thkoeln.archilab.ecommerce.solution.shoppingcart.application.dto.ShoppingCartDTO;
import thkoeln.archilab.ecommerce.solution.shoppingcart.application.dto.ShoppingCartDTOHelper;
import thkoeln.archilab.ecommerce.solution.shoppingcart.application.dto.ShoppingCartPositionDTO;
import thkoeln.archilab.ecommerce.solution.shoppingcart.application.dto.ShoppingCartPositionDTOHelper;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartId;
import thkoeln.archilab.ecommerce.solution.user.application.UserService;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.UUID;

@RestController
public class ShoppingCartController {

    private final ShoppingCartService shoppingCartService;
    private final UserService userService;
    private final OrderService orderService;

    @Autowired
    public ShoppingCartController(ShoppingCartService shoppingCartService,
                                  UserService userService,
                                  OrderService orderService){
        this.shoppingCartService = shoppingCartService;
        this.userService = userService;
        this.orderService = orderService;
    }

    @GetMapping("/shoppingCarts")
    public ResponseEntity<ShoppingCartDTO> getShoppingCart(
            @RequestParam(value="userId", required = false) String userId){
        if(userId==null) throw new MethodNotAllowedException("method not allowed");

        UserId newUserId;
        try {
            newUserId = new UserId(UUID.fromString(userId));
        } catch (IllegalArgumentException e) {
            throw new NotFoundException("Invalid UUID format for userId");
        }

        ShoppingCart shoppingCart = shoppingCartService.getOrCreateShoppingCart(newUserId);

        Currency totalValue = shoppingCartService.getShoppingCartAsCurrencyValue(shoppingCart);

        List<ShoppingCartPositionDTO> shoppingCartPositionDTOs = ShoppingCartPositionDTOHelper.
                fromListOfShoppingCartPositions(shoppingCart.getShoppingCartPositions());

        ShoppingCartDTO shoppingCartDTO = ShoppingCartDTOHelper.
                fromEntityToDTO(shoppingCart.getId(), totalValue, shoppingCartPositionDTOs);

        return ResponseEntity.ok(shoppingCartDTO);
    }


    @PostMapping("/shoppingCarts/{shoppingCartId}/positions")
    public ResponseEntity addShoppingCartPosition(@PathVariable UUID shoppingCartId,
                                                  @RequestBody ShoppingCartPositionDTO shoppingCartPositionDTO){
        shoppingCartService.addItemToShoppingCart(new ShoppingCartId(shoppingCartId),
                new ItemId(shoppingCartPositionDTO.getItemId()),
                shoppingCartPositionDTO.getQuantity());

        return new ResponseEntity<>(HttpStatus.CREATED);
    }

    @DeleteMapping("/shoppingCarts/{shoppingCartId}/positions/{itemId}")
    public ResponseEntity deleteShoppingCartPosition(@PathVariable UUID shoppingCartId,
                                                     @PathVariable UUID itemId){
        shoppingCartService.removeAllQuantityOfItemFromShoppingCart(new ShoppingCartId(shoppingCartId), new ItemId(itemId));
        return new ResponseEntity<>(HttpStatus.OK);
    }


    @PostMapping("shoppingCarts/{shoppingCartId}/checkout")
    public ResponseEntity checkoutShoppingCart(@PathVariable UUID shoppingCartId){
        ShoppingCartId newShoppingCartId = new ShoppingCartId(shoppingCartId);
        if(!shoppingCartService.checkExistence(newShoppingCartId)) throw new NotFoundException("ShoppingCart is not found");

        ShoppingCart shoppingCart = shoppingCartService.getShoppingCart(newShoppingCartId);
        UserId userId = shoppingCart.getUserId();
        String userName = userService.getUserName(userId);

        Set<UUID> orders = shoppingCartService.checkout(newShoppingCartId);

        List<OrderDTO> orderDTOS = new ArrayList<>();

        Order order = null;

        for(UUID each : orders){
            order = orderService.getOrderOrNull(new OrderId(each));
            if(order != null) {
                orderDTOS.add(
                        OrderDTOHelper.entityToOrderDto(
                                order,
                                OrderPositionDTOHelper.fromListOfOrderPositions(order.getOrderPositions()),
                                userName));
            }
        }
        return ResponseEntity
                .status(HttpStatus.CREATED)
                .body(orderDTOS);
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartDeletionService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.item.application.ShoppingCartDeletionInterface;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartPositionRepository;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartRepository;

@Service
public class ShoppingCartDeletionService implements ShoppingCartDeletionInterface {

    private final ShoppingCartPositionRepository shoppingCartPositionRepository;
    private final ShoppingCartRepository shoppingCartRepository;

    @Autowired
    public ShoppingCartDeletionService(ShoppingCartPositionRepository shoppingCartPositionRepository, ShoppingCartRepository shoppingCartRepository) {
        this.shoppingCartPositionRepository = shoppingCartPositionRepository;
        this.shoppingCartRepository = shoppingCartRepository;
    }

    public Boolean existsInAnyShoppingCart(ItemId itemId) {
        return shoppingCartPositionRepository.existsByItemId(itemId);
    }

    @Override
    public void deleteAll() {
        shoppingCartRepository.deleteAll();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.application;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.ConflictException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.InsufficientInventoryException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.NotFoundException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
import thkoeln.archilab.ecommerce.solution.item.application.ItemService;
import thkoeln.archilab.ecommerce.solution.item.domain.Item;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.order.application.OrderService;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartId;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartPosition;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartRepository;
import thkoeln.archilab.ecommerce.solution.storageunit.application.StorageUnitService;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnit;
import thkoeln.archilab.ecommerce.solution.user.application.UserService;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class ShoppingCartService {

    private final ShoppingCartRepository shoppingCartRepository;
    private final UserService userService;
    private final ItemService itemService;
    private final StorageUnitService storageUnitService;
    private final OrderService orderService;


    @Autowired
    public ShoppingCartService(ShoppingCartRepository shoppingCartRepository,
                               ItemService itemService, UserService userService,
                               StorageUnitService storageUnitService,
                               OrderService orderService) {
        this.shoppingCartRepository = shoppingCartRepository;
        this.userService = userService;
        this.itemService = itemService;
        this.storageUnitService = storageUnitService;
        this.orderService = orderService;
    }


    /**
     * Adds an item to the cart of a user
     * param userEmail
     * param itemId
     * param quantityOf
     * throws ShopException if ...
     *                       - userEmail is null or empty,
     *                       - the user with the given email does not exist,
     *                       - itemId is null,
     *                       - the item with itemId does not exist
     *                       - the Quantity is negative,
     */

    public void addItemToShoppingCart(Email userEmail, ItemId itemId, int quantityOf) {
        addItemToShoppingCart(getOrCreateShoppingCart(getUserId(userEmail)).getId(), itemId, quantityOf);
    }

    public void addItemToShoppingCart(ShoppingCartId shoppingCartId, ItemId itemId, int quantityOf){

        if (quantityOf <= 0) { throw new UnprocessableEntityException("Quantity is negative");}
        if(itemService.itemIdNotExisting(itemId)) {throw new NotFoundException("Item with the given id does not exist");}

        ShoppingCart shoppingCart = getShoppingCart(shoppingCartId);

        shoppingCart.addShoppingCartPosition(new ShoppingCartPosition(quantityOf, itemId));
        shoppingCartRepository.save(shoppingCart);
    }

    /**
     * Removes an item from the cart of a user
     * param userEmail
     * param itemId
     * param quantityOf
     * throws ShopException if ...
     *                       - userEmail is null or empty,
     *                       - the user with the given email does not exist,
     *                       - itemId is null,
     *                       - the item with itemId does not exist
     *                       - the Quantity is negative
     *                       - the item is not in the shopping cart in the requested Quantity
     */

    public void removeItemFromShoppingCart(Email userEmail, ItemId itemId, int quantityOf) {
        removeItemFromShoppingCart(getShoppingCart(getUserId(userEmail)).getId(), itemId, quantityOf);
    }

    public void removeItemFromShoppingCart(ShoppingCartId shoppingCartId, ItemId itemId, int quantityOf){
        if (quantityOf < 0)  throw new UnprocessableEntityException("Quantity is negative");
        if(itemService.itemIdNotExisting(itemId)) {throw new NotFoundException("Item with the given id does not exist");}

        ShoppingCart shoppingCart = getShoppingCart(shoppingCartId);
        shoppingCart.removeShoppingCartPosition(new ShoppingCartPosition(quantityOf, itemId));

        if (shoppingCart.getShoppingCartPositions().isEmpty())
            shoppingCartRepository.delete(shoppingCart);
        else
            shoppingCartRepository.save(shoppingCart);
    }

    public void removeAllQuantityOfItemFromShoppingCart(ShoppingCartId shoppingCartId, ItemId itemId){
        removeItemFromShoppingCart(shoppingCartId, itemId, getQuantityOfItemInShoppingCart(shoppingCartId, itemId));
    }

    public Integer getQuantityOfItemInShoppingCart(ShoppingCartId shoppingCartId, ItemId itemId){
        ShoppingCart shoppingCart = getShoppingCart(shoppingCartId);
        ShoppingCartPosition shoppingCartPosition = shoppingCart.getShoppingCartPositionOrNull(new ShoppingCartPosition(0, itemId));

        int quantity = 0;
        if(shoppingCartPosition != null) quantity = shoppingCartPosition.getQuantity();
        return quantity;
    }

    /**
     * Returns a map showing which items are in the cart of a user and how many of each item
     * param userEmail
     * return the cart of the user (map is empty if the cart is empty)
     * throws ShopException if
     *                       - the user with the given email does not exist
     */

    public Map<ItemId, Integer> getShoppingCartAsMap(Email userEmail) {
        return shoppingCartToMap(getOrCreateShoppingCart(getUserId(userEmail)));
    }

    protected Map<ItemId, Integer> shoppingCartToMap(ShoppingCart shoppingCart){
        return shoppingCart.getShoppingCartPositions().stream()
                .collect(Collectors.toMap(
                        ShoppingCartPosition::getItemId,
                        ShoppingCartPosition::getQuantity,
                        Integer::sum
                ));
    }

    /**
     * Returns the current value of all items in the cart of a user
     * param userEmail
     * return the cart of the user
     * throws ShopException if the user with the given email does not exist
     */
    public Currency getShoppingCartAsCurrencyValue(Email userEmail) {
        return getShoppingCartAsCurrencyValue(getShoppingCart(getUserId(userEmail)));
    }

    protected Currency getShoppingCartAsCurrencyValue(ShoppingCart shoppingCart){
        Map<ItemId, Integer> shoppingCartAsMap = shoppingCartToMap(shoppingCart);

        float totalValueFloat = 0F;
        for(Map.Entry<ItemId, Integer> entry : shoppingCartAsMap.entrySet()) {
            Item item = itemService.getItemById(entry.getKey());
            if(item != null) {
                totalValueFloat += item.getSellingPrice().getQuantity() * entry.getValue();
            }
        }
        return (Currency) Currency.of(totalValueFloat, "EUR");

    }
    /**
     * Checks out the cart of a user
     *
     * @param userEmail
     * @return A set of ids belonging to orders that were created during the checkout. If the shopping cart can
     *         only be served from more than one storage unit, each shipment from a storage unit gets a
     *         dedicated order. I.e. if there is just one shipment, then the set will contain just one order id.
     *         If there are multiple shipments, the set will contain multiple order ids.
     * @throws ShopException if
     *      - userEmail is null or empty
     *      - the user with the given email does not exist, or if the cart is empty
     * @throws
     *      - ShopException if userEmail is null
     *      - InsufficientInventoryException if there is not enough inventory level for to serve the order
     *        for all items in the shopping cart
     */


    public Set<UUID> checkout(Email userEmail) {
        return checkout(getShoppingCart(userEmail).getId());
    }


    protected Set<UUID> checkout(ShoppingCartId shoppingCartId) {
        ShoppingCart shoppingCart = getShoppingCart(shoppingCartId);
        if(shoppingCart.getShoppingCartPositions().isEmpty()) {throw new ConflictException("ShoppingCart is empty");}
        UserId userId = shoppingCart.getUserId();
        ZipCode zipCode = userService.getUserZipCodeOrNull(userId);
        Map<ShoppingCart, StorageUnit> virtualShoppingCarts = new HashMap<>();

        do {
            Map<ItemId, Integer> map = shoppingCartToMap(shoppingCart);

            StorageUnit bestStorageUnitId = storageUnitService.findBestStorageUnit(map, zipCode);
            if (bestStorageUnitId == null) throw new ConflictException("no storage Units found");

            ShoppingCart virtualShopCart = createVirtualShoppingCart(bestStorageUnitId, map, userId);
            if (virtualShopCart == null) {throw new InsufficientInventoryException("Not enough inventory in any storageUnit");}

            virtualShoppingCarts.put(virtualShopCart, bestStorageUnitId);
            shoppingCart.removeShoppingCartPositions(virtualShopCart.getShoppingCartPositions());
        } while (!shoppingCart.getShoppingCartPositions().isEmpty()) ;

        Set<UUID> orderings = new HashSet<>();
        for(Map.Entry<ShoppingCart, StorageUnit> each : virtualShoppingCarts.entrySet()){
            OrderId orderId = orderService.createOrder(shoppingCartToMap(each.getKey()),
                    each.getValue().getId(), userId);
            orderings.add(orderId.getId());
        }

        shoppingCartRepository.save(shoppingCart);
        return orderings;
    }

    private ShoppingCart createVirtualShoppingCart(StorageUnit storageUnit, Map<ItemId, Integer> map, UserId userid){

        ShoppingCart shoppingCart1 = new ShoppingCart(userid);

        for (Map.Entry<ItemId, Integer> each : map.entrySet()) {
            int available = storageUnitService.getAvailableInventory(storageUnit.getId(), each.getKey());
            int required = each.getValue();

            if (available >= required) {
                shoppingCart1.addShoppingCartPosition(new ShoppingCartPosition(required, each.getKey()));
            }
        }

        if(shoppingCart1.getShoppingCartPositions().isEmpty()) {return null;}
        return shoppingCart1;
    }

    public void emptyAllShoppingCarts() {
        shoppingCartRepository.findAll()
                .forEach(shoppingCart -> {
                    shoppingCart.getShoppingCartPositions().clear();
                    shoppingCartRepository.save(shoppingCart);
                });
    }

    protected ShoppingCart getOrCreateShoppingCart(UserId userId) {

        if(!userService.userExists(userId)) throw new NotFoundException("User does not exist");
        Optional <ShoppingCart> shoppingCart = shoppingCartRepository.findByUserId(userId);

        if (shoppingCart.isPresent()) return shoppingCart.get();
        else {
            ShoppingCart newShoppingCart = new ShoppingCart(userId);
            shoppingCartRepository.save(newShoppingCart);
            return newShoppingCart;
        }

    }

    public ShoppingCart getShoppingCart(UserId userId){
        if(userId == null) throw new NotFoundException("UserId is null");

        Optional <ShoppingCart> shoppingCart = shoppingCartRepository.findByUserId(userId);
        if (shoppingCart.isEmpty()) throw new NotFoundException("ShoppingCart is not found");
        return shoppingCart.get();
    }

    public ShoppingCart getShoppingCart(Email email){
        return getShoppingCart(getUserId(email));
    }

    public ShoppingCart getShoppingCart(ShoppingCartId shoppingCartId){
        Optional <ShoppingCart> shoppingCart = shoppingCartRepository.findById(shoppingCartId);
        if (shoppingCart.isEmpty()) throw new NotFoundException("ShoppingCart is not found");
        return shoppingCart.get();
    }

    public UserId getUserId(Email email){
        if(email == null || email.toString().isEmpty()) throw new UnprocessableEntityException("User email is null or empty");
        UserId userId = userService.getUserIdOrNullByEmail(email);
        if( userId == null) throw new NotFoundException("No UserId found for given Email");
        return userId;
    }

    public Boolean checkExistence(ShoppingCartId shoppingCartId){ return shoppingCartRepository.existsById(shoppingCartId);}

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCart.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.NotFoundException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.ArrayList;
import java.util.List;

@Entity
@Getter
@NoArgsConstructor
public class ShoppingCart {
    @Setter(AccessLevel.PRIVATE)    // only for JPA
    @EmbeddedId
    private ShoppingCartId id;

    @Setter
    @OneToMany(cascade= CascadeType.ALL, fetch= FetchType.EAGER, orphanRemoval = true)
    private List<ShoppingCartPosition> shoppingCartPositions;

    @Embedded
    private UserId userId;

    public ShoppingCart(UserId userId) {
        this.id = new ShoppingCartId();
        this.shoppingCartPositions = new ArrayList<>();
        this.userId = userId;
    }

    public void addShoppingCartPosition(ShoppingCartPosition shoppingCartPosition) {
        for(ShoppingCartPosition existingPosition : this.shoppingCartPositions) {
            if (existingPosition.getItemId().equals(shoppingCartPosition.getItemId())) {
                int newQuantity = existingPosition.getQuantity() + shoppingCartPosition.getQuantity();
                existingPosition.setQuantity(newQuantity);
                return;
            }
        }
        this.shoppingCartPositions.add(shoppingCartPosition);
    }

    public void removeShoppingCartPosition(ShoppingCartPosition shoppingCartPosition) {
        for(ShoppingCartPosition existingPosition : this.shoppingCartPositions) {
            if (existingPosition.getItemId().equals(shoppingCartPosition.getItemId())) {
                int newQuantity = existingPosition.getQuantity() - shoppingCartPosition.getQuantity();
                if (newQuantity > 0) {
                    existingPosition.setQuantity(newQuantity);
                } else if (newQuantity == 0) {
                    this.shoppingCartPositions.remove(existingPosition);
                }
                else {
                    throw new UnprocessableEntityException("quantity cannot be negative");
                }
                return;
            }
        }
        throw new NotFoundException("no shopping cart position found for item " + shoppingCartPosition.getItemId());
    }

    public void removeShoppingCartPositions(Iterable<ShoppingCartPosition> list){
        for(ShoppingCartPosition shoppingCartPosition : list){
            removeShoppingCartPosition(shoppingCartPosition);
        }
    }

    public ShoppingCartPosition getShoppingCartPositionOrNull(ShoppingCartPosition shoppingCartPosition){
        for(ShoppingCartPosition shoppingCartPosition1 : this.shoppingCartPositions){
            if( shoppingCartPosition1.getItemId().equals(shoppingCartPosition.getItemId()))
                return shoppingCartPosition1;
        }
        return null;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartId.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "shoppingCart_id"))
public class ShoppingCartId extends GenericId {
    public ShoppingCartId(UUID id ) {
        super( id );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ShoppingCartIdConverter extends GenericIdConverter<ShoppingCartId> {
    public ShoppingCartIdConverter() {
        super(ShoppingCartId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPosition.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;

import jakarta.persistence.Embedded;
import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;

@Entity
@Getter
@NoArgsConstructor
public class ShoppingCartPosition {
    @Setter(AccessLevel.PRIVATE)    // only for JPA
    @EmbeddedId
    private ShoppingCartPositionId id;
    private Integer quantity;


    @Embedded
    private ItemId itemId;

    public ShoppingCartPosition(Integer quantity, ItemId itemId) {
        this.id = new ShoppingCartPositionId();
        setQuantity(quantity);
        this.itemId = itemId;
    }

    public void setQuantity(Integer quantity) {
        if (quantity < 0) {
            throw new UnprocessableEntityException("Quantity cannot be negative");
        }
        this.quantity = quantity;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPositionId.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "shoppingCartPosition_id"))
public class ShoppingCartPositionId extends GenericId {
    public ShoppingCartPositionId(UUID id ) {
        super( id );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPositionIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ShoppingCartPositionIdConverter extends GenericIdConverter<ShoppingCartPositionId> {
    public ShoppingCartPositionIdConverter() {
        super(ShoppingCartPositionId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPositionRepository.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;

@Repository
public interface ShoppingCartPositionRepository extends CrudRepository<ShoppingCartPosition, ShoppingCartPositionId> {
    Boolean existsByItemId(ItemId itemId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartRepository.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.Optional;

@Repository
public interface ShoppingCartRepository extends CrudRepository<ShoppingCart, ShoppingCartId> {
    Optional<ShoppingCart> findByUserId(UserId userId);
  }


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\InventoryLevelDeletionService.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.item.application.InventoryLevelDeletionInterface;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.InventoryLevel;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnit;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitRepository;

@Service
public class InventoryLevelDeletionService implements InventoryLevelDeletionInterface {

    private final StorageUnitRepository storageUnitRepository;

    @Autowired
    public InventoryLevelDeletionService( StorageUnitRepository storageUnitRepository) {
        this.storageUnitRepository = storageUnitRepository;
    }

    public Boolean existsInAnyInventoryLevel(ItemId itemId) {
        for (StorageUnit storageUnit : storageUnitRepository.findAll()) {
            for (InventoryLevel inventoryLevel : storageUnit.getInventoryLevels()) {
                if (inventoryLevel.getItemId().equals(itemId)) {
                    return true;
                }
            }
        }
        return false;
    }

    public void deleteAllInventoryLevels() {
        for(StorageUnit storageUnit : storageUnitRepository.findAll()){
            storageUnit.setInventoryLevels(null);
            storageUnitRepository.save(storageUnit);
        }
    }



    // TODO() FRAGE: Dürfte das oder MUSS ich über StorageUnit gehen? AggretateRoot...
    //public Boolean existByItemId(ItemId itemId) {
    //    return inventoryLevelRepository.existsByItemId(itemId);
    //}
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\StorageUnitAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.application;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;

import java.util.UUID;

@Service
public class StorageUnitAdapterService implements StorageUnitUseCases {

    private final StorageUnitService storageUnitService;

    @Autowired
    public StorageUnitAdapterService(StorageUnitService storageUnitService) {
        this.storageUnitService = storageUnitService;
    }



    @Override
    public UUID addNewStorageUnit(String name, AddressType address) {
        return storageUnitService.addNewStorageUnit(name, (Address) address).getId();
    }

    @Override
    public void deleteAllStorageUnits() {
        storageUnitService.deleteAllStorageUnits();
    }


    @Override
    public void addToInventory(UUID storageUnitId, UUID itemId, int addedQuantityOf) {
        storageUnitService.addToInventory(new StorageUnitId(storageUnitId), new ItemId(itemId), addedQuantityOf);
    }

    @Override
    public void removeFromInventory(UUID storageUnitId, UUID itemId, int removedQuantityOf) {
        storageUnitService.removeFromInventory(new StorageUnitId(storageUnitId), new ItemId(itemId), removedQuantityOf);
    }


    @Override
    public void changeInventoryTo(UUID storageUnitId, UUID itemId, int newTotalQuantityOf) {
        storageUnitService.changeInventoryTo(new StorageUnitId(storageUnitId), new ItemId(itemId), newTotalQuantityOf);
    }

    @Override
    public int getAvailableInventory(UUID storageUnitId, UUID itemId) {
        return storageUnitService.getAvailableInventory(new StorageUnitId(storageUnitId), new ItemId(itemId));
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\StorageUnitService.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.NotFoundException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
import thkoeln.archilab.ecommerce.solution.item.application.ItemService;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.*;

import java.util.List;
import java.util.Map;


@Service
public class StorageUnitService {

    private final StorageUnitRepository storageUnitRepository;
    private final ItemService itemService;

    @Autowired
    public StorageUnitService(StorageUnitRepository storageUnitRepository, ItemService itemService) {
        this.storageUnitRepository = storageUnitRepository;
        this.itemService = itemService;
    }


    public StorageUnitId addNewStorageUnit(String name, Address address) {

        validateShopDetails(name, address);
        StorageUnit storageUnit = new StorageUnit(name, address);
        storageUnitRepository.save(storageUnit);
        return storageUnit.getId();
    }


    public void deleteAllStorageUnits() {storageUnitRepository.deleteAll();}


    public void addToInventory(StorageUnitId storageUnitId, ItemId itemId, int addedQuantityOf) {
        if( addedQuantityOf < 0) throw new UnprocessableEntityException("Quantity cannot be negative");

        if(!storageUnitRepository.existsById(storageUnitId) ) {
            throw new NotFoundException("No suitable storage unit found for the given id");
        }
        StorageUnit storageUnit = storageUnitRepository.findById(storageUnitId).get();

        if(itemService.itemIdNotExisting(itemId)) throw new NotFoundException("ItemId ist not existing");

        storageUnit.addInventoryLevel(new InventoryLevel(itemId, addedQuantityOf));
        storageUnitRepository.save(storageUnit);
    }


    public void removeFromInventory(StorageUnitId storageUnitId, ItemId itemId, int removedQuantityOf) {
        if(removedQuantityOf < 0) throw new UnprocessableEntityException("Quantity cannot be negative");

        if(!storageUnitRepository.existsById(storageUnitId) ) {
            throw new NotFoundException("No storage unit found for the given id");
        }
        if(itemService.itemIdNotExisting(itemId)) throw new NotFoundException("ItemId is not existing");


        StorageUnit storageUnit = storageUnitRepository.findById(storageUnitId).get();

        storageUnit.removeInventoryLevel(new InventoryLevel(itemId, removedQuantityOf));
        storageUnitRepository.save(storageUnit);
    }


    public void changeInventoryTo(StorageUnitId storageUnitId, ItemId itemId, int newTotalQuantityOf) {
        validateStorageUnitExistenceById(storageUnitId);
        if(itemService.itemIdNotExisting(itemId)){
            throw new NotFoundException("Item with the given id does not exist");
        }
        if(newTotalQuantityOf < 0) throw new UnprocessableEntityException("Quantity cannot be negative");

        StorageUnit storageUnit = storageUnitRepository.findById(storageUnitId).get();
        storageUnit.changeInventoryLevel(new InventoryLevel(itemId, newTotalQuantityOf));

        storageUnitRepository.save(storageUnit);
    }


    public int getAvailableInventory(StorageUnitId storageUnitId, ItemId itemId) {
        validateStorageUnitExistenceById(storageUnitId);
        if(itemService.itemIdNotExisting(itemId)){
            throw new NotFoundException("Item with the given id does not exist");
        }
        StorageUnit storageUnit = storageUnitRepository.findById(storageUnitId).get();
        for(InventoryLevel inventoryLevel : storageUnit.getInventoryLevels()){
            if(inventoryLevel.getItemId().equals(itemId)){
                return inventoryLevel.getQuantity();
            }
        }
        return 0;
    }

    public StorageUnit findBestStorageUnit(Map<ItemId, Integer> map, ZipCode zipcode){
        StorageUnitComparator comparator = new StorageUnitComparator(map, zipcode);

        List<StorageUnit> storageUnits = (List<StorageUnit>) storageUnitRepository.findAll();
        storageUnits.sort(comparator);
        if(storageUnits.isEmpty()){
            return null;
        } else return storageUnits.getLast();
    }

/**
 * Validation methods
 *
 * @throws ShopException if ...
 *      - name, street, city are null or empty
 *      - zipCode is null, empty, or not a valid zip code
 *      - fromZipCodeFirstDigit is null, or not between 0 und 9
 *      - toZipCodeFirstDigit is null, >9, or < fromZipCodeFirstDigit
 */


private void validateShopDetails(String name, Address address) {
    if(address == null) {
        throw new ShopException("Address cannot be null");
    }
    validateNotEmpty(name, "Name");
    validateNotEmpty(address.getStreet(), "Street");
    validateNotEmpty(address.getCity(), "City");
    validateZipCodeLength(address.getZipCode().toString());
}

private void validateNotEmpty(String value, String fieldName) {
    if (value == null || value.isEmpty()) {
        throw new UnprocessableEntityException(fieldName + " cannot be null or empty");
    }
}

private void validateZipCodeLength(String zipCode) {
    if (zipCode == null || zipCode.length() != 5) {
        throw new UnprocessableEntityException("Invalid zip code");
    }
}


private void validateStorageUnitExistenceById(StorageUnitId storageUnitId) {
    if (storageUnitId == null) {
        throw new UnprocessableEntityException("Storage unit ID cannot be null");
    }
    if (!storageUnitRepository.existsById(storageUnitId)) {
        throw new NotFoundException("Storage unit with ID " + storageUnitId + " does not exist");
    }
}


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\InventoryLevel.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;


import jakarta.persistence.Embedded;
import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;


// nicht immer setter !!

@Getter
@Entity
@NoArgsConstructor
public class InventoryLevel {
    @Setter(AccessLevel.PRIVATE)    // only for JPA
    @EmbeddedId
    private InventoryLevelId id;

    private Integer quantity;

    @Embedded
    private ItemId itemId;

    public InventoryLevel(ItemId itemId, Integer quantity) {
        this.itemId = itemId;
        this.quantity = quantity;
        this.id = new InventoryLevelId();
    }

    public void setQuantity(Integer quantity) {
        if (quantity < 0) {
            throw new IllegalArgumentException("Quantity cannot be negative");
        }
        this.quantity = quantity;
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\InventoryLevelId.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "inventoryLevel_id"))
public class InventoryLevelId extends GenericId {
    public InventoryLevelId(UUID id ) {
        super( id );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\InventoryLevelIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class InventoryLevelIdConverter extends GenericIdConverter<InventoryLevelId> {
    public InventoryLevelIdConverter() {
        super(InventoryLevelId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\InventoryLevelRepository.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;

@Repository
public interface InventoryLevelRepository extends CrudRepository<InventoryLevel, InventoryLevelId> {
    Boolean existsByItemId(ItemId itemId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnit.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;

import jakarta.persistence.*;
import lombok.*;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.NotFoundException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

@Getter
@Entity
@NoArgsConstructor
@ToString
public class StorageUnit {
    @Setter(AccessLevel.PRIVATE)    // only for JPA
    @EmbeddedId
    private StorageUnitId id;
    private String name;

    @Embedded
    private Address address;

    @Setter
    @OneToMany(cascade= CascadeType.ALL, fetch= FetchType.EAGER, orphanRemoval = true)
    private List<InventoryLevel> inventoryLevels;

    public StorageUnit(String name, Address address) {
        this.id = new StorageUnitId();
        this.name = name;
        this.address = address;
        this.inventoryLevels = new ArrayList<>();
    }

    public void addInventoryLevel(InventoryLevel inventoryLevelToAdd) {
        for (InventoryLevel existingLevel : this.inventoryLevels) {
            if (existingLevel.getItemId().equals(inventoryLevelToAdd.getItemId())) {
                int newQuantity = existingLevel.getQuantity() + inventoryLevelToAdd.getQuantity();
                existingLevel.setQuantity(newQuantity);
                return;
            }
        }
        this.inventoryLevels.add(inventoryLevelToAdd);
    }


    public void removeInventoryLevel(InventoryLevel inventoryLevelToRemove) {
        for (InventoryLevel existingLevel : this.inventoryLevels) {
            if (existingLevel.getItemId().equals(inventoryLevelToRemove.getItemId())) {
                int newQuantity = existingLevel.getQuantity() - inventoryLevelToRemove.getQuantity();
                if (newQuantity > 0) {
                    existingLevel.setQuantity(newQuantity);
                } else if (newQuantity == 0) {
                    this.inventoryLevels.remove(existingLevel);
                } else {
                    throw new UnprocessableEntityException("quantity cannot be negative");
                }
                return;
            }
        }
        if(inventoryLevelToRemove.getQuantity() != 0) throw new NotFoundException("Item not found in inventory");
    }

    public void changeInventoryLevel(InventoryLevel updatedInventoryLevel) {
        for (InventoryLevel inventoryLevel : this.inventoryLevels) {
            if (inventoryLevel.getItemId().equals(updatedInventoryLevel.getItemId())) {
                inventoryLevel.setQuantity(updatedInventoryLevel.getQuantity());
                return;
            }
        }
        this.inventoryLevels.add(updatedInventoryLevel);
    }

    public Set<ItemId> fulfillableShoppingCartPositions(Map<ItemId, Integer> itemQuantityMap ){
        Set<ItemId> fulfillableItems = new java.util.HashSet<>(Set.of());

        for (InventoryLevel inventoryLevel : this.inventoryLevels) {
            ItemId itemId = inventoryLevel.getItemId();
            if (itemQuantityMap.containsKey(itemId)) {
                if(inventoryLevel.getQuantity() >= itemQuantityMap.get(itemId)) {
                    fulfillableItems.add(itemId);
                }
            }
        }
        return fulfillableItems;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitComparator.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;

import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;

import java.util.Comparator;
import java.util.Map;

public class StorageUnitComparator implements Comparator<StorageUnit>{

    private final Map<ItemId, Integer> itemQuantityMap;
    private final ZipCode otherZipCode;

    public StorageUnitComparator(Map<ItemId, Integer> itemQuantityMap, ZipCode otherZipCode) {
        this.itemQuantityMap = itemQuantityMap;
        this.otherZipCode = otherZipCode;
    }

    @Override
    public int compare(StorageUnit o1, StorageUnit o2) {
        int diff = o1.fulfillableShoppingCartPositions(itemQuantityMap).size() - o2.fulfillableShoppingCartPositions(itemQuantityMap).size();
        int fst = Integer.compare(diff, 0);
        if( fst != 0){
            return fst;
        } else {
            int zipfst = otherZipCode.difference((ZipCode) o1.getAddress().getZipCode());
            int zipsec = otherZipCode.difference((ZipCode) o2.getAddress().getZipCode());
            return Integer.compare(zipsec, zipfst);
        }
    }
}






--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitId.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "storageUnit_id"))
public class StorageUnitId extends GenericId {
    public StorageUnitId(UUID id ) {
        super( id );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class StorageUnitIdConverter extends GenericIdConverter<StorageUnitId> {
    public StorageUnitIdConverter() {
        super(StorageUnitId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitRepository.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface StorageUnitRepository extends CrudRepository<StorageUnit, StorageUnitId> {
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;


@Service
public class UserAdapterService implements UserRegistrationUseCases {

    private final UserService userService;

    @Autowired
    public UserAdapterService(UserService userService) {
        this.userService = userService;
    }

    @Override
    public void register(String name, EmailType email, AddressType address) {
        userService.register(name, (Email) email, (Address) address);
    }

    @Override
    public void changeAddress(EmailType userEmail, AddressType address) {
        userService.changeAddress((Email) userEmail, (Address) address);
    }

    @Override
    public UserType getUserData(EmailType userEmail) {
        return userService.getUserData((Email) userEmail);
    }

    @Override
    public void deleteAllUsers() {
        userService.deleteAllUsers();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserController.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.MethodNotAllowedException;
import thkoeln.archilab.ecommerce.solution.user.domain.User;

@RestController
public class UserController {

    private final UserService userService;

    @Autowired
    public UserController(UserService userService){
        this.userService = userService;
    };

    /**
     *
     * Decide how to deal with error handling and HTTP status codes.
     * The two options are explained in this infopage.
     * If you choose lean controller methods and annotions of exceptions,
     * you need to created dedicated exceptions for the main HTTP error codes
     * (404 Not Found, 409 Conflict, 422 Unprocessable)
     * You can place these new exceptions in the domainprimitive package
     * In your code, you need to start replacing the generic ShopException by the dedicated exceptions
     */

    @GetMapping("/users")
    public ResponseEntity<UserDTO>getUserByEmail(@RequestParam(value = "email", required = false) Email email){
        if(email==null) throw new MethodNotAllowedException("method not allowed");
        User user = userService.getUserData(email);
        ModelMapper modelMapper = new ModelMapper();
        return new ResponseEntity<>(modelMapper.map(user, UserDTO.class), HttpStatus.OK);
    }



}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserDTO.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.domainprimitives.Email;

import java.util.UUID;

@Getter
@Setter
public class UserDTO {

    private UUID id;
    private String name;
    private Email email;
    private Address address;

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserService.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.ConflictException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.NotFoundException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
import thkoeln.archilab.ecommerce.solution.item.application.OrderDeletionInterface;
import thkoeln.archilab.ecommerce.solution.item.application.ShoppingCartDeletionInterface;
import thkoeln.archilab.ecommerce.solution.user.domain.User;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;

@Service
public class UserService {

    private final UserRepository userRepository;
    private final OrderDeletionInterface orderDeletionInterface;
    private final ShoppingCartDeletionInterface shoppingCartDeletionInterface;

    @Autowired
    public UserService(UserRepository userRepository,
                       OrderDeletionInterface orderDeletionInterface,
                       ShoppingCartDeletionInterface shoppingCartDeletionInterface) {
        this.userRepository = userRepository;
        this.orderDeletionInterface = orderDeletionInterface;
        this.shoppingCartDeletionInterface = shoppingCartDeletionInterface;
    }
    /**
     * Registers a new user
     * param name
     * param email
     * param street
     * param city
     * param zipCode
     * throws ShopException if ...
     *                       - user with the given email already exists
     *                       - if the data are invalid (name, email, street, city, zipCode empty or null,
     *                       zipCode is not a valid zip code)
     */

    public void register(String name, Email email, Address address) {
        if( address == null ) {
            throw new ShopException("Address cannot be null");
        }
        if(email == null) {
            throw new ShopException("Email cannot be null");
        }
        User.validateNotEmptyOrNull(email.toString(), "email");
        User.validateNotEmptyOrNull(name, "name");
        User.validateNotEmptyOrNull(address.getStreet(), "street");
        User.validateNotEmptyOrNull(address.getCity(), "city");
        User.validateNotEmptyOrNull(address.getZipCode().toString(), "zipCode");
        if(ZipCode.isZipCodeValid(address.getZipCode().toString()) == false) {
            throw new UnprocessableEntityException("Invalid zip code");
        }
        if(userRepository.existsByEmail(email)) {
            throw new ConflictException("User with email already exists");
        }
        User user = new User(name, email, address);
        userRepository.save(user);
    }

    /**
     * Changes the address of a user
     * param userEmail
     * param street
     * param city
     * param zipCode
     * throws ShopException if ...
     *                       - the user with the given email does not exist,
     *                       - the address data are invalid (street, city, zipCode empty, null or not a valid zip code)
     */

    public void changeAddress(Email userEmail, Address address) {
        if(address == null) {
            throw new ShopException("Address is null");
        }
        User.validateNotEmptyOrNull(address.getStreet(), "street");
        User.validateNotEmptyOrNull(address.getCity(), "city");
        User.validateNotEmptyOrNull(address.getZipCode().toString(), "zipCode");
        if(ZipCode.isZipCodeValid(address.getZipCode().toString()) == false) {
            throw new UnprocessableEntityException("Invalid zip code");
        }

        User user = userRepository.findByEmail(userEmail);
        if(user == null) {
            throw new NotFoundException("User with email does not exist");
        }
        user.setAddress(address);
        userRepository.save(user);
    }

    /**
     * Returns the data of a user as an array of strings (name, email, street, city, zipCode)
     * param userEmail
     * return the user data
     * throws ShopException if the user with the given email does not exist
     */

    public User getUserData(Email userEmail) {
        User user = userRepository.findByEmail(userEmail);
        if(user == null) {
            throw new NotFoundException("User with email does not exist");
        }
        return user;
    }

    /**
     * Clears all users, including all orders and shopping carts
     */
    public void deleteAllUsers() {
        shoppingCartDeletionInterface.deleteAll();
        orderDeletionInterface.deleteAll();
        userRepository.deleteAll();
    }



    public UserId getUserIdOrNullByEmail(Email email) {
        if(userRepository.existsByEmail(email)) {
            return userRepository.findByEmail(email).getId();
        } else {
            return null;
        }
    }




    public ZipCode getUserZipCodeOrNull(UserId userId) {
        if(userRepository.existsById(userId)){
            return (ZipCode) userRepository.findById(userId).get().getAddress().getZipCode();
        }
        return null;
    }


    public Boolean userExists(UserId userId) {
        return userRepository.existsById(userId);
    }


    public String getUserName(UserId userId){
        if(!userExists(userId)) throw new NotFoundException("User is does not exist");
        return userRepository.findById(userId).get().getName();
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\User.java ---
package thkoeln.archilab.ecommerce.solution.user.domain;


import jakarta.persistence.Embedded;
import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.*;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
import thkoeln.archilab.ecommerce.usecases.UserType;


@Entity
@ToString
@Getter
@Setter
@NoArgsConstructor
@Table(name = "app_user")
public class User implements UserType {
    @Setter(AccessLevel.PRIVATE)    // only for JPA
    @EmbeddedId
    private UserId id;

    @Embedded
    private Email email;

    private String name;

    @Embedded
    private Address address;

    public User(String name, Email email, Address address) {
        this.id = new UserId();
        this.name = name;
        this.email = email;
        this.address = address;
    }

    public static void validateNotEmptyOrNull(String value, String fieldName) {
        if (value == null || value.trim().isEmpty()) {
            throw new UnprocessableEntityException(fieldName + " darf nicht leer oder null sein.");
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserId.java ---
package thkoeln.archilab.ecommerce.solution.user.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "user_id"))
public class UserId extends GenericId {
    public UserId(UUID id ) {
        super( id );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.user.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class UserIdConverter extends GenericIdConverter<UserId> {
    public UserIdConverter() {
        super(UserId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserRepository.java ---
package thkoeln.archilab.ecommerce.solution.user.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.domainprimitives.Email;


@Repository
public interface UserRepository extends CrudRepository<User, UserId> {
    Boolean existsByEmail(Email email);
    User findByEmail(Email email);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\AddressType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface AddressType {
    /**
     * @return the street as a string
     */
    public String getStreet();

    /**
     * @return the city as a string
     */
    public String getCity();

    /**
     * @return the zip code
     */
    public ZipCodeType getZipCode();

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an zip code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param street the street as a string
     * @param city the city as a string
     * @param zipCode the zip code
     * @return the address object matching the parameters
     * @throws ShopException if ...
     *      - street is null or empty
     *      - city is null or empty
     *      - zipCode is null
     */
     // public static AddressType of( String street, String city, ZipCodeType zipCode );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\CurrencyType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface CurrencyType {
    /**
     * @return the quantity of currency
     */
    public Float getQuantity();


    /**
     * @return the currency unit of the currency
     */
    public String getCurrencyUnit();


    /**
     * @param otherCurrency
     * @return this + otherCurrency, as a new object
     * @throws ShopException if ...
     *      - otherCurrency is null
     *      - otherCurrency.currencyUnit != this.currencyUnit
     */
    public CurrencyType add( CurrencyType otherCurrency );


    /**
     * @param otherCurrency
     * @return this - otherCurrency, as a new object
     * @throws ShopException if ...
     *      - otherCurrency is null
     *      - otherCurrency.currencyUnit != this.currencyUnit
     *      - otherCurrency > this
     */
    public CurrencyType subtract( CurrencyType otherCurrency );


    /**
     * @param factor
     * @return this * factor, as a new object
     * @throws ShopException if ...
     *     - factor < 0
     */
    public CurrencyType multiplyBy( int factor );

    /**
     * @param otherCurrency
     * @return true, if this > otherCurrency
     * @throws ShopException if ...
     *      - otherCurrency is null
     *      - otherCurrency.currencyUnit != this.currencyUnit
     */
    public boolean largerThan( CurrencyType otherCurrency );


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates a currency object from an quantity and a currency unit (as string).
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param quantity the quantity of currency (must be >= 0)
     * @param currencyUnit the currency unit of the currency (allowed values: "EUR", "CHF")
     * @return a new Currency object with the given quantity and currency unit
     * @throws ShopException if ...
     *   - quantity is null
     *   - quantity < 0
     *   - currency unit is null
     *   - currency unit is not one of the allowed values
     */
     // public static CurrencyType of( Float quantity, String currencyUnit );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\EmailType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface EmailType {
    /**
     * @return the email as a string
     */
    public String toString();


    /**
     * A special kind of "copy constructor": Returns a new email object with
     * the same identifyer (the substring left of the "@" sign) as the current one, but
     * with a new domain substring (right of the "@" sign).
     * @param domainString - the new domain for the copied email
     * @return the new email
     * @throws ShopException if ...
     *     - domainString is null
     *     - the new email would not be valid (see `of(...)` method)
     */
    public EmailType sameIdentifyerDifferentDomain( String domainString );

    /**
     * Another special kind of "copy constructor": Returns a new email object
     * with the same domain (the substring right of the "@" sign) as the current one, but
     * with a new identifyer substring (left of the "@" sign).
     * @param identifyerString - the new identifyer for the copied email
     * @return the new email
     * @throws ShopException if ...
     *     - identifyerString is null
     *     - the new email would not be valid (see `of(...)` method)
     */
    public EmailType sameDomainDifferentIdentifyer( String identifyerString );


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an email, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param emailAsString - the email as a string.
     *      We will use a much simplified validation method to check if the email is valid:
     *      - it must contain exactly one '@' character.
     *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
     *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
     *      - the substrings before and after the '@' may contain one or several '.' as separators
     *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
     *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
     *        (for simplicity we do not allow any other domains)
     * @return a new EmailType object matching the given email
     * @throws ShopException if ...
     *      - emailAsString is null
     *      - emailAsString is not a valid email (see above)
     */
     // public static EmailType of( String emailAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\ZipCodeType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import com.fasterxml.jackson.annotation.JsonIgnore;
import thkoeln.archilab.ecommerce.ShopException;

public interface ZipCodeType {
    /**
     * @return the zip code as a string
     */
    public String toString();

    /**
     * You will need some idea of "imprecise difference" between two zip codes for properly
     * implementing storage units in your shopping platform. This method calculates such a
     * difference. You can decide for yourself what values you return, unless you comply
     * with the following rules.
     * - The return value is 0 if both zip codes are the same
     * - If not:
     *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
     *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
     *        So, 56733 and 56734 have the same difference as 56733 and 56739.
     *      - The difference grows if more digits (counted from the right side) differ.
     *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
     *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
     *        53876 and 54876 have the same difference as 53876 and 57261.
     *      - However, the difference between 5abcd and 6rstu must be smaller than the one
     *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
     *        one between 5abcd and 9rstu.
     *      - This last condition reflects the fact the first digits of a zip code marks a region
     *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
     *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
     *        other.
     * @param otherZipCode
     * @return the calculated difference
     * @throws ShopException if otherZipCode is null
     */
    public int difference( ZipCodeType otherZipCode );


    /**
     * For the currently used way of deciding on the best fitting storage unit for a order,
     * we need to know the first digit of the zip code.
     */
    @JsonIgnore
    public Integer getFirstDigitZipCode();


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an zip code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param zipCodeAsString - the zip code as a string.
     *      We will use a much simplified validation method to check if the zip code is valid:
     *      - It must contain exactly 5 digits.
     *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid zip code, but 20001 is valid)
     * @return a new zip code object matching the given string
     * @throws ShopException if ...
     *      - zipCodeAsString is null
     *      - zipCodeAsString is not a valid zip code (see above)
     */
     // public static ZipCodeType of( String zipCodeAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\ItemCatalogUseCases.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

import java.util.UUID;


/**
 * This interface contains methods needed in the context of use cases concerning the item catalog.
 * The interface is probably incomplete, and will grow over time ...
 */

public interface ItemCatalogUseCases {
    /**
     * Adds a new item to the shop catalog
     * @param name
     * @param descriptOf
     * @param size
     * @param buyingPrice
     * @param sellingPrice
     * @return the id of the new item
     * @throws ShopException if ...
     *      - the item id already exists,
     *      - name or description are null or empty,
     *      - the size is <= 0 (but can be null!),
     *      - the buying price is null or <= 0,
     *      - the buyingPrice is null,
     *      - the selling price is null,
     *      - the selling price is lower than the buyingPrice
     */
    public UUID addItemToCatalog( String name, String descriptOf, Float size,
                                           CurrencyType buyingPrice, CurrencyType sellingPrice );


    /**
     * Removes a item from the shop catalog
     * @param itemId
     * @throws ShopException if
     *      - itemId is null
     *      - the item id does not exist
     *      - the item is still in inventory
     *      - the item is still in a shopping cart, or referenced by a completed order
     */
    public void removeItemFromCatalog( UUID itemId );


    /**
     * Get the selling price of a given item
     * @param itemId
     * @return the selling price
     * @throws ShopException if ...
     *      - itemId is null,
     *      - the item with that id does not exist
     */
    public CurrencyType getSellingPrice( UUID itemId );


    /**
     * Clears the item catalog, i.e. removes all items from the catalog, including all the inventory,
     * all the reservations and all the orders.
     */
    public void deleteItemCatalog();

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.Enumeration;

import static org.junit.jupiter.api.Assertions.*;

public class FactoryMethodInvoker {

    public static EmailType instantiateEmail( String emailAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for EmailType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, emailAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + emailAsString + "'", e );
        }
        assertNotNull( instance );
        return (EmailType) instance;
    }


    public static AddressType instantiateAddress(
            String street, String city, ZipCodeType zipCode ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of",
                    String.class, String.class, ZipCodeType.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for AddressType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, street, city, zipCode );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" +
                    street + "', '" + city + "', '" + zipCode + "'", e );
        }
        assertNotNull( instance );
        return (AddressType) instance;
    }


    public static ZipCodeType instantiateZipCode( String zipCodeAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for ZipCodeType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, zipCodeAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + zipCodeAsString + "'", e );
        }
        assertNotNull( instance );
        return (ZipCodeType) instance;
    }


    public static CurrencyType instantiateCurrency( Float quantity, String currencyUnit ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for CurrencyType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, quantity, currencyUnit );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + quantity + "', '" + currencyUnit + "'", e );
        }
        assertNotNull( instance );
        return (CurrencyType) instance;
    }


    private static Class<?> findImplementation( Class<?> interfaceClass ) {
        Method factoryMethod = null;
        try {
            String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
            Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
            assertNotNull( implementingClass );
            return implementingClass;
        } catch (Exception e) {
            fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
            return null; // This line will never be reached, but it's necessary to satisfy the compiler
        }
    }


    private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
            throws ClassNotFoundException, IOException {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        String path = packageName.replace( '.', '/' );
        Enumeration<URL> resources = classLoader.getResources( path );
        int count = 0;
        Class<?> result = null;
        while (resources.hasMoreElements()) {
            URL resource = resources.nextElement();
            File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
            File[] files = directory.listFiles();
            for ( File file : files ) {
                if ( file.getName().endsWith( ".class" ) ) {
                    String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
                    Class<?> clazz = Class.forName( className );
                    if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
                        count++;
                        result = clazz;
                    }
                }
            }
        }
        assertEquals( 1, count, "There should be exactly one implementing class" );
        return result;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\InventoryTestHelperImpl.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;

import java.util.*;

/**
 * This is a test helper class that initializes and registers items (but without inventory)
 * in the system, using the given interface(s).
 */
@Component
@SuppressWarnings("PMD")
public class InventoryTestHelperImpl
                        implements ItemTestHelper, StorageUnitTestHelper {
    private ItemCatalogUseCases itemCatalogUseCases;
    private StorageUnitUseCases storageUnitUseCases;
    private static Random random = new Random();

    private static final String EUR = "EUR";
    private static final int ITEM_NUMOF = 15;
    private static final Object[][] ITEM_DATA = new Object[][]{
            {null, "0-TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
                    1.5f, FactoryMethodInvoker.instantiateCurrency( 5.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 10.0f, EUR ),
                    "0"},
            {null, "1-EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
                    0.3f, FactoryMethodInvoker.instantiateCurrency( 2.5f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 4.0f, EUR ),
                    "0"},
            {null, "2-MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
                    7.2f, FactoryMethodInvoker.instantiateCurrency( 50.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 80.0f, EUR ),
                    "0"},
            {null, "3-Gh-25", "Kompakter und leichter Akku für mobile Geräte",
                    null, FactoryMethodInvoker.instantiateCurrency( 6.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 8.0f, EUR ),
                    "0"},
            {null, "4-MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
                    null, FactoryMethodInvoker.instantiateCurrency( 0.6f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 1.0f, EUR ),
                    "0"},
            {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
                    1.0f, FactoryMethodInvoker.instantiateCurrency( 150.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 250.0f, EUR ),
                    "0"},
            {null, "6-Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
                    null, FactoryMethodInvoker.instantiateCurrency( 0.3f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 0.5f, EUR ),
                    "0"},
            {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
                    6.0f, FactoryMethodInvoker.instantiateCurrency( 80.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 120.0f, EUR ),
                    "123"},
            {null, "8-JKL-67", "Wasserdichtes Gehäuse",
                    3.0f, FactoryMethodInvoker.instantiateCurrency( 1.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 1.2f, EUR ),
                    "467"},
            {null, "9-MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
                    5.5f, FactoryMethodInvoker.instantiateCurrency( 25.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 45.0f, EUR ),
                    "578"},
            {null, "10-PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
                    4.0f, FactoryMethodInvoker.instantiateCurrency( 20.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 35.0f, EUR ),
                    "567"},
            {null, "11-STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
                    null, FactoryMethodInvoker.instantiateCurrency( 200.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 350.0f, EUR ),
                    "478"},
            {null, "12-VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
                    null, FactoryMethodInvoker.instantiateCurrency( 15.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 25.0f, EUR ),
                    "5"},
            {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
                    3.5f, FactoryMethodInvoker.instantiateCurrency( 60.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 100.0f, EUR ),
                    "78"},
            {null, "14-Nosedive", "Klammer zum Verschließen der Nase beim Tauchen",
                    5.0f, FactoryMethodInvoker.instantiateCurrency( 2.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 5.0f, EUR ),
                    "457"}
    };
    

    // These addresss are used for the storage units. The storage unit name will equal
    // the zip code of the site. Their index number will be visible in the house number.
    // The storage units are used as such:
    // - storage unit 0 is holds all items 0 - 6, and is used for all tests where multiple
    //   shipments are irrelevant.
    // - storage units 1 - 3 are used for the proximity tests, where you can deliver items 7 to
    //   to a user from the closest storage unit.
    // - storage units 4 - 8 are used for the tests where you need to deliver items 8 - 14 in
    //   the most cost-efficient way, as multiple shipments.
    // - storage unit 9 is empty.
    private final static int STORAGE_UNIT_NUMOF = 10;
    private final static AddressType[] STORAGE_UNIT_ADDRESS = new AddressType[]{
            FactoryMethodInvoker.instantiateAddress(
                    "Stapelallee 0", "Potsdam",
                    FactoryMethodInvoker.instantiateZipCode( "14476" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Lagerhausstr. 1", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02345" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Speicherplatz 2", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02313" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Ablageweg 3", "Reichswürgen",
                    FactoryMethodInvoker.instantiateZipCode( "44923" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Paketstellenallee 4", "Düsseldorf",
                    FactoryMethodInvoker.instantiateZipCode( "40588" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Kaputte-Sachen-Straße 5", "Düren",
                    FactoryMethodInvoker.instantiateZipCode( "52355" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Aufbewahrungsweg 6", "Viernheim",
                    FactoryMethodInvoker.instantiateZipCode( "68519" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Paketallee 7", "Baden-Baden",
                    FactoryMethodInvoker.instantiateZipCode( "76532" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Sendenstr. 8", "Senden",
                    FactoryMethodInvoker.instantiateZipCode( "89250" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Schickweg 9", "Hohenroth",
                    FactoryMethodInvoker.instantiateZipCode( "97618" ) )
    };
    private final static UUID[] STORAGE_UNIT_ID = new UUID[STORAGE_UNIT_NUMOF];


    // These data structures contain the inventory of the items in the storage units.
    // ITEM_INVENTORY is a map item name -> Integer[STORAGE_UNIT_NUMOF].
    // The Integer[STORAGE_UNIT_NUMOF] contains the inventory of the item in each of
    // the storage units.
    //
    // The following rules apply:
    // - item 0 is out of inventory
    // - item 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in storage unit 0
    // - item 4 / 5 / 6 have a random inventory between 30 and 130, also all ONLY in storage unit 0
    //   (these are the items used for tests on how to add and remove inventory)
    // - the others have a random inventory between 30 and 130, distributed over several
    //   storage units. Here we follow this convention for simplicity:
    //   - Assume that the item is available in <n> storage units. Then the first <n-1> storage units
    //     in the list (in ascending sequence) contain 3, and all the remaining inventory is in the
    //     last storage unit.

    private static final Map<String, Integer[]> ITEM_INVENTORY = new HashMap<>();

    static {
        // items 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
        ITEM_INVENTORY.put( (String) ITEM_DATA[0][1],
                getInventoryDistribution( 0, (String) ITEM_DATA[0][6] ) );
        ITEM_INVENTORY.put( (String) ITEM_DATA[1][1],
                getInventoryDistribution( 10, (String) ITEM_DATA[1][6] ) );
        ITEM_INVENTORY.put( (String) ITEM_DATA[2][1],
                getInventoryDistribution( 20, (String) ITEM_DATA[2][6] ) );
        ITEM_INVENTORY.put( (String) ITEM_DATA[3][1],
                getInventoryDistribution( 30, (String) ITEM_DATA[3][6] ) );

        // The other items have a random inventory between 30 and 130,
        for ( int i = 4; i < ITEM_NUMOF; i++ ) {
            Integer totalNumber = random.nextInt( 100 ) + 30;
            Integer[] inventoryInStorageUnits =
                    getInventoryDistribution( totalNumber, (String) ITEM_DATA[i][6] );
            ITEM_INVENTORY.put( (String) ITEM_DATA[i][1], inventoryInStorageUnits );
        }
    }

    /**
     * This method creates a random inventory distribution for the given item.
     *
     * @param totalQuantity - the total number of items in the storage units
     * @param zeroToNine  - a string with numbers between 0 and 9, representing the storage units
     * @return an Integer array with the inventory distribution for the item, according to
     * the rules described above.
     */
    private static Integer[] getInventoryDistribution( Integer totalQuantity, String zeroToNine ) {
        Integer[] inventoryInStorageUnits = new Integer[STORAGE_UNIT_NUMOF];
        for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) inventoryInStorageUnits[i] = 0;
        TreeSet<Integer> storageUnitIndices = getStorageUnitIndices( zeroToNine );
        int numOfIndices = storageUnitIndices.size();
        int currentIndexNumber = 0;
        int currentQuantity = totalQuantity;
        for ( Integer storageUnitIndex : storageUnitIndices ) {
            currentIndexNumber++;
            if ( currentIndexNumber < numOfIndices ) {
                inventoryInStorageUnits[storageUnitIndex] = 3;
                currentQuantity -= 3;
            } else {
                inventoryInStorageUnits[storageUnitIndex] = currentQuantity;
            }
        }
        return inventoryInStorageUnits;
    }

    private static TreeSet<Integer> getStorageUnitIndices( String zeroToNine ) {
        TreeSet<Integer> storageUnitIndices = new TreeSet<>();
        for ( int i = 0; i < zeroToNine.length(); i++ ) {
            storageUnitIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
        }
        return storageUnitIndices;
    }


    @Autowired
    public InventoryTestHelperImpl( ItemCatalogUseCases itemCatalogUseCases,
                                         StorageUnitUseCases storageUnitUseCases ) {
        this.itemCatalogUseCases = itemCatalogUseCases;
        this.storageUnitUseCases = storageUnitUseCases;
    }


    @Override
    public void addAllItems() {
        int i = 0;
        for ( Object[] itemData : ITEM_DATA ) {
            UUID newId = itemCatalogUseCases.addItemToCatalog(
                    (String) itemData[1], (String) itemData[2],
                    (Float) itemData[3], (CurrencyType) itemData[4],
                    (CurrencyType) itemData[5] );
            // The first element of the item data is the id, which was initialized with null before, but can now be set
            ITEM_DATA[i][0] = newId;
            i++;
        }
    }


    @Override
    public int numberOfItems() {
        return ITEM_NUMOF;
    }


    @Override
    public UUID getItemId( int index ) {
        if ( index < 0 || index >= ITEM_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (UUID) ITEM_DATA[index][0];
    }


    @Override
    public CurrencyType getBuyingPrice( int index ) {
        if ( index < 0 || index >= ITEM_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (CurrencyType) ITEM_DATA[index][4];
    }


    @Override
    public CurrencyType getSellingPrice( int index ) {
        if ( index < 0 || index >= ITEM_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (CurrencyType) ITEM_DATA[index][5];
    }


    @Override
    public void addAllStorageUnits( boolean withInventory ) {
        for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) {
            STORAGE_UNIT_ID[i] = storageUnitUseCases.addNewStorageUnit(
                    STORAGE_UNIT_ADDRESS[i].getStreet(),
                    STORAGE_UNIT_ADDRESS[i] );
        }
        if ( withInventory ) {
            addAllInventory();
        }
    }


    private void addAllInventory() {
        for ( Object[] itemData : ITEM_DATA ) {
            Integer[] inventoryInStorageUnits =
                    ITEM_INVENTORY.get( itemData[1] );
            for ( int iStorageUnit = 0; iStorageUnit < STORAGE_UNIT_NUMOF; iStorageUnit++ ) {
                if ( inventoryInStorageUnits[iStorageUnit] > 0 )
                    storageUnitUseCases.addToInventory(
                            STORAGE_UNIT_ID[iStorageUnit], (UUID) itemData[0],
                            inventoryInStorageUnits[iStorageUnit] );
            }
        }
    }


    @Override
    public int numberOfStorageUnits() {
        return STORAGE_UNIT_NUMOF;
    }


    @Override
    public UUID getStorageUnitId( int index ) {
        if ( index < 0 || index >= STORAGE_UNIT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return STORAGE_UNIT_ID[index];
    }


    @Override
    public Integer getStorageUnitInventory( int storageUnitIndex, int itemIndex ) {
        if ( storageUnitIndex < 0 || storageUnitIndex >= STORAGE_UNIT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + storageUnitIndex );
        }
        if ( itemIndex < 0 || itemIndex >= ITEM_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + itemIndex );
        }
        String itemName = (String) ITEM_DATA[itemIndex][1];
        Integer[] inventoryInStorageUnits = ITEM_INVENTORY.get( itemName );
        Integer foundInventory = inventoryInStorageUnits[storageUnitIndex];
        return foundInventory == null ? 0 : foundInventory;
    }


    @Override
    public int findStorageUnitIndex( UUID storageUnitId ) {
        for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) {
            if ( STORAGE_UNIT_ID[i].equals( storageUnitId ) ) {
                return i;
            }
        }
        throw new IllegalArgumentException( "No test storage unit with UUID id " + storageUnitId );
    }


    @Override
    public int findItemIndex( UUID itemId ) {
        for ( int iItemData = 0; iItemData < STORAGE_UNIT_NUMOF; iItemData++ ) {
            Object[] itemData = ITEM_DATA[iItemData];
            if ( itemData[0].equals( itemId ) ) {
                return iItemData;
            }
        }
        throw new IllegalArgumentException( "No test item with UUID id " + itemId );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\UserTestHelperImpl.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
import thkoeln.archilab.ecommerce.usecases.masterdata.MockUser;

import static org.junit.jupiter.api.Assertions.assertThrows;

/**
 * This is a test helper class that initializes and registers users in the system,
 * using the given interface(s).
 */
@Component
@SuppressWarnings("PMD")
public class UserTestHelperImpl implements UserTestHelper {

    private UserRegistrationUseCases userRegistrationUseCases;

    @Autowired
    public UserTestHelperImpl( UserRegistrationUseCases userRegistrationUseCases ) {
        this.userRegistrationUseCases = userRegistrationUseCases;
    }

    private final static String[] USER_NAME = new String[]{
            "Max Mueller",
            "Sophie Schmitz",
            "Irene Mihalic",
            "Emilia Fischer",
            "Filiz Polat",
            "Lina Wagner",
            "Leon Becker",
            "Agnieszka Kalterer",
            "Felix Bauer",
            "Lara Schulz"
    };

    private final static EmailType[] USER_EMAIL = new EmailType[]{
            FactoryMethodInvoker.instantiateEmail( "99Z@example.com" ),
            FactoryMethodInvoker.instantiateEmail( "a@4.com" ),
            FactoryMethodInvoker.instantiateEmail( "irene@wearefreedomnow.com" ),
            FactoryMethodInvoker.instantiateEmail( "emilia.fischer@example.com" ),
            FactoryMethodInvoker.instantiateEmail( "j877d3@example.this.com" ),
            FactoryMethodInvoker.instantiateEmail( "lina.marie.wagner@example.com" ),
            FactoryMethodInvoker.instantiateEmail( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
            FactoryMethodInvoker.instantiateEmail( "agna@here.ch" ),
            FactoryMethodInvoker.instantiateEmail( "felix.bauer@example.org" ),
            FactoryMethodInvoker.instantiateEmail( "lara.schulz@example.at" )
    };

    // The following array is used to create a list of addresss for the users.
    // The indices are coded into the house number.
    // - Persons 0 - 5 are used for proximity tests with one storage unit.
    private final static AddressType[] USER_ADDRESS = new AddressType[]{
            FactoryMethodInvoker.instantiateAddress(
                    "Marktstraße 0", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02314" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Hauptstraße 1", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02368" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Kirchplatz 2", "Niemandstown",
                    FactoryMethodInvoker.instantiateZipCode( "12345" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Schulstraße 3", "Geisterhausen",
                    FactoryMethodInvoker.instantiateZipCode( "31463" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Rosenweg 4", "Kuhhausen",
                    FactoryMethodInvoker.instantiateZipCode( "72162" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Wiesenstraße 5", "Waldschenkensdorf",
                    FactoryMethodInvoker.instantiateZipCode( "82195" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Muehlenweg 6", "Koeln",
                    FactoryMethodInvoker.instantiateZipCode( "50667" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Goethestraße 7", "Frankfurt am Main",
                    FactoryMethodInvoker.instantiateZipCode( "60311" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Dorfstraße 8", "Stuttgart",
                    FactoryMethodInvoker.instantiateZipCode( "70173" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Bahnhofstraße 9", "Muenchen",
                    FactoryMethodInvoker.instantiateZipCode( "80331" ) )
    };

    private final static UserType[] mockUsers;

    static {
        mockUsers = new UserType[USER_NAME.length];
        for ( int i = 0; i < USER_NAME.length; i++ ) {
            mockUsers[i] = new MockUser(
                    USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
        }
    }


    @Override
    public void registerAllUsers() {
        for ( int i = 0; i < USER_NAME.length; i++ ) {
            registerUser( USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
        }
    }


    private void registerUser( String name, EmailType email, AddressType address ) {
        userRegistrationUseCases.register( name, email, address );
    }


    @Override
    public int getNumberOfUsers() {
        return USER_NAME.length;
    }


    @Override
    public String getUserName( int index ) {
        if ( index < 0 || index >= USER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return USER_NAME[index];
    }


    @Override
    public EmailType getUserEmail( int index ) {
        if ( index < 0 || index >= USER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return USER_EMAIL[index];
    }


    @Override
    public AddressType getUserAddress( int index ) {
        if ( index < 0 || index >= USER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return USER_ADDRESS[index];
    }


    @Override
    public UserType getUser( int index ) {
        if ( index < 0 || index >= USER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return mockUsers[index];
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ItemTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

import java.util.UUID;

public interface ItemTestHelper {
    /**
     * Adds all test items to the database.
     * If you use the debugger and want to identify _which_ test item you currently look at:
     * The indices are coded into the first number in the name string of the item, like e.g.
     * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
     */
    void addAllItems();


    /**
     * @return the number of test items in the database
     */
    int numberOfItems();


    /**
     * @param index
     * @return the id of the test item at the given index
     */
    UUID getItemId( int index );


    /**
     * @param itemId - the id of the item in the test data
     * @return the index of the test item with that id
     */
    int findItemIndex( UUID itemId );


    /**
     * @param index
     * @return the buying price of test item at the given index
     */
    CurrencyType getBuyingPrice( int index );


    /**
     * @param index
     * @return the selling price of test item at the given index
     */
    CurrencyType getSellingPrice( int index );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockUser.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import lombok.Setter;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;


import java.util.Objects;

@Setter
public class MockUser implements UserType {
    private String name;
    private EmailType emailType;
    private AddressType addressType;


    public MockUser( String name, EmailType emailType, AddressType addressType) {
        this.name = name;
        this.emailType = emailType;
        this.addressType = addressType;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public EmailType getEmail() {
        return emailType;
    }

    @Override
    public AddressType getAddress() {
        return addressType;
    }

    @Override
    public boolean equals( Object o ) {
        if ( this == o ) return true;
        if ( !( o instanceof MockUser ) ) return false;
        MockUser that = (MockUser) o;
        return Objects.equals( getName(), that.getName() ) &&
                Objects.equals( emailType, that.emailType ) &&
                Objects.equals( addressType, that.addressType );
    }

    @Override
    public int hashCode() {
        return Objects.hash( getName(), emailType, addressType );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.usecases.*;

/**
 * Removes everything :-)
 */
@Service
public class Purgatory {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private ShoppingCartUseCases shoppingCartUseCases;
    @Autowired
    private OrderUseCases orderUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private StorageUnitUseCases storageUnitUseCases;

    public void deleteEverything() {
        orderUseCases.deleteAllOrders();
        shoppingCartUseCases.emptyAllShoppingCarts();
        storageUnitUseCases.deleteAllStorageUnits();
        userRegistrationUseCases.deleteAllUsers();
        itemCatalogUseCases.deleteItemCatalog();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;

@Component
@Slf4j
@Profile("!test")
@SuppressWarnings("PMD")
public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
    private Purgatory purgatory;
    private UserTestHelper userTestHelper;
    private ItemTestHelper itemTestHelper;
    private StorageUnitTestHelper storageUnitTestHelper;


    @Autowired
    public StartupListener( Purgatory purgatory,
                            UserTestHelper userTestHelper,
                            ItemTestHelper itemTestHelper,
                            StorageUnitTestHelper storageUnitTestHelper ) {
        this.purgatory = purgatory;
        this.userTestHelper = userTestHelper;
        this.itemTestHelper = itemTestHelper;
        this.storageUnitTestHelper = storageUnitTestHelper;
    }

    @Override
    public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
        log.info( "StartupListener initializing master data ..." );
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        itemTestHelper.addAllItems();
        storageUnitTestHelper.addAllStorageUnits( true );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StorageUnitTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import java.util.UUID;

public interface StorageUnitTestHelper {
    /**
     * Adds the test storage units to the system.
     * If you want to use the storage units, or want to know which index the storage unit has that you see
     * in the debugger, the following rules apply:
     * - The storage unit name will equal the street name of the address of the storage unit.
     * - The index number is visible in the house number. Example: storage unit 3 is located at
     *   "Ablageweg 3", and that is also its name.
     *
     *  The storage units are used in the tests as follows:
     *  - storage unit 0 holds all items 0 - 6, and is used for all tests where it is not relevant
     *    to split one shopping cart into several orders.
     *  - storage units 1 - 3 are used for the proximity tests, where you can deliver item 7 to
     *    to a user from the closest storage unit.
     *  - storage units 4 - 8 are used for the tests where you need to deliver items 8 - 14 in
     *    the most cost-efficient way, as multiple shipments.
     *  - storage unit 9 is empty.
     *
     *  If withInventory is true, then the storage units are filled with items. This happens
     *  according to the following rules:
     *  - items 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
     *    ONLY available in storage unit 0. (This means that item 0 out of inventory everywhere.)
     *  - items 4, 5, 6 have a random inventory between 30 and 130, also all ONLY in storage unit 0
          (these are the items used for tests on how to add and remove inventory)
     *  - item 7 has a random inventory between 30 and 130, distributed over
     *    storage units 1, 2, and 3. You can use this to test if the appropriate storage unit is found
     *    for a shopping cart with only item 7 in it, but with different quantities (<= 3, or > 3).
     *  - The other items (8 - 14) have also a random inventory between 30 and 130, all distributed
     *    over several storage units. The distribution is done as follows:
     *    Assume that the item is available in <n> storage units. Then the first <n-1> storage units
     *    in the list (in ascending sequence) contain 3, and all the remaining inventory is in the
     *    last storage unit.
     *
     *    This is how the inventory of items could be distributed
     *    (Wx = storage unit x with its zip code, Px = item x,
     *    numbers marked with (*) are random large numbers):
     *
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
     *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *    | P0   |      |     |     |      |     |      |     |       |      |     |
     *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
     *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
     *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
     *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
     *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
     *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
     *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
     *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
     *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
     *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
     *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
     *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
     *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
     *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *
     * @param withInventory if true, the inventory of the items is added to the storage unit. Otherwise, the
     *                           the inventory is not added and the storage unit is empty.
     */
    public void addAllStorageUnits( boolean withInventory );


    /**
     * @return the number of test storage units in the database
     */
    int numberOfStorageUnits();


    /**
     * @param index
     * @return the id of the test storage unit at the given index
     */
    UUID getStorageUnitId( int index );


    /**
     * @param storageUnitId - the id of the storage unit in the test data
     * @return the index of the test storage unit with that id
     */
    int findStorageUnitIndex( UUID storageUnitId );


    /**
     * @param itemIndex - the index of the item in the test data
     * @param storageUnitIndex - the index of the storage unit in the test data
     * @return the number of items (inventory) available in the storage unit at the given index
     */
    Integer getStorageUnitInventory( int storageUnitIndex, int itemIndex );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\UserTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;


import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;

/**
 * This is a test helper interface provides access to predefined test data for
 * users.
 */
public interface UserTestHelper {
    /**
     * This method calls the use case implementation to register all users specified in the
     * test data set.
     * If you use the debugger and want to identify _which_ test user you currently look at:
     * The indices are coded into the house number (in the user's address) and in the first
     * cipher of the zip code. This is the list of users:
     *
     * +-------+-------------------+--------+---------------------
     * | Index | Name              | PLZ    | Email
     * +-------+-------------------+--------+---------------------
     * | 0     | Max Mueller       | 02314  | 99Z@example.com
     * | 1     | Sophie Schmitz    | 02368  | a@4.com
     * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
     * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
     * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
     * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
     * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
     * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
     * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
     * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
     * +-------+-------------------+--------+---------------------
     */
    void registerAllUsers();


    /**
     * @return the number of test users in the test data set.
     */
    int getNumberOfUsers();


    /**
     * @param index the index of the user in the test data set.
     * @return the name of the test user with the given index.
     */
    String getUserName( int index );


    /**
     * @param index the index of the user in the test data set.
     * @return the email of the test user with the given index.
     */
    EmailType getUserEmail( int index );


    /**
     * @param index the index of the user in the test data set.
     * @return the address of the test user with the given index.
     */
    AddressType getUserAddress( int index );


    /**
     * @param index the index of the user in the test data set.
     * @return the test user with the given index.
     */
    UserType getUser( int index );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\OrderUseCases.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */
package thkoeln.archilab.ecommerce.usecases;


import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.Map;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of the order history of a user.
 */
public interface OrderUseCases {

    /**
     * Returns a map showing which items have been ordered by a user and how many of each item
     *
     * @param userEmail
     * @return the order history of the user (map is empty if the user has not ordered anything yet)
     * @throws ShopException if
     *      - userEmail is null
     *      - the user with the given email does not exist
     */
    public Map<UUID, Integer> getOrderHistory( EmailType userEmail );



    /**
     * @return the number of items in a given order. If the item is not a position of the order, the method
     *         returns 0. No exception is thrown.
     * @param orderId - the id of the order to be checked
     * @param itemId - the id of the item for which we want to know the quantity
     * @throws ShopException if
     *     - orderId is null, or doesn't exist in the system
     *     - itemId is null, or doesn't exist in the system
     */
    public Integer getOrderQuantityOfItem( UUID orderId, UUID itemId );


    /**
     * @return the id of the storage unit that is responsible for the given order
     * @param orderId - the id of the order to be checked
     * @throws ShopException if
     *      - orderId is null, or doesn't exist in the system
     */
    public UUID getStorageUnitIdForOrder( UUID orderId );


    /**
     * Deletes all orders in the system
     */
    public void deleteAllOrders();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingCartUseCases.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.Map;
import java.util.Set;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of use cases handling the shopping cart.
 * The interface is probably incomplete, and will grow over time ...
 */
public interface ShoppingCartUseCases {
    /**
     * Adds a item to the cart of a user
     *
     * @param userEmail
     * @param itemId
     * @param quantityOf
     * @throws ShopException if ...
     *          - userEmail is null,
     *          - the user with the given email does not exist,
     *          - itemId is null,
     *          - the item with itemId does not exist
     *          - the Quantity is negative,
     */
    public void addItemToShoppingCart( EmailType userEmail,
                                                 UUID itemId, int quantityOf );


    /**
     * Removes a item from the cart of a user
     *
     * @param userEmail
     * @param itemId
     * @param quantityOf
     * @throws ShopException if ...
     *          - userEmail is null,
     *          - the user with the given email does not exist,
     *          - itemId is null,
     *          - the item with itemId does not exist
     *          - the Quantity is negative
     *          - the item is not in the shopping cart in the requested Quantity
     */
    public void removeItemFromShoppingCart( EmailType userEmail,
                                                      UUID itemId, int quantityOf );


    /**
     * Returns a map showing which items are in the cart of a user and how many of each item
     *
     * @param userEmail
     * @return the cart of the user (map is empty if the cart is empty)
     * @throws ShopException if
     *          - userEmail is null,
     *          - the user with the given email does not exist
     */
    public Map<UUID, Integer> getShoppingCartAsMap( EmailType userEmail );


    /**
     * Returns the current value of all items in the cart of a user
     *
     * @param userEmail
     * @return the cart of the user
     * @throws ShopException if
     *          - userEmail is null,
     *          - the user with the given email does not exist
     */
    public CurrencyType getShoppingCartAsCurrencyValue( EmailType userEmail );




    /**
     * Checks out the cart of a user
     *
     * @param userEmail
     * @return A set of ids belonging to orders that were created during the checkout. If the shopping cart can
     *         only be served from more than one storage unit, each shipment from a storage unit gets a
     *         dedicated order. I.e. if there is just one shipment, then the set will contain just one order id.
     *         If there are multiple shipments, the set will contain multiple order ids.
     * @throws ShopException if
     *      - userEmail is null or empty
     *      - the user with the given email does not exist, or if the cart is empty
     * @throws
     *      - ShopException if userEmail is null
     *      - InsufficientInventoryException if there is not enough inventory level for to serve the order
     *        for all items in the shopping cart
     */
    public Set<UUID> checkout( EmailType userEmail );


    /**
     * Empties all shopping carts in the system
     */
    public void emptyAllShoppingCarts();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\StorageUnitUseCases.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;

import java.util.UUID;

/**
 * This interface contains methods needed in the context of handling the shop inventory,
 * i.e. managing storage units, and adding / removing items in the storage unit.
 */
public interface StorageUnitUseCases {
    /**
     *
     * @param name
     * @param address
     * @return the id of the new storage unit
     * @throws ShopException if ...
     *      - name is null or empty
     *      - address is null
     */
    public UUID addNewStorageUnit( String name, AddressType address );


    /**
     * Deletes all storage units from the shop. Intended for testing purposes.
     */
    public void deleteAllStorageUnits();


    /**
     * Adds a certain Quantity of a given item to the inventory
     * @param storageUnitId
     * @param itemId
     * @param addedQuantityOf
     * @throws ShopException if ...
     *      - storageUnitId is null
     *      - the storage unit with that id does not exist
     *      - itemId is null
     *      - the item with that id does not exist
     *      - addedQuantityOf < 0
     */
    public void addToInventory( UUID storageUnitId, UUID itemId, int addedQuantityOf );


    /**
     * Removes a certain Quantity of a given item from the inventory.
     * @param storageUnitId
     * @param itemId
     * @param removedQuantityOf
     * @throws ShopException if ...
     *      - storageUnitId is null
     *      - the storage unit with that id does not exist
     *      - itemId is null
     *      - the item with that id does not exist
     *      - removedQuantityOf < 0
     */
    public void removeFromInventory( UUID storageUnitId, UUID itemId, int removedQuantityOf );


    /**
     * Changes the total Quantity of a given item in the inventory.
     * @param storageUnitId
     * @param itemId
     * @param newTotalQuantityOf
     * @throws ShopException if ...
     *      - storageUnitId is null
     *      - the storage unit with that id does not exist
     *      - itemId is null
     *      - the item with that id does not exist
     *      - newTotalQuantityOf < 0
     */
    public void changeInventoryTo( UUID storageUnitId, UUID itemId, int newTotalQuantityOf );


    /**
     * Get the current inventory of a given item in one specific storage unit.
     * @param storageUnitId
     * @param itemId
     * @return the current total inventory of the item
     * @throws ShopException if ...
     *      - storageUnitId is null
     *      - the storage unit with that id does not exist
     *      - itemId is null
     *      - the item with that id does not exist
     */
    public int getAvailableInventory( UUID storageUnitId, UUID itemId );


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\UserRegistrationUseCases.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;

/**
 * This interface contains methods needed in the context of use cases concerning the registration of a user.
 * The interface is probably incomplete, and will grow over time ...
 */
public interface UserRegistrationUseCases {
    /**
     * Registers a new user
     *
     * @param name
     * @param email
     * @param address
     * @throws ShopException if ...
     *      - the user with the given email already exists
     *      - address is null
     */
    public void register( String name, EmailType email, AddressType address );


    /**
     * Changes the address of a user
     *
     * @param userEmail
     * @param userEmail
     * @param address
     * @throws ShopException if ...
     *      - the user with the given email does not exist,
     *      - address is null
     */
    public void changeAddress( EmailType userEmail,
                               AddressType address );


    /**
     * Returns the data of a user as an array of strings (name, email, street, city, zipCode)
     * @param userEmail
     * @return the user data
     * @throws ShopException the user with the given email does not exist,
     */
    public UserType getUserData( EmailType userEmail );



    /**
     * Clears all users, including all orders and shopping carts
     */
    public void deleteAllUsers();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\UserType.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;

/**
 * This interface expresses the essence of a shop user
 */
public interface UserType {
    String getName();
    EmailType getEmail();
    AddressType getAddress();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
package thkoeln.archilab.ecommerce.helpers.impl;

import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.test.web.servlet.MockMvc;
import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;


@TestConfiguration
public class RESTTestHelperConfiguration {

    @Bean
    public ShoppingCartRESTHelper shoppingCartRESTHelper(
            MockMvc mockMvc, ItemCatalogUseCases itemCatalogUseCases ) {
        return new ShoppingCartRESTHelperImpl( mockMvc, itemCatalogUseCases );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingCartRESTHelperImpl.java ---
package thkoeln.archilab.ecommerce.helpers.impl;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.Map;
import java.util.UUID;

import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@Slf4j
public class ShoppingCartRESTHelperImpl implements ShoppingCartRESTHelper {
    private MockMvc mockMvc;
    private ItemCatalogUseCases itemCatalogUseCases;

    private static final ResultMatcher CREATED = status().isCreated();
    private static final ResultMatcher OK = status().isOk();

    public ShoppingCartRESTHelperImpl( MockMvc mockMvc, ItemCatalogUseCases itemCatalogUseCases ) {
        this.mockMvc = mockMvc;
        this.itemCatalogUseCases = itemCatalogUseCases;
    }


    @Override
    public UUID getQueryShoppingCart( EmailType email, Map<UUID, Integer> quantityMap )
            throws Exception {
        // first query the users API to get the proper userId
        UUID userId;
        String userUri = "/users?email=" + email.toString();
        MvcResult userGetResult = mockMvc.perform( get( userUri ) )
                .andExpect( status().isOk() )
                .andReturn();
        ObjectMapper objectMapper = new ObjectMapper();
        IdDTO idDTO = objectMapper.readValue( userGetResult.getResponse().getContentAsString(), IdDTO.class );
        userId = idDTO.getId();

        // then query the shopping cart API and extract the shopping cart id
        String shoppingCartUri = "/shoppingCarts?userId=" + userId.toString();
        ResultActions resultActions = mockMvc.perform( get( shoppingCartUri ) )
                .andExpect( status().isOk() );
        idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
        UUID shoppingCartId = idDTO.getId();

        // additional checks, if desired
        if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
        return shoppingCartId;
    }


    private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
        if ( quantityMap == null ) return;
        int numOfItems = quantityMap.size();
        resultActions.andExpect( jsonPath( "$.positions.length()" ).value( numOfItems ) );
        float totalSellingPriceAsFloat = 0f;
        for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
            UUID itemId = entry.getKey();
            Integer quantity = entry.getValue();
            resultActions.andExpect( jsonPath( "$.positions.[?(@.itemId == '" + itemId + "')].quantity" )
                    .value( quantity ) );
            CurrencyType sellingPrice = itemCatalogUseCases.getSellingPrice( itemId );
            totalSellingPriceAsFloat += sellingPrice.getQuantity() * quantity;
        }
        // last thing - check the total selling price
        String totalSellingPriceString = String.format( "%.2f €", totalSellingPriceAsFloat );
        resultActions
                .andExpect( jsonPath( "$.totalSellingPrice" ).value( totalSellingPriceString ) );
    }


    @Override
    public void addItemToShoppingCart( UUID shoppingCartId, UUID itemId, Integer quantity )
            throws Exception {
        addItemToShoppingCart( shoppingCartId, itemId, quantity, null );
    }


    @Override
    public void addItemToShoppingCart( UUID shoppingCartId, UUID itemId, Integer quantity,
                                                  ResultMatcher expectedStatus ) throws Exception {
        ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
        ObjectMapper objectMapper = new ObjectMapper();
        QuantityDTO dto = new QuantityDTO( itemId, quantity );
        String quantityJson = objectMapper.writeValueAsString( dto );
        mockMvc.perform( post( "/shoppingCarts/" + shoppingCartId + "/positions" )
                        .contentType( APPLICATION_JSON ).content( quantityJson ) )
                .andExpect( status );
    }



    @Override
    public void deleteItemFromShoppingCart( UUID shoppingCartId, UUID itemId )
            throws Exception {
        deleteItemFromShoppingCart( shoppingCartId, itemId, null );
    }



    @Override
    public void deleteItemFromShoppingCart( UUID shoppingCartId, UUID itemId,
                                                      ResultMatcher expectedStatus ) throws Exception {
        ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
        String uri = "/shoppingCarts/" + shoppingCartId + "/positions/" + itemId;
        mockMvc.perform( delete( uri ) ).andExpect( status );
    }


    @Override
    public void checkout( UUID shoppingCartId, String expectedUserName,
                          ResultMatcher expectedStatus,
                          Map<UUID, Map<UUID, Integer>> expectedOrders ) throws Exception {
        ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
        String uri = "/shoppingCarts/" + shoppingCartId + "/checkout";
        MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
        ObjectMapper objectMapper = new ObjectMapper();

        // check the response content
        if ( expectedOrders != null || expectedUserName != null ) {
            String responseContent = result.getResponse().getContentAsString();
            log.info( "ShoppingCartRESTHelperImpl - checkout: found response content " + responseContent );
            OrderDTO[] orders = objectMapper.readValue( responseContent, OrderDTO[].class );
            checkExpectedUserName( expectedUserName, orders );
            checkExpectedOrders( expectedOrders, orders );
        }
    }


    private void checkExpectedUserName( String expectedUserName, OrderDTO[] orders ) {
        if ( expectedUserName == null ) return;
        for ( OrderDTO order : orders ) {
            if ( !order.getUserName().equals( expectedUserName ) ) {
                throw new AssertionError( "Expected userName '" + expectedUserName +
                        "' but got '" + order.getUserName() + "'" );
            }
        }
    }


    private void checkExpectedOrders( Map<UUID, Map<UUID, Integer>> expectedOrders,
                                            OrderDTO[] orders ) {
        if ( expectedOrders == null ) return;
        for ( OrderDTO order : orders ) {
            UUID storageUnitId = order.getStorageUnitId();
            Map<UUID, Integer> expectedQuantities = expectedOrders.get( storageUnitId );
            if ( expectedQuantities == null ) {
                throw new AssertionError( "No expected quantities for storage unit " + storageUnitId );
            }
            QuantityDTO[] positions = order.getPositions();
            for ( QuantityDTO quantityDTO : positions ) {
                UUID itemId = quantityDTO.getItemId();
                Integer expectedQuantity = expectedQuantities.get( itemId );
                if ( expectedQuantity == null ) {
                    throw new AssertionError( "No expected quantity for item " + itemId +
                            " in storage unit " + storageUnitId );
                }
                if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
                    throw new AssertionError( "Expected quantity " + expectedQuantity + " for item " +
                            itemId + " in storage unit " + storageUnitId +
                            ", but got " + quantityDTO.getQuantity() );
                }
            }
        }
    }


    /**
     * A DTO containing just a quantity, used in testing.
     * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
     * Therefore, constructors and getters/setters are manually defined.
     */
    @NoArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class QuantityDTO {
        private UUID itemId;
        private Integer quantity;

        public QuantityDTO( UUID itemId, Integer quantity ) {
            this.itemId = itemId;
            this.quantity = quantity;
        }
        public UUID getItemId() {
            return itemId;
        }
        public Integer getQuantity() {
            return quantity;
        }
        public void setItemId( UUID itemId ) {
            this.itemId = itemId;
        }
        public void setQuantity( Integer quantity ) {
            this.quantity = quantity;
        }
    }


    /**
     * A DTO containing just the id of an entity, used in testing.
     */
    @AllArgsConstructor
    @NoArgsConstructor
    @Getter
    @Setter
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class IdDTO {
        private UUID id;
    }


    /**
     * A DTO containing the order data, used in testing.
     * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
     * Therefore, constructors and getters/setters are manually defined.
     */
    @NoArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class OrderDTO {
        private UUID id;
        private String userName;
        private UUID storageUnitId;
        private QuantityDTO[] positions;

        public UUID getId() {
            return id;
        }
        public String getUserName() {
            return userName;
        }
        public UUID getStorageUnitId() {
            return storageUnitId;
        }
        public QuantityDTO[] getPositions() {
            return positions;
        }
        public void setId( UUID id ) {
            this.id = id;
        }
        public void setUserName( String userName ) {
            this.userName = userName;
        }
        public void setStorageUnitId( UUID storageUnitId ) {
            this.storageUnitId = storageUnitId;
        }
        public void setPositions( QuantityDTO[] positions ) {
            this.positions = positions;
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingCartRESTHelper.java ---
package thkoeln.archilab.ecommerce.helpers;

import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.Map;
import java.util.UUID;

/**
 * A REST helper for shopping cart-related operations.
 * This interface defines methods to interact with a shopping cart via REST calls, such as querying, adding,
 * deleting, and checking out.
 */
public interface ShoppingCartRESTHelper {
    /**
     * Executes a REST GET query on a shopping cart and returns its id, with the user's email as a
     * starting point. The resulting shopping cart is checked against the given expected quantity map.
     * @param email The email of the user whose shopping cart is queried.
     * @param expectedQuantityMap A map of items and their quantities in the shopping cart. (If null, then don't check.)
     * @return The id of the user's shopping cart.
     * @throws Exception (whenever the REST call fails, or the shopping cart does not match the expected quantity map)
     */
    public UUID getQueryShoppingCart( EmailType email,
                                       Map<UUID, Integer> expectedQuantityMap ) throws Exception;


    /**
     * Adds a item to a shopping cart via a REST call.
     * @param shoppingCartId Id of the shopping cart.
     * @param itemId Id of the item.
     * @param quantity Quantity of the item.
     * @throws Exception (whenever the REST call fails)
     */
    public void addItemToShoppingCart( UUID shoppingCartId, UUID itemId, Integer quantity )
            throws Exception;


    /**
     * Adds a item to a shopping cart via a REST call.
     * @param shoppingCartId Id of the shopping cart.
     * @param itemId Id of the item.
     * @param quantity Quantity of the item.
     * @param expectedStatus expected status of the operation (null = CREATED)
     * @throws Exception (whenever the REST call fails or the status does not match)
     */
    public void addItemToShoppingCart( UUID shoppingCartId, UUID itemId, Integer quantity,
                                                  ResultMatcher expectedStatus ) throws Exception;


    /**
     * Deletes a item from a shopping cart via a REST call.
     * @param shoppingCartId Id of the shopping cart.
     * @param itemId Id of the item.
     * @throws Exception (whenever the REST call fails)
     */
    public void deleteItemFromShoppingCart( UUID shoppingCartId, UUID itemId )
            throws Exception;


    /**
     * Deletes a item from a shopping cart via a REST call.
     * @param shoppingCartId Id of the shopping cart.
     * @param itemId Id of the item.
     * @param expectedStatus expected status of the operation (null = OK)
     * @throws Exception (whenever the REST call fails or the status does not match)
     */
    public void deleteItemFromShoppingCart( UUID shoppingCartId, UUID itemId,
                                                      ResultMatcher expectedStatus ) throws Exception;


    /**
     * Checks out a shopping cart via REST call, and returns the id of the created order.
     * @param shoppingCartId
     * @param expectedUserName expected name of the user who owns the shopping cart (null = don't check)
     * @param expectedStatus expected status of the operation (null = don't check)
     * @param expectedOrders the expected orders to be created as a result of the checkout. This is
     *                            a map of the following form:
     *                            <pre>
     *                               storageUnitId -> Map<itemId,Integer>
     *                            </pre>
     *                            where the inner map contains the items and their quantities
     * @return
     * @throws Exception
     */
    public void checkout( UUID shoppingCartId, String expectedUserName,
                          ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedOrders )
           throws Exception;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class BasicNoOutsideSolutionRulesTest {

    @ArchTest
    static final ArchRule noClassesOnTopLevel =
            classes().should().resideInAPackage( "..solution.*.." )
                    .allowEmptyShould( true );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.library.Architectures.layeredArchitecture;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln")
@SuppressWarnings("PMD")
public class BasicProperDependenciesTest {

    @ArchTest
    static final ArchRule properDependencies =
            layeredArchitecture()
                    .consideringAllDependencies()
                    //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
                    .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
                    .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )

                    //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
                    .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
                    .allowEmptyShould( true );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import org.junit.jupiter.api.Test;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.MetadataReaderFactory;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertTrue;

public class BasicRequiredClassesTest {
    private static final String[] REQUIRED_CLASSES = {
            "User",
            "UserRepository",
            "Item",
            "ItemRepository",
            "Order",
            "OrderRepository",
            "InventoryLevel",
            "ShoppingCart",
            "ShoppingCartRepository",
            "StorageUnitRepository",
            "ShoppingCartPosition",
            "OrderPosition",
            "StorageUnit",
    };

    @Test
    public void testRequiredClassesDeclared() throws IOException {
        String basePackage = "thkoeln.archilab.ecommerce";
        String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";

        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );

        Set<String> foundClasses = new HashSet<>();

        Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
            try {
                MetadataReader reader = readerFactory.getMetadataReader( resource );
                foundClasses.add( reader.getClassMetadata().getClassName() );
            } catch (IOException e) {
                e.printStackTrace();
            }
        } );

        Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
            boolean found = foundClasses.stream().anyMatch(className ->
                    className.startsWith(basePackage) && className.endsWith("." + requiredClass)
            );
            assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
        });
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.ApplicationContext;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
public class BasicUseCaseImplementationPackageTest {

    @Autowired
    private ApplicationContext applicationContext;

    private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
        put("UserRegistrationUseCases", Arrays.asList("user"));
        put("StorageUnitUseCases", Arrays.asList("storageunit"));
        put("ItemCatalogUseCases", Arrays.asList("item"));
        put("ShoppingCartUseCases", Arrays.asList("shoppingcart"));
        put("OrderUseCases", Arrays.asList("order"));
    }};
    private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
    private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";

    @Test
    public void testRequiredClassesDeclared() {
        for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
            String interfaceName = USECASE_PATH + "." + entry.getKey();
            List<String> correctTopLevelPackages = entry.getValue();
            Class<?> useCaseInterfaceClass = null;
            try {
                useCaseInterfaceClass = Class.forName( interfaceName );
            } catch (ClassNotFoundException e) {
                fail( "Use case interface " + interfaceName + " not found.", e );
                continue;
            }
            String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
            assertEquals( 1, beans.length,
                    "There should be exactly 1 service implementation for the interface " +
                            entry.getKey() + ", but found " + beans.length );
            Object bean = applicationContext.getBean( beans[0] );
            boolean isValid = false;
            for ( String correctTopLevelPackage : correctTopLevelPackages ) {
                String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
                if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
                    isValid = true;
                    break;
                }
            }
            assertTrue( isValid,
                    "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
                            + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Service;

import jakarta.persistence.Entity;
import org.springframework.web.bind.annotation.RestController;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class DDDRulesTest {

    @ArchTest
    static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
            noClasses().that().resideInAPackage( "..domain.." )
                    .should().dependOnClassesThat().resideInAPackage( "..application.." )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule entitiesMustResideInADomainPackage =
            classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
                    .as( "Entities must reside in a package '..domain..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule entitiesMustNotAccessRepositories =
            noClasses().that().areAnnotatedWith( Entity.class )
                    .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule repositoriesMustResideInADomainPackage =
            classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
                    .as( "Repositories must reside in a package '..domain..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule repositoryNamesMustHaveProperSuffix =
            classes().that().areAssignableTo( CrudRepository.class )
                    .should().haveSimpleNameEndingWith( "Repository" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule servicesMustResideInAnApplicationPackage =
            classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
                    .as( "Application Services must reside in a package '..application..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule serviceNamesMustHaveProperSuffix =
            classes().that().areAnnotatedWith( Service.class )
                    .should().haveSimpleNameEndingWith( "Service" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule controllersMustResideInAnApplicationPackage =
            classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
                    .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );

    @ArchTest
    static final ArchRule controllersNamesMustHaveProperSuffix =
            classes().that().areAnnotatedWith( RestController.class )
                    .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );

    @ArchTest
    static final ArchRule controllersMustNotAccessRepositories =
            noClasses().that().areAnnotatedWith( RestController.class )
                    .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
                    .allowEmptyShould( false );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.library.dependencies.SliceAssignment;
import com.tngtech.archunit.library.dependencies.SliceIdentifier;
import org.junit.jupiter.api.Test;

import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;

public class NoCycleTest {
    private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");

    private SliceAssignment inAllClasses() {
        return new SliceAssignment() {
            @Override
            public String getDescription() {
                return "every class in it's own slice";
            }

            @Override
            public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
                return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
            }
        };
    }

    @Test
    public void testNoCyclicDependenciesBetweenClasses() {
        slices().assignedFrom(inAllClasses())
                .namingSlices("$1[$2.$3]")
                .should().beFreeOfCycles()
                .check(importedClasses);
    }

    @Test
    public void testNoCyclicDependenciesBetweenPackages() {
        ArchRule rule = slices().matching("..solution.(*)..")
                .should().beFreeOfCycles().allowEmptyShould( true );
        rule.check(importedClasses);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.base.DescribedPredicate;
import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaField;
import com.tngtech.archunit.core.domain.JavaParameterizedType;
import com.tngtech.archunit.core.domain.JavaType;
import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchCondition;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.lang.ConditionEvents;
import com.tngtech.archunit.lang.SimpleConditionEvent;
import jakarta.persistence.*;
import lombok.extern.slf4j.Slf4j;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.List;

import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
@Slf4j
public class OnlyReferenceViaIDTest { //STORAGE_UNIT
    private static final String SHOPPING_CART_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingcart.domain";
    private static final String USER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.user.domain";
    private static final String ITEM_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.item.domain";
    private static final String ORDER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.order.domain";
    private static final String STORAGE_UNIT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.storageunit.domain";

    @ArchTest
    static final ArchRule idFieldsMustUseGenericId =
            fields()
                    .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
                    .and().areAnnotatedWith( Id.class )
                    .should().haveRawType( assignableTo( GenericId.class ) )
                    .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
                    .allowEmptyShould( true );


    private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
            annotatedWith( ManyToOne.class )
                    .or( annotatedWith( OneToOne.class ) )
                    .or( annotatedWith( Embedded.class ) )
                    .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );

    private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
            annotatedWith( OneToMany.class )
                    .or( annotatedWith( ManyToMany.class ) )
                    .or( annotatedWith( ElementCollection.class ) )
                    .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );


    private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
        String description = "an entity or value object from same aggregate, or a domain primitive";
        return new DescribedPredicate<>( description ) {
            @Override
            public boolean test( JavaClass type ) {
                // check if the class is an entity or value object, and resides in the allowed package
                if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
                    return false;
                }
                // a GenericId is always allowed
                if ( type.isAssignableTo( GenericId.class ) ) {
                    return true;
                }
                // a domain primitive is also always allowed
                if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
                    return true;
                }
                return type.getPackageName().startsWith( allowedPackage );
            }
        };
    }


    @ArchTest
    static final ArchRule shoppingCartToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_CART_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_CART_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule userToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( USER_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( USER_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule itemToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( ITEM_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( ITEM_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule orderToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule storageUnitToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( STORAGE_UNIT_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( STORAGE_UNIT_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );


    private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
        return new ArchCondition<JavaField>(
                "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
            @Override
            public void check( JavaField field, ConditionEvents events ) {
                JavaClass rawType = field.getRawType();
                String rawTypeName = rawType.getFullName();
                if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
                    return;
                }
                JavaType fieldType = field.getType();
                if ( !( fieldType instanceof JavaParameterizedType ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " is a raw List/Set without a type argument" ) );
                    return;
                }
                List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
                if ( typeArguments.isEmpty() ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " has no type arguments" ) );
                    return;
                }
                JavaType elementType = typeArguments.get( 0 );
                if ( !( elementType instanceof JavaClass ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " has an unknown element type" ) );
                    return;
                }
                JavaClass elementClass = (JavaClass) elementType;
                boolean hasAnnotation =
                        elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
                boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
                boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
                boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
                boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
                if ( !ok ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " refers to " + elementClass.getFullName()
                                    + " which is not a DP, or an entity/value object in " + allowedPackage ) );
                }
            }
        };
    }


    @ArchTest
    static final ArchRule shoppingCartToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_CART_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_CART_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule userToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( USER_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( USER_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule itemToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( ITEM_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( ITEM_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule orderToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule storageUnitToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( STORAGE_UNIT_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( STORAGE_UNIT_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

/**
 * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
 */

public class OwnTestsTest {
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

public class PackageStructureTest {

    private static final String[] REQUIRED_PACKAGES = {"user", "shoppingcart", "item", "order", "storageunit"};
    private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
    private JavaClasses importedClasses;


    @BeforeEach
    public void setUp() {
        importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
    }

    @Test
    void testRequiredPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage;
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredDomainPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected domain sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredApplicationPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected application sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\AddressTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateAddress;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;

class AddressTest {

    @Test
    public void testGetterAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        AddressType instance = instantiateAddress( street, city, plz );

        // then
        assertEquals( street, instance.getStreet() );
        assertEquals( city, instance.getCity() );
        assertEquals( plz, instance.getZipCode() );
    }

    @Test
    public void testFactoryValidAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        // then
        assertDoesNotThrow( () -> instantiateAddress( street, city, plz ) );
    }

    @Test
    public void testFactoryInvalidAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        // then
        assertThrows( ShopException.class, () -> instantiateAddress( null, city, plz ) );
        assertThrows( ShopException.class, () -> instantiateAddress( "", city, plz ) );
        assertThrows( ShopException.class, () -> instantiateAddress( street, null, plz ) );
        assertThrows( ShopException.class, () -> instantiateAddress( street, "", plz ) );
        assertThrows( ShopException.class, () -> instantiateAddress( street, city, null ) );
    }

    @Test
    public void testEqualityAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        AddressType instance1 = instantiateAddress( street, city, plz );
        AddressType instance2 = instantiateAddress( street, city, plz );
        AddressType instance3 = instantiateAddress( "Anderestr. 12", city, plz );
        AddressType instance4 = instantiateAddress( street, "AndereStadt", plz );
        AddressType instance5 = instantiateAddress( street, city, instantiateZipCode( "54321" ) );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
        assertNotEquals( instance1, instance4 );
        assertNotEquals( instance1, instance5 );
    }

    @Test
    public void testImmutabilityAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        AddressType instance = instantiateAddress( street, city, plz );

        // then
        try {
            instance.getClass().getMethod( "setStreet", String.class );
            fail( "setStreet method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setCity", String.class );
            fail( "setCity method should not exist" );

        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setZipCode", ZipCodeType.class );
            fail( "setZipCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\CurrencyTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateCurrency;

class CurrencyTest {

    @Test
    public void testGetQuantityCurrency() {
        // given
        Float inputQuantity = 10.0f;

        // when
        CurrencyType instance = instantiateCurrency( inputQuantity, "EUR" );

        // then
        assertEquals( inputQuantity, instance.getQuantity() );
    }

    @Test
    public void testGetCurrencyUnitCurrency() {
        // given
        String inputCurrencyUnit = "EUR";

        // when
        CurrencyType instance = instantiateCurrency( 10.0f, inputCurrencyUnit );

        // then
        assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
    }

    @Test
    public void testAddToCurrency() {
        // given
        CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
        CurrencyType instance3 = instantiateCurrency( 0.0f, "EUR" );

        // when
        CurrencyType result12 = instance1.add( instance2 );
        CurrencyType result13 = instance1.add( instance3 );

        // then
        assertEquals( 30.0f, result12.getQuantity() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
        assertEquals( 10.0f, result13.getQuantity() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
    }

    @Test
    public void testInvalidAddToCurrency() {
        // given
        CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 20.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
    }

    @Test
    public void testSubtractFromCurrency() {
        // given
        CurrencyType instance1 = instantiateCurrency( 30.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
        CurrencyType instance3 = instantiateCurrency( 0.0f, "EUR" );
        CurrencyType instance4 = instantiateCurrency( 30.0f, "EUR" );

        // when
        CurrencyType result12 = instance1.subtract( instance2 );
        CurrencyType result13 = instance1.subtract( instance3 );
        CurrencyType result14 = instance1.subtract( instance4 );

        // then
        assertEquals( 10.0f, result12.getQuantity() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
        assertEquals( 30.0f, result13.getQuantity() );
        assertEquals( "EUR", result13.getCurrencyUnit() );
        assertEquals( 0.0f, result14.getQuantity() );
        assertEquals( "EUR", result14.getCurrencyUnit() );
    }

    @Test
    public void testInvalidSubtractFromCurrency() {
        // given
        CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
        CurrencyType instance3 = instantiateCurrency( 5.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
        assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
    }

    @Test
    public void testMultiplyByCurrency() {
        // given
        CurrencyType instance = instantiateCurrency( 10.0f, "EUR" );

        // when
        CurrencyType result = instance.multiplyBy( 3 );

        // then
        assertEquals( 30.0f, result.getQuantity() );
        assertEquals( "EUR", result.getCurrencyUnit() );
    }

    @Test
    public void testFactoryValidCurrencyUnitCurrency() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiateCurrency( 10.0f, "EUR" ) );
    }

    @Test
    public void testFactoryInvalidCurrencyUnitCurrency() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateCurrency( -10.0f, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateCurrency( 10.0f, "USD" ) );
        assertThrows( ShopException.class, () -> instantiateCurrency( null, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateCurrency( 10.0f, null ) );
    }

    @Test
    public void testLargerThanCurrencyUnitCurrency() {
        // given
        CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
        CurrencyType instance3 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance4 = instantiateCurrency( 10.0f, "CHF" );

        // when
        // then
        assertTrue( instance2.largerThan( instance1 ) );
        assertFalse( instance1.largerThan( instance2 ) );
        assertFalse( instance1.largerThan( instance3 ) );
        assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
    }


    @Test
    public void testEqualityCurrencyUnitCurrency() {
        // given
        // when
        CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance3 = instantiateCurrency( 20.0f, "EUR" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutabilityCurrencyUnitCurrency() {
        // given
        // when
        CurrencyType instance = instantiateCurrency( 10.0f, "EUR" );

        // then
        try {
            instance.getClass().getMethod( "setQuantity", Float.class );
            fail( "setQuantity method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }

        try {
            instance.getClass().getMethod( "setCurrencyUnit", String.class );
            fail( "setCurrencyUnit method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

@ArchTag("domainPrimitivesUsageRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class DomainPrimitivesUsageRulesTest {
    private static final String EMAIL_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Email";
    private static final String CURRENCY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Currency";
    private static final String ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Address";

    @ArchTest
    static final ArchRule userShouldReferenceEmail =
            classes()
                    .that().haveSimpleName( "User" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( EMAIL_CLASS )
                    .because( "User should use Email instead of String" );

    @ArchTest
    static final ArchRule userShouldReferenceAddress =
            classes()
                    .that().haveSimpleName( "User" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( ADDRESS_CLASS )
                    .because( "User should use Address instead of whatever else" );

    @ArchTest
    static final ArchRule storageUnitShouldReferenceAddress =
            classes()
                    .that().haveSimpleName( "StorageUnit" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( ADDRESS_CLASS )
                    .because( "User should use Address instead of whatever else" );

    @ArchTest
    static final ArchRule itemShouldReferenceCurrency =
            classes()
                    .that().haveSimpleName( "Item" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( CURRENCY_CLASS )
                    .because( "Item should use Currency instead of float or whatever else" );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\EmailTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmail;

class EmailTest {

    @Test
    public void testToStringEmail() {
        // given
        String input = "test@example.com";

        // when
        EmailType instance = instantiateEmail( input );

        // then
        assertEquals( input, instance.toString() );
    }

    @Test
    public void testEqualityEmail() {
        // given
        // when
        EmailType instance1 = instantiateEmail( "test@example.com" );
        EmailType instance2 = instantiateEmail( "test@example.com" );
        EmailType instance3 = instantiateEmail( "different@example.com" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutabilityEmail() {
        // given
        // when
        EmailType instance = instantiateEmail( "test@example.com" );

        // then
        try {
            instance.getClass().getMethod( "setEmail", String.class );
            fail( "setEmail method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }



    @Test
    public void smokeTestForCopyConstructors() {
        // given
        EmailType email =
                instantiateEmail( "peter.schmidt@web.de" );

        // when
        EmailType emailOtherIdentifyer =
                email.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
        assertThrows( ShopException.class, () ->
                email.sameDomainDifferentIdentifyer( "p...eter" ) );
        EmailType emailOtherDomain =
                email.sameIdentifyerDifferentDomain( "web.ch" );
        assertThrows( ShopException.class, () ->
                email.sameIdentifyerDifferentDomain( "web.edu" ) );

        // then
        assertEquals( "p.e.t.e.r@web.de", emailOtherIdentifyer.toString() );
        assertEquals( "peter.schmidt@web.ch", emailOtherDomain.toString() );
    }


    @Test
    public void testFactoryValidEmail() {
        // given
        // when
        // then
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "99Z@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "GGGhh@s77.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "a@4.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "Max.Hammer@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "Max.Gideon.Hammer@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.this.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.de" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.at" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.ch" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.org" ) );
    }


    @Test
    public void testFactoryInvalidEmail() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateEmail( null ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "testexample.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "Max..Gideon.Hammer@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@examplecom" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@example..com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test#example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@example.42" ) );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\ZipCodeTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;

class ZipCodeTest {

    private String input1, input4;
    private ZipCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
            _04233, _02544, _99123, _56323, _79332;


    @BeforeEach
    public void setUp() {
        input1 = "12345";
        input4 = "49188";
        _12345 = FactoryMethodInvoker.instantiateZipCode( "12345" );
        _12345b = FactoryMethodInvoker.instantiateZipCode( "12345" );
        _23455 = FactoryMethodInvoker.instantiateZipCode( "23455" );
        _01234 = FactoryMethodInvoker.instantiateZipCode( "01234" );
        _01235 = FactoryMethodInvoker.instantiateZipCode( "01235" );
        _01238 = FactoryMethodInvoker.instantiateZipCode( "01238" );
        _01263 = FactoryMethodInvoker.instantiateZipCode( "01263" );
        _01213 = FactoryMethodInvoker.instantiateZipCode( "01213" );
        _01823 = FactoryMethodInvoker.instantiateZipCode( "01823" );
        _01312 = FactoryMethodInvoker.instantiateZipCode( "01312" );
        _04233 = FactoryMethodInvoker.instantiateZipCode( "04233" );
        _02544 = FactoryMethodInvoker.instantiateZipCode( "02544" );
        _99123 = FactoryMethodInvoker.instantiateZipCode( "99123" );
        _56323 = FactoryMethodInvoker.instantiateZipCode( "56323" );
        _79332 = FactoryMethodInvoker.instantiateZipCode( "79332" );

    }


    @Test
    public void testToStringZipCode() {
        // given
        // when
        ZipCodeType instance = instantiateZipCode( input1 );

        // then
        assertEquals( input1, instance.toString() );
    }

    @Test
    public void testFactoryValidZipCode() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiateZipCode( input1 ) );
    }

    @Test
    public void testFactoryInvalidZipCode() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateZipCode( "123456" ) );
        assertThrows( ShopException.class, () -> instantiateZipCode( "1234" ) );
        assertThrows( ShopException.class, () -> instantiateZipCode( "20000" ) );
        assertThrows( ShopException.class, () -> instantiateZipCode( null ) );
    }

    @Test
    public void testEqualityZipCode() {
        // given
        // when
        ZipCodeType instance1a = instantiateZipCode( input1 );
        ZipCodeType instance1b = instantiateZipCode( input1 );
        ZipCodeType instance4 = instantiateZipCode( input4 );

        // then
        assertEquals( instance1a, instance1b );
        assertNotEquals( instance1a, instance4 );
    }

    @Test
    public void testImmutabilityZipCode() {
        // given
        // when
        ZipCodeType instance = instantiateZipCode( input1 );

        // then
        try {
            instance.getClass().getMethod( "setzipCode", String.class );
            fail( "setzipCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }


    @Test
    public void smokeTestForDifference() {
        // given
        ZipCodeType instance1a = instantiateZipCode( input1 );
        ZipCodeType instance1b = instantiateZipCode( input1 );
        ZipCodeType instance12479 = instantiateZipCode( "12479" );
        ZipCodeType instance21456 = instantiateZipCode( "21456" );

        // when
        int differenceAB = instance1a.difference( instance1b );
        int difference12 = instance1a.difference( instance12479 );
        int difference23 = instance12479.difference( instance21456 );

        // then
        assertEquals( 0, differenceAB );
        assertTrue( difference12 > 0 );
        assertTrue( difference23 > difference12 );
    }


    @Test
    public void testZipCodeFirstDigit() {
        // given
        ZipCodeType instance1 = instantiateZipCode( input1 );
        ZipCodeType instance4 = instantiateZipCode( input4 );

        // when
        // then
        assertEquals( 1, instance1.getFirstDigitZipCode() );
        assertEquals( 4, instance4.getFirstDigitZipCode() );
    }



    @Test
    public void testInvalidParameters() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () ->
                _12345.difference( null ) );
    }


    @Test
    public void testSameZipCode() {
        // given
        // when
        int diff = _12345.difference( _12345b );

        // then
        assertEquals( 0, diff );
    }


    /**
     *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
     *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
     *        So, 56733 and 56734 have the same difference as 56733 and 56739.
     *      - The difference grows if more digits (counted from the right side) differ.
     *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
     *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
     *        53876 and 54876 have the same difference as 53876 and 57261.
     */
    @Test
    public void testZipCodeDifferenceInAllButFirstDigit() {
        // given
        // when
        int diff5a = _01234.difference( _01235 );
        int diff5b = _01234.difference( _01238 );
        int diff4a = _01234.difference( _01263 );
        int diff4b = _01234.difference( _01213 );
        int diff3a = _01234.difference( _01823 );
        int diff3b = _01234.difference( _01312 );
        int diff2a = _01234.difference( _04233 );
        int diff2b = _01234.difference( _02544 );

        // then
        assertEquals( diff5a, diff5b, "difference 01234-01235 must be the same as difference 01234-01238" );
        assertEquals( diff4a, diff4b, "difference 01234-01263 must be the same as difference 01234-01213" );
        assertEquals( diff3a, diff3b, "difference 01234-01823 must be the same as difference 01234-01312" );
        assertEquals( diff2a, diff2b, "difference 01234-04233 must be the same as difference 01234-02544" );

        assertTrue( diff5a < diff4a,
                "difference 01234-01235 must be smaller than difference 01234-01263" );
        assertTrue( diff4a < diff3a,
                "difference 01234-01263 must be smaller than difference 01234-01823" );
        assertTrue( diff3a < diff2a,
                "difference 01234-01823 must be smaller than difference 01234-04233" );
    }


    /**
     *      - However, the difference between 5abcd and 6rstu must be smaller than the one
     *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
     *        one between 5abcd and 9rstu.
     *      - This last condition reflects the fact the first digits of a zip code marks a region
     *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
     *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
     *        other.
     */
    @Test
    public void testZipCodedifferenceInFirstDigit() {
        // given
        // when
        int diff1_1 = _01234.difference( _99123 );
        int diff1_2 = _01234.difference( _23455 );
        int diff1_5 = _01234.difference( _56323 );
        int diff1_3 = _01234.difference( _79332 );

        // then
        assertTrue( diff1_1 < diff1_2,
                "difference 01234-99123 must be smaller than difference 01234-23455"  );
        assertTrue( diff1_2 < diff1_3,
                "difference 01234-23455 must be smaller than difference 01234-79332" );
        assertTrue( diff1_3 < diff1_5,
                "difference 01234-79332 must be smaller than difference 01234-56323"  );
    }



}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
package thkoeln.archilab.ecommerce.tests.e1restcalls;

import org.junit.jupiter.api.Test;
import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;


public class E1RestCallTableTest {

    private GenericTableSpecificationTests genericTableSpecificationTests = null;


    public E1RestCallTableTest() {
        this.genericTableSpecificationTests = new GenericTableSpecificationTests();
    }

    @Test
    public void restTest() throws Exception {
        genericTableSpecificationTests.testTableSpecification("E1" );
    }
}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\item\ItemCatalogTest.java ---
package thkoeln.archilab.ecommerce.tests.item;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.masterdata.*;

import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;


@SpringBootTest
public class ItemCatalogTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private ShoppingCartUseCases shoppingCartUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private StorageUnitUseCases storageUnitUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private StorageUnitTestHelper storageUnitTestHelper;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        itemTestHelper.addAllItems();
    }


    @Test
    public void testAddItemToCatalog() {
        // given
        UUID itemId4 = itemTestHelper.getItemId( 4 );
        CurrencyType sellingPrice4 = itemTestHelper.getSellingPrice( 4 );

        // when
        CurrencyType foundSellingPrice = itemCatalogUseCases.getSellingPrice( itemId4 );

        // then
        assertEquals( sellingPrice4, foundSellingPrice );
    }


    @Test
    public void testAddItemWithInvalidData() {
        // given
        String name = "SomeStuff";
        String description = "Some more explanation on the stuff";
        Float size = 5.0f;
        CurrencyType buyingPrice =
                FactoryMethodInvoker.instantiateCurrency( 5.0f, "EUR" );
        CurrencyType sellingPrice =
                FactoryMethodInvoker.instantiateCurrency( 10.0f, "EUR" );
        CurrencyType tooLowSellingPrice =
                FactoryMethodInvoker.instantiateCurrency( 4.0f, "EUR" );

        // when / then
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        null, description, size, buyingPrice, sellingPrice ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        "", description, size, buyingPrice, sellingPrice ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        name, null, size, buyingPrice, sellingPrice ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        name, "", size, buyingPrice, sellingPrice ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        name, description, size, null, sellingPrice ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        name, description, size, buyingPrice, null ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        name, description, size, buyingPrice, tooLowSellingPrice ) );
    }


    @Test
    public void testRemoveNonExistentItem() {
        // given item 2 is not in inventory anywhere - should be removable
        UUID nonExistentItemId = UUID.randomUUID();

        // when
        // then
        assertThrows( ShopException.class,
                () -> itemCatalogUseCases.removeItemFromCatalog( nonExistentItemId ) );
    }


    @Test
    public void testRemoveItemWithNoInventory() {
        // given item 0 is not in inventory anywhere - should be removable
        UUID itemId0 = itemTestHelper.getItemId( 0 );
        storageUnitTestHelper.addAllStorageUnits( true );

        // when
        assertDoesNotThrow( () -> itemCatalogUseCases.getSellingPrice( itemId0 ) );
        itemCatalogUseCases.removeItemFromCatalog( itemId0 );

        // then
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.getSellingPrice( itemId0 ) );
    }


    @Test
    public void testRemoveItemThatIsInInventory() {
        // given
        storageUnitTestHelper.addAllStorageUnits( false );
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
        UUID itemId3 = itemTestHelper.getItemId( 3 );
        UUID itemId4 = itemTestHelper.getItemId( 4 );
        storageUnitUseCases.addToInventory( storageUnitId0, itemId3, 3 );

        // then item 3 must not be removable, but item 4 must be removable
        assertThrows( ShopException.class,
                () -> itemCatalogUseCases.removeItemFromCatalog( itemId3 ) );
        assertDoesNotThrow( () -> itemCatalogUseCases.removeItemFromCatalog( itemId4 ) );
    }


    @Test
    public void testRemoveItemThatIsInOrder() {
        // given
        storageUnitTestHelper.addAllStorageUnits( false );
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
        UUID itemId4 = itemTestHelper.getItemId( 4 );
        EmailType userEmail4 =
                userTestHelper.getUserEmail( 4 );
        storageUnitUseCases.addToInventory( storageUnitId0, itemId4, 4 );

        // when user 4 adds 4x item 4 to his shopping cart and checks out ...
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail4, itemId4, 4 );
        shoppingCartUseCases.checkout( userEmail4 );

        // then item 4 must not be removable
        assertThrows( ShopException.class,
                () -> itemCatalogUseCases.removeItemFromCatalog( itemId4 ) );
    }


    @Test
    public void testClearItemCatalog() {
        // given
        UUID itemId4 = itemTestHelper.getItemId( 4 );

        // when
        itemCatalogUseCases.deleteItemCatalog();

        // then
        assertThrows( ShopException.class, () -> itemCatalogUseCases.getSellingPrice( itemId4 ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\order\OrderTest.java ---
package thkoeln.archilab.ecommerce.tests.order;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;


@SpringBootTest
public class OrderTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private ShoppingCartUseCases shoppingCartUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private StorageUnitUseCases storageUnitUseCases;
    @Autowired
    private OrderUseCases orderUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private StorageUnitTestHelper storageUnitTestHelper;

    private UUID nonExistingId1;
    private UUID nonExistingId2;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        itemTestHelper.addAllItems();
        storageUnitTestHelper.addAllStorageUnits( true );
        nonExistingId1 = UUID.randomUUID();
        nonExistingId2 = UUID.randomUUID();
    }


    @Test
    public void testOrderHistory() {
        // given
        UUID itemId1 = itemTestHelper.getItemId( 1 );
        UUID itemId2 = itemTestHelper.getItemId( 2 );
        EmailType userEmail7 =
                userTestHelper.getUserEmail( 7 );
        Map<UUID, Integer> orderHistoryBefore = orderUseCases.getOrderHistory( userEmail7 );

        // when
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail7, itemId1, 3 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail7, itemId2, 2 );
        shoppingCartUseCases.checkout( userEmail7 );
        Map<UUID, Integer> orderHistory1 =
                orderUseCases.getOrderHistory( userEmail7 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail7, itemId1, 6 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail7, itemId2, 2 );
        shoppingCartUseCases.checkout( userEmail7 );
        Map<UUID, Integer> orderHistory2 =
                orderUseCases.getOrderHistory( userEmail7 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail7, itemId1, 1 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail7, itemId2, 6 );
        shoppingCartUseCases.checkout( userEmail7 );
        Map<UUID, Integer> orderHistory3 =
                orderUseCases.getOrderHistory( userEmail7 );

        // then
        assertEquals( 0, orderHistoryBefore.size() );
        assertEquals( 2, orderHistory1.size() );
        assertEquals( 2, orderHistory2.size() );
        assertEquals( 2, orderHistory3.size() );
        assertEquals( 3, orderHistory1.get( itemId1 ) );
        assertEquals( 2, orderHistory1.get( itemId2 ) );
        assertEquals( 9, orderHistory2.get( itemId1 ) );
        assertEquals( 4, orderHistory2.get( itemId2 ) );
        assertEquals( 10, orderHistory3.get( itemId1 ) );
        assertEquals( 10, orderHistory3.get( itemId2 ) );
    }


    @Test
    public void testForEmptyOrderHistory() {
        // given
        EmailType userEmail4 =
                userTestHelper.getUserEmail( 4 );
        // when
        Map<UUID, Integer> orderHistory =
                orderUseCases.getOrderHistory( userEmail4 );
        // then
        assertEquals( 0, orderHistory.size() );
    }


    @Test
    public void testInvalidParamsForGetOrderQuantityOfItem() {
        // given
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );

        // when / then
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantityOfItem( null, null ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantityOfItem( nonExistingId1, null ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantityOfItem( null, nonExistingId2 ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantityOfItem( nonExistingId1, nonExistingId2 ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantityOfItem( storageUnitId0, null ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantityOfItem( storageUnitId0, nonExistingId2 ) );
    }


    @Test
    public void testInvalidParamsForGetStorageUnitIdForOrder() {
        // given / when / then
        assertThrows ( ShopException.class,
                () -> orderUseCases.getStorageUnitIdForOrder( null ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getStorageUnitIdForOrder( nonExistingId1 ) );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
package thkoeln.archilab.ecommerce.tests.owntests;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.jayway.jsonpath.JsonPath;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;

import static org.junit.jupiter.api.Assertions.assertEquals;


public class DomainPrimitiveJSONSerializationTest {



    @BeforeEach
    public void setUp() {
        // ... add own setup code here

    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * Email.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_Email_Serialization() throws Exception {
        // given
        ObjectMapper objectMapper = new ObjectMapper();
        Email email = (Email) Email.of("hallo@example.com");
        // when
        String json = objectMapper.writeValueAsString(email);
        // then
        String emailString = JsonPath.read(json, "$.emailString");
        assertEquals("hallo@example.com", emailString);
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * ZipCode.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_ZipCode_Serialization() throws Exception {

        // given
        ObjectMapper objectMapper = new ObjectMapper();
        ZipCode zipCode = (ZipCode) ZipCode.of("51545");

        // when
        String json = objectMapper.writeValueAsString(zipCode);
        // then
        String zipCodeString = JsonPath.read(json, "$.zipCodeString");
        assertEquals("51545", zipCodeString, "zipCode test failed");
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * Address.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_Address_Serialization() throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();
        ZipCode zipCode = (ZipCode) ZipCode.of("51545");
        String street = "Buchenweg 11";
        String city = "Gummersbach";
        Address address = (Address) Address.of(street, city, zipCode );

        // when
        String json = objectMapper.writeValueAsString(address);
        // then
        String zipCodeString = JsonPath.read(json, "$.zipCode.zipCodeString");
        String streetString = JsonPath.read(json, "$.street");
        String cityString = JsonPath.read(json, "$.city");
        assertEquals("51545", zipCodeString, "zipCode test failed");
        assertEquals(city, cityString);
        assertEquals(street,streetString);
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * Currency.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_Currency_Serialization() throws Exception {
        // given
        ObjectMapper objectMapper = new ObjectMapper();
        Currency currency = (Currency) Currency.of(5f, "EUR");

        // when
        String json = objectMapper.writeValueAsString(currency);
        // then
        Double quantity = JsonPath.read(json, "$.quantity");
        String currenyUnitString = JsonPath.read(json, "$.currencyUnit");
        assertEquals(5f, quantity);
        assertEquals("EUR", currenyUnitString);
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingCartRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.owntests;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.shoppingcart.application.ShoppingCartService;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;

import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;


@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class OwnShoppingCartRESTTest {
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private StorageUnitTestHelper storageUnitTestHelper;
    @Autowired
    private ShoppingCartUseCases shoppingCartUseCases;

    @Autowired
    private ShoppingCartRESTHelper shoppingCartRESTHelper;

    @Autowired
    private ShoppingCartService shoppingCartService;


    private Email email3;
    private String userName3;
    private UUID itemId2;
    private UUID itemId3;
    private ShoppingCart shoppingCart3;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        itemTestHelper.addAllItems();
        storageUnitTestHelper.addAllStorageUnits( true );

        // ... add own setup code here
        email3 = (Email) userTestHelper.getUser(3).getEmail();
        userName3 = userTestHelper.getUser(3).getName();
        itemId2 = itemTestHelper.getItemId(2);
        itemId3 = itemTestHelper.getItemId(3);
    }


    /**
     * Provide a test that implements a simple call to the REST endpoint (3):
     * <pre>
     *     GET /shoppingCarts?userId=<user id as uuid>
     * </pre>
     * - Use the {@link UserTestHelper} to obtain the email
     *   of some example user.
     * - Use your shopping cart service to add entries to the shopping cart of that person.
     * - then use the `ShoppingCartRESTHelper` to create the GET call, and check the results.
     * - (or do it by directly calling your REST controller, if you prefer)
     * @ throws Exception
     */
    @Test
    public void test_getQuery_ShoppingCart() throws Exception {
        // given
        shoppingCartUseCases.addItemToShoppingCart(email3, itemId2, 2);
        Map<UUID, Integer> expectedMap = Map.of(itemId2, 2);
        // when
        shoppingCartRESTHelper.getQueryShoppingCart(email3, expectedMap);
        // then
    }



    /**
     * Provide a test that implements the addition of one item to the shopping cart via
     * REST endpoint (6):
     * <pre>
     *     POST /shoppingCarts/{shoppingCart-Id}/positions
     * </pre>
     * You can test now "the other way around" as in test_getQuery_ShoppingCart():
     * - Use `ShoppingCartRESTHelper` to add items via REST, then use shopping cart service methods
     *   to check of the shopping cart contains the right stuff.
     * - (or do it by directly calling your REST controller, if you prefer)*
     * @ throws Exception
     */
    @Test
    public void test_post_ShoppingCartPositions() throws Exception {
        // given
        Map<ItemId, Integer> expectedMap = Map.of(new ItemId(itemId2), 2, new ItemId(itemId3), 3);
        shoppingCartUseCases.addItemToShoppingCart(email3, itemId3, 3);

        // when
        shoppingCart3 = shoppingCartService.getShoppingCart(email3);

        shoppingCartRESTHelper.addItemToShoppingCart(shoppingCart3.getId().getId(), itemId2, 2);
        Map<ItemId, Integer> isMap = shoppingCartService.getShoppingCartAsMap(email3);
        // then
        assertEquals(2, isMap.size());
        assertEquals(expectedMap.entrySet(), isMap.entrySet());
    }



    /**
     * Provide a test that implements the deletion of one item in the shopping cart via
     * REST endpoint (10):
     * <pre>
     *     DELETE /shoppingCarts/{shoppingCart-Id}/positions/{item-Id}
     * </pre>
     * This should be just a slight variation of the test_post_ShoppingCartPositions()
     * method, but instead of adding an item to the shopping cart, you delete it.*
     * @ throws Exception
     */
    @Test
    public void test_delete_ShoppingCartPositions() throws Exception {
        //
        Map<ItemId, Integer> expectedMap = Map.of(new ItemId(itemId3), 3);
        shoppingCartService.addItemToShoppingCart(email3,new ItemId(itemId3), 3);
        shoppingCartService.addItemToShoppingCart(email3, new ItemId(itemId2), 2);

        // when
        shoppingCart3 = shoppingCartService.getShoppingCart(email3);

        shoppingCartRESTHelper.deleteItemFromShoppingCart(shoppingCart3.getId().getId(), itemId2);
        Map<ItemId, Integer> isMap = shoppingCartService.getShoppingCartAsMap(email3);

        // then
        assertEquals(1, isMap.size());
        assertEquals(expectedMap.entrySet(), isMap.entrySet());
    }



    /**
     * Provide a test that implements the checkout of a shopping cart that can be served
     * by just 1 storage unit, using the REST endpoint (11):
     * <pre>
     *     POST /shoppingCarts/{shoppingCart-Id}/checkout
     * </pre>
     * - Use your shopping cart service to add entries to the shopping cart of some example user,
     * - then use the `ShoppingCartRESTHelper to post the checkout call, and to check the results.
     * - (or do it by directly calling your REST controller, if you prefer)*
     * @ throws Exception
     */
    @Test
    public void test_checkout_1_storageUnit() throws Exception {
        // given
        Map<UUID, Map<UUID, Integer>> expectedMap = Map.of(storageUnitTestHelper.getStorageUnitId(0) ,Map.of(itemId2, 2));
        shoppingCartUseCases.addItemToShoppingCart(email3, itemId2, 2);
        // when
        shoppingCart3 = shoppingCartService.getShoppingCart( email3);
        // then
        shoppingCartRESTHelper.checkout(shoppingCart3.getId().getId(), userName3, status().isCreated(), expectedMap);
    }



    /**
     * Provide a test that implements the checkout of a shopping cart that can only be served
     * by using 2 storage units, using the REST endpoint (11):
     * <pre>
     *     POST /shoppingCarts/{shoppingCart-Id}/checkout
     * </pre>
     * This should be just a slight variation of thetest_checkout_1_storageUnit() test.*
     * @ throws Exception
     */
    @Test
    public void test_checkout_2_storageUnits() throws Exception {
        // given
        UUID itemId3 = itemTestHelper.getItemId(7);
        UUID storageUnitId = storageUnitTestHelper.getStorageUnitId(0);
        UUID storageUnitId1 = storageUnitTestHelper.getStorageUnitId(3);

        Map<UUID, Map<UUID, Integer>> expectedMap = Map.of(storageUnitId,Map.of(itemId2, 2),
                storageUnitId1, Map.of(itemId3, 1));

        shoppingCartUseCases.addItemToShoppingCart(email3, itemId2, 2);
        shoppingCartUseCases.addItemToShoppingCart(email3, itemId3, 1);

        // when
        shoppingCart3 = shoppingCartService.getShoppingCart( email3);
        // then
        shoppingCartRESTHelper.checkout(shoppingCart3.getId().getId(), userName3, status().isCreated(), expectedMap);
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\CheckoutAcceptanceTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingcart;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * This test checks the management of inventory across storage units. It focuses on the
 * cases where more than one storage unit are needed to serve the shopping cart of a user.
 */
@Slf4j
@SpringBootTest
public class CheckoutAcceptanceTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private ShoppingCartUseCases shoppingCartUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private OrderUseCases orderUseCases;
    @Autowired
    private StorageUnitUseCases storageUnitUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private StorageUnitTestHelper storageUnitTestHelper;

    private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
                                map8_11_14_quantity_3_3_4,
                                map10_12_quantity_1_1, 
                                map11_quantity_1, 
                                map12_quantity_10,
                                map8_9_10_11_quantity_2_1_4_2;
    private EmailType userEmail3, userEmail6,
            userEmail2;
    private UUID itemId8, itemId9, itemId10, itemId11, itemId12,
            itemId14;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        itemTestHelper.addAllItems();
        storageUnitTestHelper.addAllStorageUnits( true );

        userEmail3 = userTestHelper.getUserEmail( 3 );
        userEmail6 = userTestHelper.getUserEmail( 6 );
        userEmail2 = userTestHelper.getUserEmail( 2 );

        itemId8 = itemTestHelper.getItemId( 8 );
        itemId9 = itemTestHelper.getItemId( 9 );
        itemId10 = itemTestHelper.getItemId( 10 );
        itemId11 = itemTestHelper.getItemId( 11 );
        itemId12 = itemTestHelper.getItemId( 12 );
        itemId14 = itemTestHelper.getItemId( 14 );

        map8_11_14_quantity_2_2_2 = new HashMap<>() {{
            put( itemId8, 2 );
            put( itemId11, 2 );
            put( itemId14, 2 );
        }};
        map8_11_14_quantity_3_3_4 = new HashMap<>() {{
            put( itemId8, 3 );
            put( itemId11, 3 );
            put( itemId14, 4 );
        }};
        map10_12_quantity_1_1 = new HashMap<>() {{
            put( itemId10, 1 );
            put( itemId12, 1 );
        }};
        map11_quantity_1 = new HashMap<>() {{
            put( itemId11, 1 );
        }};
        map12_quantity_10 = new HashMap<>() {{
            put( itemId12, 10 );
        }};
        map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
            put( itemId8, 2 );
            put( itemId9, 1 );
            put( itemId10, 4 );
            put( itemId11, 2 );
        }};

    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of inventory
     * across storage units, as specified in the StorageUnitTestHelper and in the README file.
     */
    @Test
    public void testClosestSingleStorageUnitWins() {
        log.info( "testClosestSingleStorageUnitWins" );

        // given
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail3, itemId8, 2 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail3, itemId11, 2 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail3, itemId14, 2 );
        // that basket could have been served from storage unit 4 or 7, but 4 is closer to the user
        UUID storageUnitId4 = storageUnitTestHelper.getStorageUnitId( 4 );

        // when
        Set<UUID> orderIds = shoppingCartUseCases.checkout( userEmail3 );

        // then
        checkStorageUnitIds( orderIds, storageUnitId4 );
        checkItemNumbers( orderIds, storageUnitId4, map8_11_14_quantity_2_2_2 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of inventory
     * across storage units, as specified in the StorageUnitTestHelper and in the README file.
     */
    @Test
    public void testStorageUnitWithEnoughCapacityWins() {
        log.info( "testStorageUnitWithEnoughCapacityWins" );

        // given
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail3, itemId8, 3 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail3, itemId11, 3 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail3, itemId14, 4 );
        // that basket could have been served from storage unit 4 or 7, 4 is closer to the user,
        // but only 7 has enough capacity
        UUID storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );

        // when
        Set<UUID> orderIds = shoppingCartUseCases.checkout( userEmail3 );

        // then
        checkStorageUnitIds( orderIds, storageUnitId7 );
        checkItemNumbers( orderIds, storageUnitId7, map8_11_14_quantity_3_3_4 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of inventory
     * across storage units, as specified in the StorageUnitTestHelper and in the README file.
     */
    @Test
    public void testTwoStorageUnits() {
        log.info( "testTwoStorageUnits" );

        // given
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail6, itemId10, 1 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail6, itemId11, 1 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail6, itemId12, 1 );
        // that basket needs two shipments (2 + 1 items) anyway, and there
        // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
        // closer. The smaller can then be served from 4 (closest), 7, or 8.
        UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
                // should cover map10_12_quantity_1_1
        UUID storageUnitId4 = storageUnitTestHelper.getStorageUnitId( 4 );
                // should cover map11_quantity_1

        // when
        Set<UUID> orderIds = shoppingCartUseCases.checkout( userEmail6 );

        // then
        checkStorageUnitIds( orderIds, storageUnitId5, storageUnitId4 );
        checkItemNumbers( orderIds, storageUnitId5, map10_12_quantity_1_1 );
        checkItemNumbers( orderIds, storageUnitId4, map11_quantity_1 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of inventory
     * across storage units, as specified in the StorageUnitTestHelper and in the README file.
     */
    @Test
    public void testTwoBigShipments() {
        log.info( "testTwoBigShipments" );

        // given
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail2, itemId8, 2 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail2, itemId9, 1 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail2, itemId10, 4 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail2, itemId11, 2 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail2, itemId12, 10 );
        // when
        Set<UUID> orderIds = shoppingCartUseCases.checkout( userEmail2 );
        UUID storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );
                // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 items
        UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
                // should cover map12_quantity_10 - the only storage unit with enough capacity for 10 items

        // then
        checkStorageUnitIds( orderIds, storageUnitId7, storageUnitId5 );
        checkItemNumbers( orderIds, storageUnitId7, map8_9_10_11_quantity_2_1_4_2 );
        checkItemNumbers( orderIds, storageUnitId5, map12_quantity_10 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of inventory
     * across storage units, as specified in the StorageUnitTestHelper and in the README file.
     */
    @Test
    public void testOnlyOneSolution() {
        log.info( "testOnlyOneSolution" );

        // given
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail6, itemId12, 10 );
        // when
        Set<UUID> orderIds = shoppingCartUseCases.checkout( userEmail6 );
        UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
        // should cover map12_quantity_10 - the only storage unit with enough capacity for 10 items

        // then
        checkStorageUnitIds( orderIds, storageUnitId5 );
        checkItemNumbers( orderIds, storageUnitId5, map12_quantity_10 );
    }



    private void checkItemNumbers( Set<UUID> orderIds, UUID storageUnitId, Map<UUID, Integer> expectedMap ) {
        UUID fittingOrderId = null;
        for ( UUID orderId : orderIds ) {
            UUID foundStorageUnitId = orderUseCases.getStorageUnitIdForOrder( orderId );
            if ( foundStorageUnitId.equals( storageUnitId ) ) {
                fittingOrderId = orderId;
                break;
            }
        }
        assertNotNull( fittingOrderId, "No fitting order found for storage unit " + storageUnitId );

        int totalExpected = 0;
        int totalActual = 0;
        for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
            totalExpected += entry.getValue();
        }
        log.info( "Check order numbers for item {} in storage unit {}", fittingOrderId, storageUnitId );
        for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
            UUID itemId = entry.getKey();
            Integer foundNumber =
                    orderUseCases.getOrderQuantityOfItem( fittingOrderId, itemId );
            assertEquals( entry.getValue(), foundNumber );
            totalActual += foundNumber;
        }
        // last check - do the total sums match?
        assertEquals( totalExpected, totalActual );
    }


    private void checkStorageUnitIds( Set<UUID> orderIds, UUID... expectedStorageUnitIds ) {
        assertEquals( expectedStorageUnitIds.length, orderIds.size() );
        Set<UUID> foundStorageUnitIds = new HashSet<>();
        for ( UUID orderId : orderIds ) {
            UUID storageUnitId = orderUseCases.getStorageUnitIdForOrder( orderId );
            foundStorageUnitIds.add( storageUnitId );
        }
        for ( UUID expectedStorageUnitId : expectedStorageUnitIds ) {
            assertTrue( foundStorageUnitIds.contains( expectedStorageUnitId ) );
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\ShoppingCartRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingcart;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmail;


@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class ShoppingCartRESTTest {
    @Autowired
    private StorageUnitUseCases storageUnitUseCases;
    @Autowired
    private ShoppingCartUseCases shoppingCartUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private StorageUnitTestHelper storageUnitTestHelper;
    @Autowired
    private MockMvc mockMvc;
    @Autowired
    private ShoppingCartRESTHelper shoppingCartRESTHelper;

    private EmailType nonExistingEmail;
    private final Map<UUID, Integer> emptyMap = new HashMap<>();

    private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
    private EmailType
            userEmail0,
            userEmail3,
            userEmail6,
            userEmail8;
    private String userName0, userName8;
    private UUID itemId0, itemId1, itemId2, itemId3, itemId5,
                 itemId7, itemId9, itemId11, nonExistentItemId;
    private UUID storageUnitId0, storageUnitId3, storageUnitId7, storageUnitId8;


    private static final ResultMatcher NOT_FOUND = status().isNotFound();
    private static final ResultMatcher OK = status().isOk();
    private static final ResultMatcher CREATED = status().isCreated();
    private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
    private static final ResultMatcher CONFLICT = status().isConflict();

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        itemTestHelper.addAllItems();
        storageUnitTestHelper.addAllStorageUnits( true );
        nonExistingEmail = instantiateEmail( "harry@sally.de" );

        userEmail0 = userTestHelper.getUserEmail( 0 );
        userEmail3 = userTestHelper.getUserEmail( 3 );
        userEmail6 = userTestHelper.getUserEmail( 6 );
        userEmail8 = userTestHelper.getUserEmail( 8 );
        userName0 = userTestHelper.getUserName( 0 );
        userName8 = userTestHelper.getUserName( 8 );

        itemId0 = itemTestHelper.getItemId( 0 );
        itemId1 = itemTestHelper.getItemId( 1 );
        itemId2 = itemTestHelper.getItemId( 2 );
        itemId3 = itemTestHelper.getItemId( 3 );
        itemId5 = itemTestHelper.getItemId( 5 );
        itemId7 = itemTestHelper.getItemId( 7 );
        itemId9 = itemTestHelper.getItemId( 9 );
        itemId11 = itemTestHelper.getItemId( 11 );
        nonExistentItemId = UUID.randomUUID();

        storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
        storageUnitId3 = storageUnitTestHelper.getStorageUnitId( 3 );
        storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );
        storageUnitId8 = storageUnitTestHelper.getStorageUnitId( 8 );

        map9_quantity_1 = new HashMap<>() {{
            put( itemId9, 1 );
        }};
        map5_quantity_2 = new HashMap<>() {{
            put( itemId5, 2 );
        }};
        map7_quantity_7 = new HashMap<>() {{
            put( itemId7, 7 );
        }};
        map9_11_quantity_2_2 = new HashMap<>() {{
            put( itemId9, 2 );
            put( itemId11, 2 );
        }};
    }


    @Test
    public void testInvalidShoppingCartBaseUris() throws Exception {
        // given
        String allShoppingCartsUri = "/shoppingCarts";
        String randomIdUri = "/shoppingCarts/" + UUID.randomUUID();
        String randomUserUUID = "/shoppingCarts?userId=" + UUID.randomUUID();
        String invalidUserUUID = "/shoppingCarts?userId=invalidUUID";
        String randomParamUri = "/shoppingCarts?randomParam=randomValue";

        // when
        // then
        mockMvc.perform( get( allShoppingCartsUri ) ).andExpect( status().isMethodNotAllowed() );
        mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomUserUUID ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( invalidUserUUID ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
    }


    @Test
    public void testInvalidPositionUris() throws Exception {
        // given
        UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail8, emptyMap );
        String randomPositionUri = "/shoppingCarts/" + shoppingCartId8.toString() + "/random";
        String randomItemUri = "/shoppingCarts/" + shoppingCartId8.toString()
                + "/positions/" + UUID.randomUUID();

        // when
        // then
        mockMvc.perform( post( randomPositionUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( delete( randomItemUri ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testInvalidAddToShoppingCart() throws Exception {
        // given
        Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
        expectedStartQuantityMap.put( itemId2, 19 );

        // when
        UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( userEmail0, emptyMap );
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId, itemId2, 6 );
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId, itemId2, 13 );

        // then
        shoppingCartRESTHelper.getQueryShoppingCart( userEmail0, expectedStartQuantityMap );

        // ... and check a couple of invalid cases
        shoppingCartRESTHelper.addItemToShoppingCart(
                shoppingCartId, nonExistentItemId, 12, NOT_FOUND );
        shoppingCartRESTHelper.addItemToShoppingCart(
                UUID.randomUUID(), itemId5, 12, NOT_FOUND );
        shoppingCartRESTHelper.addItemToShoppingCart(
                shoppingCartId, itemId5, -1, UNPROCESSABLE_ENTITY );

        // check if the shopping cart is still the same
        shoppingCartRESTHelper.getQueryShoppingCart( userEmail0, expectedStartQuantityMap );
    }


    @Test
    public void testInvalidCheckout_unavailableItem() throws Exception {
        // given
        UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( userEmail0, emptyMap );

        // when
        // productId0 is not available in the requested quantity (or rather, not at all)
        shoppingCartRESTHelper.addItemToShoppingCart(
                shoppingCartId, itemId0, 1, CREATED );

        // check if the shopping cart is still the same
        shoppingCartRESTHelper.checkout( shoppingCartId, null, CONFLICT, null );
    }


    @Test
    public void testInvalidCheckout_tooLittleInventory() throws Exception {
        // given
        UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( userEmail0, emptyMap );

        // when
        // There are only 10 pieces of productId1 available
        shoppingCartRESTHelper.addItemToShoppingCart(
                shoppingCartId, itemId1, 11, CREATED );

        // check if the shopping cart is still the same
        shoppingCartRESTHelper.checkout( shoppingCartId, null, CONFLICT, null );
    }



    @Test
    public void testDeleteItemFromShoppingCart() throws Exception {
        // given
        UUID shoppingCartId6 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, emptyMap );
        Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
        expectedQuantityMap1.put( itemId1, 1 );
        expectedQuantityMap1.put( itemId2, 2 );
        expectedQuantityMap1.put( itemId3, 3 );
        Map<UUID, Integer> quantityMap2 = new HashMap<>();
        quantityMap2.put( itemId1, 1 );
        quantityMap2.put( itemId3, 3 );

        // when
        // then
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId6, itemId1, 1 );
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId6, itemId2, 2 );
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId6, itemId3, 3 );
        shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, expectedQuantityMap1 );

        shoppingCartRESTHelper.deleteItemFromShoppingCart( shoppingCartId6, itemId2 );
        shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, quantityMap2 );
    }


    @Test
    public void testNoDoubleDelete() throws Exception {
        // given
        UUID shoppingCartId6 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, emptyMap );

        // when
        // then
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId6, itemId3, 3 );
        shoppingCartRESTHelper.deleteItemFromShoppingCart( shoppingCartId6, itemId3 );
        shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, new HashMap<>() );
        shoppingCartRESTHelper.deleteItemFromShoppingCart( shoppingCartId6, itemId3, NOT_FOUND );
    }


    @Test
    public void testAddRemoveItemsFromAndToShoppingCart() throws Exception {
        // given
        UUID shoppingCartId3 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail3, emptyMap );
        UUID shoppingCartId5 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, emptyMap );

        // when
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId3, itemId1, 2 );
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId3, itemId2, 3 );
        shoppingCartRESTHelper.deleteItemFromShoppingCart( shoppingCartId3, itemId1 );
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId3, itemId1, 1 );
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId3, itemId2, 6 );

        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId5, itemId1, 2 );
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId5, itemId2, 8 );
        shoppingCartRESTHelper.deleteItemFromShoppingCart( shoppingCartId5, itemId1 );
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId5, itemId1, 1 );
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId5, itemId2, 2 );

        // then
        // user3 has 1x itemId1 and 9x itemId2 expected in cart
        Map<UUID, Integer> expectedMap3 = new HashMap<>();
        expectedMap3.put( itemId1, 1 );
        expectedMap3.put( itemId2, 9 );
        shoppingCartRESTHelper.getQueryShoppingCart( userEmail3, expectedMap3 );

        // user6 has 1x itemId1 and 10x itemId2 in cart
        Map<UUID, Integer> expectedMap5 = new HashMap<>();
        expectedMap5.put( itemId1, 1 );
        expectedMap5.put( itemId2, 10 );
        shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, expectedMap5 );
    }


    @Test
    public void testNoDoubleCheckout() throws Exception {
        // given
        UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail8, emptyMap );

        // when
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId8, itemId2, 3 );

        // then
        shoppingCartRESTHelper.checkout( shoppingCartId8, userName8, CREATED, null );
        shoppingCartRESTHelper.checkout( shoppingCartId8, null, CONFLICT, null );
    }


    @Test
    public void testCheckout_1_Order() throws Exception {
        // given:
        // User 0 wants to buy 1x item 9. This is in storage unit 5, 7, and 8. Out of these,
        // storage unit 8 with zip code 89250 is closest to user 0 with zip code 02314.
        Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
            put( storageUnitId8, map9_quantity_1 );
        }};
        UUID shoppingCartId0 = shoppingCartRESTHelper.getQueryShoppingCart(
                userEmail0, null );
        int inventory9before =
                storageUnitUseCases.getAvailableInventory( storageUnitId8, itemId9 );

        // when
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId0, itemId9, 1 );
        shoppingCartRESTHelper.checkout( shoppingCartId0, userName0, CREATED, expectedOrders );
        int inventory9after =
                storageUnitUseCases.getAvailableInventory( storageUnitId8, itemId9 );

        // then
        assertEquals( 1, inventory9before - inventory9after );
    }


    @Test
    public void testCheckout_3_Order() throws Exception {
        // given:
        // User 8 (Felix Bauer) wants to buy 2x each of items 5, 9, 11; and 7x item 7.
        //       - items 9 and 11 can both be found in storage units 7 and 8. Storage units 7 (76532) is closer to
        //         the user (70173)
        //       - item 7 is available in storage units 1, 2, and 3, but only storage unit 3 has enough inventory.
        //       - item 5 is only available in storage unit 0.
        Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
            put( storageUnitId0, map5_quantity_2 );
            put( storageUnitId3, map7_quantity_7 );
            put( storageUnitId7, map9_11_quantity_2_2 );
        }};
        UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart(
                userEmail8, null );
        int inventory5before =
                storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId5 );
        int inventory7before =
                storageUnitUseCases.getAvailableInventory( storageUnitId3, itemId7 );
        int inventory9before =
                storageUnitUseCases.getAvailableInventory( storageUnitId7, itemId9 );
        int inventory11before =
                storageUnitUseCases.getAvailableInventory( storageUnitId7, itemId11 );

        // when
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId8, itemId5, 2 );
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId8, itemId7, 7 );
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId8, itemId9, 2 );
        shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId8, itemId11, 2 );
        shoppingCartRESTHelper.checkout( shoppingCartId8, userName8, CREATED, expectedOrders );
        int inventory5after =
                storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId5 );
        int inventory7after =
                storageUnitUseCases.getAvailableInventory( storageUnitId3, itemId7 );
        int inventory9after =
                storageUnitUseCases.getAvailableInventory( storageUnitId7, itemId9 );
        int inventory11after =
                storageUnitUseCases.getAvailableInventory( storageUnitId7, itemId11 );

        // then
        assertEquals( 2, inventory5before - inventory5after );
        assertEquals( 7, inventory7before - inventory7after );
        assertEquals( 2, inventory9before - inventory9after );
        assertEquals( 2, inventory11before - inventory11after );
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\ShoppingCartTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingcart;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.InsufficientInventoryException;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;


import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;

@SpringBootTest
public class ShoppingCartTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private ShoppingCartUseCases shoppingCartUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private StorageUnitUseCases storageUnitUseCases;
    @Autowired
    private OrderUseCases orderUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private StorageUnitTestHelper storageUnitTestHelper;

    private EmailType nonExistingEmail;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        itemTestHelper.addAllItems();

        nonExistingEmail = instantiateEmail( "this@nononono.de" );
    }


    @Test
    public void testInvalidAddToShoppingCart() {
        // given
        UUID nonExistentItemId = UUID.randomUUID();
        UUID itemId5 = itemTestHelper.getItemId( 5 );
        UUID itemId0 = itemTestHelper.getItemId( 0 );
        EmailType userEmail0 =
                userTestHelper.getUserEmail( 0 );
        storageUnitTestHelper.addAllStorageUnits( true );

        // then
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.addItemToShoppingCart(
                        nonExistingEmail, itemId0, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.addItemToShoppingCart(
                        null, itemId0, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.addItemToShoppingCart(
                        userEmail0, nonExistentItemId, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.addItemToShoppingCart(
                        userEmail0, null, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.addItemToShoppingCart(
                        userEmail0, itemId5, -1 ) );
    }


    @Test
    public void testInvalidRemoveFromShoppingCart() {
        // given
        UUID nonExistentItemId = UUID.randomUUID();
        UUID itemId5 = itemTestHelper.getItemId( 5 );
        UUID itemId1 = itemTestHelper.getItemId( 1 );
        UUID itemId2 = itemTestHelper.getItemId( 2 );
        storageUnitTestHelper.addAllStorageUnits( true );
        EmailType userEmail0 =
                userTestHelper.getUserEmail( 0 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail0, itemId1, 5 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail0, itemId2, 15 );

        // when
        shoppingCartUseCases.removeItemFromShoppingCart(
                userEmail0, itemId1, 2 );
        shoppingCartUseCases.removeItemFromShoppingCart(
                userEmail0, itemId2, 4 );
        shoppingCartUseCases.removeItemFromShoppingCart(
                userEmail0, itemId2, 7 );
        // now we should have 3x itemId1 and 4x itemId2 in the shopping cart

        // then
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.removeItemFromShoppingCart(
                        userEmail0, nonExistentItemId, 12 ) );
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.removeItemFromShoppingCart(
                        nonExistingEmail, itemId5, 12 ) );
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.removeItemFromShoppingCart(
                        userEmail0, itemId5, -1 ) );
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.removeItemFromShoppingCart(
                        userEmail0, itemId1, 4 ) );
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.removeItemFromShoppingCart(
                        userEmail0, itemId2, 5 ) );
    }


    @Test
    public void testAddRemoveItemsFromAndToShoppingCart() {
        // given
        UUID itemId1 = itemTestHelper.getItemId( 1 );
        UUID itemId2 = itemTestHelper.getItemId( 2 );
        EmailType userEmail3 =
                userTestHelper.getUserEmail( 3 );
        EmailType userEmail5 =
                userTestHelper.getUserEmail( 5 );

        // when user 3 ...
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail3, itemId1, 2 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail3, itemId2, 3 );
        shoppingCartUseCases.removeItemFromShoppingCart(
                userEmail3, itemId1, 2 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail3, itemId1, 1 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail3, itemId2, 6 );
        Map<UUID, Integer> cart3 = shoppingCartUseCases.getShoppingCartAsMap( userEmail3 );
        // user3 has 1x itemId1 and 9x itemId2 in cart

        // ... and when user 5 ...
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail5, itemId1, 2 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail5, itemId2, 8 );
        shoppingCartUseCases.removeItemFromShoppingCart(
                userEmail5, itemId1, 1 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail5, itemId2, 2 );
        Map<UUID, Integer> cart5 = shoppingCartUseCases.getShoppingCartAsMap( userEmail5 );
        // user5 has 1x itemId1 and 10x itemId2 in cart

        // then
        assertEquals( 2, cart3.size() );
        assertEquals( 1, cart3.get( itemId1 ) );
        assertEquals( 9, cart3.get( itemId2 ) );

        assertEquals( 2, cart5.size() );
        assertEquals( 1, cart5.get( itemId1 ) );
        assertEquals( 10, cart5.get( itemId2 ) );
    }


    @Test
    public void testShoppingCartValue() {
        // given
        UUID itemId3 = itemTestHelper.getItemId( 3 );
        UUID itemId6 = itemTestHelper.getItemId( 6 );
        UUID itemId8 = itemTestHelper.getItemId( 8 );
        CurrencyType price3 = itemTestHelper.getSellingPrice( 3 );
        CurrencyType price6 = itemTestHelper.getSellingPrice( 6 );
        CurrencyType price8 = itemTestHelper.getSellingPrice( 8 );
        EmailType userEmail3 =
                userTestHelper.getUserEmail( 3 );

        // when
        shoppingCartUseCases.addItemToShoppingCart( userEmail3, itemId3, 3 );
        shoppingCartUseCases.addItemToShoppingCart( userEmail3, itemId6, 2 );
        shoppingCartUseCases.addItemToShoppingCart( userEmail3, itemId8, 5 );
        // user3 has 3x itemId3, 2x itemId6 and 5x itemId8 in cart
        CurrencyType cartValue = shoppingCartUseCases.getShoppingCartAsCurrencyValue( userEmail3 );

        // then
        assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
                cartValue );
    }


    @Test
    public void testShoppingCartValueInvalid() {
        // given
        // when
        // then
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.getShoppingCartAsCurrencyValue( nonExistingEmail ) );
    }


    @Test
    public void testUnsuccessfulCheckout() {
        // given user buying item 0 (which is not in inventory), and user 1 buying item 1
        // in a bigger quantity (11) than available (10)
        storageUnitTestHelper.addAllStorageUnits( true );
        EmailType userEmail0 =
                userTestHelper.getUserEmail( 0 );
        EmailType userEmail1 =
                userTestHelper.getUserEmail( 1 );
        UUID itemId0 = itemTestHelper.getItemId( 0 );
        UUID itemId1 = itemTestHelper.getItemId( 1 );

        // when
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail0, itemId0, 1 );
        shoppingCartUseCases.addItemToShoppingCart(
                userEmail1, itemId1, 11 );

        // then
        assertThrows( InsufficientInventoryException.class,
                () -> shoppingCartUseCases.checkout( userEmail0 ) );
        assertThrows( InsufficientInventoryException.class,
                () -> shoppingCartUseCases.checkout( userEmail1 ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\storageunit\StorageUnitManagementTest.java ---
package thkoeln.archilab.ecommerce.tests.storageunit;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;

import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateAddress;


/**
 * This test checks the management and lifecycle of storage units.
 */
@SpringBootTest
public class StorageUnitManagementTest {
    @Autowired
    private StorageUnitUseCases storageUnitUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private StorageUnitTestHelper storageUnitTestHelper;

    private AddressType someAddress;
    private UUID nonExistingId1;
    private UUID nonExistingId2;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        itemTestHelper.addAllItems();

        someAddress = instantiateAddress( "Some Street", "Some City",
                instantiateZipCode( "90001" ) );
        nonExistingId1 = UUID.randomUUID();
        nonExistingId2 = UUID.randomUUID();
    }


    @Test
    public void testAddInvalidStorageUnit() {
        // given
        String name = "Lager1";

        // when
        // then
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.addNewStorageUnit(
                        null, someAddress ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.addNewStorageUnit(
                        "", someAddress ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.addNewStorageUnit(
                        name, null ) );
    }


    @Test
    public void testDeleteAllStorageUnitsWhenEmpty() {
        // given
        storageUnitTestHelper.addAllStorageUnits( false );
        UUID itemId9 = itemTestHelper.getItemId( 9 );
        UUID storageUnitId1 = storageUnitTestHelper.getStorageUnitId( 1 );
        UUID storageUnitId2 = storageUnitTestHelper.getStorageUnitId( 2 );

        // when
        int numOf1 = storageUnitUseCases.getAvailableInventory( storageUnitId1, itemId9 );
        int numOf2 = storageUnitUseCases.getAvailableInventory( storageUnitId2, itemId9 );

        // then
        assertEquals( 0, numOf1 );
        assertEquals( 0, numOf2 );
        storageUnitUseCases.deleteAllStorageUnits();
        // ... ids must be invalid now
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.getAvailableInventory( storageUnitId1, itemId9 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.getAvailableInventory( storageUnitId2, itemId9 ) );
    }


    @Test
    public void testDeleteAllStorageUnitsWhenFull() {
        // given
        storageUnitTestHelper.addAllStorageUnits( true );
        UUID itemId7 = itemTestHelper.getItemId( 7 );
        UUID storageUnitId1 = storageUnitTestHelper.getStorageUnitId( 1 );
        UUID storageUnitId2 = storageUnitTestHelper.getStorageUnitId( 2 );

        // when
        int numOf1 = storageUnitUseCases.getAvailableInventory( storageUnitId1, itemId7 );
        int numOf2 = storageUnitUseCases.getAvailableInventory( storageUnitId2, itemId7 );

        // then
        assertTrue( numOf1 == 3 );
        assertTrue( numOf2 == 3 );
        storageUnitUseCases.deleteAllStorageUnits();
        // ... ids must be invalid now
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.getAvailableInventory( storageUnitId1, itemId7 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.getAvailableInventory( storageUnitId2, itemId7 ) );
    }



    @Test
    public void testAddToInventory() {
        // given
        storageUnitTestHelper.addAllStorageUnits( true );
        UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in storage unit 0
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
        int originalInventory5 =
                storageUnitTestHelper.getStorageUnitInventory( 0, 5 );

        // when
        int inventory5before = storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId5 );
        storageUnitUseCases.addToInventory( storageUnitId0, itemId5, 23 );
        int inventory5after = storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId5 );
        storageUnitUseCases.addToInventory( storageUnitId0, itemId5, 0 );
        int inventory5after2 = storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId5 );

        // then
        assertEquals( originalInventory5, inventory5before );
        assertEquals( inventory5before + 23, inventory5after );
        assertEquals( inventory5after, inventory5after2 );
    }


    @Test
    public void testInvalidAddToInventory() {
        // given
        storageUnitTestHelper.addAllStorageUnits( true );
        UUID itemId2 = itemTestHelper.getItemId( 2 );
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );

        // when
        // then
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.addToInventory( nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.addToInventory(
                        storageUnitId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.addToInventory(
                        nonExistingId1, itemId2, 12 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.addToInventory(
                        storageUnitId0, itemId2, -1 ) );
    }


    @Test
    public void testRemoveFromInventory() {
        // given
        storageUnitTestHelper.addAllStorageUnits( true );
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
        UUID itemId0 = itemTestHelper.getItemId( 0 ); // 0 in storage unit 0
        UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in storage unit 0
        UUID itemId6 = itemTestHelper.getItemId( 6 ); // random >30 in storage unit 0
        int inventory0before =
                storageUnitTestHelper.getStorageUnitInventory( 0, 0 );
        int inventory5before =
                storageUnitTestHelper.getStorageUnitInventory( 0, 5 );
        int inventory6before =
                storageUnitTestHelper.getStorageUnitInventory( 0, 6 );

        // when
        storageUnitUseCases.removeFromInventory( storageUnitId0, itemId5, 1 );
        int inventory5after = storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId5 );
        storageUnitUseCases.removeFromInventory( storageUnitId0, itemId0, 0 );
        int inventory0after = storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId0 );
        storageUnitUseCases.removeFromInventory(
                storageUnitId0, itemId6, inventory6before );
        int inventory6after = storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId6 );

        // then
        assertEquals( inventory5before - 1, inventory5after );
        assertEquals( inventory0before, inventory0after );
        assertEquals( 0, inventory6after );
    }


    @Test
    public void testInvalidRemoveFromInventory() {
        // given
        storageUnitTestHelper.addAllStorageUnits( true );
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
        UUID itemId0 = itemTestHelper.getItemId( 0 ); // 0 in storage unit 0
        UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in storage unit 0
        int inventory5before =
                storageUnitTestHelper.getStorageUnitInventory( 0, 5 );

        // when
        // then
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.removeFromInventory( nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.removeFromInventory(
                        storageUnitId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.removeFromInventory(
                        nonExistingId1, itemId5, 12 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.removeFromInventory(
                        storageUnitId0, itemId5, -1 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.removeFromInventory(
                        storageUnitId0, itemId5, inventory5before + 1 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.removeFromInventory(
                        storageUnitId0, itemId0, 1 ) ); // already 0 in storage unit 0
    }


    @Test
    public void testChangeInventory() {
        // given
        storageUnitTestHelper.addAllStorageUnits( true );
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
        UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in storage unit 0

        // when
        storageUnitUseCases.changeInventoryTo( storageUnitId0, itemId5, 111 );
        int inventory5after = storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId5 );

        // then
        assertEquals( 111, inventory5after );
    }


    @Test
    public void testInvalidChangeInventory() {
        // given
        storageUnitTestHelper.addAllStorageUnits( true );
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
        UUID itemId6 = itemTestHelper.getItemId( 6 );

        // when
        // then
        assertThrows( ShopException.class, () -> storageUnitUseCases.changeInventoryTo(
                nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class, () -> storageUnitUseCases.changeInventoryTo(
                nonExistingId1, itemId6, 12 ) );
        assertThrows( ShopException.class, () -> storageUnitUseCases.changeInventoryTo(
                storageUnitId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class, () -> storageUnitUseCases.changeInventoryTo(
                storageUnitId0, itemId6, -1 ) );
    }


    @Test
    public void testEmptyStorageUnit() {
        // given
        storageUnitTestHelper.addAllStorageUnits( true );
        UUID storageUnitId9 = storageUnitTestHelper.getStorageUnitId( 9 ); // empty storage unit

        // when
        int totalInventory = 0;
        for ( int iItem = 0; iItem < itemTestHelper.numberOfItems(); iItem++ ) {
            UUID itemId = itemTestHelper.getItemId( iItem );
            totalInventory += storageUnitUseCases.getAvailableInventory(
                    storageUnitId9, itemId );
        }

        // then
        assertEquals( 0, totalInventory );
    }



}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
package thkoeln.archilab.ecommerce.tests.testtests;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.domain.JavaMethod;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.web.bind.annotation.RestController;
import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingCartRESTTest;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static org.springframework.test.util.AssertionErrors.assertTrue;

/**
 * This test checks if there are the appropriate tests in the test class(es) for domain
 * primitives.
 */

public class RulesForOwnTests {
    private JavaClass dpTestClass, restTestClass;
    private JavaClasses dpTestClasses, restTestClasses;
    private static final String STORAGE_UNIT_DOMAIN_PACKAGE =
            "thkoeln.archilab.ecommerce.solution.storageunit.domain";
    private static final String STORAGE_UNIT_CLASS_NAME =
            STORAGE_UNIT_DOMAIN_PACKAGE + ".StorageUnit";


    @BeforeEach
    public void setUp() throws Exception {
        dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
        restTestClass = new ClassFileImporter().importClass( OwnShoppingCartRESTTest.class );

        dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
        restTestClasses = new ClassFileImporter().importClasses( OwnShoppingCartRESTTest.class );
    }


    @Test
    public void ensureMinimumNumberOfTestMethods() {
        // given
        // when
        int dpTestMethodCount = getTestMethodCount( dpTestClass );
        int restTestMethodCount = getTestMethodCount( restTestClass );

        // then
        assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
                        + dpTestMethodCount,dpTestMethodCount >= 2 );
        assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
                        + restTestMethodCount, restTestMethodCount >= 5 );
    }

    private int getTestMethodCount( JavaClass testClass ) {
        int testMethodCount = 0;
        for ( JavaMethod method : testClass.getMethods() ) {
            if ( isTestMethod( method ) ) {
                testMethodCount++;
            }
        }
        return testMethodCount;
    }

    private boolean isTestMethod( JavaMethod method ) {
        return method.isAnnotatedWith( Test.class );
    }


    @Test
    public void dpTestsShouldReferenceTheRightClasses() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAssignableTo( ZipCodeType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( CurrencyType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( AddressType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( EmailType.class )
                .because( "DomainPrimitiveJSONSerializationTest should reference ZipCode, " +
                        "Currency, Email, and Address!" );
        rule.check( dpTestClasses );
    }


    @Test
    public void restTestsShouldReferenceEmail() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAssignableTo( EmailType.class )
                .because( "StorageUnitComparatorUnitTest should reference EmailType!" );
        rule.check( restTestClasses );
    }


    @Test
    public void restTestsShouldReferenceRESTControllers() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAnnotatedWith( RestController.class )
                .orShould().dependOnClassesThat()
                .areAssignableTo( ShoppingCartRESTHelper.class )
                .because( "StorageUnitComparatorUnitTest should call REST controllers! " +
                        "(either directly or via the ShoppingCartRESTHelper REST helper)" );
        rule.check( restTestClasses );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\user\UserRegistrationTest.java ---
package thkoeln.archilab.ecommerce.tests.user;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;


@SpringBootTest
public class UserRegistrationTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;

    private EmailType nonExistingEmail;
    private AddressType someAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        nonExistingEmail = instantiateEmail( "this@nononono.de" );
        someAddress = instantiateAddress( "Some Street", "Some City",
                instantiateZipCode( "90001" ) );
    }

    @Test
    public void testAllUsersRegistered() {
        // given
        userTestHelper.registerAllUsers();
        EmailType email3 =
                userTestHelper.getUserEmail( 3 );
        String name3 = userTestHelper.getUserName( 3 );
        AddressType address3 = userTestHelper.getUserAddress( 3 );

        // when
        UserType user3 = userRegistrationUseCases.getUserData(
                email3 );

        // then
        Assertions.assertEquals( name3, user3.getName() );
        Assertions.assertEquals( email3, user3.getEmail() );
        Assertions.assertEquals( address3, user3.getAddress() );
    }


    @Test
    public void testRegisterUserWithDuplicateEmail() {
        // given
        userTestHelper.registerAllUsers();
        AddressType address5 = userTestHelper.getUserAddress( 5 );
        EmailType email5 =
                userTestHelper.getUserEmail( 5 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.register( "Gandalf The Grey",
                        email5, address5 ) );
    }


    @Test
    public void testRegisterUserWithDuplicateNameOrAddress() {
        // given
        userTestHelper.registerAllUsers();
        EmailType newEmail =
                instantiateEmail( "some@this.de" );
        AddressType address2 = userTestHelper.getUserAddress( 2 );
        String name2 = userTestHelper.getUserName( 2 );

        // when
        // then
        assertDoesNotThrow( () ->
                userRegistrationUseCases.register( name2, newEmail, address2 ) );
    }


    @Test
    public void testRegisterUserWithInvalidData() {
        // given
        EmailType email5 =
                userTestHelper.getUserEmail( 5 );
        AddressType address5 = userTestHelper.getUserAddress( 5 );
        String name5 = userTestHelper.getUserName( 5 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.register( null, email5, address5 ) );
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.register("", email5, address5 ) );
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.register( name5, null, address5 ) );
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.register( name5, email5, null ) );
    }


    @Test
    public void testChangeAddressWithInvalidData() {
        // given
        userTestHelper.registerAllUsers();
        AddressType address7 = userTestHelper.getUserAddress( 7 );
        EmailType email7 =
                userTestHelper.getUserEmail( 7 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.changeAddress( nonExistingEmail, address7 ) );
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.changeAddress( null, address7 ) );
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.changeAddress( email7, null ) );
    }


    @Test
    public void testGetDataForNonexistingEmail() {
        // given
        userTestHelper.registerAllUsers();

        // when
        // then
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.getUserData( nonExistingEmail ) );
    }


    @Test
    public void testDeleteUsersNoMoreUsers() {
        // given
        userTestHelper.registerAllUsers();
        EmailType email0 =
                userTestHelper.getUserEmail( 0 );


        // when
        userRegistrationUseCases.deleteAllUsers();

        // then
        assertThrows( ShopException.class, () -> userRegistrationUseCases.getUserData(
                email0 ) );
    }


    @Test
    public void testChangeAddressSuccessful() {
        // given
        userTestHelper.registerAllUsers();
        EmailType email6 =
                userTestHelper.getUserEmail( 6 );

        // when
        userRegistrationUseCases.changeAddress( email6, someAddress );
        UserType newUser6 =
                userRegistrationUseCases.getUserData( email6 );

        // then
        Assertions.assertEquals( email6, newUser6.getEmail() );
        Assertions.assertEquals( someAddress, newUser6.getAddress() );
    }


    @Test
    public void testChangeAddressForNonexistingEmail() {
        // given
        userTestHelper.registerAllUsers();

        // when
        // then
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.changeAddress( nonExistingEmail, someAddress ) );
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\user\UserRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.user;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.web.servlet.MockMvc;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.*;

import java.util.UUID;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class UserRESTTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private MockMvc mockMvc;

    private UUID randomId;
    private EmailType nonExistingEmail;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();

        nonExistingEmail = FactoryMethodInvoker.instantiateEmail(
                "harry@sally.de" );
        randomId = UUID.randomUUID();
    }


    @Test
    public void testInvalidUserUris() throws Exception {
        // given
        String allUsersUri = "/users";
        String randomIdUri = "/users/" +  randomId;
        String nonExistingEmailUri = "/users?email=" + nonExistingEmail;
        String randomParamUri = "/users?randomParam=randomValue";

        // when
        // then
        mockMvc.perform( get( allUsersUri ) ).andExpect( status().isMethodNotAllowed() );
        mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( nonExistingEmailUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
    }


    @Test
    public void testRandomUserId() throws Exception {
        // given
        String invalidUri = "/users/" +  randomId;

        // when
        // then
        mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testQueryUser() throws Exception {
        // given
        EmailType email4 =
                userTestHelper.getUserEmail( 4 );
        String userUri4 = "/users?email=" + email4;

        // when
        UserType user4 = userRegistrationUseCases.getUserData( email4 );
        String name = userTestHelper.getUserName( 4 );
        AddressType address4 = userTestHelper.getUserAddress( 4 );

        // then (check using JSONPath)
        mockMvc.perform( get( userUri4 ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.name" ).value( name ) )
                // id is position 0 (cannot be tested with current API structure), name is position 1,
                // email is 2, address is 3)
                .andExpect( jsonPath( "$..emailString" ).value( email4.toString() ) )
                .andExpect( jsonPath( "$..city" ).value( address4.getCity() ) )
                .andExpect( jsonPath( "$..zipCodeString" ).value(
                        address4.getZipCode().toString() ) );
    }

}


[RESPONSE]:
# Code Review - Smells

## Duplication
**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Currency.java**
- Zeile 48: `if(this.currencyUnit.name().equals(otherCurrency.getCurrencyUnit()) == false)` (Original: Zeile 48)
- Zeile 56: `if(this.currencyUnit.name().equals(otherCurrency.getCurrencyUnit()) == false)` (Duplikat von Zeile 48)
- Zeile 80: `if(this.currencyUnit.name().equals(otherCurrency.getCurrencyUnit()) == false)` (Duplikat von Zeile 48)

**Begründung:** Drei mal identische Überprüfung der Währungseinheit. Könnte in eine private Methode ausgelagert werden.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Email.java**
- Zeile 87: `if (emailAsString.contains(".."))` (Original)
- Zeile 109: `!emailAsString.matches(".*\\.\\.{2,}.*")` (Duplikat)

**Begründung:** Doppelte Prüfung auf aufeinanderfolgende Punkte in der Email-Validierung.

## Negative Conditionals
**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Currency.java**
- Zeile 48: `if(this.currencyUnit.name().equals(otherCurrency.getCurrencyUnit()) == false)`
- Zeile 56: `if(this.currencyUnit.name().equals(otherCurrency.getCurrencyUnit()) == false)`
- Zeile 80: `if(this.currencyUnit.name().equals(otherCurrency.getCurrencyUnit()) == false)`
- Zeile 90: `if(isValidCurrency(currencyUnit) == false)`

**Begründung:** Verwendung von `== false` anstelle des Negationsoperators `!` macht den Code weniger lesbar.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java**
- Zeile 81: `if (isZipCodeValid(zipCodeAsString) == false)`

**Begründung:** Verwendung von `== false` anstelle von `!`.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ItemService.java**
- Zeilen 77-79: Methode `itemIdNotExisting` mit doppelter Negation: `return !(itemId != null && itemRepository.existsById(itemId))`

**Begründung:** Doppelte Negation macht die Logik schwer verständlich. Besser: `return itemId == null || !itemRepository.existsById(itemId)`.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\StorageUnitService.java**
- Zeile 130: `if(itemService.itemIdNotExisting(itemId))`
- Zeile 189: `if(itemService.itemIdNotExisting(itemId))`

**Begründung:** Verwendung einer negativ formulierten Methode (`itemIdNotExisting`) in Bedingungen, was die Lesbarkeit beeinträchtigt.

## Anemic Entity
**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\Item.java**
- **Anemic Entity** - Die Klasse enthält nur Datenfelder mit Gettern/Settern und keine Geschäftslogik.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\User.java**
- **Anemic Entity** - Bis auf eine statische Validierungsmethode enthält die Klasse nur Datenfelder mit Gettern/Settern.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\InventoryLevel.java**
- **Anemic Entity** - Die Klasse enthält nur Datenfelder mit Gettern/Settern.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPosition.java**
- **Anemic Entity** - Die Klasse enthält nur Datenfelder mit Gettern/Settern.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPosition.java**
- **Anemic Entity** - Die Klasse enthält nur Datenfelder mit Gettern/Settern.

**Hinweis:** Die Klassen ShoppingCart, StorageUnit und Order enthalten Geschäftslogik und sind daher nicht anämisch.

ENDE
Generated by deepseek-reasoner
-----------------------------------