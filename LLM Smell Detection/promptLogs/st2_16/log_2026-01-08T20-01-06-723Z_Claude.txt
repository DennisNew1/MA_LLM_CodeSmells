--- DATE: 8.1.2026, 21:01:06 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
    Architektur: 4-Layer (Eric Evans).
    Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
    Regeln:
    1. Begründe kurz jeden Fund.
    4. Gruppiere nach Datei (mit Pfad). 
    2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
    3. Keine Code-Wiederholung, nur Referenzen.
    5. Wenn fertig, schreibe "ENDE".



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ClientNotFoundException.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class ClientNotFoundException extends RuntimeException {
    public ClientNotFoundException(String email) {
        super("Client not found for email: " + email);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\EmailAddress.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Objects;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED) // Für JPA
public class EmailAddress implements EmailAddressType {

    @Column(name = "email_identifier")
    private String identifier;

    @Column(name = "email_domain")
    private String domain;

    private static final String[] ALLOWED_TLDS = { "de", "at", "ch", "com", "org" };

    public static EmailAddress of(String emailAddressAsString) {
        if (emailAddressAsString == null)
            throw new ShopException("Email address must not be null");

        if (emailAddressAsString.contains(" "))
            throw new ShopException("Email must not contain whitespace");

        if (emailAddressAsString.chars().filter(ch -> ch == '@').count() != 1)
            throw new ShopException("Email must contain exactly one '@'");

        String[] parts = emailAddressAsString.split("@");
        if (parts.length != 2)
            throw new ShopException("Email must contain exactly one '@'");

        String identifier = parts[0];
        String domain = parts[1];

        if (identifier.isEmpty() || domain.isEmpty())
            throw new ShopException("Identifier and domain must not be empty");

        if (!identifier.matches(".*[A-Za-z0-9].*") || !domain.matches(".*[A-Za-z0-9].*"))
            throw new ShopException("Identifier and domain must contain alphanumeric characters");

        if (identifier.contains("..") || domain.contains(".."))
            throw new ShopException("Identifier and domain must not contain consecutive dots");

        if (!domain.contains("."))
            throw new ShopException("Domain must contain at least one dot");

        String[] domainParts = domain.split("\\.");
        String tld = domainParts[domainParts.length - 1];
        boolean tldAllowed = false;
        for (String allowed : ALLOWED_TLDS) {
            if (allowed.equalsIgnoreCase(tld)) {
                tldAllowed = true;
                break;
            }
        }
        if (!tldAllowed)
            throw new ShopException("Domain must end with one of the allowed TLDs");

        if (!emailAddressAsString.matches("^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+$"))
            throw new ShopException("Email contains invalid characters");

        return new EmailAddress(identifier, domain);
    }

    private EmailAddress(String identifier, String domain) {
        this.identifier = identifier;
        this.domain = domain;
    }

    @Override
    public EmailAddressType sameIdentifyerDifferentDomain(String domainString) {
        return EmailAddress.of(this.identifier + "@" + domainString);
    }

    @Override
    public EmailAddressType sameDomainDifferentIdentifyer(String identifyerString) {
        return EmailAddress.of(identifyerString + "@" + this.domain);
    }

    @Override
    public String toString() {
        return identifier + "@" + domain;
    }

    @JsonValue
    public String getValue() {
        return toString();
    }

    @JsonCreator
    public static EmailAddress fromJson(String value) {
        return of(value);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof EmailAddress that)) return false;
        return Objects.equals(identifier, that.identifier) && Objects.equals(domain, that.domain);
    }

    @Override
    public int hashCode() {
        return Objects.hash(identifier, domain);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\EmailMissingException.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.METHOD_NOT_ALLOWED)
public class EmailMissingException extends RuntimeException {
    public EmailMissingException() {
        super("Email address is required.");
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.Locale;
import java.util.Objects;

@JsonIgnoreProperties(ignoreUnknown = true)  // ← verhindert Fehler bei "formatted"
@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED) // notwendig für Hibernate
public class Money implements MoneyType {

    @Column(name = "amount", nullable = false)
    private Float amount;

    @Column(name = "currencyUnit", nullable = false)
    private String currencyUnit;

    public static Money of(Float amount, String currencyUnit) {
        if (amount == null) {
            throw new ShopException("Amount must not be null");
        }
        if (amount < 0) {
            throw new ShopException("Amount must not be negative");
        }
        if (currencyUnit == null) {
            throw new ShopException("Currency unit must not be null");
        }
        if (!currencyUnit.equals("EUR") && !currencyUnit.equals("CHF")) {
            throw new ShopException("Currency unit must be EUR or CHF");
        }
        return new Money(amount, currencyUnit);
    }

    private Money(Float amount, String currencyUnit) {
        this.amount = amount;
        this.currencyUnit = currencyUnit;
    }

    @Override
    public Float getAmount() {
        return amount;
    }

    @Override
    public String getCurrencyUnit() {
        return currencyUnit;
    }

    @Override
    public MoneyType add(MoneyType otherMoney) {
        validateOperation(otherMoney);
        return Money.of(this.amount + otherMoney.getAmount(), currencyUnit);
    }

    @Override
    public MoneyType subtract(MoneyType otherMoney) {
        validateOperation(otherMoney);
        if (otherMoney.getAmount() > this.amount) {
            throw new ShopException("Cannot subtract: otherMoney is greater than this");
        }
        return Money.of(this.amount - otherMoney.getAmount(), currencyUnit);
    }

    @Override
    public MoneyType multiplyBy(int factor) {
        if (factor < 0) {
            throw new ShopException("Factor must not be negative");
        }
        return Money.of(this.amount * factor, currencyUnit);
    }

    @Override
    public boolean largerThan(MoneyType otherMoney) {
        validateOperation(otherMoney);
        return this.amount > otherMoney.getAmount();
    }

    private void validateOperation(MoneyType otherMoney) {
        if (otherMoney == null) {
            throw new ShopException("Other money must not be null");
        }
        if (!this.currencyUnit.equals(otherMoney.getCurrencyUnit())) {
            throw new ShopException("Currency units must match");
        }
    }

    @Override
    public String toString() {
        return amount + " " + currencyUnit;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Money)) return false;
        Money money = (Money) o;
        return Objects.equals(amount, money.amount) &&
                Objects.equals(currencyUnit, money.currencyUnit);
    }

    @Override
    public int hashCode() {
        return Objects.hash(amount, currencyUnit);
    }

    @JsonIgnore
    public String getFormatted() {
        String symbol = switch (currencyUnit) {
            case "EUR" -> "€";
            case "CHF" -> "CHF";
            default -> currencyUnit;
        };
        // Hier .2f: immer zwei Nachkommastellen, z.B. 12.00
        // replace '.' durch ',' für deutsche Schreibweise
        return String.format(Locale.getDefault(), "%.2f", amount) + " " + symbol;
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PhysicalAddress.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import java.util.Objects;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED) // <- wichtig für JPA
public class PhysicalAddress implements PhysicalAddressType {

    @Column(name = "street")
    private String street;

    @Column(name = "city")
    private String city;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "zipCode", column = @Column(name = "zip_code"))
    })
    private ZipCode zipCode;

    // Factory-Methode für Tests (Reflection)
    public static PhysicalAddress of(String street, String city, ZipCode zipCode) {
        return ofInternal(street, city, zipCode);
    }

    // Factory-Methode für Interface-Nutzung
    public static PhysicalAddress of(String street, String city, ZipCodeType zipCode) {
        if (!(zipCode instanceof ZipCode)) {
            throw new ShopException("Provided ZipCodeType is not a valid ZipCode instance");
        }
        return ofInternal(street, city, (ZipCode) zipCode);
    }

    // Gemeinsame Validierung
    private static PhysicalAddress ofInternal(String street, String city, ZipCode zipCode) {
        if (street == null || street.trim().isEmpty()) throw new ShopException("Street must not be null or empty");
        if (city == null || city.trim().isEmpty()) throw new ShopException("City must not be null or empty");
        if (zipCode == null) throw new ShopException("ZipCode must not be null");
        return new PhysicalAddress(street.trim(), city.trim(), zipCode);
    }

    // privater Konstruktor für Factory
    private PhysicalAddress(String street, String city, ZipCode zipCode) {
        this.street = street;
        this.city = city;
        this.zipCode = zipCode;
    }

    @Override
    public String getStreet() {
        return street;
    }

    @Override
    public String getCity() {
        return city;
    }

    @Override
    public ZipCodeType getZipCode() {
        return zipCode;
    }

    @Override
    public String toString() {
        return street + ", " + zipCode.toString() + " " + city;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof PhysicalAddress that)) return false;
        return Objects.equals(street, that.street) &&
                Objects.equals(city, that.city) &&
                Objects.equals(zipCode, that.zipCode);
    }

    @Override
    public int hashCode() {
        return Objects.hash(street, city, zipCode);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import java.util.Objects;

@Embeddable
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class ZipCode implements ZipCodeType {

    @Column(name = "zip_code")
    private String zipCode;

    private ZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    public static ZipCode of(String zipCodeAsString) {
        if (zipCodeAsString == null) {
            throw new ShopException("ZipCode cannot be null");
        }

        if (!zipCodeAsString.matches("\\d{5}")) {
            throw new ShopException("ZipCode must be exactly 5 digits");
        }

        if (zipCodeAsString.endsWith("0000")) {
            throw new ShopException("ZipCode must not end with 0000");
        }

        return new ZipCode(zipCodeAsString);
    }

    @Override
    public int difference(ZipCodeType otherZipCode) {
        if (otherZipCode == null) throw new ShopException("Zip code must not be null");

        String other = otherZipCode.toString();

        if (zipCode.equals(other)) return 0;

        for (int i = 0; i < zipCode.length(); i++) {
            if (zipCode.charAt(i) != other.charAt(i)) {
                if (i == 0) {
                    int thisDigit = Character.getNumericValue(zipCode.charAt(0));
                    int otherDigit = Character.getNumericValue(other.charAt(0));
                    int rawDiff = Math.abs(thisDigit - otherDigit);
                    int wrappedDiff = Math.min(rawDiff, 10 - rawDiff);
                    return 10 + wrappedDiff; // Stelle 0 = höchste Priorität
                }
                return zipCode.length() - i; // Stelle 4 (ganz rechts) → 1, Stelle 3 → 2, ...
            }
        }

        return 0;
    }






    @Override
    public Integer getFirstDigitZipCode() {
        return Integer.parseInt(zipCode.substring(0, 1));
    }

    @Override
    public String toString() {
        return zipCode;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ZipCode)) return false;
        ZipCode zipCode1 = (ZipCode) o;
        return Objects.equals(zipCode, zipCode1.zipCode);
    }

    @Override
    public int hashCode() {
        return Objects.hash(zipCode);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
 */
package thkoeln.archilab.ecommerce;

import jakarta.persistence.Column;
import jakarta.persistence.MappedSuperclass;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

import java.io.Serializable;
import java.util.UUID;

@MappedSuperclass
@Getter
@EqualsAndHashCode(of = "id")
@ToString(of = "id")
public abstract class GenericId implements Serializable {
    @Column(nullable = false, updatable = false)
    private final UUID id;

    protected GenericId() {
        this( UUID.randomUUID() );
    }

    protected GenericId( UUID id ) {
        this.id = id;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
 */
package thkoeln.archilab.ecommerce;

import jakarta.persistence.AttributeConverter;

import java.util.UUID;
import java.util.function.Function;


public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
    private final Function<UUID, T> factory;

    protected GenericIdConverter( Function<UUID, T> factory ) {
        this.factory = factory;
    }

    @Override
    public UUID convertToDatabaseColumn( T attribute ) {
        return attribute == null ? null : attribute.getId();
    }

    @Override
    public T convertToEntityAttribute( UUID dbData ) {
        return dbData == null ? null : factory.apply( dbData );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\InsufficientStockException.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
 */
package thkoeln.archilab.ecommerce;

/**
 * Exception is thrown if the item's stock level is not sufficient to serve the order.
 */
public class InsufficientStockException extends ShopException {
    public InsufficientStockException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
 */
package thkoeln.archilab.ecommerce;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class ProjectApplication {

	/**
	 * Entry method
	 * @param args
	 */
	public static void main(String[] args) {
		SpringApplication.run(ProjectApplication.class, args);
	}
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
 */
package thkoeln.archilab.ecommerce;

public class ShopException extends RuntimeException {
    public ShopException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.client.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

@Service
public class ClientAdapterService implements ClientRegistrationUseCases {

    private final ClientRegistrationService clientRegistrationService;

    public ClientAdapterService(ClientRegistrationService clientRegistrationService) {
        this.clientRegistrationService = clientRegistrationService;
    }

    @Override
    public void register(String name, EmailAddressType emailAddress, PhysicalAddressType physicalAddress) {
        clientRegistrationService.register(name, emailAddress, physicalAddress);
    }

    @Override
    public void changeAddress(EmailAddressType clientEmailAddress, PhysicalAddressType physicalAddress) {
        clientRegistrationService.changeAddress(clientEmailAddress, physicalAddress);
    }

    @Override
    public ClientType getClientData(EmailAddressType clientEmailAddress) {
        return clientRegistrationService.getClientData(clientEmailAddress);
    }

    @Override
    public void deleteAllClients() {
        clientRegistrationService.deleteAllClients();
    }

    public ClientResponseDTO getClientByEmailAddress(String emailString) {
        EmailAddress email = EmailAddress.of(emailString);
        var client = clientRegistrationService.getClientByEmail(email);
        return ClientResponseDTO.from(client);
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientController.java ---
package thkoeln.archilab.ecommerce.solution.client.application;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import thkoeln.archilab.ecommerce.domainprimitives.EmailMissingException;

@RestController
@RequestMapping("/clients")
public class ClientController {

    private final ClientAdapterService clientAdapterService;

    public ClientController(ClientAdapterService clientAdapterService) {
        this.clientAdapterService = clientAdapterService;
    }

    @GetMapping
    public ResponseEntity<ClientResponseDTO> getClientByEmail(@RequestParam(required = false) String emailAddress) {
        if (emailAddress == null || emailAddress.isBlank()) {
            throw new EmailMissingException();
        }
        return ResponseEntity.ok(clientAdapterService.getClientByEmailAddress(emailAddress));
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientRegistrationService.java ---
package thkoeln.archilab.ecommerce.solution.client.application;

import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.*;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

@Service
@Transactional
public class ClientRegistrationService {
    private final ClientRepository clientRepository;

    public ClientRegistrationService(ClientRepository clientRepository) {
        this.clientRepository = clientRepository;
    }

    public void register(String name, EmailAddressType emailAddress, PhysicalAddressType physicalAddress) {
        if (name == null || name.trim().isEmpty()) {
            throw new ShopException("Name must not be empty");
        }

        if (emailAddress == null) {
            throw new ShopException("Email address must not be null");
        }

        if (physicalAddress == null) {
            throw new ShopException("Address must not be null");
        }

        EmailAddress email = EmailAddress.of(emailAddress.toString());
        if (clientRepository.findByEmail(email).isPresent()) {
            throw new ShopException("Client with this email already exists.");
        }

        PhysicalAddress address = PhysicalAddress.of(
                physicalAddress.getStreet(),
                physicalAddress.getCity(),
                ZipCode.of(physicalAddress.getZipCode().toString())
        );

        Client client = new Client(name, email, address);
        clientRepository.save(client);
    }

    public void changeAddress(EmailAddressType clientEmailAddress, PhysicalAddressType physicalAddress) {
        if (clientEmailAddress == null) {
            throw new ShopException("Client email address must not be null");
        }

        if (physicalAddress == null) {
            throw new ShopException("Address must not be null");
        }

        EmailAddress email = EmailAddress.of(clientEmailAddress.toString());
        Client client = clientRepository.findByEmail(email)
                .orElseThrow(() -> new ShopException("Client not found"));

        PhysicalAddress newAddress = PhysicalAddress.of(
                physicalAddress.getStreet(),
                physicalAddress.getCity(),
                ZipCode.of(physicalAddress.getZipCode().toString())
        );

        client.updateAddress(newAddress);
        clientRepository.save(client);
    }

    public ClientType getClientData(EmailAddressType clientEmailAddress) {
        if (clientEmailAddress == null) {
            throw new ShopException("Client email address must not be null");
        }

        EmailAddress email = EmailAddress.of(clientEmailAddress.toString());
        Client client = clientRepository.findByEmail(email)
                .orElseThrow(() -> new ShopException("Client not found"));

        return client;
    }

    public void deleteAllClients() {
        clientRepository.deleteAll();
    }

    public Client getClientByEmail(EmailAddress email) {
        return clientRepository.findByEmail(email)
                .orElseThrow(() -> new ClientNotFoundException(email.toString()));
    }

    public ClientType getClientByEmail(EmailAddressType clientEmailAddress) {
        if (clientEmailAddress == null) {
            throw new EmailMissingException();
        }

        EmailAddress email = EmailAddress.of(clientEmailAddress.toString());

        return clientRepository.findByEmail(email)
                .orElseThrow(() -> new ClientNotFoundException(email.toString()));
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientResponseDTO.java ---
package thkoeln.archilab.ecommerce.solution.client.application;

import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;

import java.util.UUID;

public class ClientResponseDTO {
    public UUID id;
    public String name;
    public EmailAddressDTO emailAddress;
    public PhysicalAddressDTO physicalAddress;

    public static ClientResponseDTO from(Client client) {
        ClientResponseDTO dto = new ClientResponseDTO();
        dto.id = client.getId().getId(); // statt client.getId().toUUID()
        dto.name = client.getName();
        dto.emailAddress = new EmailAddressDTO((EmailAddress) client.getEmailAddress());
        dto.physicalAddress = new PhysicalAddressDTO((PhysicalAddress) client.getPhysicalAddress());
        return dto;
    }



    public static class EmailAddressDTO {
        public String emailAddressString;

        public EmailAddressDTO(EmailAddress email) {
            this.emailAddressString = email.toString();
        }
    }

    public static class PhysicalAddressDTO {
        public String street;
        public String city;
        public ZipCodeDTO zipCode;

        public PhysicalAddressDTO(PhysicalAddress address) {
            this.street = address.getStreet();
            this.city = address.getCity();
            this.zipCode = new ZipCodeDTO((ZipCode) address.getZipCode());
        }
    }

    public static class ZipCodeDTO {
        public String zipCodeString;

        public ZipCodeDTO(ZipCode zipCode) {
            this.zipCodeString = zipCode.toString();
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\Client.java ---
package thkoeln.archilab.ecommerce.solution.client.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

@Entity
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Client implements ClientType {

    @EmbeddedId
    private ClientId id;

    private String name;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "identifier", column = @Column(name = "email_identifier")),
            @AttributeOverride(name = "domain", column = @Column(name = "email_domain"))
    })
    private EmailAddress email;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "street", column = @Column(name = "street")),
            @AttributeOverride(name = "city", column = @Column(name = "city")),
            @AttributeOverride(name = "zipCode.zipCode", column = @Column(name = "zip_code"))
    })
    private PhysicalAddress address;

    public Client(String name, EmailAddress email, PhysicalAddress address) {
        this.id = new ClientId();
        this.name = name;
        this.email = email;
        this.address = address;
    }

    public void updateAddress(PhysicalAddress newAddress) {
        this.address = newAddress;
    }

    @Override
    public EmailAddressType getEmailAddress() {
        return this.email;
    }

    @Override
    public PhysicalAddressType getPhysicalAddress() {
        return this.address;
    }

    public String getPostalCode() {
        return address.getZipCode().toString();
    }

}

// Nur erreichbar, wenn clientId vorhanden ist
/** @GetMapping
public ResponseEntity<ShoppingBasketResponseDTO> getBasketByClientId(@RequestParam(required = false) UUID clientId) {
if (clientId == null) {
return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).build();
}

try {
ShoppingBasketResponseDTO dto = shoppingBasketAdapterService.getShoppingBasketForClient(clientId);
return ResponseEntity.ok(dto);
} catch (ShopException e) {
return ResponseEntity.status(HttpStatus.NOT_FOUND).build(); // oder BAD_REQUEST
}

}
 */

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ClientId.java ---
package thkoeln.archilab.ecommerce.solution.client.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "client_id"))
public class ClientId extends GenericId {
    public ClientId(UUID id) {
        super(id);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ClientIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.client.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ClientIdConverter extends GenericIdConverter<ClientId> {
    public ClientIdConverter() {
        super(ClientId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ClientRepository.java ---
package thkoeln.archilab.ecommerce.solution.client.domain;

import org.springframework.data.jpa.repository.JpaRepository;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;

import java.util.Optional;

public interface ClientRepository extends JpaRepository<Client, ClientId> {
    Optional<Client> findByEmail(EmailAddress emailAddress);

    boolean existsByEmail(EmailAddress clientEmailAddress);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;

import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.UUID;

@Service
@Transactional
public class FulfillmentCenterAdapterService implements FulfillmentCenterUseCases {

    private final FulfillmentCenterService domainService;

    public FulfillmentCenterAdapterService(FulfillmentCenterService domainService) {
        this.domainService = domainService;
    }

    @Override
    public UUID addNewFulfillmentCenter(String name, PhysicalAddressType addressType) {
        if (name == null || name.isBlank()) {
            throw new ShopException("Name must not be null or blank");
        }
        if (addressType == null) {
            throw new ShopException("Address must not be null");
        }

        // Defaultbereich (z. B. 0–9), da Interface keine Parameter für PLZ-Range erlaubt
        int fromZipDigit = 0;
        int toZipDigit = 9;

        PhysicalAddress address = PhysicalAddress.of(
                addressType.getStreet(),
                addressType.getCity(),
                ZipCode.of(addressType.getZipCode().toString())
        );

        return domainService.create(name, address, fromZipDigit, toZipDigit);
    }

    @Override
    public void deleteAllFulfillmentCenters() {
        domainService.deleteAll();
    }

    @Override
    public void addToStock(UUID fulfillmentCenterId, UUID itemId, int addedQuantFor) {
        if (fulfillmentCenterId == null || itemId == null) {
            throw new ShopException("IDs must not be null");
        }
        if (addedQuantFor < 0) {
            throw new ShopException("Quantity must not be negative");
        }
        domainService.add(fulfillmentCenterId, itemId, addedQuantFor);
    }

    @Override
    public void removeFromStock(UUID fulfillmentCenterId, UUID itemId, int removedQuantFor) {
        if (fulfillmentCenterId == null || itemId == null) {
            throw new ShopException("IDs must not be null");
        }
        if (removedQuantFor < 0) {
            throw new ShopException("Quantity must not be negative");
        }
        domainService.remove(fulfillmentCenterId, itemId, removedQuantFor);
    }

    @Override
    public void changeStockTo(UUID fulfillmentCenterId, UUID itemId, int newTotalQuantFor) {
        if (fulfillmentCenterId == null || itemId == null) {
            throw new ShopException("IDs must not be null");
        }
        if (newTotalQuantFor < 0) {
            throw new ShopException("Quantity must not be negative");
        }
        domainService.setStock(fulfillmentCenterId, itemId, newTotalQuantFor);
    }

    @Override
    public int getAvailableStock(UUID fulfillmentCenterId, UUID itemId) {
        if (fulfillmentCenterId == null || itemId == null) {
            throw new ShopException("IDs must not be null");
        }
        return domainService.getStock(fulfillmentCenterId, itemId);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterQueryImplService.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;

import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenter;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterRepository;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.queryport.FulfillmentCenterQueryPort;

import java.util.List;
import java.util.UUID;

@Service
@Transactional
public class FulfillmentCenterQueryImplService implements FulfillmentCenterQueryPort {

    private final FulfillmentCenterRepository fulfillmentCenterRepository;

    public FulfillmentCenterQueryImplService(FulfillmentCenterRepository fulfillmentCenterRepository) {
        this.fulfillmentCenterRepository = fulfillmentCenterRepository;
    }

    @Override
    public boolean isItemInStock(UUID itemId) {
        return fulfillmentCenterRepository.findAll().stream()
                .anyMatch(fc -> fc.getStock(itemId) > 0);
    }

    public List<FulfillmentCenter> getAllFulfillmentCenters() {
        return fulfillmentCenterRepository.findAll();
    }

    @Override
    public UUID findSuitableFulfillmentCenter(String zipCode) {
        if (zipCode == null || !zipCode.matches("\\d{5}")) {
            throw new IllegalArgumentException("Invalid zip code");
        }

        int firstDigit = Integer.parseInt(zipCode.substring(0, 1));

        return fulfillmentCenterRepository.findAll().stream()
                .filter(fc -> fc.servesZipDigit(firstDigit))
                .findFirst()
                .map(fc -> fc.getId().getId())
                .orElseThrow(() -> new IllegalArgumentException("No suitable center found"));
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterService.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenter;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterId;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterRepository;
import thkoeln.archilab.ecommerce.solution.item.queryport.ItemQueryPort;

import java.util.UUID;

@Service
public class FulfillmentCenterService {
    private final FulfillmentCenterRepository centerRepo;
    private final ItemQueryPort itemQueryPort;

    public FulfillmentCenterService(FulfillmentCenterRepository centerRepo, ItemQueryPort itemQueryPort) {
        this.centerRepo = centerRepo;
        this.itemQueryPort = itemQueryPort;
    }

    public UUID create(String name, PhysicalAddress address, int fromZipDigit, int toZipDigit) {
        FulfillmentCenter fc = new FulfillmentCenter(name, address, fromZipDigit, toZipDigit);
        centerRepo.save(fc);
        return fc.getId().getId();
    }

    public void deleteAll() {
        centerRepo.deleteAll();
    }

    public UUID findByZip(String zipCodeStr) {
        if (zipCodeStr == null || !zipCodeStr.matches("\\d{5}")) {
            throw new ShopException("Invalid zip code");
        }
        int digit = Integer.parseInt(zipCodeStr.substring(0, 1));
        return centerRepo.findAll().stream()
                .filter(c -> c.servesZipDigit(digit))
                .findFirst()
                .map(c -> c.getId().getId())
                .orElseThrow(() -> new ShopException("No suitable center found"));
    }

    public void add(UUID centerId, UUID itemId, int quantity) {
        FulfillmentCenter center = getCenter(centerId);
        if (!itemQueryPort.itemExists(itemId)) throw new ShopException("Item not found");
        center.addStock(itemId, quantity);
        centerRepo.save(center);
    }

    public void remove(UUID centerId, UUID itemId, int quantity) {
        FulfillmentCenter center = getCenter(centerId);
        if (!itemQueryPort.itemExists(itemId)) throw new ShopException("Item not found");
        center.removeStock(itemId, quantity);
        centerRepo.save(center);
    }

    public void setStock(UUID centerId, UUID itemId, int newQuantity) {
        FulfillmentCenter center = getCenter(centerId);
        if (!itemQueryPort.itemExists(itemId)) throw new ShopException("Item not found");
        center.setStock(itemId, newQuantity);
        centerRepo.save(center);
    }

    public int getStock(UUID centerId, UUID itemId) {
        FulfillmentCenter center = getCenter(centerId);
        if (!itemQueryPort.itemExists(itemId)) throw new ShopException("Item not found");
        return center.getStock(itemId);
    }

    private FulfillmentCenter getCenter(UUID uuid) {
        if (uuid == null) throw new ShopException("Center ID must not be null");
        return centerRepo.findById(new FulfillmentCenterId(uuid))
                .orElseThrow(() -> new ShopException("Center not found"));
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\StockLevelQueryImplService.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;

import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.queryport.FulfillmentCenterQueryPort;
import thkoeln.archilab.ecommerce.solution.item.queryport.StockLevelQueryPort;

import java.util.UUID;

@Service
@Transactional
public class StockLevelQueryImplService implements StockLevelQueryPort {

    private final FulfillmentCenterQueryPort fulfillmentCenterQueryPort;

    public StockLevelQueryImplService(FulfillmentCenterQueryPort fulfillmentCenterQueryPort) {
        this.fulfillmentCenterQueryPort = fulfillmentCenterQueryPort;
    }

    @Override
    public boolean isItemInStock(UUID itemId) {
        return fulfillmentCenterQueryPort.isItemInStock(itemId);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenter.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.InsufficientStockException;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.*;

@Entity
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class FulfillmentCenter {

    @EmbeddedId
    private FulfillmentCenterId id = new FulfillmentCenterId();

    private String name;

    private int fromPostalCodeFirstDigit;
    private int toPostalCodeFirstDigit;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "street", column = @Column(name = "street")),
            @AttributeOverride(name = "city", column = @Column(name = "city")),
            @AttributeOverride(name = "zipCode.zipCode", column = @Column(name = "zip_code"))
    })
    private PhysicalAddress address;

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    private List<StockLevel> stock = new ArrayList<>();

    public FulfillmentCenter(String name, PhysicalAddress address,
                             int fromPostalCodeFirstDigit, int toPostalCodeFirstDigit) {
        this.name = name;
        this.address = address;
        this.fromPostalCodeFirstDigit = fromPostalCodeFirstDigit;
        this.toPostalCodeFirstDigit = toPostalCodeFirstDigit;
    }

    public boolean servesZipDigit(int firstDigit) {
        return firstDigit >= fromPostalCodeFirstDigit && firstDigit <= toPostalCodeFirstDigit;
    }

    public void addStock(UUID itemId, int quantity) {
        if (quantity < 0) throw new IllegalArgumentException("Quantity must be >= 0");

        Optional<StockLevel> levelOpt = stock.stream()
                .filter(s -> s.getItemId().equals(itemId))
                .findFirst();

        if (levelOpt.isPresent()) {
            levelOpt.get().increase(quantity);
        } else {
            stock.add(new StockLevel(itemId, quantity));
        }
    }

    public void removeStock(UUID itemId, int quantity) {
        if (quantity < 0) throw new ShopException("Quantity must not be negative");

        Optional<StockLevel> level = stock.stream()
                .filter(s -> s.getItemId().equals(itemId))
                .findFirst();

        if (quantity == 0) {
            // Wenn es keine Menge gibt, die entfernt werden soll → nichts tun
            if (level.isEmpty()) return;
            return;
        }

        StockLevel existing = level.orElseThrow(() -> new InsufficientStockException("Item not found in stock"));

        if (existing.getQuantity() < quantity) {
            throw new InsufficientStockException("Not enough stock");
        }

        existing.decrease(quantity);
    }


    public void setStock(UUID itemId, int newQuantity) {
        Optional<StockLevel> levelOpt = stock.stream()
                .filter(s -> s.getItemId().equals(itemId))
                .findFirst();

        if (levelOpt.isPresent()) {
            levelOpt.get().setQuantity(newQuantity);
        } else {
            stock.add(new StockLevel(itemId, newQuantity));
        }
    }

    public int getStock(UUID itemId) {
        return stock.stream()
                .filter(s -> s.getItemId().equals(itemId))
                .findFirst()
                .map(StockLevel::getQuantity)
                .orElse(0);
    }

    public PhysicalAddressType getAddress() {
        return this.address;
    }


    public Set<ItemId> fulfillableShoppingBasketPositions(Map<ItemId, Integer> itemQuantityMap) {
        Set<ItemId> fulfillableItems = new HashSet<>();

        for (Map.Entry<ItemId, Integer> entry : itemQuantityMap.entrySet()) {
            ItemId itemId = entry.getKey();
            int requestedQuantity = entry.getValue();

            boolean canFulfill = stock.stream()
                    .anyMatch(stockLevel ->
                            stockLevel.getItemId().equals(itemId.getId()) &&
                                    stockLevel.getQuantity() >= requestedQuantity
                    );

            if (canFulfill) {
                fulfillableItems.add(itemId);
            }
        }

        return fulfillableItems;
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterComparator.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;

import java.util.Comparator;
import java.util.Map;

public class FulfillmentCenterComparator implements Comparator<FulfillmentCenter> {

    private final Map<ItemId, Integer> shoppingBasket;
    private final ZipCode clientZipCode;

    public FulfillmentCenterComparator(Map<ItemId, Integer> shoppingBasket, ZipCode clientZipCode) {
        this.shoppingBasket = shoppingBasket;
        this.clientZipCode = clientZipCode;
    }

    @Override
    public int compare(FulfillmentCenter fc1, FulfillmentCenter fc2) {
        int count1 = fc1.fulfillableShoppingBasketPositions(shoppingBasket).size();
        int count2 = fc2.fulfillableShoppingBasketPositions(shoppingBasket).size();

        if (count1 != count2) {
            return Integer.compare(count2, count1); // mehr ist besser
        }

        int dist1 = clientZipCode.difference(fc1.getAddress().getZipCode());
        int dist2 = clientZipCode.difference(fc2.getAddress().getZipCode());

        return Integer.compare(dist1, dist2); // näher ist besser
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterId.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "fulfillment_center_id"))
public class FulfillmentCenterId extends GenericId {
    public FulfillmentCenterId(UUID id) {
        super(id);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class FulfillmentCenterIdConverter extends GenericIdConverter<FulfillmentCenterId> {
    public FulfillmentCenterIdConverter() {
        super(FulfillmentCenterId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterRepository.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import org.springframework.data.jpa.repository.JpaRepository;

public interface FulfillmentCenterRepository extends JpaRepository<FulfillmentCenter, FulfillmentCenterId> {
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\StockLevel.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.InsufficientStockException;

import java.util.UUID;

@Entity
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class StockLevel {

    @EmbeddedId
    private StockLevelId id;

    private UUID itemId;

    private int quantities;

    public StockLevel(UUID itemId, int quantities) {
        this.id = new StockLevelId();
        this.itemId = itemId;
        this.quantities = quantities;
    }

    public UUID getItemId() {
        return this.itemId;
    }

    public void increase(int amount) {
        if (amount < 0) throw new IllegalArgumentException("Cannot increase by negative amount");
        this.quantities += amount;
    }

    public void decrease(int amount) {
        if (amount < 0 || amount > this.quantities) {
            throw new InsufficientStockException("Not enough stock available to decrease");
        }
        this.quantities -= amount;
    }

    public void setQuantity(int quantity) {
        if (quantity < 0) throw new IllegalArgumentException("Quantity cannot be negative");
        this.quantities = quantity;
    }

    public int getQuantity() {
        return this.quantities;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\StockLevelId.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "stock_level_id"))
public class StockLevelId extends GenericId {
    public StockLevelId(UUID id) {
        super(id);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\StockLevelIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class StockLevelIdConverter extends GenericIdConverter<StockLevelId> {
    public StockLevelIdConverter() {
        super(StockLevelId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\StockLevelRepository.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import org.springframework.data.jpa.repository.JpaRepository;

public interface StockLevelRepository extends JpaRepository<StockLevel, StockLevelId> {
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\queryport\FulfillmentCenterQueryPort.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.queryport; // Richtiges Package!

import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenter;

import java.util.List;
import java.util.UUID;

public interface FulfillmentCenterQueryPort {
    boolean isItemInStock(UUID itemId);

    UUID findSuitableFulfillmentCenter(String zipCode);

    List<FulfillmentCenter> getAllFulfillmentCenters();

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ItemAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.item.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;

@Service
public class ItemAdapterService implements ItemCatalogUseCases {

    private final ItemCatalogService itemCatalogService;

    public ItemAdapterService(ItemCatalogService itemCatalogService) {
        this.itemCatalogService = itemCatalogService;
    }

    @Override
    public UUID addItemToCatalog(String name, String description, Float size,
                                 MoneyType buyingPrice, MoneyType sellingPrice) {
        return itemCatalogService.addItemToCatalog(name, description, size, buyingPrice, sellingPrice);
    }

    @Override
    public void removeItemFromCatalog(UUID itemId) {
        itemCatalogService.removeItemFromCatalog(itemId);
    }

    @Override
    public MoneyType getSellingPrice(UUID itemId) {
        return itemCatalogService.getSellingPrice(itemId);
    }

    @Override
    public void deleteItemCatalog() {
        itemCatalogService.deleteItemCatalog();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ItemCatalogService.java ---
package thkoeln.archilab.ecommerce.solution.item.application;

import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.item.domain.Item;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemRepository;
import thkoeln.archilab.ecommerce.solution.item.queryport.OrderQueryPort;
import thkoeln.archilab.ecommerce.solution.item.queryport.ShoppingBasketQueryPort;
import thkoeln.archilab.ecommerce.solution.item.queryport.StockLevelQueryPort;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;

@Service
@Transactional
public class ItemCatalogService {

    private final ItemRepository itemRepository;
    private final ShoppingBasketQueryPort shoppingBasketQueryPort;
    private final OrderQueryPort orderQueryPort;
    private final StockLevelQueryPort stockLevelQueryPort;

    public ItemCatalogService(ItemRepository itemRepository,
                              ShoppingBasketQueryPort shoppingBasketQueryPort,
                              OrderQueryPort orderQueryPort,
                              StockLevelQueryPort stockLevelQueryPort) {
        this.itemRepository = itemRepository;
        this.shoppingBasketQueryPort = shoppingBasketQueryPort;
        this.orderQueryPort = orderQueryPort;
        this.stockLevelQueryPort = stockLevelQueryPort;
    }

    public UUID addItemToCatalog(String name, String description, Float size,
                                 MoneyType buyingPriceType, MoneyType sellingPriceType) {
        if (name == null || name.isBlank()
                || description == null || description.isBlank()
                || (size != null && size <= 0)
                || buyingPriceType == null || buyingPriceType.getAmount() <= 0
                || sellingPriceType == null || sellingPriceType.getAmount() <= 0
                || sellingPriceType.getAmount() < buyingPriceType.getAmount()) {
            throw new ShopException("Invalid item data");
        }

        Money buyingPrice = Money.of(buyingPriceType.getAmount(), buyingPriceType.getCurrencyUnit());
        Money sellingPrice = Money.of(sellingPriceType.getAmount(), sellingPriceType.getCurrencyUnit());

        Item item = new Item(name, description, size, buyingPrice, sellingPrice);
        itemRepository.save(item);
        return item.getId().getId();
    }

    public void removeItemFromCatalog(UUID rawItemId) {
        ItemId itemId = new ItemId(rawItemId);

        if (!itemRepository.existsById(itemId)) {
            throw new ShopException("Item does not exist");
        }

        if (orderQueryPort.isItemUsedInOrders(itemId)) {
            throw new ShopException("Item is used in an order and cannot be deleted");
        }

        if (shoppingBasketQueryPort.isItemInBasket(itemId)) {
            throw new ShopException("Item is in a shopping basket and cannot be deleted");
        }

        if (stockLevelQueryPort.isItemInStock(itemId.getId())) {
            throw new ShopException("Item is still in stock and cannot be deleted");
        }

        itemRepository.deleteById(itemId);
    }

    public MoneyType getSellingPrice(UUID rawItemId) {
        ItemId itemId = new ItemId(rawItemId);

        return itemRepository.findById(itemId)
                .map(Item::getSellingPrice)
                .orElseThrow(() -> new ShopException("Item not found"));
    }

    public void deleteItemCatalog() {
        itemRepository.deleteAll();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ItemQueryImplService.java ---
package thkoeln.archilab.ecommerce.solution.item.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemRepository;
import thkoeln.archilab.ecommerce.solution.item.queryport.ItemQueryPort;

import java.util.UUID;

@Service
public class ItemQueryImplService implements ItemQueryPort {

    private final ItemRepository itemRepository;

    public ItemQueryImplService(ItemRepository itemRepository) {
        this.itemRepository = itemRepository;
    }

    @Override
    public boolean itemExists(UUID itemId) {
        return itemRepository.existsById(new ItemId(itemId));
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\Item.java ---
package thkoeln.archilab.ecommerce.solution.item.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.domainprimitives.Money;

@Entity
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED) // JPA
public class Item {

    @EmbeddedId
    private ItemId id = new ItemId();

    private String name;

    private String description;

    private Float size;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "amount", column = @Column(name = "buying_amount")),
            @AttributeOverride(name = "currencyUnit", column = @Column(name = "buying_currency"))
    })
    private Money buyingPrice;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "amount", column = @Column(name = "selling_amount")),
            @AttributeOverride(name = "currencyUnit", column = @Column(name = "selling_currency"))
    })
    private Money sellingPrice;

    public Item(String name, String description, Float size, Money buyingPrice, Money sellingPrice) {
        this.name = name;
        this.description = description;
        this.size = size;
        this.buyingPrice = buyingPrice;
        this.sellingPrice = sellingPrice;
    }

    public Money getSellingPrice() {
        return sellingPrice;
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemId.java ---
package thkoeln.archilab.ecommerce.solution.item.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "item_id"))
public class ItemId extends GenericId {
    public ItemId(UUID id) {
        super(id);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.item.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ItemIdConverter extends GenericIdConverter<ItemId> {
    public ItemIdConverter() {
        super(ItemId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemRepository.java ---
package thkoeln.archilab.ecommerce.solution.item.domain;

import org.springframework.data.jpa.repository.JpaRepository;

public interface ItemRepository extends JpaRepository<Item, ItemId> {
    boolean existsByName(String name);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\queryport\ItemQueryPort.java ---
package thkoeln.archilab.ecommerce.solution.item.queryport;

import java.util.UUID;

public interface ItemQueryPort {
    boolean itemExists(UUID itemId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\queryport\OrderQueryPort.java ---
package thkoeln.archilab.ecommerce.solution.item.queryport;

import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;

public interface OrderQueryPort {
    boolean isItemUsedInOrders(ItemId itemId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\queryport\ShoppingBasketQueryPort.java ---
package thkoeln.archilab.ecommerce.solution.item.queryport;

import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;

public interface ShoppingBasketQueryPort {
    boolean isItemInBasket(ItemId itemId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\queryport\StockLevelQueryPort.java ---
package thkoeln.archilab.ecommerce.solution.item.queryport;

import java.util.UUID;

public interface StockLevelQueryPort {
    boolean isItemInStock(UUID itemId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.order.application;

import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
import thkoeln.archilab.ecommerce.usecases.OrderUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Map;
import java.util.UUID;

@Service
@Transactional
public class OrderAdapterService implements OrderUseCases {

    private final OrderService orderService;

    public OrderAdapterService(OrderService orderService) {
        this.orderService = orderService;
    }

    @Override
    public Map<UUID, Integer> getOrderHistory(EmailAddressType clientEmailAddress) {
        return orderService.getOrderHistory(clientEmailAddress);
    }

    @Override
    public void deleteAllOrders() {
        orderService.deleteAllOrders();
    }

    @Override
    public Integer getOrderQuantForItem(UUID orderId, UUID itemId) {
        if (orderId == null || itemId == null) {
            throw new ShopException("OrderId or ItemId must not be null");
        }

        Order order = orderService.getOrderById(orderId);

        return order.getPositions().stream()
                .filter(pos -> pos.getItemId().getId().equals(itemId))
                .map(OrderPosition::getQuantity)
                .findFirst()
                .orElse(0);
    }

    @Override
    public UUID getFulfillmentCenterIdForOrder(UUID orderId) {
        if (orderId == null) throw new ShopException("OrderId must not be null");

        Order order = orderService.getOrderById(orderId);
        return order.getFulfillmentCenterId().getId(); // oder toUUID()
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderQueryImplService.java ---
package thkoeln.archilab.ecommerce.solution.order.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.item.queryport.OrderQueryPort;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;

@Service
public class OrderQueryImplService implements OrderQueryPort {

    private final OrderRepository orderRepository;

    public OrderQueryImplService(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }

    @Override
    public boolean isItemUsedInOrders(ItemId itemId) {
        return orderRepository.findAll().stream()
                .flatMap(order -> order.getPositions().stream())
                .anyMatch(pos -> pos.getItemId().equals(itemId));
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderService.java ---
package thkoeln.archilab.ecommerce.solution.order.application;

import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Service
@Transactional
public class OrderService {

    private final OrderRepository orderRepository;
    private final ClientRepository clientRepository;

    public OrderService(OrderRepository orderRepository, ClientRepository clientRepository) {
        this.orderRepository = orderRepository;
        this.clientRepository = clientRepository;
    }

    public Map<UUID, Integer> getOrderHistory(EmailAddressType clientEmailAddress) {
        if (clientEmailAddress == null) {
            throw new ShopException("Email must not be null");
        }

        EmailAddress email = EmailAddress.of(clientEmailAddress.toString());
        Client client = clientRepository.findByEmail(email)
                .orElseThrow(() -> new ShopException("Client not found"));

        Map<UUID, Integer> history = new HashMap<>();

        for (Order order : orderRepository.findAll()) {
            if (!order.getClientId().equals(client.getId())) continue;

            for (OrderPosition pos : order.getPositions()) {
                history.merge(pos.getItemId().getId(), pos.getQuantity(), Integer::sum);
            }
        }

        return history;
    }

    public void deleteAllOrders() {
        orderRepository.deleteAll();
    }

    public Order getOrderById(UUID orderId) {
        return orderRepository.findById(new OrderId(orderId))
                .orElseThrow(() -> new ShopException("Order not found"));
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.*;
import lombok.Getter;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterId;

import java.util.ArrayList;
import java.util.List;

@Entity
@Getter
@Table(name = "`order`")
public class Order {

    @EmbeddedId
    private OrderId id;

    @Embedded
    private ClientId clientId;

    @Embedded
    private FulfillmentCenterId fulfillmentCenterId;

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER, orphanRemoval = true)
    @JoinColumn(name = "order_id")
    private List<OrderPosition> positions = new ArrayList<>();

    protected Order() {
        // für JPA
    }

    public Order(ClientId clientId) {
        this.id = new OrderId();
        this.clientId = clientId;
    }

    public Order(ClientId clientId, FulfillmentCenterId fulfillmentCenterId) {
        this.id = new OrderId();
        this.clientId = clientId;
        this.fulfillmentCenterId = fulfillmentCenterId;
    }

    public void addPosition(OrderPosition position) {
        this.positions.add(position);
    }

    public List<OrderPosition> getPositions() {
        return positions;
    }

    @Transient
    private String clientName; // ⬅️ Nicht persistieren, nur für REST

    public void setClientName(String clientName) {
        this.clientName = clientName;
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderId.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "order_id"))
public class OrderId extends GenericId {
    public OrderId(UUID id) {
        super(id);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class OrderIdConverter extends GenericIdConverter<OrderId> {
    public OrderIdConverter() {
        super(OrderId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPosition.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;

@Entity
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class OrderPosition {

    @EmbeddedId
    private OrderPositionId id;

    @Embedded
    private ItemId itemId;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "amount", column = @Column(name = "price_amount")),
            @AttributeOverride(name = "currencyUnit", column = @Column(name = "price_currency"))
    })
    private Money price;

    private int quantity;

    public OrderPosition(ItemId itemId, Money price, int quantity) {
        this.id = new OrderPositionId();
        this.itemId = itemId;
        this.price = price;
        this.quantity = quantity;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionId.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = lombok.AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "order_position_id"))
public class OrderPositionId extends GenericId {
    public OrderPositionId(UUID id) {
        super(id);
    }

    public OrderPositionId(String id) {
        super(UUID.fromString(id));
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class OrderPositionIdConverter extends GenericIdConverter<OrderPositionId> {
    public OrderPositionIdConverter() {
        super(OrderPositionId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionRepository.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderPositionRepository extends JpaRepository<OrderPosition, OrderPositionId> {
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderRepository.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderRepository extends JpaRepository<Order, OrderId> {

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\OrderPositionResponseDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import java.util.UUID;

public record OrderPositionResponseDTO(
        UUID itemId,
        int quantity
) {}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\OrderResponseDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import java.util.List;
import java.util.UUID;

public record OrderResponseDTO(
        UUID id,
        String clientName,
        UUID fulfillmentCenterId,
        List<OrderPositionResponseDTO> positions
) {}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.*;

import java.util.Set;
import java.util.UUID;

@Service
@Transactional
public class ShoppingBasketAdapterService implements ShoppingBasketUseCases {

    private final ShoppingBasketService domainService;


    public ShoppingBasketAdapterService(ShoppingBasketService domainService) {
        this.domainService = domainService;
    }

    @Override
    public void addItemToShoppingBasket(EmailAddressType clientEmailAddress, UUID itemId, int quantity) {
        if (clientEmailAddress == null) {
            throw new ShopException("Email address must not be null");
        }
        if (itemId == null) {
            throw new ShopException("Item ID must not be null");
        }
        if (quantity <= 0) {
            throw new ShopException("Quantity must be positive");
        }

        domainService.addItem(EmailAddress.of(clientEmailAddress.toString()), itemId, quantity);
    }

    @Override
    public void removeItemFromShoppingBasket(EmailAddressType clientEmailAddress, UUID itemId, int quantity) {
        if (clientEmailAddress == null) {
            throw new ShopException("Email address must not be null");
        }
        if (itemId == null) {
            throw new ShopException("Item ID must not be null");
        }
        if (quantity <= 0) {
            throw new ShopException("Quantity must be positive");
        }

        domainService.removeItem(EmailAddress.of(clientEmailAddress.toString()), itemId, quantity);
    }

    @Override
    public Map<UUID, Integer> getShoppingBasketAsMap(EmailAddressType clientEmailAddress) {
        return domainService.getBasketMap(EmailAddress.of(clientEmailAddress.toString()));
    }

    @Override
    public MoneyType getShoppingBasketAsMoneyValue(EmailAddressType clientEmailAddress) {
        return domainService.getBasketValue(EmailAddress.of(clientEmailAddress.toString()));
    }

    @Override
    public Set<UUID> checkout(EmailAddressType clientEmailAddress) {
        if (clientEmailAddress == null) {
            throw new ShopException("Email address must not be null");
        }
        return domainService.checkoutMultipleDeliveries(EmailAddress.of(clientEmailAddress.toString()));
    }

    @Override
    public void emptyAllShoppingBaskets() {
        domainService.clearAllBaskets();
    }
    
    public void addItemToShoppingBasketByBasketId(UUID basketId, UUID itemId, int quantity) {
        // Basket laden
        ShoppingBasket basket = domainService.getBasketById(basketId)
                .orElseThrow(() -> new ShopException("Basket not found"));

        Client client = domainService.getClientById(basket.getClientId());
        EmailAddress email = (EmailAddress) client.getEmailAddress();
        domainService.addItem(email, itemId, quantity);

    }

    public void removeItemFromShoppingBasketByBasketId(UUID basketId, UUID itemId) {
        ShoppingBasket basket = domainService.getBasketById(basketId)
                .orElseThrow(() -> new ShopException("Basket not found"));

        int quantity = basket.getItems().stream()
                .filter(p -> p.getItemId().getId().equals(itemId))
                .findFirst()
                .map(p -> p.getQuantity())
                .orElseThrow(() -> new ShopException("Item not found in basket"));

        EmailAddress email = (EmailAddress) domainService.getClientById(basket.getClientId()).getEmailAddress();
        domainService.removeItem(email, itemId, quantity);
    }

    public Set<Order> checkoutMultipleDeliveries(UUID basketId) {
        ShoppingBasket basket = domainService.getBasketById(basketId)
                .orElseThrow(() -> new ShopException("Basket not found"));

        Client client = domainService.getClientById(basket.getClientId());

        // EmailAddressType → EmailAddress konvertieren
        EmailAddress email = EmailAddress.of(client.getEmailAddress().toString());

        return domainService.checkoutMultipleDeliveriesWithOrders(email);
    }

    public ShoppingBasketResponseDTO getOrCreateBasketForClient(UUID clientIdRaw) {
        ClientId clientId = new ClientId(clientIdRaw);
        Client client = domainService.getClientById(clientId);
        ShoppingBasket basket = domainService.getOrCreateBasketByClientId(clientId);
        Money total = (Money) domainService.getBasketValue(EmailAddress.of(client.getEmailAddress().toString()));
        return ShoppingBasketResponseDTO.from(basket, total);
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;

import java.util.*;

@RestController
@RequestMapping("/shoppingBaskets")
@RequiredArgsConstructor
public class ShoppingBasketController {

    private final ShoppingBasketAdapterService shoppingBasketAdapterService;

    @GetMapping(params = "clientId")
    public ResponseEntity<ShoppingBasketResponseDTO> getBasketByClientId(@RequestParam String clientId) {
        try {
            UUID uuid = UUID.fromString(clientId);
            return ResponseEntity.ok(shoppingBasketAdapterService.getOrCreateBasketForClient(uuid));
        } catch (IllegalArgumentException ex) {
            throw new ShopException("not found"); // wird zu 404 durch ExceptionHandler
        }
    }

    // Fallback-Mapping: kein clientId vorhanden
    @GetMapping
    public ResponseEntity<Void> handleMissingClientId() {
        return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).build(); // 405
    }

    @PostMapping("/{basketId}/positions")
    public ResponseEntity<Void> addItemToBasket(@PathVariable UUID basketId,
                                                @RequestBody QuantityDTO quantityDTO) {
        shoppingBasketAdapterService.addItemToShoppingBasketByBasketId(
                basketId,
                quantityDTO.getItemId(),
                quantityDTO.getQuantity());
        return ResponseEntity.status(HttpStatus.CREATED).build(); // 201
    }

    @DeleteMapping("/{basketId}/positions/{itemId}")
    public ResponseEntity<Void> deleteItemFromBasket(@PathVariable UUID basketId,
                                                     @PathVariable UUID itemId) {
        shoppingBasketAdapterService.removeItemFromShoppingBasketByBasketId(basketId, itemId);
        return ResponseEntity.ok().build(); // 200
    }

    @PostMapping("/{basketId}/checkout")
    public ResponseEntity<List<OrderResponseDTO>> checkout(@PathVariable UUID basketId) {
        Set<Order> createdOrders = shoppingBasketAdapterService.checkoutMultipleDeliveries(basketId);
        List<OrderResponseDTO> responseList = createdOrders.stream().map(order -> {
            UUID orderId = extractUUID(order.getId());
            UUID fcId = extractUUID(order.getFulfillmentCenterId());
            List<OrderPositionResponseDTO> positions = order.getPositions().stream()
                    .map(pos -> new OrderPositionResponseDTO(
                            extractUUID(pos.getItemId()),
                            pos.getQuantity()
                    )).toList();
            return new OrderResponseDTO(orderId, order.getClientName(), fcId, positions);
        }).toList();
        return ResponseEntity.status(HttpStatus.CREATED).body(responseList); // 201
    }

    @ExceptionHandler(ShopException.class)
    public ResponseEntity<String> handleShopException(ShopException exception) {
        String message = exception.getMessage();
        if (message != null) {
            if (message.toLowerCase().contains("not found")) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(message); // 404
            }
            if (message.toLowerCase().contains("must") || message.toLowerCase().contains("invalid")) {
                return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body(message); // 422
            }
        }
        return ResponseEntity.status(HttpStatus.CONFLICT).body(message); // 409
    }

    private UUID extractUUID(Object id) {
        try {
            var field = id.getClass().getSuperclass().getDeclaredField("id");
            field.setAccessible(true);
            return (UUID) field.get(id);
        } catch (Exception e) {
            throw new RuntimeException("Cannot extract UUID from GenericId", e);
        }
    }

    public static class QuantityDTO {
        private UUID itemId;
        private Integer quantity;
        public UUID getItemId() { return itemId; }
        public void setItemId(UUID itemId) { this.itemId = itemId; }
        public Integer getQuantity() { return quantity; }
        public void setQuantity(Integer quantity) { this.quantity = quantity; }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketQueryImplService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.item.queryport.ShoppingBasketQueryPort;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;

;

@Service
public class ShoppingBasketQueryImplService implements ShoppingBasketQueryPort {

    private final ShoppingBasketRepository shoppingBasketRepository;

    public ShoppingBasketQueryImplService(ShoppingBasketRepository shoppingBasketRepository) {
        this.shoppingBasketRepository = shoppingBasketRepository;
    }

    @Override
    public boolean isItemInBasket(ItemId itemId) {
        return shoppingBasketRepository.findAll().stream()
                .flatMap(basket -> basket.getItems().stream())
                .anyMatch(part -> part.getItemId().equals(itemId));
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketResponseDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class ShoppingBasketResponseDTO {
    public UUID id;
    public String totalSellingPrice;
    public List<ShoppingBasketPositionDTO> positions;


    public static ShoppingBasketResponseDTO from(ShoppingBasket basket, Money total) {
        ShoppingBasketResponseDTO dto = new ShoppingBasketResponseDTO();
        dto.id = basket.getId().getId(); // GenericId
        dto.totalSellingPrice = total.getFormatted();
        dto.positions = new ArrayList<>();

        for (ShoppingBasketPosition pos : basket.getItems()) {
            ShoppingBasketPositionDTO positionDTO = new ShoppingBasketPositionDTO();
            positionDTO.itemId = pos.getItemId().getId(); // UUID
            positionDTO.quantity = pos.getQuantity();
            dto.positions.add(positionDTO);
        }

        return dto;
    }

    public static class ShoppingBasketPositionDTO {
        public UUID itemId;
        public int quantity;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.InsufficientStockException;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenter;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterComparator;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.queryport.FulfillmentCenterQueryPort;
import thkoeln.archilab.ecommerce.solution.item.domain.Item;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemRepository;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketId;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.*;
import java.util.stream.Collectors;

@Component
public class ShoppingBasketService {
    private final ShoppingBasketRepository basketRepo;
    private final ClientRepository clientRepo;
    private final ItemRepository itemRepo;
    private final OrderRepository orderRepo;
    private final FulfillmentCenterUseCases fulfillment;
    private final FulfillmentCenterQueryPort fulfillmentCenterQuery;


    public ShoppingBasketService(ShoppingBasketRepository basketRepo,
                                 ClientRepository clientRepo,
                                 ItemRepository itemRepo,
                                 OrderRepository orderRepo,
                                 FulfillmentCenterUseCases fulfillmentCenterUseCases,
                                 FulfillmentCenterQueryPort fulfillmentCenterQuery) {
        this.basketRepo = basketRepo;
        this.clientRepo = clientRepo;
        this.itemRepo = itemRepo;
        this.orderRepo = orderRepo;
        this.fulfillment = fulfillmentCenterUseCases;
        this.fulfillmentCenterQuery = fulfillmentCenterQuery;
    }

    public void addItem(EmailAddress email, UUID itemIdRaw, int quantity) {
        if (itemIdRaw == null || quantity <= 0) throw new ShopException("Invalid input");
        ItemId itemId = new ItemId(itemIdRaw);
        if (!itemRepo.existsById(itemId)) throw new ShopException("Item not found");

        Client client = getClient(email);
        ShoppingBasket basket = basketRepo.findByClientId(client.getId())
                .orElse(new ShoppingBasket(client.getId()));

        basket.addItem(itemIdRaw, quantity);
        basketRepo.save(basket);
    }

    public void removeItem(EmailAddress email, UUID itemIdRaw, int quantity) {
        if (itemIdRaw == null || quantity <= 0) throw new ShopException("Invalid input");
        Client client = getClient(email);

        ShoppingBasket basket = basketRepo.findByClientId(client.getId())
                .orElseThrow(() -> new ShopException("Basket not found"));
        try {
            basket.removeItem(itemIdRaw, quantity);
        } catch (IllegalArgumentException ex) {
            throw new ShopException(ex.getMessage());
        }

        basketRepo.save(basket);
    }

    public Map<UUID, Integer> getBasketMap(EmailAddress email) {
        Client client = getClient(email);
        return basketRepo.findByClientId(client.getId())
                .map(basket -> basket.getItems().stream()
                        .collect(Collectors.toMap(p -> p.getItemId().getId(), ShoppingBasketPosition::getQuantity)))
                .orElse(Collections.emptyMap());
    }

    public MoneyType getBasketValue(EmailAddress email) {
        Client client = getClient(email);
        ShoppingBasket basket = basketRepo.findByClientId(client.getId())
                .orElseThrow(() -> new ShopException("Basket not found"));

        return basket.getItems().stream()
                .map(pos -> {
                    Item item = itemRepo.findById(pos.getItemId())
                            .orElseThrow(() -> new ShopException("Item not found"));
                    return item.getSellingPrice().multiplyBy(pos.getQuantity());
                })
                .reduce(Money.of(0f, "EUR"), MoneyType::add);
    }

    public UUID checkout(EmailAddress email) {
        Client client = getClient(email);
        ShoppingBasket basket = basketRepo.findByClientId(client.getId())
                .orElseThrow(() -> new ShopException("Basket not found"));
        if (basket.isEmpty()) throw new ShopException("Basket is empty");

        for (ShoppingBasketPosition pos : basket.getItems()) {
            UUID fcId = fulfillmentCenterQuery.findSuitableFulfillmentCenter(client.getPostalCode().toString());
            try {
                fulfillment.removeFromStock(fcId, pos.getItemId().getId(), pos.getQuantity());
            } catch (ShopException e) {
                throw new InsufficientStockException("Not enough stock for item " + pos.getItemId().getId());
            }
        }

        Order order = new Order(client.getId());
        for (ShoppingBasketPosition pos : basket.getItems()) {
            Item item = itemRepo.findById(pos.getItemId())
                    .orElseThrow(() -> new ShopException("Item not found"));
            order.addPosition(new OrderPosition(pos.getItemId(), item.getSellingPrice(), pos.getQuantity()));
        }

        orderRepo.save(order);
        basket.clear();
        basketRepo.save(basket);
        return order.getId().getId();
    }

    public Set<UUID> checkoutMultipleDeliveries(EmailAddress email) {
        Client client = getClient(email);
        ShoppingBasket basket = basketRepo.findByClientId(client.getId())
                .orElseThrow(() -> new ShopException("Basket not found"));
        if (basket.isEmpty()) throw new ShopException("Basket is empty");

        // Map<ItemId, Integer> aus ShoppingBasketPosition extrahieren
        Map<ItemId, Integer> remainingItems = basket.getItems().stream()
                .collect(Collectors.toMap(ShoppingBasketPosition::getItemId, ShoppingBasketPosition::getQuantity));

        // Alle FulfillmentCenter laden
        List<FulfillmentCenter> centers = fulfillmentCenterQuery.getAllFulfillmentCenters();

        Set<UUID> orderIds = new HashSet<>();

        while (!remainingItems.isEmpty()) {
            // nach Kriterien sortieren
            ZipCode clientZip = ZipCode.of(client.getAddress().getZipCode().toString());
            centers.sort(new FulfillmentCenterComparator(remainingItems, clientZip));

            FulfillmentCenter bestCenter = centers.get(0);
            Set<ItemId> fulfillable = bestCenter.fulfillableShoppingBasketPositions(remainingItems);

            if (fulfillable.isEmpty()) {
                throw new InsufficientStockException("No fulfillment center can deliver remaining items");
            }

            Order order = new Order(client.getId(), bestCenter.getId());

            for (ItemId itemId : fulfillable) {
                int quantity = remainingItems.get(itemId);
                Item item = itemRepo.findById(itemId)
                        .orElseThrow(() -> new ShopException("Item not found"));
                order.addPosition(new OrderPosition(itemId, item.getSellingPrice(), quantity));

                // Bestand reduzieren
                fulfillment.removeFromStock(bestCenter.getId().getId(), itemId.getId(), quantity);
            }

            orderRepo.save(order);
            orderIds.add(order.getId().getId());

            // erfüllte Items entfernen
            for (ItemId itemId : fulfillable) {
                remainingItems.remove(itemId);
            }
        }

        basket.clear();
        basketRepo.save(basket);
        return orderIds;
    }

    public void clearAllBaskets() {
        basketRepo.deleteAll();
    }

    private Client getClient(EmailAddress email) {
        return clientRepo.findByEmail(email)
                .orElseThrow(() -> new ShopException("Client not found"));
    }

    public Optional<ShoppingBasket> getBasketByClientId(ClientId clientId) {
        return basketRepo.findByClientId(clientId);
    }

    public Client getClientById(ClientId clientId) {
        return clientRepo.findAll().stream()
                .filter(c -> c.getId().getId().equals(clientId.getId()))
                .findFirst()
                .orElseThrow(() -> new ShopException("Client not found"));
    }

    public ShoppingBasket getOrCreateBasketByClientId(ClientId clientId) {
        return basketRepo.findByClientId(clientId)
                .orElseGet(() -> {
                    ShoppingBasket newBasket = new ShoppingBasket(clientId);
                    return basketRepo.save(newBasket);
                });
    }




    public Optional<ShoppingBasket> getBasketById(UUID basketIdRaw) {
        return basketRepo.findById(new ShoppingBasketId(basketIdRaw));
    }

    public Set<Order> checkoutMultipleDeliveriesWithOrders(EmailAddress email) {
        Client client = getClient(email);
        ShoppingBasket basket = basketRepo.findByClientId(client.getId())
                .orElseThrow(() -> new ShopException("Basket not found"));
        if (basket.isEmpty()) throw new ShopException("Basket is empty");

        Map<ItemId, Integer> remainingItems = basket.getItems().stream()
                .collect(Collectors.toMap(ShoppingBasketPosition::getItemId, ShoppingBasketPosition::getQuantity));

        List<FulfillmentCenter> centers = fulfillmentCenterQuery.getAllFulfillmentCenters();
        Set<Order> createdOrders = new HashSet<>();

        while (!remainingItems.isEmpty()) {
            centers.sort(new FulfillmentCenterComparator(remainingItems, ZipCode.of(client.getAddress().getZipCode().toString())));
            FulfillmentCenter bestCenter = centers.get(0);
            Set<ItemId> fulfillable = bestCenter.fulfillableShoppingBasketPositions(remainingItems);

            if (fulfillable.isEmpty()) {
                throw new InsufficientStockException("No fulfillment center can deliver remaining items");
            }

            Order order = new Order(client.getId(), bestCenter.getId());
            order.setClientName(client.getName());

            for (ItemId itemId : fulfillable) {
                int quantity = remainingItems.get(itemId);
                Item item = itemRepo.findById(itemId)
                        .orElseThrow(() -> new ShopException("Item not found"));
                order.addPosition(new OrderPosition(itemId, item.getSellingPrice(), quantity));

                fulfillment.removeFromStock(bestCenter.getId().getId(), itemId.getId(), quantity);
            }

            orderRepo.save(order);
            createdOrders.add(order);
            fulfillable.forEach(remainingItems::remove);
        }

        basket.clear();
        basketRepo.save(basket);
        return createdOrders;
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Entity
@Getter
@Setter(AccessLevel.PRIVATE)
public class ShoppingBasket {

    @EmbeddedId
    private ShoppingBasketId id;

    @Embedded
    private ClientId clientId;

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
    @JoinColumn(name = "shopping_basket_id")
    private List<ShoppingBasketPosition> basketParts = new ArrayList<>();

    protected ShoppingBasket() {}

    public ShoppingBasket(ClientId clientId) {
        this.id = new ShoppingBasketId();
        this.clientId = clientId;
    }

    public void addItem(UUID itemIdRaw, int quantity) {
        ItemId itemId = new ItemId(itemIdRaw);
        Optional<ShoppingBasketPosition> existing = basketParts.stream()
                .filter(p -> p.getItemId().equals(itemId))
                .findFirst();

        if (existing.isPresent()) {
            existing.get().increase(quantity);
        } else {
            basketParts.add(new ShoppingBasketPosition(itemId, quantity));
        }
    }

    public void removeItem(UUID itemIdRaw, int quantity) {
        ItemId itemId = new ItemId(itemIdRaw);
        ShoppingBasketPosition position = basketParts.stream()
                .filter(p -> p.getItemId().equals(itemId))
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("Item not in basket"));

        position.decrease(quantity);
        if (position.isEmpty()) {
            basketParts.remove(position);
        }
    }

    public void clear() {
        basketParts.clear();
    }

    public boolean isEmpty() {
        return basketParts.isEmpty();
    }

    public List<ShoppingBasketPosition> getItems() {
        return basketParts;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketId.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = lombok.AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "shopping_basket_id"))
public class ShoppingBasketId extends GenericId {
    public ShoppingBasketId(UUID id) {
        super(id);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ShoppingBasketIdConverter extends GenericIdConverter<ShoppingBasketId> {
    public ShoppingBasketIdConverter() {
        super(ShoppingBasketId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.Embedded;
import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;

@Entity
@Getter
@Setter(AccessLevel.PRIVATE)
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class ShoppingBasketPosition {

    @EmbeddedId
    private ShoppingBasketPositionId id;

    @Embedded
    private ItemId itemId;

    private int quantity;

    public ShoppingBasketPosition(ItemId itemId, int quantity) {
        this.id = new ShoppingBasketPositionId();
        this.itemId = itemId;
        this.quantity = quantity;
    }

    public void increase(int amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Quantity to increase must be positive");
        }
        this.quantity += amount;
    }


    public void decrease(int amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Quantity to decrease must be positive");
        }
        if (amount > this.quantity) {
            throw new IllegalArgumentException("Not enough quantity to remove");
        }
        this.quantity -= amount;
    }


    public boolean isEmpty() {
        return this.quantity <= 0;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionId.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = lombok.AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "shopping_basket_position_id"))
public class ShoppingBasketPositionId extends GenericId {
    public ShoppingBasketPositionId(UUID id) {
        super(id);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ShoppingBasketPositionIdConverter extends GenericIdConverter<ShoppingBasketPositionId> {
    public ShoppingBasketPositionIdConverter() {
        super(ShoppingBasketPositionId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionRepository.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import org.springframework.data.jpa.repository.JpaRepository;

public interface ShoppingBasketPositionRepository extends JpaRepository<ShoppingBasketPosition, ShoppingBasketPositionId> {

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketRepository.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import org.springframework.data.jpa.repository.JpaRepository;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;

import java.util.Optional;

public interface ShoppingBasketRepository extends JpaRepository<ShoppingBasket, ShoppingBasketId> {
    Optional<ShoppingBasket> findByClientId(ClientId clientId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\ClientRegistrationUseCases.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

/**
 * This interface contains methods needed in the context of use cases concerning the registration of a client.
 * The interface is probably incomplete, and will grow over time ...
 */
public interface ClientRegistrationUseCases {
    /**
     * Registers a new client
     *
     * @param name
     * @param emailAddress
     * @param physicalAddress
     * @throws ShopException if ...
     *      - the client with the given email address already exists
     *      - physicalAddress is null
     */
    public void register( String name, EmailAddressType emailAddress, PhysicalAddressType physicalAddress );


    /**
     * Changes the address of a client
     *
     * @param clientEmailAddress
     * @param clientEmailAddress
     * @param physicalAddress
     * @throws ShopException if ...
     *      - the client with the given email address does not exist,
     *      - physicalAddress is null
     */
    public void changeAddress( EmailAddressType clientEmailAddress,
                               PhysicalAddressType physicalAddress );


    /**
     * Returns the data of a client as an array of strings (name, emailAddress, street, city, zipCode)
     * @param clientEmailAddress
     * @return the client data
     * @throws ShopException the client with the given email address does not exist,
     */
    public ClientType getClientData( EmailAddressType clientEmailAddress );



    /**
     * Clears all clients, including all orders and shopping baskets
     */
    public void deleteAllClients();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\ClientType.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

/**
 * This interface expresses the essence of a shop client
 */
public interface ClientType {
    String getName();
    EmailAddressType getEmailAddress();
    PhysicalAddressType getPhysicalAddress();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\EmailAddressType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface EmailAddressType {
    /**
     * @return the email address as a string
     */
    public String toString();


    /**
     * A special kind of "copy constructor": Returns a new email address object with
     * the same identifyer (the substring left of the "@" sign) as the current one, but
     * with a new domain substring (right of the "@" sign).
     * @param domainString - the new domain for the copied email address
     * @return the new email address
     * @throws ShopException if ...
     *     - domainString is null
     *     - the new email address would not be valid (see `of(...)` method)
     */
    public EmailAddressType sameIdentifyerDifferentDomain( String domainString );

    /**
     * Another special kind of "copy constructor": Returns a new email address object
     * with the same domain (the substring right of the "@" sign) as the current one, but
     * with a new identifyer substring (left of the "@" sign).
     * @param identifyerString - the new identifyer for the copied email address
     * @return the new email address
     * @throws ShopException if ...
     *     - identifyerString is null
     *     - the new email address would not be valid (see `of(...)` method)
     */
    public EmailAddressType sameDomainDifferentIdentifyer( String identifyerString );


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an email address, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param emailAddressAsString - the email address as a string.
     *      We will use a much simplified validation method to check if the email address is valid:
     *      - it must contain exactly one '@' character.
     *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
     *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
     *      - the substrings before and after the '@' may contain one or several '.' as separators
     *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
     *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
     *        (for simplicity we do not allow any other domains)
     * @return a new EmailAddressType object matching the given email address
     * @throws ShopException if ...
     *      - emailAddressAsString is null
     *      - emailAddressAsString is not a valid email address (see above)
     */
     // public static EmailAddressType of( String emailAddressAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MoneyType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface MoneyType {
    /**
     * @return the amount of money
     */
    public Float getAmount();


    /**
     * @return the currency unit of the money
     */
    public String getCurrencyUnit();


    /**
     * @param otherMoney
     * @return this + otherMoney, as a new object
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currencyUnit != this.currencyUnit
     */
    public MoneyType add( MoneyType otherMoney );


    /**
     * @param otherMoney
     * @return this - otherMoney, as a new object
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currencyUnit != this.currencyUnit
     *      - otherMoney > this
     */
    public MoneyType subtract( MoneyType otherMoney );


    /**
     * @param factor
     * @return this * factor, as a new object
     * @throws ShopException if ...
     *     - factor < 0
     */
    public MoneyType multiplyBy( int factor );

    /**
     * @param otherMoney
     * @return true, if this > otherMoney
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currencyUnit != this.currencyUnit
     */
    public boolean largerThan( MoneyType otherMoney );


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates a money object from an amount and a currency unit (as string).
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param amount the amount of money (must be >= 0)
     * @param currencyUnit the currency unit of the money (allowed values: "EUR", "CHF")
     * @return a new Money object with the given amount and currency unit
     * @throws ShopException if ...
     *   - amount is null
     *   - amount < 0
     *   - currency unit is null
     *   - currency unit is not one of the allowed values
     */
     // public static MoneyType of( Float amount, String currencyUnit );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PhysicalAddressType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface PhysicalAddressType {
    /**
     * @return the street as a string
     */
    public String getStreet();

    /**
     * @return the city as a string
     */
    public String getCity();

    /**
     * @return the zip code
     */
    public ZipCodeType getZipCode();

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an zip code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param street the street as a string
     * @param city the city as a string
     * @param zipCode the zip code
     * @return the physical address object matching the parameters
     * @throws ShopException if ...
     *      - street is null or empty
     *      - city is null or empty
     *      - zipCode is null
     */
     // public static PhysicalAddressType of( String street, String city, ZipCodeType zipCode );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\ZipCodeType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import com.fasterxml.jackson.annotation.JsonIgnore;
import thkoeln.archilab.ecommerce.ShopException;

public interface ZipCodeType {
    /**
     * @return the zip code as a string
     */
    public String toString();

    /**
     * You will need some idea of "imprecise difference" between two zip codes for properly
     * implementing fulfillment centers in your shopping platform. This method calculates such a
     * difference. You can decide for yourself what values you return, unless you comply
     * with the following rules.
     * - The return value is 0 if both zip codes are the same
     * - If not:
     *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
     *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
     *        So, 56733 and 56734 have the same difference as 56733 and 56739.
     *      - The difference grows if more digits (counted from the right side) differ.
     *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
     *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
     *        53876 and 54876 have the same difference as 53876 and 57261.
     *      - However, the difference between 5abcd and 6rstu must be smaller than the one
     *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
     *        one between 5abcd and 9rstu.
     *      - This last condition reflects the fact the first digits of a zip code marks a region
     *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
     *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
     *        other.
     * @param otherZipCode
     * @return the calculated difference
     * @throws ShopException if otherZipCode is null
     */
    public int difference( ZipCodeType otherZipCode );


    /**
     * For the currently used way of deciding on the best fitting fulfillment center for a order,
     * we need to know the first digit of the zip code.
     */
    @JsonIgnore
    public Integer getFirstDigitZipCode();


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an zip code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param zipCodeAsString - the zip code as a string.
     *      We will use a much simplified validation method to check if the zip code is valid:
     *      - It must contain exactly 5 digits.
     *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid zip code, but 20001 is valid)
     * @return a new zip code object matching the given string
     * @throws ShopException if ...
     *      - zipCodeAsString is null
     *      - zipCodeAsString is not a valid zip code (see above)
     */
     // public static ZipCodeType of( String zipCodeAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\FulfillmentCenterUseCases.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.UUID;

/**
 * This interface contains methods needed in the context of handling the shop stock,
 * i.e. managing fulfillment centers, and adding / removing items in the fulfillment center.
 */
public interface FulfillmentCenterUseCases {
    /**
     *
     * @param name
     * @param physicalAddress
     * @return the id of the new fulfillment center
     * @throws ShopException if ...
     *      - name is null or empty
     *      - physicalAddress is null
     */
    public UUID addNewFulfillmentCenter( String name, PhysicalAddressType physicalAddress );


    /**
     * Deletes all fulfillment centers from the shop. Intended for testing purposes.
     */
    public void deleteAllFulfillmentCenters();


    /**
     * Adds a certain Quantity of a given item to the stock
     * @param fulfillmentCenterId
     * @param itemId
     * @param addedQuantFor
     * @throws ShopException if ...
     *      - fulfillmentCenterId is null
     *      - the fulfillment center with that id does not exist
     *      - itemId is null
     *      - the item with that id does not exist
     *      - addedQuantFor < 0
     */
    public void addToStock( UUID fulfillmentCenterId, UUID itemId, int addedQuantFor );


    /**
     * Removes a certain Quantity of a given item from the stock.
     * @param fulfillmentCenterId
     * @param itemId
     * @param removedQuantFor
     * @throws ShopException if ...
     *      - fulfillmentCenterId is null
     *      - the fulfillment center with that id does not exist
     *      - itemId is null
     *      - the item with that id does not exist
     *      - removedQuantFor < 0
     */
    public void removeFromStock( UUID fulfillmentCenterId, UUID itemId, int removedQuantFor );


    /**
     * Changes the total Quantity of a given item in the stock.
     * @param fulfillmentCenterId
     * @param itemId
     * @param newTotalQuantFor
     * @throws ShopException if ...
     *      - fulfillmentCenterId is null
     *      - the fulfillment center with that id does not exist
     *      - itemId is null
     *      - the item with that id does not exist
     *      - newTotalQuantFor < 0
     */
    public void changeStockTo( UUID fulfillmentCenterId, UUID itemId, int newTotalQuantFor );


    /**
     * Get the current stock of a given item in one specific fulfillment center.
     * @param fulfillmentCenterId
     * @param itemId
     * @return the current total stock of the item
     * @throws ShopException if ...
     *      - fulfillmentCenterId is null
     *      - the fulfillment center with that id does not exist
     *      - itemId is null
     *      - the item with that id does not exist
     */
    public int getAvailableStock( UUID fulfillmentCenterId, UUID itemId );


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\ItemCatalogUseCases.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;


/**
 * This interface contains methods needed in the context of use cases concerning the item catalog.
 * The interface is probably incomplete, and will grow over time ...
 */

public interface ItemCatalogUseCases {
    /**
     * Adds a new item to the shop catalog
     * @param name
     * @param descriptionFor
     * @param size
     * @param buyingPrice
     * @param sellingPrice
     * @return the id of the new item
     * @throws ShopException if ...
     *      - the item id already exists,
     *      - name or description are null or empty,
     *      - the size is <= 0 (but can be null!),
     *      - the buying price is null or <= 0,
     *      - the buyingPrice is null,
     *      - the selling price is null,
     *      - the selling price is lower than the buyingPrice
     */
    public UUID addItemToCatalog( String name, String descriptionFor, Float size,
                                           MoneyType buyingPrice, MoneyType sellingPrice );


    /**
     * Removes a item from the shop catalog
     * @param itemId
     * @throws ShopException if
     *      - itemId is null
     *      - the item id does not exist
     *      - the item is still in stock
     *      - the item is still in a shopping basket, or referenced by a completed order
     */
    public void removeItemFromCatalog( UUID itemId );


    /**
     * Get the selling price of a given item
     * @param itemId
     * @return the selling price
     * @throws ShopException if ...
     *      - itemId is null,
     *      - the item with that id does not exist
     */
    public MoneyType getSellingPrice( UUID itemId );


    /**
     * Clears the item catalog, i.e. removes all items from the catalog, including all the stock,
     * all the reservations and all the orders.
     */
    public void deleteItemCatalog();

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ClientTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;


import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

/**
 * This is a test helper interface provides access to predefined test data for
 * clients.
 */
public interface ClientTestHelper {
    /**
     * This method calls the use case implementation to register all clients specified in the
     * test data set.
     * If you use the debugger and want to identify _which_ test client you currently look at:
     * The indices are coded into the house number (in the client's physical address) and in the first
     * cipher of the zip code. This is the list of clients:
     *
     * +-------+-------------------+--------+---------------------
     * | Index | Name              | PLZ    | EmailAddress
     * +-------+-------------------+--------+---------------------
     * | 0     | Max Mueller       | 02314  | 99Z@example.com
     * | 1     | Sophie Schmitz    | 02368  | a@4.com
     * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
     * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
     * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
     * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
     * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
     * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
     * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
     * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
     * +-------+-------------------+--------+---------------------
     */
    void registerAllClients();


    /**
     * @return the number of test clients in the test data set.
     */
    int getNumberOfClients();


    /**
     * @param index the index of the client in the test data set.
     * @return the name of the test client with the given index.
     */
    String getClientName( int index );


    /**
     * @param index the index of the client in the test data set.
     * @return the email address of the test client with the given index.
     */
    EmailAddressType getClientEmailAddress( int index );


    /**
     * @param index the index of the client in the test data set.
     * @return the physical address of the test client with the given index.
     */
    PhysicalAddressType getClientPhysicalAddress( int index );


    /**
     * @param index the index of the client in the test data set.
     * @return the test client with the given index.
     */
    ClientType getClient( int index );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.Enumeration;

import static org.junit.jupiter.api.Assertions.*;

public class FactoryMethodInvoker {

    public static EmailAddressType instantiateEmailAddress( String emailAddressAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for EmailAddressType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, emailAddressAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + emailAddressAsString + "'", e );
        }
        assertNotNull( instance );
        return (EmailAddressType) instance;
    }


    public static PhysicalAddressType instantiatePhysicalAddress(
            String street, String city, ZipCodeType zipCode ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of",
                    String.class, String.class, ZipCodeType.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for PhysicalAddressType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, street, city, zipCode );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" +
                    street + "', '" + city + "', '" + zipCode + "'", e );
        }
        assertNotNull( instance );
        return (PhysicalAddressType) instance;
    }


    public static ZipCodeType instantiateZipCode( String zipCodeAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for ZipCodeType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, zipCodeAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + zipCodeAsString + "'", e );
        }
        assertNotNull( instance );
        return (ZipCodeType) instance;
    }


    public static MoneyType instantiateMoney( Float amount, String currencyUnit ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for MoneyType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, amount, currencyUnit );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + amount + "', '" + currencyUnit + "'", e );
        }
        assertNotNull( instance );
        return (MoneyType) instance;
    }


    private static Class<?> findImplementation( Class<?> interfaceClass ) {
        Method factoryMethod = null;
        try {
            String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
            Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
            assertNotNull( implementingClass );
            return implementingClass;
        } catch (Exception e) {
            fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
            return null; // This line will never be reached, but it's necessary to satisfy the compiler
        }
    }


    private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
            throws ClassNotFoundException, IOException {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        String path = packageName.replace( '.', '/' );
        Enumeration<URL> resources = classLoader.getResources( path );
        int count = 0;
        Class<?> result = null;
        while (resources.hasMoreElements()) {
            URL resource = resources.nextElement();
            File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
            File[] files = directory.listFiles();
            for ( File file : files ) {
                if ( file.getName().endsWith( ".class" ) ) {
                    String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
                    Class<?> clazz = Class.forName( className );
                    if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
                        count++;
                        result = clazz;
                    }
                }
            }
        }
        assertEquals( 1, count, "There should be exactly one implementing class" );
        return result;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FulfillmentCenterTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import java.util.UUID;

public interface FulfillmentCenterTestHelper {
    /**
     * Adds the test fulfillment centers to the system.
     * If you want to use the fulfillment centers, or want to know which index the fulfillment center has that you see
     * in the debugger, the following rules apply:
     * - The fulfillment center name will equal the street name of the physical address of the fulfillment center.
     * - The index number is visible in the house number. Example: fulfillment center 3 is located at
     *   "Ablageweg 3", and that is also its name.
     *
     *  The fulfillment centers are used in the tests as follows:
     *  - fulfillment center 0 holds all items 0 - 6, and is used for all tests where it is not relevant
     *    to split one shopping basket into several orders.
     *  - fulfillment centers 1 - 3 are used for the proximity tests, where you can deliver item 7 to
     *    to a client from the closest fulfillment center.
     *  - fulfillment centers 4 - 8 are used for the tests where you need to deliver items 8 - 14 in
     *    the most cost-efficient way, as multiple deliveries.
     *  - fulfillment center 9 is empty.
     *
     *  If withStock is true, then the fulfillment centers are filled with items. This happens
     *  according to the following rules:
     *  - items 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
     *    ONLY available in fulfillment center 0. (This means that item 0 out of stock everywhere.)
     *  - items 4, 5, 6 have a random stock between 30 and 130, also all ONLY in fulfillment center 0
          (these are the items used for tests on how to add and remove stock)
     *  - item 7 has a random stock between 30 and 130, distributed over
     *    fulfillment centers 1, 2, and 3. You can use this to test if the appropriate fulfillment center is found
     *    for a shopping basket with only item 7 in it, but with different quantities (<= 3, or > 3).
     *  - The other items (8 - 14) have also a random stock between 30 and 130, all distributed
     *    over several fulfillment centers. The distribution is done as follows:
     *    Assume that the item is available in <n> fulfillment centers. Then the first <n-1> fulfillment centers
     *    in the list (in ascending sequence) contain 3, and all the remaining stock is in the
     *    last fulfillment center.
     *
     *    This is how the stock of items could be distributed
     *    (Wx = fulfillment center x with its zip code, Px = item x,
     *    numbers marked with (*) are random large numbers):
     *
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
     *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *    | P0   |      |     |     |      |     |      |     |       |      |     |
     *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
     *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
     *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
     *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
     *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
     *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
     *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
     *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
     *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
     *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
     *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
     *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
     *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
     *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *
     * @param withStock if true, the stock of the items is added to the fulfillment center. Otherwise, the
     *                           the stock is not added and the fulfillment center is empty.
     */
    public void addAllFulfillmentCenters( boolean withStock );


    /**
     * @return the number of test fulfillment centers in the database
     */
    int numberOfFulfillmentCenters();


    /**
     * @param index
     * @return the id of the test fulfillment center at the given index
     */
    UUID getFulfillmentCenterId( int index );


    /**
     * @param fulfillmentCenterId - the id of the fulfillment center in the test data
     * @return the index of the test fulfillment center with that id
     */
    int findFulfillmentCenterIndex( UUID fulfillmentCenterId );


    /**
     * @param itemIndex - the index of the item in the test data
     * @param fulfillmentCenterIndex - the index of the fulfillment center in the test data
     * @return the number of items (stock) available in the fulfillment center at the given index
     */
    Integer getFulfillmentCenterStock( int fulfillmentCenterIndex, int itemIndex );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\ClientTestHelperImpl.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
import thkoeln.archilab.ecommerce.usecases.masterdata.MockClient;

import static org.junit.jupiter.api.Assertions.assertThrows;

/**
 * This is a test helper class that initializes and registers clients in the system,
 * using the given interface(s).
 */
@Component
@SuppressWarnings("PMD")
public class ClientTestHelperImpl implements ClientTestHelper {

    private ClientRegistrationUseCases clientRegistrationUseCases;

    @Autowired
    public ClientTestHelperImpl( ClientRegistrationUseCases clientRegistrationUseCases ) {
        this.clientRegistrationUseCases = clientRegistrationUseCases;
    }

    private final static String[] CLIENT_NAME = new String[]{
            "Max Mueller",
            "Sophie Schmitz",
            "Irene Mihalic",
            "Emilia Fischer",
            "Filiz Polat",
            "Lina Wagner",
            "Leon Becker",
            "Agnieszka Kalterer",
            "Felix Bauer",
            "Lara Schulz"
    };

    private final static EmailAddressType[] CLIENT_EMAIL = new EmailAddressType[]{
            FactoryMethodInvoker.instantiateEmailAddress( "99Z@example.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "a@4.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "irene@wearefreedomnow.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "emilia.fischer@example.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "j877d3@example.this.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "lina.marie.wagner@example.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "agna@here.ch" ),
            FactoryMethodInvoker.instantiateEmailAddress( "felix.bauer@example.org" ),
            FactoryMethodInvoker.instantiateEmailAddress( "lara.schulz@example.at" )
    };

    // The following array is used to create a list of physicalAddresss for the clients.
    // The indices are coded into the house number.
    // - Persons 0 - 5 are used for proximity tests with one fulfillment center.
    private final static PhysicalAddressType[] CLIENT_ADDRESS = new PhysicalAddressType[]{
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Marktstraße 0", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02314" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Hauptstraße 1", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02368" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Kirchplatz 2", "Niemandstown",
                    FactoryMethodInvoker.instantiateZipCode( "12345" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Schulstraße 3", "Geisterhausen",
                    FactoryMethodInvoker.instantiateZipCode( "31463" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Rosenweg 4", "Kuhhausen",
                    FactoryMethodInvoker.instantiateZipCode( "72162" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Wiesenstraße 5", "Waldschenkensdorf",
                    FactoryMethodInvoker.instantiateZipCode( "82195" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Muehlenweg 6", "Koeln",
                    FactoryMethodInvoker.instantiateZipCode( "50667" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Goethestraße 7", "Frankfurt am Main",
                    FactoryMethodInvoker.instantiateZipCode( "60311" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Dorfstraße 8", "Stuttgart",
                    FactoryMethodInvoker.instantiateZipCode( "70173" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Bahnhofstraße 9", "Muenchen",
                    FactoryMethodInvoker.instantiateZipCode( "80331" ) )
    };

    private final static ClientType[] mockClients;

    static {
        mockClients = new ClientType[CLIENT_NAME.length];
        for ( int i = 0; i < CLIENT_NAME.length; i++ ) {
            mockClients[i] = new MockClient(
                    CLIENT_NAME[i], CLIENT_EMAIL[i], CLIENT_ADDRESS[i] );
        }
    }


    @Override
    public void registerAllClients() {
        for ( int i = 0; i < CLIENT_NAME.length; i++ ) {
            registerClient( CLIENT_NAME[i], CLIENT_EMAIL[i], CLIENT_ADDRESS[i] );
        }
    }


    private void registerClient( String name, EmailAddressType emailAddress, PhysicalAddressType physicalAddress ) {
        clientRegistrationUseCases.register( name, emailAddress, physicalAddress );
    }


    @Override
    public int getNumberOfClients() {
        return CLIENT_NAME.length;
    }


    @Override
    public String getClientName( int index ) {
        if ( index < 0 || index >= CLIENT_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return CLIENT_NAME[index];
    }


    @Override
    public EmailAddressType getClientEmailAddress( int index ) {
        if ( index < 0 || index >= CLIENT_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return CLIENT_EMAIL[index];
    }


    @Override
    public PhysicalAddressType getClientPhysicalAddress( int index ) {
        if ( index < 0 || index >= CLIENT_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return CLIENT_ADDRESS[index];
    }


    @Override
    public ClientType getClient( int index ) {
        if ( index < 0 || index >= CLIENT_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return mockClients[index];
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\StockTestHelperImpl.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;

import java.util.*;

/**
 * This is a test helper class that initializes and registers items (but without stock)
 * in the system, using the given interface(s).
 */
@Component
@SuppressWarnings("PMD")
public class StockTestHelperImpl
                        implements ItemTestHelper, FulfillmentCenterTestHelper {
    private ItemCatalogUseCases itemCatalogUseCases;
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    private static Random random = new Random();

    private static final String EUR = "EUR";
    private static final int ITEM_NUMOF = 15;
    private static final Object[][] ITEM_DATA = new Object[][]{
            {null, "0-TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
                    1.5f, FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 10.0f, EUR ),
                    "0"},
            {null, "1-EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
                    0.3f, FactoryMethodInvoker.instantiateMoney( 2.5f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 4.0f, EUR ),
                    "0"},
            {null, "2-MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
                    7.2f, FactoryMethodInvoker.instantiateMoney( 50.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
                    "0"},
            {null, "3-Gh-25", "Kompakter und leichter Akku für mobile Geräte",
                    null, FactoryMethodInvoker.instantiateMoney( 6.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 8.0f, EUR ),
                    "0"},
            {null, "4-MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
                    null, FactoryMethodInvoker.instantiateMoney( 0.6f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
                    "0"},
            {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
                    1.0f, FactoryMethodInvoker.instantiateMoney( 150.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 250.0f, EUR ),
                    "0"},
            {null, "6-Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
                    null, FactoryMethodInvoker.instantiateMoney( 0.3f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 0.5f, EUR ),
                    "0"},
            {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
                    6.0f, FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 120.0f, EUR ),
                    "123"},
            {null, "8-JKL-67", "Wasserdichtes Gehäuse",
                    3.0f, FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 1.2f, EUR ),
                    "467"},
            {null, "9-MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
                    5.5f, FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 45.0f, EUR ),
                    "578"},
            {null, "10-PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
                    4.0f, FactoryMethodInvoker.instantiateMoney( 20.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 35.0f, EUR ),
                    "567"},
            {null, "11-STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
                    null, FactoryMethodInvoker.instantiateMoney( 200.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 350.0f, EUR ),
                    "478"},
            {null, "12-VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
                    null, FactoryMethodInvoker.instantiateMoney( 15.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
                    "5"},
            {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
                    3.5f, FactoryMethodInvoker.instantiateMoney( 60.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 100.0f, EUR ),
                    "78"},
            {null, "14-Nosedive", "Klammer zum Verschließen der Nase beim Tauchen",
                    5.0f, FactoryMethodInvoker.instantiateMoney( 2.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
                    "457"}
    };
    

    // These physical addresss are used for the fulfillment centers. The fulfillment center name will equal
    // the zip code of the site. Their index number will be visible in the house number.
    // The fulfillment centers are used as such:
    // - fulfillment center 0 is holds all items 0 - 6, and is used for all tests where multiple
    //   deliveries are irrelevant.
    // - fulfillment centers 1 - 3 are used for the proximity tests, where you can deliver items 7 to
    //   to a client from the closest fulfillment center.
    // - fulfillment centers 4 - 8 are used for the tests where you need to deliver items 8 - 14 in
    //   the most cost-efficient way, as multiple deliveries.
    // - fulfillment center 9 is empty.
    private final static int FULFILLMENT_CENTER_NUMOF = 10;
    private final static PhysicalAddressType[] FULFILLMENT_CENTER_PHYSICAL_ADDRESS = new PhysicalAddressType[]{
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Stapelallee 0", "Potsdam",
                    FactoryMethodInvoker.instantiateZipCode( "14476" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Lagerhausstr. 1", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02345" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Speicherplatz 2", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02313" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Ablageweg 3", "Reichswürgen",
                    FactoryMethodInvoker.instantiateZipCode( "44923" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Paketstellenallee 4", "Düsseldorf",
                    FactoryMethodInvoker.instantiateZipCode( "40588" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Kaputte-Sachen-Straße 5", "Düren",
                    FactoryMethodInvoker.instantiateZipCode( "52355" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Aufbewahrungsweg 6", "Viernheim",
                    FactoryMethodInvoker.instantiateZipCode( "68519" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Paketallee 7", "Baden-Baden",
                    FactoryMethodInvoker.instantiateZipCode( "76532" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Sendenstr. 8", "Senden",
                    FactoryMethodInvoker.instantiateZipCode( "89250" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Schickweg 9", "Hohenroth",
                    FactoryMethodInvoker.instantiateZipCode( "97618" ) )
    };
    private final static UUID[] FULFILLMENT_CENTER_ID = new UUID[FULFILLMENT_CENTER_NUMOF];


    // These data structures contain the stock of the items in the fulfillment centers.
    // ITEM_STOCK is a map item name -> Integer[FULFILLMENT_CENTER_NUMOF].
    // The Integer[FULFILLMENT_CENTER_NUMOF] contains the stock of the item in each of
    // the fulfillment centers.
    //
    // The following rules apply:
    // - item 0 is out of stock
    // - item 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in fulfillment center 0
    // - item 4 / 5 / 6 have a random stock between 30 and 130, also all ONLY in fulfillment center 0
    //   (these are the items used for tests on how to add and remove stock)
    // - the others have a random stock between 30 and 130, distributed over several
    //   fulfillment centers. Here we follow this convention for simplicity:
    //   - Assume that the item is available in <n> fulfillment centers. Then the first <n-1> fulfillment centers
    //     in the list (in ascending sequence) contain 3, and all the remaining stock is in the
    //     last fulfillment center.

    private static final Map<String, Integer[]> ITEM_STOCK = new HashMap<>();

    static {
        // items 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
        ITEM_STOCK.put( (String) ITEM_DATA[0][1],
                getStockDistribution( 0, (String) ITEM_DATA[0][6] ) );
        ITEM_STOCK.put( (String) ITEM_DATA[1][1],
                getStockDistribution( 10, (String) ITEM_DATA[1][6] ) );
        ITEM_STOCK.put( (String) ITEM_DATA[2][1],
                getStockDistribution( 20, (String) ITEM_DATA[2][6] ) );
        ITEM_STOCK.put( (String) ITEM_DATA[3][1],
                getStockDistribution( 30, (String) ITEM_DATA[3][6] ) );

        // The other items have a random stock between 30 and 130,
        for ( int i = 4; i < ITEM_NUMOF; i++ ) {
            Integer totalNumber = random.nextInt( 100 ) + 30;
            Integer[] stockInFulfillmentCenters =
                    getStockDistribution( totalNumber, (String) ITEM_DATA[i][6] );
            ITEM_STOCK.put( (String) ITEM_DATA[i][1], stockInFulfillmentCenters );
        }
    }

    /**
     * This method creates a random stock distribution for the given item.
     *
     * @param totalQuantity - the total number of items in the fulfillment centers
     * @param zeroToNine  - a string with numbers between 0 and 9, representing the fulfillment centers
     * @return an Integer array with the stock distribution for the item, according to
     * the rules described above.
     */
    private static Integer[] getStockDistribution( Integer totalQuantity, String zeroToNine ) {
        Integer[] stockInFulfillmentCenters = new Integer[FULFILLMENT_CENTER_NUMOF];
        for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) stockInFulfillmentCenters[i] = 0;
        TreeSet<Integer> fulfillmentCenterIndices = getFulfillmentCenterIndices( zeroToNine );
        int numOfIndices = fulfillmentCenterIndices.size();
        int currentIndexNumber = 0;
        int currentQuantity = totalQuantity;
        for ( Integer fulfillmentCenterIndex : fulfillmentCenterIndices ) {
            currentIndexNumber++;
            if ( currentIndexNumber < numOfIndices ) {
                stockInFulfillmentCenters[fulfillmentCenterIndex] = 3;
                currentQuantity -= 3;
            } else {
                stockInFulfillmentCenters[fulfillmentCenterIndex] = currentQuantity;
            }
        }
        return stockInFulfillmentCenters;
    }

    private static TreeSet<Integer> getFulfillmentCenterIndices( String zeroToNine ) {
        TreeSet<Integer> fulfillmentCenterIndices = new TreeSet<>();
        for ( int i = 0; i < zeroToNine.length(); i++ ) {
            fulfillmentCenterIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
        }
        return fulfillmentCenterIndices;
    }


    @Autowired
    public StockTestHelperImpl( ItemCatalogUseCases itemCatalogUseCases,
                                         FulfillmentCenterUseCases fulfillmentCenterUseCases ) {
        this.itemCatalogUseCases = itemCatalogUseCases;
        this.fulfillmentCenterUseCases = fulfillmentCenterUseCases;
    }


    @Override
    public void addAllItems() {
        int i = 0;
        for ( Object[] itemData : ITEM_DATA ) {
            UUID newId = itemCatalogUseCases.addItemToCatalog(
                    (String) itemData[1], (String) itemData[2],
                    (Float) itemData[3], (MoneyType) itemData[4],
                    (MoneyType) itemData[5] );
            // The first element of the item data is the id, which was initialized with null before, but can now be set
            ITEM_DATA[i][0] = newId;
            i++;
        }
    }


    @Override
    public int numberOfItems() {
        return ITEM_NUMOF;
    }


    @Override
    public UUID getItemId( int index ) {
        if ( index < 0 || index >= ITEM_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (UUID) ITEM_DATA[index][0];
    }


    @Override
    public MoneyType getBuyingPrice( int index ) {
        if ( index < 0 || index >= ITEM_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (MoneyType) ITEM_DATA[index][4];
    }


    @Override
    public MoneyType getSellingPrice( int index ) {
        if ( index < 0 || index >= ITEM_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (MoneyType) ITEM_DATA[index][5];
    }


    @Override
    public void addAllFulfillmentCenters( boolean withStock ) {
        for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) {
            FULFILLMENT_CENTER_ID[i] = fulfillmentCenterUseCases.addNewFulfillmentCenter(
                    FULFILLMENT_CENTER_PHYSICAL_ADDRESS[i].getStreet(),
                    FULFILLMENT_CENTER_PHYSICAL_ADDRESS[i] );
        }
        if ( withStock ) {
            addAllStock();
        }
    }


    private void addAllStock() {
        for ( Object[] itemData : ITEM_DATA ) {
            Integer[] stockInFulfillmentCenters =
                    ITEM_STOCK.get( itemData[1] );
            for ( int iFulfillmentCenter = 0; iFulfillmentCenter < FULFILLMENT_CENTER_NUMOF; iFulfillmentCenter++ ) {
                if ( stockInFulfillmentCenters[iFulfillmentCenter] > 0 )
                    fulfillmentCenterUseCases.addToStock(
                            FULFILLMENT_CENTER_ID[iFulfillmentCenter], (UUID) itemData[0],
                            stockInFulfillmentCenters[iFulfillmentCenter] );
            }
        }
    }


    @Override
    public int numberOfFulfillmentCenters() {
        return FULFILLMENT_CENTER_NUMOF;
    }


    @Override
    public UUID getFulfillmentCenterId( int index ) {
        if ( index < 0 || index >= FULFILLMENT_CENTER_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return FULFILLMENT_CENTER_ID[index];
    }


    @Override
    public Integer getFulfillmentCenterStock( int fulfillmentCenterIndex, int itemIndex ) {
        if ( fulfillmentCenterIndex < 0 || fulfillmentCenterIndex >= FULFILLMENT_CENTER_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + fulfillmentCenterIndex );
        }
        if ( itemIndex < 0 || itemIndex >= ITEM_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + itemIndex );
        }
        String itemName = (String) ITEM_DATA[itemIndex][1];
        Integer[] stockInFulfillmentCenters = ITEM_STOCK.get( itemName );
        Integer foundStock = stockInFulfillmentCenters[fulfillmentCenterIndex];
        return foundStock == null ? 0 : foundStock;
    }


    @Override
    public int findFulfillmentCenterIndex( UUID fulfillmentCenterId ) {
        for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) {
            if ( FULFILLMENT_CENTER_ID[i].equals( fulfillmentCenterId ) ) {
                return i;
            }
        }
        throw new IllegalArgumentException( "No test fulfillment center with UUID id " + fulfillmentCenterId );
    }


    @Override
    public int findItemIndex( UUID itemId ) {
        for ( int iItemData = 0; iItemData < FULFILLMENT_CENTER_NUMOF; iItemData++ ) {
            Object[] itemData = ITEM_DATA[iItemData];
            if ( itemData[0].equals( itemId ) ) {
                return iItemData;
            }
        }
        throw new IllegalArgumentException( "No test item with UUID id " + itemId );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ItemTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;

public interface ItemTestHelper {
    /**
     * Adds all test items to the database.
     * If you use the debugger and want to identify _which_ test item you currently look at:
     * The indices are coded into the first number in the name string of the item, like e.g.
     * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
     */
    void addAllItems();


    /**
     * @return the number of test items in the database
     */
    int numberOfItems();


    /**
     * @param index
     * @return the id of the test item at the given index
     */
    UUID getItemId( int index );


    /**
     * @param itemId - the id of the item in the test data
     * @return the index of the test item with that id
     */
    int findItemIndex( UUID itemId );


    /**
     * @param index
     * @return the buying price of test item at the given index
     */
    MoneyType getBuyingPrice( int index );


    /**
     * @param index
     * @return the selling price of test item at the given index
     */
    MoneyType getSellingPrice( int index );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockClient.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import lombok.Setter;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;


import java.util.Objects;

@Setter
public class MockClient implements ClientType {
    private String name;
    private EmailAddressType emailAddressType;
    private PhysicalAddressType physicalAddressType;


    public MockClient( String name, EmailAddressType emailAddressType, PhysicalAddressType physicalAddressType) {
        this.name = name;
        this.emailAddressType = emailAddressType;
        this.physicalAddressType = physicalAddressType;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public EmailAddressType getEmailAddress() {
        return emailAddressType;
    }

    @Override
    public PhysicalAddressType getPhysicalAddress() {
        return physicalAddressType;
    }

    @Override
    public boolean equals( Object o ) {
        if ( this == o ) return true;
        if ( !( o instanceof MockClient ) ) return false;
        MockClient that = (MockClient) o;
        return Objects.equals( getName(), that.getName() ) &&
                Objects.equals( emailAddressType, that.emailAddressType ) &&
                Objects.equals( physicalAddressType, that.physicalAddressType );
    }

    @Override
    public int hashCode() {
        return Objects.hash( getName(), emailAddressType, physicalAddressType );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.usecases.*;

/**
 * Removes everything :-)
 */
@Service
public class Purgatory {
    @Autowired
    private ClientRegistrationUseCases clientRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private OrderUseCases orderUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;

    public void deleteEverything() {
        orderUseCases.deleteAllOrders();
        shoppingBasketUseCases.emptyAllShoppingBaskets();
        fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
        clientRegistrationUseCases.deleteAllClients();
        itemCatalogUseCases.deleteItemCatalog();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;

@Component
@Slf4j
@Profile("!test")
@SuppressWarnings("PMD")
public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
    private Purgatory purgatory;
    private ClientTestHelper clientTestHelper;
    private ItemTestHelper itemTestHelper;
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;


    @Autowired
    public StartupListener( Purgatory purgatory,
                            ClientTestHelper clientTestHelper,
                            ItemTestHelper itemTestHelper,
                            FulfillmentCenterTestHelper fulfillmentCenterTestHelper ) {
        this.purgatory = purgatory;
        this.clientTestHelper = clientTestHelper;
        this.itemTestHelper = itemTestHelper;
        this.fulfillmentCenterTestHelper = fulfillmentCenterTestHelper;
    }

    @Override
    public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
        log.info( "StartupListener initializing master data ..." );
        purgatory.deleteEverything();
        clientTestHelper.registerAllClients();
        itemTestHelper.addAllItems();
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\OrderUseCases.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
 */
package thkoeln.archilab.ecommerce.usecases;


import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Map;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of the order history of a client.
 */
public interface OrderUseCases {

    /**
     * Returns a map showing which items have been ordered by a client and how many of each item
     *
     * @param clientEmailAddress
     * @return the order history of the client (map is empty if the client has not ordered anything yet)
     * @throws ShopException if
     *      - clientEmailAddress is null
     *      - the client with the given email address does not exist
     */
    public Map<UUID, Integer> getOrderHistory( EmailAddressType clientEmailAddress );



    /**
     * @return the number of items in a given order. If the item is not a position of the order, the method
     *         returns 0. No exception is thrown.
     * @param orderId - the id of the order to be checked
     * @param itemId - the id of the item for which we want to know the quantity
     * @throws ShopException if
     *     - orderId is null, or doesn't exist in the system
     *     - itemId is null, or doesn't exist in the system
     */
    public Integer getOrderQuantForItem( UUID orderId, UUID itemId );


    /**
     * @return the id of the fulfillment center that is responsible for the given order
     * @param orderId - the id of the order to be checked
     * @throws ShopException if
     *      - orderId is null, or doesn't exist in the system
     */
    public UUID getFulfillmentCenterIdForOrder( UUID orderId );


    /**
     * Deletes all orders in the system
     */
    public void deleteAllOrders();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingBasketUseCases.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Map;
import java.util.Set;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of use cases handling the shopping basket.
 * The interface is probably incomplete, and will grow over time ...
 */
public interface ShoppingBasketUseCases {
    /**
     * Adds a item to the cart of a client
     *
     * @param clientEmailAddress
     * @param itemId
     * @param quantFor
     * @throws ShopException if ...
     *          - clientEmailAddress is null,
     *          - the client with the given email address does not exist,
     *          - itemId is null,
     *          - the item with itemId does not exist
     *          - the Quantity is negative,
     */
    public void addItemToShoppingBasket( EmailAddressType clientEmailAddress,
                                                 UUID itemId, int quantFor );


    /**
     * Removes a item from the cart of a client
     *
     * @param clientEmailAddress
     * @param itemId
     * @param quantFor
     * @throws ShopException if ...
     *          - clientEmailAddress is null,
     *          - the client with the given email address does not exist,
     *          - itemId is null,
     *          - the item with itemId does not exist
     *          - the Quantity is negative
     *          - the item is not in the shopping basket in the requested Quantity
     */
    public void removeItemFromShoppingBasket( EmailAddressType clientEmailAddress,
                                                      UUID itemId, int quantFor );


    /**
     * Returns a map showing which items are in the cart of a client and how many of each item
     *
     * @param clientEmailAddress
     * @return the cart of the client (map is empty if the cart is empty)
     * @throws ShopException if
     *          - clientEmailAddress is null,
     *          - the client with the given email address does not exist
     */
    public Map<UUID, Integer> getShoppingBasketAsMap( EmailAddressType clientEmailAddress );


    /**
     * Returns the current value of all items in the cart of a client
     *
     * @param clientEmailAddress
     * @return the cart of the client
     * @throws ShopException if
     *          - clientEmailAddress is null,
     *          - the client with the given email address does not exist
     */
    public MoneyType getShoppingBasketAsMoneyValue( EmailAddressType clientEmailAddress );




    /**
     * Checks out the cart of a client
     *
     * @param clientEmailAddress
     * @return A set of ids belonging to orders that were created during the checkout. If the shopping basket can
     *         only be served from more than one fulfillment center, each delivery from a fulfillment center gets a
     *         dedicated order. I.e. if there is just one delivery, then the set will contain just one order id.
     *         If there are multiple deliveries, the set will contain multiple order ids.
     * @throws ShopException if
     *      - clientEmailAddress is null or empty
     *      - the client with the given email address does not exist, or if the cart is empty
     * @throws
     *      - ShopException if clientEmailAddress is null
     *      - InsufficientStockException if there is not enough stock level for to serve the order
     *        for all items in the shopping basket
     */
    public Set<UUID> checkout( EmailAddressType clientEmailAddress );


    /**
     * Empties all shopping baskets in the system
     */
    public void emptyAllShoppingBaskets();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
package thkoeln.archilab.ecommerce.helpers.impl;

import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.test.web.servlet.MockMvc;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;


@TestConfiguration
public class RESTTestHelperConfiguration {

    @Bean
    public ShoppingBasketRESTHelper shoppingBasketRESTHelper(
            MockMvc mockMvc, ItemCatalogUseCases itemCatalogUseCases ) {
        return new ShoppingBasketRESTHelperImpl( mockMvc, itemCatalogUseCases );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingBasketRESTHelperImpl.java ---
package thkoeln.archilab.ecommerce.helpers.impl;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Map;
import java.util.UUID;

import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@Slf4j
public class ShoppingBasketRESTHelperImpl implements ShoppingBasketRESTHelper {
    private MockMvc mockMvc;
    private ItemCatalogUseCases itemCatalogUseCases;

    private static final ResultMatcher CREATED = status().isCreated();
    private static final ResultMatcher OK = status().isOk();

    public ShoppingBasketRESTHelperImpl( MockMvc mockMvc, ItemCatalogUseCases itemCatalogUseCases ) {
        this.mockMvc = mockMvc;
        this.itemCatalogUseCases = itemCatalogUseCases;
    }


    @Override
    public UUID getQueryShoppingBasket( EmailAddressType emailAddress, Map<UUID, Integer> quantityMap )
            throws Exception {
        // first query the clients API to get the proper clientId
        UUID clientId;
        String clientUri = "/clients?emailAddress=" + emailAddress.toString();
        MvcResult clientGetResult = mockMvc.perform( get( clientUri ) )
                .andExpect( status().isOk() )
                .andReturn();
        ObjectMapper objectMapper = new ObjectMapper();
        IdDTO idDTO = objectMapper.readValue( clientGetResult.getResponse().getContentAsString(), IdDTO.class );
        clientId = idDTO.getId();

        // then query the shopping basket API and extract the shopping basket id
        String shoppingBasketUri = "/shoppingBaskets?clientId=" + clientId.toString();
        ResultActions resultActions = mockMvc.perform( get( shoppingBasketUri ) )
                .andExpect( status().isOk() );
        idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
        UUID shoppingBasketId = idDTO.getId();

        // additional checks, if desired
        if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
        return shoppingBasketId;
    }


    private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
        if ( quantityMap == null ) return;
        int numOfItems = quantityMap.size();
        resultActions.andExpect( jsonPath( "$.positions.length()" ).value( numOfItems ) );
        float totalSellingPriceAsFloat = 0f;
        for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
            UUID itemId = entry.getKey();
            Integer quantity = entry.getValue();
            resultActions.andExpect( jsonPath( "$.positions.[?(@.itemId == '" + itemId + "')].quantity" )
                    .value( quantity ) );
            MoneyType sellingPrice = itemCatalogUseCases.getSellingPrice( itemId );
            totalSellingPriceAsFloat += sellingPrice.getAmount() * quantity;
        }
        // last thing - check the total selling price
        String totalSellingPriceString = String.format( "%.2f €", totalSellingPriceAsFloat );
        resultActions
                .andExpect( jsonPath( "$.totalSellingPrice" ).value( totalSellingPriceString ) );
    }


    @Override
    public void addItemToShoppingBasket( UUID shoppingBasketId, UUID itemId, Integer quantity )
            throws Exception {
        addItemToShoppingBasket( shoppingBasketId, itemId, quantity, null );
    }


    @Override
    public void addItemToShoppingBasket( UUID shoppingBasketId, UUID itemId, Integer quantity,
                                                  ResultMatcher expectedStatus ) throws Exception {
        ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
        ObjectMapper objectMapper = new ObjectMapper();
        QuantityDTO dto = new QuantityDTO( itemId, quantity );
        String quantityJson = objectMapper.writeValueAsString( dto );
        mockMvc.perform( post( "/shoppingBaskets/" + shoppingBasketId + "/positions" )
                        .contentType( APPLICATION_JSON ).content( quantityJson ) )
                .andExpect( status );
    }



    @Override
    public void deleteItemFromShoppingBasket( UUID shoppingBasketId, UUID itemId )
            throws Exception {
        deleteItemFromShoppingBasket( shoppingBasketId, itemId, null );
    }



    @Override
    public void deleteItemFromShoppingBasket( UUID shoppingBasketId, UUID itemId,
                                                      ResultMatcher expectedStatus ) throws Exception {
        ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
        String uri = "/shoppingBaskets/" + shoppingBasketId + "/positions/" + itemId;
        mockMvc.perform( delete( uri ) ).andExpect( status );
    }


    @Override
    public void checkout( UUID shoppingBasketId, String expectedClientName,
                          ResultMatcher expectedStatus,
                          Map<UUID, Map<UUID, Integer>> expectedOrders ) throws Exception {
        ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
        String uri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
        MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
        ObjectMapper objectMapper = new ObjectMapper();

        // check the response content
        if ( expectedOrders != null || expectedClientName != null ) {
            String responseContent = result.getResponse().getContentAsString();
            log.info( "ShoppingBasketRESTHelperImpl - checkout: found response content " + responseContent );
            OrderDTO[] orders = objectMapper.readValue( responseContent, OrderDTO[].class );
            checkExpectedClientName( expectedClientName, orders );
            checkExpectedOrders( expectedOrders, orders );
        }
    }


    private void checkExpectedClientName( String expectedClientName, OrderDTO[] orders ) {
        if ( expectedClientName == null ) return;
        for ( OrderDTO order : orders ) {
            if ( !order.getClientName().equals( expectedClientName ) ) {
                throw new AssertionError( "Expected clientName '" + expectedClientName +
                        "' but got '" + order.getClientName() + "'" );
            }
        }
    }


    private void checkExpectedOrders( Map<UUID, Map<UUID, Integer>> expectedOrders,
                                            OrderDTO[] orders ) {
        if ( expectedOrders == null ) return;
        for ( OrderDTO order : orders ) {
            UUID fulfillmentCenterId = order.getFulfillmentCenterId();
            Map<UUID, Integer> expectedQuantities = expectedOrders.get( fulfillmentCenterId );
            if ( expectedQuantities == null ) {
                throw new AssertionError( "No expected quantities for fulfillment center " + fulfillmentCenterId );
            }
            QuantityDTO[] positions = order.getPositions();
            for ( QuantityDTO quantityDTO : positions ) {
                UUID itemId = quantityDTO.getItemId();
                Integer expectedQuantity = expectedQuantities.get( itemId );
                if ( expectedQuantity == null ) {
                    throw new AssertionError( "No expected quantity for item " + itemId +
                            " in fulfillment center " + fulfillmentCenterId );
                }
                if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
                    throw new AssertionError( "Expected quantity " + expectedQuantity + " for item " +
                            itemId + " in fulfillment center " + fulfillmentCenterId +
                            ", but got " + quantityDTO.getQuantity() );
                }
            }
        }
    }


    /**
     * A DTO containing just a quantity, used in testing.
     * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
     * Therefore, constructors and getters/setters are manually defined.
     */
    @NoArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class QuantityDTO {
        private UUID itemId;
        private Integer quantity;

        public QuantityDTO( UUID itemId, Integer quantity ) {
            this.itemId = itemId;
            this.quantity = quantity;
        }
        public UUID getItemId() {
            return itemId;
        }
        public Integer getQuantity() {
            return quantity;
        }
        public void setItemId( UUID itemId ) {
            this.itemId = itemId;
        }
        public void setQuantity( Integer quantity ) {
            this.quantity = quantity;
        }
    }


    /**
     * A DTO containing just the id of an entity, used in testing.
     */
    @AllArgsConstructor
    @NoArgsConstructor
    @Getter
    @Setter
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class IdDTO {
        private UUID id;
    }


    /**
     * A DTO containing the order data, used in testing.
     * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
     * Therefore, constructors and getters/setters are manually defined.
     */
    @NoArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class OrderDTO {
        private UUID id;
        private String clientName;
        private UUID fulfillmentCenterId;
        private QuantityDTO[] positions;

        public UUID getId() {
            return id;
        }
        public String getClientName() {
            return clientName;
        }
        public UUID getFulfillmentCenterId() {
            return fulfillmentCenterId;
        }
        public QuantityDTO[] getPositions() {
            return positions;
        }
        public void setId( UUID id ) {
            this.id = id;
        }
        public void setClientName( String clientName ) {
            this.clientName = clientName;
        }
        public void setFulfillmentCenterId( UUID fulfillmentCenterId ) {
            this.fulfillmentCenterId = fulfillmentCenterId;
        }
        public void setPositions( QuantityDTO[] positions ) {
            this.positions = positions;
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingBasketRESTHelper.java ---
package thkoeln.archilab.ecommerce.helpers;

import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Map;
import java.util.UUID;

/**
 * A REST helper for shopping basket-related operations.
 * This interface defines methods to interact with a shopping basket via REST calls, such as querying, adding,
 * deleting, and checking out.
 */
public interface ShoppingBasketRESTHelper {
    /**
     * Executes a REST GET query on a shopping basket and returns its id, with the client's email address as a
     * starting point. The resulting shopping basket is checked against the given expected quantity map.
     * @param emailAddress The emailAddress of the client whose shopping basket is queried.
     * @param expectedQuantityMap A map of items and their quantities in the shopping basket. (If null, then don't check.)
     * @return The id of the client's shopping basket.
     * @throws Exception (whenever the REST call fails, or the shopping basket does not match the expected quantity map)
     */
    public UUID getQueryShoppingBasket( EmailAddressType emailAddress,
                                       Map<UUID, Integer> expectedQuantityMap ) throws Exception;


    /**
     * Adds a item to a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param itemId Id of the item.
     * @param quantity Quantity of the item.
     * @throws Exception (whenever the REST call fails)
     */
    public void addItemToShoppingBasket( UUID shoppingBasketId, UUID itemId, Integer quantity )
            throws Exception;


    /**
     * Adds a item to a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param itemId Id of the item.
     * @param quantity Quantity of the item.
     * @param expectedStatus expected status of the operation (null = CREATED)
     * @throws Exception (whenever the REST call fails or the status does not match)
     */
    public void addItemToShoppingBasket( UUID shoppingBasketId, UUID itemId, Integer quantity,
                                                  ResultMatcher expectedStatus ) throws Exception;


    /**
     * Deletes a item from a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param itemId Id of the item.
     * @throws Exception (whenever the REST call fails)
     */
    public void deleteItemFromShoppingBasket( UUID shoppingBasketId, UUID itemId )
            throws Exception;


    /**
     * Deletes a item from a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param itemId Id of the item.
     * @param expectedStatus expected status of the operation (null = OK)
     * @throws Exception (whenever the REST call fails or the status does not match)
     */
    public void deleteItemFromShoppingBasket( UUID shoppingBasketId, UUID itemId,
                                                      ResultMatcher expectedStatus ) throws Exception;


    /**
     * Checks out a shopping basket via REST call, and returns the id of the created order.
     * @param shoppingBasketId
     * @param expectedClientName expected name of the client who owns the shopping basket (null = don't check)
     * @param expectedStatus expected status of the operation (null = don't check)
     * @param expectedOrders the expected orders to be created as a result of the checkout. This is
     *                            a map of the following form:
     *                            <pre>
     *                               fulfillmentCenterId -> Map<itemId,Integer>
     *                            </pre>
     *                            where the inner map contains the items and their quantities
     * @return
     * @throws Exception
     */
    public void checkout( UUID shoppingBasketId, String expectedClientName,
                          ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedOrders )
           throws Exception;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\client\ClientRegistrationTest.java ---
package thkoeln.archilab.ecommerce.tests.client;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;


@SpringBootTest
public class ClientRegistrationTest {
    @Autowired
    private ClientRegistrationUseCases clientRegistrationUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ClientTestHelper clientTestHelper;

    private EmailAddressType nonExistingEmailAddress;
    private PhysicalAddressType somePhysicalAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        nonExistingEmailAddress = instantiateEmailAddress( "this@nononono.de" );
        somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
                instantiateZipCode( "90001" ) );
    }

    @Test
    public void testAllClientsRegistered() {
        // given
        clientTestHelper.registerAllClients();
        EmailAddressType emailAddress3 =
                clientTestHelper.getClientEmailAddress( 3 );
        String name3 = clientTestHelper.getClientName( 3 );
        PhysicalAddressType physicalAddress3 = clientTestHelper.getClientPhysicalAddress( 3 );

        // when
        ClientType client3 = clientRegistrationUseCases.getClientData(
                emailAddress3 );

        // then
        Assertions.assertEquals( name3, client3.getName() );
        Assertions.assertEquals( emailAddress3, client3.getEmailAddress() );
        Assertions.assertEquals( physicalAddress3, client3.getPhysicalAddress() );
    }


    @Test
    public void testRegisterClientWithDuplicateEmailAddress() {
        // given
        clientTestHelper.registerAllClients();
        PhysicalAddressType physicalAddress5 = clientTestHelper.getClientPhysicalAddress( 5 );
        EmailAddressType emailAddress5 =
                clientTestHelper.getClientEmailAddress( 5 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.register( "Gandalf The Grey",
                        emailAddress5, physicalAddress5 ) );
    }


    @Test
    public void testRegisterClientWithDuplicateNameOrPhysicalAddress() {
        // given
        clientTestHelper.registerAllClients();
        EmailAddressType newEmailAddress =
                instantiateEmailAddress( "some@this.de" );
        PhysicalAddressType physicalAddress2 = clientTestHelper.getClientPhysicalAddress( 2 );
        String name2 = clientTestHelper.getClientName( 2 );

        // when
        // then
        assertDoesNotThrow( () ->
                clientRegistrationUseCases.register( name2, newEmailAddress, physicalAddress2 ) );
    }


    @Test
    public void testRegisterClientWithInvalidData() {
        // given
        EmailAddressType emailAddress5 =
                clientTestHelper.getClientEmailAddress( 5 );
        PhysicalAddressType physicalAddress5 = clientTestHelper.getClientPhysicalAddress( 5 );
        String name5 = clientTestHelper.getClientName( 5 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.register( null, emailAddress5, physicalAddress5 ) );
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.register("", emailAddress5, physicalAddress5 ) );
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.register( name5, null, physicalAddress5 ) );
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.register( name5, emailAddress5, null ) );
    }


    @Test
    public void testChangeAddressWithInvalidData() {
        // given
        clientTestHelper.registerAllClients();
        PhysicalAddressType physicalAddress7 = clientTestHelper.getClientPhysicalAddress( 7 );
        EmailAddressType emailAddress7 =
                clientTestHelper.getClientEmailAddress( 7 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.changeAddress( nonExistingEmailAddress, physicalAddress7 ) );
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.changeAddress( null, physicalAddress7 ) );
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.changeAddress( emailAddress7, null ) );
    }


    @Test
    public void testGetDataForNonexistingEmailAddress() {
        // given
        clientTestHelper.registerAllClients();

        // when
        // then
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.getClientData( nonExistingEmailAddress ) );
    }


    @Test
    public void testDeleteClientsNoMoreClients() {
        // given
        clientTestHelper.registerAllClients();
        EmailAddressType emailAddress0 =
                clientTestHelper.getClientEmailAddress( 0 );


        // when
        clientRegistrationUseCases.deleteAllClients();

        // then
        assertThrows( ShopException.class, () -> clientRegistrationUseCases.getClientData(
                emailAddress0 ) );
    }


    @Test
    public void testChangeAddressSuccessful() {
        // given
        clientTestHelper.registerAllClients();
        EmailAddressType emailAddress6 =
                clientTestHelper.getClientEmailAddress( 6 );

        // when
        clientRegistrationUseCases.changeAddress( emailAddress6, somePhysicalAddress );
        ClientType newClient6 =
                clientRegistrationUseCases.getClientData( emailAddress6 );

        // then
        Assertions.assertEquals( emailAddress6, newClient6.getEmailAddress() );
        Assertions.assertEquals( somePhysicalAddress, newClient6.getPhysicalAddress() );
    }


    @Test
    public void testChangeAddressForNonexistingEmailAddress() {
        // given
        clientTestHelper.registerAllClients();

        // when
        // then
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.changeAddress( nonExistingEmailAddress, somePhysicalAddress ) );
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\client\ClientRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.client;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.web.servlet.MockMvc;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.*;

import java.util.UUID;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class ClientRESTTest {
    @Autowired
    private ClientRegistrationUseCases clientRegistrationUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ClientTestHelper clientTestHelper;
    @Autowired
    private MockMvc mockMvc;

    private UUID randomId;
    private EmailAddressType nonExistingEmailAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        clientTestHelper.registerAllClients();

        nonExistingEmailAddress = FactoryMethodInvoker.instantiateEmailAddress(
                "harry@sally.de" );
        randomId = UUID.randomUUID();
    }


    @Test
    public void testInvalidClientUris() throws Exception {
        // given
        String allClientsUri = "/clients";
        String randomIdUri = "/clients/" +  randomId;
        String nonExistingEmailAddressUri = "/clients?emailAddress=" + nonExistingEmailAddress;
        String randomParamUri = "/clients?randomParam=randomValue";

        // when
        // then
        mockMvc.perform( get( allClientsUri ) ).andExpect( status().isMethodNotAllowed() );
        mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( nonExistingEmailAddressUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
    }


    @Test
    public void testRandomClientId() throws Exception {
        // given
        String invalidUri = "/clients/" +  randomId;

        // when
        // then
        mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testQueryClient() throws Exception {
        // given
        EmailAddressType emailAddress4 =
                clientTestHelper.getClientEmailAddress( 4 );
        String clientUri4 = "/clients?emailAddress=" + emailAddress4;

        // when
        ClientType client4 = clientRegistrationUseCases.getClientData( emailAddress4 );
        String name = clientTestHelper.getClientName( 4 );
        PhysicalAddressType physicalAddress4 = clientTestHelper.getClientPhysicalAddress( 4 );

        // then (check using JSONPath)
        mockMvc.perform( get( clientUri4 ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.name" ).value( name ) )
                // id is position 0 (cannot be tested with current API structure), name is position 1,
                // email address is 2, physical address is 3)
                .andExpect( jsonPath( "$..emailAddressString" ).value( emailAddress4.toString() ) )
                .andExpect( jsonPath( "$..city" ).value( physicalAddress4.getCity() ) )
                .andExpect( jsonPath( "$..zipCodeString" ).value(
                        physicalAddress4.getZipCode().toString() ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class BasicNoOutsideSolutionRulesTest {

    @ArchTest
    static final ArchRule noClassesOnTopLevel =
            classes().should().resideInAPackage( "..solution.*.." )
                    .allowEmptyShould( true );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.library.Architectures.layeredArchitecture;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln")
@SuppressWarnings("PMD")
public class BasicProperDependenciesTest {

    @ArchTest
    static final ArchRule properDependencies =
            layeredArchitecture()
                    .consideringAllDependencies()
                    //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
                    .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
                    .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )

                    //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
                    .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
                    .allowEmptyShould( true );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import org.junit.jupiter.api.Test;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.MetadataReaderFactory;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertTrue;

public class BasicRequiredClassesTest {
    private static final String[] REQUIRED_CLASSES = {
            "Client",
            "ClientRepository",
            "Item",
            "ItemRepository",
            "Order",
            "OrderRepository",
            "StockLevel",
            "ShoppingBasket",
            "ShoppingBasketRepository",
            "FulfillmentCenterRepository",
            "ShoppingBasketPosition",
            "OrderPosition",
            "FulfillmentCenter",
    };

    @Test
    public void testRequiredClassesDeclared() throws IOException {
        String basePackage = "thkoeln.archilab.ecommerce";
        String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";

        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );

        Set<String> foundClasses = new HashSet<>();

        Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
            try {
                MetadataReader reader = readerFactory.getMetadataReader( resource );
                foundClasses.add( reader.getClassMetadata().getClassName() );
            } catch (IOException e) {
                e.printStackTrace();
            }
        } );

        Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
            boolean found = foundClasses.stream().anyMatch(className ->
                    className.startsWith(basePackage) && className.endsWith("." + requiredClass)
            );
            assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
        });
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.ApplicationContext;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
public class BasicUseCaseImplementationPackageTest {

    @Autowired
    private ApplicationContext applicationContext;

    private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
        put("ClientRegistrationUseCases", Arrays.asList("client"));
        put("FulfillmentCenterUseCases", Arrays.asList("fulfillmentcenter"));
        put("ItemCatalogUseCases", Arrays.asList("item"));
        put("ShoppingBasketUseCases", Arrays.asList("shoppingbasket"));
        put("OrderUseCases", Arrays.asList("order"));
    }};
    private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
    private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";

    @Test
    public void testRequiredClassesDeclared() {
        for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
            String interfaceName = USECASE_PATH + "." + entry.getKey();
            List<String> correctTopLevelPackages = entry.getValue();
            Class<?> useCaseInterfaceClass = null;
            try {
                useCaseInterfaceClass = Class.forName( interfaceName );
            } catch (ClassNotFoundException e) {
                fail( "Use case interface " + interfaceName + " not found.", e );
                continue;
            }
            String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
            assertEquals( 1, beans.length,
                    "There should be exactly 1 service implementation for the interface " +
                            entry.getKey() + ", but found " + beans.length );
            Object bean = applicationContext.getBean( beans[0] );
            boolean isValid = false;
            for ( String correctTopLevelPackage : correctTopLevelPackages ) {
                String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
                if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
                    isValid = true;
                    break;
                }
            }
            assertTrue( isValid,
                    "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
                            + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Service;

import jakarta.persistence.Entity;
import org.springframework.web.bind.annotation.RestController;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class DDDRulesTest {

    @ArchTest
    static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
            noClasses().that().resideInAPackage( "..domain.." )
                    .should().dependOnClassesThat().resideInAPackage( "..application.." )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule entitiesMustResideInADomainPackage =
            classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
                    .as( "Entities must reside in a package '..domain..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule entitiesMustNotAccessRepositories =
            noClasses().that().areAnnotatedWith( Entity.class )
                    .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule repositoriesMustResideInADomainPackage =
            classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
                    .as( "Repositories must reside in a package '..domain..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule repositoryNamesMustHaveProperSuffix =
            classes().that().areAssignableTo( CrudRepository.class )
                    .should().haveSimpleNameEndingWith( "Repository" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule servicesMustResideInAnApplicationPackage =
            classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
                    .as( "Application Services must reside in a package '..application..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule serviceNamesMustHaveProperSuffix =
            classes().that().areAnnotatedWith( Service.class )
                    .should().haveSimpleNameEndingWith( "Service" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule controllersMustResideInAnApplicationPackage =
            classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
                    .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );

    @ArchTest
    static final ArchRule controllersNamesMustHaveProperSuffix =
            classes().that().areAnnotatedWith( RestController.class )
                    .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );

    @ArchTest
    static final ArchRule controllersMustNotAccessRepositories =
            noClasses().that().areAnnotatedWith( RestController.class )
                    .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
                    .allowEmptyShould( false );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.library.dependencies.SliceAssignment;
import com.tngtech.archunit.library.dependencies.SliceIdentifier;
import org.junit.jupiter.api.Test;

import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;

public class NoCycleTest {
    private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");

    private SliceAssignment inAllClasses() {
        return new SliceAssignment() {
            @Override
            public String getDescription() {
                return "every class in it's own slice";
            }

            @Override
            public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
                return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
            }
        };
    }

    @Test
    public void testNoCyclicDependenciesBetweenClasses() {
        slices().assignedFrom(inAllClasses())
                .namingSlices("$1[$2.$3]")
                .should().beFreeOfCycles()
                .check(importedClasses);
    }

    @Test
    public void testNoCyclicDependenciesBetweenPackages() {
        ArchRule rule = slices().matching("..solution.(*)..")
                .should().beFreeOfCycles().allowEmptyShould( true );
        rule.check(importedClasses);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.base.DescribedPredicate;
import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaField;
import com.tngtech.archunit.core.domain.JavaParameterizedType;
import com.tngtech.archunit.core.domain.JavaType;
import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchCondition;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.lang.ConditionEvents;
import com.tngtech.archunit.lang.SimpleConditionEvent;
import jakarta.persistence.*;
import lombok.extern.slf4j.Slf4j;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.List;

import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
@Slf4j
public class OnlyReferenceViaIDTest { //FULFILLMENT_CENTER
    private static final String SHOPPING_BASKET_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingbasket.domain";
    private static final String CLIENT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.client.domain";
    private static final String ITEM_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.item.domain";
    private static final String ORDER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.order.domain";
    private static final String FULFILLMENT_CENTER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain";

    @ArchTest
    static final ArchRule idFieldsMustUseGenericId =
            fields()
                    .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
                    .and().areAnnotatedWith( Id.class )
                    .should().haveRawType( assignableTo( GenericId.class ) )
                    .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
                    .allowEmptyShould( true );


    private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
            annotatedWith( ManyToOne.class )
                    .or( annotatedWith( OneToOne.class ) )
                    .or( annotatedWith( Embedded.class ) )
                    .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );

    private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
            annotatedWith( OneToMany.class )
                    .or( annotatedWith( ManyToMany.class ) )
                    .or( annotatedWith( ElementCollection.class ) )
                    .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );


    private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
        String description = "an entity or value object from same aggregate, or a domain primitive";
        return new DescribedPredicate<>( description ) {
            @Override
            public boolean test( JavaClass type ) {
                // check if the class is an entity or value object, and resides in the allowed package
                if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
                    return false;
                }
                // a GenericId is always allowed
                if ( type.isAssignableTo( GenericId.class ) ) {
                    return true;
                }
                // a domain primitive is also always allowed
                if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
                    return true;
                }
                return type.getPackageName().startsWith( allowedPackage );
            }
        };
    }


    @ArchTest
    static final ArchRule shoppingBasketToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule clientToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( CLIENT_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( CLIENT_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule itemToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( ITEM_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( ITEM_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule orderToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule fulfillmentCenterToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( FULFILLMENT_CENTER_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( FULFILLMENT_CENTER_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );


    private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
        return new ArchCondition<JavaField>(
                "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
            @Override
            public void check( JavaField field, ConditionEvents events ) {
                JavaClass rawType = field.getRawType();
                String rawTypeName = rawType.getFullName();
                if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
                    return;
                }
                JavaType fieldType = field.getType();
                if ( !( fieldType instanceof JavaParameterizedType ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " is a raw List/Set without a type argument" ) );
                    return;
                }
                List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
                if ( typeArguments.isEmpty() ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " has no type arguments" ) );
                    return;
                }
                JavaType elementType = typeArguments.get( 0 );
                if ( !( elementType instanceof JavaClass ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " has an unknown element type" ) );
                    return;
                }
                JavaClass elementClass = (JavaClass) elementType;
                boolean hasAnnotation =
                        elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
                boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
                boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
                boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
                boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
                if ( !ok ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " refers to " + elementClass.getFullName()
                                    + " which is not a DP, or an entity/value object in " + allowedPackage ) );
                }
            }
        };
    }


    @ArchTest
    static final ArchRule shoppingBasketToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule clientToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( CLIENT_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( CLIENT_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule itemToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( ITEM_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( ITEM_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule orderToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule fulfillmentCenterToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( FULFILLMENT_CENTER_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( FULFILLMENT_CENTER_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

/**
 * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
 */

public class OwnTestsTest {
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

public class PackageStructureTest {

    private static final String[] REQUIRED_PACKAGES = {"client", "shoppingbasket", "item", "order", "fulfillmentcenter"};
    private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
    private JavaClasses importedClasses;


    @BeforeEach
    public void setUp() {
        importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
    }

    @Test
    void testRequiredPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage;
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredDomainPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected domain sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredApplicationPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected application sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

@ArchTag("domainPrimitivesUsageRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class DomainPrimitivesUsageRulesTest {
    private static final String EMAIL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.EmailAddress";
    private static final String MONEY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Money";
    private static final String PHYSICAL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress";

    @ArchTest
    static final ArchRule clientShouldReferenceEmailAddress =
            classes()
                    .that().haveSimpleName( "Client" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( EMAIL_ADDRESS_CLASS )
                    .because( "Client should use EmailAddress instead of String" );

    @ArchTest
    static final ArchRule clientShouldReferencePhysicalAddress =
            classes()
                    .that().haveSimpleName( "Client" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
                    .because( "Client should use PhysicalAddress instead of whatever else" );

    @ArchTest
    static final ArchRule fulfillmentCenterShouldReferencePhysicalAddress =
            classes()
                    .that().haveSimpleName( "FulfillmentCenter" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
                    .because( "Client should use PhysicalAddress instead of whatever else" );

    @ArchTest
    static final ArchRule itemShouldReferenceMoney =
            classes()
                    .that().haveSimpleName( "Item" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( MONEY_CLASS )
                    .because( "Item should use Money instead of float or whatever else" );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\EmailAddressTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmailAddress;

class EmailAddressTest {

    @Test
    public void testToStringEmailAddress() {
        // given
        String input = "test@example.com";

        // when
        EmailAddressType instance = instantiateEmailAddress( input );

        // then
        assertEquals( input, instance.toString() );
    }

    @Test
    public void testEqualityEmailAddress() {
        // given
        // when
        EmailAddressType instance1 = instantiateEmailAddress( "test@example.com" );
        EmailAddressType instance2 = instantiateEmailAddress( "test@example.com" );
        EmailAddressType instance3 = instantiateEmailAddress( "different@example.com" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutabilityEmailAddress() {
        // given
        // when
        EmailAddressType instance = instantiateEmailAddress( "test@example.com" );

        // then
        try {
            instance.getClass().getMethod( "setEmailAddress", String.class );
            fail( "setEmailAddress method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }



    @Test
    public void smokeTestForCopyConstructors() {
        // given
        EmailAddressType emailAddress =
                instantiateEmailAddress( "peter.schmidt@web.de" );

        // when
        EmailAddressType emailAddressOtherIdentifyer =
                emailAddress.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
        assertThrows( ShopException.class, () ->
                emailAddress.sameDomainDifferentIdentifyer( "p...eter" ) );
        EmailAddressType emailAddressOtherDomain =
                emailAddress.sameIdentifyerDifferentDomain( "web.ch" );
        assertThrows( ShopException.class, () ->
                emailAddress.sameIdentifyerDifferentDomain( "web.edu" ) );

        // then
        assertEquals( "p.e.t.e.r@web.de", emailAddressOtherIdentifyer.toString() );
        assertEquals( "peter.schmidt@web.ch", emailAddressOtherDomain.toString() );
    }


    @Test
    public void testFactoryValidEmailAddress() {
        // given
        // when
        // then
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "99Z@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "GGGhh@s77.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "a@4.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "Max.Hammer@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "Max.Gideon.Hammer@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.this.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.de" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.at" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.ch" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.org" ) );
    }


    @Test
    public void testFactoryInvalidEmailAddress() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateEmailAddress( null ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "testexample.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "Max..Gideon.Hammer@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@examplecom" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example..com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test#example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.42" ) );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\MoneyTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMoney;

class MoneyTest {

    @Test
    public void testGetAmountMoney() {
        // given
        Float inputAmount = 10.0f;

        // when
        MoneyType instance = instantiateMoney( inputAmount, "EUR" );

        // then
        assertEquals( inputAmount, instance.getAmount() );
    }

    @Test
    public void testGetCurrencyUnitMoney() {
        // given
        String inputCurrencyUnit = "EUR";

        // when
        MoneyType instance = instantiateMoney( 10.0f, inputCurrencyUnit );

        // then
        assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
    }

    @Test
    public void testAddToMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );

        // when
        MoneyType result12 = instance1.add( instance2 );
        MoneyType result13 = instance1.add( instance3 );

        // then
        assertEquals( 30.0f, result12.getAmount() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
        assertEquals( 10.0f, result13.getAmount() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
    }

    @Test
    public void testInvalidAddToMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
    }

    @Test
    public void testSubtractFromMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 30.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
        MoneyType instance4 = instantiateMoney( 30.0f, "EUR" );

        // when
        MoneyType result12 = instance1.subtract( instance2 );
        MoneyType result13 = instance1.subtract( instance3 );
        MoneyType result14 = instance1.subtract( instance4 );

        // then
        assertEquals( 10.0f, result12.getAmount() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
        assertEquals( 30.0f, result13.getAmount() );
        assertEquals( "EUR", result13.getCurrencyUnit() );
        assertEquals( 0.0f, result14.getAmount() );
        assertEquals( "EUR", result14.getCurrencyUnit() );
    }

    @Test
    public void testInvalidSubtractFromMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 5.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
        assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
    }

    @Test
    public void testMultiplyByMoney() {
        // given
        MoneyType instance = instantiateMoney( 10.0f, "EUR" );

        // when
        MoneyType result = instance.multiplyBy( 3 );

        // then
        assertEquals( 30.0f, result.getAmount() );
        assertEquals( "EUR", result.getCurrencyUnit() );
    }

    @Test
    public void testFactoryValidCurrencyUnitMoney() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiateMoney( 10.0f, "EUR" ) );
    }

    @Test
    public void testFactoryInvalidCurrencyUnitMoney() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateMoney( -10.0f, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, "USD" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( null, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, null ) );
    }

    @Test
    public void testLargerThanCurrencyUnitMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance4 = instantiateMoney( 10.0f, "CHF" );

        // when
        // then
        assertTrue( instance2.largerThan( instance1 ) );
        assertFalse( instance1.largerThan( instance2 ) );
        assertFalse( instance1.largerThan( instance3 ) );
        assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
    }


    @Test
    public void testEqualityCurrencyUnitMoney() {
        // given
        // when
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 20.0f, "EUR" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutabilityCurrencyUnitMoney() {
        // given
        // when
        MoneyType instance = instantiateMoney( 10.0f, "EUR" );

        // then
        try {
            instance.getClass().getMethod( "setAmount", Float.class );
            fail( "setAmount method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }

        try {
            instance.getClass().getMethod( "setCurrencyUnit", String.class );
            fail( "setCurrencyUnit method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\PhysicalAddressTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;

class PhysicalAddressTest {

    @Test
    public void testGetterPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );

        // then
        assertEquals( street, instance.getStreet() );
        assertEquals( city, instance.getCity() );
        assertEquals( plz, instance.getZipCode() );
    }

    @Test
    public void testFactoryValidPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        // then
        assertDoesNotThrow( () -> instantiatePhysicalAddress( street, city, plz ) );
    }

    @Test
    public void testFactoryInvalidPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        // then
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( null, city, plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( "", city, plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, null, plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, "", plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, city, null ) );
    }

    @Test
    public void testEqualityPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        PhysicalAddressType instance1 = instantiatePhysicalAddress( street, city, plz );
        PhysicalAddressType instance2 = instantiatePhysicalAddress( street, city, plz );
        PhysicalAddressType instance3 = instantiatePhysicalAddress( "Anderestr. 12", city, plz );
        PhysicalAddressType instance4 = instantiatePhysicalAddress( street, "AndereStadt", plz );
        PhysicalAddressType instance5 = instantiatePhysicalAddress( street, city, instantiateZipCode( "54321" ) );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
        assertNotEquals( instance1, instance4 );
        assertNotEquals( instance1, instance5 );
    }

    @Test
    public void testImmutabilityPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );

        // then
        try {
            instance.getClass().getMethod( "setStreet", String.class );
            fail( "setStreet method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setCity", String.class );
            fail( "setCity method should not exist" );

        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setZipCode", ZipCodeType.class );
            fail( "setZipCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\ZipCodeTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;

class ZipCodeTest {

    private String input1, input4;
    private ZipCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
            _04233, _02544, _99123, _56323, _79332;


    @BeforeEach
    public void setUp() {
        input1 = "12345";
        input4 = "49188";
        _12345 = FactoryMethodInvoker.instantiateZipCode( "12345" );
        _12345b = FactoryMethodInvoker.instantiateZipCode( "12345" );
        _23455 = FactoryMethodInvoker.instantiateZipCode( "23455" );
        _01234 = FactoryMethodInvoker.instantiateZipCode( "01234" );
        _01235 = FactoryMethodInvoker.instantiateZipCode( "01235" );
        _01238 = FactoryMethodInvoker.instantiateZipCode( "01238" );
        _01263 = FactoryMethodInvoker.instantiateZipCode( "01263" );
        _01213 = FactoryMethodInvoker.instantiateZipCode( "01213" );
        _01823 = FactoryMethodInvoker.instantiateZipCode( "01823" );
        _01312 = FactoryMethodInvoker.instantiateZipCode( "01312" );
        _04233 = FactoryMethodInvoker.instantiateZipCode( "04233" );
        _02544 = FactoryMethodInvoker.instantiateZipCode( "02544" );
        _99123 = FactoryMethodInvoker.instantiateZipCode( "99123" );
        _56323 = FactoryMethodInvoker.instantiateZipCode( "56323" );
        _79332 = FactoryMethodInvoker.instantiateZipCode( "79332" );

    }


    @Test
    public void testToStringZipCode() {
        // given
        // when
        ZipCodeType instance = instantiateZipCode( input1 );

        // then
        assertEquals( input1, instance.toString() );
    }

    @Test
    public void testFactoryValidZipCode() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiateZipCode( input1 ) );
    }

    @Test
    public void testFactoryInvalidZipCode() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateZipCode( "123456" ) );
        assertThrows( ShopException.class, () -> instantiateZipCode( "1234" ) );
        assertThrows( ShopException.class, () -> instantiateZipCode( "20000" ) );
        assertThrows( ShopException.class, () -> instantiateZipCode( null ) );
    }

    @Test
    public void testEqualityZipCode() {
        // given
        // when
        ZipCodeType instance1a = instantiateZipCode( input1 );
        ZipCodeType instance1b = instantiateZipCode( input1 );
        ZipCodeType instance4 = instantiateZipCode( input4 );

        // then
        assertEquals( instance1a, instance1b );
        assertNotEquals( instance1a, instance4 );
    }

    @Test
    public void testImmutabilityZipCode() {
        // given
        // when
        ZipCodeType instance = instantiateZipCode( input1 );

        // then
        try {
            instance.getClass().getMethod( "setzipCode", String.class );
            fail( "setzipCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }


    @Test
    public void smokeTestForDifference() {
        // given
        ZipCodeType instance1a = instantiateZipCode( input1 );
        ZipCodeType instance1b = instantiateZipCode( input1 );
        ZipCodeType instance12479 = instantiateZipCode( "12479" );
        ZipCodeType instance21456 = instantiateZipCode( "21456" );

        // when
        int differenceAB = instance1a.difference( instance1b );
        int difference12 = instance1a.difference( instance12479 );
        int difference23 = instance12479.difference( instance21456 );

        // then
        assertEquals( 0, differenceAB );
        assertTrue( difference12 > 0 );
        assertTrue( difference23 > difference12 );
    }


    @Test
    public void testZipCodeFirstDigit() {
        // given
        ZipCodeType instance1 = instantiateZipCode( input1 );
        ZipCodeType instance4 = instantiateZipCode( input4 );

        // when
        // then
        assertEquals( 1, instance1.getFirstDigitZipCode() );
        assertEquals( 4, instance4.getFirstDigitZipCode() );
    }



    @Test
    public void testInvalidParameters() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () ->
                _12345.difference( null ) );
    }


    @Test
    public void testSameZipCode() {
        // given
        // when
        int diff = _12345.difference( _12345b );

        // then
        assertEquals( 0, diff );
    }


    /**
     *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
     *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
     *        So, 56733 and 56734 have the same difference as 56733 and 56739.
     *      - The difference grows if more digits (counted from the right side) differ.
     *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
     *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
     *        53876 and 54876 have the same difference as 53876 and 57261.
     */
    @Test
    public void testZipCodeDifferenceInAllButFirstDigit() {
        // given
        // when
        int diff5a = _01234.difference( _01235 );
        int diff5b = _01234.difference( _01238 );
        int diff4a = _01234.difference( _01263 );
        int diff4b = _01234.difference( _01213 );
        int diff3a = _01234.difference( _01823 );
        int diff3b = _01234.difference( _01312 );
        int diff2a = _01234.difference( _04233 );
        int diff2b = _01234.difference( _02544 );

        // then
        assertEquals( diff5a, diff5b, "difference 01234-01235 must be the same as difference 01234-01238" );
        assertEquals( diff4a, diff4b, "difference 01234-01263 must be the same as difference 01234-01213" );
        assertEquals( diff3a, diff3b, "difference 01234-01823 must be the same as difference 01234-01312" );
        assertEquals( diff2a, diff2b, "difference 01234-04233 must be the same as difference 01234-02544" );

        assertTrue( diff5a < diff4a,
                "difference 01234-01235 must be smaller than difference 01234-01263" );
        assertTrue( diff4a < diff3a,
                "difference 01234-01263 must be smaller than difference 01234-01823" );
        assertTrue( diff3a < diff2a,
                "difference 01234-01823 must be smaller than difference 01234-04233" );
    }


    /**
     *      - However, the difference between 5abcd and 6rstu must be smaller than the one
     *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
     *        one between 5abcd and 9rstu.
     *      - This last condition reflects the fact the first digits of a zip code marks a region
     *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
     *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
     *        other.
     */
    @Test
    public void testZipCodedifferenceInFirstDigit() {
        // given
        // when
        int diff1_1 = _01234.difference( _99123 );
        int diff1_2 = _01234.difference( _23455 );
        int diff1_5 = _01234.difference( _56323 );
        int diff1_3 = _01234.difference( _79332 );

        // then
        assertTrue( diff1_1 < diff1_2,
                "difference 01234-99123 must be smaller than difference 01234-23455"  );
        assertTrue( diff1_2 < diff1_3,
                "difference 01234-23455 must be smaller than difference 01234-79332" );
        assertTrue( diff1_3 < diff1_5,
                "difference 01234-79332 must be smaller than difference 01234-56323"  );
    }



}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
package thkoeln.archilab.ecommerce.tests.e1restcalls;

import org.junit.jupiter.api.Test;
import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;


public class E1RestCallTableTest {

    private GenericTableSpecificationTests genericTableSpecificationTests = null;


    public E1RestCallTableTest() {
        this.genericTableSpecificationTests = new GenericTableSpecificationTests();
    }

    @Test
    public void restTest() throws Exception {
        genericTableSpecificationTests.testTableSpecification("E1" );
    }
}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\fulfillmentcenter\FulfillmentCenterManagementTest.java ---
package thkoeln.archilab.ecommerce.tests.fulfillmentcenter;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;


/**
 * This test checks the management and lifecycle of fulfillment centers.
 */
@SpringBootTest
public class FulfillmentCenterManagementTest {
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;

    private PhysicalAddressType somePhysicalAddress;
    private UUID nonExistingId1;
    private UUID nonExistingId2;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        itemTestHelper.addAllItems();

        somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
                instantiateZipCode( "90001" ) );
        nonExistingId1 = UUID.randomUUID();
        nonExistingId2 = UUID.randomUUID();
    }


    @Test
    public void testAddInvalidFulfillmentCenter() {
        // given
        String name = "Lager1";

        // when
        // then
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
                        null, somePhysicalAddress ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
                        "", somePhysicalAddress ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
                        name, null ) );
    }


    @Test
    public void testDeleteAllFulfillmentCentersWhenEmpty() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
        UUID itemId9 = itemTestHelper.getItemId( 9 );
        UUID fulfillmentCenterId1 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 1 );
        UUID fulfillmentCenterId2 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 2 );

        // when
        int numOf1 = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId1, itemId9 );
        int numOf2 = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId2, itemId9 );

        // then
        assertEquals( 0, numOf1 );
        assertEquals( 0, numOf2 );
        fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
        // ... ids must be invalid now
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId1, itemId9 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId2, itemId9 ) );
    }


    @Test
    public void testDeleteAllFulfillmentCentersWhenFull() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID itemId7 = itemTestHelper.getItemId( 7 );
        UUID fulfillmentCenterId1 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 1 );
        UUID fulfillmentCenterId2 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 2 );

        // when
        int numOf1 = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId1, itemId7 );
        int numOf2 = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId2, itemId7 );

        // then
        assertTrue( numOf1 == 3 );
        assertTrue( numOf2 == 3 );
        fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
        // ... ids must be invalid now
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId1, itemId7 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId2, itemId7 ) );
    }



    @Test
    public void testAddToStock() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in fulfillment center 0
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        int originalStock5 =
                fulfillmentCenterTestHelper.getFulfillmentCenterStock( 0, 5 );

        // when
        int stock5before = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId5 );
        fulfillmentCenterUseCases.addToStock( fulfillmentCenterId0, itemId5, 23 );
        int stock5after = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId5 );
        fulfillmentCenterUseCases.addToStock( fulfillmentCenterId0, itemId5, 0 );
        int stock5after2 = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId5 );

        // then
        assertEquals( originalStock5, stock5before );
        assertEquals( stock5before + 23, stock5after );
        assertEquals( stock5after, stock5after2 );
    }


    @Test
    public void testInvalidAddToStock() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID itemId2 = itemTestHelper.getItemId( 2 );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );

        // when
        // then
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addToStock( nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addToStock(
                        fulfillmentCenterId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addToStock(
                        nonExistingId1, itemId2, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addToStock(
                        fulfillmentCenterId0, itemId2, -1 ) );
    }


    @Test
    public void testRemoveFromStock() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID itemId0 = itemTestHelper.getItemId( 0 ); // 0 in fulfillment center 0
        UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in fulfillment center 0
        UUID itemId6 = itemTestHelper.getItemId( 6 ); // random >30 in fulfillment center 0
        int stock0before =
                fulfillmentCenterTestHelper.getFulfillmentCenterStock( 0, 0 );
        int stock5before =
                fulfillmentCenterTestHelper.getFulfillmentCenterStock( 0, 5 );
        int stock6before =
                fulfillmentCenterTestHelper.getFulfillmentCenterStock( 0, 6 );

        // when
        fulfillmentCenterUseCases.removeFromStock( fulfillmentCenterId0, itemId5, 1 );
        int stock5after = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId5 );
        fulfillmentCenterUseCases.removeFromStock( fulfillmentCenterId0, itemId0, 0 );
        int stock0after = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId0 );
        fulfillmentCenterUseCases.removeFromStock(
                fulfillmentCenterId0, itemId6, stock6before );
        int stock6after = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId6 );

        // then
        assertEquals( stock5before - 1, stock5after );
        assertEquals( stock0before, stock0after );
        assertEquals( 0, stock6after );
    }


    @Test
    public void testInvalidRemoveFromStock() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID itemId0 = itemTestHelper.getItemId( 0 ); // 0 in fulfillment center 0
        UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in fulfillment center 0
        int stock5before =
                fulfillmentCenterTestHelper.getFulfillmentCenterStock( 0, 5 );

        // when
        // then
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromStock( nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromStock(
                        fulfillmentCenterId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromStock(
                        nonExistingId1, itemId5, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromStock(
                        fulfillmentCenterId0, itemId5, -1 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromStock(
                        fulfillmentCenterId0, itemId5, stock5before + 1 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromStock(
                        fulfillmentCenterId0, itemId0, 1 ) ); // already 0 in fulfillment center 0
    }


    @Test
    public void testChangeStock() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in fulfillment center 0

        // when
        fulfillmentCenterUseCases.changeStockTo( fulfillmentCenterId0, itemId5, 111 );
        int stock5after = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId5 );

        // then
        assertEquals( 111, stock5after );
    }


    @Test
    public void testInvalidChangeStock() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID itemId6 = itemTestHelper.getItemId( 6 );

        // when
        // then
        assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeStockTo(
                nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeStockTo(
                nonExistingId1, itemId6, 12 ) );
        assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeStockTo(
                fulfillmentCenterId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeStockTo(
                fulfillmentCenterId0, itemId6, -1 ) );
    }


    @Test
    public void testEmptyFulfillmentCenter() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID fulfillmentCenterId9 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 9 ); // empty fulfillment center

        // when
        int totalStock = 0;
        for ( int iItem = 0; iItem < itemTestHelper.numberOfItems(); iItem++ ) {
            UUID itemId = itemTestHelper.getItemId( iItem );
            totalStock += fulfillmentCenterUseCases.getAvailableStock(
                    fulfillmentCenterId9, itemId );
        }

        // then
        assertEquals( 0, totalStock );
    }



}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\item\ItemCatalogTest.java ---
package thkoeln.archilab.ecommerce.tests.item;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.*;

import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;


@SpringBootTest
public class ItemCatalogTest {
    @Autowired
    private ClientRegistrationUseCases clientRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ClientTestHelper clientTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        clientTestHelper.registerAllClients();
        itemTestHelper.addAllItems();
    }


    @Test
    public void testAddItemToCatalog() {
        // given
        UUID itemId4 = itemTestHelper.getItemId( 4 );
        MoneyType sellingPrice4 = itemTestHelper.getSellingPrice( 4 );

        // when
        MoneyType foundSellingPrice = itemCatalogUseCases.getSellingPrice( itemId4 );

        // then
        assertEquals( sellingPrice4, foundSellingPrice );
    }


    @Test
    public void testAddItemWithInvalidData() {
        // given
        String name = "SomeStuff";
        String description = "Some more explanation on the stuff";
        Float size = 5.0f;
        MoneyType buyingPrice =
                FactoryMethodInvoker.instantiateMoney( 5.0f, "EUR" );
        MoneyType sellingPrice =
                FactoryMethodInvoker.instantiateMoney( 10.0f, "EUR" );
        MoneyType tooLowSellingPrice =
                FactoryMethodInvoker.instantiateMoney( 4.0f, "EUR" );

        // when / then
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        null, description, size, buyingPrice, sellingPrice ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        "", description, size, buyingPrice, sellingPrice ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        name, null, size, buyingPrice, sellingPrice ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        name, "", size, buyingPrice, sellingPrice ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        name, description, size, null, sellingPrice ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        name, description, size, buyingPrice, null ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        name, description, size, buyingPrice, tooLowSellingPrice ) );
    }


    @Test
    public void testRemoveNonExistentItem() {
        // given item 2 is not in stock anywhere - should be removable
        UUID nonExistentItemId = UUID.randomUUID();

        // when
        // then
        assertThrows( ShopException.class,
                () -> itemCatalogUseCases.removeItemFromCatalog( nonExistentItemId ) );
    }


    @Test
    public void testRemoveItemWithNoStock() {
        // given item 0 is not in stock anywhere - should be removable
        UUID itemId0 = itemTestHelper.getItemId( 0 );
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );

        // when
        assertDoesNotThrow( () -> itemCatalogUseCases.getSellingPrice( itemId0 ) );
        itemCatalogUseCases.removeItemFromCatalog( itemId0 );

        // then
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.getSellingPrice( itemId0 ) );
    }


    @Test
    public void testRemoveItemThatIsInStock() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID itemId3 = itemTestHelper.getItemId( 3 );
        UUID itemId4 = itemTestHelper.getItemId( 4 );
        fulfillmentCenterUseCases.addToStock( fulfillmentCenterId0, itemId3, 3 );

        // then item 3 must not be removable, but item 4 must be removable
        assertThrows( ShopException.class,
                () -> itemCatalogUseCases.removeItemFromCatalog( itemId3 ) );
        assertDoesNotThrow( () -> itemCatalogUseCases.removeItemFromCatalog( itemId4 ) );
    }


    @Test
    public void testRemoveItemThatIsInOrder() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID itemId4 = itemTestHelper.getItemId( 4 );
        EmailAddressType clientEmailAddress4 =
                clientTestHelper.getClientEmailAddress( 4 );
        fulfillmentCenterUseCases.addToStock( fulfillmentCenterId0, itemId4, 4 );

        // when client 4 adds 4x item 4 to his shopping basket and checks out ...
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress4, itemId4, 4 );
        shoppingBasketUseCases.checkout( clientEmailAddress4 );

        // then item 4 must not be removable
        assertThrows( ShopException.class,
                () -> itemCatalogUseCases.removeItemFromCatalog( itemId4 ) );
    }


    @Test
    public void testClearItemCatalog() {
        // given
        UUID itemId4 = itemTestHelper.getItemId( 4 );

        // when
        itemCatalogUseCases.deleteItemCatalog();

        // then
        assertThrows( ShopException.class, () -> itemCatalogUseCases.getSellingPrice( itemId4 ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\order\OrderTest.java ---
package thkoeln.archilab.ecommerce.tests.order;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;


@SpringBootTest
public class OrderTest {
    @Autowired
    private ClientRegistrationUseCases clientRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private OrderUseCases orderUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ClientTestHelper clientTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;

    private UUID nonExistingId1;
    private UUID nonExistingId2;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        clientTestHelper.registerAllClients();
        itemTestHelper.addAllItems();
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        nonExistingId1 = UUID.randomUUID();
        nonExistingId2 = UUID.randomUUID();
    }


    @Test
    public void testOrderHistory() {
        // given
        UUID itemId1 = itemTestHelper.getItemId( 1 );
        UUID itemId2 = itemTestHelper.getItemId( 2 );
        EmailAddressType clientEmailAddress7 =
                clientTestHelper.getClientEmailAddress( 7 );
        Map<UUID, Integer> orderHistoryBefore = orderUseCases.getOrderHistory( clientEmailAddress7 );

        // when
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress7, itemId1, 3 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress7, itemId2, 2 );
        shoppingBasketUseCases.checkout( clientEmailAddress7 );
        Map<UUID, Integer> orderHistory1 =
                orderUseCases.getOrderHistory( clientEmailAddress7 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress7, itemId1, 6 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress7, itemId2, 2 );
        shoppingBasketUseCases.checkout( clientEmailAddress7 );
        Map<UUID, Integer> orderHistory2 =
                orderUseCases.getOrderHistory( clientEmailAddress7 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress7, itemId1, 1 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress7, itemId2, 6 );
        shoppingBasketUseCases.checkout( clientEmailAddress7 );
        Map<UUID, Integer> orderHistory3 =
                orderUseCases.getOrderHistory( clientEmailAddress7 );

        // then
        assertEquals( 0, orderHistoryBefore.size() );
        assertEquals( 2, orderHistory1.size() );
        assertEquals( 2, orderHistory2.size() );
        assertEquals( 2, orderHistory3.size() );
        assertEquals( 3, orderHistory1.get( itemId1 ) );
        assertEquals( 2, orderHistory1.get( itemId2 ) );
        assertEquals( 9, orderHistory2.get( itemId1 ) );
        assertEquals( 4, orderHistory2.get( itemId2 ) );
        assertEquals( 10, orderHistory3.get( itemId1 ) );
        assertEquals( 10, orderHistory3.get( itemId2 ) );
    }


    @Test
    public void testForEmptyOrderHistory() {
        // given
        EmailAddressType clientEmailAddress4 =
                clientTestHelper.getClientEmailAddress( 4 );
        // when
        Map<UUID, Integer> orderHistory =
                orderUseCases.getOrderHistory( clientEmailAddress4 );
        // then
        assertEquals( 0, orderHistory.size() );
    }


    @Test
    public void testInvalidParamsForGetOrderQuantForItem() {
        // given
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );

        // when / then
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForItem( null, null ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForItem( nonExistingId1, null ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForItem( null, nonExistingId2 ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForItem( nonExistingId1, nonExistingId2 ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForItem( fulfillmentCenterId0, null ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForItem( fulfillmentCenterId0, nonExistingId2 ) );
    }


    @Test
    public void testInvalidParamsForGetFulfillmentCenterIdForOrder() {
        // given / when / then
        assertThrows ( ShopException.class,
                () -> orderUseCases.getFulfillmentCenterIdForOrder( null ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getFulfillmentCenterIdForOrder( nonExistingId1 ) );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
package thkoeln.archilab.ecommerce.tests.owntests;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.fail;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.domainprimitives.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.math.BigDecimal;

import static org.assertj.core.api.Assertions.assertThat;



public class DomainPrimitiveJSONSerializationTest {

    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        objectMapper = new ObjectMapper();
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * EmailAddress.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_EmailAddress_Serialization() throws Exception {
        // TODO: implement this test
        // given
        EmailAddressType email = EmailAddress.of("test@example.com");

        // when
        String json = objectMapper.writeValueAsString(email); // → "test@example.com"
        EmailAddress deserialized = objectMapper.readValue(json, EmailAddress.class);

        // then
        assertThat(json).contains("test@example.com");
        assertThat(deserialized).isEqualTo(email);
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * ZipCode.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_ZipCode_Serialization() throws Exception {
        // TODO: implement this test
        // given
        ZipCode zipCode = ZipCode.of("50667");

        // when
        String json = objectMapper.writeValueAsString(zipCode);
        ZipCode deserialized = objectMapper.readValue(json, ZipCode.class);

        // then
        assertThat(json).contains("50667");
        assertThat(deserialized).isEqualTo(zipCode);
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * PhysicalAddress.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_PhysicalAddress_Serialization() throws Exception {
        // TODO: implement this test
        // given
        PhysicalAddress address = PhysicalAddress.of("Bahnhofstr. 1", "Köln", ZipCode.of("50667"));

        // when
        String json = objectMapper.writeValueAsString(address);
        PhysicalAddress deserialized = objectMapper.readValue(json, PhysicalAddress.class);

        // then
        assertThat(json).contains("Bahnhofstr. 1", "Köln", "50667");
        assertThat(deserialized).isEqualTo(address);
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * Money.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_Money_Serialization() throws Exception {
        // TODO: implement this test
        // given
        Money money = Money.of(12.34f, "EUR");

        // when
        String json = objectMapper.writeValueAsString(money);
        Money deserialized = objectMapper.readValue(json, Money.class);

        // then
        assertThat(json).contains("12.34", "EUR");
        assertThat(deserialized).isEqualTo(money);
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingBasketRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.owntests;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;

import java.util.Locale;
import java.util.Map;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;


@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import(RESTTestHelperConfiguration.class)
public class OwnShoppingBasketRESTTest {
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ClientTestHelper clientTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ShoppingBasketRESTHelper shoppingBasketRESTHelper;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        clientTestHelper.registerAllClients();
        itemTestHelper.addAllItems();
        fulfillmentCenterTestHelper.addAllFulfillmentCenters(true);
        Locale.setDefault(Locale.US);

        // ... add own setup code here
    }


    /**
     * Provide a test that implements a simple call to the REST endpoint (3):
     * <pre>
     *     GET /shoppingBaskets?clientId=<client id as uuid>
     * </pre>
     * - Use the {@link ClientTestHelper} to obtain to obtain the email address
     * of some example client.
     * - Use your shopping basket service to add entries to the shopping basket of that person.
     * - then use the `ShoppingBasketRESTHelper` to create the GET call, and check the results.
     * - (or do it by directly calling your REST controller, if you prefer)
     *
     * @throws Exception
     */
    @Test
    public void test_getQuery_ShoppingBasket() throws Exception {
        // TODO: implement this test
        // given
        EmailAddressType email = clientTestHelper.getClientEmailAddress(1);
        EmailAddress unused = (EmailAddress) email;
        UUID itemId = itemTestHelper.getItemId(1); // irgendein Item
        shoppingBasketUseCases.addItemToShoppingBasket(email, itemId, 3);

        Map<UUID, Integer> expectedQuantities = Map.of(itemId, 3);

        // when
        UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(email, expectedQuantities);

        // then
        assertThat(basketId).isNotNull();
    }


    /**
     * Provide a test that implements the addition of one item to the shopping basket via
     * REST endpoint (6):
     * <pre>
     *     POST /shoppingBaskets/{shoppingBasket-Id}/positions
     * </pre>
     * You can test now "the other way around" as in test_getQuery_ShoppingBasket():
     * - Use `ShoppingBasketRESTHelper` to add items via REST, then use shopping basket service methods
     * to check of the shopping basket contains the right stuff.
     * - (or do it by directly calling your REST controller, if you prefer)
     *
     * @throws Exception
     */
    @Test
    public void test_post_ShoppingBasketPositions() throws Exception {
        // given
        EmailAddressType email = clientTestHelper.getClientEmailAddress(1);
        UUID itemId = itemTestHelper.getItemId(1);
        shoppingBasketUseCases.addItemToShoppingBasket(email, itemId, 3);
        Map<UUID, Integer> expectedQuantities = Map.of(itemId, 3);

        EmailAddressType emailWithOtherDomain = email.sameIdentifyerDifferentDomain("example.com");
        assertThat(emailWithOtherDomain).isNotNull(); // echte Verwendung

        // when
        UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(email, expectedQuantities);

        // then
        assertThat(basketId).isNotNull();
    }


    /**
     * Provide a test that implements the deletion of one item in the shopping basket via
     * REST endpoint (10):
     * <pre>
     *     DELETE /shoppingBaskets/{shoppingBasket-Id}/positions/{item-Id}
     * </pre>
     * This should be just a slight variation of the test_post_ShoppingBasketPositions()
     * method, but instead of adding an item to the shopping basket, you delete it.
     *
     * @throws Exception
     */
    @Test
    public void test_delete_ShoppingBasketPositions() throws Exception {
        // TODO: implement this test
        // given – Beispielkunde und Item
        EmailAddressType email = clientTestHelper.getClientEmailAddress(3); // Emilia Fischer
        UUID itemId = itemTestHelper.getItemId(3);
        int quantity = 4;

        // Erstes Item hinzufügen )
        shoppingBasketUseCases.addItemToShoppingBasket(email, itemId, quantity);

        // Basket abfragen (Basket existiert sicher)
        UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(email, Map.of(itemId, quantity));

        // when – per REST-Call löschen
        shoppingBasketRESTHelper.deleteItemFromShoppingBasket(basketId, itemId);

        // then – sicherstellen, dass Basket leer ist
        shoppingBasketRESTHelper.getQueryShoppingBasket(email, Map.of()); // leer erwartet
    }


    /**
     * Provide a test that implements the checkout of a shopping basket that can be served
     * by just 1 fulfillment center, using the REST endpoint (11):
     * <pre>
     *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
     * </pre>
     * - Use your shopping basket service to add entries to the shopping basket of some example client,
     * - then use the `ShoppingBasketRESTHelper to post the checkout call, and to check the results.
     * - (or do it by directly calling your REST controller, if you prefer)
     *
     * @throws Exception
     */
    @Test
    public void test_checkout_1_fulfillmentCenter() throws Exception {
        // TODO: implement this test
        // given – Beispielkunde und Item
        EmailAddressType email = clientTestHelper.getClientEmailAddress(3); // Emilia Fischer
        UUID itemId = itemTestHelper.getItemId(3);
        int quantity = 2;

        // Schritt 1: Item zum Basket hinzufügen (via Service oder REST)
        shoppingBasketUseCases.addItemToShoppingBasket(email, itemId, quantity);
        Map<UUID, Integer> expectedItems = Map.of(itemId, quantity);
        UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(email, expectedItems);


        UUID fc0Id = fulfillmentCenterTestHelper.getFulfillmentCenterId(0);
        Map<UUID, Map<UUID, Integer>> expectedOrders = Map.of(
                fc0Id, Map.of(itemId, quantity)
        );

        // when – Checkout durchführen
        shoppingBasketRESTHelper.checkout(basketId, clientTestHelper.getClientName(3), null, expectedOrders);

        // then – (indirekt getestet durch ShoppingBasketRESTHelper)

    }


    /**
     * Provide a test that implements the checkout of a shopping basket that can only be served
     * by using 2 fulfillment centers, using the REST endpoint (11):
     * <pre>
     *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
     * </pre>
     * This should be just a slight variation of thetest_checkout_1_fulfillmentCenter() test.
     *
     * @throws Exception
     */
    @Test
    public void test_checkout_2_fulfillmentCenters() throws Exception {
        // TODO: implement this test
        // given
        EmailAddressType email = clientTestHelper.getClientEmailAddress(4); // z. B. Jakob Klein
        UUID itemId = itemTestHelper.getItemId(8); // Item 8 = P8

        UUID fc7Id = fulfillmentCenterTestHelper.getFulfillmentCenterId(7); // FC7 hat den Großteil

        // Item 8 in den Warenkorb legen (6 Stück)
        shoppingBasketUseCases.addItemToShoppingBasket(email, itemId, 6);
        UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(email, Map.of(itemId, 6));

        // Erwartete Orders: alles von FC7
        Map<UUID, Map<UUID, Integer>> expectedOrders = Map.of(
                fc7Id, Map.of(itemId, 6)
        );

        // when & then
        shoppingBasketRESTHelper.checkout(basketId, clientTestHelper.getClientName(4), null, expectedOrders);

    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\CheckoutAcceptanceTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingbasket;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * This test checks the management of stock across fulfillment centers. It focuses on the
 * cases where more than one fulfillment center are needed to serve the shopping basket of a client.
 */
@Slf4j
@SpringBootTest
public class CheckoutAcceptanceTest {
    @Autowired
    private ClientRegistrationUseCases clientRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private OrderUseCases orderUseCases;
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ClientTestHelper clientTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;

    private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
                                map8_11_14_quantity_3_3_4,
                                map10_12_quantity_1_1, 
                                map11_quantity_1, 
                                map12_quantity_10,
                                map8_9_10_11_quantity_2_1_4_2;
    private EmailAddressType clientEmailAddress3, clientEmailAddress6,
            clientEmailAddress2;
    private UUID itemId8, itemId9, itemId10, itemId11, itemId12,
            itemId14;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        clientTestHelper.registerAllClients();
        itemTestHelper.addAllItems();
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );

        clientEmailAddress3 = clientTestHelper.getClientEmailAddress( 3 );
        clientEmailAddress6 = clientTestHelper.getClientEmailAddress( 6 );
        clientEmailAddress2 = clientTestHelper.getClientEmailAddress( 2 );

        itemId8 = itemTestHelper.getItemId( 8 );
        itemId9 = itemTestHelper.getItemId( 9 );
        itemId10 = itemTestHelper.getItemId( 10 );
        itemId11 = itemTestHelper.getItemId( 11 );
        itemId12 = itemTestHelper.getItemId( 12 );
        itemId14 = itemTestHelper.getItemId( 14 );

        map8_11_14_quantity_2_2_2 = new HashMap<>() {{
            put( itemId8, 2 );
            put( itemId11, 2 );
            put( itemId14, 2 );
        }};
        map8_11_14_quantity_3_3_4 = new HashMap<>() {{
            put( itemId8, 3 );
            put( itemId11, 3 );
            put( itemId14, 4 );
        }};
        map10_12_quantity_1_1 = new HashMap<>() {{
            put( itemId10, 1 );
            put( itemId12, 1 );
        }};
        map11_quantity_1 = new HashMap<>() {{
            put( itemId11, 1 );
        }};
        map12_quantity_10 = new HashMap<>() {{
            put( itemId12, 10 );
        }};
        map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
            put( itemId8, 2 );
            put( itemId9, 1 );
            put( itemId10, 4 );
            put( itemId11, 2 );
        }};

    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
     */
    @Test
    public void testClosestSingleFulfillmentCenterWins() {
        log.info( "testClosestSingleFulfillmentCenterWins" );

        // given
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress3, itemId8, 2 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress3, itemId11, 2 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress3, itemId14, 2 );
        // that basket could have been served from fulfillment center 4 or 7, but 4 is closer to the client
        UUID fulfillmentCenterId4 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 4 );

        // when
        Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmailAddress3 );

        // then
        checkFulfillmentCenterIds( orderIds, fulfillmentCenterId4 );
        checkItemNumbers( orderIds, fulfillmentCenterId4, map8_11_14_quantity_2_2_2 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
     */
    @Test
    public void testFulfillmentCenterWithEnoughCapacityWins() {
        log.info( "testFulfillmentCenterWithEnoughCapacityWins" );

        // given
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress3, itemId8, 3 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress3, itemId11, 3 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress3, itemId14, 4 );
        // that basket could have been served from fulfillment center 4 or 7, 4 is closer to the client,
        // but only 7 has enough capacity
        UUID fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );

        // when
        Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmailAddress3 );

        // then
        checkFulfillmentCenterIds( orderIds, fulfillmentCenterId7 );
        checkItemNumbers( orderIds, fulfillmentCenterId7, map8_11_14_quantity_3_3_4 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
     */
    @Test
    public void testTwoFulfillmentCenters() {
        log.info( "testTwoFulfillmentCenters" );

        // given
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress6, itemId10, 1 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress6, itemId11, 1 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress6, itemId12, 1 );
        // that basket needs two deliveries (2 + 1 items) anyway, and there
        // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
        // closer. The smaller can then be served from 4 (closest), 7, or 8.
        UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
                // should cover map10_12_quantity_1_1
        UUID fulfillmentCenterId4 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 4 );
                // should cover map11_quantity_1

        // when
        Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmailAddress6 );

        // then
        checkFulfillmentCenterIds( orderIds, fulfillmentCenterId5, fulfillmentCenterId4 );
        checkItemNumbers( orderIds, fulfillmentCenterId5, map10_12_quantity_1_1 );
        checkItemNumbers( orderIds, fulfillmentCenterId4, map11_quantity_1 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
     */
    @Test
    public void testTwoBigDeliverys() {
        log.info( "testTwoBigDeliverys" );

        // given
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress2, itemId8, 2 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress2, itemId9, 1 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress2, itemId10, 4 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress2, itemId11, 2 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress2, itemId12, 10 );
        // when
        Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmailAddress2 );
        UUID fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );
                // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 items
        UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
                // should cover map12_quantity_10 - the only fulfillment center with enough capacity for 10 items

        // then
        checkFulfillmentCenterIds( orderIds, fulfillmentCenterId7, fulfillmentCenterId5 );
        checkItemNumbers( orderIds, fulfillmentCenterId7, map8_9_10_11_quantity_2_1_4_2 );
        checkItemNumbers( orderIds, fulfillmentCenterId5, map12_quantity_10 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
     */
    @Test
    public void testOnlyOneSolution() {
        log.info( "testOnlyOneSolution" );

        // given
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress6, itemId12, 10 );
        // when
        Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmailAddress6 );
        UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
        // should cover map12_quantity_10 - the only fulfillment center with enough capacity for 10 items

        // then
        checkFulfillmentCenterIds( orderIds, fulfillmentCenterId5 );
        checkItemNumbers( orderIds, fulfillmentCenterId5, map12_quantity_10 );
    }



    private void checkItemNumbers( Set<UUID> orderIds, UUID fulfillmentCenterId, Map<UUID, Integer> expectedMap ) {
        UUID fittingOrderId = null;
        for ( UUID orderId : orderIds ) {
            UUID foundFulfillmentCenterId = orderUseCases.getFulfillmentCenterIdForOrder( orderId );
            if ( foundFulfillmentCenterId.equals( fulfillmentCenterId ) ) {
                fittingOrderId = orderId;
                break;
            }
        }
        assertNotNull( fittingOrderId, "No fitting order found for fulfillment center " + fulfillmentCenterId );

        int totalExpected = 0;
        int totalActual = 0;
        for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
            totalExpected += entry.getValue();
        }
        log.info( "Check order numbers for item {} in fulfillment center {}", fittingOrderId, fulfillmentCenterId );
        for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
            UUID itemId = entry.getKey();
            Integer foundNumber =
                    orderUseCases.getOrderQuantForItem( fittingOrderId, itemId );
            assertEquals( entry.getValue(), foundNumber );
            totalActual += foundNumber;
        }
        // last check - do the total sums match?
        assertEquals( totalExpected, totalActual );
    }


    private void checkFulfillmentCenterIds( Set<UUID> orderIds, UUID... expectedFulfillmentCenterIds ) {
        assertEquals( expectedFulfillmentCenterIds.length, orderIds.size() );
        Set<UUID> foundFulfillmentCenterIds = new HashSet<>();
        for ( UUID orderId : orderIds ) {
            UUID fulfillmentCenterId = orderUseCases.getFulfillmentCenterIdForOrder( orderId );
            foundFulfillmentCenterIds.add( fulfillmentCenterId );
        }
        for ( UUID expectedFulfillmentCenterId : expectedFulfillmentCenterIds ) {
            assertTrue( foundFulfillmentCenterIds.contains( expectedFulfillmentCenterId ) );
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingbasket;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmailAddress;


@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class ShoppingBasketRESTTest {
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ClientTestHelper clientTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
    @Autowired
    private MockMvc mockMvc;
    @Autowired
    private ShoppingBasketRESTHelper shoppingBasketRESTHelper;

    private EmailAddressType nonExistingEmailAddress;
    private final Map<UUID, Integer> emptyMap = new HashMap<>();

    private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
    private EmailAddressType
            clientEmailAddress0,
            clientEmailAddress3,
            clientEmailAddress6,
            clientEmailAddress8;
    private String clientName0, clientName8;
    private UUID itemId0, itemId1, itemId2, itemId3, itemId5,
                 itemId7, itemId9, itemId11, nonExistentItemId;
    private UUID fulfillmentCenterId0, fulfillmentCenterId3, fulfillmentCenterId7, fulfillmentCenterId8;


    private static final ResultMatcher NOT_FOUND = status().isNotFound();
    private static final ResultMatcher OK = status().isOk();
    private static final ResultMatcher CREATED = status().isCreated();
    private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
    private static final ResultMatcher CONFLICT = status().isConflict();

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        clientTestHelper.registerAllClients();
        itemTestHelper.addAllItems();
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        nonExistingEmailAddress = instantiateEmailAddress( "harry@sally.de" );

        clientEmailAddress0 = clientTestHelper.getClientEmailAddress( 0 );
        clientEmailAddress3 = clientTestHelper.getClientEmailAddress( 3 );
        clientEmailAddress6 = clientTestHelper.getClientEmailAddress( 6 );
        clientEmailAddress8 = clientTestHelper.getClientEmailAddress( 8 );
        clientName0 = clientTestHelper.getClientName( 0 );
        clientName8 = clientTestHelper.getClientName( 8 );

        itemId0 = itemTestHelper.getItemId( 0 );
        itemId1 = itemTestHelper.getItemId( 1 );
        itemId2 = itemTestHelper.getItemId( 2 );
        itemId3 = itemTestHelper.getItemId( 3 );
        itemId5 = itemTestHelper.getItemId( 5 );
        itemId7 = itemTestHelper.getItemId( 7 );
        itemId9 = itemTestHelper.getItemId( 9 );
        itemId11 = itemTestHelper.getItemId( 11 );
        nonExistentItemId = UUID.randomUUID();

        fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        fulfillmentCenterId3 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 3 );
        fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );
        fulfillmentCenterId8 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 8 );

        map9_quantity_1 = new HashMap<>() {{
            put( itemId9, 1 );
        }};
        map5_quantity_2 = new HashMap<>() {{
            put( itemId5, 2 );
        }};
        map7_quantity_7 = new HashMap<>() {{
            put( itemId7, 7 );
        }};
        map9_11_quantity_2_2 = new HashMap<>() {{
            put( itemId9, 2 );
            put( itemId11, 2 );
        }};
    }


    @Test
    public void testInvalidShoppingBasketBaseUris() throws Exception {
        // given
        String allShoppingBasketsUri = "/shoppingBaskets";
        String randomIdUri = "/shoppingBaskets/" + UUID.randomUUID();
        String randomClientUUID = "/shoppingBaskets?clientId=" + UUID.randomUUID();
        String invalidClientUUID = "/shoppingBaskets?clientId=invalidUUID";
        String randomParamUri = "/shoppingBaskets?randomParam=randomValue";

        // when
        // then
        mockMvc.perform( get( allShoppingBasketsUri ) ).andExpect( status().isMethodNotAllowed() );
        mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomClientUUID ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( invalidClientUUID ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
    }


    @Test
    public void testInvalidPositionUris() throws Exception {
        // given
        UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress8, emptyMap );
        String randomPositionUri = "/shoppingBaskets/" + shoppingBasketId8.toString() + "/random";
        String randomItemUri = "/shoppingBaskets/" + shoppingBasketId8.toString()
                + "/positions/" + UUID.randomUUID();

        // when
        // then
        mockMvc.perform( post( randomPositionUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( delete( randomItemUri ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testInvalidAddToShoppingBasket() throws Exception {
        // given
        Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
        expectedStartQuantityMap.put( itemId2, 19 );

        // when
        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress0, emptyMap );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId, itemId2, 6 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId, itemId2, 13 );

        // then
        shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress0, expectedStartQuantityMap );

        // ... and check a couple of invalid cases
        shoppingBasketRESTHelper.addItemToShoppingBasket(
                shoppingBasketId, nonExistentItemId, 12, NOT_FOUND );
        shoppingBasketRESTHelper.addItemToShoppingBasket(
                UUID.randomUUID(), itemId5, 12, NOT_FOUND );
        shoppingBasketRESTHelper.addItemToShoppingBasket(
                shoppingBasketId, itemId5, -1, UNPROCESSABLE_ENTITY );

        // check if the shopping basket is still the same
        shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress0, expectedStartQuantityMap );
    }


    @Test
    public void testInvalidCheckout_unavailableItem() throws Exception {
        // given
        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress0, emptyMap );

        // when
        // productId0 is not available in the requested quantity (or rather, not at all)
        shoppingBasketRESTHelper.addItemToShoppingBasket(
                shoppingBasketId, itemId0, 1, CREATED );

        // check if the shopping basket is still the same
        shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
    }


    @Test
    public void testInvalidCheckout_tooLittleStock() throws Exception {
        // given
        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress0, emptyMap );

        // when
        // There are only 10 pieces of productId1 available
        shoppingBasketRESTHelper.addItemToShoppingBasket(
                shoppingBasketId, itemId1, 11, CREATED );

        // check if the shopping basket is still the same
        shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
    }



    @Test
    public void testDeleteItemFromShoppingBasket() throws Exception {
        // given
        UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress6, emptyMap );
        Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
        expectedQuantityMap1.put( itemId1, 1 );
        expectedQuantityMap1.put( itemId2, 2 );
        expectedQuantityMap1.put( itemId3, 3 );
        Map<UUID, Integer> quantityMap2 = new HashMap<>();
        quantityMap2.put( itemId1, 1 );
        quantityMap2.put( itemId3, 3 );

        // when
        // then
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId6, itemId1, 1 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId6, itemId2, 2 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId6, itemId3, 3 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress6, expectedQuantityMap1 );

        shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId6, itemId2 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress6, quantityMap2 );
    }


    @Test
    public void testNoDoubleDelete() throws Exception {
        // given
        UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress6, emptyMap );

        // when
        // then
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId6, itemId3, 3 );
        shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId6, itemId3 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress6, new HashMap<>() );
        shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId6, itemId3, NOT_FOUND );
    }


    @Test
    public void testAddRemoveItemsFromAndToShoppingBasket() throws Exception {
        // given
        UUID shoppingBasketId3 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress3, emptyMap );
        UUID shoppingBasketId5 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress6, emptyMap );

        // when
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId3, itemId1, 2 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId3, itemId2, 3 );
        shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId3, itemId1 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId3, itemId1, 1 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId3, itemId2, 6 );

        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId5, itemId1, 2 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId5, itemId2, 8 );
        shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId5, itemId1 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId5, itemId1, 1 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId5, itemId2, 2 );

        // then
        // client3 has 1x itemId1 and 9x itemId2 expected in cart
        Map<UUID, Integer> expectedMap3 = new HashMap<>();
        expectedMap3.put( itemId1, 1 );
        expectedMap3.put( itemId2, 9 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress3, expectedMap3 );

        // client6 has 1x itemId1 and 10x itemId2 in cart
        Map<UUID, Integer> expectedMap5 = new HashMap<>();
        expectedMap5.put( itemId1, 1 );
        expectedMap5.put( itemId2, 10 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress6, expectedMap5 );
    }


    @Test
    public void testNoDoubleCheckout() throws Exception {
        // given
        UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress8, emptyMap );

        // when
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId2, 3 );

        // then
        shoppingBasketRESTHelper.checkout( shoppingBasketId8, clientName8, CREATED, null );
        shoppingBasketRESTHelper.checkout( shoppingBasketId8, null, CONFLICT, null );
    }


    @Test
    public void testCheckout_1_Order() throws Exception {
        // given:
        // Client 0 wants to buy 1x item 9. This is in fulfillment center 5, 7, and 8. Out of these,
        // fulfillment center 8 with zip code 89250 is closest to client 0 with zip code 02314.
        Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
            put( fulfillmentCenterId8, map9_quantity_1 );
        }};
        UUID shoppingBasketId0 = shoppingBasketRESTHelper.getQueryShoppingBasket(
                clientEmailAddress0, null );
        int stock9before =
                fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId8, itemId9 );

        // when
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId0, itemId9, 1 );
        shoppingBasketRESTHelper.checkout( shoppingBasketId0, clientName0, CREATED, expectedOrders );
        int stock9after =
                fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId8, itemId9 );

        // then
        assertEquals( 1, stock9before - stock9after );
    }


    @Test
    public void testCheckout_3_Order() throws Exception {
        // given:
        // Client 8 (Felix Bauer) wants to buy 2x each of items 5, 9, 11; and 7x item 7.
        //       - items 9 and 11 can both be found in fulfillment centers 7 and 8. Fulfillment centers 7 (76532) is closer to
        //         the client (70173)
        //       - item 7 is available in fulfillment centers 1, 2, and 3, but only fulfillment center 3 has enough stock.
        //       - item 5 is only available in fulfillment center 0.
        Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
            put( fulfillmentCenterId0, map5_quantity_2 );
            put( fulfillmentCenterId3, map7_quantity_7 );
            put( fulfillmentCenterId7, map9_11_quantity_2_2 );
        }};
        UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket(
                clientEmailAddress8, null );
        int stock5before =
                fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId5 );
        int stock7before =
                fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId3, itemId7 );
        int stock9before =
                fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId7, itemId9 );
        int stock11before =
                fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId7, itemId11 );

        // when
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId5, 2 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId7, 7 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId9, 2 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId11, 2 );
        shoppingBasketRESTHelper.checkout( shoppingBasketId8, clientName8, CREATED, expectedOrders );
        int stock5after =
                fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId5 );
        int stock7after =
                fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId3, itemId7 );
        int stock9after =
                fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId7, itemId9 );
        int stock11after =
                fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId7, itemId11 );

        // then
        assertEquals( 2, stock5before - stock5after );
        assertEquals( 7, stock7before - stock7after );
        assertEquals( 2, stock9before - stock9after );
        assertEquals( 2, stock11before - stock11after );
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingbasket;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.InsufficientStockException;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;


import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;

@SpringBootTest
public class ShoppingBasketTest {
    @Autowired
    private ClientRegistrationUseCases clientRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private OrderUseCases orderUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ClientTestHelper clientTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;

    private EmailAddressType nonExistingEmailAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        clientTestHelper.registerAllClients();
        itemTestHelper.addAllItems();

        nonExistingEmailAddress = instantiateEmailAddress( "this@nononono.de" );
    }


    @Test
    public void testInvalidAddToShoppingBasket() {
        // given
        UUID nonExistentItemId = UUID.randomUUID();
        UUID itemId5 = itemTestHelper.getItemId( 5 );
        UUID itemId0 = itemTestHelper.getItemId( 0 );
        EmailAddressType clientEmailAddress0 =
                clientTestHelper.getClientEmailAddress( 0 );
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );

        // then
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addItemToShoppingBasket(
                        nonExistingEmailAddress, itemId0, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addItemToShoppingBasket(
                        null, itemId0, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addItemToShoppingBasket(
                        clientEmailAddress0, nonExistentItemId, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addItemToShoppingBasket(
                        clientEmailAddress0, null, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addItemToShoppingBasket(
                        clientEmailAddress0, itemId5, -1 ) );
    }


    @Test
    public void testInvalidRemoveFromShoppingBasket() {
        // given
        UUID nonExistentItemId = UUID.randomUUID();
        UUID itemId5 = itemTestHelper.getItemId( 5 );
        UUID itemId1 = itemTestHelper.getItemId( 1 );
        UUID itemId2 = itemTestHelper.getItemId( 2 );
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        EmailAddressType clientEmailAddress0 =
                clientTestHelper.getClientEmailAddress( 0 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress0, itemId1, 5 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress0, itemId2, 15 );

        // when
        shoppingBasketUseCases.removeItemFromShoppingBasket(
                clientEmailAddress0, itemId1, 2 );
        shoppingBasketUseCases.removeItemFromShoppingBasket(
                clientEmailAddress0, itemId2, 4 );
        shoppingBasketUseCases.removeItemFromShoppingBasket(
                clientEmailAddress0, itemId2, 7 );
        // now we should have 3x itemId1 and 4x itemId2 in the shopping basket

        // then
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
                        clientEmailAddress0, nonExistentItemId, 12 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
                        nonExistingEmailAddress, itemId5, 12 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
                        clientEmailAddress0, itemId5, -1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
                        clientEmailAddress0, itemId1, 4 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
                        clientEmailAddress0, itemId2, 5 ) );
    }


    @Test
    public void testAddRemoveItemsFromAndToShoppingBasket() {
        // given
        UUID itemId1 = itemTestHelper.getItemId( 1 );
        UUID itemId2 = itemTestHelper.getItemId( 2 );
        EmailAddressType clientEmailAddress3 =
                clientTestHelper.getClientEmailAddress( 3 );
        EmailAddressType clientEmailAddress5 =
                clientTestHelper.getClientEmailAddress( 5 );

        // when client 3 ...
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress3, itemId1, 2 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress3, itemId2, 3 );
        shoppingBasketUseCases.removeItemFromShoppingBasket(
                clientEmailAddress3, itemId1, 2 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress3, itemId1, 1 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress3, itemId2, 6 );
        Map<UUID, Integer> cart3 = shoppingBasketUseCases.getShoppingBasketAsMap( clientEmailAddress3 );
        // client3 has 1x itemId1 and 9x itemId2 in cart

        // ... and when client 5 ...
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress5, itemId1, 2 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress5, itemId2, 8 );
        shoppingBasketUseCases.removeItemFromShoppingBasket(
                clientEmailAddress5, itemId1, 1 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress5, itemId2, 2 );
        Map<UUID, Integer> cart5 = shoppingBasketUseCases.getShoppingBasketAsMap( clientEmailAddress5 );
        // client5 has 1x itemId1 and 10x itemId2 in cart

        // then
        assertEquals( 2, cart3.size() );
        assertEquals( 1, cart3.get( itemId1 ) );
        assertEquals( 9, cart3.get( itemId2 ) );

        assertEquals( 2, cart5.size() );
        assertEquals( 1, cart5.get( itemId1 ) );
        assertEquals( 10, cart5.get( itemId2 ) );
    }


    @Test
    public void testShoppingBasketValue() {
        // given
        UUID itemId3 = itemTestHelper.getItemId( 3 );
        UUID itemId6 = itemTestHelper.getItemId( 6 );
        UUID itemId8 = itemTestHelper.getItemId( 8 );
        MoneyType price3 = itemTestHelper.getSellingPrice( 3 );
        MoneyType price6 = itemTestHelper.getSellingPrice( 6 );
        MoneyType price8 = itemTestHelper.getSellingPrice( 8 );
        EmailAddressType clientEmailAddress3 =
                clientTestHelper.getClientEmailAddress( 3 );

        // when
        shoppingBasketUseCases.addItemToShoppingBasket( clientEmailAddress3, itemId3, 3 );
        shoppingBasketUseCases.addItemToShoppingBasket( clientEmailAddress3, itemId6, 2 );
        shoppingBasketUseCases.addItemToShoppingBasket( clientEmailAddress3, itemId8, 5 );
        // client3 has 3x itemId3, 2x itemId6 and 5x itemId8 in cart
        MoneyType cartValue = shoppingBasketUseCases.getShoppingBasketAsMoneyValue( clientEmailAddress3 );

        // then
        assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
                cartValue );
    }


    @Test
    public void testShoppingBasketValueInvalid() {
        // given
        // when
        // then
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.getShoppingBasketAsMoneyValue( nonExistingEmailAddress ) );
    }


    @Test
    public void testUnsuccessfulCheckout() {
        // given client buying item 0 (which is not in stock), and client 1 buying item 1
        // in a bigger quantity (11) than available (10)
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        EmailAddressType clientEmailAddress0 =
                clientTestHelper.getClientEmailAddress( 0 );
        EmailAddressType clientEmailAddress1 =
                clientTestHelper.getClientEmailAddress( 1 );
        UUID itemId0 = itemTestHelper.getItemId( 0 );
        UUID itemId1 = itemTestHelper.getItemId( 1 );

        // when
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress0, itemId0, 1 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmailAddress1, itemId1, 11 );

        // then
        assertThrows( InsufficientStockException.class,
                () -> shoppingBasketUseCases.checkout( clientEmailAddress0 ) );
        assertThrows( InsufficientStockException.class,
                () -> shoppingBasketUseCases.checkout( clientEmailAddress1 ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
package thkoeln.archilab.ecommerce.tests.testtests;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.domain.JavaMethod;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.web.bind.annotation.RestController;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingBasketRESTTest;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static org.springframework.test.util.AssertionErrors.assertTrue;

/**
 * This test checks if there are the appropriate tests in the test class(es) for domain
 * primitives.
 */

public class RulesForOwnTests {
    private JavaClass dpTestClass, restTestClass;
    private JavaClasses dpTestClasses, restTestClasses;
    private static final String FULFILLMENT_CENTER_DOMAIN_PACKAGE =
            "thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain";
    private static final String FULFILLMENT_CENTER_CLASS_NAME =
            FULFILLMENT_CENTER_DOMAIN_PACKAGE + ".FulfillmentCenter";


    @BeforeEach
    public void setUp() throws Exception {
        dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
        restTestClass = new ClassFileImporter().importClass( OwnShoppingBasketRESTTest.class );

        dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
        restTestClasses = new ClassFileImporter().importClasses( OwnShoppingBasketRESTTest.class );
    }


    @Test
    public void ensureMinimumNumberOfTestMethods() {
        // given
        // when
        int dpTestMethodCount = getTestMethodCount( dpTestClass );
        int restTestMethodCount = getTestMethodCount( restTestClass );

        // then
        assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
                        + dpTestMethodCount,dpTestMethodCount >= 2 );
        assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
                        + restTestMethodCount, restTestMethodCount >= 5 );
    }

    private int getTestMethodCount( JavaClass testClass ) {
        int testMethodCount = 0;
        for ( JavaMethod method : testClass.getMethods() ) {
            if ( isTestMethod( method ) ) {
                testMethodCount++;
            }
        }
        return testMethodCount;
    }

    private boolean isTestMethod( JavaMethod method ) {
        return method.isAnnotatedWith( Test.class );
    }


    @Test
    public void dpTestsShouldReferenceTheRightClasses() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAssignableTo( ZipCodeType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( MoneyType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( PhysicalAddressType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( EmailAddressType.class )
                .because( "DomainPrimitiveJSONSerializationTest should reference ZipCode, " +
                        "Money, EmailAddress, and PhysicalAddress!" );
        rule.check( dpTestClasses );
    }


    @Test
    public void restTestsShouldReferenceEmailAddress() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAssignableTo( EmailAddressType.class )
                .because( "FulfillmentCenterComparatorUnitTest should reference EmailAddressType!" );
        rule.check( restTestClasses );
    }


    @Test
    public void restTestsShouldReferenceRESTControllers() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAnnotatedWith( RestController.class )
                .orShould().dependOnClassesThat()
                .areAssignableTo( ShoppingBasketRESTHelper.class )
                .because( "FulfillmentCenterComparatorUnitTest should call REST controllers! " +
                        "(either directly or via the ShoppingBasketRESTHelper REST helper)" );
        rule.check( restTestClasses );
    }

}


[RESPONSE]:
Ich analysiere den Code systematisch nach den genannten Smells.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ClientNotFoundException.java**

Keine Smells gefunden.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\EmailAddress.java**

[EmailAddress] [Zeile 50]: negative conditional: `!tldAllowed` - Variable mit negiertem Namen in Bedingung.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\EmailMissingException.java**

Keine Smells gefunden.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java**

Keine Smells gefunden.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PhysicalAddress.java**

Keine Smells gefunden.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java**

Keine Smells gefunden.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientRegistrationService.java**

[ClientRegistrationService] [Zeilen 32-40] Duplication [Original: Zeilen 50-56]: Die Konvertierung `EmailAddress.of(emailAddress.toString())` und `PhysicalAddress.of(...)` mit `ZipCode.of(...)` wird mehrfach identisch durchgeführt (in `register`, `changeAddress`, `getClientData`).

[ClientRegistrationService] [Zeilen 73-82]: Duplication [Original: Zeilen 84-93]: Die Methoden `getClientByEmail(EmailAddress)` und `getClientByEmail(EmailAddressType)` sind nahezu identisch, nur der Parametertyp unterscheidet sich.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientResponseDTO.java**

[ClientResponseDTO] [Zeile 1]: misplaced responsibility: DTOs gehören typischerweise in einen separaten `dto`-Ordner oder Package, nicht direkt in `application`.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\Client.java**

[Client] [Zeilen 64-77]: dead code: Der auskommentierte Code-Block mit `@GetMapping` am Ende der Datei ist toter Code.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenter.java**

[FulfillmentCenter] [Zeilen 62-65]: Duplication [Original: Zeilen 78-81]: Das Pattern `stock.stream().filter(s -> s.getItemId().equals(itemId)).findFirst()` wird in `addStock`, `removeStock`, `setStock` und `getStock` wiederholt.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\StockLevelRepository.java**

[StockLevelRepository] [Zeile 1]: dead code: Dieses Repository wird im gesamten Codebase nie verwendet.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\queryport\FulfillmentCenterQueryPort.java**

[FulfillmentCenterQueryPort] [Zeile 1]: layer violation: Dieses Interface im `queryport`-Package importiert `FulfillmentCenter` aus der Domain-Schicht und gibt diese direkt zurück. Ein Query-Port sollte DTOs oder primitive Typen zurückgeben, keine Domain-Entities.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterQueryImplService.java**

[FulfillmentCenterQueryImplService] [Zeile 27]: layer violation: Die Methode `getAllFulfillmentCenters()` gibt Domain-Entities (`FulfillmentCenter`) nach außen zurück, was die Kapselung der Domain-Schicht verletzt.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemRepository.java**

[ItemRepository] [Zeile 7]: dead code: Die Methode `existsByName(String name)` wird nirgends im Code aufgerufen.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionRepository.java**

[OrderPositionRepository] [Zeile 1]: dead code: Dieses Repository wird im gesamten Codebase nie verwendet.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java**

[ShoppingBasketService] [Zeilen 16-22]: layer violation: Der Service greift direkt auf `ClientRepository` und `ItemRepository` zu, die zu anderen Packages (`client.domain`, `item.domain`) gehören. Dies ist Shared Persistency.

[ShoppingBasketService] [Zeilen 16-22]: shared persistency: Zugriff auf `ClientRepository` (client-Package) und `ItemRepository` (item-Package) aus dem shoppingbasket-Package.

[ShoppingBasketService] [Zeilen 111-165]: Duplication [Original: Zeilen 170-224]: Die Methoden `checkoutMultipleDeliveries` und `checkoutMultipleDeliveriesWithOrders` sind nahezu identisch, unterscheiden sich nur im Rückgabetyp (`Set<UUID>` vs `Set<Order>`).

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketAdapterService.java**

[ShoppingBasketAdapterService] [Zeile 16]: layer violation: Der Service importiert und verwendet `Client` aus `client.domain`, was eine Verletzung der Package-Grenzen darstellt.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\OrderResponseDTO.java**

[OrderResponseDTO] [Zeile 1]: misplaced responsibility: Dieser DTO gehört ins `order`-Package, nicht ins `shoppingbasket`-Package.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\OrderPositionResponseDTO.java**

[OrderPositionResponseDTO] [Zeile 1]: misplaced responsibility: Dieser DTO gehört ins `order`-Package, nicht ins `shoppingbasket`-Package.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionRepository.java**

[ShoppingBasketPositionRepository] [Zeile 1]: dead code: Dieses Repository wird im gesamten Codebase nie verwendet.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderService.java**

[OrderService] [Zeilen 12-13]: shared persistency: Der `OrderService` greift auf `ClientRepository` aus dem `client`-Package zu.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java**

[Order] [Zeilen 42-46]: dead code: Das Feld `clientName` mit Setter wird nur für REST gesetzt, aber nie persistiert oder konsistent genutzt.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\StockLevel.java**

- Anemic Entity: Die Klasse enthält hauptsächlich Getter/Setter und einfache `increase`/`decrease`-Methoden ohne komplexe Geschäftslogik.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java**

- Anemic Entity: Die Klasse enthält hauptsächlich Getter/Setter und einfache `increase`/`decrease`-Methoden ohne komplexe Geschäftslogik.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPosition.java**

- Anemic Entity: Die Klasse enthält nur Getter und einen Konstruktor ohne Geschäftslogik.

---

ENDE
Generated by claude-opus-4-5-20251101
-----------------------------------