--- DATE: 13.1.2026, 15:19:38 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
        Architektur: 4-Layer (Eric Evans).
        Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
        Regeln:
        1. Begründe kurz jeden Fund.
        4. Gruppiere nach Datei (mit Pfad). 
        2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
        3. Keine Code-Wiederholung, nur Referenzen.
        5. Wenn fertig, schreibe "ENDE". 
        6. Nutze die Zeilenangaben die mitgeschickt worden sind.



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\HomeAddressPrimitive.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import lombok.AccessLevel;
4: import lombok.AllArgsConstructor;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
10: 
11: import javax.persistence.Embeddable;
12: import javax.persistence.Embedded;
13: 
14: @Getter
15: @AllArgsConstructor(access = AccessLevel.PROTECTED)
16: @NoArgsConstructor
17: @Embeddable
18: public class HomeAddressPrimitive implements HomeAddressType {
19:     private String street;
20:     private String city;
21:     @Embedded
22:     private ZipCodePrimitive zipCode;
23: 
24:     public static HomeAddressType of(String street, String city, ZipCodeType zipCode) {
25:         if(street == null || street.isEmpty())
26:             throw new ShopException("Street is invalid");
27:         if(city == null || city.isEmpty())
28:             throw new ShopException("City is invalid");
29:         if(zipCode == null)
30:             throw new ShopException("Zipcode is invalid");
31:         return new HomeAddressPrimitive(street, city, (ZipCodePrimitive) zipCode);
32:     }
33: 
34:     @Override
35:     public boolean equals(Object obj) {
36:         if(!(obj instanceof HomeAddressType))
37:             return false;
38:         HomeAddressType homeAddressType = (HomeAddressType) obj;
39:         return street.equals(homeAddressType.getStreet()) && city.equals(homeAddressType.getCity()) && zipCode.equals(homeAddressType.getZipCode());
40:     }
41: }
42: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\MailAddressPrimitive.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import lombok.AccessLevel;
4: import lombok.AllArgsConstructor;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
9: 
10: import javax.persistence.Embeddable;
11: 
12: @Getter
13: @AllArgsConstructor(access = AccessLevel.PROTECTED)
14: @Embeddable
15: @NoArgsConstructor
16: public class MailAddressPrimitive implements MailAddressType {
17:     private String mailAddressString;
18: 
19:     public static MailAddressType of(String mailAddressAsString) {
20:         if(mailAddressAsString == null || mailAddressAsString.isEmpty())
21:             throw new ShopException("Mail address is invalid");
22:         if(!mailAddressAsString.matches("^[A-Za-z0-9]+(?:\\.[A-Za-z0-9]+)*@([A-Za-z0-9]+(?:\\.[A-Za-z0-9]+)*)\\.(de|at|ch|com|org)"))
23:             throw new ShopException("Mail address is invalid");
24:         return new MailAddressPrimitive(mailAddressAsString);
25:     }
26: 
27:     @Override
28:     public String toString() {
29:         return mailAddressString;
30:     }
31: 
32:     @Override
33:     public boolean equals(Object obj) {
34:         if(!(obj instanceof MailAddressType))
35:             return false;
36:         MailAddressType mailAddressType = (MailAddressType) obj;
37:         return mailAddressString.equals(mailAddressType.toString());
38:     }
39: }
40: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\MoneyPrimitive.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import lombok.AccessLevel;
4: import lombok.AllArgsConstructor;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: 
10: import javax.persistence.Column;
11: import javax.persistence.Embeddable;
12: 
13: @Getter
14: @AllArgsConstructor(access = AccessLevel.PROTECTED)
15: @Embeddable
16: @NoArgsConstructor
17: public class MoneyPrimitive implements MoneyType {
18:     @Column(insertable = false, updatable = false)
19:     private Float amount;
20:     @Column(insertable = false, updatable = false)
21:     private String currency;
22: 
23:     @Override
24:     public MoneyType add(MoneyType otherMoney) {
25:         if (!currency.equals(otherMoney.getCurrency()))
26:             throw new ShopException("Currency is different");
27:         return of(amount + otherMoney.getAmount(), currency);
28:     }
29: 
30:     @Override
31:     public MoneyType subtract(MoneyType otherMoney) {
32:         if (amount - otherMoney.getAmount() < 0)
33:             throw new ShopException("Amount is negative");
34:         if (!currency.equals(otherMoney.getCurrency()))
35:             throw new ShopException("Currency is different");
36:         return of(amount - otherMoney.getAmount(), currency);
37:     }
38: 
39:     @Override
40:     public MoneyType multiplyBy(int factor) {
41:         return of(amount * factor, currency);
42:     }
43: 
44:     @Override
45:     public boolean largerThan(MoneyType otherMoney) {
46:         if (!currency.equals(otherMoney.getCurrency()))
47:             throw new ShopException("Currency is different");
48:         return amount > otherMoney.getAmount();
49:     }
50: 
51:     public static MoneyType of(Float amount, String currency) {
52:         if (amount == null || amount < 0)
53:             throw new ShopException("Amount is negative");
54:         if (currency == null || currency.isEmpty() || (!currency.equals("EUR") && !currency.equals("CHF")))
55:             throw new ShopException("Currency is invalid");
56:         return new MoneyPrimitive(amount, currency);
57:     }
58: 
59:     @Override
60:     public boolean equals(Object obj) {
61:         if (!(obj instanceof MoneyType))
62:             return false;
63:         MoneyType moneyType = (MoneyType) obj;
64:         return amount.equals(moneyType.getAmount()) && currency.equals(moneyType.getCurrency());
65:     }
66: }
67: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCodePrimitive.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import lombok.AccessLevel;
4: import lombok.AllArgsConstructor;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
9: 
10: import javax.persistence.Embeddable;
11: 
12: @Getter
13: @AllArgsConstructor(access = AccessLevel.PROTECTED)
14: @Embeddable
15: @NoArgsConstructor
16: public class ZipCodePrimitive implements ZipCodeType {
17:     private String zipCode;
18: 
19:     public static ZipCodeType of(String zipCodeAsString) {
20:         if(zipCodeAsString == null || zipCodeAsString.length() != 5 || zipCodeAsString.endsWith("0000"))
21:             throw new ShopException("Zipcode is invalid");
22:         return new ZipCodePrimitive(zipCodeAsString);
23:     }
24: 
25:     @Override
26:     public String toString() {
27:         return zipCode;
28:     }
29: 
30:     @Override
31:     public boolean equals(Object obj) {
32:         if(!(obj instanceof ZipCodeType))
33:             return false;
34:         ZipCodeType zipCodeType = (ZipCodeType) obj;
35:         return zipCode.equals(obj.toString());
36:     }
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\masterdata\FactoryMethodInvoker.java ---
1: package thkoeln.archilab.ecommerce.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
8: 
9: import java.io.File;
10: import java.io.IOException;
11: import java.lang.reflect.InvocationTargetException;
12: import java.lang.reflect.Method;
13: import java.lang.reflect.Modifier;
14: import java.net.URL;
15: import java.net.URLDecoder;
16: import java.nio.charset.StandardCharsets;
17: import java.util.Enumeration;
18: 
19: import static org.junit.jupiter.api.Assertions.*;
20: 
21: public class FactoryMethodInvoker {
22: 
23:     public static MailAddressType instantiateMailAddress( String mailAddressAsString ) {
24:         Method factoryMethod = null;
25:         try {
26:             Class<?> interfaceClass = Class.forName(
27:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType" );
28:             Class<?> implementingClass = findImplementation( interfaceClass );
29: 
30:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
31:             assertNotNull( factoryMethod );
32:             int modifiers = factoryMethod.getModifiers();
33:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
34:         } catch (Exception e) {
35:             fail( "Failed to find implementation for MailAddressType", e );
36:         }
37: 
38:         Object instance = null;
39:         try {
40:             instance = factoryMethod.invoke( null, mailAddressAsString );
41:         } catch (Exception e) {
42:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
43:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
44:             fail( "Failed to invoke factory method 'of' for '" + mailAddressAsString + "'", e );
45:         }
46:         assertNotNull( instance );
47:         return (MailAddressType) instance;
48:     }
49: 
50: 
51:     public static HomeAddressType instantiateHomeAddress(
52:             String street, String city, ZipCodeType zipCode ) {
53:         Method factoryMethod = null;
54:         try {
55:             Class<?> interfaceClass = Class.forName(
56:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType" );
57:             Class<?> implementingClass = findImplementation( interfaceClass );
58: 
59:             factoryMethod = implementingClass.getDeclaredMethod( "of",
60:                     String.class, String.class, ZipCodeType.class );
61:             assertNotNull( factoryMethod );
62:             int modifiers = factoryMethod.getModifiers();
63:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
64:         } catch (Exception e) {
65:             fail( "Failed to find implementation for HomeAddressType", e );
66:         }
67: 
68:         Object instance = null;
69:         try {
70:             instance = factoryMethod.invoke( null, street, city, zipCode );
71:         } catch (Exception e) {
72:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
73:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
74:             fail( "Failed to invoke factory method 'of' for '" +
75:                     street + "', '" + city + "', '" + zipCode + "'", e );
76:         }
77:         assertNotNull( instance );
78:         return (HomeAddressType) instance;
79:     }
80: 
81: 
82:     public static ZipCodeType instantiateZipCode( String zipCodeAsString ) {
83:         Method factoryMethod = null;
84:         try {
85:             Class<?> interfaceClass = Class.forName(
86:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType" );
87:             Class<?> implementingClass = findImplementation( interfaceClass );
88: 
89:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
90:             assertNotNull( factoryMethod );
91:             int modifiers = factoryMethod.getModifiers();
92:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
93:         } catch (Exception e) {
94:             fail( "Failed to find implementation for ZipCodeType", e );
95:         }
96: 
97:         Object instance = null;
98:         try {
99:             instance = factoryMethod.invoke( null, zipCodeAsString );
100:         } catch (Exception e) {
101:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
102:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
103:             fail( "Failed to invoke factory method 'of' for '" + zipCodeAsString + "'", e );
104:         }
105:         assertNotNull( instance );
106:         return (ZipCodeType) instance;
107:     }
108: 
109: 
110:     public static MoneyType instantiateMoney( Float amount, String currency ) {
111:         Method factoryMethod = null;
112:         try {
113:             Class<?> interfaceClass = Class.forName(
114:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType" );
115:             Class<?> implementingClass = findImplementation( interfaceClass );
116: 
117:             factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
118:             assertNotNull( factoryMethod );
119:             int modifiers = factoryMethod.getModifiers();
120:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
121:         } catch (Exception e) {
122:             fail( "Failed to find implementation for MoneyType", e );
123:         }
124: 
125:         Object instance = null;
126:         try {
127:             instance = factoryMethod.invoke( null, amount, currency );
128:         } catch (Exception e) {
129:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
130:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
131:             fail( "Failed to invoke factory method 'of' for '" + amount + "', '" + currency + "'", e );
132:         }
133:         assertNotNull( instance );
134:         return (MoneyType) instance;
135:     }
136: 
137: 
138:     private static Class<?> findImplementation( Class<?> interfaceClass ) {
139:         Method factoryMethod = null;
140:         try {
141:             String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
142:             Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
143:             assertNotNull( implementingClass );
144:             return implementingClass;
145:         } catch (Exception e) {
146:             fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
147:             return null; // This line will never be reached, but it's necessary to satisfy the compiler
148:         }
149:     }
150: 
151: 
152:     private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
153:             throws ClassNotFoundException, IOException {
154:         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
155:         String path = packageName.replace( '.', '/' );
156:         Enumeration<URL> resources = classLoader.getResources( path );
157:         int count = 0;
158:         Class<?> result = null;
159:         while (resources.hasMoreElements()) {
160:             URL resource = resources.nextElement();
161:             File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
162:             File[] files = directory.listFiles();
163:             for ( File file : files ) {
164:                 if ( file.getName().endsWith( ".class" ) ) {
165:                     String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
166:                     Class<?> clazz = Class.forName( className );
167:                     if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
168:                         count++;
169:                         result = clazz;
170:                     }
171:                 }
172:             }
173:         }
174:         assertEquals( 1, count, "There should be exactly one implementing class" );
175:         return result;
176:     }
177: }
178: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\masterdata\InitialMasterDataCreator.java ---
1: package thkoeln.archilab.ecommerce.masterdata;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.context.ApplicationListener;
5: import org.springframework.context.annotation.Profile;
6: import org.springframework.context.event.ContextRefreshedEvent;
7: import org.springframework.stereotype.Component;
8: import thkoeln.archilab.ecommerce.usecases.*;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
12: 
13: import java.util.HashMap;
14: import java.util.Map;
15: import java.util.Random;
16: import java.util.UUID;
17: 
18: 
19: /**
20:  * This class is used to create the initial master data for the application. This includes
21:  * clients and things. It is executed on application startup, and is used for testing purposes.
22:  */
23: @Component
24: @SuppressWarnings("PMD")
25: public class InitialMasterDataCreator {
26: 
27:     public final static String[] CLIENT_NAME = new String[]{
28:             "Max Müller",
29:             "Sophie Schmitz",
30:             "Irene Mihalic",
31:             "Emilia Fischer",
32:             "Filiz Polat",
33:             "Lina Wagner",
34:             "Leon Becker",
35:             "Agnieszka Kalterer",
36:             "Felix Bauer",
37:             "Lara Schulz"
38:     };
39:     public final static MailAddressType[] CLIENT_EMAIL = new MailAddressType[] {
40:             FactoryMethodInvoker.instantiateMailAddress( "max.mueller@example.com" ),
41:             FactoryMethodInvoker.instantiateMailAddress( "sophie.schmitz@example.com" ),
42:             FactoryMethodInvoker.instantiateMailAddress( "irene@wearefreedomnow.com" ),
43:             FactoryMethodInvoker.instantiateMailAddress( "emilia.fischer@example.com" ),
44:             FactoryMethodInvoker.instantiateMailAddress( "j877d3@gmail.com" ),
45:             FactoryMethodInvoker.instantiateMailAddress( "lina.wagner@example.com" ),
46:             FactoryMethodInvoker.instantiateMailAddress( "leon.becker@example.com" ),
47:             FactoryMethodInvoker.instantiateMailAddress( "agna@here.com" ),
48:             FactoryMethodInvoker.instantiateMailAddress( "felix.bauer@example.com" ),
49:             FactoryMethodInvoker.instantiateMailAddress( "lara.schulz@example.com" )
50:     };
51: 
52:     public final static HomeAddressType[] CLIENT_ADDRESS = new HomeAddressType[] {
53:             FactoryMethodInvoker.instantiateHomeAddress(
54:                     "Hauptstraße 1", "Berlin",
55:                     FactoryMethodInvoker.instantiateZipCode( "10115" ) ),
56:             FactoryMethodInvoker.instantiateHomeAddress(
57:                     "Bahnhofstraße 12", "München",
58:                     FactoryMethodInvoker.instantiateZipCode( "80331" ) ),
59:             FactoryMethodInvoker.instantiateHomeAddress(
60:                     "Kirchplatz 3", "Hamburg",
61:                     FactoryMethodInvoker.instantiateZipCode( "20095" ) ),
62:             FactoryMethodInvoker.instantiateHomeAddress(
63:                     "Goethestraße 7", "Frankfurt am Main",
64:                     FactoryMethodInvoker.instantiateZipCode( "60311" ) ),
65:             FactoryMethodInvoker.instantiateHomeAddress(
66:                     "Mühlenweg 15", "Köln",
67:                     FactoryMethodInvoker.instantiateZipCode( "50667" ) ),
68:             FactoryMethodInvoker.instantiateHomeAddress(
69:                     "Schulstraße 9", "Düsseldorf",
70:                     FactoryMethodInvoker.instantiateZipCode( "40213" ) ),
71:             FactoryMethodInvoker.instantiateHomeAddress(
72:                     "Dorfstraße 21", "Stuttgart",
73:                     FactoryMethodInvoker.instantiateZipCode( "70173" ) ),
74:             FactoryMethodInvoker.instantiateHomeAddress(
75:                     "Marktstraße 5", "Leipzig",
76:                     FactoryMethodInvoker.instantiateZipCode( "04109" ) ),
77:             FactoryMethodInvoker.instantiateHomeAddress(
78:                     "Rosenweg 14", "Dortmund",
79:                     FactoryMethodInvoker.instantiateZipCode( "44135" ) ),
80:             FactoryMethodInvoker.instantiateHomeAddress(
81:                     "Wiesenstraße 6", "Essen",
82:                     FactoryMethodInvoker.instantiateZipCode( "45127" ) )
83:     };
84: 
85:     public final static ClientType[] mockClients;
86: 
87:     public static final String EUR = "EUR";
88: 
89:     public static final Object[][] THING_DATA = new Object[][]{
90:             {UUID.randomUUID(), "TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
91:                     1.5f, FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
92:                     FactoryMethodInvoker.instantiateMoney( 10.0f, EUR )},
93:             {UUID.randomUUID(), "EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
94:                     0.3f, FactoryMethodInvoker.instantiateMoney( 2.5f, EUR ),
95:                     FactoryMethodInvoker.instantiateMoney( 4.0f, EUR )},
96:             {UUID.randomUUID(), "MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
97:                     7.2f, FactoryMethodInvoker.instantiateMoney( 50.0f, EUR ),
98:                     FactoryMethodInvoker.instantiateMoney( 80.0f, EUR )},
99:             {UUID.randomUUID(), "Gh-25", "Kompakter und leichter Akku für mobile Geräte",
100:                     null, FactoryMethodInvoker.instantiateMoney( 6.0f, EUR ),
101:                     FactoryMethodInvoker.instantiateMoney( 8.0f, EUR )},
102:             {UUID.randomUUID(), "MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
103:                     null, FactoryMethodInvoker.instantiateMoney( 0.6f, EUR ),
104:                     FactoryMethodInvoker.instantiateMoney( 1.0f, EUR )},
105:             {UUID.randomUUID(), "ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
106:                     1.0f, FactoryMethodInvoker.instantiateMoney( 150.0f, EUR ),
107:                     FactoryMethodInvoker.instantiateMoney( 250.0f, EUR )},
108:             {UUID.randomUUID(), "Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
109:                     null, FactoryMethodInvoker.instantiateMoney( 0.3f, EUR ),
110:                     FactoryMethodInvoker.instantiateMoney( 0.5f, EUR )},
111:             {UUID.randomUUID(), "Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
112:                     6.0f, FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
113:                     FactoryMethodInvoker.instantiateMoney( 120.0f, EUR )},
114:             {UUID.randomUUID(), "JKL-67", "Wasserdichtes Gehäuse",
115:                     3.0f, FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
116:                     FactoryMethodInvoker.instantiateMoney( 1.2f, EUR )},
117:             {UUID.randomUUID(), "MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
118:                     5.5f, FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
119:                     FactoryMethodInvoker.instantiateMoney( 45.0f, EUR )},
120:             {UUID.randomUUID(), "PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
121:                     4.0f, FactoryMethodInvoker.instantiateMoney( 20.0f, EUR ),
122:                     FactoryMethodInvoker.instantiateMoney( 35.0f, EUR )},
123:             {UUID.randomUUID(), "STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
124:                     null, FactoryMethodInvoker.instantiateMoney( 200.0f, EUR ),
125:                     FactoryMethodInvoker.instantiateMoney( 350.0f, EUR )},
126:             {UUID.randomUUID(), "VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
127:                     null, FactoryMethodInvoker.instantiateMoney( 15.0f, EUR ),
128:                     FactoryMethodInvoker.instantiateMoney( 25.0f, EUR )},
129:             {UUID.randomUUID(), "YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
130:                     3.5f, FactoryMethodInvoker.instantiateMoney( 60.0f, EUR ),
131:                     FactoryMethodInvoker.instantiateMoney( 100.0f, EUR )}
132:     };
133: 
134:     private ClientRegistrationUseCases clientRegistrationUseCases;
135:     private ThingCatalogUseCases thingCatalogUseCases;
136:     private StockManagementUseCases stockManagementUseCases;
137:     private ShoppingCartUseCases shoppingCartUseCases;
138: 
139: 
140:     // thing 0 is out of stock, thing 1 and 2 have fixed quantities of 10 and 20, respectively, and the
141:     // others have a random stock between 5 and 100
142:     public static final Map<UUID, Integer> THING_STOCK = new HashMap<>();
143: 
144:     static {
145:         mockClients = new ClientType[CLIENT_NAME.length];
146:         for ( int i = 0; i < CLIENT_NAME.length; i++ ) {
147:             mockClients[i] = new MockClient(
148:                     CLIENT_NAME[i], CLIENT_EMAIL[i], CLIENT_ADDRESS[i]);
149:         }
150:         Random random = new Random();
151:         for ( Object[] thingData : THING_DATA ) {
152:             THING_STOCK.put( (UUID) thingData[0], random.nextInt( 100 ) + 20 );
153:         }
154:         THING_STOCK.put( (UUID) THING_DATA[0][0], 0 );
155:         THING_STOCK.put( (UUID) THING_DATA[1][0], 10 );
156:         THING_STOCK.put( (UUID) THING_DATA[2][0], 20 );
157:         THING_STOCK.put( (UUID) THING_DATA[3][0], 30 );
158: 
159:     }
160: 
161: 
162:     public enum InvalidReason {
163:         NULL, EMPTY;
164: 
165:         public Object getInvalidValue( Object originalValue ) {
166:             switch (this) {
167:                 case NULL:
168:                     return null;
169:                 case EMPTY:
170:                     return "";
171:                 default:
172:                     return null;
173:             }
174:         }
175:     }
176: 
177: 
178:     @Autowired
179:     public InitialMasterDataCreator(
180:             ClientRegistrationUseCases clientRegistrationUseCases,
181:             ThingCatalogUseCases thingCatalogUseCases,
182:             StockManagementUseCases stockManagementUseCases,
183:             ShoppingCartUseCases shoppingCartUseCases ) {
184:         this.clientRegistrationUseCases = clientRegistrationUseCases;
185:         this.thingCatalogUseCases = thingCatalogUseCases;
186:         this.stockManagementUseCases = stockManagementUseCases;
187:         this.shoppingCartUseCases = shoppingCartUseCases;
188:     }
189: 
190: 
191:     public void deleteAll() {
192:         shoppingCartUseCases.deleteAllOrders();
193:         thingCatalogUseCases.deleteThingCatalog();
194:         clientRegistrationUseCases.deleteAllClients();
195:     }
196: 
197: 
198:     public void registerAllClients() {
199:         for ( int i = 0; i < InitialMasterDataCreator.CLIENT_NAME.length; i++ ) {
200:             registerClient( InitialMasterDataCreator.CLIENT_NAME[i], CLIENT_EMAIL[i], CLIENT_ADDRESS[i] );
201:         }
202:     }
203: 
204: 
205:     public void registerClient( String name, MailAddressType mailAddress, HomeAddressType homeAddress ) {
206:         clientRegistrationUseCases.register( name, mailAddress, homeAddress );
207:     }
208: 
209:     public void addAllThings() {
210:         for ( Object[] thingData : THING_DATA ) {
211:             addThingDataToCatalog( thingData );
212:         }
213:     }
214: 
215:     public void addThingDataToCatalog( Object[] thingData ) {
216:         thingCatalogUseCases.addThingToCatalog( (UUID) thingData[0], (String) thingData[1], (String) thingData[2],
217:                 (Float) thingData[3], (MoneyType) thingData[4], (MoneyType) thingData[5] );
218:     }
219: 
220: 
221:     public Object[] getThingDataInvalidAtIndex( int index, InvalidReason reason ) {
222:         Object[] thingData = THING_DATA[1];
223:         Object[] thingDataInvalid = new Object[thingData.length];
224:         System.arraycopy( thingData, 0, thingDataInvalid, 0, thingData.length );
225:         thingDataInvalid[index] = thingData[index].getClass().cast(
226:                 reason.getInvalidValue( thingData[index] ) );
227:         return thingDataInvalid;
228:     }
229: 
230: 
231:     public void stockUpAllThings() {
232:         for ( Object[] thingData : THING_DATA ) {
233:             if ( THING_STOCK.get( thingData[0] ) > 0 )
234:                 stockManagementUseCases.addToStock( (UUID) thingData[0], THING_STOCK.get( thingData[0] ) );
235:         }
236:     }
237: }
238: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\masterdata\MockClient.java ---
1: package thkoeln.archilab.ecommerce.masterdata;
2: 
3: import lombok.Setter;
4: import thkoeln.archilab.ecommerce.usecases.ClientType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;
7: 
8: import java.util.Objects;
9: 
10: @Setter
11: public class MockClient implements ClientType {
12:     private String name;
13:     private MailAddressType mailAddress;
14:     private HomeAddressType homeAddress;
15: 
16: 
17:     public MockClient( String name, MailAddressType mailAddress, HomeAddressType homeAddress) {
18:         this.name = name;
19:         this.mailAddress = mailAddress;
20:         this.homeAddress = homeAddress;
21:     }
22: 
23:     @Override
24:     public String getName() {
25:         return name;
26:     }
27: 
28:     @Override
29:     public MailAddressType getMailAddress() {
30:         return mailAddress;
31:     }
32: 
33:     @Override
34:     public HomeAddressType getHomeAddress() {
35:         return homeAddress;
36:     }
37: 
38:     @Override
39:     public boolean equals( Object o ) {
40:         if ( this == o ) return true;
41:         if ( !( o instanceof MockClient ) ) return false;
42:         MockClient that = (MockClient) o;
43:         return Objects.equals( getName(), that.getName() ) && Objects.equals( mailAddress, that.mailAddress ) && Objects.equals( homeAddress, that.homeAddress );
44:     }
45: 
46:     @Override
47:     public int hashCode() {
48:         return Objects.hash( getName(), mailAddress, homeAddress );
49:     }
50: }
51: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\masterdata\StartupListener.java ---
1: package thkoeln.archilab.ecommerce.masterdata;
2: 
3: import org.slf4j.Logger;
4: import org.slf4j.LoggerFactory;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.context.ApplicationListener;
7: import org.springframework.context.annotation.Profile;
8: import org.springframework.context.event.ContextRefreshedEvent;
9: import org.springframework.stereotype.Component;
10: 
11: @Component
12: @Profile("!test")
13: public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
14:     private Logger logger = LoggerFactory.getLogger( StartupListener.class );
15: 
16:     private InitialMasterDataCreator initialMasterDataCreator;
17: 
18:     @Autowired
19:     public StartupListener( InitialMasterDataCreator initialMasterDataCreator ) {
20:         this.initialMasterDataCreator = initialMasterDataCreator;
21:     }
22: 
23:     @Override
24:     public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
25:         logger.info( "Initializing master data..." );
26:         initialMasterDataCreator.registerAllClients();
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
1: package thkoeln.archilab.ecommerce;
2: 
3: import org.springframework.boot.SpringApplication;
4: import org.springframework.boot.autoconfigure.SpringBootApplication;
5: 
6: 
7: @SpringBootApplication
8: public class ProjectApplication {
9: 
10: 	/**
11: 	 * Entry method
12: 	 * @param args
13: 	 */
14: 	public static void main(String[] args) {
15: 		SpringApplication.run(ProjectApplication.class, args);
16: 	}
17: }
18: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
1: package thkoeln.archilab.ecommerce;
2: 
3: public class ShopException extends RuntimeException {
4:     public ShopException( String message ) {
5:         super( message );
6:     }
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientRegistrationService.java ---
1: package thkoeln.archilab.ecommerce.solution.client.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.domainprimitives.HomeAddressPrimitive;
6: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
7: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
8: import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
9: import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
10: import thkoeln.archilab.ecommerce.usecases.ClientType;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
13: 
14: import java.util.ArrayList;
15: import java.util.UUID;
16: 
17: @Service
18: public class ClientRegistrationService implements ClientRegistrationUseCases {
19:     private final ClientRepository clientRepository;
20:     private final ClientShoppingCartInterface clientShoppingCartService;
21: 
22:     public ClientRegistrationService(ClientRepository clientRepository, ClientShoppingCartInterface clientShoppingCartService) {
23:         this.clientRepository = clientRepository;
24:         this.clientShoppingCartService = clientShoppingCartService;
25:     }
26: 
27:     @Override
28:     public void register(String name, MailAddressType mailAddress, HomeAddressType homeAddress) {
29:         if (name == null || name.isEmpty())
30:             throw new ShopException("Name is invalid");
31:         if (mailAddress == null || mailAddress.toString().isEmpty())
32:             throw new ShopException("Mail address is invalid");
33:         if (homeAddress == null)
34:             throw new ShopException("Home address is invalid");
35:         if (homeAddress.getStreet() == null || homeAddress.getStreet().isEmpty())
36:             throw new ShopException("Street is invalid");
37:         if (homeAddress.getCity() == null || homeAddress.getCity().isEmpty())
38:             throw new ShopException("City is invalid");
39:         if (homeAddress.getZipCode() == null || homeAddress.getZipCode().toString().isEmpty())
40:             throw new ShopException("Zipcode is invalid");
41:         if (clientRepository.existsByMailAddress((MailAddressPrimitive) mailAddress))
42:             throw new ShopException("Client with this mail address already exists");
43:         Client client = Client.newInstance(UUID.randomUUID(), name, (MailAddressPrimitive) mailAddress, (HomeAddressPrimitive) HomeAddressPrimitive.of(homeAddress.getStreet(), homeAddress.getCity(), homeAddress.getZipCode()));
44:         clientRepository.save(client);
45:         clientShoppingCartService.save(UUID.randomUUID(), client, new ArrayList<>());
46:     }
47: 
48:     @Override
49:     public void changeAddress(MailAddressType clientMailAddress, HomeAddressType homeAddress) {
50:         if (clientMailAddress == null || clientMailAddress.toString().isEmpty())
51:             throw new ShopException("Name is invalid");
52:         if (homeAddress == null)
53:             throw new ShopException("Home address is invalid");
54:         if (homeAddress.getStreet() == null || homeAddress.toString().isEmpty())
55:             throw new ShopException("Street is invalid");
56:         if (homeAddress.getCity() == null || homeAddress.getCity().isEmpty())
57:             throw new ShopException("City is invalid");
58:         if (homeAddress.getZipCode() == null || homeAddress.getZipCode().toString() == null || homeAddress.getZipCode().toString().isEmpty())
59:             throw new ShopException("Zipcode is invalid");
60:         Client dbClient = clientRepository.findByMailAddress((MailAddressPrimitive) clientMailAddress).orElseThrow(() -> new ShopException("Client with this mail does not exists"));
61:         dbClient = Client.newInstance(dbClient.getId(), dbClient.getName(), dbClient.getMailAddress(), (HomeAddressPrimitive) HomeAddressPrimitive.of(homeAddress.getStreet(), homeAddress.getCity(), homeAddress.getZipCode()));
62:         clientRepository.save(dbClient);
63:     }
64: 
65:     @Override
66:     public ClientType getClientData(MailAddressType clientMailAddress) {
67:         if (clientMailAddress == null || clientMailAddress.toString().isEmpty())
68:             throw new ShopException("Mail address is invalid");
69:         return clientRepository.findByMailAddress((MailAddressPrimitive) clientMailAddress).orElseThrow(() -> new ShopException("Client with this mail does not exists"));
70:     }
71: 
72:     @Override
73:     public void deleteAllClients() {
74:         clientRepository.findAll().forEach(client -> {
75:             if(!clientShoppingCartService.shoppingCartExists(client.getMailAddress()))
76:                 return;
77:             clientShoppingCartService.delete(client.getMailAddress());
78:         });
79:         clientRepository.deleteAll();
80:     }
81: }
82: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientShoppingCartInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.client.application;
2: 
3: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: 
6: import java.util.List;
7: import java.util.UUID;
8: 
9: public interface ClientShoppingCartInterface {
10:     void save(UUID id, Client client, List parts);
11:     boolean shoppingCartExists(MailAddressType mailAddressType);
12: 
13:     void delete(MailAddressType mailAddressType);
14: }
15: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\OrderClientInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.client.application;
2: 
3: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
4: 
5: import java.util.UUID;
6: 
7: public interface OrderClientInterface {
8:     Client getClient(UUID id);
9: }
10: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ShoppingCartClientInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.client.application;
2: 
3: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: 
6: import java.util.UUID;
7: 
8: public interface ShoppingCartClientInterface {
9:     void checkIfClientExists(MailAddressType mailAddressType);
10:     UUID getIdFromClient(MailAddressType mailAddressType);
11:     Client getClient(UUID id);
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\Client.java ---
1: package thkoeln.archilab.ecommerce.solution.client.domain;
2: 
3: import lombok.AccessLevel;
4: import lombok.AllArgsConstructor;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.domainprimitives.HomeAddressPrimitive;
8: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
9: import thkoeln.archilab.ecommerce.usecases.ClientType;
10: 
11: import javax.persistence.Embedded;
12: import javax.persistence.Entity;
13: import javax.persistence.Id;
14: import java.util.UUID;
15: 
16: @Entity
17: @Getter
18: @AllArgsConstructor(access = AccessLevel.PROTECTED)
19: @NoArgsConstructor
20: public class Client implements ClientType {
21:     @Id
22:     private UUID id;
23:     private String name;
24:     @Embedded
25:     private MailAddressPrimitive mailAddress;
26:     @Embedded
27:     private HomeAddressPrimitive homeAddress;
28: 
29:     public static Client newInstance(UUID id, String name, MailAddressPrimitive mailAddressType, HomeAddressPrimitive homeAddress) {
30:         return new Client(id, name, mailAddressType, homeAddress);
31:     }
32: }
33: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ClientRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.client.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
6: 
7: import java.util.Optional;
8: import java.util.UUID;
9: 
10: @Repository
11: public interface ClientRepository extends JpaRepository<Client, UUID>{
12:     Optional<Client> findByMailAddress(MailAddressPrimitive mailAddressType);
13: 
14:     boolean existsByMailAddress(MailAddressPrimitive mailAddressType);
15: }
16: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\application\DeliveryService.java ---
1: package thkoeln.archilab.ecommerce.solution.delivery.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
6: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
7: import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
8: import thkoeln.archilab.ecommerce.solution.delivery.domain.Delivery;
9: import thkoeln.archilab.ecommerce.solution.delivery.domain.DeliveryPart;
10: import thkoeln.archilab.ecommerce.solution.delivery.domain.DeliveryRepository;
11: import thkoeln.archilab.ecommerce.usecases.ClientType;
12: import thkoeln.archilab.ecommerce.usecases.DeliveryUseCases;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: 
15: import java.util.*;
16: 
17: @Service
18: public class DeliveryService implements DeliveryUseCases {
19:     private final DeliveryRepository deliveryRepository;
20:     private final ClientRepository clientRepository;
21: 
22:     public DeliveryService(DeliveryRepository deliveryRepository, ClientRepository clientRepository) {
23:         this.deliveryRepository = deliveryRepository;
24:         this.clientRepository = clientRepository;
25:     }
26: 
27:     @Override
28:     public UUID triggerDelivery(ClientType deliveryRecipient, Map<UUID, Integer> deliveryContent) {
29:         if (deliveryRecipient == null)
30:             throw new ShopException("Delivery recipient is invalid");
31:         if (deliveryRecipient.getMailAddress() == null || deliveryRecipient.getMailAddress().toString().isEmpty())
32:             throw new ShopException("Name is invalid");
33:         if (deliveryRecipient.getName() == null || deliveryRecipient.getName().isEmpty())
34:             throw new ShopException("Name is invalid");
35:         if (deliveryRecipient.getHomeAddress().getStreet() == null || deliveryRecipient.getHomeAddress().getStreet().isEmpty())
36:             throw new ShopException("Street is invalid");
37:         if (deliveryRecipient.getHomeAddress().getCity() == null || deliveryRecipient.getHomeAddress().getCity().isEmpty())
38:             throw new ShopException("City  is invalid");
39:         if (deliveryRecipient.getHomeAddress().getZipCode() == null || deliveryRecipient.getHomeAddress().getZipCode().toString().isEmpty())
40:             throw new ShopException("Zipcode is invalid");
41:         if (deliveryContent == null || deliveryContent.isEmpty())
42:             throw new ShopException("Delivery content is invalid");
43:         if(!isDeliveryAuthorized(deliveryRecipient, deliveryContent))
44:             throw new ShopException("Amount is greater than 20");
45:         Delivery delivery = Delivery.newInstance(UUID.randomUUID(), deliveryRecipient.getName(), deliveryRecipient.getHomeAddress().getStreet(), deliveryRecipient.getHomeAddress().getCity(), deliveryRecipient.getHomeAddress().getZipCode().toString(), new ArrayList<>());
46:         deliveryContent.forEach((uuid, integer) -> delivery.getDeliveryParts().add(DeliveryPart.newInstance(uuid, integer)));
47:         deliveryRepository.save(delivery);
48:         return delivery.getId();
49:     }
50: 
51:     @Override
52:     public Map<UUID, Integer> getDeliveryHistory(MailAddressType clientMailAddress) {
53:         if (clientMailAddress == null || clientMailAddress.toString().isEmpty())
54:             throw new ShopException("Mail address is invalid");
55:         Client client = clientRepository.findByMailAddress((MailAddressPrimitive) clientMailAddress).orElseThrow(() -> new ShopException("Client with this mail address does not exists"));
56:         List<Delivery> history = deliveryRepository.findByName(client.getName()).orElse(new ArrayList<>());
57:         Map<UUID, Integer> result = new HashMap<>();
58:         history.forEach(delivery -> delivery.getDeliveryParts().forEach(deliveryPart -> {
59:             if (result.containsKey(deliveryPart.getUuid()))
60:                 result.put(deliveryPart.getUuid(), result.get(deliveryPart.getUuid()) + deliveryPart.getQuantity());
61:             else
62:                 result.put(deliveryPart.getUuid(), deliveryPart.getQuantity());
63:         }));
64:         return result;
65:     }
66: 
67:     public boolean isDeliveryAuthorized(ClientType deliveryRecipient, Map<UUID, Integer> deliveryContent) {
68:         int sum = deliveryContent.values().stream().mapToInt(Integer::intValue).sum();
69:         return sum <= 20;
70:     }
71: 
72:     @Override
73:     public void deleteDeliveryHistory() {
74:         deliveryRepository.deleteAll();
75:     }
76: }
77: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\application\ShoppingCartDeliveryService.java ---
1: package thkoeln.archilab.ecommerce.solution.delivery.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
5: import thkoeln.archilab.ecommerce.solution.delivery.domain.DeliveryRepository;
6: import thkoeln.archilab.ecommerce.solution.shoppingcart.application.ShoppingCartDeliveryInterface;
7: import thkoeln.archilab.ecommerce.usecases.ClientType;
8: import thkoeln.archilab.ecommerce.usecases.DeliveryUseCases;
9: 
10: import java.util.Map;
11: import java.util.UUID;
12: 
13: @Service
14: public class ShoppingCartDeliveryService implements ShoppingCartDeliveryInterface {
15:     private final DeliveryRepository deliveryRepository;
16:     private final DeliveryUseCases deliveryUseCases;
17: 
18:     public ShoppingCartDeliveryService(DeliveryRepository deliveryRepository, DeliveryUseCases deliveryUseCases) {
19:         this.deliveryRepository = deliveryRepository;
20:         this.deliveryUseCases = deliveryUseCases;
21:     }
22: 
23:     @Override
24:     public void triggerDelivery(ClientType clientType, Map<UUID, Integer> shoppingCartAsMap) {
25:         deliveryUseCases.triggerDelivery(clientType, shoppingCartAsMap);
26:     }
27: 
28:     @Override
29:     public boolean isDeliveryAuthorized(ClientType clientType, Map<UUID, Integer> shoppingCartAsMap) {
30:         int sum = shoppingCartAsMap.values().stream().mapToInt(Integer::intValue).sum();
31:         return sum <= 20;
32:     }
33: }
34: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\Delivery.java ---
1: package thkoeln.archilab.ecommerce.solution.delivery.domain;
2: 
3: import lombok.AccessLevel;
4: import lombok.AllArgsConstructor;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: 
8: import javax.persistence.ElementCollection;
9: import javax.persistence.Entity;
10: import javax.persistence.Id;
11: import java.util.List;
12: import java.util.UUID;
13: 
14: @Entity
15: @Getter
16: @AllArgsConstructor(access = AccessLevel.PROTECTED)
17: @NoArgsConstructor
18: public class Delivery {
19:     @Id
20:     private UUID id;
21:     private String name;
22: 
23:     private String street;
24: 
25:     private String city;
26: 
27:     private String zipCode;
28:     @ElementCollection(targetClass = DeliveryPart.class)
29:     private List<DeliveryPart> deliveryParts;
30: 
31:     public static Delivery newInstance(UUID id, String name, String street, String city, String zipCode, List<DeliveryPart> deliveryParts) {
32:         return new Delivery(id, name, street, city, zipCode, deliveryParts);
33:     }
34: }
35: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\DeliveryPart.java ---
1: package thkoeln.archilab.ecommerce.solution.delivery.domain;
2: 
3: import lombok.AccessLevel;
4: import lombok.AllArgsConstructor;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: 
8: import javax.persistence.Embeddable;
9: import java.util.UUID;
10: 
11: @Embeddable
12: @Getter
13: @AllArgsConstructor(access = AccessLevel.PROTECTED)
14: @NoArgsConstructor
15: public class DeliveryPart {
16:     private UUID uuid;
17:     private int quantity;
18: 
19:     public static DeliveryPart newInstance(UUID uuid, int quantity) {
20:         return new DeliveryPart(uuid, quantity);
21:     }
22: }
23: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\DeliveryRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.delivery.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: 
5: import java.util.List;
6: import java.util.Optional;
7: import java.util.UUID;
8: 
9: public interface DeliveryRepository extends JpaRepository<Delivery, UUID> {
10:     Optional<List<Delivery>> findByName(String name);
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderClientService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.solution.client.application.OrderClientInterface;
5: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
6: import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
7: 
8: import java.util.UUID;
9: 
10: @Service
11: public class OrderClientService implements OrderClientInterface {
12:     private final ClientRepository clientRepository;
13: 
14:     public OrderClientService(ClientRepository clientRepository) {
15:         this.clientRepository = clientRepository;
16:     }
17: 
18:     @Override
19:     public Client getClient(UUID id) {
20:         return clientRepository.findById(id).get();
21:     }
22: }
23: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderController.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import org.springframework.http.ResponseEntity;
4: import org.springframework.web.bind.annotation.GetMapping;
5: import org.springframework.web.bind.annotation.RestController;
6: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
7: import thkoeln.archilab.ecommerce.domainprimitives.MoneyPrimitive;
8: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
9: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPart;
10: import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
11: 
12: import javax.ws.rs.QueryParam;
13: import java.util.ArrayList;
14: import java.util.Collections;
15: import java.util.List;
16: import java.util.concurrent.atomic.AtomicReference;
17: 
18: @RestController
19: public class OrderController {
20:     private final OrderRepository orderRepository;
21:     private final OrderThingInterface orderThingInterface;
22: 
23:     public OrderController(OrderRepository orderRepository, OrderThingInterface orderThingInterface) {
24:         this.orderRepository = orderRepository;
25:         this.orderThingInterface = orderThingInterface;
26:     }
27: 
28:     @GetMapping("/orders")
29:     public ResponseEntity<List<Order>> getOrders(@QueryParam(value = "mailAddress") String mailAddress, @QueryParam(value = "filter") String filter) {
30:         if (mailAddress == null || mailAddress.isEmpty() || !isValidEmail(mailAddress) || orderRepository.findByClientMailAddress((MailAddressPrimitive) MailAddressPrimitive.of(mailAddress)).isEmpty())
31:             return ResponseEntity.ok(orderRepository.findAll());
32:         if (filter == null || filter.isEmpty()) {
33:             List<Order> result = new ArrayList<>();
34:             orderRepository.findByClientMailAddress((MailAddressPrimitive) MailAddressPrimitive.of(mailAddress)).orElse(new ArrayList<>()).forEach(order -> {
35:                 order.setPrice(getOrderValue(order));
36:                 order.setMailAddress((MailAddressPrimitive) MailAddressPrimitive.of(mailAddress));
37:                 result.add(order);
38:             });
39:             return ResponseEntity.ok(result);
40:         }
41:         if (!filter.equalsIgnoreCase("latest"))
42:             return ResponseEntity.ok(orderRepository.findAll());
43:         AtomicReference<Order> order = new AtomicReference<>(orderRepository.findByClientMailAddress((MailAddressPrimitive) MailAddressPrimitive.of(mailAddress)).orElse(new ArrayList<>()).stream().findFirst().orElse(null));
44:         if (order.get() == null)
45:             return ResponseEntity.ok().build();
46:         orderRepository.findByClientMailAddress((MailAddressPrimitive) MailAddressPrimitive.of(mailAddress)).orElse(new ArrayList<>()).forEach(order1 -> {
47:             if (order.get().getSubmissionDate().getNano() < order1.getSubmissionDate().getNano())
48:                 order.set(order1);
49:         });
50:         Order result = order.get();
51:         result.setPrice(getOrderValue(result));
52:         result.setMailAddress((MailAddressPrimitive) MailAddressPrimitive.of(mailAddress));
53:         return ResponseEntity.ok(Collections.singletonList(result));
54:     }
55: 
56:     private MoneyPrimitive getOrderValue(Order order) {
57:         AtomicReference<MoneyPrimitive> orderPrice = new AtomicReference<>((MoneyPrimitive) MoneyPrimitive.of(0.0f, "EUR"));
58:         for (OrderPart orderPart : order.getOrderParts()) {
59:             MoneyPrimitive price = (MoneyPrimitive) orderThingInterface.getSellingPrice(orderPart.getThingId());
60:             MoneyPrimitive newPrice = (MoneyPrimitive) price.multiplyBy(orderPart.getQuantity());
61:             orderPrice.set((MoneyPrimitive) orderPrice.get().add(newPrice));
62:         }
63:         return orderPrice.get();
64:     }
65: 
66:     private boolean isValidEmail(String mailAddress) {
67:         return mailAddress.matches("^[A-Za-z0-9]+(?:\\.[A-Za-z0-9]+)*@([A-Za-z0-9]+(?:\\.[A-Za-z0-9]+)*)\\.(de|at|ch|com|org)");
68:     }
69: }
70: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
5: 
6: @Service
7: public class OrderService {
8:     private final OrderRepository orderRepository;
9: 
10:     public OrderService(OrderRepository orderRepository) {
11:         this.orderRepository = orderRepository;
12:     }
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderThingInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
4: 
5: import java.util.UUID;
6: 
7: public interface OrderThingInterface {
8:     MoneyType getSellingPrice(UUID id);
9: }
10: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\ShoppingCartOrderService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import com.google.gson.Gson;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
6: import thkoeln.archilab.ecommerce.solution.client.application.OrderClientInterface;
7: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
8: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPart;
9: import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
10: import thkoeln.archilab.ecommerce.solution.shoppingcart.application.ShoppingCartOrderInterface;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
12: 
13: import java.util.*;
14: 
15: @Service
16: public class ShoppingCartOrderService implements ShoppingCartOrderInterface {
17:     private final OrderRepository orderRepository;
18:     private final OrderClientInterface orderClientInterface;
19: 
20:     public ShoppingCartOrderService(OrderRepository orderRepository, OrderClientInterface orderClientInterface) {
21:         this.orderRepository = orderRepository;
22:         this.orderClientInterface = orderClientInterface;
23:     }
24: 
25:     @Override
26:     public void createOrder(UUID clientId, List<String> collect) {
27:         Order order = Order.newInstance(UUID.randomUUID(), orderClientInterface.getClient(clientId), new ArrayList<>());
28:         for (String s : collect)
29:             order.getOrderParts().add(new Gson().fromJson(s, OrderPart.class));
30:         orderRepository.save(order);
31:     }
32: 
33:     @Override
34:     public Map<UUID, Integer> getOrderHistory(MailAddressType mailAddressType) {
35:         //Client client = clientRepository.findByMailAddress((MailAddressPrimitive) mailAddressType).orElseThrow(() -> new ShopException("Client with this mail address does not exists"));
36:         List<Order> history = orderRepository.findByClientMailAddress((MailAddressPrimitive) mailAddressType).orElse(new ArrayList<>());
37:         Map<UUID, Integer> result = new HashMap<>();
38:         history.forEach(order -> order.getOrderParts().forEach(orderPart -> {
39:             if (result.containsKey(orderPart.getThingId()))
40:                 result.put(orderPart.getThingId(), result.get(orderPart.getThingId()) + orderPart.getQuantity());
41:             else
42:                 result.put(orderPart.getThingId(), orderPart.getQuantity());
43:         }));
44:         return result;
45:     }
46: 
47:     @Override
48:     public void deleteAll() {
49:         orderRepository.deleteAll();
50:     }
51: }
52: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import lombok.*;
4: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
5: import thkoeln.archilab.ecommerce.domainprimitives.MoneyPrimitive;
6: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
8: 
9: import javax.persistence.*;
10: import java.time.LocalDateTime;
11: import java.util.List;
12: import java.util.UUID;
13: 
14: @Entity
15: @Getter
16: @AllArgsConstructor(access = AccessLevel.PROTECTED)
17: @NoArgsConstructor
18: @Table(name = "OrderTable")
19: public class Order {
20:     @Id
21:     private UUID id;
22:     @ManyToOne
23:     private Client client;
24:     @ElementCollection(targetClass = OrderPart.class)
25:     private List<OrderPart> orderParts;
26:     private LocalDateTime submissionDate;
27:     @Setter
28:     private MailAddressPrimitive mailAddress;
29:     @Setter
30:     private MoneyPrimitive price;
31: 
32:     public static Order newInstance(UUID id, Client client, List<OrderPart> orderParts) {
33:         return new Order(id, client, orderParts, LocalDateTime.now(), null, (MoneyPrimitive) MoneyPrimitive.of(0.0f, "EUR"));
34:     }
35: }
36: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderClient.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import java.util.List;
4: 
5: public interface OrderClient {
6:         String getName();
7:         void setName(String name);
8:         String getEmail();
9:         void setEmail(String email);
10:         List<Order> getOrders();
11:         void setOrders(List<Order> orders);
12:         void addOrder(Order order);
13:         void removeOrder(Order order);
14:     }
15: 
16: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPart.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import lombok.AccessLevel;
4: import lombok.AllArgsConstructor;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.solution.thing.domain.Thing;
8: 
9: import javax.persistence.Embeddable;
10: import javax.persistence.ManyToOne;
11: import java.util.UUID;
12: 
13: @Embeddable
14: @Getter
15: @AllArgsConstructor(access = AccessLevel.PROTECTED)
16: @NoArgsConstructor
17: public class OrderPart {
18:     private UUID thingId;
19:     private int quantity;
20:     private String comment;
21: 
22:     public static OrderPart newInstance(UUID thingId, int quantity, String comment) {
23:         return new OrderPart(thingId, quantity, comment);
24:     }
25: }
26: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
6: 
7: import java.util.List;
8: import java.util.Optional;
9: import java.util.UUID;
10: 
11: public interface OrderRepository extends JpaRepository<Order, UUID> {
12:     Optional<List<Order>> findByClientMailAddress(MailAddressPrimitive mailAddressPrimitive);
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\payment\application\PaymentService.java ---
1: package thkoeln.archilab.ecommerce.solution.payment.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
6: import thkoeln.archilab.ecommerce.domainprimitives.MoneyPrimitive;
7: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
8: import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
9: import thkoeln.archilab.ecommerce.solution.payment.domain.Payment;
10: import thkoeln.archilab.ecommerce.solution.payment.domain.PaymentRepository;
11: import thkoeln.archilab.ecommerce.usecases.PaymentUseCases;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
14: 
15: import java.util.ArrayList;
16: import java.util.List;
17: import java.util.UUID;
18: import java.util.concurrent.atomic.AtomicReference;
19: 
20: @Service
21: public class PaymentService implements PaymentUseCases {
22:     private final PaymentRepository paymentRepository;
23:     private final ClientRepository clientRepository;
24: 
25:     public PaymentService(PaymentRepository paymentRepository, ClientRepository clientRepository) {
26:         this.paymentRepository = paymentRepository;
27:         this.clientRepository = clientRepository;
28:     }
29: 
30:     @Override
31:     public UUID authorizePayment(MailAddressType clientMailAddress, MoneyType amount) {
32:         if (clientMailAddress == null || clientMailAddress.toString().isEmpty())
33:             throw new ShopException("Mail address is invalid");
34:         Client client = clientRepository.findByMailAddress((MailAddressPrimitive) clientMailAddress).orElseThrow(() -> new ShopException("Client does not exists"));
35:         if(!isPaymentAuthorized(clientMailAddress, amount))
36:             throw new ShopException("Amount is invalid");
37:         Payment payment = Payment.newInstance(UUID.randomUUID(), client, (MoneyPrimitive) amount, true);
38:         paymentRepository.save(payment);
39:         return payment.getId();
40:     }
41: 
42:     public boolean isPaymentAuthorized(MailAddressType clientMailAddress, MoneyType amount) {
43:         return amount != null && amount.getAmount() > 0 && !(amount.getAmount() > 500.0);
44:     }
45: 
46:     @Override
47:     public MoneyType getPaymentTotal(MailAddressType clientMailAddress) {
48:         if (clientMailAddress == null || clientMailAddress.toString().isEmpty())
49:             throw new ShopException("Mail address is invalid");
50:         Client client = clientRepository.findByMailAddress((MailAddressPrimitive) clientMailAddress).orElseThrow(() -> new ShopException("Client does not exists"));
51:         List<Payment> payments = paymentRepository.findByClientMailAddress((MailAddressPrimitive) clientMailAddress).orElse(new ArrayList<>());
52:         if (payments.isEmpty())
53:             return MoneyPrimitive.of(0.0f, "EUR");
54:         AtomicReference<MoneyType> moneyType = new AtomicReference<>(MoneyPrimitive.of(0.0f, payments.get(0).getAmount().getCurrency()));
55:         payments.forEach(payment -> {
56:             moneyType.set(moneyType.get().add(payment.getAmount()));
57:         });
58:         return moneyType.get();
59:     }
60: 
61:     @Override
62:     public void deletePaymentHistory() {
63:         paymentRepository.deleteAll();
64:     }
65: }
66: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\payment\application\ShoppingCartPaymentService.java ---
1: package thkoeln.archilab.ecommerce.solution.payment.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
5: import thkoeln.archilab.ecommerce.domainprimitives.MoneyPrimitive;
6: import thkoeln.archilab.ecommerce.solution.payment.domain.Payment;
7: import thkoeln.archilab.ecommerce.solution.payment.domain.PaymentRepository;
8: import thkoeln.archilab.ecommerce.solution.shoppingcart.application.ShoppingCartPaymentInterface;
9: import thkoeln.archilab.ecommerce.usecases.PaymentUseCases;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
12: 
13: import java.util.ArrayList;
14: import java.util.List;
15: 
16: @Service
17: public class ShoppingCartPaymentService implements ShoppingCartPaymentInterface {
18:     private final PaymentRepository paymentRepository;
19:     private final PaymentUseCases paymentUseCases;
20: 
21:     public ShoppingCartPaymentService(PaymentRepository paymentRepository, PaymentUseCases paymentUseCases) {
22:         this.paymentRepository = paymentRepository;
23:         this.paymentUseCases = paymentUseCases;
24:     }
25: 
26:     @Override
27:     public boolean checkIfClientIsAuthorized(MoneyType amount) {
28:         return amount != null && amount.getAmount() > 0 && !(amount.getAmount() > 500.0);
29:     }
30: 
31:     @Override
32:     public void authorizePayment(MailAddressType clientMailAddress, MoneyType shoppingCartAsMoneyValue) {
33:         paymentUseCases.authorizePayment(clientMailAddress, shoppingCartAsMoneyValue);
34:     }
35: }
36: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\payment\domain\Payment.java ---
1: package thkoeln.archilab.ecommerce.solution.payment.domain;
2: 
3: import lombok.AccessLevel;
4: import lombok.AllArgsConstructor;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.domainprimitives.MoneyPrimitive;
8: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
9: 
10: import javax.persistence.Embedded;
11: import javax.persistence.Entity;
12: import javax.persistence.Id;
13: import javax.persistence.ManyToOne;
14: import java.util.UUID;
15: 
16: @Entity
17: @Getter
18: @AllArgsConstructor(access = AccessLevel.PROTECTED)
19: @NoArgsConstructor
20: public class Payment {
21:     @Id
22:     private UUID id;
23:     @ManyToOne
24:     private Client client;
25:     @Embedded
26:     private MoneyPrimitive amount;
27:     private boolean authorized;
28: 
29:     public static Payment newInstance(UUID id, Client client, MoneyPrimitive amount, boolean authorized) {
30:         return new Payment(id, client, amount, authorized);
31:     }
32: }
33: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\payment\domain\PaymentRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.payment.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
5: 
6: import java.util.List;
7: import java.util.Optional;
8: import java.util.UUID;
9: 
10: public interface PaymentRepository extends JpaRepository<Payment, UUID> {
11:     Optional<List<Payment>> findByClientMailAddress(MailAddressPrimitive mailAddressPrimitive);
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ClientShoppingCartService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
5: import thkoeln.archilab.ecommerce.solution.client.application.ClientShoppingCartInterface;
6: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
7: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
8: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartRepository;
9: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartState;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
11: 
12: import java.util.List;
13: import java.util.UUID;
14: 
15: @Service
16: public class ClientShoppingCartService implements ClientShoppingCartInterface {
17:     private final ShoppingCartRepository shoppingCartRepository;
18: 
19:     public ClientShoppingCartService(ShoppingCartRepository shoppingCartRepository) {
20:         this.shoppingCartRepository = shoppingCartRepository;
21:         //this.clientRepository = clientRepository;
22:     }
23: 
24:     @Override
25:     public void save(UUID id, Client client, List parts) {
26:         shoppingCartRepository.save(ShoppingCart.newInstance(UUID.randomUUID(), client, parts, ShoppingCartState.EMPTY));
27:     }
28: 
29:     @Override
30:     public boolean shoppingCartExists(MailAddressType mailAddressType) {
31:         return shoppingCartRepository.findByClientMailAddress((MailAddressPrimitive) mailAddressType).isPresent();
32:     }
33: 
34:     @Override
35:     public void delete(MailAddressType mailAddressType) {
36:         shoppingCartRepository.delete(shoppingCartRepository.findByClientMailAddress((MailAddressPrimitive) mailAddressType).get());
37:     }
38: }
39: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartClientService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
6: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
7: import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
8: import thkoeln.archilab.ecommerce.solution.client.application.ShoppingCartClientInterface;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
10: 
11: import java.util.UUID;
12: 
13: @Service
14: public class ShoppingCartClientService implements ShoppingCartClientInterface {
15:     private final ClientRepository clientRepository;
16: 
17:     public ShoppingCartClientService(ClientRepository clientRepository) {
18:         this.clientRepository = clientRepository;
19:     }
20: 
21:     @Override
22:     public void checkIfClientExists(MailAddressType mailAddressType) {
23:         clientRepository.findByMailAddress((MailAddressPrimitive) mailAddressType).orElseThrow(() -> new ShopException("Client with this mail address does not exists"));
24:     }
25: 
26:     @Override
27:     public UUID getIdFromClient(MailAddressType mailAddressType) {
28:         checkIfClientExists(mailAddressType);
29:         return clientRepository.findByMailAddress((MailAddressPrimitive) mailAddressType).get().getId();
30:     }
31: 
32:     @Override
33:     public Client getClient(UUID id) {
34:         return clientRepository.findById(id).get();
35:     }
36: }
37: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartController.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.http.ResponseEntity;
5: import org.springframework.web.bind.annotation.*;
6: import org.springframework.web.servlet.support.ServletUriComponentsBuilder;
7: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
8: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
9: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartPart;
10: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartRepository;
11: 
12: import javax.ws.rs.QueryParam;
13: import java.net.URI;
14: import java.util.Map;
15: import java.util.Optional;
16: import java.util.UUID;
17: import java.util.stream.Collectors;
18: 
19: @RestController
20: public class ShoppingCartController {
21:     private final ShoppingCartRepository shoppingCartRepository;
22:     private final ShoppingCartService shoppingCartService;
23: 
24:     public ShoppingCartController(ShoppingCartRepository shoppingCartRepository, ShoppingCartService shoppingCartService) {
25:         this.shoppingCartRepository = shoppingCartRepository;
26:         this.shoppingCartService = shoppingCartService;
27:     }
28: 
29:     @GetMapping("/shoppingCarts")
30:     public ResponseEntity<ShoppingCart> getShoppingCart(@QueryParam(value = "mailAddress") String mailAddress) {
31:         if (mailAddress == null || mailAddress.isEmpty() || !isValidEmail(mailAddress) || shoppingCartRepository.findByClientMailAddress((MailAddressPrimitive) MailAddressPrimitive.of(mailAddress)).isEmpty())
32:             return ResponseEntity.notFound().build();
33:         ShoppingCart shoppingCart = shoppingCartRepository.findByClientMailAddress((MailAddressPrimitive) MailAddressPrimitive.of(mailAddress)).get();
34:         int totalQuantity = 0;
35:         for (ShoppingCartPart shoppingCartPart : shoppingCart.getShoppingCartParts()) {
36:             totalQuantity += shoppingCartPart.getQuantity();
37:         }
38:         shoppingCart.setTotalQuantity(totalQuantity);
39:         return ResponseEntity.ok(shoppingCart);
40:     }
41: 
42:     @PostMapping("/shoppingCarts/{shoppingCart-id}/shoppingCartParts")
43:     public ResponseEntity<?> addShoppingCartPart(@PathVariable("shoppingCart-id") String shoppingCartId, @RequestBody Map<String, Object> values) {
44:         if (shoppingCartId == null || shoppingCartId.isEmpty())
45:             return ResponseEntity.notFound().build();
46:         Optional<ShoppingCart> shoppingCartOptional = shoppingCartRepository.findById(UUID.fromString(shoppingCartId));
47:         if (shoppingCartOptional.isEmpty())
48:             return ResponseEntity.notFound().build();
49:         ShoppingCart shoppingCart = shoppingCartOptional.get();
50:         UUID thingId = UUID.fromString((String) values.get("thingId"));
51:         Integer quantity = (Integer) values.get("quantity");
52:         String comment = (String) values.get("comment");
53:         if (quantity < 0) {
54:             if (shoppingCart.getShoppingCartParts().stream().noneMatch(shoppingCartPart -> shoppingCartPart.getThingId().equals(thingId) && shoppingCartPart.getQuantity() >= -quantity))
55:                 return new ResponseEntity<>(HttpStatus.CONFLICT);
56:             shoppingCartService.removeThingFromShoppingCart(shoppingCart.getClient().getMailAddress(), thingId, -quantity, comment);
57:         } else {
58:             if (shoppingCartService.getShoppingCartWareHouseInterface().getQuantityFromThing(thingId) < (shoppingCartService.getReservedStockInShoppingCarts(thingId) + quantity))
59:                 return new ResponseEntity<>(HttpStatus.CONFLICT);
60:             shoppingCartService.addThingToShoppingCart(shoppingCart.getClient().getMailAddress(), thingId, quantity, comment);
61:         }
62:         URI returnURI = ServletUriComponentsBuilder
63:                 .fromCurrentRequest()
64:                 .build()
65:                 .toUri();
66:         return ResponseEntity.created(returnURI).build();
67:     }
68: 
69:     @GetMapping("/shoppingCarts/{shoppingCart-id}/shoppingCartParts/{thing-id}")
70:     public ResponseEntity<ShoppingCartPart> getShoppingCartPart(@PathVariable("shoppingCart-id") String shoppingCartId, @PathVariable("thing-id") String thingId) {
71:         if (shoppingCartId == null || shoppingCartId.isEmpty())
72:             return ResponseEntity.notFound().build();
73:         if (thingId == null || thingId.isEmpty())
74:             return ResponseEntity.notFound().build();
75:         Optional<ShoppingCart> shoppingCartOptional = shoppingCartRepository.findById(UUID.fromString(shoppingCartId));
76:         if (shoppingCartOptional.isEmpty())
77:             return ResponseEntity.notFound().build();
78:         ShoppingCart shoppingCart = shoppingCartOptional.get();
79:         try {
80:             shoppingCartService.getShoppingCartThingInterface().checkIfThingExists(UUID.fromString(thingId));
81:         } catch (Exception e) {
82:             return ResponseEntity.notFound().build();
83:         }
84:         if (shoppingCart.getShoppingCartParts().stream().noneMatch(shoppingCartPart -> shoppingCartPart.getThingId().equals(UUID.fromString(thingId))))
85:             return ResponseEntity.notFound().build();
86:         return ResponseEntity.ok(shoppingCart.getShoppingCartParts().stream().filter(shoppingCartPart -> shoppingCartPart.getThingId().equals(UUID.fromString(thingId))).collect(Collectors.toList()).get(0));
87:     }
88: 
89:     @DeleteMapping("/shoppingCarts/{shoppingCart-id}/shoppingCartParts/{thing-id}")
90:     public ResponseEntity<?> deleteShoppingCartPart(@PathVariable("shoppingCart-id") String shoppingCartId, @PathVariable("thing-id") String thingId) {
91:         if (shoppingCartId == null || shoppingCartId.isEmpty())
92:             return ResponseEntity.notFound().build();
93:         if (thingId == null || thingId.isEmpty())
94:             return ResponseEntity.notFound().build();
95:         Optional<ShoppingCart> shoppingCartOptional = shoppingCartRepository.findById(UUID.fromString(shoppingCartId));
96:         if (shoppingCartOptional.isEmpty())
97:             return ResponseEntity.notFound().build();
98:         ShoppingCart shoppingCart = shoppingCartOptional.get();
99:         try {
100:             shoppingCartService.getShoppingCartThingInterface().checkIfThingExists(UUID.fromString(thingId));
101:         } catch (Exception e) {
102:             return ResponseEntity.notFound().build();
103:         }
104:         if (shoppingCart.getShoppingCartParts().stream().noneMatch(shoppingCartPart -> shoppingCartPart.getThingId().equals(UUID.fromString(thingId))))
105:             return ResponseEntity.notFound().build();
106:         shoppingCart.getShoppingCartParts().removeAll(shoppingCart.getShoppingCartParts().stream().filter(shoppingCartPart -> shoppingCartPart.getThingId().equals(UUID.fromString(thingId))).collect(Collectors.toList()));
107:         shoppingCartRepository.save(shoppingCart);
108:         return ResponseEntity.ok().build();
109:     }
110: 
111:     @PutMapping("/shoppingCarts/{shoppingCart-id}/checkout")
112:     public ResponseEntity<?> checkout(@PathVariable("shoppingCart-id") String shoppingCartId) {
113:         if (shoppingCartId == null || shoppingCartId.isEmpty())
114:             return ResponseEntity.notFound().build();
115:         Optional<ShoppingCart> shoppingCartOptional = shoppingCartRepository.findById(UUID.fromString(shoppingCartId));
116:         if (shoppingCartOptional.isEmpty())
117:             return ResponseEntity.notFound().build();
118:         ShoppingCart shoppingCart = shoppingCartOptional.get();
119:         if (shoppingCart.getShoppingCartParts().isEmpty())
120:             return new ResponseEntity<>(HttpStatus.CONFLICT);
121:         if (!shoppingCartService.getShoppingCartPaymentInterface().checkIfClientIsAuthorized(shoppingCartService.getShoppingCartAsMoneyValue(shoppingCart.getClient().getMailAddress())))
122:             return new ResponseEntity<>(HttpStatus.CONFLICT);
123:         if (!shoppingCartService.getShoppingCartDeliveryInterface().isDeliveryAuthorized(shoppingCart.getClient(), shoppingCartService.getShoppingCartAsMap(shoppingCart.getClient().getMailAddress())))
124:             return new ResponseEntity<>(HttpStatus.CONFLICT);
125:         shoppingCartService.checkout(shoppingCart.getClient().getMailAddress());
126:         return ResponseEntity.ok().build();
127:     }
128: 
129:     private boolean isValidEmail(String mailAddress) {
130:         return mailAddress.matches("^[A-Za-z0-9]+(?:\\.[A-Za-z0-9]+)*@([A-Za-z0-9]+(?:\\.[A-Za-z0-9]+)*)\\.(de|at|ch|com|org)");
131:     }
132: }
133: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartDeliveryInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
4: import thkoeln.archilab.ecommerce.usecases.ClientType;
5: 
6: import java.util.Map;
7: import java.util.UUID;
8: 
9: public interface ShoppingCartDeliveryInterface {
10:     void triggerDelivery(ClientType clientType, Map<UUID, Integer> shoppingCartAsMap);
11: 
12:     boolean isDeliveryAuthorized(ClientType clientType, Map<UUID, Integer> shoppingCartAsMap);
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartOrderInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
4: 
5: import java.util.List;
6: import java.util.Map;
7: import java.util.UUID;
8: 
9: public interface ShoppingCartOrderInterface {
10:     void createOrder(UUID clientId, List<String> collect);
11: 
12:     Map<UUID, Integer> getOrderHistory(MailAddressType mailAddressType);
13: 
14:     void deleteAll();
15: }
16: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartPaymentInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
5: 
6: import java.util.UUID;
7: 
8: public interface ShoppingCartPaymentInterface {
9:     boolean checkIfClientIsAuthorized(MoneyType moneyType);
10: 
11:     void authorizePayment(MailAddressType clientMailAddress, MoneyType shoppingCartAsMoneyValue);
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import com.google.gson.Gson;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
7: import thkoeln.archilab.ecommerce.domainprimitives.MoneyPrimitive;
8: import thkoeln.archilab.ecommerce.solution.client.application.ShoppingCartClientInterface;
9: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
10: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartPart;
11: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartRepository;
12: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartState;
13: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
16: 
17: import java.util.*;
18: import java.util.concurrent.atomic.AtomicInteger;
19: import java.util.concurrent.atomic.AtomicReference;
20: import java.util.stream.Collectors;
21: 
22: @Service
23: public class ShoppingCartService implements ShoppingCartUseCases {
24:     private final ShoppingCartRepository shoppingCartRepository;
25:     private final ShoppingCartClientInterface shoppingCartClientInterface;
26:     private final ShoppingCartThingInterface shoppingCartThingInterface;
27:     private final ShoppingCartWareHouseInterface shoppingCartWareHouseInterface;
28:     private final ShoppingCartPaymentInterface shoppingCartPaymentInterface;
29:     private final ShoppingCartDeliveryInterface shoppingCartDeliveryInterface;
30:     private final ShoppingCartOrderInterface shoppingCartOrderInterface;
31: 
32:     public ShoppingCartService(ShoppingCartClientInterface shoppingCartClientInterface, ShoppingCartThingInterface shoppingCartThingInterface, ShoppingCartWareHouseInterface shoppingCartWareHouseInterface, ShoppingCartPaymentInterface shoppingCartPaymentInterface, ShoppingCartDeliveryInterface shoppingCartDeliveryInterface, ShoppingCartRepository shoppingCartRepository, ShoppingCartOrderInterface shoppingCartOrderInterface) {
33:         this.shoppingCartClientInterface = shoppingCartClientInterface;
34:         this.shoppingCartThingInterface = shoppingCartThingInterface;
35:         this.shoppingCartWareHouseInterface = shoppingCartWareHouseInterface;
36:         this.shoppingCartPaymentInterface = shoppingCartPaymentInterface;
37:         this.shoppingCartDeliveryInterface = shoppingCartDeliveryInterface;
38:         this.shoppingCartRepository = shoppingCartRepository;
39:         this.shoppingCartOrderInterface = shoppingCartOrderInterface;
40:     }
41: 
42:     @Override
43:     public void addThingToShoppingCart(MailAddressType clientMailAddress, UUID thingId, int quantity) {
44:         addThingToShoppingCart(clientMailAddress, thingId, quantity, null);
45:     }
46: 
47:     public void addThingToShoppingCart(MailAddressType clientMailAddress, UUID thingId, int quantity, String comment) {
48:         if (clientMailAddress == null || clientMailAddress.toString().isEmpty())
49:             throw new ShopException("Mail address is invalid");
50:         if (thingId == null)
51:             throw new ShopException("Thing id is invalid");
52:         if (quantity < 0)
53:             throw new ShopException("Quantity is negative");
54:         shoppingCartClientInterface.checkIfClientExists(clientMailAddress);
55:         shoppingCartThingInterface.checkIfThingExists(thingId);
56:         shoppingCartWareHouseInterface.checkIfWareHouseExists(thingId);
57:         if (shoppingCartWareHouseInterface.getQuantityFromThing(thingId) < (getReservedStockInShoppingCarts(thingId) + quantity))
58:             throw new ShopException("Thing is not enough in stock");
59:         UUID clientId = shoppingCartClientInterface.getIdFromClient(clientMailAddress);
60:         ShoppingCart shoppingCart = shoppingCartRepository.findByClientMailAddress((MailAddressPrimitive) clientMailAddress).orElse(ShoppingCart.newInstance(UUID.randomUUID(), shoppingCartClientInterface.getClient(clientId), new ArrayList<>(), ShoppingCartState.FILLED));
61:         if (shoppingCart.getShoppingCartParts().stream().anyMatch(shoppingCartPart -> shoppingCartPart.getThingId().equals(thingId))) {
62:             ShoppingCartPart shoppingCartPart = shoppingCart.getShoppingCartParts().stream().filter(shoppingCartPart1 -> shoppingCartPart1.getThingId().equals(thingId)).findFirst().orElse(null);
63:             if (shoppingCartPart == null)
64:                 return;
65:             shoppingCart.getShoppingCartParts().remove(shoppingCartPart);
66:             shoppingCartPart = ShoppingCartPart.newInstance(thingId, shoppingCartPart.getQuantity() + quantity, shoppingCartPart.getComment());
67:             shoppingCart.getShoppingCartParts().add(shoppingCartPart);
68:         } else
69:             shoppingCart.getShoppingCartParts().add(ShoppingCartPart.newInstance(thingId, quantity, comment));
70:         shoppingCart = ShoppingCart.newInstance(shoppingCart.getId(), shoppingCartClientInterface.getClient(clientId), shoppingCart.getShoppingCartParts(), ShoppingCartState.FILLED);
71:         shoppingCartRepository.save(shoppingCart);
72:     }
73: 
74:     @Override
75:     public void removeThingFromShoppingCart(MailAddressType clientMailAddress, UUID thingId, int quantity) {
76:         removeThingFromShoppingCart(clientMailAddress, thingId, quantity, null);
77:     }
78: 
79:     public void removeThingFromShoppingCart(MailAddressType clientMailAddress, UUID thingId, int quantity, String comment) {
80:         if (clientMailAddress == null || clientMailAddress.toString().isEmpty())
81:             throw new ShopException("Mail address is invalid");
82:         if (thingId == null)
83:             throw new ShopException("Thing id is invalid");
84:         if (quantity < 0)
85:             throw new ShopException("Quantity is negative");
86:         shoppingCartClientInterface.checkIfClientExists(clientMailAddress);
87:         shoppingCartThingInterface.checkIfThingExists(thingId);
88:         UUID clientId = shoppingCartClientInterface.getIdFromClient(clientMailAddress);
89:         ShoppingCart shoppingCart = shoppingCartRepository.findByClientMailAddress((MailAddressPrimitive) clientMailAddress).orElse(ShoppingCart.newInstance(UUID.randomUUID(), shoppingCartClientInterface.getClient(clientId), new ArrayList<>(), ShoppingCartState.FILLED));
90:         if (shoppingCart.getShoppingCartParts().stream().noneMatch(shoppingCartPart -> shoppingCartPart.getThingId().equals(thingId) && shoppingCartPart.getQuantity() >= quantity))
91:             throw new ShopException("Thing is not in shopping cart or in requested quantity");
92:         ShoppingCartPart shoppingCartPart = shoppingCart.getShoppingCartParts().stream().filter(shoppingCartPart1 -> shoppingCartPart1.getThingId().equals(thingId)).findFirst().orElse(null);
93:         if (shoppingCartPart == null)
94:             return;
95:         int newQuantity = shoppingCartPart.getQuantity() - quantity;
96:         shoppingCart.getShoppingCartParts().remove(shoppingCartPart);
97:         if (newQuantity == 0) {
98:             if (shoppingCart.getShoppingCartParts().isEmpty()) {
99:                 shoppingCartRepository.delete(shoppingCart);
100:                 return;
101:             }
102:         } else {
103:             shoppingCartPart = ShoppingCartPart.newInstance(thingId, newQuantity, comment);
104:             shoppingCart.getShoppingCartParts().add(shoppingCartPart);
105:         }
106:         shoppingCartRepository.save(shoppingCart);
107:     }
108: 
109:     @Override
110:     public void setCommentForShoppingCartPart(MailAddressType clientMailAddress, UUID thingId, String comment) {
111:         if (clientMailAddress == null || clientMailAddress.toString().isEmpty())
112:             throw new ShopException("Mail address is invalid");
113:         if (thingId == null)
114:             throw new ShopException("Thing id is invalid");
115:         shoppingCartClientInterface.checkIfClientExists(clientMailAddress);
116:         ShoppingCart shoppingCart = shoppingCartRepository.findByClientMailAddress((MailAddressPrimitive) clientMailAddress).orElseThrow(() -> new ShopException("Shoppingcard does not exists"));
117:         shoppingCartThingInterface.checkIfThingExists(thingId);
118:         Optional<ShoppingCartPart> partOptional = shoppingCart.getShoppingCartParts().stream().filter(shoppingCartPart1 -> shoppingCartPart1.getThingId().equals(thingId)).findFirst();
119:         if(partOptional.isEmpty())
120:             throw new ShopException("Not in shopping card");
121:         ShoppingCartPart shoppingCartPart = partOptional.get();
122:         shoppingCart.getShoppingCartParts().remove(shoppingCartPart);
123:         shoppingCartPart = ShoppingCartPart.newInstance(shoppingCartPart.getThingId(), shoppingCartPart.getQuantity(), comment);
124:         shoppingCart.getShoppingCartParts().add(shoppingCartPart);
125:         shoppingCartRepository.save(shoppingCart);
126:     }
127: 
128:     @Override
129:     public String getCommentForShoppingCartPart(MailAddressType clientMailAddress, UUID thingId) {
130:         if (clientMailAddress == null || clientMailAddress.toString().isEmpty())
131:             throw new ShopException("Mail address is invalid");
132:         if (thingId == null)
133:             throw new ShopException("Thing id is invalid");
134:         shoppingCartClientInterface.checkIfClientExists(clientMailAddress);
135:         ShoppingCart shoppingCart = shoppingCartRepository.findByClientMailAddress((MailAddressPrimitive) clientMailAddress).orElseThrow(() -> new ShopException("Shoppingcard does not exists"));
136:         shoppingCartThingInterface.checkIfThingExists(thingId);
137:         Optional<ShoppingCartPart> partOptional = shoppingCart.getShoppingCartParts().stream().filter(shoppingCartPart1 -> shoppingCartPart1.getThingId().equals(thingId)).findFirst();
138:         if(partOptional.isEmpty())
139:             throw new ShopException("Not in shopping card");
140:         return partOptional.get().getComment();
141:     }
142: 
143:     @Override
144:     public Map<UUID, Integer> getShoppingCartAsMap(MailAddressType clientMailAddress) {
145:         if (clientMailAddress == null || clientMailAddress.toString().isEmpty())
146:             throw new ShopException("Mail address is invalid");
147:         shoppingCartClientInterface.checkIfClientExists(clientMailAddress);
148:         ShoppingCart shoppingCart = shoppingCartRepository.findByClientMailAddress((MailAddressPrimitive) clientMailAddress).orElse(null);
149:         if (shoppingCart == null)
150:             return Collections.emptyMap();
151:         Map<UUID, Integer> shoppingCartMap = new HashMap<>();
152:         shoppingCart.getShoppingCartParts().forEach(shoppingCartPart -> shoppingCartMap.put(shoppingCartPart.getThingId(), shoppingCartPart.getQuantity()));
153:         return shoppingCartMap;
154:     }
155: 
156:     @Override
157:     public MoneyType getShoppingCartAsMoneyValue(MailAddressType clientMailAddress) {
158:         if (clientMailAddress == null || clientMailAddress.toString().isEmpty())
159:             throw new ShopException("Mail address is invalid");
160:         shoppingCartClientInterface.checkIfClientExists(clientMailAddress);
161:         UUID clientId = shoppingCartClientInterface.getIdFromClient(clientMailAddress);
162:         ShoppingCart shoppingCart = shoppingCartRepository.findByClientMailAddress((MailAddressPrimitive) clientMailAddress).orElse(null);
163:         if (shoppingCart == null)
164:             return MoneyPrimitive.of(0.0f, "EUR");
165:         AtomicReference<MoneyType> sum = new AtomicReference<>(MoneyPrimitive.of(0.0f, "EUR"));
166:         shoppingCart.getShoppingCartParts().forEach(shoppingCartPart -> {
167:             shoppingCartThingInterface.checkIfThingExists(shoppingCartPart.getThingId());
168:             sum.set(sum.get().add(shoppingCartThingInterface.getSellingPriceFromThing(shoppingCartPart.getThingId()).multiplyBy(shoppingCartPart.getQuantity())));
169:         });
170:         return sum.get();
171:     }
172: 
173:     @Override
174:     public int getReservedStockInShoppingCarts(UUID thingId) {
175:         if (thingId == null)
176:             throw new ShopException("Thing id is invalid");
177:         shoppingCartThingInterface.checkIfThingExists(thingId);
178:         AtomicInteger sum = new AtomicInteger();
179:         shoppingCartRepository.findAll().forEach(shoppingCart -> shoppingCart.getShoppingCartParts().forEach(shoppingCartPart -> {
180:             if (shoppingCartPart.getThingId().equals(thingId))
181:                 sum.addAndGet(shoppingCartPart.getQuantity());
182:         }));
183:         return sum.get();
184:     }
185: 
186:     @Override
187:     public boolean isEmpty(MailAddressType clientMailAddress) {
188:         if (clientMailAddress == null || clientMailAddress.toString().isEmpty())
189:             throw new ShopException("Mail address is invalid");
190:         shoppingCartClientInterface.checkIfClientExists(clientMailAddress);
191:         ShoppingCart shoppingCart = shoppingCartRepository.findByClientMailAddress((MailAddressPrimitive) clientMailAddress).orElse(null);
192:         return shoppingCart == null || shoppingCart.getShoppingCartParts().isEmpty();
193:     }
194: 
195:     @Override
196:     public boolean isPaymentAuthorized(MailAddressType clientMailAddress) {
197:         if (clientMailAddress == null || clientMailAddress.toString().isEmpty())
198:             throw new ShopException("Mail address is invalid");
199:         shoppingCartClientInterface.checkIfClientExists(clientMailAddress);
200:         ShoppingCart shoppingCart = shoppingCartRepository.findByClientMailAddress((MailAddressPrimitive) clientMailAddress).orElse(null);
201:         if (shoppingCart == null || shoppingCart.getShoppingCartParts().isEmpty())
202:             return false;
203:         return shoppingCartPaymentInterface.checkIfClientIsAuthorized(getShoppingCartAsMoneyValue(clientMailAddress));
204:     }
205: 
206:     @Override
207:     public void checkout(MailAddressType clientMailAddress) {
208:         if (clientMailAddress == null || clientMailAddress.toString().isEmpty())
209:             throw new ShopException("Mail address is invalid");
210:         shoppingCartClientInterface.checkIfClientExists(clientMailAddress);
211:         UUID clientId = shoppingCartClientInterface.getIdFromClient(clientMailAddress);
212:         ShoppingCart shoppingCart = shoppingCartRepository.findByClientMailAddress((MailAddressPrimitive) clientMailAddress).orElseThrow(() -> new ShopException("Shopping cart does not exists"));
213:         if (shoppingCart.getShoppingCartParts().isEmpty())
214:             throw new ShopException("Shopping cart is empty");
215:         switch (shoppingCart.getShoppingCartState()) {
216:             case EMPTY:
217:                 break;
218:             case FILLED:
219:                 shoppingCartPaymentInterface.authorizePayment(clientMailAddress, getShoppingCartAsMoneyValue(clientMailAddress));
220:                 shoppingCart = ShoppingCart.newInstance(shoppingCart.getId(), shoppingCartClientInterface.getClient(clientId), shoppingCart.getShoppingCartParts(), ShoppingCartState.PAYMENT_AUTHORIZED);
221:                 shoppingCartDeliveryInterface.triggerDelivery(shoppingCart.getClient(), getShoppingCartAsMap(clientMailAddress));
222:                 shoppingCart = ShoppingCart.newInstance(shoppingCart.getId(), shoppingCartClientInterface.getClient(clientId), shoppingCart.getShoppingCartParts(), ShoppingCartState.DELIVERY_TRIGGERED);
223:                 break;
224:             case PAYMENT_AUTHORIZED:
225:                 shoppingCartDeliveryInterface.triggerDelivery(shoppingCart.getClient(), getShoppingCartAsMap(clientMailAddress));
226:                 shoppingCart = ShoppingCart.newInstance(shoppingCart.getId(), shoppingCartClientInterface.getClient(clientId), shoppingCart.getShoppingCartParts(), ShoppingCartState.DELIVERY_TRIGGERED);
227:                 break;
228:             case DELIVERY_TRIGGERED:
229:                 shoppingCart = ShoppingCart.newInstance(shoppingCart.getId(), shoppingCartClientInterface.getClient(clientId), shoppingCart.getShoppingCartParts(), ShoppingCartState.EMPTY);
230:                 break;
231:         }
232:         shoppingCartRepository.save(shoppingCart);
233:         for (ShoppingCartPart shoppingCartPart : shoppingCart.getShoppingCartParts()) {
234:             shoppingCartWareHouseInterface.checkIfWareHouseExists(shoppingCartPart.getThingId());
235:             int newStockQuantity = shoppingCartWareHouseInterface.getQuantityFromThing(shoppingCartPart.getThingId()) - shoppingCartPart.getQuantity();
236:             if (newStockQuantity < 0)
237:                 throw new ShopException("Not enough stock for");
238:             shoppingCartThingInterface.checkIfThingExists(shoppingCartPart.getThingId());
239:             shoppingCartWareHouseInterface.save(shoppingCartPart.getThingId(), newStockQuantity);
240:         }
241:         shoppingCartOrderInterface.createOrder(clientId, shoppingCart.getShoppingCartParts().stream().map(shoppingCartPart -> new Gson().toJson(shoppingCartPart)).collect(Collectors.toList()));
242:         shoppingCart = ShoppingCart.newInstance(shoppingCart.getId(), shoppingCartClientInterface.getClient(clientId), new ArrayList<>(), ShoppingCartState.EMPTY);
243:         shoppingCartRepository.save(shoppingCart);
244:     }
245: 
246:     @Override
247:     public Map<UUID, Integer> getOrderHistory(MailAddressType clientMailAddress) {
248:         if (clientMailAddress == null || clientMailAddress.toString().isEmpty())
249:             throw new ShopException("Mail address is invalid");
250:         shoppingCartClientInterface.checkIfClientExists(clientMailAddress);
251:         UUID clientId = shoppingCartClientInterface.getIdFromClient(clientMailAddress);
252:         return shoppingCartOrderInterface.getOrderHistory(clientMailAddress);
253:     }
254: 
255:     @Override
256:     public void deleteAllOrders() {
257:         shoppingCartRepository.deleteAll();
258:         shoppingCartOrderInterface.deleteAll();
259:     }
260: 
261:     public ShoppingCartClientInterface getShoppingCartClientInterface() {
262:         return shoppingCartClientInterface;
263:     }
264: 
265:     public ShoppingCartDeliveryInterface getShoppingCartDeliveryInterface() {
266:         return shoppingCartDeliveryInterface;
267:     }
268: 
269:     public ShoppingCartPaymentInterface getShoppingCartPaymentInterface() {
270:         return shoppingCartPaymentInterface;
271:     }
272: 
273:     public ShoppingCartThingInterface getShoppingCartThingInterface() {
274:         return shoppingCartThingInterface;
275:     }
276: 
277:     public ShoppingCartWareHouseInterface getShoppingCartWareHouseInterface() {
278:         return shoppingCartWareHouseInterface;
279:     }
280: }
281: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartThingInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
4: 
5: import java.util.UUID;
6: 
7: public interface ShoppingCartThingInterface {
8:     void checkIfThingExists(UUID id);
9:     MoneyType getSellingPriceFromThing(UUID id);
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartWareHouseInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import java.util.UUID;
4: 
5: public interface ShoppingCartWareHouseInterface {
6:     void checkIfWareHouseExists(UUID id);
7:     int getQuantityFromThing(UUID id);
8: 
9:     void save(UUID thingId, int newStockQuantity);
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ThingShoppingCartInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import java.util.UUID;
4: 
5: public interface ThingShoppingCartInterface {
6:     int getReservedStockInShoppingCarts(UUID thingId);
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCart.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import lombok.*;
4: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
5: 
6: import javax.persistence.*;
7: import java.util.ArrayList;
8: import java.util.List;
9: import java.util.UUID;
10: 
11: @Entity
12: @Getter
13: @AllArgsConstructor(access = AccessLevel.PROTECTED)
14: @NoArgsConstructor
15: public class ShoppingCart {
16:     @Id
17:     private UUID id;
18:     @OneToOne
19:     private Client client;
20:     @ElementCollection(targetClass = ShoppingCartPart.class)
21:     private List<ShoppingCartPart> shoppingCartParts = new ArrayList<>();
22:     @Enumerated
23:     private ShoppingCartState shoppingCartState = ShoppingCartState.EMPTY;
24:     @Setter
25:     private int totalQuantity;
26: 
27:     public static ShoppingCart newInstance(UUID id, Client client, List<ShoppingCartPart> shoppingCartParts, ShoppingCartState shoppingCartState) {
28:         return new ShoppingCart(id, client, shoppingCartParts, shoppingCartState, 0);
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPart.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import lombok.AccessLevel;
4: import lombok.AllArgsConstructor;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: 
8: import javax.persistence.Embeddable;
9: import java.util.UUID;
10: 
11: @Embeddable
12: @Getter
13: @AllArgsConstructor(access = AccessLevel.PROTECTED)
14: @NoArgsConstructor
15: public class ShoppingCartPart {
16:     private UUID thingId;
17:     private int quantity;
18:     private String comment;
19:     public static ShoppingCartPart newInstance(UUID thingId, int quantity, String comment) {
20:         return new ShoppingCartPart(thingId, quantity, comment);
21:     }
22: }
23: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.data.jpa.repository.Query;
5: import org.springframework.data.repository.query.Param;
6: import thkoeln.archilab.ecommerce.domainprimitives.MailAddressPrimitive;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
8: 
9: import java.util.Optional;
10: import java.util.UUID;
11: 
12: public interface ShoppingCartRepository extends JpaRepository<ShoppingCart, UUID> {
13:     Optional<ShoppingCart> findByClientMailAddress(MailAddressPrimitive mailAddressPrimitive);
14:     @Query("SELECT coalesce(SUM(scp.quantity), 0) FROM ShoppingCart as sc join sc.shoppingCartParts scp WHERE scp.thingId=:thingId")
15:     Integer getReservedStockInShoppingCarts(@Param("thingId") UUID thingId);
16: }
17: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartState.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: public enum ShoppingCartState {
4:     EMPTY,
5:     FILLED,
6:     PAYMENT_AUTHORIZED,
7:     DELIVERY_TRIGGERED
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\thing\application\OrderThingService.java ---
1: package thkoeln.archilab.ecommerce.solution.thing.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.solution.order.application.OrderThingInterface;
5: import thkoeln.archilab.ecommerce.solution.thing.domain.ThingRepository;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
7: 
8: import java.util.UUID;
9: 
10: @Service
11: public class OrderThingService implements OrderThingInterface {
12:     private final ThingRepository thingRepository;
13: 
14:     public OrderThingService(ThingRepository thingRepository) {
15:         this.thingRepository = thingRepository;
16:     }
17: 
18:     @Override
19:     public MoneyType getSellingPrice(UUID id) {
20:         return thingRepository.findById(id).get().getSellingPrize();
21:     }
22: }
23: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\thing\application\ShoppingCartThingService.java ---
1: package thkoeln.archilab.ecommerce.solution.thing.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.solution.shoppingcart.application.ShoppingCartThingInterface;
6: import thkoeln.archilab.ecommerce.solution.thing.domain.ThingRepository;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
8: 
9: import java.util.UUID;
10: 
11: @Service
12: public class ShoppingCartThingService implements ShoppingCartThingInterface {
13:     private final ThingRepository thingRepository;
14: 
15:     public ShoppingCartThingService(ThingRepository thingRepository) {
16:         this.thingRepository = thingRepository;
17:     }
18: 
19:     @Override
20:     public void checkIfThingExists(UUID id) {
21:         thingRepository.findById(id).orElseThrow(() -> new ShopException("Thing does not exists"));
22:     }
23: 
24:     @Override
25:     public MoneyType getSellingPriceFromThing(UUID id) {
26:         checkIfThingExists(id);
27:         return thingRepository.findById(id).get().getSellingPrize();
28:     }
29: }
30: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\thing\application\ThingService.java ---
1: package thkoeln.archilab.ecommerce.solution.thing.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.domainprimitives.MoneyPrimitive;
6: import thkoeln.archilab.ecommerce.solution.shoppingcart.application.ThingShoppingCartInterface;
7: import thkoeln.archilab.ecommerce.solution.thing.domain.Thing;
8: import thkoeln.archilab.ecommerce.solution.thing.domain.ThingRepository;
9: import thkoeln.archilab.ecommerce.usecases.ThingCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
11: 
12: import java.util.UUID;
13: 
14: @Service
15: public class ThingService implements ThingCatalogUseCases {
16:     private final ThingRepository thingRepository;
17:     private final ThingWareHouseInterface thingWareHouseInterface;
18:     private final ThingShoppingCartInterface thingShoppingCartInterface;
19: 
20:     public ThingService(ThingRepository thingRepository, ThingWareHouseInterface thingWareHouseInterface, ThingShoppingCartInterface thingShoppingCartInterface) {
21:         this.thingRepository = thingRepository;
22:         this.thingWareHouseInterface = thingWareHouseInterface;
23:         this.thingShoppingCartInterface = thingShoppingCartInterface;
24:     }
25: 
26:     @Override
27:     public void addThingToCatalog(UUID thingId, String name, String description, Float size, MoneyType purchasePrice, MoneyType sellingPrice) {
28:         if (thingId == null)
29:             throw new ShopException("Thing id is invalid");
30:         if (name == null || name.isEmpty())
31:             throw new ShopException("Name is invalid");
32:         if (description == null || description.isEmpty())
33:             throw new ShopException("Description is invalid");
34:         if (size != null && size <= 0)
35:             throw new ShopException("Size is invalid");
36:         if (purchasePrice == null || purchasePrice.getAmount() <= 0)
37:             throw new ShopException("Purchase price is invalid");
38:         if (sellingPrice == null || sellingPrice.getAmount() <= 0)
39:             throw new ShopException("Selling price is invalid");
40:         if (sellingPrice.getAmount() < purchasePrice.getAmount())
41:             throw new ShopException("Selling price is lower than purchase price");
42:         if (thingRepository.findById(thingId).isPresent())
43:             throw new ShopException("Thing with this id already exists");
44:         Thing thing = Thing.newInstance(thingId, name, description, size, (MoneyPrimitive) purchasePrice, (MoneyPrimitive) sellingPrice);
45:         thingRepository.save(thing);
46:     }
47: 
48:     @Override
49:     public void removeThingFromCatalog(UUID thingId) {
50:         if (thingId == null)
51:             throw new ShopException("Thing id is invalid");
52:         if (thingWareHouseInterface.existsInWareHouse(thingId))
53:             throw new ShopException("Thing is still in stock");
54:         if (thingShoppingCartInterface.getReservedStockInShoppingCarts(thingId) > 0)
55:             throw new ShopException("Thing is still in a shopping cart");
56:         thingRepository.deleteById(thingId);
57:     }
58: 
59:     @Override
60:     public MoneyType getSellingPrice(UUID thingId) {
61:         if (thingId == null)
62:             throw new ShopException("Thing id is invalid");
63:         Thing thing = thingRepository.findById(thingId).orElseThrow(() -> new ShopException("Thing with this id does not exists"));
64:         return thing.getSellingPrize();
65:     }
66: 
67:     @Override
68:     public void deleteThingCatalog() {
69:         thingRepository.deleteAll();
70:     }
71: }
72: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\thing\application\ThingShoppingCartService.java ---
1: package thkoeln.archilab.ecommerce.solution.thing.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.solution.shoppingcart.application.ThingShoppingCartInterface;
5: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartRepository;
6: 
7: import java.util.UUID;
8: import java.util.concurrent.atomic.AtomicInteger;
9: 
10: @Service
11: public class ThingShoppingCartService implements ThingShoppingCartInterface {
12:     private final ShoppingCartRepository shoppingCartRepository;
13: 
14:     public ThingShoppingCartService(ShoppingCartRepository shoppingCartRepository) {
15:         this.shoppingCartRepository = shoppingCartRepository;
16:     }
17: 
18:     @Override
19:     public int getReservedStockInShoppingCarts(UUID thingId) {
20:         AtomicInteger sum = new AtomicInteger();
21:         shoppingCartRepository.findAll().forEach(shoppingCart -> shoppingCart.getShoppingCartParts().forEach(shoppingCartPart -> {
22:             if (shoppingCartPart.getThingId().equals(thingId))
23:                 sum.addAndGet(shoppingCartPart.getQuantity());
24:         }));
25:         return sum.get();
26:     }
27: }
28: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\thing\application\ThingWareHouseInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.thing.application;
2: 
3: import java.util.UUID;
4: 
5: public interface ThingWareHouseInterface {
6:     boolean existsInWareHouse(UUID thingId);
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\thing\application\WareHouseThingInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.thing.application;
2: 
3: import thkoeln.archilab.ecommerce.solution.thing.domain.Thing;
4: 
5: import java.util.UUID;
6: 
7: public interface WareHouseThingInterface {
8:     void checkIfThingExists(UUID id);
9: 
10:     Thing getThing(UUID thingId);
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\thing\domain\Thing.java ---
1: package thkoeln.archilab.ecommerce.solution.thing.domain;
2: 
3: import lombok.AccessLevel;
4: import lombok.AllArgsConstructor;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.domainprimitives.MoneyPrimitive;
8: 
9: import javax.persistence.Column;
10: import javax.persistence.Embedded;
11: import javax.persistence.Entity;
12: import javax.persistence.Id;
13: import java.util.UUID;
14: 
15: @Entity
16: @Getter
17: @AllArgsConstructor(access = AccessLevel.PROTECTED)
18: @NoArgsConstructor
19: public class Thing {
20:     @Id
21:     private UUID id;
22:     private String name;
23:     private String description;
24:     private Float size;
25:     @Embedded
26:     private MoneyPrimitive purchasePrize;
27:     @Embedded
28:     private MoneyPrimitive sellingPrize;
29: 
30:     public static Thing newInstance(UUID id, String name, String description, Float size, MoneyPrimitive purchasePrize, MoneyPrimitive sellingPrize) {
31:         return new Thing(id, name, description, size, purchasePrize, sellingPrize);
32:     }
33: }
34: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\thing\domain\ThingRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.thing.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: 
5: import java.util.UUID;
6: 
7: public interface ThingRepository extends JpaRepository<Thing, UUID> {
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\warehouse\application\ShoppingCartWareHouseService.java ---
1: package thkoeln.archilab.ecommerce.solution.warehouse.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.solution.shoppingcart.application.ShoppingCartWareHouseInterface;
7: import thkoeln.archilab.ecommerce.solution.warehouse.domain.WareHouse;
8: import thkoeln.archilab.ecommerce.solution.warehouse.domain.WareHouseRepository;
9: 
10: import java.util.UUID;
11: 
12: @Service
13: public class ShoppingCartWareHouseService implements ShoppingCartWareHouseInterface {
14:     private final WareHouseRepository wareHouseRepository;
15:     private final WareHouseThingService wareHouseThingService;
16: 
17:     public ShoppingCartWareHouseService(WareHouseRepository wareHouseRepository, WareHouseThingService wareHouseThingService) {
18:         this.wareHouseRepository = wareHouseRepository;
19:         this.wareHouseThingService = wareHouseThingService;
20:     }
21: 
22:     @Override
23:     public void checkIfWareHouseExists(UUID id) {
24:         wareHouseRepository.findByThingId(id).orElseThrow(() -> new ShopException("Thing with this id does not exists"));
25:     }
26: 
27:     @Override
28:     public int getQuantityFromThing(UUID id) {
29:         checkIfWareHouseExists(id);
30:         return wareHouseRepository.findByThingId(id).get().getQuantity();
31:     }
32: 
33:     @Override
34:     public void save(UUID thingId, int newStockQuantity) {
35:         checkIfWareHouseExists(thingId);
36:         WareHouse wareHouse = wareHouseRepository.findByThingId(thingId).get();
37:         wareHouse = WareHouse.newInstance(wareHouse.getId(), wareHouseThingService.getThing(thingId), newStockQuantity);
38:         wareHouseRepository.save(wareHouse);
39:     }
40: }
41: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\warehouse\application\StockService.java ---
1: package thkoeln.archilab.ecommerce.solution.warehouse.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
6: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartPart;
7: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartRepository;
8: import thkoeln.archilab.ecommerce.solution.thing.application.WareHouseThingInterface;
9: import thkoeln.archilab.ecommerce.solution.warehouse.domain.WareHouse;
10: import thkoeln.archilab.ecommerce.solution.warehouse.domain.WareHouseRepository;
11: import thkoeln.archilab.ecommerce.usecases.StockManagementUseCases;
12: 
13: import java.util.UUID;
14: 
15: @Service
16: public class StockService implements StockManagementUseCases {
17:     private final WareHouseRepository wareHouseRepository;
18:     //private final EcommerceWareHouseUseCases ecommerceWareHouseUseCases;
19:     private final WareHouseThingInterface wareHouseThingInterface;
20:     private final ShoppingCartRepository shoppingCartRepository;
21: 
22:     public StockService(WareHouseRepository wareHouseRepository, WareHouseThingInterface wareHouseThingInterface, ShoppingCartRepository shoppingCartRepository) {
23:         this.wareHouseRepository = wareHouseRepository;
24:         this.wareHouseThingInterface = wareHouseThingInterface;
25:         this.shoppingCartRepository = shoppingCartRepository;
26:     }
27: 
28:     @Override
29:     public void addToStock(UUID thingId, int addedQuantity) {
30:         if (thingId == null)
31:             throw new ShopException("Thing id is invalid");
32:         if (addedQuantity <= 0)
33:             throw new ShopException("Quantity is negative");
34:         wareHouseThingInterface.checkIfThingExists(thingId);
35:         //Thing thing = ecommerceThingUseCases.getThing(thingId).orElseThrow(() -> new ShopException("Thing with this id does not exists"));
36:         WareHouse wareHouse = wareHouseRepository.findByThingId(thingId).orElse(WareHouse.newInstance(UUID.randomUUID(), wareHouseThingInterface.getThing(thingId), 0));
37:         wareHouse = WareHouse.newInstance(wareHouse.getId(), wareHouse.getThing(), wareHouse.getQuantity() + addedQuantity);
38:         wareHouseRepository.save(wareHouse);
39:     }
40: 
41:     @Override
42:     public void removeFromStock(UUID thingId, int removedQuantity) {
43:         if (thingId == null)
44:             throw new ShopException("Thing id is invalid");
45:         if (removedQuantity <= 0)
46:             throw new ShopException("Quantity is negative");
47:         wareHouseThingInterface.checkIfThingExists(thingId);
48:         //Thing thing = ecommerceThingUseCases.getThing(thingId).orElseThrow(() -> new ShopException("Thing with this id does not exists"));
49:         WareHouse wareHouse = wareHouseRepository.findByThingId(thingId).orElseThrow(() -> new ShopException("Thing with this id is not in stock"));
50:         int newQuantity = wareHouse.getQuantity() - removedQuantity;
51:         if (newQuantity < 0)
52:             throw new ShopException("New quantity is negative");
53:         wareHouse = WareHouse.newInstance(wareHouse.getId(), wareHouseThingInterface.getThing(thingId), newQuantity);
54:         wareHouseRepository.save(wareHouse);
55:         while (shoppingCartRepository.getReservedStockInShoppingCarts(thingId) > newQuantity) {
56:             ShoppingCart order = null;
57:             ShoppingCartPart orderPart = null;
58:             for (ShoppingCart order1 : shoppingCartRepository.findAll()) {
59:                 for (ShoppingCartPart orderPart1 : order1.getShoppingCartParts()) {
60:                     if (orderPart1.getThingId().equals(thingId) && orderPart1.getQuantity() > 0) {
61:                         order = order1;
62:                         orderPart = orderPart1;
63:                         break;
64:                     }
65:                 }
66:             }
67: 
68:             if (orderPart == null)
69:                 return;
70:             order.getShoppingCartParts().remove(orderPart);
71:             orderPart = ShoppingCartPart.newInstance(orderPart.getThingId(), orderPart.getQuantity() - 1, orderPart.getComment());
72:             order.getShoppingCartParts().add(orderPart);
73:             shoppingCartRepository.save(order);
74:         }
75:     }
76: 
77:     @Override
78:     public void changeStockTo(UUID thingId, int newTotalQuantity) {
79:         wareHouseThingInterface.checkIfThingExists(thingId);
80:         //Thing thing = ecommerceThingUseCases.getThing(id).orElseThrow(() -> new ShopException("Thing with this id does not exists"));
81:         WareHouse wareHouse = wareHouseRepository.findByThingId(thingId).orElseThrow(() -> new ShopException("Thing with this id is not in stock"));
82:         wareHouse = WareHouse.newInstance(wareHouse.getId(), wareHouseThingInterface.getThing(thingId), newTotalQuantity);
83:         wareHouseRepository.save(wareHouse);
84:         while (shoppingCartRepository.getReservedStockInShoppingCarts(thingId) > newTotalQuantity) {
85:             ShoppingCart order = null;
86:             ShoppingCartPart orderPart = null;
87:             for (ShoppingCart order1 : shoppingCartRepository.findAll()) {
88:                 for (ShoppingCartPart orderPart1 : order1.getShoppingCartParts()) {
89:                     if (orderPart1.getThingId().equals(thingId) && orderPart1.getQuantity() > newTotalQuantity) {
90:                         order = order1;
91:                         orderPart = orderPart1;
92:                         break;
93:                     }
94:                 }
95:             }
96: 
97:             if (orderPart == null)
98:                 return;
99:             order.getShoppingCartParts().remove(orderPart);
100:             orderPart = ShoppingCartPart.newInstance(orderPart.getThingId(), orderPart.getQuantity() - 1, orderPart.getComment());
101:             order.getShoppingCartParts().add(orderPart);
102:             shoppingCartRepository.save(order);
103:         }
104:     }
105: 
106:     @Override
107:     public int getAvailableStock(UUID thingId) {
108:         if (thingId == null)
109:             throw new ShopException("Thing id is invalid");
110:         wareHouseThingInterface.checkIfThingExists(thingId);
111:         //Thing thing = ecommerceThingUseCases.getThing(id).orElseThrow(() -> new ShopException("Thing with this id does not exists"));
112:         WareHouse wareHouse = wareHouseRepository.findByThingId(thingId).orElseThrow(() -> new ShopException("Thing with this id is not in stock"));
113:         return wareHouse.getQuantity();
114:     }
115: }
116: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\warehouse\application\ThingWareHouseService.java ---
1: package thkoeln.archilab.ecommerce.solution.warehouse.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.thing.application.ThingWareHouseInterface;
6: import thkoeln.archilab.ecommerce.solution.warehouse.domain.WareHouseRepository;
7: 
8: import java.util.UUID;
9: 
10: @Service
11: public class ThingWareHouseService implements ThingWareHouseInterface {
12:     private final WareHouseRepository wareHouseRepository;
13: 
14:     public ThingWareHouseService(WareHouseRepository wareHouseRepository) {
15:         this.wareHouseRepository = wareHouseRepository;
16:     }
17: 
18:     @Override
19:     public boolean existsInWareHouse(UUID thingId) {
20:         return wareHouseRepository.existsByThingId(thingId);
21:     }
22: }
23: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\warehouse\application\WareHouseThingService.java ---
1: package thkoeln.archilab.ecommerce.solution.warehouse.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.solution.thing.domain.Thing;
6: import thkoeln.archilab.ecommerce.solution.thing.domain.ThingRepository;
7: import thkoeln.archilab.ecommerce.solution.thing.application.WareHouseThingInterface;
8: 
9: import java.util.UUID;
10: 
11: @Service
12: public class WareHouseThingService implements WareHouseThingInterface {
13:     private final ThingRepository thingRepository;
14: 
15:     public WareHouseThingService(ThingRepository thingRepository) {
16:         this.thingRepository = thingRepository;
17:     }
18: 
19:     @Override
20:     public void checkIfThingExists(UUID id) {
21:         thingRepository.findById(id).orElseThrow(() -> new ShopException("Thing with this id does not exists"));
22:     }
23: 
24:     @Override
25:     public Thing getThing(UUID thingId) {
26:         return thingRepository.findById(thingId).get();
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\warehouse\domain\WareHouse.java ---
1: package thkoeln.archilab.ecommerce.solution.warehouse.domain;
2: 
3: import lombok.AccessLevel;
4: import lombok.AllArgsConstructor;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.solution.thing.domain.Thing;
8: 
9: import javax.persistence.Entity;
10: import javax.persistence.Id;
11: import javax.persistence.OneToOne;
12: import java.util.UUID;
13: 
14: @Entity
15: @Getter
16: @AllArgsConstructor(access = AccessLevel.PROTECTED)
17: @NoArgsConstructor
18: public class WareHouse {
19:     @Id
20:     private UUID id;
21:     @OneToOne
22:     private Thing thing;
23:     private int quantity;
24: 
25:     public static WareHouse newInstance(UUID id, Thing thing, int quantity) {
26:         return new WareHouse(id, thing, quantity);
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\warehouse\domain\WareHouseRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.warehouse.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: 
5: import java.util.Optional;
6: import java.util.UUID;
7: 
8: public interface WareHouseRepository extends JpaRepository<WareHouse, UUID> {
9:     boolean existsByThingId(UUID id);
10: 
11:     Optional<WareHouse> findByThingId(UUID id);
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\usecases\ClientRegistrationUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;
6: 
7: /**
8:  * This interface contains methods needed in the context of use cases dealing with registering a client.
9:  * The interface is probably incomplete, and will grow over time.
10:  */
11: public interface ClientRegistrationUseCases {
12:     /**
13:      * Registers a new client
14:      *
15:      * @param name
16:      * @param mailAddress
17:      * @param homeAddress
18:      * @throws ShopException if ...
19:      *      - name is null or empty
20:      *      - mailAddress is null
21:      *      - client with the given mail address already exists
22:      *      - homeAddress is null
23:      */
24:     public void register( String name, MailAddressType mailAddress, HomeAddressType homeAddress );
25: 
26: 
27:     /**
28:      * Changes the homeAddress of a client
29:      *
30:      * @param clientMailAddress
31:      * @param homeAddress
32:      * @throws ShopException if ...
33:      *      - mailAddress is null
34:      *      - client with the given mail address already exists
35:      *      - homeAddress is null
36:      */
37:     public void changeAddress( MailAddressType clientMailAddress, HomeAddressType homeAddress );
38: 
39: 
40:     /**
41:      * Returns the data of a client
42:      * @param clientMailAddress
43:      * @return the client data
44:      * @throws ShopException if ...
45:      *      - mailAddress is null
46:      *      - the client with the given mail address does not exist
47:      */
48:     public ClientType getClientData( MailAddressType clientMailAddress );
49: 
50: 
51: 
52:     /**
53:      * Deletes all clients, including all orders and shopping carts
54:      */
55:     public void deleteAllClients();
56: }
57: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\usecases\ClientType.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;
5: 
6: /**
7:  * This interface expresses the essence of a shop client
8:  */
9: public interface ClientType {
10:     public String getName();
11:     public MailAddressType getMailAddress();
12:     public HomeAddressType getHomeAddress();
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\usecases\DeliveryUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: 
6: import java.util.Map;
7: import java.util.UUID;
8: 
9: /**
10:  * This interface contains methods needed in the context of use cases dealing with logistics,
11:  * i.e. the delivery of things to a client. It is probably incomplete, and will grow over time.
12:  */
13: public interface DeliveryUseCases {
14:     /**
15:      * Delivers a thing to a client. The thing is identified by its id, and the client by
16:      * his/her name, street, city and zip code.
17:      * @param deliveryRecipient
18:      * @param deliveryContent - a map of thing ids and quantities
19:      * @return the id of the delivery, if successfully triggered
20:      * @throws ShopException if ...
21:      *      - deliveryRecipient is null
22:      *      - any of the properties in deliveryRecipient (the getXxx(...) methods) return null or empty strings
23:      *      - deliveryContent is null or empty
24:      *      - the total number of things in the delivery is > 20
25:      */
26:     public UUID triggerDelivery( ClientType deliveryRecipient, Map<UUID, Integer> deliveryContent );
27: 
28: 
29:     /**
30:      * Returns a map showing which things have been delivered to a client, and how many of each thing
31:      *
32:      * @param clientMailAddress
33:      * @return the delivery history of the client (map is empty if the client has not had any deliveries yet)
34:      * @throws ShopException if
35:      *      - mailAddress is null
36:      *      - the client with the given mail address does not exist
37:      */
38:     public Map<UUID, Integer> getDeliveryHistory( MailAddressType clientMailAddress );
39: 
40: 
41: 
42:     /**
43:      *  Deletes all delivery history.
44:      */
45:     public void deleteDeliveryHistory();
46: }
47: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\HomeAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface HomeAddressType {
6:     /**
7:      * @return the street as a string
8:      */
9:     public String getStreet();
10: 
11:     /**
12:      * @return the city as a string
13:      */
14:     public String getCity();
15: 
16:     /**
17:      * @return the zip code
18:      */
19:     public ZipCodeType getZipCode();
20: 
21:     /**
22:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
23:      * implementing class to provide a static factory method (simply named "of(...)"),
24:      * which creates an zip code, given as a string.
25:      * We specify this factory method here as a comment, using the Javadoc documentation style.
26:      *
27:      * @param street the street as a string
28:      * @param city the city as a string
29:      * @param zipCode the zip code
30:      * @return the homeAddress object matching the parameters
31:      * @throws ShopException if ...
32:      *      - street is null or empty
33:      *      - city is null or empty
34:      *      - zipCode is null
35:      */
36:      // public static HomeAddressType of( String street, String city, ZipCodeType zipCode );
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MailAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface MailAddressType {
6:     /**
7:      * @return the mail address as a string
8:      */
9:     public String toString();
10: 
11:     /**
12:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
13:      * implementing class to provide a static factory method (simply named "of(...)"),
14:      * which creates an mail address, given as a string.
15:      * We specify this factory method here as a comment, using the Javadoc documentation style.
16:      *
17:      * @param mailAddressAsString - the mail address as a string.
18:      *      We will use a much simplified validation method to check if the mail address is valid:
19:      *      - it must contain exactly one '@' character.
20:      *      - the part before the '@' and the part after the '@' must not be empty, contain of
21:      *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
22:      *      - the parts before and after the '@' may contain one or several '.' as separators
23:      *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
24:      *      - the part after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
25:      *        (for simplicity we do not allow any other domains)
26:      * @return a new MailAddressType object matching the given mail address
27:      * @throws ShopException if ...
28:      *      - mailAddressAsString is null
29:      *      - mailAddressAsString is not a valid mail address (see above)
30:      */
31:      // public static MailAddressType of( String mailAddressAsString );
32: }
33: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MoneyType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface MoneyType {
6:     /**
7:      * @return the amount of money
8:      */
9:     public Float getAmount();
10: 
11: 
12:     /**
13:      * @return the currency of the money
14:      */
15:     public String getCurrency();
16: 
17: 
18:     /**
19:      * @param otherMoney
20:      * @return this + otherMoney, as a new object
21:      * @throws ShopException if ...
22:      *      - otherMoney is null
23:      *      - otherMoney.currency != this.currency
24:      */
25:     public MoneyType add( MoneyType otherMoney );
26: 
27: 
28:     /**
29:      * @param otherMoney
30:      * @return this - otherMoney, as a new object
31:      * @throws ShopException if ...
32:      *      - otherMoney is null
33:      *      - otherMoney.currency != this.currency
34:      *      - otherMoney > this
35:      */
36:     public MoneyType subtract( MoneyType otherMoney );
37: 
38: 
39:     /**
40:      * @param factor
41:      * @return this * factor, as a new object
42:      * @throws ShopException if ...
43:      *     - factor < 0
44:      */
45:     public MoneyType multiplyBy( int factor );
46: 
47:     /**
48:      * @param otherMoney
49:      * @return true, if this > otherMoney
50:      * @throws ShopException if ...
51:      *      - otherMoney is null
52:      *      - otherMoney.currency != this.currency
53:      */
54:     public boolean largerThan( MoneyType otherMoney );
55: 
56: 
57:     /**
58:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
59:      * implementing class to provide a static factory method (simply named "of(...)"),
60:      * which creates a money object from an amount and a currency (as string).
61:      * We specify this factory method here as a comment, using the Javadoc documentation style.
62:      *
63:      * @param amount the amount of money (must be >= 0)
64:      * @param currency the currency of the money (allowed values: "EUR", "CHF")
65:      * @return a new Money object with the given amount and currency
66:      * @throws ShopException if ...
67:      *   - amount is null
68:      *   - amount < 0
69:      *   - currency is null
70:      *   - currency is not one of the allowed values
71:      */
72:      // public static MoneyType of( Float amount, String currency );
73: }
74: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\ZipCodeType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface ZipCodeType {
6:     /**
7:      * @return the zip code as a string
8:      */
9:     public String toString();
10: 
11:     /**
12:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
13:      * implementing class to provide a static factory method (simply named "of(...)"),
14:      * which creates an zip code, given as a string.
15:      * We specify this factory method here as a comment, using the Javadoc documentation style.
16:      *
17:      * @param zipCodeAsString - the zip code as a string.
18:      *      We will use a much simplified validation method to check if the postal code is valid:
19:      *      - It must contain exactly 5 digits.
20:      *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid postal code, but 20001 is valid)
21:      * @return a new zip code object matching the given string
22:      * @throws ShopException if ...
23:      *      - zipCodeAsString is null
24:      *      - zipCodeAsString is not a valid zip code (see above)
25:      */
26:      // public static ZipCodeType of( String zipCodeAsString );
27: }
28: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\usecases\PaymentUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import java.util.UUID;
8: 
9: /**
10:  * This interface contains methods needed in the context of use cases dealing with payments.
11:  */
12: public interface PaymentUseCases {
13: 
14:     /**
15:      * Authorizes a payment from a credit card for a given amount
16:      *
17:      * @param clientMailAddress
18:      * @param moneyAmount
19:      * @return the id of the payment, if successfully authorized
20:      * @throws ShopException if ...
21:      *      - clientMailAddress is null
22:      *      - the amount is null
23:      *      - the amount is 0.00 EUR
24:      *      - the payment cannot be processed, because it is over the limit of 500.00 EUR
25:      */
26:     public UUID authorizePayment( MailAddressType clientMailAddress, MoneyType moneyAmount );
27: 
28: 
29:     /**
30:      * Returns the total amount of payments (over the complete history) for a client
31:      * (identified by his/her mail address)
32:      *
33:      * @param clientMailAddress
34:      * @return the total amount of payments made using this credit card, or 0.00 EUR if there
35:      *         weren't any payments yet.
36:      * @throws ShopException if ...
37:      *      - clientMailAddress is null
38:      */
39:     public MoneyType getPaymentTotal( MailAddressType clientMailAddress );
40: 
41: 
42:     /**
43:      * Deletes all payment history, for all clients.
44:      */
45:     public void deletePaymentHistory();
46: }
47: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingCartUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import java.util.Map;
8: import java.util.UUID;
9: 
10: /**
11:  * This interface contains methods needed in the context of use cases dealing with the shopping cart.
12:  * The interface is probably incomplete, and will grow over time.
13:  */
14: public interface ShoppingCartUseCases {
15:     /**
16:      * Adds a thing to the shopping cart of a client
17:      *
18:      * @param clientMailAddress
19:      * @param thingId
20:      * @param quantity
21:      * @throws ShopException if ...
22:      *      - the client with the given mailAddress does not exist,
23:      *      - the thing does not exist,
24:      *      - the quantity <= 0,
25:      *      - the thing is not available in the requested quantity
26:      */
27:     public void addThingToShoppingCart( MailAddressType clientMailAddress, UUID thingId, int quantity );
28: 
29: 
30:     /**
31:      * Removes a thing from the shopping cart of a client
32:      *
33:      * @param clientMailAddress
34:      * @param thingId
35:      * @param quantity
36:      * @throws ShopException if ...
37:      *      - clientMailAddress is null,
38:      *      - the client with the given mailAddress does not exist,
39:      *      - the thing does not exist
40:      *      - the quantity <= 0,
41:      *      - the thing is not in the shopping cart in the requested quantity
42:      */
43:     public void removeThingFromShoppingCart( MailAddressType clientMailAddress, UUID thingId, int quantity );
44: 
45: 
46:     /**
47:      * Sets a comment in the shopping cart part containing a thing
48:      *
49:      * @param clientMailAddress
50:      * @param thingId
51:      * @param comment (can be null)
52:      * @throws ShopException if ...
53:      *      - clientMailAddress is null,
54:      *      - the client with the given mailAddress does not exist,
55:      *      - the thing does not exist
56:      *      - the thing is not in the shopping cart
57:      */
58:     public void setCommentForShoppingCartPart( MailAddressType clientMailAddress, UUID thingId, String comment );
59: 
60: 
61:     /**
62:      * Returns the comment in the shopping cart part containing a thing
63:      *
64:      * @param clientMailAddress
65:      * @param thingId
66:      * @return the comment (can be null)
67:      * @throws ShopException if ...
68:      *      - clientMailAddress is null,
69:      *      - the client with the given mailAddress does not exist,
70:      *      - the thing does not exist
71:      *      - the thing is not in the shopping cart
72:      */
73:     public String getCommentForShoppingCartPart( MailAddressType clientMailAddress, UUID thingId );
74: 
75: 
76:     /**
77:      * Returns a map showing which things are in the shopping cart of a client and how many of each thing
78:      *
79:      * @param clientMailAddress
80:      * @return the shopping cart of the client (map is empty if the shopping cart is empty)
81:      * @throws ShopException if ...
82:      *      - clientMailAddress is null,
83:      *      - the client with the given mailAddress does not exist
84:      */
85:     public Map<UUID, Integer> getShoppingCartAsMap( MailAddressType clientMailAddress );
86: 
87: 
88:     /**
89:      * Returns the current value of all things in the shopping cart of a client
90:      *
91:      * @param clientMailAddress
92:      * @return the value of shopping cart of the client
93:      * @throws ShopException if ...
94:      *      - clientMailAddress is null,
95:      *      - the client with the given mailAddress does not exist
96:      */
97:     public MoneyType getShoppingCartAsMoneyValue( MailAddressType clientMailAddress );
98: 
99: 
100: 
101:     /**
102:      * Get the number units of a specific thing that are currently reserved in the shopping carts of all clients
103:      * @param thingId
104:      * @return the number of reserved things of that type in all shopping carts
105:      * @throws ShopException
106:      *      - thingId is null
107:      *      - if the thing id does not exist
108:      */
109:     public int getReservedStockInShoppingCarts( UUID thingId );
110: 
111: 
112:     /**
113:      * Checks if the shopping cart of a client is empty
114:      *
115:      * @param clientMailAddress
116:      * @return true if the shopping cart is empty, false otherwise
117:      * @throws ShopException if ...
118:      *    - clientMailAddress is null
119:      *    - the client with the given mail address does not exist
120:      */
121:     public boolean isEmpty( MailAddressType clientMailAddress );
122: 
123: 
124:     /**
125:      * Checks if the payment for a specific shopping cart of a client has been authorized to be paid,
126:      * i.e. the shopping cart is not empty, the client has given his/her payment details, and the payment
127:      * has been authorized (under the limits of the client's credit card). However, the order
128:      * has not yet been placed yet, and the logistics details have not yet been given.
129:      *
130:      * @param clientMailAddress
131:      * @return true if the payment has been authorized, false otherwise
132:      * @throws ShopException if ...
133:      *      - clientMailAddress is null
134:      *      - the client with the given mail address does not exist
135:      */
136:     public boolean isPaymentAuthorized( MailAddressType clientMailAddress );
137: 
138: 
139:     /**
140:      * Checks out the shopping cart of a client
141:      *
142:      * @param clientMailAddress
143:      * @throws ShopException if ... 
144:      * @throws ShopException if ...
145:      *      - clientMailAddress is null
146:      *      - the client with the given mail address does not exist
147:      *      - the shopping cart is empty
148:      */
149:     public void checkout( MailAddressType clientMailAddress );
150: 
151: 
152: 
153: 
154:     /**
155:      * Returns a map showing which things have been ordered by a client, and how many of each thing
156:      *
157:      * @param clientMailAddress
158:      * @return the order history of the client (map is empty if the client has not ordered anything yet)
159:      * @Deprecated Might be split into a dedicated OrderUseCases interface later (but still valid in this milestone)
160:      * @throws ShopException if
161:      *      - the mail address is null
162:      *      - the client with the given mail address does not exist
163:      */
164:     public Map<UUID, Integer> getOrderHistory( MailAddressType clientMailAddress );
165: 
166: 
167: 
168:     /**
169:      * Deletes all orders and shopping carts in the system
170:      * @Deprecated Might be split into two methods later (delete orders and delete shopping carts), with
171:      *             the order deletion moved to a dedicated OrderUseCases interface later
172:      *             (but still valid in this milestone)
173:      */
174:     public void deleteAllOrders();
175: }
176: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\usecases\StockManagementUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: import java.util.UUID;
6: 
7: 
8: /**
9:  * This interface contains methods needed in the context of use cases dealing with managing the shop stock,
10:  * i.e. adding and removing things in the warehouse. The interface is probably incomplete, and
11:  * will grow over time.
12:  */
13: public interface StockManagementUseCases {
14:     /**
15:      * Adds a certain quantity of a given thing to the stock
16:      * @param thingId
17:      * @param addedQuantity
18:      * @throws ShopException if ...
19:      *      - thingId is null
20:      *      - the thing with that id does not exist
21:      *      - addedQuantity <= 0
22:      */
23:     public void addToStock( UUID thingId, int addedQuantity );
24: 
25: 
26:     /**
27:      * Removes a certain quantity of a given thing from the stock.
28:      * If the new total quantity is lower than the currently reserved things, some of currently reserved things
29:      * (in the clients' shopping baskets) are removed. This means that some of the reserved things are lost for
30:      * the client. (This is necessary because there probably was a mistake in the stock management, a mis-counting,
31:      * or some of the things were stolen from the warehouse, are broken, etc.)
32:      * @param thingId
33:      * @param removedQuantity
34:      * @throws ShopException if ...
35:      *      - thingId is null
36:      *      - the thing with that id does not exist
37:      *      - removedQuantity <= 0
38:      *      - the removed quantity is greater than the current stock and the currently reserved things together
39:      */
40:     public void removeFromStock( UUID thingId, int removedQuantity );
41: 
42: 
43:     /**
44:      * Changes the total quantity of a given thing in the stock.
45:      * If the new total quantity is lower than the currently reserved things, some of currently reserved things
46:      * (in the clients' shopping baskets) are removed. This means that some of the reserved things are lost for
47:      * the client. (This is necessary because there probably was a mistake in the stock management, a mis-counting,
48:      * or some of the things were stolen from the warehouse, are broken, etc.)
49:      * @param thingId
50:      * @param newTotalQuantity
51:      * @throws ShopException if ...
52:      *      - thingId is null
53:      *      - the thing with that id does not exist
54:      *      - newTotalQuantity < 0
55:      */
56:     public void changeStockTo( UUID thingId, int newTotalQuantity );
57: 
58: 
59:     /**
60:      * Get the current total stock of a given thing, including the currently reserved things
61:      * @param thingId
62:      * @return the current total stock of the thing
63:      * @throws ShopException if ...
64:      *      - thingId is null
65:      *      - the thing with that id does not exist
66:      */
67:     public int getAvailableStock( UUID thingId );
68: }
69: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\usecases\ThingCatalogUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
5: 
6: import java.util.UUID;
7: 
8: 
9: /**
10:  * This interface contains methods needed in the context of use cases dealing with managing the thing catalog.
11:  * The interface is probably incomplete, and will grow over time.
12:  */
13: 
14: public interface ThingCatalogUseCases {
15:     /**
16:      * Adds a new thing to the shop catalog
17:      * @param thingId
18:      * @param name
19:      * @param description
20:      * @param size
21:      * @param purchasePrice
22:      * @param sellingPrice
23:      * @throws ShopException if ...
24:      *      - thingId is null,
25:      *      - the thing with that id already exists,
26:      *      - name or description are null or empty,
27:      *      - the size is <= 0 (but can be null!),
28:      *      - the purchase price is null,
29:      *      - the selling price is null,
30:      *      - the selling price is lower than the purchase price
31:      */
32:     public void addThingToCatalog( UUID thingId, String name, String description, Float size,
33:                                            MoneyType purchasePrice, MoneyType sellingPrice );
34: 
35: 
36:     /**
37:      * Removes a thing from the shop catalog
38:      * @param thingId
39:      * @throws ShopException if
40:      *      - thingId is null,
41:      *      - the thing with that id does not exist
42:      *      - the thing is still in stock
43:      *      - the thing is still reserved in a shopping cart, or part of a completed order
44:      */
45:     public void removeThingFromCatalog( UUID thingId );
46: 
47: 
48:     /**
49:      * Get the selling price of a given thing
50:      * @param thingId
51:      * @return the selling price
52:      * @throws ShopException if ...
53:      *      - thingId is null,
54:      *      - the thing with that id does not exist
55:      */
56:     public MoneyType getSellingPrice( UUID thingId );
57: 
58: 
59:     /**
60:      * Clears the thing catalog, i.e. removes all things from the catalog, including all the stock,
61:      * all the reservations and all the orders.
62:      */
63:     public void deleteThingCatalog();
64: 
65: }
66: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\codereview\E3DDDOutsideSolutionRulesTest.java ---
1: package thkoeln.archilab.ecommerce.codereview;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.library.Architectures.layeredArchitecture;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln")
12: @SuppressWarnings("PMD")
13: public class E3DDDOutsideSolutionRulesTest {
14: 
15:     @ArchTest
16:     static final ArchRule noClassesOutsideSolutionAndDomainprimitives =
17:             layeredArchitecture()
18:                     .consideringAllDependencies()
19:                     .layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
20:                     .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
21:                     .layer( "Test1" ).definedBy( "thkoeln.archilab.ecommerce.codereview.." )
22:                     .layer( "Test2" ).definedBy( "thkoeln.archilab.ecommerce.e1e2resttests.." )
23:                     .layer( "Test3" ).definedBy( "thkoeln.archilab.ecommerce.regression.." )
24: 
25:                     .whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers( "SolutionClasses", "Test1", "Test2", "Test3" )
26:                     .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Test1", "Test2", "Test3" );
27: }
28: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\codereview\E3DDDRulesTest.java ---
1: package thkoeln.archilab.ecommerce.codereview;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: import org.springframework.data.repository.CrudRepository;
8: import org.springframework.stereotype.Service;
9: 
10: import javax.persistence.Entity;
11: import javax.persistence.Id;
12: 
13: import java.util.UUID;
14: 
15: import static com.tngtech.archunit.core.domain.JavaMember.Predicates.declaredIn;
16: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.*;
17: 
18: @ArchTag("layerRules")
19: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
20: @SuppressWarnings("PMD")
21: public class E3DDDRulesTest {
22: 
23:     @ArchTest
24:     static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
25:             noClasses().that().resideInAPackage("..domain..")
26:                     .should().dependOnClassesThat().resideInAPackage("..application..");
27: 
28:     @ArchTest
29:     static final ArchRule entitiesMustResideInADomainPackage =
30:             classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage("..domain..")
31:                     .as("Entities must reside in a package '..domain..'");
32: 
33:     @ArchTest
34:     static final ArchRule entitiesMustNotAccessRepositories =
35:             noClasses().that().areAnnotatedWith( Entity.class )
36:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class );
37: 
38:     @ArchTest
39:     static final ArchRule repositoriesMustResideInADomainPackage =
40:             classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage("..domain..")
41:                     .as("Repositories must reside in a package '..domain..'");
42: 
43:     @ArchTest
44:     static final ArchRule repositoryNamesMustHaveProperSuffix =
45:             classes().that().areAssignableTo( CrudRepository.class )
46:                     .should().haveSimpleNameEndingWith("Repository");
47: 
48:     @ArchTest
49:     static final ArchRule servicesMustResideInAnApplicationPackage =
50:             classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage("..application..")
51:                     .as("Application Services must reside in a package '..application..'");
52: 
53:     @ArchTest
54:     static final ArchRule serviceNamesMustHaveProperSuffix =
55:             classes().that().areAnnotatedWith( Service.class )
56:                     .should().haveSimpleNameEndingWith("Service");
57: 
58:     @ArchTest
59:     static final ArchRule noClassesOnTopLevel =
60:             classes().should().resideInAPackage( "..solution.*.." );
61: 
62:     @ArchTest
63:     static final ArchRule noNonIdFieldsOfTypeIUUID =
64:             fields()
65:                     .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
66:                     .and().areNotAnnotatedWith( Id.class )
67:                     .and().areDeclaredInClassesThat().doNotHaveSimpleName( "Thing" )
68:                     .should().notHaveRawType( UUID.class );
69: }
70: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\codereview\E3NoCycleTest.java ---
1: package thkoeln.archilab.ecommerce.codereview;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.importer.ClassFileImporter;
6: import com.tngtech.archunit.lang.ArchRule;
7: import com.tngtech.archunit.library.dependencies.SliceAssignment;
8: import com.tngtech.archunit.library.dependencies.SliceIdentifier;
9: import org.junit.jupiter.api.Test;
10: 
11: import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
12: 
13: public class E3NoCycleTest {
14:     private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");
15: 
16:     private SliceAssignment inAllClasses() {
17:         return new SliceAssignment() {
18:             @Override
19:             public String getDescription() {
20:                 return "every class in it's own slice";
21:             }
22: 
23:             @Override
24:             public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
25:                 return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
26:             }
27:         };
28:     }
29: 
30:     @Test
31:     public void testNoCyclicDependenciesBetweenClasses() {
32:         slices().assignedFrom(inAllClasses())
33:                 .namingSlices("$1[$2.$3]")
34:                 .should().beFreeOfCycles()
35:                 .check(importedClasses);
36:     }
37: 
38:     @Test
39:     public void testNoCyclicDependenciesBetweenPackages() {
40:         ArchRule rule = slices().matching("..solution.(*)..").should().beFreeOfCycles();
41:         rule.check(importedClasses);
42:     }
43: }
44: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\codereview\E3PackageStructureTest.java ---
1: package thkoeln.archilab.ecommerce.codereview;
2: 
3: import com.tngtech.archunit.core.domain.JavaClasses;
4: import com.tngtech.archunit.core.importer.ClassFileImporter;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: 
8: import static org.assertj.core.api.Assertions.assertThat;
9: import static org.junit.jupiter.api.Assertions.assertTrue;
10: 
11: public class E3PackageStructureTest {
12: 
13:     private static final String[] REQUIRED_PACKAGES = {"client", "shoppingcart", "thing", "order"};
14:     private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
15:     private JavaClasses importedClasses;
16: 
17: 
18:     @BeforeEach
19:     public void setUp() {
20:         importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
21:     }
22: 
23:     @Test
24:     void testRequiredPackagesAreThere() {
25:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
26:             String packageName = BASE_PACKAGE + "." + requiredPackage;
27:             assertThat( importedClasses.containPackage( packageName ) )
28:                     .as( "Expected package %s not found!", packageName )
29:                     .isTrue();
30:         }
31:     }
32: 
33:     @Test
34:     void testRequiredDomainPackagesAreThere() {
35:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
36:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
37:             assertThat( importedClasses.containPackage( packageName ) )
38:                     .as( "Expected domain sub-package %s not found!", packageName )
39:                     .isTrue();
40:         }
41:     }
42: 
43:     @Test
44:     void testRequiredApplicationPackagesAreThere() {
45:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
46:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
47:             assertThat( importedClasses.containPackage( packageName ) )
48:                     .as( "Expected application sub-package %s not found!", packageName )
49:                     .isTrue();
50:         }
51:     }
52: 
53: }
54: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\codereview\E3RequiredClassesTest.java ---
1: package thkoeln.archilab.ecommerce.codereview;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
5: import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
6: import org.springframework.core.type.classreading.MetadataReader;
7: import org.springframework.core.type.classreading.MetadataReaderFactory;
8: 
9: import java.io.IOException;
10: import java.util.Arrays;
11: import java.util.HashSet;
12: import java.util.Set;
13: 
14: import static org.junit.jupiter.api.Assertions.assertTrue;
15: 
16: public class E3RequiredClassesTest {
17: 
18: 
19:     private static final String[] REQUIRED_CLASSES = {
20:             "Client",
21:             "ClientRepository",
22:             "Order",
23:             "OrderRepository",
24:             "ShoppingCart",
25:             "ShoppingCartRepository",
26:             "Thing",
27:             "ThingRepository"
28:     };
29: 
30:     @Test
31:     public void testRequiredClassesDeclared() throws IOException {
32:         String basePackage = "thkoeln.archilab.ecommerce";
33:         String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";
34: 
35:         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
36:         MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );
37: 
38:         Set<String> foundClasses = new HashSet<>();
39: 
40:         Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
41:             try {
42:                 MetadataReader reader = readerFactory.getMetadataReader( resource );
43:                 foundClasses.add( reader.getClassMetadata().getClassName() );
44:             } catch (IOException e) {
45:                 e.printStackTrace();
46:             }
47:         } );
48: 
49:         Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
50:             boolean found = foundClasses.stream().anyMatch(className ->
51:                     className.startsWith(basePackage) && className.endsWith("." + requiredClass)
52:             );
53:             assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
54:         });
55:     }
56: }
57: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\E1OrdertRESTTest.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import org.springframework.test.context.ActiveProfiles;
9: import org.springframework.test.web.servlet.MockMvc;
10: import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
13: 
14: import javax.transaction.Transactional;
15: import java.util.UUID;
16: 
17: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
18: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
19: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
20: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
21: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.instantiateMailAddress;
22: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.THING_DATA;
23: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.CLIENT_EMAIL;
24: 
25: @SpringBootTest
26: @Transactional
27: @AutoConfigureMockMvc
28: @ActiveProfiles("test")
29: public class E1OrdertRESTTest {
30: 
31:     @Autowired
32:     private InitialMasterDataCreator initialMasterDataCreator;
33:     @Autowired
34:     private MockMvc mockMvc;
35: 
36:     private RESTHelper restHelper;
37:     private MailAddressType nonExistingMailAddress;
38: 
39: 
40:     @BeforeEach
41:     public void setUp() {
42:         initialMasterDataCreator.deleteAll();
43: 
44:         initialMasterDataCreator.addAllThings();
45:         initialMasterDataCreator.stockUpAllThings();
46:         initialMasterDataCreator.registerAllClients();
47: 
48:         restHelper = new RESTHelper( mockMvc );
49:         nonExistingMailAddress = instantiateMailAddress( "harry@sally.de" );
50:     }
51: 
52: 
53:     @Test
54:     public void testGetNoOrders() throws Exception {
55:         // given
56:         // when
57:         // then
58:         mockMvc.perform( get( "/orders" ) )
59:                 .andExpect( status().isOk() )
60:                 .andExpect( jsonPath( "$.length()" ).value( 0 ) );
61:         mockMvc.perform( get( "/orders?mailAddress=" + nonExistingMailAddress ) )
62:                 .andExpect( status().isOk() )
63:                 .andExpect( jsonPath( "$.length()" ).value( 0 ) );
64:         mockMvc.perform( get( "/orders?mailAddress=invalidEmailString" ) )
65:                 .andExpect( status().isOk() )
66:                 .andExpect( jsonPath( "$.length()" ).value( 0 ) );
67:         mockMvc.perform( get( "/orders?mailAddress=" + CLIENT_EMAIL[3].toString() ) )
68:                 .andExpect( status().isOk() )
69:                 .andExpect( jsonPath( "$.length()" ).value( 0 ) );
70:     }
71: 
72: 
73:     @Test void testMakeThreeOrders() throws Exception {
74:         // given
75:         String mailAddressString = CLIENT_EMAIL[6].toString();
76: 
77:         UUID thingId2 = (UUID) THING_DATA[2][0];
78:         UUID thingId4 = (UUID) THING_DATA[4][0];
79:         UUID thingId6 = (UUID) THING_DATA[6][0];
80:         Float thingMoneyAmount2 = ((MoneyType) THING_DATA[2][5]).getAmount() * 2;
81:         Float thingMoneyAmount4 = ((MoneyType) THING_DATA[4][5]).getAmount() * 4;
82:         Float thingMoneyAmount6 = ((MoneyType) THING_DATA[6][5]).getAmount() * 6;
83: 
84:         String uriAllOrders = "/orders?mailAddress=" + mailAddressString;
85:         String uriLatestOrder = uriAllOrders + "&filter=latest";
86: 
87:         // when
88:         restHelper.makeOrderForClient( mailAddressString, thingId2, 2 );
89:         restHelper.makeOrderForClient( mailAddressString, thingId4, 4 );
90:         restHelper.makeOrderForClient( mailAddressString, thingId6, 6 );
91: 
92:         // then get all orders ...
93:         mockMvc.perform( get( uriAllOrders ) )
94:                 .andExpect( status().isOk() )
95:                 .andExpect( jsonPath( "$.length()" ).value( 3 ) )
96: 
97:                 .andExpect( jsonPath( "$[0].mailAddress.mailAddressString" ).value( mailAddressString ) )
98:                 .andExpect( jsonPath( "$[0].price.amount" ).value( thingMoneyAmount2 ) )
99: 
100:                 .andExpect( jsonPath( "$[1].mailAddress.mailAddressString" ).value( mailAddressString ) )
101:                 .andExpect( jsonPath( "$[1].price.amount" ).value( thingMoneyAmount4 ) )
102: 
103:                 .andExpect( jsonPath( "$[2].mailAddress.mailAddressString" ).value( mailAddressString ) )
104:                 .andExpect( jsonPath( "$[2].price.amount" ).value( thingMoneyAmount6 ) );
105: 
106:         // ... and the latest order
107:         mockMvc.perform( get( uriLatestOrder ) )
108:                 .andExpect( status().isOk() )
109:                 .andExpect( jsonPath( "$.length()" ).value( 1 ) )
110:                 .andExpect( jsonPath( "$[0].price.amount" ).value( thingMoneyAmount6 ) );
111:     }
112: 
113: 
114:     @Test
115:     public void testIfMoneySumInOrderIsCorrect() throws Exception {
116:         // given
117:         String mailAddressString = CLIENT_EMAIL[3].toString();
118:         UUID thingId3 = (UUID) THING_DATA[3][0];
119:         UUID thingId4 = (UUID) THING_DATA[4][0];
120:         Integer quantity3 = 14;
121:         Integer quantity4 = 5;
122:         Float thingMoneyAmount =
123:                 ((MoneyType) THING_DATA[3][5]).getAmount() * quantity3 +
124:                 ((MoneyType) THING_DATA[4][5]).getAmount() * quantity4;
125: 
126:         // when
127:         UUID shoppingCartId = restHelper.getShoppingCartId( mailAddressString );
128:         restHelper.addThingToShoppingCart( shoppingCartId, thingId3, quantity3 );
129:         restHelper.addThingToShoppingCart( shoppingCartId, thingId4, quantity4 );
130:         mockMvc.perform( put( "/shoppingCarts/" + shoppingCartId.toString() + "/checkout" ) )
131:                 .andExpect( status().isOk() );
132: 
133:         // then
134:         mockMvc.perform( get(
135:                 "/orders?mailAddress=" + mailAddressString + "&filter=latest") )
136:                 .andExpect( status().isOk() )
137:                 .andExpect( jsonPath( "$.length()" ).value( 1 ) )
138:                 .andExpect( jsonPath( "$[0].price.amount" ).value( thingMoneyAmount ) );
139:     }
140: 
141: 
142: 
143: }
144: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\E2ShoppingCartRESTTest.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import org.springframework.test.context.ActiveProfiles;
9: import org.springframework.test.web.servlet.MockMvc;
10: import org.springframework.test.web.servlet.ResultMatcher;
11: import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
13: 
14: import javax.transaction.Transactional;
15: import java.util.UUID;
16: 
17: import static org.springframework.http.MediaType.APPLICATION_JSON;
18: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
19: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
20: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
21: import static thkoeln.archilab.ecommerce.e1e2resttests.RESTHelper.CONFLICT;
22: import static thkoeln.archilab.ecommerce.e1e2resttests.RESTHelper.CREATED;
23: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.instantiateMailAddress;
24: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.THING_DATA;
25: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.CLIENT_EMAIL;
26: 
27: @SpringBootTest
28: @Transactional
29: @AutoConfigureMockMvc
30: @ActiveProfiles("test")
31: public class E2ShoppingCartRESTTest {
32: 
33:     @Autowired
34:     private InitialMasterDataCreator initialMasterDataCreator;
35:     @Autowired
36:     private MockMvc mockMvc;
37: 
38:     private RESTHelper restHelper;
39:     private MailAddressType nonExistingMailAddress;
40: 
41: 
42:     @BeforeEach
43:     public void setUp() {
44:         initialMasterDataCreator.deleteAll();
45: 
46:         initialMasterDataCreator.addAllThings();
47:         initialMasterDataCreator.stockUpAllThings();
48:         initialMasterDataCreator.registerAllClients();
49: 
50:         restHelper = new RESTHelper( mockMvc );
51:         nonExistingMailAddress = instantiateMailAddress( "harry@sally.de" );
52:     }
53: 
54: 
55:     @Test
56:     public void testEmptyShoppingCart() throws Exception {
57:         // given
58:         String validUri = "/shoppingCarts?mailAddress=" + CLIENT_EMAIL[4].toString();
59:         String invalidUri1 = "/shoppingCarts?mailAddress=" + nonExistingMailAddress.toString();
60:         String invalidUri2 = "/shoppingCarts?mailAddress=justaninvalidemailaddress";
61: 
62:         // when
63:         // then
64:         mockMvc.perform( get( validUri ) )
65:                 .andExpect( status().isOk() )
66:                 .andExpect( jsonPath( "$.totalQuantity" ).value( 0 ) );
67:         mockMvc.perform( get( invalidUri1 ) )
68:                 .andExpect( status().isNotFound() );
69:         mockMvc.perform( get( invalidUri2 ) )
70:                 .andExpect( status().isNotFound() );
71:     }
72: 
73: 
74:     @Test
75:     public void testInvalidUris() throws Exception {
76:         // given
77:         UUID thingId = (UUID) THING_DATA[3][0];
78:         String clientEmailString = CLIENT_EMAIL[4].toString();
79:         UUID shoppingCartId = restHelper.getShoppingCartId( clientEmailString );
80: 
81:         String invalidPostUri = "/shoppingCarts/" + UUID.randomUUID() + "/shoppingCartParts";
82:         String invalidPatchGetDeleteUri1 =
83:                 "/shoppingCarts/" + shoppingCartId + "/shoppingCartParts/" + UUID.randomUUID();
84:         String invalidPatchGetDeleteUri2 =
85:                 "/shoppingCarts/" + UUID.randomUUID().toString() + "/shoppingCartParts/" + thingId;
86:         String invalidCheckoutUri1 = "/shoppingCarts/" + shoppingCartId + "/chekkout";
87:         String invalidCheckoutUri2 = "/shoppingCarts/" + UUID.randomUUID() + "/checkout";
88: 
89:         // when
90:         // then
91:         mockMvc.perform( post( invalidPostUri )
92:                 .contentType( APPLICATION_JSON ).content( "[]" ) ).andExpect( status().is4xxClientError() );
93: 
94:         mockMvc.perform( delete( invalidPatchGetDeleteUri1 ) ).andExpect( status().isNotFound() );
95:         mockMvc.perform( get( invalidPatchGetDeleteUri1 ) ).andExpect( status().isNotFound() );
96: 
97:         mockMvc.perform( delete( invalidPatchGetDeleteUri2 ) ).andExpect( status().isNotFound() );
98:         mockMvc.perform( get( invalidPatchGetDeleteUri2 ) ).andExpect( status().isNotFound() );
99: 
100:         mockMvc.perform( put( invalidCheckoutUri1 ) ).andExpect( status().isNotFound() );
101:         mockMvc.perform( put( invalidCheckoutUri2 ) ).andExpect( status().isNotFound() );
102:     }
103: 
104: 
105:     @Test
106:     public void testQueryNonExistingThing() throws Exception {
107:         // given
108:         UUID thingId = (UUID) THING_DATA[3][0];
109:         String clientEmailString = CLIENT_EMAIL[7].toString();
110:         UUID shoppingCartId = restHelper.getShoppingCartId( clientEmailString );
111:         String invalidUri = "/shoppingCarts/" + shoppingCartId + "/shoppingCartParts/" + thingId;
112: 
113:         // when
114:         // then
115:         mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
116:     }
117: 
118: 
119:     @Test
120:     public void testDeleteFromShoppingCart() throws Exception {
121:         // given
122:         UUID thingId1 = (UUID) THING_DATA[1][0];
123:         String clientEmailString9 = CLIENT_EMAIL[9].toString();
124:         String clientEmailString7 = CLIENT_EMAIL[7].toString();
125: 
126:         UUID shoppingCartId9 = restHelper.getShoppingCartId( clientEmailString9 );
127:         UUID shoppingCartId7 = restHelper.getShoppingCartId( clientEmailString7 );
128: 
129:         String baseUri9 = "/shoppingCarts/" + shoppingCartId9 + "/shoppingCartParts/";
130:         String checkoutUri9 = "/shoppingCarts/" + shoppingCartId9 + "/checkout";
131:         String checkoutUri7 = "/shoppingCarts/" + shoppingCartId7 + "/checkout";
132: 
133:         // when
134:         restHelper.addMultipleThingsToShoppingCart( clientEmailString9,
135:                 new Integer[]{1, 4, 6}, new Integer[]{1, 4, 6}, new String[]{"c1", "c4", "c6"} );
136:         restHelper.checkMultipleShoppingCartParts(
137:                 clientEmailString9, new Integer[]{1, 4, 6}, new Integer[]{1, 4, 6},
138:                 new String[]{"c1", "c4", "c6"} );
139:         mockMvc.perform( delete( baseUri9 + thingId1 ) )
140:                 .andExpect( status().isOk() );
141:         restHelper.checkMultipleShoppingCartParts(
142:                 clientEmailString9, new Integer[]{1, 4, 6}, new Integer[]{null, 4, 6},
143:                 new String[]{null, "c4", "c6"}, new Boolean[]{false, true, true} );
144:         // ... and another customer can still buy 10 of the "Nr. 1" thing
145:         restHelper.addThingToShoppingCart( shoppingCartId7, thingId1, 10,
146:                 "still10", null );
147: 
148:         // then
149:         mockMvc.perform( put( checkoutUri9 ) ).andExpect( status().isOk() );
150:         restHelper.checkMultipleOrderPartsInLatestOrder( clientEmailString9,
151:                 new Integer[]{4, 6}, new Integer[]{4, 6}, new String[]{"c4", "c6"} );
152:         mockMvc.perform( put( checkoutUri7 ) ).andExpect( status().isOk() );
153:         restHelper.checkMultipleOrderPartsInLatestOrder( clientEmailString7,
154:                 new Integer[]{1}, new Integer[]{10}, new String[]{"still10"} );
155:     }
156: 
157: 
158:     @Test
159:     public void testAddToAndRemoveFromShoppingCart() throws Exception {
160:         // given
161:         String clientEmailString = CLIENT_EMAIL[2].toString();
162:         UUID shoppingCartId = restHelper.getShoppingCartId( clientEmailString );
163:         String checkoutUri = "/shoppingCarts/" + shoppingCartId + "/checkout";
164: 
165:         // when
166:         restHelper.addMultipleThingsToShoppingCart( clientEmailString,
167:                 new Integer[]{2, 4, 2, 4, 6, 2}, new Integer[]{2, 3, 4, -1, 3, -6},
168:                 new String[]{null, "c4a", "c2a", "c4b", "c6", null} );
169:         restHelper.checkMultipleShoppingCartParts(
170:                 clientEmailString, new Integer[]{2, 4, 6}, new Integer[]{null, 2, 3},
171:                 new String[]{null, "c4b", "c6"}, new Boolean[]{false, true, true} );
172: 
173:         // then
174:         mockMvc.perform( put( checkoutUri ) ).andExpect( status().isOk() );
175:         restHelper.checkMultipleOrderPartsInLatestOrder( clientEmailString,
176:                 new Integer[]{4, 6}, new Integer[]{2, 3}, new String[]{"c4b", "c6"} );
177:     }
178: 
179: 
180:     @Test
181:     public void testRemoveMoreThanThereIsInShoppingCart() throws Exception {
182:         // given
183:         String clientEmailString = CLIENT_EMAIL[2].toString();
184: 
185:         // when
186:         // then
187:         restHelper.addMultipleThingsToShoppingCart( clientEmailString,
188:                 new Integer[]{2, 4, 2}, new Integer[]{2, 3, -3}, new String[]{null, null, null},
189:                 new ResultMatcher[]{CREATED, CREATED, CONFLICT} );
190:     }
191: 
192: 
193:     @Test
194:     public void testAddMoreThanIsInStock() throws Exception {
195:         // given
196:         String clientEmailString = CLIENT_EMAIL[7].toString();
197: 
198:         // when
199:         // then
200:         restHelper.addMultipleThingsToShoppingCart( clientEmailString,
201:                 new Integer[]{1, 1, 1, 1}, new Integer[]{2, 3, 4, 2}, new String[]{null, null, null, null},
202:                 new ResultMatcher[]{CREATED, CREATED, CREATED, CONFLICT} );
203:     }
204: 
205: 
206:     @Test
207:     public void testSuccessfulCheckoutJustWithinPaymentLimit() throws Exception {
208:         // given
209:         String clientEmailString = CLIENT_EMAIL[5].toString();
210:         UUID shoppingCartId = restHelper.getShoppingCartId( clientEmailString );
211:         String checkoutUri = "/shoppingCarts/" + shoppingCartId + "/checkout";
212: 
213:         // when
214:         restHelper.addMultipleThingsToShoppingCart( clientEmailString,
215:                 new Integer[]{11, 13, 10, 6}, new Integer[]{1, 1, 1, 17}, new String[]{"350€", "100€", "35€", "8.50€"} );
216: 
217:         // then
218:         mockMvc.perform( put( checkoutUri ) ).andExpect( status().isOk() );
219:         restHelper.checkMultipleOrderPartsInLatestOrder( clientEmailString,
220:                 new Integer[]{11, 13, 10, 6}, new Integer[]{1, 1, 1, 17}, new String[]{"350€", "100€", "35€", "8.50€"} );
221:     }
222: 
223: 
224: 
225:     @Test
226:     public void testUnsuccessfulCheckoutAbovePaymentLimit() throws Exception {
227:         // given
228:         String clientEmailString = CLIENT_EMAIL[1].toString();
229:         UUID shoppingCartId = restHelper.getShoppingCartId( clientEmailString );
230:         String checkoutUri = "/shoppingCarts/" + shoppingCartId + "/checkout";
231: 
232:         // when
233:         restHelper.addMultipleThingsToShoppingCart( clientEmailString,
234:                 new Integer[]{13, 10}, new Integer[]{4, 3}, new String[]{"400€", "105€"} );
235: 
236:         // then
237:         mockMvc.perform( put( checkoutUri ) ).andExpect( status().isConflict() );
238:     }
239: 
240: 
241:     @Test
242:     public void testUnsuccessfulCheckoutAboveDeliveryLimit() throws Exception {
243:         // given
244:         String clientEmailString = CLIENT_EMAIL[8].toString();
245:         UUID shoppingCartId = restHelper.getShoppingCartId( clientEmailString );
246:         String checkoutUri = "/shoppingCarts/" + shoppingCartId + "/checkout";
247: 
248:         // when
249:         restHelper.addMultipleThingsToShoppingCart( clientEmailString,
250:                 new Integer[]{13, 6}, new Integer[]{3, 18}, new String[]{"300€", "9€"} );
251: 
252:         // then
253:         mockMvc.perform( put( checkoutUri ) ).andExpect( status().isConflict() );
254:     }
255: 
256: 
257:     @Test
258:     public void testNoCheckoutForEmptyShoppingCart() throws Exception {
259:         // given
260:         String clientEmailString = CLIENT_EMAIL[9].toString();
261:         UUID shoppingCartId = restHelper.getShoppingCartId( clientEmailString );
262:         String checkoutUri = "/shoppingCarts/" + shoppingCartId + "/checkout";
263: 
264:         // when
265:         // then
266:         mockMvc.perform( put( checkoutUri ) ).andExpect( status().isConflict() );
267:     }
268: }
269: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\RESTHelper.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests;
2: 
3: import com.fasterxml.jackson.databind.ObjectMapper;
4: import org.springframework.test.web.servlet.MockMvc;
5: import org.springframework.test.web.servlet.MvcResult;
6: import org.springframework.test.web.servlet.ResultActions;
7: import org.springframework.test.web.servlet.ResultMatcher;
8: import thkoeln.archilab.ecommerce.e1e2resttests.testdtos.IdDTO;
9: import thkoeln.archilab.ecommerce.e1e2resttests.testdtos.QuantityAndCommentDTO;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
11: 
12: import java.util.HashMap;
13: import java.util.Map;
14: import java.util.UUID;
15: 
16: import static org.springframework.http.MediaType.APPLICATION_JSON;
17: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
18: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
19: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
20: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.THING_DATA;
21: 
22: public class RESTHelper {
23:     private MockMvc mockMvc;
24: 
25:     public static final ResultMatcher NOT_FOUND = status().isNotFound();
26:     public static final ResultMatcher OK = status().isOk();
27:     public static final ResultMatcher CREATED = status().isCreated();
28:     public static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
29:     public static final ResultMatcher CONFLICT = status().isConflict();
30: 
31:     public RESTHelper( MockMvc mockMvc ) {
32:         this.mockMvc = mockMvc;
33:     }
34: 
35:     public void makeOrderForClient( String mailAddressString, UUID thingId, Integer quantity ) throws Exception {
36:         UUID shoppingCartId = getShoppingCartId( mailAddressString );
37:         addThingToShoppingCart( shoppingCartId, thingId, quantity );
38:         mockMvc.perform( put( "/shoppingCarts/" + shoppingCartId.toString() + "/checkout" ) )
39:                 .andExpect( OK );
40:     }
41: 
42:     public UUID getShoppingCartId( String mailAddressString ) throws Exception {
43:         // get the shopping cart and extract its id ...
44:         MvcResult shoppingCart = mockMvc.perform( get( "/shoppingCarts?mailAddress=" + mailAddressString ) )
45:                 .andExpect( OK )
46:                 .andExpect( jsonPath( "$.id" ).isNotEmpty() )
47:                 .andReturn();
48:         ObjectMapper objectMapper = new ObjectMapper();
49:         IdDTO idDTO = objectMapper.readValue( shoppingCart.getResponse().getContentAsString(), IdDTO.class );
50:         return idDTO.getId();
51:     }
52: 
53:     public void addThingToShoppingCart( UUID shoppingCartId, UUID thingId, Integer quantity,
54:                                                  String comment, ResultMatcher expectedStatus )
55:                                                 throws Exception {
56:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
57:         ObjectMapper objectMapper = new ObjectMapper();
58:         QuantityAndCommentDTO dto = new QuantityAndCommentDTO( thingId, quantity, comment );
59:         String quantityJson = objectMapper.writeValueAsString( dto );
60:         mockMvc.perform( post( "/shoppingCarts/" + shoppingCartId + "/shoppingCartParts" )
61:                 .contentType( APPLICATION_JSON ).content( quantityJson ) )
62:                 .andExpect( status );
63:     }
64: 
65: 
66:     public void addThingToShoppingCart( UUID shoppingCartId, UUID thingId, Integer quantity )
67:             throws Exception {
68:         addThingToShoppingCart( shoppingCartId, thingId, quantity, null, null );
69:     }
70: 
71: 
72: 
73:     public void addMultipleThingsToShoppingCart(
74:             String clientEmailString, Integer[] thingIndices, Integer[] quantities, String[] comments,
75:             ResultMatcher[] expectedAddStatuses ) throws Exception {
76:         UUID shoppingCartId = getShoppingCartId( clientEmailString );
77:         String shoppingCartUri = "shoppingCarts?mailAddress=" + clientEmailString;
78:         String baseUri = "/shoppingCarts/" + shoppingCartId + "/shoppingCartParts/";
79: 
80:         // add all the things to the shopping cart ...
81:         Map<Integer, Integer> quantityMap = new HashMap<>();
82:         Map<Integer, String> commentMap = new HashMap<>();
83:         for ( int i = 0; i < thingIndices.length; i++ ) {
84:             UUID thingId = (UUID) THING_DATA[thingIndices[i]][0];
85:             addThingToShoppingCart( shoppingCartId, thingId, quantities[i], comments[i], expectedAddStatuses[i] );
86:             if ( expectedAddStatuses[i] != null || expectedAddStatuses[i] == CREATED || expectedAddStatuses[i] == OK ) {
87:                 quantityMap.put( thingIndices[i],
88:                         quantities[i] + quantityMap.getOrDefault( thingIndices[i], 0 ) );
89:                 commentMap.put( thingIndices[i], comments[i] );
90:             }
91:         }
92:     }
93: 
94: 
95:     public void addMultipleThingsToShoppingCart(
96:             String clientEmailString, Integer[] thingIndices, Integer[] quantities,
97:             String[] comments ) throws Exception {
98:         ResultMatcher[] expectedAddStatuses = new ResultMatcher[thingIndices.length];
99:         for ( int i = 0; i < thingIndices.length; i++ ) {
100:             expectedAddStatuses[i] = CREATED;
101:         }
102:         addMultipleThingsToShoppingCart( clientEmailString, thingIndices, quantities,
103:                 comments, expectedAddStatuses );
104:     }
105: 
106: 
107:     public void checkMultipleShoppingCartParts( String clientEmailString,
108:                                                          Integer[] thingIndices, Integer[] expectedQuantities,
109:                                                          String[] expectedComments, Boolean[] expectedToBeFound ) throws Exception {
110:         UUID shoppingCartId = getShoppingCartId( clientEmailString );
111:         String shoppingCartUri = "/shoppingCarts?mailAddress=" + clientEmailString;
112:         String baseUri = "/shoppingCarts/" + shoppingCartId + "/shoppingCartParts/";
113: 
114:         // check that the shopping cart contains all the things ...
115:         int totalQuantity = 0;
116:         for ( int i = 0; i < thingIndices.length; i++ ) {
117:             if ( expectedQuantities[i] != null ) {
118:                 totalQuantity += expectedQuantities[i];
119:             }
120:         }
121:         mockMvc.perform( get( shoppingCartUri ) )
122:                 .andExpect( OK )
123:                 .andExpect( jsonPath( "$.totalQuantity" ).value( totalQuantity ) );
124: 
125:         // check that each thing has the correct quantity and comment ...
126:         for ( int i = 0; i < thingIndices.length; i++ ) {
127:             UUID thingId = (UUID) THING_DATA[thingIndices[i]][0];
128:             if ( expectedToBeFound[i] ) {
129:                 mockMvc.perform( get( baseUri + thingId ) )
130:                         .andExpect( OK )
131:                         .andExpect( jsonPath( "$.quantity" ).value( expectedQuantities[i] ) )
132:                         .andExpect( jsonPath( "$.comment" ).value( expectedComments[i] ) );
133:             } else {
134:                 mockMvc.perform( get( baseUri + thingId ) )
135:                         .andExpect( NOT_FOUND );
136:             }
137:         }
138:     }
139: 
140: 
141:     public void checkMultipleShoppingCartParts( String clientEmailString,
142:                                                          Integer[] thingIndices, Integer[] expectedQuantities,
143:                                                          String[] expectedComments ) throws Exception {
144:         Boolean[] expectedToBeFound = new Boolean[thingIndices.length];
145:         for ( int i = 0; i < thingIndices.length; i++ ) {
146:             expectedToBeFound[i] = true;
147:         }
148:         checkMultipleShoppingCartParts( clientEmailString, thingIndices, expectedQuantities,
149:                 expectedComments, expectedToBeFound );
150:     }
151: 
152: 
153: 
154:     public void checkMultipleOrderPartsInLatestOrder(
155:             String clientEmailString, Integer[] thingIndices, Integer[] expectedQuantities,
156:             String[] expectedComments ) throws Exception {
157:         String latestOrderUri = "/orders?mailAddress=" + clientEmailString + "&filter=latest";
158: 
159:         // Calculate the total price of the order ...
160:         float totalPrice = 0f;
161:         for ( int i = 0; i < thingIndices.length; i++ ) {
162:             totalPrice += expectedQuantities[i] * ((MoneyType) THING_DATA[thingIndices[i]][5]).getAmount();
163:         }
164: 
165:         // ... and check that the order has the correct total price (and other data)
166:         ResultActions resultActions = mockMvc.perform( get( latestOrderUri ) ).andExpect( OK )
167:                 .andExpect( jsonPath( "$.length()" ).value( 1 ) )
168:                 .andExpect( jsonPath( "$[0].price.amount" ).value( totalPrice ) )
169:                 .andExpect( jsonPath( "$[0].mailAddress.mailAddressString" ).value( clientEmailString ) );
170: 
171:         // Now check that all the expected parts are there
172:         for ( int i = 0; i < thingIndices.length; i++ ) {
173:             UUID thingId = (UUID) THING_DATA[thingIndices[i]][0];
174:             resultActions.andExpect(
175:                     jsonPath( "$[0].orderParts.length()" ).value( thingIndices.length ) );
176:             resultActions.andExpect(
177:                     jsonPath( "$[0].orderParts[?(@.thingId == '" + thingId + "')].quantity" )
178:                             .value( expectedQuantities[i] ) );
179:             if ( expectedComments[i] != null ) {
180:                 resultActions.andExpect(
181:                         jsonPath( "$[0].orderParts[?(@.thingId == '" + thingId + "')].comment" )
182:                                 .value( expectedComments[i] ) );
183:             }
184:         }
185:     }
186: 
187: }
188: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\testdtos\CommentDTO.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests.testdtos;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import lombok.*;
5: 
6: import java.util.UUID;
7: 
8: /**
9:  * A DTO containing just a comment, used in testing.
10:  */
11: 
12: @AllArgsConstructor
13: @NoArgsConstructor
14: @Setter
15: @Getter
16: @ToString
17: @JsonIgnoreProperties(ignoreUnknown = true)
18: public class CommentDTO {
19:     private UUID thingId;
20:     private String comment;
21: }
22: 
23: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\testdtos\IdDTO.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests.testdtos;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import lombok.*;
5: 
6: import java.util.UUID;
7: 
8: /**
9:  * A DTO containing just the id of an entity, used in testing.
10:  */
11: 
12: @AllArgsConstructor
13: @NoArgsConstructor
14: @Setter
15: @Getter
16: @ToString
17: @JsonIgnoreProperties(ignoreUnknown = true)
18: public class IdDTO {
19:     private UUID id;
20: }
21: 
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\testdtos\QuantityAndCommentDTO.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests.testdtos;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import lombok.*;
5: 
6: import java.util.UUID;
7: 
8: /**
9:  * A DTO containing just a quantity, used in testing.
10:  */
11: 
12: 
13: @NoArgsConstructor
14: @Setter
15: @Getter
16: @ToString
17: @JsonIgnoreProperties(ignoreUnknown = true)
18: public class QuantityAndCommentDTO {
19:     private UUID thingId;
20:     private Integer quantity;
21:     private String comment;
22: 
23:     public QuantityAndCommentDTO( UUID thingId, Integer quantity, String comment ) {
24:         this.thingId = thingId;
25:         this.quantity = quantity;
26:         this.comment = comment;
27:     }
28: }
29: 
30: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionHomeAddressTest.java ---
1: package thkoeln.archilab.ecommerce.regression.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;
10: 
11: class RegressionHomeAddressTest {
12: 
13:     @Test
14:     public void testGetterMethods() {
15:         // given
16:         String street = "Irgendeinestraße 42";
17:         String city = "Irgendeinestadt";
18:         ZipCodeType plz = instantiateZipCode( "12345" );
19: 
20:         // when
21:         HomeAddressType instance = instantiateHomeAddress( street, city, plz );
22: 
23:         // then
24:         assertEquals( street, instance.getStreet() );
25:         assertEquals( city, instance.getCity() );
26:         assertEquals( plz, instance.getZipCode() );
27:     }
28: 
29:     @Test
30:     public void testFactoryMethodValid() {
31:         // given
32:         String street = "Irgendeinestraße 42";
33:         String city = "Irgendeinestadt";
34:         ZipCodeType plz = instantiateZipCode( "12345" );
35: 
36:         // when
37:         // then
38:         assertDoesNotThrow( () -> instantiateHomeAddress( street, city, plz ) );
39:     }
40: 
41:     @Test
42:     public void testFactoryMethodInvalid() {
43:         // given
44:         String street = "Irgendeinestraße 42";
45:         String city = "Irgendeinestadt";
46:         ZipCodeType plz = instantiateZipCode( "12345" );
47: 
48:         // when
49:         // then
50:         assertThrows( ShopException.class, () -> instantiateHomeAddress( null, city, plz ) );
51:         assertThrows( ShopException.class, () -> instantiateHomeAddress( "", city, plz ) );
52:         assertThrows( ShopException.class, () -> instantiateHomeAddress( street, null, plz ) );
53:         assertThrows( ShopException.class, () -> instantiateHomeAddress( street, "", plz ) );
54:         assertThrows( ShopException.class, () -> instantiateHomeAddress( street, city, null ) );
55:     }
56: 
57:     @Test
58:     public void testValueObjectEquality() {
59:         // given
60:         String street = "Irgendeinestraße 42";
61:         String city = "Irgendeinestadt";
62:         ZipCodeType plz = instantiateZipCode( "12345" );
63: 
64:         // when
65:         HomeAddressType instance1 = instantiateHomeAddress( street, city, plz );
66:         HomeAddressType instance2 = instantiateHomeAddress( street, city, plz );
67:         HomeAddressType instance3 = instantiateHomeAddress( "Anderestr. 12", city, plz );
68:         HomeAddressType instance4 = instantiateHomeAddress( street, "AndereStadt", plz );
69:         HomeAddressType instance5 = instantiateHomeAddress( street, city, instantiateZipCode( "54321" ) );
70: 
71:         // then
72:         assertEquals( instance1, instance2 );
73:         assertNotEquals( instance1, instance3 );
74:         assertNotEquals( instance1, instance4 );
75:         assertNotEquals( instance1, instance5 );
76:     }
77: 
78:     @Test
79:     public void testImmutability() {
80:         // given
81:         String street = "Irgendeinestraße 42";
82:         String city = "Irgendeinestadt";
83:         ZipCodeType plz = instantiateZipCode( "12345" );
84: 
85:         // when
86:         HomeAddressType instance = instantiateHomeAddress( street, city, plz );
87: 
88:         // then
89:         try {
90:             instance.getClass().getMethod( "setStreet", String.class );
91:             fail( "setStreet method should not exist" );
92:         } catch (NoSuchMethodException e) {
93:             // Success: the object is immutable
94:         }
95:         try {
96:             instance.getClass().getMethod( "setCity", String.class );
97:             fail( "setCity method should not exist" );
98: 
99:         } catch (NoSuchMethodException e) {
100:             // Success: the object is immutable
101:         }
102:         try {
103:             instance.getClass().getMethod( "setZipCode", ZipCodeType.class );
104:             fail( "setZipCode method should not exist" );
105:         } catch (NoSuchMethodException e) {
106:             // Success: the object is immutable
107:         }
108:     }
109: }
110: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionMailAddressTest.java ---
1: package thkoeln.archilab.ecommerce.regression.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;
9: 
10: class RegressionMailAddressTest {
11: 
12:     @Test
13:     public void testToString() {
14:         // given
15:         String input = "test@example.com";
16: 
17:         // when
18:         MailAddressType instance = instantiateMailAddress( input );
19: 
20:         // then
21:         assertEquals( input, instance.toString() );
22:     }
23: 
24:     @Test
25:     public void testFactoryMethodValid() {
26:         // given
27:         // when
28:         // then
29:         assertDoesNotThrow( () -> instantiateMailAddress( "test@example.com" ) );
30:         assertDoesNotThrow( () -> instantiateMailAddress( "99Z@example.com" ) );
31:         assertDoesNotThrow( () -> instantiateMailAddress( "GGGhh@s77.com" ) );
32:         assertDoesNotThrow( () -> instantiateMailAddress( "a@4.com" ) );
33:         assertDoesNotThrow( () -> instantiateMailAddress( "Max.Hammer@example.com" ) );
34:         assertDoesNotThrow( () -> instantiateMailAddress( "Max.Gideon.Hammer@example.com" ) );
35:         assertDoesNotThrow( () -> instantiateMailAddress( "test@example.this.com" ) );
36:         assertDoesNotThrow( () -> instantiateMailAddress( "test@example.de" ) );
37:         assertDoesNotThrow( () -> instantiateMailAddress( "test@example.at" ) );
38:         assertDoesNotThrow( () -> instantiateMailAddress( "test@example.ch" ) );
39:         assertDoesNotThrow( () -> instantiateMailAddress( "test@example.org" ) );
40:     }
41: 
42:     @Test
43:     public void testFactoryMethodInvalid() {
44:         // given
45:         // when
46:         // then
47:         assertThrows( ShopException.class, () -> instantiateMailAddress( null ) );
48:         assertThrows( ShopException.class, () -> instantiateMailAddress( "testexample.com" ) );
49:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@" ) );
50:         assertThrows( ShopException.class, () -> instantiateMailAddress( "@example.com" ) );
51:         assertThrows( ShopException.class, () -> instantiateMailAddress( "Max..Gideon.Hammer@example.com" ) );
52:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@examplecom" ) );
53:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example..com" ) );
54:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example@that.com" ) );
55:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test example@that.com" ) );
56:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test#example@that.com" ) );
57:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.biz" ) );
58:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.biz" ) );
59:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.42" ) );
60:     }
61: 
62:     @Test
63:     public void testValueObjectEquality() {
64:         // given
65:         // when
66:         MailAddressType instance1 = instantiateMailAddress( "test@example.com" );
67:         MailAddressType instance2 = instantiateMailAddress( "test@example.com" );
68:         MailAddressType instance3 = instantiateMailAddress( "different@example.com" );
69: 
70:         // then
71:         assertEquals( instance1, instance2 );
72:         assertNotEquals( instance1, instance3 );
73:     }
74: 
75:     @Test
76:     public void testImmutability() {
77:         // given
78:         // when
79:         MailAddressType instance = instantiateMailAddress( "test@example.com" );
80: 
81:         // then
82:         try {
83:             instance.getClass().getMethod( "setMailAddress", String.class );
84:             fail( "setMailAddress method should not exist" );
85:         } catch (NoSuchMethodException e) {
86:             // Success: the object is immutable
87:         }
88:     }
89: }
90: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionMoneyTest.java ---
1: package thkoeln.archilab.ecommerce.regression.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;
9: 
10: class RegressionMoneyTest {
11: 
12:     @Test
13:     public void testGetAmount() {
14:         // given
15:         Float inputAmount = 10.0f;
16: 
17:         // when
18:         MoneyType instance = instantiateMoney( inputAmount, "EUR" );
19: 
20:         // then
21:         assertEquals( inputAmount, instance.getAmount() );
22:     }
23: 
24:     @Test
25:     public void testGetCurrency() {
26:         // given
27:         String inputCurrency = "EUR";
28: 
29:         // when
30:         MoneyType instance = instantiateMoney( 10.0f, inputCurrency );
31: 
32:         // then
33:         assertEquals( inputCurrency, instance.getCurrency() );
34:     }
35: 
36:     @Test
37:     public void testAddTo() {
38:         // given
39:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
40:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
41:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
42: 
43:         // when
44:         MoneyType result12 = instance1.add( instance2 );
45:         MoneyType result13 = instance1.add( instance3 );
46: 
47:         // then
48:         assertEquals( 30.0f, result12.getAmount() );
49:         assertEquals( "EUR", result12.getCurrency() );
50:         assertEquals( 10.0f, result13.getAmount() );
51:         assertEquals( "EUR", result12.getCurrency() );
52:     }
53: 
54:     @Test
55:     public void testInvalidAddTo() {
56:         // given
57:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
58:         MoneyType instance2 = instantiateMoney( 20.0f, "CHF" );
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
63:     }
64: 
65:     @Test
66:     public void testSubtractFrom() {
67:         // given
68:         MoneyType instance1 = instantiateMoney( 30.0f, "EUR" );
69:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
70:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
71:         MoneyType instance4 = instantiateMoney( 30.0f, "EUR" );
72: 
73:         // when
74:         MoneyType result12 = instance1.subtract( instance2 );
75:         MoneyType result13 = instance1.subtract( instance3 );
76:         MoneyType result14 = instance1.subtract( instance4 );
77: 
78:         // then
79:         assertEquals( 10.0f, result12.getAmount() );
80:         assertEquals( "EUR", result12.getCurrency() );
81:         assertEquals( 30.0f, result13.getAmount() );
82:         assertEquals( "EUR", result13.getCurrency() );
83:         assertEquals( 0.0f, result14.getAmount() );
84:         assertEquals( "EUR", result14.getCurrency() );
85:     }
86: 
87:     @Test
88:     public void testInvalidSubtractFrom() {
89:         // given
90:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
91:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
92:         MoneyType instance3 = instantiateMoney( 5.0f, "CHF" );
93: 
94:         // when
95:         // then
96:         assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
97:         assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
98:     }
99: 
100:     @Test
101:     public void testMultiplyBy() {
102:         // given
103:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
104: 
105:         // when
106:         MoneyType result = instance.multiplyBy( 3 );
107: 
108:         // then
109:         assertEquals( 30.0f, result.getAmount() );
110:         assertEquals( "EUR", result.getCurrency() );
111:     }
112: 
113:     @Test
114:     public void testFactoryMethodValid() {
115:         // given
116:         // when
117:         // then
118:         assertDoesNotThrow( () -> instantiateMoney( 10.0f, "EUR" ) );
119:     }
120: 
121:     @Test
122:     public void testFactoryMethodInvalid() {
123:         // given
124:         // when
125:         // then
126:         assertThrows( ShopException.class, () -> instantiateMoney( -10.0f, "EUR" ) );
127:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, "USD" ) );
128:         assertThrows( ShopException.class, () -> instantiateMoney( null, "EUR" ) );
129:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, null ) );
130:     }
131: 
132:     @Test
133:     public void testLargerThan() {
134:         // given
135:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
136:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
137:         MoneyType instance3 = instantiateMoney( 10.0f, "EUR" );
138:         MoneyType instance4 = instantiateMoney( 10.0f, "CHF" );
139: 
140:         // when
141:         // then
142:         assertTrue( instance2.largerThan( instance1 ) );
143:         assertFalse( instance1.largerThan( instance2 ) );
144:         assertFalse( instance1.largerThan( instance3 ) );
145:         assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
146:     }
147: 
148: 
149:     @Test
150:     public void testValueObjectEquality() {
151:         // given
152:         // when
153:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
154:         MoneyType instance2 = instantiateMoney( 10.0f, "EUR" );
155:         MoneyType instance3 = instantiateMoney( 20.0f, "EUR" );
156: 
157:         // then
158:         assertEquals( instance1, instance2 );
159:         assertNotEquals( instance1, instance3 );
160:     }
161: 
162:     @Test
163:     public void testImmutability() {
164:         // given
165:         // when
166:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
167: 
168:         // then
169:         try {
170:             instance.getClass().getMethod( "setAmount", Float.class );
171:             fail( "setAmount method should not exist" );
172:         } catch (NoSuchMethodException e) {
173:             // Success: the object is immutable
174:         }
175: 
176:         try {
177:             instance.getClass().getMethod( "setCurrency", String.class );
178:             fail( "setCurrency method should not exist" );
179:         } catch (NoSuchMethodException e) {
180:             // Success: the object is immutable
181:         }
182:     }
183: }
184: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionZipCodeTest.java ---
1: package thkoeln.archilab.ecommerce.regression.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;
9: 
10: class RegressionZipCodeTest {
11: 
12:     @Test
13:     public void testToString() {
14:         // given
15:         String input = "12345";
16: 
17:         // when
18:         ZipCodeType instance = instantiateZipCode( input );
19: 
20:         // then
21:         assertEquals( input, instance.toString() );
22:     }
23: 
24:     @Test
25:     public void testFactoryMethodValid() {
26:         // given
27:         // when
28:         // then
29:         assertDoesNotThrow( () -> instantiateZipCode( "12345" ) );
30:     }
31: 
32:     @Test
33:     public void testFactoryMethodInvalid() {
34:         // given
35:         // when
36:         // then
37:         assertThrows( ShopException.class, () -> instantiateZipCode( "123456" ) );
38:         assertThrows( ShopException.class, () -> instantiateZipCode( "1234" ) );
39:         assertThrows( ShopException.class, () -> instantiateZipCode( "20000" ) );
40:         assertThrows( ShopException.class, () -> instantiateZipCode( null ) );
41:     }
42: 
43:     @Test
44:     public void testValueObjectEquality() {
45:         // given
46:         // when
47:         ZipCodeType instance1 = instantiateZipCode( "12345" );
48:         ZipCodeType instance2 = instantiateZipCode( "12345" );
49:         ZipCodeType instance3 = instantiateZipCode( "54321" );
50: 
51:         // then
52:         assertEquals( instance1, instance2 );
53:         assertNotEquals( instance1, instance3 );
54:     }
55: 
56:     @Test
57:     public void testImmutability() {
58:         // given
59:         // when
60:         ZipCodeType instance = instantiateZipCode( "12345" );
61: 
62:         // then
63:         try {
64:             instance.getClass().getMethod( "setzipCode", String.class );
65:             fail( "setzipCode method should not exist" );
66:         } catch (NoSuchMethodException e) {
67:             // Success: the object is immutable
68:         }
69:     }
70: }
71: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\regression\RegressionClientRegistrationTest.java ---
1: package thkoeln.archilab.ecommerce.regression;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
10: import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.ClientType;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
13: 
14: import javax.transaction.Transactional;
15: 
16: import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
17: import static org.junit.jupiter.api.Assertions.assertThrows;
18: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.instantiateMailAddress;
19: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.CLIENT_ADDRESS;
20: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.CLIENT_EMAIL;
21: 
22: @SpringBootTest
23: @Transactional
24: public class RegressionClientRegistrationTest {
25: 
26:     @Autowired
27:     private ClientRegistrationUseCases clientRegistrationUseCases;
28:     @Autowired
29:     private InitialMasterDataCreator initialMasterDataCreator;
30: 
31:     private MailAddressType nonExistingMailAddress;
32: 
33:     @BeforeEach
34:     public void setUp() {
35:         initialMasterDataCreator.deleteAll();
36:         nonExistingMailAddress = instantiateMailAddress( "this@nononono.de" );
37:     }
38: 
39: 
40:     @Test
41:     public void testAllClientsRegistered() {
42:         // given
43:         initialMasterDataCreator.registerAllClients();
44: 
45:         // when
46:         ClientType client3 = clientRegistrationUseCases.getClientData( CLIENT_EMAIL[3] );
47: 
48:         // then
49:         Assertions.assertEquals( initialMasterDataCreator.CLIENT_NAME[3], client3.getName() );
50:         Assertions.assertEquals( CLIENT_EMAIL[3], client3.getMailAddress() );
51:         Assertions.assertEquals( CLIENT_ADDRESS[3], client3.getHomeAddress() );
52:     }
53: 
54: 
55:     @Test
56:     public void testRegisterClientWithDuplicateMailAddress() {
57:         // given
58:         initialMasterDataCreator.registerAllClients();
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class, () ->
63:                 clientRegistrationUseCases.register( "Gandalf The Grey", CLIENT_EMAIL[5],
64:                         CLIENT_ADDRESS[5] ) );
65:     }
66: 
67:     @Test
68:     public void testRegisterClientWithDuplicateNameOrHomeAddress() {
69:         // given
70:         initialMasterDataCreator.registerAllClients();
71:         MailAddressType newMailAddress = instantiateMailAddress( "some@this.de" );
72: 
73:         // when
74:         // then
75:         assertDoesNotThrow(() ->
76:                 clientRegistrationUseCases.register( initialMasterDataCreator.CLIENT_NAME[2], newMailAddress,
77:                         CLIENT_ADDRESS[2] ) );
78:     }
79: 
80: 
81:     @Test
82:     public void testDeleteClientsNoMoreClients() {
83:         // given
84:         initialMasterDataCreator.registerAllClients();
85: 
86:         // when
87:         clientRegistrationUseCases.deleteAllClients();
88: 
89:         // then
90:         assertThrows( ShopException.class, () -> clientRegistrationUseCases.getClientData( CLIENT_EMAIL[0] ) );
91:     }
92: 
93: }
94: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\regression\RegressionStockManagementTest.java ---
1: package thkoeln.archilab.ecommerce.regression;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
8: import thkoeln.archilab.ecommerce.usecases.StockManagementUseCases;
9: 
10: import javax.transaction.Transactional;
11: import java.util.UUID;
12: 
13: import static org.junit.jupiter.api.Assertions.assertEquals;
14: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.THING_STOCK;
15: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.THING_DATA;
16: 
17: @SpringBootTest
18: @Transactional
19: public class RegressionStockManagementTest {
20: 
21:     @Autowired
22:     private StockManagementUseCases stockManagementUseCases;
23:     @Autowired
24:     private InitialMasterDataCreator initialMasterDataCreator;
25: 
26: 
27:     @BeforeEach
28:     public void setUp() {
29:         initialMasterDataCreator.deleteAll();
30:         initialMasterDataCreator.addAllThings();
31:     }
32: 
33: 
34: 
35:     @Test
36:     public void testAddToStock() {
37:         // given
38:         initialMasterDataCreator.stockUpAllThings();
39:         UUID thingId8 = (UUID) THING_DATA[8][0];
40: 
41:         // when
42:         int stock8before = stockManagementUseCases.getAvailableStock( thingId8 );
43:         assertEquals( THING_STOCK.get( thingId8 ), stock8before );
44:         stockManagementUseCases.addToStock( thingId8, 22 );
45:         int stock8after = stockManagementUseCases.getAvailableStock( thingId8 );
46:         stockManagementUseCases.addToStock( thingId8, 1 );
47:         int stock8after2 = stockManagementUseCases.getAvailableStock( thingId8 );
48: 
49:         // then
50:         assertEquals( stock8before + 22, stock8after );
51:         assertEquals( stock8after + 1, stock8after2 );
52:     }
53: 
54: 
55:     @Test
56:     public void testRemoveFromStock() {
57:         // given
58:         initialMasterDataCreator.stockUpAllThings();
59:         UUID thingId6 = (UUID) THING_DATA[6][0];
60:         int stock6before = THING_STOCK.get( thingId6 );
61:         UUID thingId9 = (UUID) THING_DATA[9][0];
62:         int stock9before = THING_STOCK.get( thingId9 );
63:         UUID thingId1 = (UUID) THING_DATA[1][0];
64:         int stock1before = THING_STOCK.get( thingId1 );
65: 
66:         // when
67:         stockManagementUseCases.removeFromStock( thingId6, 1 );
68:         int stock6after = stockManagementUseCases.getAvailableStock( thingId6 );
69:         stockManagementUseCases.removeFromStock( thingId1, 3 );
70:         int stock1after = stockManagementUseCases.getAvailableStock( thingId1 );
71:         stockManagementUseCases.removeFromStock( thingId9, stock9before );
72:         int stock9after = stockManagementUseCases.getAvailableStock( thingId9 );
73: 
74:         // then
75:         assertEquals( stock6before - 1, stock6after );
76:         assertEquals( stock1before - 3, stock1after );
77:         assertEquals( 0, stock9after );
78:     }
79: 
80: }
81: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\test\java\thkoeln\archilab\ecommerce\regression\RegressionThingCatalogTest.java ---
1: package thkoeln.archilab.ecommerce.regression;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
9: import thkoeln.archilab.ecommerce.usecases.StockManagementUseCases;
10: import thkoeln.archilab.ecommerce.usecases.ThingCatalogUseCases;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
12: 
13: import javax.transaction.Transactional;
14: import java.util.UUID;
15: 
16: import static org.junit.jupiter.api.Assertions.*;
17: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.THING_DATA;
18: 
19: @SpringBootTest
20: @Transactional
21: public class RegressionThingCatalogTest {
22: 
23:     @Autowired
24:     private ThingCatalogUseCases thingCatalogUseCases;
25:     @Autowired
26:     private StockManagementUseCases stockManagementUseCases;
27:     @Autowired
28:     private InitialMasterDataCreator initialMasterDataCreator;
29: 
30:     @BeforeEach
31:     public void setUp() {
32:         initialMasterDataCreator.deleteAll();
33:     }
34: 
35: 
36: 
37:     @Test
38:     public void testAddThingToCatalog() {
39:         // given
40:         initialMasterDataCreator.addAllThings();
41: 
42:         // when
43:         MoneyType sellingPrice = thingCatalogUseCases.getSellingPrice( (UUID) THING_DATA[4][0] );
44: 
45:         // then
46:         assertEquals( THING_DATA[4][5], sellingPrice );
47:     }
48: 
49:     @Test
50:     public void testRemoveThingFromCatalog() {
51:         // given
52:         initialMasterDataCreator.addAllThings();
53:         UUID thingId = (UUID) THING_DATA[4][0];
54: 
55:         // when
56:         assertDoesNotThrow( () -> thingCatalogUseCases.getSellingPrice( thingId ) );
57:         thingCatalogUseCases.removeThingFromCatalog( thingId );
58: 
59:         // then
60:         assertThrows( ShopException.class, () -> thingCatalogUseCases.getSellingPrice( thingId ) );
61:     }
62: 
63: 
64: 
65: 
66:     @Test
67:     public void testRemoveThingThatIsInStock() {
68:         // given
69:         initialMasterDataCreator.addAllThings();
70:         UUID thingId = (UUID) THING_DATA[4][0];
71:         stockManagementUseCases.addToStock( thingId, 3 );
72: 
73:         // when
74:         // then
75:         assertThrows( ShopException.class, () -> thingCatalogUseCases.removeThingFromCatalog( thingId ) );
76:     }
77: 
78: 
79:     @Test
80:     public void testClearThingCatalog() {
81:         // given
82:         initialMasterDataCreator.addAllThings();
83: 
84:         // when
85:         thingCatalogUseCases.deleteThingCatalog();
86: 
87:         // then
88:         assertThrows( ShopException.class, () -> thingCatalogUseCases.getSellingPrice( (UUID) THING_DATA[4][0] ) );
89:     }
90: 
91: }
92: 

[RESPONSE]:
**Review-Zusammenfassung**

---

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\MailAddressPrimitive.java**  
- MailAddressPrimitive.java Zeile 22: Duplication (Original: MailAddressPrimitive.java Zeile 22) : Regex zur Mail-Validierung ist in OrderController.java (Zeile 66) und ShoppingCartController.java (Zeile 130) dupliziert.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\masterdata\FactoryMethodInvoker.java**  
- FactoryMethodInvoker.java Zeilen 23-48: Duplication (Original: FactoryMethodInvoker.java Zeilen 23-48) : Reflektionscode für Factory-Methoden ist in instantiateHomeAddress (Zeilen 51-79), instantiateZipCode (Zeilen 82-107) und instantiateMoney (Zeilen 110-135) nahezu identisch dupliziert.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientRegistrationService.java**  
- ClientRegistrationService.java Zeilen 29-40: Duplication (Original: ClientRegistrationService.java Zeilen 29-40) : Validierungslogik für Client-Daten (Name, Mail, Adresse) ist in DeliveryService.java (Zeilen 29-42) und anderen Services dupliziert.  
- ClientRegistrationService.java Zeilen 50-59: Duplication (Original: ClientRegistrationService.java Zeilen 50-59) : Validierungslogik für Adressänderung ist ähnlich zu register-Methode.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\Client.java**  
- Anemic Entity : Domain Entity enthält nur Getter/Setter und keine Geschäftslogik.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\application\DeliveryService.java**  
- DeliveryService.java Zeilen 29-42: Duplication (Original: ClientRegistrationService.java Zeilen 29-40) : Validierungslogik für Lieferempfänger ist ähnlich zu ClientRegistrationService.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\Delivery.java**  
- Anemic Entity : Domain Entity enthält nur Getter/Setter und keine Geschäftslogik.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderController.java**  
- OrderController.java Zeile 66: Duplication (Original: MailAddressPrimitive.java Zeile 22) : Regex zur Mail-Validierung ist dupliziert.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java**  
- Anemic Entity : Domain Entity enthält nur Getter/Setter und keine Geschäftslogik.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\payment\domain\Payment.java**  
- Anemic Entity : Domain Entity enthält nur Getter/Setter und keine Geschäftslogik.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartController.java**  
- ShoppingCartController.java Zeile 130: Duplication (Original: MailAddressPrimitive.java Zeile 22) : Regex zur Mail-Validierung ist dupliziert.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCart.java**  
- Anemic Entity : Domain Entity enthält nur Getter/Setter und keine Geschäftslogik.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\thing\domain\Thing.java**  
- Anemic Entity : Domain Entity enthält nur Getter/Setter und keine Geschäftslogik.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\solution\warehouse\domain\WareHouse.java**  
- Anemic Entity : Domain Entity enthält nur Getter/Setter und keine Geschäftslogik.

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3794b9ff-0ba3-4617-b77d-7ab0222bfe8e\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\ZipCodeType.java**  
- ZipCodePrimitive.java Zeile 35: Duplication (Original: ZipCodePrimitive.java Zeile 20) : In der equals-Methode wird `obj.toString()` verwendet, aber `zipCode.equals(obj.toString())` vergleicht mit dem falschen Objekt (sollte `zipCode.equals(zipCodeType.toString())` sein). Zudem ist die Logik dupliziert zu anderen Value Objects.

**Anmerkung zu negativen Conditionals:** Einfache Negationen (wie `if (!(...))`) sind vorhanden, aber gemäß Aufgabenstellung akzeptabel, solange sie verständlich sind. Keine auffälligen doppelten Negationen gefunden.

**Anmerkung zu Dead Code:** Die Methode `getThingDataInvalidAtIndex` in `InitialMasterDataCreator` wird in den gegebenen Dateien nicht aufgerufen, könnte aber in Tests verwendet werden. Ohne weiteren Kontext nicht eindeutig als Dead Code klassifizierbar.

**Anmerkung zu Layer Violations:** Keine Verstöße gegen die 4-Layer-Architektur festgestellt.

**Anmerkung zu Shared Persistency:** Keine unerlaubten Zugriffe auf Repositories anderer Bounded Contexts/Packages.

**ENDE**
Generated by deepseek-reasoner
-----------------------------------