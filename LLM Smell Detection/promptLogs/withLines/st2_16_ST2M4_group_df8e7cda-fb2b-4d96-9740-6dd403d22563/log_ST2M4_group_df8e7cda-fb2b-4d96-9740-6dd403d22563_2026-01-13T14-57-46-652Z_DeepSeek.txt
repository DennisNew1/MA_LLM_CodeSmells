--- DATE: 13.1.2026, 15:57:46 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
        Architektur: 4-Layer (Eric Evans).
        Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
        Regeln:
        1. Begründe kurz jeden Fund.
        4. Gruppiere nach Datei (mit Pfad). 
        2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
        3. Keine Code-Wiederholung, nur Referenzen.
        5. Wenn fertig, schreibe "ENDE". 
        6. Nutze die Zeilenangaben die mitgeschickt worden sind.



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ClientNotFoundException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: 
6: @ResponseStatus(HttpStatus.NOT_FOUND)
7: public class ClientNotFoundException extends RuntimeException {
8:     public ClientNotFoundException(String email) {
9:         super("Client not found for email: " + email);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\EmailAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonCreator;
4: import com.fasterxml.jackson.annotation.JsonValue;
5: import jakarta.persistence.Column;
6: import jakarta.persistence.Embeddable;
7: import lombok.AccessLevel;
8: import lombok.NoArgsConstructor;
9: import thkoeln.archilab.ecommerce.ShopException;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
11: 
12: import java.util.Objects;
13: 
14: @Embeddable
15: @NoArgsConstructor(access = AccessLevel.PROTECTED) // Für JPA
16: public class EmailAddress implements EmailAddressType {
17: 
18:     @Column(name = "email_identifier")
19:     private String identifier;
20: 
21:     @Column(name = "email_domain")
22:     private String domain;
23: 
24:     private static final String[] ALLOWED_TLDS = { "de", "at", "ch", "com", "org" };
25: 
26:     public static EmailAddress of(String emailAddressAsString) {
27:         if (emailAddressAsString == null)
28:             throw new ShopException("Email address must not be null");
29: 
30:         if (emailAddressAsString.contains(" "))
31:             throw new ShopException("Email must not contain whitespace");
32: 
33:         if (emailAddressAsString.chars().filter(ch -> ch == '@').count() != 1)
34:             throw new ShopException("Email must contain exactly one '@'");
35: 
36:         String[] parts = emailAddressAsString.split("@");
37:         if (parts.length != 2)
38:             throw new ShopException("Email must contain exactly one '@'");
39: 
40:         String identifier = parts[0];
41:         String domain = parts[1];
42: 
43:         if (identifier.isEmpty() || domain.isEmpty())
44:             throw new ShopException("Identifier and domain must not be empty");
45: 
46:         if (!identifier.matches(".*[A-Za-z0-9].*") || !domain.matches(".*[A-Za-z0-9].*"))
47:             throw new ShopException("Identifier and domain must contain alphanumeric characters");
48: 
49:         if (identifier.contains("..") || domain.contains(".."))
50:             throw new ShopException("Identifier and domain must not contain consecutive dots");
51: 
52:         if (!domain.contains("."))
53:             throw new ShopException("Domain must contain at least one dot");
54: 
55:         String[] domainParts = domain.split("\\.");
56:         String tld = domainParts[domainParts.length - 1];
57:         boolean tldAllowed = false;
58:         for (String allowed : ALLOWED_TLDS) {
59:             if (allowed.equalsIgnoreCase(tld)) {
60:                 tldAllowed = true;
61:                 break;
62:             }
63:         }
64:         if (!tldAllowed)
65:             throw new ShopException("Domain must end with one of the allowed TLDs");
66: 
67:         if (!emailAddressAsString.matches("^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+$"))
68:             throw new ShopException("Email contains invalid characters");
69: 
70:         return new EmailAddress(identifier, domain);
71:     }
72: 
73:     private EmailAddress(String identifier, String domain) {
74:         this.identifier = identifier;
75:         this.domain = domain;
76:     }
77: 
78:     @Override
79:     public EmailAddressType sameIdentifyerDifferentDomain(String domainString) {
80:         return EmailAddress.of(this.identifier + "@" + domainString);
81:     }
82: 
83:     @Override
84:     public EmailAddressType sameDomainDifferentIdentifyer(String identifyerString) {
85:         return EmailAddress.of(identifyerString + "@" + this.domain);
86:     }
87: 
88:     @Override
89:     public String toString() {
90:         return identifier + "@" + domain;
91:     }
92: 
93:     @JsonValue
94:     public String getValue() {
95:         return toString();
96:     }
97: 
98:     @JsonCreator
99:     public static EmailAddress fromJson(String value) {
100:         return of(value);
101:     }
102: 
103:     @Override
104:     public boolean equals(Object o) {
105:         if (this == o) return true;
106:         if (!(o instanceof EmailAddress that)) return false;
107:         return Objects.equals(identifier, that.identifier) && Objects.equals(domain, that.domain);
108:     }
109: 
110:     @Override
111:     public int hashCode() {
112:         return Objects.hash(identifier, domain);
113:     }
114: }
115: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\EmailMissingException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: 
6: @ResponseStatus(HttpStatus.METHOD_NOT_ALLOWED)
7: public class EmailMissingException extends RuntimeException {
8:     public EmailMissingException() {
9:         super("Email address is required.");
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnore;
4: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
5: import jakarta.persistence.Column;
6: import jakarta.persistence.Embeddable;
7: import lombok.AccessLevel;
8: import lombok.NoArgsConstructor;
9: import thkoeln.archilab.ecommerce.ShopException;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
11: 
12: import java.util.Locale;
13: import java.util.Objects;
14: 
15: @JsonIgnoreProperties(ignoreUnknown = true)  // ← verhindert Fehler bei "formatted"
16: @Embeddable
17: @NoArgsConstructor(access = AccessLevel.PROTECTED) // notwendig für Hibernate
18: public class Money implements MoneyType {
19: 
20:     @Column(name = "amount", nullable = false)
21:     private Float amount;
22: 
23:     @Column(name = "currencyUnit", nullable = false)
24:     private String currencyUnit;
25: 
26:     public static Money of(Float amount, String currencyUnit) {
27:         if (amount == null) {
28:             throw new ShopException("Amount must not be null");
29:         }
30:         if (amount < 0) {
31:             throw new ShopException("Amount must not be negative");
32:         }
33:         if (currencyUnit == null) {
34:             throw new ShopException("Currency unit must not be null");
35:         }
36:         if (!currencyUnit.equals("EUR") && !currencyUnit.equals("CHF")) {
37:             throw new ShopException("Currency unit must be EUR or CHF");
38:         }
39:         return new Money(amount, currencyUnit);
40:     }
41: 
42:     private Money(Float amount, String currencyUnit) {
43:         this.amount = amount;
44:         this.currencyUnit = currencyUnit;
45:     }
46: 
47:     @Override
48:     public Float getAmount() {
49:         return amount;
50:     }
51: 
52:     @Override
53:     public String getCurrencyUnit() {
54:         return currencyUnit;
55:     }
56: 
57:     @Override
58:     public MoneyType add(MoneyType otherMoney) {
59:         validateOperation(otherMoney);
60:         return Money.of(this.amount + otherMoney.getAmount(), currencyUnit);
61:     }
62: 
63:     @Override
64:     public MoneyType subtract(MoneyType otherMoney) {
65:         validateOperation(otherMoney);
66:         if (otherMoney.getAmount() > this.amount) {
67:             throw new ShopException("Cannot subtract: otherMoney is greater than this");
68:         }
69:         return Money.of(this.amount - otherMoney.getAmount(), currencyUnit);
70:     }
71: 
72:     @Override
73:     public MoneyType multiplyBy(int factor) {
74:         if (factor < 0) {
75:             throw new ShopException("Factor must not be negative");
76:         }
77:         return Money.of(this.amount * factor, currencyUnit);
78:     }
79: 
80:     @Override
81:     public boolean largerThan(MoneyType otherMoney) {
82:         validateOperation(otherMoney);
83:         return this.amount > otherMoney.getAmount();
84:     }
85: 
86:     private void validateOperation(MoneyType otherMoney) {
87:         if (otherMoney == null) {
88:             throw new ShopException("Other money must not be null");
89:         }
90:         if (!this.currencyUnit.equals(otherMoney.getCurrencyUnit())) {
91:             throw new ShopException("Currency units must match");
92:         }
93:     }
94: 
95:     @Override
96:     public String toString() {
97:         return amount + " " + currencyUnit;
98:     }
99: 
100:     @Override
101:     public boolean equals(Object o) {
102:         if (this == o) return true;
103:         if (!(o instanceof Money)) return false;
104:         Money money = (Money) o;
105:         return Objects.equals(amount, money.amount) &&
106:                 Objects.equals(currencyUnit, money.currencyUnit);
107:     }
108: 
109:     @Override
110:     public int hashCode() {
111:         return Objects.hash(amount, currencyUnit);
112:     }
113: 
114:     @JsonIgnore
115:     public String getFormatted() {
116:         String symbol = switch (currencyUnit) {
117:             case "EUR" -> "€";
118:             case "CHF" -> "CHF";
119:             default -> currencyUnit;
120:         };
121:         // Hier .2f: immer zwei Nachkommastellen, z.B. 12.00
122:         // replace '.' durch ',' für deutsche Schreibweise
123:         return String.format(Locale.getDefault(), "%.2f", amount) + " " + symbol;
124:     }
125: 
126: }
127: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PhysicalAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.*;
4: import lombok.AccessLevel;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
9: 
10: import java.util.Objects;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED) // <- wichtig für JPA
14: public class PhysicalAddress implements PhysicalAddressType {
15: 
16:     @Column(name = "street")
17:     private String street;
18: 
19:     @Column(name = "city")
20:     private String city;
21: 
22:     @Embedded
23:     @AttributeOverrides({
24:             @AttributeOverride(name = "zipCode", column = @Column(name = "zip_code"))
25:     })
26:     private ZipCode zipCode;
27: 
28:     // Factory-Methode für Tests (Reflection)
29:     public static PhysicalAddress of(String street, String city, ZipCode zipCode) {
30:         return ofInternal(street, city, zipCode);
31:     }
32: 
33:     // Factory-Methode für Interface-Nutzung
34:     public static PhysicalAddress of(String street, String city, ZipCodeType zipCode) {
35:         if (!(zipCode instanceof ZipCode)) {
36:             throw new ShopException("Provided ZipCodeType is not a valid ZipCode instance");
37:         }
38:         return ofInternal(street, city, (ZipCode) zipCode);
39:     }
40: 
41:     // Gemeinsame Validierung
42:     private static PhysicalAddress ofInternal(String street, String city, ZipCode zipCode) {
43:         if (street == null || street.trim().isEmpty()) throw new ShopException("Street must not be null or empty");
44:         if (city == null || city.trim().isEmpty()) throw new ShopException("City must not be null or empty");
45:         if (zipCode == null) throw new ShopException("ZipCode must not be null");
46:         return new PhysicalAddress(street.trim(), city.trim(), zipCode);
47:     }
48: 
49:     // privater Konstruktor für Factory
50:     private PhysicalAddress(String street, String city, ZipCode zipCode) {
51:         this.street = street;
52:         this.city = city;
53:         this.zipCode = zipCode;
54:     }
55: 
56:     @Override
57:     public String getStreet() {
58:         return street;
59:     }
60: 
61:     @Override
62:     public String getCity() {
63:         return city;
64:     }
65: 
66:     @Override
67:     public ZipCodeType getZipCode() {
68:         return zipCode;
69:     }
70: 
71:     @Override
72:     public String toString() {
73:         return street + ", " + zipCode.toString() + " " + city;
74:     }
75: 
76:     @Override
77:     public boolean equals(Object o) {
78:         if (this == o) return true;
79:         if (!(o instanceof PhysicalAddress that)) return false;
80:         return Objects.equals(street, that.street) &&
81:                 Objects.equals(city, that.city) &&
82:                 Objects.equals(zipCode, that.zipCode);
83:     }
84: 
85:     @Override
86:     public int hashCode() {
87:         return Objects.hash(street, city, zipCode);
88:     }
89: }
90: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Column;
4: import jakarta.persistence.Embeddable;
5: import lombok.AccessLevel;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
10: 
11: import java.util.Objects;
12: 
13: @Embeddable
14: @Getter
15: @NoArgsConstructor(access = AccessLevel.PROTECTED)
16: public class ZipCode implements ZipCodeType {
17: 
18:     @Column(name = "zip_code")
19:     private String zipCode;
20: 
21:     private ZipCode(String zipCode) {
22:         this.zipCode = zipCode;
23:     }
24: 
25:     public static ZipCode of(String zipCodeAsString) {
26:         if (zipCodeAsString == null) {
27:             throw new ShopException("ZipCode cannot be null");
28:         }
29: 
30:         if (!zipCodeAsString.matches("\\d{5}")) {
31:             throw new ShopException("ZipCode must be exactly 5 digits");
32:         }
33: 
34:         if (zipCodeAsString.endsWith("0000")) {
35:             throw new ShopException("ZipCode must not end with 0000");
36:         }
37: 
38:         return new ZipCode(zipCodeAsString);
39:     }
40: 
41:     @Override
42:     public int difference(ZipCodeType otherZipCode) {
43:         if (otherZipCode == null) throw new ShopException("Zip code must not be null");
44: 
45:         String other = otherZipCode.toString();
46: 
47:         if (zipCode.equals(other)) return 0;
48: 
49:         for (int i = 0; i < zipCode.length(); i++) {
50:             if (zipCode.charAt(i) != other.charAt(i)) {
51:                 if (i == 0) {
52:                     int thisDigit = Character.getNumericValue(zipCode.charAt(0));
53:                     int otherDigit = Character.getNumericValue(other.charAt(0));
54:                     int rawDiff = Math.abs(thisDigit - otherDigit);
55:                     int wrappedDiff = Math.min(rawDiff, 10 - rawDiff);
56:                     return 10 + wrappedDiff; // Stelle 0 = höchste Priorität
57:                 }
58:                 return zipCode.length() - i; // Stelle 4 (ganz rechts) → 1, Stelle 3 → 2, ...
59:             }
60:         }
61: 
62:         return 0;
63:     }
64: 
65: 
66: 
67: 
68: 
69: 
70:     @Override
71:     public Integer getFirstDigitZipCode() {
72:         return Integer.parseInt(zipCode.substring(0, 1));
73:     }
74: 
75:     @Override
76:     public String toString() {
77:         return zipCode;
78:     }
79: 
80:     @Override
81:     public boolean equals(Object o) {
82:         if (this == o) return true;
83:         if (!(o instanceof ZipCode)) return false;
84:         ZipCode zipCode1 = (ZipCode) o;
85:         return Objects.equals(zipCode, zipCode1.zipCode);
86:     }
87: 
88:     @Override
89:     public int hashCode() {
90:         return Objects.hash(zipCode);
91:     }
92: }
93: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.Column;
7: import jakarta.persistence.MappedSuperclass;
8: import lombok.EqualsAndHashCode;
9: import lombok.Getter;
10: import lombok.ToString;
11: 
12: import java.io.Serializable;
13: import java.util.UUID;
14: 
15: @MappedSuperclass
16: @Getter
17: @EqualsAndHashCode(of = "id")
18: @ToString(of = "id")
19: public abstract class GenericId implements Serializable {
20:     @Column(nullable = false, updatable = false)
21:     private final UUID id;
22: 
23:     protected GenericId() {
24:         this( UUID.randomUUID() );
25:     }
26: 
27:     protected GenericId( UUID id ) {
28:         this.id = id;
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.AttributeConverter;
7: 
8: import java.util.UUID;
9: import java.util.function.Function;
10: 
11: 
12: public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
13:     private final Function<UUID, T> factory;
14: 
15:     protected GenericIdConverter( Function<UUID, T> factory ) {
16:         this.factory = factory;
17:     }
18: 
19:     @Override
20:     public UUID convertToDatabaseColumn( T attribute ) {
21:         return attribute == null ? null : attribute.getId();
22:     }
23: 
24:     @Override
25:     public T convertToEntityAttribute( UUID dbData ) {
26:         return dbData == null ? null : factory.apply( dbData );
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\InsufficientStockException.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: /**
7:  * Exception is thrown if the item's stock level is not sufficient to serve the order.
8:  */
9: public class InsufficientStockException extends ShopException {
10:     public InsufficientStockException( String message ) {
11:         super( message );
12:     }
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import org.springframework.boot.SpringApplication;
7: import org.springframework.boot.autoconfigure.SpringBootApplication;
8: 
9: 
10: @SpringBootApplication
11: public class ProjectApplication {
12: 
13: 	/**
14: 	 * Entry method
15: 	 * @param args
16: 	 */
17: 	public static void main(String[] args) {
18: 		SpringApplication.run(ProjectApplication.class, args);
19: 	}
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: public class ShopException extends RuntimeException {
7:     public ShopException( String message ) {
8:         super( message );
9:     }
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.client.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
5: import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
6: import thkoeln.archilab.ecommerce.usecases.ClientType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
9: 
10: @Service
11: public class ClientAdapterService implements ClientRegistrationUseCases {
12: 
13:     private final ClientRegistrationService clientRegistrationService;
14: 
15:     public ClientAdapterService(ClientRegistrationService clientRegistrationService) {
16:         this.clientRegistrationService = clientRegistrationService;
17:     }
18: 
19:     @Override
20:     public void register(String name, EmailAddressType emailAddress, PhysicalAddressType physicalAddress) {
21:         clientRegistrationService.register(name, emailAddress, physicalAddress);
22:     }
23: 
24:     @Override
25:     public void changeAddress(EmailAddressType clientEmailAddress, PhysicalAddressType physicalAddress) {
26:         clientRegistrationService.changeAddress(clientEmailAddress, physicalAddress);
27:     }
28: 
29:     @Override
30:     public ClientType getClientData(EmailAddressType clientEmailAddress) {
31:         return clientRegistrationService.getClientData(clientEmailAddress);
32:     }
33: 
34:     @Override
35:     public void deleteAllClients() {
36:         clientRegistrationService.deleteAllClients();
37:     }
38: 
39:     public ClientResponseDTO getClientByEmailAddress(String emailString) {
40:         EmailAddress email = EmailAddress.of(emailString);
41:         var client = clientRegistrationService.getClientByEmail(email);
42:         return ClientResponseDTO.from(client);
43:     }
44: 
45: }
46: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientController.java ---
1: package thkoeln.archilab.ecommerce.solution.client.application;
2: 
3: import org.springframework.http.ResponseEntity;
4: import org.springframework.web.bind.annotation.*;
5: import thkoeln.archilab.ecommerce.domainprimitives.EmailMissingException;
6: 
7: @RestController
8: @RequestMapping("/clients")
9: public class ClientController {
10: 
11:     private final ClientAdapterService clientAdapterService;
12: 
13:     public ClientController(ClientAdapterService clientAdapterService) {
14:         this.clientAdapterService = clientAdapterService;
15:     }
16: 
17:     @GetMapping
18:     public ResponseEntity<ClientResponseDTO> getClientByEmail(@RequestParam(required = false) String emailAddress) {
19:         if (emailAddress == null || emailAddress.isBlank()) {
20:             throw new EmailMissingException();
21:         }
22:         return ResponseEntity.ok(clientAdapterService.getClientByEmailAddress(emailAddress));
23:     }
24: 
25: }
26: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientRegistrationService.java ---
1: package thkoeln.archilab.ecommerce.solution.client.application;
2: 
3: import jakarta.transaction.Transactional;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.*;
7: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
8: import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
9: import thkoeln.archilab.ecommerce.usecases.ClientType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
12: 
13: @Service
14: @Transactional
15: public class ClientRegistrationService {
16:     private final ClientRepository clientRepository;
17: 
18:     public ClientRegistrationService(ClientRepository clientRepository) {
19:         this.clientRepository = clientRepository;
20:     }
21: 
22:     public void register(String name, EmailAddressType emailAddress, PhysicalAddressType physicalAddress) {
23:         if (name == null || name.trim().isEmpty()) {
24:             throw new ShopException("Name must not be empty");
25:         }
26: 
27:         if (emailAddress == null) {
28:             throw new ShopException("Email address must not be null");
29:         }
30: 
31:         if (physicalAddress == null) {
32:             throw new ShopException("Address must not be null");
33:         }
34: 
35:         EmailAddress email = EmailAddress.of(emailAddress.toString());
36:         if (clientRepository.findByEmail(email).isPresent()) {
37:             throw new ShopException("Client with this email already exists.");
38:         }
39: 
40:         PhysicalAddress address = PhysicalAddress.of(
41:                 physicalAddress.getStreet(),
42:                 physicalAddress.getCity(),
43:                 ZipCode.of(physicalAddress.getZipCode().toString())
44:         );
45: 
46:         Client client = new Client(name, email, address);
47:         clientRepository.save(client);
48:     }
49: 
50:     public void changeAddress(EmailAddressType clientEmailAddress, PhysicalAddressType physicalAddress) {
51:         if (clientEmailAddress == null) {
52:             throw new ShopException("Client email address must not be null");
53:         }
54: 
55:         if (physicalAddress == null) {
56:             throw new ShopException("Address must not be null");
57:         }
58: 
59:         EmailAddress email = EmailAddress.of(clientEmailAddress.toString());
60:         Client client = clientRepository.findByEmail(email)
61:                 .orElseThrow(() -> new ShopException("Client not found"));
62: 
63:         PhysicalAddress newAddress = PhysicalAddress.of(
64:                 physicalAddress.getStreet(),
65:                 physicalAddress.getCity(),
66:                 ZipCode.of(physicalAddress.getZipCode().toString())
67:         );
68: 
69:         client.updateAddress(newAddress);
70:         clientRepository.save(client);
71:     }
72: 
73:     public ClientType getClientData(EmailAddressType clientEmailAddress) {
74:         if (clientEmailAddress == null) {
75:             throw new ShopException("Client email address must not be null");
76:         }
77: 
78:         EmailAddress email = EmailAddress.of(clientEmailAddress.toString());
79:         Client client = clientRepository.findByEmail(email)
80:                 .orElseThrow(() -> new ShopException("Client not found"));
81: 
82:         return client;
83:     }
84: 
85:     public void deleteAllClients() {
86:         clientRepository.deleteAll();
87:     }
88: 
89:     public Client getClientByEmail(EmailAddress email) {
90:         return clientRepository.findByEmail(email)
91:                 .orElseThrow(() -> new ClientNotFoundException(email.toString()));
92:     }
93: 
94:     public ClientType getClientByEmail(EmailAddressType clientEmailAddress) {
95:         if (clientEmailAddress == null) {
96:             throw new EmailMissingException();
97:         }
98: 
99:         EmailAddress email = EmailAddress.of(clientEmailAddress.toString());
100: 
101:         return clientRepository.findByEmail(email)
102:                 .orElseThrow(() -> new ClientNotFoundException(email.toString()));
103:     }
104: 
105: 
106: }
107: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientResponseDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.client.application;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
4: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
5: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
6: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
7: 
8: import java.util.UUID;
9: 
10: public class ClientResponseDTO {
11:     public UUID id;
12:     public String name;
13:     public EmailAddressDTO emailAddress;
14:     public PhysicalAddressDTO physicalAddress;
15: 
16:     public static ClientResponseDTO from(Client client) {
17:         ClientResponseDTO dto = new ClientResponseDTO();
18:         dto.id = client.getId().getId(); // statt client.getId().toUUID()
19:         dto.name = client.getName();
20:         dto.emailAddress = new EmailAddressDTO((EmailAddress) client.getEmailAddress());
21:         dto.physicalAddress = new PhysicalAddressDTO((PhysicalAddress) client.getPhysicalAddress());
22:         return dto;
23:     }
24: 
25: 
26: 
27:     public static class EmailAddressDTO {
28:         public String emailAddressString;
29: 
30:         public EmailAddressDTO(EmailAddress email) {
31:             this.emailAddressString = email.toString();
32:         }
33:     }
34: 
35:     public static class PhysicalAddressDTO {
36:         public String street;
37:         public String city;
38:         public ZipCodeDTO zipCode;
39: 
40:         public PhysicalAddressDTO(PhysicalAddress address) {
41:             this.street = address.getStreet();
42:             this.city = address.getCity();
43:             this.zipCode = new ZipCodeDTO((ZipCode) address.getZipCode());
44:         }
45:     }
46: 
47:     public static class ZipCodeDTO {
48:         public String zipCodeString;
49: 
50:         public ZipCodeDTO(ZipCode zipCode) {
51:             this.zipCodeString = zipCode.toString();
52:         }
53:     }
54: }
55: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\Client.java ---
1: package thkoeln.archilab.ecommerce.solution.client.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.AccessLevel;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
8: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
9: import thkoeln.archilab.ecommerce.usecases.ClientType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
12: 
13: @Entity
14: @Getter
15: @NoArgsConstructor(access = AccessLevel.PROTECTED)
16: public class Client implements ClientType {
17: 
18:     @EmbeddedId
19:     private ClientId id;
20: 
21:     private String name;
22: 
23:     @Embedded
24:     @AttributeOverrides({
25:             @AttributeOverride(name = "identifier", column = @Column(name = "email_identifier")),
26:             @AttributeOverride(name = "domain", column = @Column(name = "email_domain"))
27:     })
28:     private EmailAddress email;
29: 
30:     @Embedded
31:     @AttributeOverrides({
32:             @AttributeOverride(name = "street", column = @Column(name = "street")),
33:             @AttributeOverride(name = "city", column = @Column(name = "city")),
34:             @AttributeOverride(name = "zipCode.zipCode", column = @Column(name = "zip_code"))
35:     })
36:     private PhysicalAddress address;
37: 
38:     public Client(String name, EmailAddress email, PhysicalAddress address) {
39:         this.id = new ClientId();
40:         this.name = name;
41:         this.email = email;
42:         this.address = address;
43:     }
44: 
45:     public void updateAddress(PhysicalAddress newAddress) {
46:         this.address = newAddress;
47:     }
48: 
49:     @Override
50:     public EmailAddressType getEmailAddress() {
51:         return this.email;
52:     }
53: 
54:     @Override
55:     public PhysicalAddressType getPhysicalAddress() {
56:         return this.address;
57:     }
58: 
59:     public String getPostalCode() {
60:         return address.getZipCode().toString();
61:     }
62: 
63: }
64: 
65: // Nur erreichbar, wenn clientId vorhanden ist
66: /** @GetMapping
67: public ResponseEntity<ShoppingBasketResponseDTO> getBasketByClientId(@RequestParam(required = false) UUID clientId) {
68: if (clientId == null) {
69: return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).build();
70: }
71: 
72: try {
73: ShoppingBasketResponseDTO dto = shoppingBasketAdapterService.getShoppingBasketForClient(clientId);
74: return ResponseEntity.ok(dto);
75: } catch (ShopException e) {
76: return ResponseEntity.status(HttpStatus.NOT_FOUND).build(); // oder BAD_REQUEST
77: }
78: 
79: }
80:  */

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ClientId.java ---
1: package thkoeln.archilab.ecommerce.solution.client.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "client_id"))
15: public class ClientId extends GenericId {
16:     public ClientId(UUID id) {
17:         super(id);
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ClientIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.client.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ClientIdConverter extends GenericIdConverter<ClientId> {
8:     public ClientIdConverter() {
9:         super(ClientId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ClientRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.client.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
5: 
6: import java.util.Optional;
7: 
8: public interface ClientRepository extends JpaRepository<Client, ClientId> {
9:     Optional<Client> findByEmail(EmailAddress emailAddress);
10: 
11:     boolean existsByEmail(EmailAddress clientEmailAddress);
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;
2: 
3: import jakarta.transaction.Transactional;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
7: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
8: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: 
11: import java.util.UUID;
12: 
13: @Service
14: @Transactional
15: public class FulfillmentCenterAdapterService implements FulfillmentCenterUseCases {
16: 
17:     private final FulfillmentCenterService domainService;
18: 
19:     public FulfillmentCenterAdapterService(FulfillmentCenterService domainService) {
20:         this.domainService = domainService;
21:     }
22: 
23:     @Override
24:     public UUID addNewFulfillmentCenter(String name, PhysicalAddressType addressType) {
25:         if (name == null || name.isBlank()) {
26:             throw new ShopException("Name must not be null or blank");
27:         }
28:         if (addressType == null) {
29:             throw new ShopException("Address must not be null");
30:         }
31: 
32:         // Defaultbereich (z. B. 0–9), da Interface keine Parameter für PLZ-Range erlaubt
33:         int fromZipDigit = 0;
34:         int toZipDigit = 9;
35: 
36:         PhysicalAddress address = PhysicalAddress.of(
37:                 addressType.getStreet(),
38:                 addressType.getCity(),
39:                 ZipCode.of(addressType.getZipCode().toString())
40:         );
41: 
42:         return domainService.create(name, address, fromZipDigit, toZipDigit);
43:     }
44: 
45:     @Override
46:     public void deleteAllFulfillmentCenters() {
47:         domainService.deleteAll();
48:     }
49: 
50:     @Override
51:     public void addToStock(UUID fulfillmentCenterId, UUID itemId, int addedQuantFor) {
52:         if (fulfillmentCenterId == null || itemId == null) {
53:             throw new ShopException("IDs must not be null");
54:         }
55:         if (addedQuantFor < 0) {
56:             throw new ShopException("Quantity must not be negative");
57:         }
58:         domainService.add(fulfillmentCenterId, itemId, addedQuantFor);
59:     }
60: 
61:     @Override
62:     public void removeFromStock(UUID fulfillmentCenterId, UUID itemId, int removedQuantFor) {
63:         if (fulfillmentCenterId == null || itemId == null) {
64:             throw new ShopException("IDs must not be null");
65:         }
66:         if (removedQuantFor < 0) {
67:             throw new ShopException("Quantity must not be negative");
68:         }
69:         domainService.remove(fulfillmentCenterId, itemId, removedQuantFor);
70:     }
71: 
72:     @Override
73:     public void changeStockTo(UUID fulfillmentCenterId, UUID itemId, int newTotalQuantFor) {
74:         if (fulfillmentCenterId == null || itemId == null) {
75:             throw new ShopException("IDs must not be null");
76:         }
77:         if (newTotalQuantFor < 0) {
78:             throw new ShopException("Quantity must not be negative");
79:         }
80:         domainService.setStock(fulfillmentCenterId, itemId, newTotalQuantFor);
81:     }
82: 
83:     @Override
84:     public int getAvailableStock(UUID fulfillmentCenterId, UUID itemId) {
85:         if (fulfillmentCenterId == null || itemId == null) {
86:             throw new ShopException("IDs must not be null");
87:         }
88:         return domainService.getStock(fulfillmentCenterId, itemId);
89:     }
90: }
91: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterQueryImplService.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;
2: 
3: import jakarta.transaction.Transactional;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenter;
6: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterRepository;
7: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.queryport.FulfillmentCenterQueryPort;
8: 
9: import java.util.List;
10: import java.util.UUID;
11: 
12: @Service
13: @Transactional
14: public class FulfillmentCenterQueryImplService implements FulfillmentCenterQueryPort {
15: 
16:     private final FulfillmentCenterRepository fulfillmentCenterRepository;
17: 
18:     public FulfillmentCenterQueryImplService(FulfillmentCenterRepository fulfillmentCenterRepository) {
19:         this.fulfillmentCenterRepository = fulfillmentCenterRepository;
20:     }
21: 
22:     @Override
23:     public boolean isItemInStock(UUID itemId) {
24:         return fulfillmentCenterRepository.findAll().stream()
25:                 .anyMatch(fc -> fc.getStock(itemId) > 0);
26:     }
27: 
28:     public List<FulfillmentCenter> getAllFulfillmentCenters() {
29:         return fulfillmentCenterRepository.findAll();
30:     }
31: 
32:     @Override
33:     public UUID findSuitableFulfillmentCenter(String zipCode) {
34:         if (zipCode == null || !zipCode.matches("\\d{5}")) {
35:             throw new IllegalArgumentException("Invalid zip code");
36:         }
37: 
38:         int firstDigit = Integer.parseInt(zipCode.substring(0, 1));
39: 
40:         return fulfillmentCenterRepository.findAll().stream()
41:                 .filter(fc -> fc.servesZipDigit(firstDigit))
42:                 .findFirst()
43:                 .map(fc -> fc.getId().getId())
44:                 .orElseThrow(() -> new IllegalArgumentException("No suitable center found"));
45:     }
46: 
47: }
48: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterService.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
6: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenter;
7: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterId;
8: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterRepository;
9: import thkoeln.archilab.ecommerce.solution.item.queryport.ItemQueryPort;
10: 
11: import java.util.UUID;
12: 
13: @Service
14: public class FulfillmentCenterService {
15:     private final FulfillmentCenterRepository centerRepo;
16:     private final ItemQueryPort itemQueryPort;
17: 
18:     public FulfillmentCenterService(FulfillmentCenterRepository centerRepo, ItemQueryPort itemQueryPort) {
19:         this.centerRepo = centerRepo;
20:         this.itemQueryPort = itemQueryPort;
21:     }
22: 
23:     public UUID create(String name, PhysicalAddress address, int fromZipDigit, int toZipDigit) {
24:         FulfillmentCenter fc = new FulfillmentCenter(name, address, fromZipDigit, toZipDigit);
25:         centerRepo.save(fc);
26:         return fc.getId().getId();
27:     }
28: 
29:     public void deleteAll() {
30:         centerRepo.deleteAll();
31:     }
32: 
33:     public UUID findByZip(String zipCodeStr) {
34:         if (zipCodeStr == null || !zipCodeStr.matches("\\d{5}")) {
35:             throw new ShopException("Invalid zip code");
36:         }
37:         int digit = Integer.parseInt(zipCodeStr.substring(0, 1));
38:         return centerRepo.findAll().stream()
39:                 .filter(c -> c.servesZipDigit(digit))
40:                 .findFirst()
41:                 .map(c -> c.getId().getId())
42:                 .orElseThrow(() -> new ShopException("No suitable center found"));
43:     }
44: 
45:     public void add(UUID centerId, UUID itemId, int quantity) {
46:         FulfillmentCenter center = getCenter(centerId);
47:         if (!itemQueryPort.itemExists(itemId)) throw new ShopException("Item not found");
48:         center.addStock(itemId, quantity);
49:         centerRepo.save(center);
50:     }
51: 
52:     public void remove(UUID centerId, UUID itemId, int quantity) {
53:         FulfillmentCenter center = getCenter(centerId);
54:         if (!itemQueryPort.itemExists(itemId)) throw new ShopException("Item not found");
55:         center.removeStock(itemId, quantity);
56:         centerRepo.save(center);
57:     }
58: 
59:     public void setStock(UUID centerId, UUID itemId, int newQuantity) {
60:         FulfillmentCenter center = getCenter(centerId);
61:         if (!itemQueryPort.itemExists(itemId)) throw new ShopException("Item not found");
62:         center.setStock(itemId, newQuantity);
63:         centerRepo.save(center);
64:     }
65: 
66:     public int getStock(UUID centerId, UUID itemId) {
67:         FulfillmentCenter center = getCenter(centerId);
68:         if (!itemQueryPort.itemExists(itemId)) throw new ShopException("Item not found");
69:         return center.getStock(itemId);
70:     }
71: 
72:     private FulfillmentCenter getCenter(UUID uuid) {
73:         if (uuid == null) throw new ShopException("Center ID must not be null");
74:         return centerRepo.findById(new FulfillmentCenterId(uuid))
75:                 .orElseThrow(() -> new ShopException("Center not found"));
76:     }
77: }
78: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\StockLevelQueryImplService.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;
2: 
3: import jakarta.transaction.Transactional;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.queryport.FulfillmentCenterQueryPort;
6: import thkoeln.archilab.ecommerce.solution.item.queryport.StockLevelQueryPort;
7: 
8: import java.util.UUID;
9: 
10: @Service
11: @Transactional
12: public class StockLevelQueryImplService implements StockLevelQueryPort {
13: 
14:     private final FulfillmentCenterQueryPort fulfillmentCenterQueryPort;
15: 
16:     public StockLevelQueryImplService(FulfillmentCenterQueryPort fulfillmentCenterQueryPort) {
17:         this.fulfillmentCenterQueryPort = fulfillmentCenterQueryPort;
18:     }
19: 
20:     @Override
21:     public boolean isItemInStock(UUID itemId) {
22:         return fulfillmentCenterQueryPort.isItemInStock(itemId);
23:     }
24: }
25: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenter.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.AccessLevel;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.InsufficientStockException;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
10: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
12: 
13: import java.util.*;
14: 
15: @Entity
16: @Getter
17: @NoArgsConstructor(access = AccessLevel.PROTECTED)
18: public class FulfillmentCenter {
19: 
20:     @EmbeddedId
21:     private FulfillmentCenterId id = new FulfillmentCenterId();
22: 
23:     private String name;
24: 
25:     private int fromPostalCodeFirstDigit;
26:     private int toPostalCodeFirstDigit;
27: 
28:     @Embedded
29:     @AttributeOverrides({
30:             @AttributeOverride(name = "street", column = @Column(name = "street")),
31:             @AttributeOverride(name = "city", column = @Column(name = "city")),
32:             @AttributeOverride(name = "zipCode.zipCode", column = @Column(name = "zip_code"))
33:     })
34:     private PhysicalAddress address;
35: 
36:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
37:     private List<StockLevel> stock = new ArrayList<>();
38: 
39:     public FulfillmentCenter(String name, PhysicalAddress address,
40:                              int fromPostalCodeFirstDigit, int toPostalCodeFirstDigit) {
41:         this.name = name;
42:         this.address = address;
43:         this.fromPostalCodeFirstDigit = fromPostalCodeFirstDigit;
44:         this.toPostalCodeFirstDigit = toPostalCodeFirstDigit;
45:     }
46: 
47:     public boolean servesZipDigit(int firstDigit) {
48:         return firstDigit >= fromPostalCodeFirstDigit && firstDigit <= toPostalCodeFirstDigit;
49:     }
50: 
51:     public void addStock(UUID itemId, int quantity) {
52:         if (quantity < 0) throw new IllegalArgumentException("Quantity must be >= 0");
53: 
54:         Optional<StockLevel> levelOpt = stock.stream()
55:                 .filter(s -> s.getItemId().equals(itemId))
56:                 .findFirst();
57: 
58:         if (levelOpt.isPresent()) {
59:             levelOpt.get().increase(quantity);
60:         } else {
61:             stock.add(new StockLevel(itemId, quantity));
62:         }
63:     }
64: 
65:     public void removeStock(UUID itemId, int quantity) {
66:         if (quantity < 0) throw new ShopException("Quantity must not be negative");
67: 
68:         Optional<StockLevel> level = stock.stream()
69:                 .filter(s -> s.getItemId().equals(itemId))
70:                 .findFirst();
71: 
72:         if (quantity == 0) {
73:             // Wenn es keine Menge gibt, die entfernt werden soll → nichts tun
74:             if (level.isEmpty()) return;
75:             return;
76:         }
77: 
78:         StockLevel existing = level.orElseThrow(() -> new InsufficientStockException("Item not found in stock"));
79: 
80:         if (existing.getQuantity() < quantity) {
81:             throw new InsufficientStockException("Not enough stock");
82:         }
83: 
84:         existing.decrease(quantity);
85:     }
86: 
87: 
88:     public void setStock(UUID itemId, int newQuantity) {
89:         Optional<StockLevel> levelOpt = stock.stream()
90:                 .filter(s -> s.getItemId().equals(itemId))
91:                 .findFirst();
92: 
93:         if (levelOpt.isPresent()) {
94:             levelOpt.get().setQuantity(newQuantity);
95:         } else {
96:             stock.add(new StockLevel(itemId, newQuantity));
97:         }
98:     }
99: 
100:     public int getStock(UUID itemId) {
101:         return stock.stream()
102:                 .filter(s -> s.getItemId().equals(itemId))
103:                 .findFirst()
104:                 .map(StockLevel::getQuantity)
105:                 .orElse(0);
106:     }
107: 
108:     public PhysicalAddressType getAddress() {
109:         return this.address;
110:     }
111: 
112: 
113:     public Set<ItemId> fulfillableShoppingBasketPositions(Map<ItemId, Integer> itemQuantityMap) {
114:         Set<ItemId> fulfillableItems = new HashSet<>();
115: 
116:         for (Map.Entry<ItemId, Integer> entry : itemQuantityMap.entrySet()) {
117:             ItemId itemId = entry.getKey();
118:             int requestedQuantity = entry.getValue();
119: 
120:             boolean canFulfill = stock.stream()
121:                     .anyMatch(stockLevel ->
122:                             stockLevel.getItemId().equals(itemId.getId()) &&
123:                                     stockLevel.getQuantity() >= requestedQuantity
124:                     );
125: 
126:             if (canFulfill) {
127:                 fulfillableItems.add(itemId);
128:             }
129:         }
130: 
131:         return fulfillableItems;
132:     }
133: 
134: }
135: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterComparator.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
4: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
5: 
6: import java.util.Comparator;
7: import java.util.Map;
8: 
9: public class FulfillmentCenterComparator implements Comparator<FulfillmentCenter> {
10: 
11:     private final Map<ItemId, Integer> shoppingBasket;
12:     private final ZipCode clientZipCode;
13: 
14:     public FulfillmentCenterComparator(Map<ItemId, Integer> shoppingBasket, ZipCode clientZipCode) {
15:         this.shoppingBasket = shoppingBasket;
16:         this.clientZipCode = clientZipCode;
17:     }
18: 
19:     @Override
20:     public int compare(FulfillmentCenter fc1, FulfillmentCenter fc2) {
21:         int count1 = fc1.fulfillableShoppingBasketPositions(shoppingBasket).size();
22:         int count2 = fc2.fulfillableShoppingBasketPositions(shoppingBasket).size();
23: 
24:         if (count1 != count2) {
25:             return Integer.compare(count2, count1); // mehr ist besser
26:         }
27: 
28:         int dist1 = clientZipCode.difference(fc1.getAddress().getZipCode());
29:         int dist2 = clientZipCode.difference(fc2.getAddress().getZipCode());
30: 
31:         return Integer.compare(dist1, dist2); // näher ist besser
32:     }
33: }
34: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterId.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "fulfillment_center_id"))
15: public class FulfillmentCenterId extends GenericId {
16:     public FulfillmentCenterId(UUID id) {
17:         super(id);
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class FulfillmentCenterIdConverter extends GenericIdConverter<FulfillmentCenterId> {
8:     public FulfillmentCenterIdConverter() {
9:         super(FulfillmentCenterId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: 
5: public interface FulfillmentCenterRepository extends JpaRepository<FulfillmentCenter, FulfillmentCenterId> {
6: }
7: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\StockLevel.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.EmbeddedId;
4: import jakarta.persistence.Entity;
5: import lombok.AccessLevel;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.InsufficientStockException;
9: 
10: import java.util.UUID;
11: 
12: @Entity
13: @Getter
14: @NoArgsConstructor(access = AccessLevel.PROTECTED)
15: public class StockLevel {
16: 
17:     @EmbeddedId
18:     private StockLevelId id;
19: 
20:     private UUID itemId;
21: 
22:     private int quantities;
23: 
24:     public StockLevel(UUID itemId, int quantities) {
25:         this.id = new StockLevelId();
26:         this.itemId = itemId;
27:         this.quantities = quantities;
28:     }
29: 
30:     public UUID getItemId() {
31:         return this.itemId;
32:     }
33: 
34:     public void increase(int amount) {
35:         if (amount < 0) throw new IllegalArgumentException("Cannot increase by negative amount");
36:         this.quantities += amount;
37:     }
38: 
39:     public void decrease(int amount) {
40:         if (amount < 0 || amount > this.quantities) {
41:             throw new InsufficientStockException("Not enough stock available to decrease");
42:         }
43:         this.quantities -= amount;
44:     }
45: 
46:     public void setQuantity(int quantity) {
47:         if (quantity < 0) throw new IllegalArgumentException("Quantity cannot be negative");
48:         this.quantities = quantity;
49:     }
50: 
51:     public int getQuantity() {
52:         return this.quantities;
53:     }
54: }
55: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\StockLevelId.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "stock_level_id"))
15: public class StockLevelId extends GenericId {
16:     public StockLevelId(UUID id) {
17:         super(id);
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\StockLevelIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class StockLevelIdConverter extends GenericIdConverter<StockLevelId> {
8:     public StockLevelIdConverter() {
9:         super(StockLevelId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\StockLevelRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: 
5: public interface StockLevelRepository extends JpaRepository<StockLevel, StockLevelId> {
6: }
7: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\queryport\FulfillmentCenterQueryPort.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.queryport; // Richtiges Package!
2: 
3: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenter;
4: 
5: import java.util.List;
6: import java.util.UUID;
7: 
8: public interface FulfillmentCenterQueryPort {
9:     boolean isItemInStock(UUID itemId);
10: 
11:     UUID findSuitableFulfillmentCenter(String zipCode);
12: 
13:     List<FulfillmentCenter> getAllFulfillmentCenters();
14: 
15: }
16: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ItemAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.item.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import java.util.UUID;
8: 
9: @Service
10: public class ItemAdapterService implements ItemCatalogUseCases {
11: 
12:     private final ItemCatalogService itemCatalogService;
13: 
14:     public ItemAdapterService(ItemCatalogService itemCatalogService) {
15:         this.itemCatalogService = itemCatalogService;
16:     }
17: 
18:     @Override
19:     public UUID addItemToCatalog(String name, String description, Float size,
20:                                  MoneyType buyingPrice, MoneyType sellingPrice) {
21:         return itemCatalogService.addItemToCatalog(name, description, size, buyingPrice, sellingPrice);
22:     }
23: 
24:     @Override
25:     public void removeItemFromCatalog(UUID itemId) {
26:         itemCatalogService.removeItemFromCatalog(itemId);
27:     }
28: 
29:     @Override
30:     public MoneyType getSellingPrice(UUID itemId) {
31:         return itemCatalogService.getSellingPrice(itemId);
32:     }
33: 
34:     @Override
35:     public void deleteItemCatalog() {
36:         itemCatalogService.deleteItemCatalog();
37:     }
38: }
39: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ItemCatalogService.java ---
1: package thkoeln.archilab.ecommerce.solution.item.application;
2: 
3: import jakarta.transaction.Transactional;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Money;
7: import thkoeln.archilab.ecommerce.solution.item.domain.Item;
8: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
9: import thkoeln.archilab.ecommerce.solution.item.domain.ItemRepository;
10: import thkoeln.archilab.ecommerce.solution.item.queryport.OrderQueryPort;
11: import thkoeln.archilab.ecommerce.solution.item.queryport.ShoppingBasketQueryPort;
12: import thkoeln.archilab.ecommerce.solution.item.queryport.StockLevelQueryPort;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
14: 
15: import java.util.UUID;
16: 
17: @Service
18: @Transactional
19: public class ItemCatalogService {
20: 
21:     private final ItemRepository itemRepository;
22:     private final ShoppingBasketQueryPort shoppingBasketQueryPort;
23:     private final OrderQueryPort orderQueryPort;
24:     private final StockLevelQueryPort stockLevelQueryPort;
25: 
26:     public ItemCatalogService(ItemRepository itemRepository,
27:                               ShoppingBasketQueryPort shoppingBasketQueryPort,
28:                               OrderQueryPort orderQueryPort,
29:                               StockLevelQueryPort stockLevelQueryPort) {
30:         this.itemRepository = itemRepository;
31:         this.shoppingBasketQueryPort = shoppingBasketQueryPort;
32:         this.orderQueryPort = orderQueryPort;
33:         this.stockLevelQueryPort = stockLevelQueryPort;
34:     }
35: 
36:     public UUID addItemToCatalog(String name, String description, Float size,
37:                                  MoneyType buyingPriceType, MoneyType sellingPriceType) {
38:         if (name == null || name.isBlank()
39:                 || description == null || description.isBlank()
40:                 || (size != null && size <= 0)
41:                 || buyingPriceType == null || buyingPriceType.getAmount() <= 0
42:                 || sellingPriceType == null || sellingPriceType.getAmount() <= 0
43:                 || sellingPriceType.getAmount() < buyingPriceType.getAmount()) {
44:             throw new ShopException("Invalid item data");
45:         }
46: 
47:         Money buyingPrice = Money.of(buyingPriceType.getAmount(), buyingPriceType.getCurrencyUnit());
48:         Money sellingPrice = Money.of(sellingPriceType.getAmount(), sellingPriceType.getCurrencyUnit());
49: 
50:         Item item = new Item(name, description, size, buyingPrice, sellingPrice);
51:         itemRepository.save(item);
52:         return item.getId().getId();
53:     }
54: 
55:     public void removeItemFromCatalog(UUID rawItemId) {
56:         ItemId itemId = new ItemId(rawItemId);
57: 
58:         if (!itemRepository.existsById(itemId)) {
59:             throw new ShopException("Item does not exist");
60:         }
61: 
62:         if (orderQueryPort.isItemUsedInOrders(itemId)) {
63:             throw new ShopException("Item is used in an order and cannot be deleted");
64:         }
65: 
66:         if (shoppingBasketQueryPort.isItemInBasket(itemId)) {
67:             throw new ShopException("Item is in a shopping basket and cannot be deleted");
68:         }
69: 
70:         if (stockLevelQueryPort.isItemInStock(itemId.getId())) {
71:             throw new ShopException("Item is still in stock and cannot be deleted");
72:         }
73: 
74:         itemRepository.deleteById(itemId);
75:     }
76: 
77:     public MoneyType getSellingPrice(UUID rawItemId) {
78:         ItemId itemId = new ItemId(rawItemId);
79: 
80:         return itemRepository.findById(itemId)
81:                 .map(Item::getSellingPrice)
82:                 .orElseThrow(() -> new ShopException("Item not found"));
83:     }
84: 
85:     public void deleteItemCatalog() {
86:         itemRepository.deleteAll();
87:     }
88: }
89: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ItemQueryImplService.java ---
1: package thkoeln.archilab.ecommerce.solution.item.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
5: import thkoeln.archilab.ecommerce.solution.item.domain.ItemRepository;
6: import thkoeln.archilab.ecommerce.solution.item.queryport.ItemQueryPort;
7: 
8: import java.util.UUID;
9: 
10: @Service
11: public class ItemQueryImplService implements ItemQueryPort {
12: 
13:     private final ItemRepository itemRepository;
14: 
15:     public ItemQueryImplService(ItemRepository itemRepository) {
16:         this.itemRepository = itemRepository;
17:     }
18: 
19:     @Override
20:     public boolean itemExists(UUID itemId) {
21:         return itemRepository.existsById(new ItemId(itemId));
22:     }
23: }
24: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\Item.java ---
1: package thkoeln.archilab.ecommerce.solution.item.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.AccessLevel;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.domainprimitives.Money;
8: 
9: @Entity
10: @Getter
11: @NoArgsConstructor(access = AccessLevel.PROTECTED) // JPA
12: public class Item {
13: 
14:     @EmbeddedId
15:     private ItemId id = new ItemId();
16: 
17:     private String name;
18: 
19:     private String description;
20: 
21:     private Float size;
22: 
23:     @Embedded
24:     @AttributeOverrides({
25:             @AttributeOverride(name = "amount", column = @Column(name = "buying_amount")),
26:             @AttributeOverride(name = "currencyUnit", column = @Column(name = "buying_currency"))
27:     })
28:     private Money buyingPrice;
29: 
30:     @Embedded
31:     @AttributeOverrides({
32:             @AttributeOverride(name = "amount", column = @Column(name = "selling_amount")),
33:             @AttributeOverride(name = "currencyUnit", column = @Column(name = "selling_currency"))
34:     })
35:     private Money sellingPrice;
36: 
37:     public Item(String name, String description, Float size, Money buyingPrice, Money sellingPrice) {
38:         this.name = name;
39:         this.description = description;
40:         this.size = size;
41:         this.buyingPrice = buyingPrice;
42:         this.sellingPrice = sellingPrice;
43:     }
44: 
45:     public Money getSellingPrice() {
46:         return sellingPrice;
47:     }
48: 
49: }
50: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemId.java ---
1: package thkoeln.archilab.ecommerce.solution.item.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "item_id"))
15: public class ItemId extends GenericId {
16:     public ItemId(UUID id) {
17:         super(id);
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.item.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ItemIdConverter extends GenericIdConverter<ItemId> {
8:     public ItemIdConverter() {
9:         super(ItemId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.item.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: 
5: public interface ItemRepository extends JpaRepository<Item, ItemId> {
6:     boolean existsByName(String name);
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\queryport\ItemQueryPort.java ---
1: package thkoeln.archilab.ecommerce.solution.item.queryport;
2: 
3: import java.util.UUID;
4: 
5: public interface ItemQueryPort {
6:     boolean itemExists(UUID itemId);
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\queryport\OrderQueryPort.java ---
1: package thkoeln.archilab.ecommerce.solution.item.queryport;
2: 
3: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
4: 
5: public interface OrderQueryPort {
6:     boolean isItemUsedInOrders(ItemId itemId);
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\queryport\ShoppingBasketQueryPort.java ---
1: package thkoeln.archilab.ecommerce.solution.item.queryport;
2: 
3: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
4: 
5: public interface ShoppingBasketQueryPort {
6:     boolean isItemInBasket(ItemId itemId);
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\queryport\StockLevelQueryPort.java ---
1: package thkoeln.archilab.ecommerce.solution.item.queryport;
2: 
3: import java.util.UUID;
4: 
5: public interface StockLevelQueryPort {
6:     boolean isItemInStock(UUID itemId);
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import jakarta.transaction.Transactional;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
7: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
8: import thkoeln.archilab.ecommerce.usecases.OrderUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
10: 
11: import java.util.Map;
12: import java.util.UUID;
13: 
14: @Service
15: @Transactional
16: public class OrderAdapterService implements OrderUseCases {
17: 
18:     private final OrderService orderService;
19: 
20:     public OrderAdapterService(OrderService orderService) {
21:         this.orderService = orderService;
22:     }
23: 
24:     @Override
25:     public Map<UUID, Integer> getOrderHistory(EmailAddressType clientEmailAddress) {
26:         return orderService.getOrderHistory(clientEmailAddress);
27:     }
28: 
29:     @Override
30:     public void deleteAllOrders() {
31:         orderService.deleteAllOrders();
32:     }
33: 
34:     @Override
35:     public Integer getOrderQuantForItem(UUID orderId, UUID itemId) {
36:         if (orderId == null || itemId == null) {
37:             throw new ShopException("OrderId or ItemId must not be null");
38:         }
39: 
40:         Order order = orderService.getOrderById(orderId);
41: 
42:         return order.getPositions().stream()
43:                 .filter(pos -> pos.getItemId().getId().equals(itemId))
44:                 .map(OrderPosition::getQuantity)
45:                 .findFirst()
46:                 .orElse(0);
47:     }
48: 
49:     @Override
50:     public UUID getFulfillmentCenterIdForOrder(UUID orderId) {
51:         if (orderId == null) throw new ShopException("OrderId must not be null");
52: 
53:         Order order = orderService.getOrderById(orderId);
54:         return order.getFulfillmentCenterId().getId(); // oder toUUID()
55:     }
56: 
57: 
58: }
59: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderQueryImplService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
5: import thkoeln.archilab.ecommerce.solution.item.queryport.OrderQueryPort;
6: import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
7: 
8: @Service
9: public class OrderQueryImplService implements OrderQueryPort {
10: 
11:     private final OrderRepository orderRepository;
12: 
13:     public OrderQueryImplService(OrderRepository orderRepository) {
14:         this.orderRepository = orderRepository;
15:     }
16: 
17:     @Override
18:     public boolean isItemUsedInOrders(ItemId itemId) {
19:         return orderRepository.findAll().stream()
20:                 .flatMap(order -> order.getPositions().stream())
21:                 .anyMatch(pos -> pos.getItemId().equals(itemId));
22:     }
23: }
24: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import jakarta.transaction.Transactional;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
7: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
8: import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
9: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
10: import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
11: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
12: import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: 
15: import java.util.HashMap;
16: import java.util.Map;
17: import java.util.UUID;
18: 
19: @Service
20: @Transactional
21: public class OrderService {
22: 
23:     private final OrderRepository orderRepository;
24:     private final ClientRepository clientRepository;
25: 
26:     public OrderService(OrderRepository orderRepository, ClientRepository clientRepository) {
27:         this.orderRepository = orderRepository;
28:         this.clientRepository = clientRepository;
29:     }
30: 
31:     public Map<UUID, Integer> getOrderHistory(EmailAddressType clientEmailAddress) {
32:         if (clientEmailAddress == null) {
33:             throw new ShopException("Email must not be null");
34:         }
35: 
36:         EmailAddress email = EmailAddress.of(clientEmailAddress.toString());
37:         Client client = clientRepository.findByEmail(email)
38:                 .orElseThrow(() -> new ShopException("Client not found"));
39: 
40:         Map<UUID, Integer> history = new HashMap<>();
41: 
42:         for (Order order : orderRepository.findAll()) {
43:             if (!order.getClientId().equals(client.getId())) continue;
44: 
45:             for (OrderPosition pos : order.getPositions()) {
46:                 history.merge(pos.getItemId().getId(), pos.getQuantity(), Integer::sum);
47:             }
48:         }
49: 
50:         return history;
51:     }
52: 
53:     public void deleteAllOrders() {
54:         orderRepository.deleteAll();
55:     }
56: 
57:     public Order getOrderById(UUID orderId) {
58:         return orderRepository.findById(new OrderId(orderId))
59:                 .orElseThrow(() -> new ShopException("Order not found"));
60:     }
61: 
62: 
63: }
64: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Getter;
5: import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
6: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterId;
7: 
8: import java.util.ArrayList;
9: import java.util.List;
10: 
11: @Entity
12: @Getter
13: @Table(name = "`order`")
14: public class Order {
15: 
16:     @EmbeddedId
17:     private OrderId id;
18: 
19:     @Embedded
20:     private ClientId clientId;
21: 
22:     @Embedded
23:     private FulfillmentCenterId fulfillmentCenterId;
24: 
25:     @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER, orphanRemoval = true)
26:     @JoinColumn(name = "order_id")
27:     private List<OrderPosition> positions = new ArrayList<>();
28: 
29:     protected Order() {
30:         // für JPA
31:     }
32: 
33:     public Order(ClientId clientId) {
34:         this.id = new OrderId();
35:         this.clientId = clientId;
36:     }
37: 
38:     public Order(ClientId clientId, FulfillmentCenterId fulfillmentCenterId) {
39:         this.id = new OrderId();
40:         this.clientId = clientId;
41:         this.fulfillmentCenterId = fulfillmentCenterId;
42:     }
43: 
44:     public void addPosition(OrderPosition position) {
45:         this.positions.add(position);
46:     }
47: 
48:     public List<OrderPosition> getPositions() {
49:         return positions;
50:     }
51: 
52:     @Transient
53:     private String clientName; // ⬅️ Nicht persistieren, nur für REST
54: 
55:     public void setClientName(String clientName) {
56:         this.clientName = clientName;
57:     }
58: 
59: 
60: }
61: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderId.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "order_id"))
15: public class OrderId extends GenericId {
16:     public OrderId(UUID id) {
17:         super(id);
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class OrderIdConverter extends GenericIdConverter<OrderId> {
8:     public OrderIdConverter() {
9:         super(OrderId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPosition.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.AccessLevel;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.domainprimitives.Money;
8: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
9: 
10: @Entity
11: @Getter
12: @NoArgsConstructor(access = AccessLevel.PROTECTED)
13: public class OrderPosition {
14: 
15:     @EmbeddedId
16:     private OrderPositionId id;
17: 
18:     @Embedded
19:     private ItemId itemId;
20: 
21:     @Embedded
22:     @AttributeOverrides({
23:             @AttributeOverride(name = "amount", column = @Column(name = "price_amount")),
24:             @AttributeOverride(name = "currencyUnit", column = @Column(name = "price_currency"))
25:     })
26:     private Money price;
27: 
28:     private int quantity;
29: 
30:     public OrderPosition(ItemId itemId, Money price, int quantity) {
31:         this.id = new OrderPositionId();
32:         this.itemId = itemId;
33:         this.price = price;
34:         this.quantity = quantity;
35:     }
36: }
37: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionId.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.GenericId;
8: 
9: import java.util.UUID;
10: 
11: @Embeddable
12: @NoArgsConstructor(access = lombok.AccessLevel.PROTECTED)
13: @AttributeOverride(name = "id", column = @Column(name = "order_position_id"))
14: public class OrderPositionId extends GenericId {
15:     public OrderPositionId(UUID id) {
16:         super(id);
17:     }
18: 
19:     public OrderPositionId(String id) {
20:         super(UUID.fromString(id));
21:     }
22: }
23: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class OrderPositionIdConverter extends GenericIdConverter<OrderPositionId> {
8:     public OrderPositionIdConverter() {
9:         super(OrderPositionId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: 
5: public interface OrderPositionRepository extends JpaRepository<OrderPosition, OrderPositionId> {
6: }
7: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: 
5: public interface OrderRepository extends JpaRepository<Order, OrderId> {
6: 
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\OrderPositionResponseDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import java.util.UUID;
4: 
5: public record OrderPositionResponseDTO(
6:         UUID itemId,
7:         int quantity
8: ) {}
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\OrderResponseDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import java.util.List;
4: import java.util.UUID;
5: 
6: public record OrderResponseDTO(
7:         UUID id,
8:         String clientName,
9:         UUID fulfillmentCenterId,
10:         List<OrderPositionResponseDTO> positions
11: ) {}
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import jakarta.transaction.Transactional;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
7: import thkoeln.archilab.ecommerce.domainprimitives.Money;
8: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
9: import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
10: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
11: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
12: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
15: 
16: import java.util.*;
17: 
18: import java.util.Set;
19: import java.util.UUID;
20: 
21: @Service
22: @Transactional
23: public class ShoppingBasketAdapterService implements ShoppingBasketUseCases {
24: 
25:     private final ShoppingBasketService domainService;
26: 
27: 
28:     public ShoppingBasketAdapterService(ShoppingBasketService domainService) {
29:         this.domainService = domainService;
30:     }
31: 
32:     @Override
33:     public void addItemToShoppingBasket(EmailAddressType clientEmailAddress, UUID itemId, int quantity) {
34:         if (clientEmailAddress == null) {
35:             throw new ShopException("Email address must not be null");
36:         }
37:         if (itemId == null) {
38:             throw new ShopException("Item ID must not be null");
39:         }
40:         if (quantity <= 0) {
41:             throw new ShopException("Quantity must be positive");
42:         }
43: 
44:         domainService.addItem(EmailAddress.of(clientEmailAddress.toString()), itemId, quantity);
45:     }
46: 
47:     @Override
48:     public void removeItemFromShoppingBasket(EmailAddressType clientEmailAddress, UUID itemId, int quantity) {
49:         if (clientEmailAddress == null) {
50:             throw new ShopException("Email address must not be null");
51:         }
52:         if (itemId == null) {
53:             throw new ShopException("Item ID must not be null");
54:         }
55:         if (quantity <= 0) {
56:             throw new ShopException("Quantity must be positive");
57:         }
58: 
59:         domainService.removeItem(EmailAddress.of(clientEmailAddress.toString()), itemId, quantity);
60:     }
61: 
62:     @Override
63:     public Map<UUID, Integer> getShoppingBasketAsMap(EmailAddressType clientEmailAddress) {
64:         return domainService.getBasketMap(EmailAddress.of(clientEmailAddress.toString()));
65:     }
66: 
67:     @Override
68:     public MoneyType getShoppingBasketAsMoneyValue(EmailAddressType clientEmailAddress) {
69:         return domainService.getBasketValue(EmailAddress.of(clientEmailAddress.toString()));
70:     }
71: 
72:     @Override
73:     public Set<UUID> checkout(EmailAddressType clientEmailAddress) {
74:         if (clientEmailAddress == null) {
75:             throw new ShopException("Email address must not be null");
76:         }
77:         return domainService.checkoutMultipleDeliveries(EmailAddress.of(clientEmailAddress.toString()));
78:     }
79: 
80:     @Override
81:     public void emptyAllShoppingBaskets() {
82:         domainService.clearAllBaskets();
83:     }
84:     
85:     public void addItemToShoppingBasketByBasketId(UUID basketId, UUID itemId, int quantity) {
86:         // Basket laden
87:         ShoppingBasket basket = domainService.getBasketById(basketId)
88:                 .orElseThrow(() -> new ShopException("Basket not found"));
89: 
90:         Client client = domainService.getClientById(basket.getClientId());
91:         EmailAddress email = (EmailAddress) client.getEmailAddress();
92:         domainService.addItem(email, itemId, quantity);
93: 
94:     }
95: 
96:     public void removeItemFromShoppingBasketByBasketId(UUID basketId, UUID itemId) {
97:         ShoppingBasket basket = domainService.getBasketById(basketId)
98:                 .orElseThrow(() -> new ShopException("Basket not found"));
99: 
100:         int quantity = basket.getItems().stream()
101:                 .filter(p -> p.getItemId().getId().equals(itemId))
102:                 .findFirst()
103:                 .map(p -> p.getQuantity())
104:                 .orElseThrow(() -> new ShopException("Item not found in basket"));
105: 
106:         EmailAddress email = (EmailAddress) domainService.getClientById(basket.getClientId()).getEmailAddress();
107:         domainService.removeItem(email, itemId, quantity);
108:     }
109: 
110:     public Set<Order> checkoutMultipleDeliveries(UUID basketId) {
111:         ShoppingBasket basket = domainService.getBasketById(basketId)
112:                 .orElseThrow(() -> new ShopException("Basket not found"));
113: 
114:         Client client = domainService.getClientById(basket.getClientId());
115: 
116:         // EmailAddressType → EmailAddress konvertieren
117:         EmailAddress email = EmailAddress.of(client.getEmailAddress().toString());
118: 
119:         return domainService.checkoutMultipleDeliveriesWithOrders(email);
120:     }
121: 
122:     public ShoppingBasketResponseDTO getOrCreateBasketForClient(UUID clientIdRaw) {
123:         ClientId clientId = new ClientId(clientIdRaw);
124:         Client client = domainService.getClientById(clientId);
125:         ShoppingBasket basket = domainService.getOrCreateBasketByClientId(clientId);
126:         Money total = (Money) domainService.getBasketValue(EmailAddress.of(client.getEmailAddress().toString()));
127:         return ShoppingBasketResponseDTO.from(basket, total);
128:     }
129: 
130: 
131: }
132: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import lombok.RequiredArgsConstructor;
4: import org.springframework.http.HttpStatus;
5: import org.springframework.http.ResponseEntity;
6: import org.springframework.web.bind.annotation.*;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
9: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
10: 
11: import java.util.*;
12: 
13: @RestController
14: @RequestMapping("/shoppingBaskets")
15: @RequiredArgsConstructor
16: public class ShoppingBasketController {
17: 
18:     private final ShoppingBasketAdapterService shoppingBasketAdapterService;
19: 
20:     @GetMapping(params = "clientId")
21:     public ResponseEntity<ShoppingBasketResponseDTO> getBasketByClientId(@RequestParam String clientId) {
22:         try {
23:             UUID uuid = UUID.fromString(clientId);
24:             return ResponseEntity.ok(shoppingBasketAdapterService.getOrCreateBasketForClient(uuid));
25:         } catch (IllegalArgumentException ex) {
26:             throw new ShopException("not found"); // wird zu 404 durch ExceptionHandler
27:         }
28:     }
29: 
30:     // Fallback-Mapping: kein clientId vorhanden
31:     @GetMapping
32:     public ResponseEntity<Void> handleMissingClientId() {
33:         return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).build(); // 405
34:     }
35: 
36:     @PostMapping("/{basketId}/positions")
37:     public ResponseEntity<Void> addItemToBasket(@PathVariable UUID basketId,
38:                                                 @RequestBody QuantityDTO quantityDTO) {
39:         shoppingBasketAdapterService.addItemToShoppingBasketByBasketId(
40:                 basketId,
41:                 quantityDTO.getItemId(),
42:                 quantityDTO.getQuantity());
43:         return ResponseEntity.status(HttpStatus.CREATED).build(); // 201
44:     }
45: 
46:     @DeleteMapping("/{basketId}/positions/{itemId}")
47:     public ResponseEntity<Void> deleteItemFromBasket(@PathVariable UUID basketId,
48:                                                      @PathVariable UUID itemId) {
49:         shoppingBasketAdapterService.removeItemFromShoppingBasketByBasketId(basketId, itemId);
50:         return ResponseEntity.ok().build(); // 200
51:     }
52: 
53:     @PostMapping("/{basketId}/checkout")
54:     public ResponseEntity<List<OrderResponseDTO>> checkout(@PathVariable UUID basketId) {
55:         Set<Order> createdOrders = shoppingBasketAdapterService.checkoutMultipleDeliveries(basketId);
56:         List<OrderResponseDTO> responseList = createdOrders.stream().map(order -> {
57:             UUID orderId = extractUUID(order.getId());
58:             UUID fcId = extractUUID(order.getFulfillmentCenterId());
59:             List<OrderPositionResponseDTO> positions = order.getPositions().stream()
60:                     .map(pos -> new OrderPositionResponseDTO(
61:                             extractUUID(pos.getItemId()),
62:                             pos.getQuantity()
63:                     )).toList();
64:             return new OrderResponseDTO(orderId, order.getClientName(), fcId, positions);
65:         }).toList();
66:         return ResponseEntity.status(HttpStatus.CREATED).body(responseList); // 201
67:     }
68: 
69:     @ExceptionHandler(ShopException.class)
70:     public ResponseEntity<String> handleShopException(ShopException exception) {
71:         String message = exception.getMessage();
72:         if (message != null) {
73:             if (message.toLowerCase().contains("not found")) {
74:                 return ResponseEntity.status(HttpStatus.NOT_FOUND).body(message); // 404
75:             }
76:             if (message.toLowerCase().contains("must") || message.toLowerCase().contains("invalid")) {
77:                 return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body(message); // 422
78:             }
79:         }
80:         return ResponseEntity.status(HttpStatus.CONFLICT).body(message); // 409
81:     }
82: 
83:     private UUID extractUUID(Object id) {
84:         try {
85:             var field = id.getClass().getSuperclass().getDeclaredField("id");
86:             field.setAccessible(true);
87:             return (UUID) field.get(id);
88:         } catch (Exception e) {
89:             throw new RuntimeException("Cannot extract UUID from GenericId", e);
90:         }
91:     }
92: 
93:     public static class QuantityDTO {
94:         private UUID itemId;
95:         private Integer quantity;
96:         public UUID getItemId() { return itemId; }
97:         public void setItemId(UUID itemId) { this.itemId = itemId; }
98:         public Integer getQuantity() { return quantity; }
99:         public void setQuantity(Integer quantity) { this.quantity = quantity; }
100:     }
101: }
102: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketQueryImplService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
5: import thkoeln.archilab.ecommerce.solution.item.queryport.ShoppingBasketQueryPort;
6: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
7: 
8: ;
9: 
10: @Service
11: public class ShoppingBasketQueryImplService implements ShoppingBasketQueryPort {
12: 
13:     private final ShoppingBasketRepository shoppingBasketRepository;
14: 
15:     public ShoppingBasketQueryImplService(ShoppingBasketRepository shoppingBasketRepository) {
16:         this.shoppingBasketRepository = shoppingBasketRepository;
17:     }
18: 
19:     @Override
20:     public boolean isItemInBasket(ItemId itemId) {
21:         return shoppingBasketRepository.findAll().stream()
22:                 .flatMap(basket -> basket.getItems().stream())
23:                 .anyMatch(part -> part.getItemId().equals(itemId));
24:     }
25: }
26: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketResponseDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.Money;
4: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
5: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
6: 
7: import java.util.ArrayList;
8: import java.util.List;
9: import java.util.UUID;
10: 
11: public class ShoppingBasketResponseDTO {
12:     public UUID id;
13:     public String totalSellingPrice;
14:     public List<ShoppingBasketPositionDTO> positions;
15: 
16: 
17:     public static ShoppingBasketResponseDTO from(ShoppingBasket basket, Money total) {
18:         ShoppingBasketResponseDTO dto = new ShoppingBasketResponseDTO();
19:         dto.id = basket.getId().getId(); // GenericId
20:         dto.totalSellingPrice = total.getFormatted();
21:         dto.positions = new ArrayList<>();
22: 
23:         for (ShoppingBasketPosition pos : basket.getItems()) {
24:             ShoppingBasketPositionDTO positionDTO = new ShoppingBasketPositionDTO();
25:             positionDTO.itemId = pos.getItemId().getId(); // UUID
26:             positionDTO.quantity = pos.getQuantity();
27:             dto.positions.add(positionDTO);
28:         }
29: 
30:         return dto;
31:     }
32: 
33:     public static class ShoppingBasketPositionDTO {
34:         public UUID itemId;
35:         public int quantity;
36:     }
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.stereotype.Component;
4: import thkoeln.archilab.ecommerce.InsufficientStockException;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
7: import thkoeln.archilab.ecommerce.domainprimitives.Money;
8: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
9: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
10: import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
11: import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
12: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenter;
13: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterComparator;
14: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.queryport.FulfillmentCenterQueryPort;
15: import thkoeln.archilab.ecommerce.solution.item.domain.Item;
16: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
17: import thkoeln.archilab.ecommerce.solution.item.domain.ItemRepository;
18: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
19: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
20: import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
21: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
22: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketId;
23: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
24: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
25: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
26: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
27: 
28: import java.util.*;
29: import java.util.stream.Collectors;
30: 
31: @Component
32: public class ShoppingBasketService {
33:     private final ShoppingBasketRepository basketRepo;
34:     private final ClientRepository clientRepo;
35:     private final ItemRepository itemRepo;
36:     private final OrderRepository orderRepo;
37:     private final FulfillmentCenterUseCases fulfillment;
38:     private final FulfillmentCenterQueryPort fulfillmentCenterQuery;
39: 
40: 
41:     public ShoppingBasketService(ShoppingBasketRepository basketRepo,
42:                                  ClientRepository clientRepo,
43:                                  ItemRepository itemRepo,
44:                                  OrderRepository orderRepo,
45:                                  FulfillmentCenterUseCases fulfillmentCenterUseCases,
46:                                  FulfillmentCenterQueryPort fulfillmentCenterQuery) {
47:         this.basketRepo = basketRepo;
48:         this.clientRepo = clientRepo;
49:         this.itemRepo = itemRepo;
50:         this.orderRepo = orderRepo;
51:         this.fulfillment = fulfillmentCenterUseCases;
52:         this.fulfillmentCenterQuery = fulfillmentCenterQuery;
53:     }
54: 
55:     public void addItem(EmailAddress email, UUID itemIdRaw, int quantity) {
56:         if (itemIdRaw == null || quantity <= 0) throw new ShopException("Invalid input");
57:         ItemId itemId = new ItemId(itemIdRaw);
58:         if (!itemRepo.existsById(itemId)) throw new ShopException("Item not found");
59: 
60:         Client client = getClient(email);
61:         ShoppingBasket basket = basketRepo.findByClientId(client.getId())
62:                 .orElse(new ShoppingBasket(client.getId()));
63: 
64:         basket.addItem(itemIdRaw, quantity);
65:         basketRepo.save(basket);
66:     }
67: 
68:     public void removeItem(EmailAddress email, UUID itemIdRaw, int quantity) {
69:         if (itemIdRaw == null || quantity <= 0) throw new ShopException("Invalid input");
70:         Client client = getClient(email);
71: 
72:         ShoppingBasket basket = basketRepo.findByClientId(client.getId())
73:                 .orElseThrow(() -> new ShopException("Basket not found"));
74:         try {
75:             basket.removeItem(itemIdRaw, quantity);
76:         } catch (IllegalArgumentException ex) {
77:             throw new ShopException(ex.getMessage());
78:         }
79: 
80:         basketRepo.save(basket);
81:     }
82: 
83:     public Map<UUID, Integer> getBasketMap(EmailAddress email) {
84:         Client client = getClient(email);
85:         return basketRepo.findByClientId(client.getId())
86:                 .map(basket -> basket.getItems().stream()
87:                         .collect(Collectors.toMap(p -> p.getItemId().getId(), ShoppingBasketPosition::getQuantity)))
88:                 .orElse(Collections.emptyMap());
89:     }
90: 
91:     public MoneyType getBasketValue(EmailAddress email) {
92:         Client client = getClient(email);
93:         ShoppingBasket basket = basketRepo.findByClientId(client.getId())
94:                 .orElseThrow(() -> new ShopException("Basket not found"));
95: 
96:         return basket.getItems().stream()
97:                 .map(pos -> {
98:                     Item item = itemRepo.findById(pos.getItemId())
99:                             .orElseThrow(() -> new ShopException("Item not found"));
100:                     return item.getSellingPrice().multiplyBy(pos.getQuantity());
101:                 })
102:                 .reduce(Money.of(0f, "EUR"), MoneyType::add);
103:     }
104: 
105:     public UUID checkout(EmailAddress email) {
106:         Client client = getClient(email);
107:         ShoppingBasket basket = basketRepo.findByClientId(client.getId())
108:                 .orElseThrow(() -> new ShopException("Basket not found"));
109:         if (basket.isEmpty()) throw new ShopException("Basket is empty");
110: 
111:         for (ShoppingBasketPosition pos : basket.getItems()) {
112:             UUID fcId = fulfillmentCenterQuery.findSuitableFulfillmentCenter(client.getPostalCode().toString());
113:             try {
114:                 fulfillment.removeFromStock(fcId, pos.getItemId().getId(), pos.getQuantity());
115:             } catch (ShopException e) {
116:                 throw new InsufficientStockException("Not enough stock for item " + pos.getItemId().getId());
117:             }
118:         }
119: 
120:         Order order = new Order(client.getId());
121:         for (ShoppingBasketPosition pos : basket.getItems()) {
122:             Item item = itemRepo.findById(pos.getItemId())
123:                     .orElseThrow(() -> new ShopException("Item not found"));
124:             order.addPosition(new OrderPosition(pos.getItemId(), item.getSellingPrice(), pos.getQuantity()));
125:         }
126: 
127:         orderRepo.save(order);
128:         basket.clear();
129:         basketRepo.save(basket);
130:         return order.getId().getId();
131:     }
132: 
133:     public Set<UUID> checkoutMultipleDeliveries(EmailAddress email) {
134:         Client client = getClient(email);
135:         ShoppingBasket basket = basketRepo.findByClientId(client.getId())
136:                 .orElseThrow(() -> new ShopException("Basket not found"));
137:         if (basket.isEmpty()) throw new ShopException("Basket is empty");
138: 
139:         // Map<ItemId, Integer> aus ShoppingBasketPosition extrahieren
140:         Map<ItemId, Integer> remainingItems = basket.getItems().stream()
141:                 .collect(Collectors.toMap(ShoppingBasketPosition::getItemId, ShoppingBasketPosition::getQuantity));
142: 
143:         // Alle FulfillmentCenter laden
144:         List<FulfillmentCenter> centers = fulfillmentCenterQuery.getAllFulfillmentCenters();
145: 
146:         Set<UUID> orderIds = new HashSet<>();
147: 
148:         while (!remainingItems.isEmpty()) {
149:             // nach Kriterien sortieren
150:             ZipCode clientZip = ZipCode.of(client.getAddress().getZipCode().toString());
151:             centers.sort(new FulfillmentCenterComparator(remainingItems, clientZip));
152: 
153:             FulfillmentCenter bestCenter = centers.get(0);
154:             Set<ItemId> fulfillable = bestCenter.fulfillableShoppingBasketPositions(remainingItems);
155: 
156:             if (fulfillable.isEmpty()) {
157:                 throw new InsufficientStockException("No fulfillment center can deliver remaining items");
158:             }
159: 
160:             Order order = new Order(client.getId(), bestCenter.getId());
161: 
162:             for (ItemId itemId : fulfillable) {
163:                 int quantity = remainingItems.get(itemId);
164:                 Item item = itemRepo.findById(itemId)
165:                         .orElseThrow(() -> new ShopException("Item not found"));
166:                 order.addPosition(new OrderPosition(itemId, item.getSellingPrice(), quantity));
167: 
168:                 // Bestand reduzieren
169:                 fulfillment.removeFromStock(bestCenter.getId().getId(), itemId.getId(), quantity);
170:             }
171: 
172:             orderRepo.save(order);
173:             orderIds.add(order.getId().getId());
174: 
175:             // erfüllte Items entfernen
176:             for (ItemId itemId : fulfillable) {
177:                 remainingItems.remove(itemId);
178:             }
179:         }
180: 
181:         basket.clear();
182:         basketRepo.save(basket);
183:         return orderIds;
184:     }
185: 
186:     public void clearAllBaskets() {
187:         basketRepo.deleteAll();
188:     }
189: 
190:     private Client getClient(EmailAddress email) {
191:         return clientRepo.findByEmail(email)
192:                 .orElseThrow(() -> new ShopException("Client not found"));
193:     }
194: 
195:     public Optional<ShoppingBasket> getBasketByClientId(ClientId clientId) {
196:         return basketRepo.findByClientId(clientId);
197:     }
198: 
199:     public Client getClientById(ClientId clientId) {
200:         return clientRepo.findAll().stream()
201:                 .filter(c -> c.getId().getId().equals(clientId.getId()))
202:                 .findFirst()
203:                 .orElseThrow(() -> new ShopException("Client not found"));
204:     }
205: 
206:     public ShoppingBasket getOrCreateBasketByClientId(ClientId clientId) {
207:         return basketRepo.findByClientId(clientId)
208:                 .orElseGet(() -> {
209:                     ShoppingBasket newBasket = new ShoppingBasket(clientId);
210:                     return basketRepo.save(newBasket);
211:                 });
212:     }
213: 
214: 
215: 
216: 
217:     public Optional<ShoppingBasket> getBasketById(UUID basketIdRaw) {
218:         return basketRepo.findById(new ShoppingBasketId(basketIdRaw));
219:     }
220: 
221:     public Set<Order> checkoutMultipleDeliveriesWithOrders(EmailAddress email) {
222:         Client client = getClient(email);
223:         ShoppingBasket basket = basketRepo.findByClientId(client.getId())
224:                 .orElseThrow(() -> new ShopException("Basket not found"));
225:         if (basket.isEmpty()) throw new ShopException("Basket is empty");
226: 
227:         Map<ItemId, Integer> remainingItems = basket.getItems().stream()
228:                 .collect(Collectors.toMap(ShoppingBasketPosition::getItemId, ShoppingBasketPosition::getQuantity));
229: 
230:         List<FulfillmentCenter> centers = fulfillmentCenterQuery.getAllFulfillmentCenters();
231:         Set<Order> createdOrders = new HashSet<>();
232: 
233:         while (!remainingItems.isEmpty()) {
234:             centers.sort(new FulfillmentCenterComparator(remainingItems, ZipCode.of(client.getAddress().getZipCode().toString())));
235:             FulfillmentCenter bestCenter = centers.get(0);
236:             Set<ItemId> fulfillable = bestCenter.fulfillableShoppingBasketPositions(remainingItems);
237: 
238:             if (fulfillable.isEmpty()) {
239:                 throw new InsufficientStockException("No fulfillment center can deliver remaining items");
240:             }
241: 
242:             Order order = new Order(client.getId(), bestCenter.getId());
243:             order.setClientName(client.getName());
244: 
245:             for (ItemId itemId : fulfillable) {
246:                 int quantity = remainingItems.get(itemId);
247:                 Item item = itemRepo.findById(itemId)
248:                         .orElseThrow(() -> new ShopException("Item not found"));
249:                 order.addPosition(new OrderPosition(itemId, item.getSellingPrice(), quantity));
250: 
251:                 fulfillment.removeFromStock(bestCenter.getId().getId(), itemId.getId(), quantity);
252:             }
253: 
254:             orderRepo.save(order);
255:             createdOrders.add(order);
256:             fulfillable.forEach(remainingItems::remove);
257:         }
258: 
259:         basket.clear();
260:         basketRepo.save(basket);
261:         return createdOrders;
262:     }
263: 
264: 
265: }
266: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.AccessLevel;
5: import lombok.Getter;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
8: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
9: 
10: import java.util.ArrayList;
11: import java.util.List;
12: import java.util.Optional;
13: import java.util.UUID;
14: 
15: @Entity
16: @Getter
17: @Setter(AccessLevel.PRIVATE)
18: public class ShoppingBasket {
19: 
20:     @EmbeddedId
21:     private ShoppingBasketId id;
22: 
23:     @Embedded
24:     private ClientId clientId;
25: 
26:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
27:     @JoinColumn(name = "shopping_basket_id")
28:     private List<ShoppingBasketPosition> basketParts = new ArrayList<>();
29: 
30:     protected ShoppingBasket() {}
31: 
32:     public ShoppingBasket(ClientId clientId) {
33:         this.id = new ShoppingBasketId();
34:         this.clientId = clientId;
35:     }
36: 
37:     public void addItem(UUID itemIdRaw, int quantity) {
38:         ItemId itemId = new ItemId(itemIdRaw);
39:         Optional<ShoppingBasketPosition> existing = basketParts.stream()
40:                 .filter(p -> p.getItemId().equals(itemId))
41:                 .findFirst();
42: 
43:         if (existing.isPresent()) {
44:             existing.get().increase(quantity);
45:         } else {
46:             basketParts.add(new ShoppingBasketPosition(itemId, quantity));
47:         }
48:     }
49: 
50:     public void removeItem(UUID itemIdRaw, int quantity) {
51:         ItemId itemId = new ItemId(itemIdRaw);
52:         ShoppingBasketPosition position = basketParts.stream()
53:                 .filter(p -> p.getItemId().equals(itemId))
54:                 .findFirst()
55:                 .orElseThrow(() -> new IllegalArgumentException("Item not in basket"));
56: 
57:         position.decrease(quantity);
58:         if (position.isEmpty()) {
59:             basketParts.remove(position);
60:         }
61:     }
62: 
63:     public void clear() {
64:         basketParts.clear();
65:     }
66: 
67:     public boolean isEmpty() {
68:         return basketParts.isEmpty();
69:     }
70: 
71:     public List<ShoppingBasketPosition> getItems() {
72:         return basketParts;
73:     }
74: }
75: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.GenericId;
8: 
9: import java.util.UUID;
10: 
11: @Embeddable
12: @NoArgsConstructor(access = lombok.AccessLevel.PROTECTED)
13: @AttributeOverride(name = "id", column = @Column(name = "shopping_basket_id"))
14: public class ShoppingBasketId extends GenericId {
15:     public ShoppingBasketId(UUID id) {
16:         super(id);
17:     }
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ShoppingBasketIdConverter extends GenericIdConverter<ShoppingBasketId> {
8:     public ShoppingBasketIdConverter() {
9:         super(ShoppingBasketId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.Embedded;
4: import jakarta.persistence.EmbeddedId;
5: import jakarta.persistence.Entity;
6: import lombok.AccessLevel;
7: import lombok.Getter;
8: import lombok.NoArgsConstructor;
9: import lombok.Setter;
10: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
11: 
12: @Entity
13: @Getter
14: @Setter(AccessLevel.PRIVATE)
15: @NoArgsConstructor(access = AccessLevel.PROTECTED)
16: public class ShoppingBasketPosition {
17: 
18:     @EmbeddedId
19:     private ShoppingBasketPositionId id;
20: 
21:     @Embedded
22:     private ItemId itemId;
23: 
24:     private int quantity;
25: 
26:     public ShoppingBasketPosition(ItemId itemId, int quantity) {
27:         this.id = new ShoppingBasketPositionId();
28:         this.itemId = itemId;
29:         this.quantity = quantity;
30:     }
31: 
32:     public void increase(int amount) {
33:         if (amount <= 0) {
34:             throw new IllegalArgumentException("Quantity to increase must be positive");
35:         }
36:         this.quantity += amount;
37:     }
38: 
39: 
40:     public void decrease(int amount) {
41:         if (amount <= 0) {
42:             throw new IllegalArgumentException("Quantity to decrease must be positive");
43:         }
44:         if (amount > this.quantity) {
45:             throw new IllegalArgumentException("Not enough quantity to remove");
46:         }
47:         this.quantity -= amount;
48:     }
49: 
50: 
51:     public boolean isEmpty() {
52:         return this.quantity <= 0;
53:     }
54: }
55: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.GenericId;
8: 
9: import java.util.UUID;
10: 
11: @Embeddable
12: @NoArgsConstructor(access = lombok.AccessLevel.PROTECTED)
13: @AttributeOverride(name = "id", column = @Column(name = "shopping_basket_position_id"))
14: public class ShoppingBasketPositionId extends GenericId {
15:     public ShoppingBasketPositionId(UUID id) {
16:         super(id);
17:     }
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ShoppingBasketPositionIdConverter extends GenericIdConverter<ShoppingBasketPositionId> {
8:     public ShoppingBasketPositionIdConverter() {
9:         super(ShoppingBasketPositionId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: 
5: public interface ShoppingBasketPositionRepository extends JpaRepository<ShoppingBasketPosition, ShoppingBasketPositionId> {
6: 
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
5: 
6: import java.util.Optional;
7: 
8: public interface ShoppingBasketRepository extends JpaRepository<ShoppingBasket, ShoppingBasketId> {
9:     Optional<ShoppingBasket> findByClientId(ClientId clientId);
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\ClientRegistrationUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: 
11: /**
12:  * This interface contains methods needed in the context of use cases concerning the registration of a client.
13:  * The interface is probably incomplete, and will grow over time ...
14:  */
15: public interface ClientRegistrationUseCases {
16:     /**
17:      * Registers a new client
18:      *
19:      * @param name
20:      * @param emailAddress
21:      * @param physicalAddress
22:      * @throws ShopException if ...
23:      *      - the client with the given email address already exists
24:      *      - physicalAddress is null
25:      */
26:     public void register( String name, EmailAddressType emailAddress, PhysicalAddressType physicalAddress );
27: 
28: 
29:     /**
30:      * Changes the address of a client
31:      *
32:      * @param clientEmailAddress
33:      * @param clientEmailAddress
34:      * @param physicalAddress
35:      * @throws ShopException if ...
36:      *      - the client with the given email address does not exist,
37:      *      - physicalAddress is null
38:      */
39:     public void changeAddress( EmailAddressType clientEmailAddress,
40:                                PhysicalAddressType physicalAddress );
41: 
42: 
43:     /**
44:      * Returns the data of a client as an array of strings (name, emailAddress, street, city, zipCode)
45:      * @param clientEmailAddress
46:      * @return the client data
47:      * @throws ShopException the client with the given email address does not exist,
48:      */
49:     public ClientType getClientData( EmailAddressType clientEmailAddress );
50: 
51: 
52: 
53:     /**
54:      * Clears all clients, including all orders and shopping baskets
55:      */
56:     public void deleteAllClients();
57: }
58: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\ClientType.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
5: 
6: /**
7:  * This interface expresses the essence of a shop client
8:  */
9: public interface ClientType {
10:     String getName();
11:     EmailAddressType getEmailAddress();
12:     PhysicalAddressType getPhysicalAddress();
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\EmailAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface EmailAddressType {
6:     /**
7:      * @return the email address as a string
8:      */
9:     public String toString();
10: 
11: 
12:     /**
13:      * A special kind of "copy constructor": Returns a new email address object with
14:      * the same identifyer (the substring left of the "@" sign) as the current one, but
15:      * with a new domain substring (right of the "@" sign).
16:      * @param domainString - the new domain for the copied email address
17:      * @return the new email address
18:      * @throws ShopException if ...
19:      *     - domainString is null
20:      *     - the new email address would not be valid (see `of(...)` method)
21:      */
22:     public EmailAddressType sameIdentifyerDifferentDomain( String domainString );
23: 
24:     /**
25:      * Another special kind of "copy constructor": Returns a new email address object
26:      * with the same domain (the substring right of the "@" sign) as the current one, but
27:      * with a new identifyer substring (left of the "@" sign).
28:      * @param identifyerString - the new identifyer for the copied email address
29:      * @return the new email address
30:      * @throws ShopException if ...
31:      *     - identifyerString is null
32:      *     - the new email address would not be valid (see `of(...)` method)
33:      */
34:     public EmailAddressType sameDomainDifferentIdentifyer( String identifyerString );
35: 
36: 
37:     /**
38:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
39:      * implementing class to provide a static factory method (simply named "of(...)"),
40:      * which creates an email address, given as a string.
41:      * We specify this factory method here as a comment, using the Javadoc documentation style.
42:      *
43:      * @param emailAddressAsString - the email address as a string.
44:      *      We will use a much simplified validation method to check if the email address is valid:
45:      *      - it must contain exactly one '@' character.
46:      *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
47:      *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
48:      *      - the substrings before and after the '@' may contain one or several '.' as separators
49:      *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
50:      *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
51:      *        (for simplicity we do not allow any other domains)
52:      * @return a new EmailAddressType object matching the given email address
53:      * @throws ShopException if ...
54:      *      - emailAddressAsString is null
55:      *      - emailAddressAsString is not a valid email address (see above)
56:      */
57:      // public static EmailAddressType of( String emailAddressAsString );
58: }
59: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MoneyType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface MoneyType {
6:     /**
7:      * @return the amount of money
8:      */
9:     public Float getAmount();
10: 
11: 
12:     /**
13:      * @return the currency unit of the money
14:      */
15:     public String getCurrencyUnit();
16: 
17: 
18:     /**
19:      * @param otherMoney
20:      * @return this + otherMoney, as a new object
21:      * @throws ShopException if ...
22:      *      - otherMoney is null
23:      *      - otherMoney.currencyUnit != this.currencyUnit
24:      */
25:     public MoneyType add( MoneyType otherMoney );
26: 
27: 
28:     /**
29:      * @param otherMoney
30:      * @return this - otherMoney, as a new object
31:      * @throws ShopException if ...
32:      *      - otherMoney is null
33:      *      - otherMoney.currencyUnit != this.currencyUnit
34:      *      - otherMoney > this
35:      */
36:     public MoneyType subtract( MoneyType otherMoney );
37: 
38: 
39:     /**
40:      * @param factor
41:      * @return this * factor, as a new object
42:      * @throws ShopException if ...
43:      *     - factor < 0
44:      */
45:     public MoneyType multiplyBy( int factor );
46: 
47:     /**
48:      * @param otherMoney
49:      * @return true, if this > otherMoney
50:      * @throws ShopException if ...
51:      *      - otherMoney is null
52:      *      - otherMoney.currencyUnit != this.currencyUnit
53:      */
54:     public boolean largerThan( MoneyType otherMoney );
55: 
56: 
57:     /**
58:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
59:      * implementing class to provide a static factory method (simply named "of(...)"),
60:      * which creates a money object from an amount and a currency unit (as string).
61:      * We specify this factory method here as a comment, using the Javadoc documentation style.
62:      *
63:      * @param amount the amount of money (must be >= 0)
64:      * @param currencyUnit the currency unit of the money (allowed values: "EUR", "CHF")
65:      * @return a new Money object with the given amount and currency unit
66:      * @throws ShopException if ...
67:      *   - amount is null
68:      *   - amount < 0
69:      *   - currency unit is null
70:      *   - currency unit is not one of the allowed values
71:      */
72:      // public static MoneyType of( Float amount, String currencyUnit );
73: }
74: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PhysicalAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface PhysicalAddressType {
6:     /**
7:      * @return the street as a string
8:      */
9:     public String getStreet();
10: 
11:     /**
12:      * @return the city as a string
13:      */
14:     public String getCity();
15: 
16:     /**
17:      * @return the zip code
18:      */
19:     public ZipCodeType getZipCode();
20: 
21:     /**
22:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
23:      * implementing class to provide a static factory method (simply named "of(...)"),
24:      * which creates an zip code, given as a string.
25:      * We specify this factory method here as a comment, using the Javadoc documentation style.
26:      *
27:      * @param street the street as a string
28:      * @param city the city as a string
29:      * @param zipCode the zip code
30:      * @return the physical address object matching the parameters
31:      * @throws ShopException if ...
32:      *      - street is null or empty
33:      *      - city is null or empty
34:      *      - zipCode is null
35:      */
36:      // public static PhysicalAddressType of( String street, String city, ZipCodeType zipCode );
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\ZipCodeType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnore;
4: import thkoeln.archilab.ecommerce.ShopException;
5: 
6: public interface ZipCodeType {
7:     /**
8:      * @return the zip code as a string
9:      */
10:     public String toString();
11: 
12:     /**
13:      * You will need some idea of "imprecise difference" between two zip codes for properly
14:      * implementing fulfillment centers in your shopping platform. This method calculates such a
15:      * difference. You can decide for yourself what values you return, unless you comply
16:      * with the following rules.
17:      * - The return value is 0 if both zip codes are the same
18:      * - If not:
19:      *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
20:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
21:      *        So, 56733 and 56734 have the same difference as 56733 and 56739.
22:      *      - The difference grows if more digits (counted from the right side) differ.
23:      *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
24:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
25:      *        53876 and 54876 have the same difference as 53876 and 57261.
26:      *      - However, the difference between 5abcd and 6rstu must be smaller than the one
27:      *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
28:      *        one between 5abcd and 9rstu.
29:      *      - This last condition reflects the fact the first digits of a zip code marks a region
30:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
31:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
32:      *        other.
33:      * @param otherZipCode
34:      * @return the calculated difference
35:      * @throws ShopException if otherZipCode is null
36:      */
37:     public int difference( ZipCodeType otherZipCode );
38: 
39: 
40:     /**
41:      * For the currently used way of deciding on the best fitting fulfillment center for a order,
42:      * we need to know the first digit of the zip code.
43:      */
44:     @JsonIgnore
45:     public Integer getFirstDigitZipCode();
46: 
47: 
48:     /**
49:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
50:      * implementing class to provide a static factory method (simply named "of(...)"),
51:      * which creates an zip code, given as a string.
52:      * We specify this factory method here as a comment, using the Javadoc documentation style.
53:      *
54:      * @param zipCodeAsString - the zip code as a string.
55:      *      We will use a much simplified validation method to check if the zip code is valid:
56:      *      - It must contain exactly 5 digits.
57:      *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid zip code, but 20001 is valid)
58:      * @return a new zip code object matching the given string
59:      * @throws ShopException if ...
60:      *      - zipCodeAsString is null
61:      *      - zipCodeAsString is not a valid zip code (see above)
62:      */
63:      // public static ZipCodeType of( String zipCodeAsString );
64: }
65: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\FulfillmentCenterUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
9: 
10: import java.util.UUID;
11: 
12: /**
13:  * This interface contains methods needed in the context of handling the shop stock,
14:  * i.e. managing fulfillment centers, and adding / removing items in the fulfillment center.
15:  */
16: public interface FulfillmentCenterUseCases {
17:     /**
18:      *
19:      * @param name
20:      * @param physicalAddress
21:      * @return the id of the new fulfillment center
22:      * @throws ShopException if ...
23:      *      - name is null or empty
24:      *      - physicalAddress is null
25:      */
26:     public UUID addNewFulfillmentCenter( String name, PhysicalAddressType physicalAddress );
27: 
28: 
29:     /**
30:      * Deletes all fulfillment centers from the shop. Intended for testing purposes.
31:      */
32:     public void deleteAllFulfillmentCenters();
33: 
34: 
35:     /**
36:      * Adds a certain Quantity of a given item to the stock
37:      * @param fulfillmentCenterId
38:      * @param itemId
39:      * @param addedQuantFor
40:      * @throws ShopException if ...
41:      *      - fulfillmentCenterId is null
42:      *      - the fulfillment center with that id does not exist
43:      *      - itemId is null
44:      *      - the item with that id does not exist
45:      *      - addedQuantFor < 0
46:      */
47:     public void addToStock( UUID fulfillmentCenterId, UUID itemId, int addedQuantFor );
48: 
49: 
50:     /**
51:      * Removes a certain Quantity of a given item from the stock.
52:      * @param fulfillmentCenterId
53:      * @param itemId
54:      * @param removedQuantFor
55:      * @throws ShopException if ...
56:      *      - fulfillmentCenterId is null
57:      *      - the fulfillment center with that id does not exist
58:      *      - itemId is null
59:      *      - the item with that id does not exist
60:      *      - removedQuantFor < 0
61:      */
62:     public void removeFromStock( UUID fulfillmentCenterId, UUID itemId, int removedQuantFor );
63: 
64: 
65:     /**
66:      * Changes the total Quantity of a given item in the stock.
67:      * @param fulfillmentCenterId
68:      * @param itemId
69:      * @param newTotalQuantFor
70:      * @throws ShopException if ...
71:      *      - fulfillmentCenterId is null
72:      *      - the fulfillment center with that id does not exist
73:      *      - itemId is null
74:      *      - the item with that id does not exist
75:      *      - newTotalQuantFor < 0
76:      */
77:     public void changeStockTo( UUID fulfillmentCenterId, UUID itemId, int newTotalQuantFor );
78: 
79: 
80:     /**
81:      * Get the current stock of a given item in one specific fulfillment center.
82:      * @param fulfillmentCenterId
83:      * @param itemId
84:      * @return the current total stock of the item
85:      * @throws ShopException if ...
86:      *      - fulfillmentCenterId is null
87:      *      - the fulfillment center with that id does not exist
88:      *      - itemId is null
89:      *      - the item with that id does not exist
90:      */
91:     public int getAvailableStock( UUID fulfillmentCenterId, UUID itemId );
92: 
93: 
94: }
95: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\ItemCatalogUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: 
10: import java.util.UUID;
11: 
12: 
13: /**
14:  * This interface contains methods needed in the context of use cases concerning the item catalog.
15:  * The interface is probably incomplete, and will grow over time ...
16:  */
17: 
18: public interface ItemCatalogUseCases {
19:     /**
20:      * Adds a new item to the shop catalog
21:      * @param name
22:      * @param descriptionFor
23:      * @param size
24:      * @param buyingPrice
25:      * @param sellingPrice
26:      * @return the id of the new item
27:      * @throws ShopException if ...
28:      *      - the item id already exists,
29:      *      - name or description are null or empty,
30:      *      - the size is <= 0 (but can be null!),
31:      *      - the buying price is null or <= 0,
32:      *      - the buyingPrice is null,
33:      *      - the selling price is null,
34:      *      - the selling price is lower than the buyingPrice
35:      */
36:     public UUID addItemToCatalog( String name, String descriptionFor, Float size,
37:                                            MoneyType buyingPrice, MoneyType sellingPrice );
38: 
39: 
40:     /**
41:      * Removes a item from the shop catalog
42:      * @param itemId
43:      * @throws ShopException if
44:      *      - itemId is null
45:      *      - the item id does not exist
46:      *      - the item is still in stock
47:      *      - the item is still in a shopping basket, or referenced by a completed order
48:      */
49:     public void removeItemFromCatalog( UUID itemId );
50: 
51: 
52:     /**
53:      * Get the selling price of a given item
54:      * @param itemId
55:      * @return the selling price
56:      * @throws ShopException if ...
57:      *      - itemId is null,
58:      *      - the item with that id does not exist
59:      */
60:     public MoneyType getSellingPrice( UUID itemId );
61: 
62: 
63:     /**
64:      * Clears the item catalog, i.e. removes all items from the catalog, including all the stock,
65:      * all the reservations and all the orders.
66:      */
67:     public void deleteItemCatalog();
68: 
69: }
70: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ClientTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: 
4: import thkoeln.archilab.ecommerce.usecases.ClientType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
7: 
8: /**
9:  * This is a test helper interface provides access to predefined test data for
10:  * clients.
11:  */
12: public interface ClientTestHelper {
13:     /**
14:      * This method calls the use case implementation to register all clients specified in the
15:      * test data set.
16:      * If you use the debugger and want to identify _which_ test client you currently look at:
17:      * The indices are coded into the house number (in the client's physical address) and in the first
18:      * cipher of the zip code. This is the list of clients:
19:      *
20:      * +-------+-------------------+--------+---------------------
21:      * | Index | Name              | PLZ    | EmailAddress
22:      * +-------+-------------------+--------+---------------------
23:      * | 0     | Max Mueller       | 02314  | 99Z@example.com
24:      * | 1     | Sophie Schmitz    | 02368  | a@4.com
25:      * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
26:      * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
27:      * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
28:      * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
29:      * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
30:      * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
31:      * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
32:      * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
33:      * +-------+-------------------+--------+---------------------
34:      */
35:     void registerAllClients();
36: 
37: 
38:     /**
39:      * @return the number of test clients in the test data set.
40:      */
41:     int getNumberOfClients();
42: 
43: 
44:     /**
45:      * @param index the index of the client in the test data set.
46:      * @return the name of the test client with the given index.
47:      */
48:     String getClientName( int index );
49: 
50: 
51:     /**
52:      * @param index the index of the client in the test data set.
53:      * @return the email address of the test client with the given index.
54:      */
55:     EmailAddressType getClientEmailAddress( int index );
56: 
57: 
58:     /**
59:      * @param index the index of the client in the test data set.
60:      * @return the physical address of the test client with the given index.
61:      */
62:     PhysicalAddressType getClientPhysicalAddress( int index );
63: 
64: 
65:     /**
66:      * @param index the index of the client in the test data set.
67:      * @return the test client with the given index.
68:      */
69:     ClientType getClient( int index );
70: 
71: }
72: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
8: 
9: import java.io.File;
10: import java.io.IOException;
11: import java.lang.reflect.InvocationTargetException;
12: import java.lang.reflect.Method;
13: import java.lang.reflect.Modifier;
14: import java.net.URL;
15: import java.net.URLDecoder;
16: import java.nio.charset.StandardCharsets;
17: import java.util.Enumeration;
18: 
19: import static org.junit.jupiter.api.Assertions.*;
20: 
21: public class FactoryMethodInvoker {
22: 
23:     public static EmailAddressType instantiateEmailAddress( String emailAddressAsString ) {
24:         Method factoryMethod = null;
25:         try {
26:             Class<?> interfaceClass = Class.forName(
27:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType" );
28:             Class<?> implementingClass = findImplementation( interfaceClass );
29: 
30:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
31:             assertNotNull( factoryMethod );
32:             int modifiers = factoryMethod.getModifiers();
33:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
34:         } catch (Exception e) {
35:             fail( "Failed to find implementation for EmailAddressType", e );
36:         }
37: 
38:         Object instance = null;
39:         try {
40:             instance = factoryMethod.invoke( null, emailAddressAsString );
41:         } catch (Exception e) {
42:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
43:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
44:             fail( "Failed to invoke factory method 'of' for '" + emailAddressAsString + "'", e );
45:         }
46:         assertNotNull( instance );
47:         return (EmailAddressType) instance;
48:     }
49: 
50: 
51:     public static PhysicalAddressType instantiatePhysicalAddress(
52:             String street, String city, ZipCodeType zipCode ) {
53:         Method factoryMethod = null;
54:         try {
55:             Class<?> interfaceClass = Class.forName(
56:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType" );
57:             Class<?> implementingClass = findImplementation( interfaceClass );
58: 
59:             factoryMethod = implementingClass.getDeclaredMethod( "of",
60:                     String.class, String.class, ZipCodeType.class );
61:             assertNotNull( factoryMethod );
62:             int modifiers = factoryMethod.getModifiers();
63:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
64:         } catch (Exception e) {
65:             fail( "Failed to find implementation for PhysicalAddressType", e );
66:         }
67: 
68:         Object instance = null;
69:         try {
70:             instance = factoryMethod.invoke( null, street, city, zipCode );
71:         } catch (Exception e) {
72:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
73:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
74:             fail( "Failed to invoke factory method 'of' for '" +
75:                     street + "', '" + city + "', '" + zipCode + "'", e );
76:         }
77:         assertNotNull( instance );
78:         return (PhysicalAddressType) instance;
79:     }
80: 
81: 
82:     public static ZipCodeType instantiateZipCode( String zipCodeAsString ) {
83:         Method factoryMethod = null;
84:         try {
85:             Class<?> interfaceClass = Class.forName(
86:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType" );
87:             Class<?> implementingClass = findImplementation( interfaceClass );
88: 
89:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
90:             assertNotNull( factoryMethod );
91:             int modifiers = factoryMethod.getModifiers();
92:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
93:         } catch (Exception e) {
94:             fail( "Failed to find implementation for ZipCodeType", e );
95:         }
96: 
97:         Object instance = null;
98:         try {
99:             instance = factoryMethod.invoke( null, zipCodeAsString );
100:         } catch (Exception e) {
101:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
102:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
103:             fail( "Failed to invoke factory method 'of' for '" + zipCodeAsString + "'", e );
104:         }
105:         assertNotNull( instance );
106:         return (ZipCodeType) instance;
107:     }
108: 
109: 
110:     public static MoneyType instantiateMoney( Float amount, String currencyUnit ) {
111:         Method factoryMethod = null;
112:         try {
113:             Class<?> interfaceClass = Class.forName(
114:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType" );
115:             Class<?> implementingClass = findImplementation( interfaceClass );
116: 
117:             factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
118:             assertNotNull( factoryMethod );
119:             int modifiers = factoryMethod.getModifiers();
120:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
121:         } catch (Exception e) {
122:             fail( "Failed to find implementation for MoneyType", e );
123:         }
124: 
125:         Object instance = null;
126:         try {
127:             instance = factoryMethod.invoke( null, amount, currencyUnit );
128:         } catch (Exception e) {
129:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
130:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
131:             fail( "Failed to invoke factory method 'of' for '" + amount + "', '" + currencyUnit + "'", e );
132:         }
133:         assertNotNull( instance );
134:         return (MoneyType) instance;
135:     }
136: 
137: 
138:     private static Class<?> findImplementation( Class<?> interfaceClass ) {
139:         Method factoryMethod = null;
140:         try {
141:             String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
142:             Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
143:             assertNotNull( implementingClass );
144:             return implementingClass;
145:         } catch (Exception e) {
146:             fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
147:             return null; // This line will never be reached, but it's necessary to satisfy the compiler
148:         }
149:     }
150: 
151: 
152:     private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
153:             throws ClassNotFoundException, IOException {
154:         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
155:         String path = packageName.replace( '.', '/' );
156:         Enumeration<URL> resources = classLoader.getResources( path );
157:         int count = 0;
158:         Class<?> result = null;
159:         while (resources.hasMoreElements()) {
160:             URL resource = resources.nextElement();
161:             File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
162:             File[] files = directory.listFiles();
163:             for ( File file : files ) {
164:                 if ( file.getName().endsWith( ".class" ) ) {
165:                     String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
166:                     Class<?> clazz = Class.forName( className );
167:                     if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
168:                         count++;
169:                         result = clazz;
170:                     }
171:                 }
172:             }
173:         }
174:         assertEquals( 1, count, "There should be exactly one implementing class" );
175:         return result;
176:     }
177: }
178: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FulfillmentCenterTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import java.util.UUID;
4: 
5: public interface FulfillmentCenterTestHelper {
6:     /**
7:      * Adds the test fulfillment centers to the system.
8:      * If you want to use the fulfillment centers, or want to know which index the fulfillment center has that you see
9:      * in the debugger, the following rules apply:
10:      * - The fulfillment center name will equal the street name of the physical address of the fulfillment center.
11:      * - The index number is visible in the house number. Example: fulfillment center 3 is located at
12:      *   "Ablageweg 3", and that is also its name.
13:      *
14:      *  The fulfillment centers are used in the tests as follows:
15:      *  - fulfillment center 0 holds all items 0 - 6, and is used for all tests where it is not relevant
16:      *    to split one shopping basket into several orders.
17:      *  - fulfillment centers 1 - 3 are used for the proximity tests, where you can deliver item 7 to
18:      *    to a client from the closest fulfillment center.
19:      *  - fulfillment centers 4 - 8 are used for the tests where you need to deliver items 8 - 14 in
20:      *    the most cost-efficient way, as multiple deliveries.
21:      *  - fulfillment center 9 is empty.
22:      *
23:      *  If withStock is true, then the fulfillment centers are filled with items. This happens
24:      *  according to the following rules:
25:      *  - items 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
26:      *    ONLY available in fulfillment center 0. (This means that item 0 out of stock everywhere.)
27:      *  - items 4, 5, 6 have a random stock between 30 and 130, also all ONLY in fulfillment center 0
28:           (these are the items used for tests on how to add and remove stock)
29:      *  - item 7 has a random stock between 30 and 130, distributed over
30:      *    fulfillment centers 1, 2, and 3. You can use this to test if the appropriate fulfillment center is found
31:      *    for a shopping basket with only item 7 in it, but with different quantities (<= 3, or > 3).
32:      *  - The other items (8 - 14) have also a random stock between 30 and 130, all distributed
33:      *    over several fulfillment centers. The distribution is done as follows:
34:      *    Assume that the item is available in <n> fulfillment centers. Then the first <n-1> fulfillment centers
35:      *    in the list (in ascending sequence) contain 3, and all the remaining stock is in the
36:      *    last fulfillment center.
37:      *
38:      *    This is how the stock of items could be distributed
39:      *    (Wx = fulfillment center x with its zip code, Px = item x,
40:      *    numbers marked with (*) are random large numbers):
41:      *
42:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
43:      *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
44:      *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
45:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
46:      *    | P0   |      |     |     |      |     |      |     |       |      |     |
47:      *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
48:      *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
49:      *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
50:      *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
51:      *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
52:      *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
53:      *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
54:      *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
55:      *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
56:      *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
57:      *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
58:      *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
59:      *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
60:      *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
61:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
62:      *
63:      * @param withStock if true, the stock of the items is added to the fulfillment center. Otherwise, the
64:      *                           the stock is not added and the fulfillment center is empty.
65:      */
66:     public void addAllFulfillmentCenters( boolean withStock );
67: 
68: 
69:     /**
70:      * @return the number of test fulfillment centers in the database
71:      */
72:     int numberOfFulfillmentCenters();
73: 
74: 
75:     /**
76:      * @param index
77:      * @return the id of the test fulfillment center at the given index
78:      */
79:     UUID getFulfillmentCenterId( int index );
80: 
81: 
82:     /**
83:      * @param fulfillmentCenterId - the id of the fulfillment center in the test data
84:      * @return the index of the test fulfillment center with that id
85:      */
86:     int findFulfillmentCenterIndex( UUID fulfillmentCenterId );
87: 
88: 
89:     /**
90:      * @param itemIndex - the index of the item in the test data
91:      * @param fulfillmentCenterIndex - the index of the fulfillment center in the test data
92:      * @return the number of items (stock) available in the fulfillment center at the given index
93:      */
94:     Integer getFulfillmentCenterStock( int fulfillmentCenterIndex, int itemIndex );
95: 
96: }
97: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\ClientTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
7: import thkoeln.archilab.ecommerce.usecases.ClientType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.MockClient;
12: 
13: import static org.junit.jupiter.api.Assertions.assertThrows;
14: 
15: /**
16:  * This is a test helper class that initializes and registers clients in the system,
17:  * using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class ClientTestHelperImpl implements ClientTestHelper {
22: 
23:     private ClientRegistrationUseCases clientRegistrationUseCases;
24: 
25:     @Autowired
26:     public ClientTestHelperImpl( ClientRegistrationUseCases clientRegistrationUseCases ) {
27:         this.clientRegistrationUseCases = clientRegistrationUseCases;
28:     }
29: 
30:     private final static String[] CLIENT_NAME = new String[]{
31:             "Max Mueller",
32:             "Sophie Schmitz",
33:             "Irene Mihalic",
34:             "Emilia Fischer",
35:             "Filiz Polat",
36:             "Lina Wagner",
37:             "Leon Becker",
38:             "Agnieszka Kalterer",
39:             "Felix Bauer",
40:             "Lara Schulz"
41:     };
42: 
43:     private final static EmailAddressType[] CLIENT_EMAIL = new EmailAddressType[]{
44:             FactoryMethodInvoker.instantiateEmailAddress( "99Z@example.com" ),
45:             FactoryMethodInvoker.instantiateEmailAddress( "a@4.com" ),
46:             FactoryMethodInvoker.instantiateEmailAddress( "irene@wearefreedomnow.com" ),
47:             FactoryMethodInvoker.instantiateEmailAddress( "emilia.fischer@example.com" ),
48:             FactoryMethodInvoker.instantiateEmailAddress( "j877d3@example.this.com" ),
49:             FactoryMethodInvoker.instantiateEmailAddress( "lina.marie.wagner@example.com" ),
50:             FactoryMethodInvoker.instantiateEmailAddress( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
51:             FactoryMethodInvoker.instantiateEmailAddress( "agna@here.ch" ),
52:             FactoryMethodInvoker.instantiateEmailAddress( "felix.bauer@example.org" ),
53:             FactoryMethodInvoker.instantiateEmailAddress( "lara.schulz@example.at" )
54:     };
55: 
56:     // The following array is used to create a list of physicalAddresss for the clients.
57:     // The indices are coded into the house number.
58:     // - Persons 0 - 5 are used for proximity tests with one fulfillment center.
59:     private final static PhysicalAddressType[] CLIENT_ADDRESS = new PhysicalAddressType[]{
60:             FactoryMethodInvoker.instantiatePhysicalAddress(
61:                     "Marktstraße 0", "Viertelstadt",
62:                     FactoryMethodInvoker.instantiateZipCode( "02314" ) ),
63:             FactoryMethodInvoker.instantiatePhysicalAddress(
64:                     "Hauptstraße 1", "Viertelstadt",
65:                     FactoryMethodInvoker.instantiateZipCode( "02368" ) ),
66:             FactoryMethodInvoker.instantiatePhysicalAddress(
67:                     "Kirchplatz 2", "Niemandstown",
68:                     FactoryMethodInvoker.instantiateZipCode( "12345" ) ),
69:             FactoryMethodInvoker.instantiatePhysicalAddress(
70:                     "Schulstraße 3", "Geisterhausen",
71:                     FactoryMethodInvoker.instantiateZipCode( "31463" ) ),
72:             FactoryMethodInvoker.instantiatePhysicalAddress(
73:                     "Rosenweg 4", "Kuhhausen",
74:                     FactoryMethodInvoker.instantiateZipCode( "72162" ) ),
75:             FactoryMethodInvoker.instantiatePhysicalAddress(
76:                     "Wiesenstraße 5", "Waldschenkensdorf",
77:                     FactoryMethodInvoker.instantiateZipCode( "82195" ) ),
78:             FactoryMethodInvoker.instantiatePhysicalAddress(
79:                     "Muehlenweg 6", "Koeln",
80:                     FactoryMethodInvoker.instantiateZipCode( "50667" ) ),
81:             FactoryMethodInvoker.instantiatePhysicalAddress(
82:                     "Goethestraße 7", "Frankfurt am Main",
83:                     FactoryMethodInvoker.instantiateZipCode( "60311" ) ),
84:             FactoryMethodInvoker.instantiatePhysicalAddress(
85:                     "Dorfstraße 8", "Stuttgart",
86:                     FactoryMethodInvoker.instantiateZipCode( "70173" ) ),
87:             FactoryMethodInvoker.instantiatePhysicalAddress(
88:                     "Bahnhofstraße 9", "Muenchen",
89:                     FactoryMethodInvoker.instantiateZipCode( "80331" ) )
90:     };
91: 
92:     private final static ClientType[] mockClients;
93: 
94:     static {
95:         mockClients = new ClientType[CLIENT_NAME.length];
96:         for ( int i = 0; i < CLIENT_NAME.length; i++ ) {
97:             mockClients[i] = new MockClient(
98:                     CLIENT_NAME[i], CLIENT_EMAIL[i], CLIENT_ADDRESS[i] );
99:         }
100:     }
101: 
102: 
103:     @Override
104:     public void registerAllClients() {
105:         for ( int i = 0; i < CLIENT_NAME.length; i++ ) {
106:             registerClient( CLIENT_NAME[i], CLIENT_EMAIL[i], CLIENT_ADDRESS[i] );
107:         }
108:     }
109: 
110: 
111:     private void registerClient( String name, EmailAddressType emailAddress, PhysicalAddressType physicalAddress ) {
112:         clientRegistrationUseCases.register( name, emailAddress, physicalAddress );
113:     }
114: 
115: 
116:     @Override
117:     public int getNumberOfClients() {
118:         return CLIENT_NAME.length;
119:     }
120: 
121: 
122:     @Override
123:     public String getClientName( int index ) {
124:         if ( index < 0 || index >= CLIENT_NAME.length ) {
125:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
126:         }
127:         return CLIENT_NAME[index];
128:     }
129: 
130: 
131:     @Override
132:     public EmailAddressType getClientEmailAddress( int index ) {
133:         if ( index < 0 || index >= CLIENT_NAME.length ) {
134:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
135:         }
136:         return CLIENT_EMAIL[index];
137:     }
138: 
139: 
140:     @Override
141:     public PhysicalAddressType getClientPhysicalAddress( int index ) {
142:         if ( index < 0 || index >= CLIENT_NAME.length ) {
143:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
144:         }
145:         return CLIENT_ADDRESS[index];
146:     }
147: 
148: 
149:     @Override
150:     public ClientType getClient( int index ) {
151:         if ( index < 0 || index >= CLIENT_NAME.length ) {
152:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
153:         }
154:         return mockClients[index];
155:     }
156: }
157: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\StockTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
7: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
8: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
12: 
13: import java.util.*;
14: 
15: /**
16:  * This is a test helper class that initializes and registers items (but without stock)
17:  * in the system, using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class StockTestHelperImpl
22:                         implements ItemTestHelper, FulfillmentCenterTestHelper {
23:     private ItemCatalogUseCases itemCatalogUseCases;
24:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
25:     private static Random random = new Random();
26: 
27:     private static final String EUR = "EUR";
28:     private static final int ITEM_NUMOF = 15;
29:     private static final Object[][] ITEM_DATA = new Object[][]{
30:             {null, "0-TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
31:                     1.5f, FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
32:                     FactoryMethodInvoker.instantiateMoney( 10.0f, EUR ),
33:                     "0"},
34:             {null, "1-EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
35:                     0.3f, FactoryMethodInvoker.instantiateMoney( 2.5f, EUR ),
36:                     FactoryMethodInvoker.instantiateMoney( 4.0f, EUR ),
37:                     "0"},
38:             {null, "2-MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
39:                     7.2f, FactoryMethodInvoker.instantiateMoney( 50.0f, EUR ),
40:                     FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
41:                     "0"},
42:             {null, "3-Gh-25", "Kompakter und leichter Akku für mobile Geräte",
43:                     null, FactoryMethodInvoker.instantiateMoney( 6.0f, EUR ),
44:                     FactoryMethodInvoker.instantiateMoney( 8.0f, EUR ),
45:                     "0"},
46:             {null, "4-MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
47:                     null, FactoryMethodInvoker.instantiateMoney( 0.6f, EUR ),
48:                     FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
49:                     "0"},
50:             {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
51:                     1.0f, FactoryMethodInvoker.instantiateMoney( 150.0f, EUR ),
52:                     FactoryMethodInvoker.instantiateMoney( 250.0f, EUR ),
53:                     "0"},
54:             {null, "6-Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
55:                     null, FactoryMethodInvoker.instantiateMoney( 0.3f, EUR ),
56:                     FactoryMethodInvoker.instantiateMoney( 0.5f, EUR ),
57:                     "0"},
58:             {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
59:                     6.0f, FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
60:                     FactoryMethodInvoker.instantiateMoney( 120.0f, EUR ),
61:                     "123"},
62:             {null, "8-JKL-67", "Wasserdichtes Gehäuse",
63:                     3.0f, FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
64:                     FactoryMethodInvoker.instantiateMoney( 1.2f, EUR ),
65:                     "467"},
66:             {null, "9-MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
67:                     5.5f, FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
68:                     FactoryMethodInvoker.instantiateMoney( 45.0f, EUR ),
69:                     "578"},
70:             {null, "10-PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
71:                     4.0f, FactoryMethodInvoker.instantiateMoney( 20.0f, EUR ),
72:                     FactoryMethodInvoker.instantiateMoney( 35.0f, EUR ),
73:                     "567"},
74:             {null, "11-STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
75:                     null, FactoryMethodInvoker.instantiateMoney( 200.0f, EUR ),
76:                     FactoryMethodInvoker.instantiateMoney( 350.0f, EUR ),
77:                     "478"},
78:             {null, "12-VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
79:                     null, FactoryMethodInvoker.instantiateMoney( 15.0f, EUR ),
80:                     FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
81:                     "5"},
82:             {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
83:                     3.5f, FactoryMethodInvoker.instantiateMoney( 60.0f, EUR ),
84:                     FactoryMethodInvoker.instantiateMoney( 100.0f, EUR ),
85:                     "78"},
86:             {null, "14-Nosedive", "Klammer zum Verschließen der Nase beim Tauchen",
87:                     5.0f, FactoryMethodInvoker.instantiateMoney( 2.0f, EUR ),
88:                     FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
89:                     "457"}
90:     };
91:     
92: 
93:     // These physical addresss are used for the fulfillment centers. The fulfillment center name will equal
94:     // the zip code of the site. Their index number will be visible in the house number.
95:     // The fulfillment centers are used as such:
96:     // - fulfillment center 0 is holds all items 0 - 6, and is used for all tests where multiple
97:     //   deliveries are irrelevant.
98:     // - fulfillment centers 1 - 3 are used for the proximity tests, where you can deliver items 7 to
99:     //   to a client from the closest fulfillment center.
100:     // - fulfillment centers 4 - 8 are used for the tests where you need to deliver items 8 - 14 in
101:     //   the most cost-efficient way, as multiple deliveries.
102:     // - fulfillment center 9 is empty.
103:     private final static int FULFILLMENT_CENTER_NUMOF = 10;
104:     private final static PhysicalAddressType[] FULFILLMENT_CENTER_PHYSICAL_ADDRESS = new PhysicalAddressType[]{
105:             FactoryMethodInvoker.instantiatePhysicalAddress(
106:                     "Stapelallee 0", "Potsdam",
107:                     FactoryMethodInvoker.instantiateZipCode( "14476" ) ),
108:             FactoryMethodInvoker.instantiatePhysicalAddress(
109:                     "Lagerhausstr. 1", "Viertelstadt",
110:                     FactoryMethodInvoker.instantiateZipCode( "02345" ) ),
111:             FactoryMethodInvoker.instantiatePhysicalAddress(
112:                     "Speicherplatz 2", "Viertelstadt",
113:                     FactoryMethodInvoker.instantiateZipCode( "02313" ) ),
114:             FactoryMethodInvoker.instantiatePhysicalAddress(
115:                     "Ablageweg 3", "Reichswürgen",
116:                     FactoryMethodInvoker.instantiateZipCode( "44923" ) ),
117:             FactoryMethodInvoker.instantiatePhysicalAddress(
118:                     "Paketstellenallee 4", "Düsseldorf",
119:                     FactoryMethodInvoker.instantiateZipCode( "40588" ) ),
120:             FactoryMethodInvoker.instantiatePhysicalAddress(
121:                     "Kaputte-Sachen-Straße 5", "Düren",
122:                     FactoryMethodInvoker.instantiateZipCode( "52355" ) ),
123:             FactoryMethodInvoker.instantiatePhysicalAddress(
124:                     "Aufbewahrungsweg 6", "Viernheim",
125:                     FactoryMethodInvoker.instantiateZipCode( "68519" ) ),
126:             FactoryMethodInvoker.instantiatePhysicalAddress(
127:                     "Paketallee 7", "Baden-Baden",
128:                     FactoryMethodInvoker.instantiateZipCode( "76532" ) ),
129:             FactoryMethodInvoker.instantiatePhysicalAddress(
130:                     "Sendenstr. 8", "Senden",
131:                     FactoryMethodInvoker.instantiateZipCode( "89250" ) ),
132:             FactoryMethodInvoker.instantiatePhysicalAddress(
133:                     "Schickweg 9", "Hohenroth",
134:                     FactoryMethodInvoker.instantiateZipCode( "97618" ) )
135:     };
136:     private final static UUID[] FULFILLMENT_CENTER_ID = new UUID[FULFILLMENT_CENTER_NUMOF];
137: 
138: 
139:     // These data structures contain the stock of the items in the fulfillment centers.
140:     // ITEM_STOCK is a map item name -> Integer[FULFILLMENT_CENTER_NUMOF].
141:     // The Integer[FULFILLMENT_CENTER_NUMOF] contains the stock of the item in each of
142:     // the fulfillment centers.
143:     //
144:     // The following rules apply:
145:     // - item 0 is out of stock
146:     // - item 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in fulfillment center 0
147:     // - item 4 / 5 / 6 have a random stock between 30 and 130, also all ONLY in fulfillment center 0
148:     //   (these are the items used for tests on how to add and remove stock)
149:     // - the others have a random stock between 30 and 130, distributed over several
150:     //   fulfillment centers. Here we follow this convention for simplicity:
151:     //   - Assume that the item is available in <n> fulfillment centers. Then the first <n-1> fulfillment centers
152:     //     in the list (in ascending sequence) contain 3, and all the remaining stock is in the
153:     //     last fulfillment center.
154: 
155:     private static final Map<String, Integer[]> ITEM_STOCK = new HashMap<>();
156: 
157:     static {
158:         // items 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
159:         ITEM_STOCK.put( (String) ITEM_DATA[0][1],
160:                 getStockDistribution( 0, (String) ITEM_DATA[0][6] ) );
161:         ITEM_STOCK.put( (String) ITEM_DATA[1][1],
162:                 getStockDistribution( 10, (String) ITEM_DATA[1][6] ) );
163:         ITEM_STOCK.put( (String) ITEM_DATA[2][1],
164:                 getStockDistribution( 20, (String) ITEM_DATA[2][6] ) );
165:         ITEM_STOCK.put( (String) ITEM_DATA[3][1],
166:                 getStockDistribution( 30, (String) ITEM_DATA[3][6] ) );
167: 
168:         // The other items have a random stock between 30 and 130,
169:         for ( int i = 4; i < ITEM_NUMOF; i++ ) {
170:             Integer totalNumber = random.nextInt( 100 ) + 30;
171:             Integer[] stockInFulfillmentCenters =
172:                     getStockDistribution( totalNumber, (String) ITEM_DATA[i][6] );
173:             ITEM_STOCK.put( (String) ITEM_DATA[i][1], stockInFulfillmentCenters );
174:         }
175:     }
176: 
177:     /**
178:      * This method creates a random stock distribution for the given item.
179:      *
180:      * @param totalQuantity - the total number of items in the fulfillment centers
181:      * @param zeroToNine  - a string with numbers between 0 and 9, representing the fulfillment centers
182:      * @return an Integer array with the stock distribution for the item, according to
183:      * the rules described above.
184:      */
185:     private static Integer[] getStockDistribution( Integer totalQuantity, String zeroToNine ) {
186:         Integer[] stockInFulfillmentCenters = new Integer[FULFILLMENT_CENTER_NUMOF];
187:         for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) stockInFulfillmentCenters[i] = 0;
188:         TreeSet<Integer> fulfillmentCenterIndices = getFulfillmentCenterIndices( zeroToNine );
189:         int numOfIndices = fulfillmentCenterIndices.size();
190:         int currentIndexNumber = 0;
191:         int currentQuantity = totalQuantity;
192:         for ( Integer fulfillmentCenterIndex : fulfillmentCenterIndices ) {
193:             currentIndexNumber++;
194:             if ( currentIndexNumber < numOfIndices ) {
195:                 stockInFulfillmentCenters[fulfillmentCenterIndex] = 3;
196:                 currentQuantity -= 3;
197:             } else {
198:                 stockInFulfillmentCenters[fulfillmentCenterIndex] = currentQuantity;
199:             }
200:         }
201:         return stockInFulfillmentCenters;
202:     }
203: 
204:     private static TreeSet<Integer> getFulfillmentCenterIndices( String zeroToNine ) {
205:         TreeSet<Integer> fulfillmentCenterIndices = new TreeSet<>();
206:         for ( int i = 0; i < zeroToNine.length(); i++ ) {
207:             fulfillmentCenterIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
208:         }
209:         return fulfillmentCenterIndices;
210:     }
211: 
212: 
213:     @Autowired
214:     public StockTestHelperImpl( ItemCatalogUseCases itemCatalogUseCases,
215:                                          FulfillmentCenterUseCases fulfillmentCenterUseCases ) {
216:         this.itemCatalogUseCases = itemCatalogUseCases;
217:         this.fulfillmentCenterUseCases = fulfillmentCenterUseCases;
218:     }
219: 
220: 
221:     @Override
222:     public void addAllItems() {
223:         int i = 0;
224:         for ( Object[] itemData : ITEM_DATA ) {
225:             UUID newId = itemCatalogUseCases.addItemToCatalog(
226:                     (String) itemData[1], (String) itemData[2],
227:                     (Float) itemData[3], (MoneyType) itemData[4],
228:                     (MoneyType) itemData[5] );
229:             // The first element of the item data is the id, which was initialized with null before, but can now be set
230:             ITEM_DATA[i][0] = newId;
231:             i++;
232:         }
233:     }
234: 
235: 
236:     @Override
237:     public int numberOfItems() {
238:         return ITEM_NUMOF;
239:     }
240: 
241: 
242:     @Override
243:     public UUID getItemId( int index ) {
244:         if ( index < 0 || index >= ITEM_NUMOF ) {
245:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
246:         }
247:         return (UUID) ITEM_DATA[index][0];
248:     }
249: 
250: 
251:     @Override
252:     public MoneyType getBuyingPrice( int index ) {
253:         if ( index < 0 || index >= ITEM_NUMOF ) {
254:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
255:         }
256:         return (MoneyType) ITEM_DATA[index][4];
257:     }
258: 
259: 
260:     @Override
261:     public MoneyType getSellingPrice( int index ) {
262:         if ( index < 0 || index >= ITEM_NUMOF ) {
263:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
264:         }
265:         return (MoneyType) ITEM_DATA[index][5];
266:     }
267: 
268: 
269:     @Override
270:     public void addAllFulfillmentCenters( boolean withStock ) {
271:         for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) {
272:             FULFILLMENT_CENTER_ID[i] = fulfillmentCenterUseCases.addNewFulfillmentCenter(
273:                     FULFILLMENT_CENTER_PHYSICAL_ADDRESS[i].getStreet(),
274:                     FULFILLMENT_CENTER_PHYSICAL_ADDRESS[i] );
275:         }
276:         if ( withStock ) {
277:             addAllStock();
278:         }
279:     }
280: 
281: 
282:     private void addAllStock() {
283:         for ( Object[] itemData : ITEM_DATA ) {
284:             Integer[] stockInFulfillmentCenters =
285:                     ITEM_STOCK.get( itemData[1] );
286:             for ( int iFulfillmentCenter = 0; iFulfillmentCenter < FULFILLMENT_CENTER_NUMOF; iFulfillmentCenter++ ) {
287:                 if ( stockInFulfillmentCenters[iFulfillmentCenter] > 0 )
288:                     fulfillmentCenterUseCases.addToStock(
289:                             FULFILLMENT_CENTER_ID[iFulfillmentCenter], (UUID) itemData[0],
290:                             stockInFulfillmentCenters[iFulfillmentCenter] );
291:             }
292:         }
293:     }
294: 
295: 
296:     @Override
297:     public int numberOfFulfillmentCenters() {
298:         return FULFILLMENT_CENTER_NUMOF;
299:     }
300: 
301: 
302:     @Override
303:     public UUID getFulfillmentCenterId( int index ) {
304:         if ( index < 0 || index >= FULFILLMENT_CENTER_NUMOF ) {
305:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
306:         }
307:         return FULFILLMENT_CENTER_ID[index];
308:     }
309: 
310: 
311:     @Override
312:     public Integer getFulfillmentCenterStock( int fulfillmentCenterIndex, int itemIndex ) {
313:         if ( fulfillmentCenterIndex < 0 || fulfillmentCenterIndex >= FULFILLMENT_CENTER_NUMOF ) {
314:             throw new IndexOutOfBoundsException( "Index out of bounds: " + fulfillmentCenterIndex );
315:         }
316:         if ( itemIndex < 0 || itemIndex >= ITEM_NUMOF ) {
317:             throw new IndexOutOfBoundsException( "Index out of bounds: " + itemIndex );
318:         }
319:         String itemName = (String) ITEM_DATA[itemIndex][1];
320:         Integer[] stockInFulfillmentCenters = ITEM_STOCK.get( itemName );
321:         Integer foundStock = stockInFulfillmentCenters[fulfillmentCenterIndex];
322:         return foundStock == null ? 0 : foundStock;
323:     }
324: 
325: 
326:     @Override
327:     public int findFulfillmentCenterIndex( UUID fulfillmentCenterId ) {
328:         for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) {
329:             if ( FULFILLMENT_CENTER_ID[i].equals( fulfillmentCenterId ) ) {
330:                 return i;
331:             }
332:         }
333:         throw new IllegalArgumentException( "No test fulfillment center with UUID id " + fulfillmentCenterId );
334:     }
335: 
336: 
337:     @Override
338:     public int findItemIndex( UUID itemId ) {
339:         for ( int iItemData = 0; iItemData < FULFILLMENT_CENTER_NUMOF; iItemData++ ) {
340:             Object[] itemData = ITEM_DATA[iItemData];
341:             if ( itemData[0].equals( itemId ) ) {
342:                 return iItemData;
343:             }
344:         }
345:         throw new IllegalArgumentException( "No test item with UUID id " + itemId );
346:     }
347: }
348: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ItemTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
4: 
5: import java.util.UUID;
6: 
7: public interface ItemTestHelper {
8:     /**
9:      * Adds all test items to the database.
10:      * If you use the debugger and want to identify _which_ test item you currently look at:
11:      * The indices are coded into the first number in the name string of the item, like e.g.
12:      * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
13:      */
14:     void addAllItems();
15: 
16: 
17:     /**
18:      * @return the number of test items in the database
19:      */
20:     int numberOfItems();
21: 
22: 
23:     /**
24:      * @param index
25:      * @return the id of the test item at the given index
26:      */
27:     UUID getItemId( int index );
28: 
29: 
30:     /**
31:      * @param itemId - the id of the item in the test data
32:      * @return the index of the test item with that id
33:      */
34:     int findItemIndex( UUID itemId );
35: 
36: 
37:     /**
38:      * @param index
39:      * @return the buying price of test item at the given index
40:      */
41:     MoneyType getBuyingPrice( int index );
42: 
43: 
44:     /**
45:      * @param index
46:      * @return the selling price of test item at the given index
47:      */
48:     MoneyType getSellingPrice( int index );
49: }
50: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockClient.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.Setter;
4: import thkoeln.archilab.ecommerce.usecases.ClientType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;
6: 
7: 
8: import java.util.Objects;
9: 
10: @Setter
11: public class MockClient implements ClientType {
12:     private String name;
13:     private EmailAddressType emailAddressType;
14:     private PhysicalAddressType physicalAddressType;
15: 
16: 
17:     public MockClient( String name, EmailAddressType emailAddressType, PhysicalAddressType physicalAddressType) {
18:         this.name = name;
19:         this.emailAddressType = emailAddressType;
20:         this.physicalAddressType = physicalAddressType;
21:     }
22: 
23:     @Override
24:     public String getName() {
25:         return name;
26:     }
27: 
28:     @Override
29:     public EmailAddressType getEmailAddress() {
30:         return emailAddressType;
31:     }
32: 
33:     @Override
34:     public PhysicalAddressType getPhysicalAddress() {
35:         return physicalAddressType;
36:     }
37: 
38:     @Override
39:     public boolean equals( Object o ) {
40:         if ( this == o ) return true;
41:         if ( !( o instanceof MockClient ) ) return false;
42:         MockClient that = (MockClient) o;
43:         return Objects.equals( getName(), that.getName() ) &&
44:                 Objects.equals( emailAddressType, that.emailAddressType ) &&
45:                 Objects.equals( physicalAddressType, that.physicalAddressType );
46:     }
47: 
48:     @Override
49:     public int hashCode() {
50:         return Objects.hash( getName(), emailAddressType, physicalAddressType );
51:     }
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.usecases.*;
6: 
7: /**
8:  * Removes everything :-)
9:  */
10: @Service
11: public class Purgatory {
12:     @Autowired
13:     private ClientRegistrationUseCases clientRegistrationUseCases;
14:     @Autowired
15:     private ShoppingBasketUseCases shoppingBasketUseCases;
16:     @Autowired
17:     private OrderUseCases orderUseCases;
18:     @Autowired
19:     private ItemCatalogUseCases itemCatalogUseCases;
20:     @Autowired
21:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
22: 
23:     public void deleteEverything() {
24:         orderUseCases.deleteAllOrders();
25:         shoppingBasketUseCases.emptyAllShoppingBaskets();
26:         fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
27:         clientRegistrationUseCases.deleteAllClients();
28:         itemCatalogUseCases.deleteItemCatalog();
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.context.ApplicationListener;
6: import org.springframework.context.annotation.Profile;
7: import org.springframework.context.event.ContextRefreshedEvent;
8: import org.springframework.stereotype.Component;
9: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
12: 
13: @Component
14: @Slf4j
15: @Profile("!test")
16: @SuppressWarnings("PMD")
17: public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
18:     private Purgatory purgatory;
19:     private ClientTestHelper clientTestHelper;
20:     private ItemTestHelper itemTestHelper;
21:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
22: 
23: 
24:     @Autowired
25:     public StartupListener( Purgatory purgatory,
26:                             ClientTestHelper clientTestHelper,
27:                             ItemTestHelper itemTestHelper,
28:                             FulfillmentCenterTestHelper fulfillmentCenterTestHelper ) {
29:         this.purgatory = purgatory;
30:         this.clientTestHelper = clientTestHelper;
31:         this.itemTestHelper = itemTestHelper;
32:         this.fulfillmentCenterTestHelper = fulfillmentCenterTestHelper;
33:     }
34: 
35:     @Override
36:     public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
37:         log.info( "StartupListener initializing master data ..." );
38:         purgatory.deleteEverything();
39:         clientTestHelper.registerAllClients();
40:         itemTestHelper.addAllItems();
41:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
42:     }
43: }
44: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\OrderUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
3:  */
4: package thkoeln.archilab.ecommerce.usecases;
5: 
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
9: 
10: import java.util.Map;
11: import java.util.UUID;
12: 
13: /**
14:  * This interface contains methods needed in the context of the order history of a client.
15:  */
16: public interface OrderUseCases {
17: 
18:     /**
19:      * Returns a map showing which items have been ordered by a client and how many of each item
20:      *
21:      * @param clientEmailAddress
22:      * @return the order history of the client (map is empty if the client has not ordered anything yet)
23:      * @throws ShopException if
24:      *      - clientEmailAddress is null
25:      *      - the client with the given email address does not exist
26:      */
27:     public Map<UUID, Integer> getOrderHistory( EmailAddressType clientEmailAddress );
28: 
29: 
30: 
31:     /**
32:      * @return the number of items in a given order. If the item is not a position of the order, the method
33:      *         returns 0. No exception is thrown.
34:      * @param orderId - the id of the order to be checked
35:      * @param itemId - the id of the item for which we want to know the quantity
36:      * @throws ShopException if
37:      *     - orderId is null, or doesn't exist in the system
38:      *     - itemId is null, or doesn't exist in the system
39:      */
40:     public Integer getOrderQuantForItem( UUID orderId, UUID itemId );
41: 
42: 
43:     /**
44:      * @return the id of the fulfillment center that is responsible for the given order
45:      * @param orderId - the id of the order to be checked
46:      * @throws ShopException if
47:      *      - orderId is null, or doesn't exist in the system
48:      */
49:     public UUID getFulfillmentCenterIdForOrder( UUID orderId );
50: 
51: 
52:     /**
53:      * Deletes all orders in the system
54:      */
55:     public void deleteAllOrders();
56: }
57: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingBasketUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, all rights reserved
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
10: 
11: import java.util.Map;
12: import java.util.Set;
13: import java.util.UUID;
14: 
15: /**
16:  * This interface contains methods needed in the context of use cases handling the shopping basket.
17:  * The interface is probably incomplete, and will grow over time ...
18:  */
19: public interface ShoppingBasketUseCases {
20:     /**
21:      * Adds a item to the cart of a client
22:      *
23:      * @param clientEmailAddress
24:      * @param itemId
25:      * @param quantFor
26:      * @throws ShopException if ...
27:      *          - clientEmailAddress is null,
28:      *          - the client with the given email address does not exist,
29:      *          - itemId is null,
30:      *          - the item with itemId does not exist
31:      *          - the Quantity is negative,
32:      */
33:     public void addItemToShoppingBasket( EmailAddressType clientEmailAddress,
34:                                                  UUID itemId, int quantFor );
35: 
36: 
37:     /**
38:      * Removes a item from the cart of a client
39:      *
40:      * @param clientEmailAddress
41:      * @param itemId
42:      * @param quantFor
43:      * @throws ShopException if ...
44:      *          - clientEmailAddress is null,
45:      *          - the client with the given email address does not exist,
46:      *          - itemId is null,
47:      *          - the item with itemId does not exist
48:      *          - the Quantity is negative
49:      *          - the item is not in the shopping basket in the requested Quantity
50:      */
51:     public void removeItemFromShoppingBasket( EmailAddressType clientEmailAddress,
52:                                                       UUID itemId, int quantFor );
53: 
54: 
55:     /**
56:      * Returns a map showing which items are in the cart of a client and how many of each item
57:      *
58:      * @param clientEmailAddress
59:      * @return the cart of the client (map is empty if the cart is empty)
60:      * @throws ShopException if
61:      *          - clientEmailAddress is null,
62:      *          - the client with the given email address does not exist
63:      */
64:     public Map<UUID, Integer> getShoppingBasketAsMap( EmailAddressType clientEmailAddress );
65: 
66: 
67:     /**
68:      * Returns the current value of all items in the cart of a client
69:      *
70:      * @param clientEmailAddress
71:      * @return the cart of the client
72:      * @throws ShopException if
73:      *          - clientEmailAddress is null,
74:      *          - the client with the given email address does not exist
75:      */
76:     public MoneyType getShoppingBasketAsMoneyValue( EmailAddressType clientEmailAddress );
77: 
78: 
79: 
80: 
81:     /**
82:      * Checks out the cart of a client
83:      *
84:      * @param clientEmailAddress
85:      * @return A set of ids belonging to orders that were created during the checkout. If the shopping basket can
86:      *         only be served from more than one fulfillment center, each delivery from a fulfillment center gets a
87:      *         dedicated order. I.e. if there is just one delivery, then the set will contain just one order id.
88:      *         If there are multiple deliveries, the set will contain multiple order ids.
89:      * @throws ShopException if
90:      *      - clientEmailAddress is null or empty
91:      *      - the client with the given email address does not exist, or if the cart is empty
92:      * @throws
93:      *      - ShopException if clientEmailAddress is null
94:      *      - InsufficientStockException if there is not enough stock level for to serve the order
95:      *        for all items in the shopping basket
96:      */
97:     public Set<UUID> checkout( EmailAddressType clientEmailAddress );
98: 
99: 
100:     /**
101:      * Empties all shopping baskets in the system
102:      */
103:     public void emptyAllShoppingBaskets();
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import org.springframework.boot.test.context.TestConfiguration;
4: import org.springframework.context.annotation.Bean;
5: import org.springframework.test.web.servlet.MockMvc;
6: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
7: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
8: 
9: 
10: @TestConfiguration
11: public class RESTTestHelperConfiguration {
12: 
13:     @Bean
14:     public ShoppingBasketRESTHelper shoppingBasketRESTHelper(
15:             MockMvc mockMvc, ItemCatalogUseCases itemCatalogUseCases ) {
16:         return new ShoppingBasketRESTHelperImpl( mockMvc, itemCatalogUseCases );
17:     }
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingBasketRESTHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import com.fasterxml.jackson.databind.ObjectMapper;
5: import lombok.AllArgsConstructor;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import lombok.Setter;
9: import lombok.extern.slf4j.Slf4j;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.MvcResult;
12: import org.springframework.test.web.servlet.ResultActions;
13: import org.springframework.test.web.servlet.ResultMatcher;
14: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
15: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
18: 
19: import java.util.Map;
20: import java.util.UUID;
21: 
22: import static org.springframework.http.MediaType.APPLICATION_JSON;
23: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
24: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
25: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
26: 
27: @Slf4j
28: public class ShoppingBasketRESTHelperImpl implements ShoppingBasketRESTHelper {
29:     private MockMvc mockMvc;
30:     private ItemCatalogUseCases itemCatalogUseCases;
31: 
32:     private static final ResultMatcher CREATED = status().isCreated();
33:     private static final ResultMatcher OK = status().isOk();
34: 
35:     public ShoppingBasketRESTHelperImpl( MockMvc mockMvc, ItemCatalogUseCases itemCatalogUseCases ) {
36:         this.mockMvc = mockMvc;
37:         this.itemCatalogUseCases = itemCatalogUseCases;
38:     }
39: 
40: 
41:     @Override
42:     public UUID getQueryShoppingBasket( EmailAddressType emailAddress, Map<UUID, Integer> quantityMap )
43:             throws Exception {
44:         // first query the clients API to get the proper clientId
45:         UUID clientId;
46:         String clientUri = "/clients?emailAddress=" + emailAddress.toString();
47:         MvcResult clientGetResult = mockMvc.perform( get( clientUri ) )
48:                 .andExpect( status().isOk() )
49:                 .andReturn();
50:         ObjectMapper objectMapper = new ObjectMapper();
51:         IdDTO idDTO = objectMapper.readValue( clientGetResult.getResponse().getContentAsString(), IdDTO.class );
52:         clientId = idDTO.getId();
53: 
54:         // then query the shopping basket API and extract the shopping basket id
55:         String shoppingBasketUri = "/shoppingBaskets?clientId=" + clientId.toString();
56:         ResultActions resultActions = mockMvc.perform( get( shoppingBasketUri ) )
57:                 .andExpect( status().isOk() );
58:         idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
59:         UUID shoppingBasketId = idDTO.getId();
60: 
61:         // additional checks, if desired
62:         if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
63:         return shoppingBasketId;
64:     }
65: 
66: 
67:     private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
68:         if ( quantityMap == null ) return;
69:         int numOfItems = quantityMap.size();
70:         resultActions.andExpect( jsonPath( "$.positions.length()" ).value( numOfItems ) );
71:         float totalSellingPriceAsFloat = 0f;
72:         for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
73:             UUID itemId = entry.getKey();
74:             Integer quantity = entry.getValue();
75:             resultActions.andExpect( jsonPath( "$.positions.[?(@.itemId == '" + itemId + "')].quantity" )
76:                     .value( quantity ) );
77:             MoneyType sellingPrice = itemCatalogUseCases.getSellingPrice( itemId );
78:             totalSellingPriceAsFloat += sellingPrice.getAmount() * quantity;
79:         }
80:         // last thing - check the total selling price
81:         String totalSellingPriceString = String.format( "%.2f €", totalSellingPriceAsFloat );
82:         resultActions
83:                 .andExpect( jsonPath( "$.totalSellingPrice" ).value( totalSellingPriceString ) );
84:     }
85: 
86: 
87:     @Override
88:     public void addItemToShoppingBasket( UUID shoppingBasketId, UUID itemId, Integer quantity )
89:             throws Exception {
90:         addItemToShoppingBasket( shoppingBasketId, itemId, quantity, null );
91:     }
92: 
93: 
94:     @Override
95:     public void addItemToShoppingBasket( UUID shoppingBasketId, UUID itemId, Integer quantity,
96:                                                   ResultMatcher expectedStatus ) throws Exception {
97:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
98:         ObjectMapper objectMapper = new ObjectMapper();
99:         QuantityDTO dto = new QuantityDTO( itemId, quantity );
100:         String quantityJson = objectMapper.writeValueAsString( dto );
101:         mockMvc.perform( post( "/shoppingBaskets/" + shoppingBasketId + "/positions" )
102:                         .contentType( APPLICATION_JSON ).content( quantityJson ) )
103:                 .andExpect( status );
104:     }
105: 
106: 
107: 
108:     @Override
109:     public void deleteItemFromShoppingBasket( UUID shoppingBasketId, UUID itemId )
110:             throws Exception {
111:         deleteItemFromShoppingBasket( shoppingBasketId, itemId, null );
112:     }
113: 
114: 
115: 
116:     @Override
117:     public void deleteItemFromShoppingBasket( UUID shoppingBasketId, UUID itemId,
118:                                                       ResultMatcher expectedStatus ) throws Exception {
119:         ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
120:         String uri = "/shoppingBaskets/" + shoppingBasketId + "/positions/" + itemId;
121:         mockMvc.perform( delete( uri ) ).andExpect( status );
122:     }
123: 
124: 
125:     @Override
126:     public void checkout( UUID shoppingBasketId, String expectedClientName,
127:                           ResultMatcher expectedStatus,
128:                           Map<UUID, Map<UUID, Integer>> expectedOrders ) throws Exception {
129:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
130:         String uri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
131:         MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
132:         ObjectMapper objectMapper = new ObjectMapper();
133: 
134:         // check the response content
135:         if ( expectedOrders != null || expectedClientName != null ) {
136:             String responseContent = result.getResponse().getContentAsString();
137:             log.info( "ShoppingBasketRESTHelperImpl - checkout: found response content " + responseContent );
138:             OrderDTO[] orders = objectMapper.readValue( responseContent, OrderDTO[].class );
139:             checkExpectedClientName( expectedClientName, orders );
140:             checkExpectedOrders( expectedOrders, orders );
141:         }
142:     }
143: 
144: 
145:     private void checkExpectedClientName( String expectedClientName, OrderDTO[] orders ) {
146:         if ( expectedClientName == null ) return;
147:         for ( OrderDTO order : orders ) {
148:             if ( !order.getClientName().equals( expectedClientName ) ) {
149:                 throw new AssertionError( "Expected clientName '" + expectedClientName +
150:                         "' but got '" + order.getClientName() + "'" );
151:             }
152:         }
153:     }
154: 
155: 
156:     private void checkExpectedOrders( Map<UUID, Map<UUID, Integer>> expectedOrders,
157:                                             OrderDTO[] orders ) {
158:         if ( expectedOrders == null ) return;
159:         for ( OrderDTO order : orders ) {
160:             UUID fulfillmentCenterId = order.getFulfillmentCenterId();
161:             Map<UUID, Integer> expectedQuantities = expectedOrders.get( fulfillmentCenterId );
162:             if ( expectedQuantities == null ) {
163:                 throw new AssertionError( "No expected quantities for fulfillment center " + fulfillmentCenterId );
164:             }
165:             QuantityDTO[] positions = order.getPositions();
166:             for ( QuantityDTO quantityDTO : positions ) {
167:                 UUID itemId = quantityDTO.getItemId();
168:                 Integer expectedQuantity = expectedQuantities.get( itemId );
169:                 if ( expectedQuantity == null ) {
170:                     throw new AssertionError( "No expected quantity for item " + itemId +
171:                             " in fulfillment center " + fulfillmentCenterId );
172:                 }
173:                 if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
174:                     throw new AssertionError( "Expected quantity " + expectedQuantity + " for item " +
175:                             itemId + " in fulfillment center " + fulfillmentCenterId +
176:                             ", but got " + quantityDTO.getQuantity() );
177:                 }
178:             }
179:         }
180:     }
181: 
182: 
183:     /**
184:      * A DTO containing just a quantity, used in testing.
185:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
186:      * Therefore, constructors and getters/setters are manually defined.
187:      */
188:     @NoArgsConstructor
189:     @JsonIgnoreProperties(ignoreUnknown = true)
190:     private static class QuantityDTO {
191:         private UUID itemId;
192:         private Integer quantity;
193: 
194:         public QuantityDTO( UUID itemId, Integer quantity ) {
195:             this.itemId = itemId;
196:             this.quantity = quantity;
197:         }
198:         public UUID getItemId() {
199:             return itemId;
200:         }
201:         public Integer getQuantity() {
202:             return quantity;
203:         }
204:         public void setItemId( UUID itemId ) {
205:             this.itemId = itemId;
206:         }
207:         public void setQuantity( Integer quantity ) {
208:             this.quantity = quantity;
209:         }
210:     }
211: 
212: 
213:     /**
214:      * A DTO containing just the id of an entity, used in testing.
215:      */
216:     @AllArgsConstructor
217:     @NoArgsConstructor
218:     @Getter
219:     @Setter
220:     @JsonIgnoreProperties(ignoreUnknown = true)
221:     private static class IdDTO {
222:         private UUID id;
223:     }
224: 
225: 
226:     /**
227:      * A DTO containing the order data, used in testing.
228:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
229:      * Therefore, constructors and getters/setters are manually defined.
230:      */
231:     @NoArgsConstructor
232:     @JsonIgnoreProperties(ignoreUnknown = true)
233:     private static class OrderDTO {
234:         private UUID id;
235:         private String clientName;
236:         private UUID fulfillmentCenterId;
237:         private QuantityDTO[] positions;
238: 
239:         public UUID getId() {
240:             return id;
241:         }
242:         public String getClientName() {
243:             return clientName;
244:         }
245:         public UUID getFulfillmentCenterId() {
246:             return fulfillmentCenterId;
247:         }
248:         public QuantityDTO[] getPositions() {
249:             return positions;
250:         }
251:         public void setId( UUID id ) {
252:             this.id = id;
253:         }
254:         public void setClientName( String clientName ) {
255:             this.clientName = clientName;
256:         }
257:         public void setFulfillmentCenterId( UUID fulfillmentCenterId ) {
258:             this.fulfillmentCenterId = fulfillmentCenterId;
259:         }
260:         public void setPositions( QuantityDTO[] positions ) {
261:             this.positions = positions;
262:         }
263:     }
264: 
265: }
266: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingBasketRESTHelper.java ---
1: package thkoeln.archilab.ecommerce.helpers;
2: 
3: import org.springframework.test.web.servlet.ResultMatcher;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
5: 
6: import java.util.Map;
7: import java.util.UUID;
8: 
9: /**
10:  * A REST helper for shopping basket-related operations.
11:  * This interface defines methods to interact with a shopping basket via REST calls, such as querying, adding,
12:  * deleting, and checking out.
13:  */
14: public interface ShoppingBasketRESTHelper {
15:     /**
16:      * Executes a REST GET query on a shopping basket and returns its id, with the client's email address as a
17:      * starting point. The resulting shopping basket is checked against the given expected quantity map.
18:      * @param emailAddress The emailAddress of the client whose shopping basket is queried.
19:      * @param expectedQuantityMap A map of items and their quantities in the shopping basket. (If null, then don't check.)
20:      * @return The id of the client's shopping basket.
21:      * @throws Exception (whenever the REST call fails, or the shopping basket does not match the expected quantity map)
22:      */
23:     public UUID getQueryShoppingBasket( EmailAddressType emailAddress,
24:                                        Map<UUID, Integer> expectedQuantityMap ) throws Exception;
25: 
26: 
27:     /**
28:      * Adds a item to a shopping basket via a REST call.
29:      * @param shoppingBasketId Id of the shopping basket.
30:      * @param itemId Id of the item.
31:      * @param quantity Quantity of the item.
32:      * @throws Exception (whenever the REST call fails)
33:      */
34:     public void addItemToShoppingBasket( UUID shoppingBasketId, UUID itemId, Integer quantity )
35:             throws Exception;
36: 
37: 
38:     /**
39:      * Adds a item to a shopping basket via a REST call.
40:      * @param shoppingBasketId Id of the shopping basket.
41:      * @param itemId Id of the item.
42:      * @param quantity Quantity of the item.
43:      * @param expectedStatus expected status of the operation (null = CREATED)
44:      * @throws Exception (whenever the REST call fails or the status does not match)
45:      */
46:     public void addItemToShoppingBasket( UUID shoppingBasketId, UUID itemId, Integer quantity,
47:                                                   ResultMatcher expectedStatus ) throws Exception;
48: 
49: 
50:     /**
51:      * Deletes a item from a shopping basket via a REST call.
52:      * @param shoppingBasketId Id of the shopping basket.
53:      * @param itemId Id of the item.
54:      * @throws Exception (whenever the REST call fails)
55:      */
56:     public void deleteItemFromShoppingBasket( UUID shoppingBasketId, UUID itemId )
57:             throws Exception;
58: 
59: 
60:     /**
61:      * Deletes a item from a shopping basket via a REST call.
62:      * @param shoppingBasketId Id of the shopping basket.
63:      * @param itemId Id of the item.
64:      * @param expectedStatus expected status of the operation (null = OK)
65:      * @throws Exception (whenever the REST call fails or the status does not match)
66:      */
67:     public void deleteItemFromShoppingBasket( UUID shoppingBasketId, UUID itemId,
68:                                                       ResultMatcher expectedStatus ) throws Exception;
69: 
70: 
71:     /**
72:      * Checks out a shopping basket via REST call, and returns the id of the created order.
73:      * @param shoppingBasketId
74:      * @param expectedClientName expected name of the client who owns the shopping basket (null = don't check)
75:      * @param expectedStatus expected status of the operation (null = don't check)
76:      * @param expectedOrders the expected orders to be created as a result of the checkout. This is
77:      *                            a map of the following form:
78:      *                            <pre>
79:      *                               fulfillmentCenterId -> Map<itemId,Integer>
80:      *                            </pre>
81:      *                            where the inner map contains the items and their quantities
82:      * @return
83:      * @throws Exception
84:      */
85:     public void checkout( UUID shoppingBasketId, String expectedClientName,
86:                           ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedOrders )
87:            throws Exception;
88: }
89: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\client\ClientRegistrationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.client;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
12: import thkoeln.archilab.ecommerce.usecases.ClientType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
15: 
16: import static org.junit.jupiter.api.Assertions.*;
17: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
18: 
19: 
20: @SpringBootTest
21: public class ClientRegistrationTest {
22:     @Autowired
23:     private ClientRegistrationUseCases clientRegistrationUseCases;
24:     @Autowired
25:     private Purgatory purgatory;
26:     @Autowired
27:     private ClientTestHelper clientTestHelper;
28: 
29:     private EmailAddressType nonExistingEmailAddress;
30:     private PhysicalAddressType somePhysicalAddress;
31: 
32:     @BeforeEach
33:     public void setUp() {
34:         purgatory.deleteEverything();
35:         nonExistingEmailAddress = instantiateEmailAddress( "this@nononono.de" );
36:         somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
37:                 instantiateZipCode( "90001" ) );
38:     }
39: 
40:     @Test
41:     public void testAllClientsRegistered() {
42:         // given
43:         clientTestHelper.registerAllClients();
44:         EmailAddressType emailAddress3 =
45:                 clientTestHelper.getClientEmailAddress( 3 );
46:         String name3 = clientTestHelper.getClientName( 3 );
47:         PhysicalAddressType physicalAddress3 = clientTestHelper.getClientPhysicalAddress( 3 );
48: 
49:         // when
50:         ClientType client3 = clientRegistrationUseCases.getClientData(
51:                 emailAddress3 );
52: 
53:         // then
54:         Assertions.assertEquals( name3, client3.getName() );
55:         Assertions.assertEquals( emailAddress3, client3.getEmailAddress() );
56:         Assertions.assertEquals( physicalAddress3, client3.getPhysicalAddress() );
57:     }
58: 
59: 
60:     @Test
61:     public void testRegisterClientWithDuplicateEmailAddress() {
62:         // given
63:         clientTestHelper.registerAllClients();
64:         PhysicalAddressType physicalAddress5 = clientTestHelper.getClientPhysicalAddress( 5 );
65:         EmailAddressType emailAddress5 =
66:                 clientTestHelper.getClientEmailAddress( 5 );
67: 
68:         // when
69:         // then
70:         assertThrows( ShopException.class, () ->
71:                 clientRegistrationUseCases.register( "Gandalf The Grey",
72:                         emailAddress5, physicalAddress5 ) );
73:     }
74: 
75: 
76:     @Test
77:     public void testRegisterClientWithDuplicateNameOrPhysicalAddress() {
78:         // given
79:         clientTestHelper.registerAllClients();
80:         EmailAddressType newEmailAddress =
81:                 instantiateEmailAddress( "some@this.de" );
82:         PhysicalAddressType physicalAddress2 = clientTestHelper.getClientPhysicalAddress( 2 );
83:         String name2 = clientTestHelper.getClientName( 2 );
84: 
85:         // when
86:         // then
87:         assertDoesNotThrow( () ->
88:                 clientRegistrationUseCases.register( name2, newEmailAddress, physicalAddress2 ) );
89:     }
90: 
91: 
92:     @Test
93:     public void testRegisterClientWithInvalidData() {
94:         // given
95:         EmailAddressType emailAddress5 =
96:                 clientTestHelper.getClientEmailAddress( 5 );
97:         PhysicalAddressType physicalAddress5 = clientTestHelper.getClientPhysicalAddress( 5 );
98:         String name5 = clientTestHelper.getClientName( 5 );
99: 
100:         // when
101:         // then
102:         assertThrows( ShopException.class, () ->
103:                 clientRegistrationUseCases.register( null, emailAddress5, physicalAddress5 ) );
104:         assertThrows( ShopException.class, () ->
105:                 clientRegistrationUseCases.register("", emailAddress5, physicalAddress5 ) );
106:         assertThrows( ShopException.class, () ->
107:                 clientRegistrationUseCases.register( name5, null, physicalAddress5 ) );
108:         assertThrows( ShopException.class, () ->
109:                 clientRegistrationUseCases.register( name5, emailAddress5, null ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testChangeAddressWithInvalidData() {
115:         // given
116:         clientTestHelper.registerAllClients();
117:         PhysicalAddressType physicalAddress7 = clientTestHelper.getClientPhysicalAddress( 7 );
118:         EmailAddressType emailAddress7 =
119:                 clientTestHelper.getClientEmailAddress( 7 );
120: 
121:         // when
122:         // then
123:         assertThrows( ShopException.class, () ->
124:                 clientRegistrationUseCases.changeAddress( nonExistingEmailAddress, physicalAddress7 ) );
125:         assertThrows( ShopException.class, () ->
126:                 clientRegistrationUseCases.changeAddress( null, physicalAddress7 ) );
127:         assertThrows( ShopException.class, () ->
128:                 clientRegistrationUseCases.changeAddress( emailAddress7, null ) );
129:     }
130: 
131: 
132:     @Test
133:     public void testGetDataForNonexistingEmailAddress() {
134:         // given
135:         clientTestHelper.registerAllClients();
136: 
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 clientRegistrationUseCases.getClientData( nonExistingEmailAddress ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testDeleteClientsNoMoreClients() {
146:         // given
147:         clientTestHelper.registerAllClients();
148:         EmailAddressType emailAddress0 =
149:                 clientTestHelper.getClientEmailAddress( 0 );
150: 
151: 
152:         // when
153:         clientRegistrationUseCases.deleteAllClients();
154: 
155:         // then
156:         assertThrows( ShopException.class, () -> clientRegistrationUseCases.getClientData(
157:                 emailAddress0 ) );
158:     }
159: 
160: 
161:     @Test
162:     public void testChangeAddressSuccessful() {
163:         // given
164:         clientTestHelper.registerAllClients();
165:         EmailAddressType emailAddress6 =
166:                 clientTestHelper.getClientEmailAddress( 6 );
167: 
168:         // when
169:         clientRegistrationUseCases.changeAddress( emailAddress6, somePhysicalAddress );
170:         ClientType newClient6 =
171:                 clientRegistrationUseCases.getClientData( emailAddress6 );
172: 
173:         // then
174:         Assertions.assertEquals( emailAddress6, newClient6.getEmailAddress() );
175:         Assertions.assertEquals( somePhysicalAddress, newClient6.getPhysicalAddress() );
176:     }
177: 
178: 
179:     @Test
180:     public void testChangeAddressForNonexistingEmailAddress() {
181:         // given
182:         clientTestHelper.registerAllClients();
183: 
184:         // when
185:         // then
186:         assertThrows( ShopException.class, () ->
187:                 clientRegistrationUseCases.changeAddress( nonExistingEmailAddress, somePhysicalAddress ) );
188:     }
189: 
190: 
191: }
192: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\client\ClientRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.client;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
12: import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
13: import thkoeln.archilab.ecommerce.usecases.ClientType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
16: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
17: 
18: import java.util.UUID;
19: 
20: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
21: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
22: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
23: 
24: @SpringBootTest
25: @Transactional
26: @AutoConfigureMockMvc
27: @Import( RESTTestHelperConfiguration.class )
28: public class ClientRESTTest {
29:     @Autowired
30:     private ClientRegistrationUseCases clientRegistrationUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private ClientTestHelper clientTestHelper;
35:     @Autowired
36:     private MockMvc mockMvc;
37: 
38:     private UUID randomId;
39:     private EmailAddressType nonExistingEmailAddress;
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         clientTestHelper.registerAllClients();
45: 
46:         nonExistingEmailAddress = FactoryMethodInvoker.instantiateEmailAddress(
47:                 "harry@sally.de" );
48:         randomId = UUID.randomUUID();
49:     }
50: 
51: 
52:     @Test
53:     public void testInvalidClientUris() throws Exception {
54:         // given
55:         String allClientsUri = "/clients";
56:         String randomIdUri = "/clients/" +  randomId;
57:         String nonExistingEmailAddressUri = "/clients?emailAddress=" + nonExistingEmailAddress;
58:         String randomParamUri = "/clients?randomParam=randomValue";
59: 
60:         // when
61:         // then
62:         mockMvc.perform( get( allClientsUri ) ).andExpect( status().isMethodNotAllowed() );
63:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
64:         mockMvc.perform( get( nonExistingEmailAddressUri ) ).andExpect( status().isNotFound() );
65:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
66:     }
67: 
68: 
69:     @Test
70:     public void testRandomClientId() throws Exception {
71:         // given
72:         String invalidUri = "/clients/" +  randomId;
73: 
74:         // when
75:         // then
76:         mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
77:     }
78: 
79: 
80:     @Test
81:     public void testQueryClient() throws Exception {
82:         // given
83:         EmailAddressType emailAddress4 =
84:                 clientTestHelper.getClientEmailAddress( 4 );
85:         String clientUri4 = "/clients?emailAddress=" + emailAddress4;
86: 
87:         // when
88:         ClientType client4 = clientRegistrationUseCases.getClientData( emailAddress4 );
89:         String name = clientTestHelper.getClientName( 4 );
90:         PhysicalAddressType physicalAddress4 = clientTestHelper.getClientPhysicalAddress( 4 );
91: 
92:         // then (check using JSONPath)
93:         mockMvc.perform( get( clientUri4 ) )
94:                 .andExpect( status().isOk() )
95:                 .andExpect( jsonPath( "$.name" ).value( name ) )
96:                 // id is position 0 (cannot be tested with current API structure), name is position 1,
97:                 // email address is 2, physical address is 3)
98:                 .andExpect( jsonPath( "$..emailAddressString" ).value( emailAddress4.toString() ) )
99:                 .andExpect( jsonPath( "$..city" ).value( physicalAddress4.getCity() ) )
100:                 .andExpect( jsonPath( "$..zipCodeString" ).value(
101:                         physicalAddress4.getZipCode().toString() ) );
102:     }
103: 
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class BasicNoOutsideSolutionRulesTest {
14: 
15:     @ArchTest
16:     static final ArchRule noClassesOnTopLevel =
17:             classes().should().resideInAPackage( "..solution.*.." )
18:                     .allowEmptyShould( true );
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.library.Architectures.layeredArchitecture;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln")
12: @SuppressWarnings("PMD")
13: public class BasicProperDependenciesTest {
14: 
15:     @ArchTest
16:     static final ArchRule properDependencies =
17:             layeredArchitecture()
18:                     .consideringAllDependencies()
19:                     //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
20:                     .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
21:                     .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )
22: 
23:                     //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
24:                     .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
25:                     .allowEmptyShould( true );
26: }
27: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
5: import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
6: import org.springframework.core.type.classreading.MetadataReader;
7: import org.springframework.core.type.classreading.MetadataReaderFactory;
8: 
9: import java.io.IOException;
10: import java.util.Arrays;
11: import java.util.HashSet;
12: import java.util.Set;
13: 
14: import static org.junit.jupiter.api.Assertions.assertTrue;
15: 
16: public class BasicRequiredClassesTest {
17:     private static final String[] REQUIRED_CLASSES = {
18:             "Client",
19:             "ClientRepository",
20:             "Item",
21:             "ItemRepository",
22:             "Order",
23:             "OrderRepository",
24:             "StockLevel",
25:             "ShoppingBasket",
26:             "ShoppingBasketRepository",
27:             "FulfillmentCenterRepository",
28:             "ShoppingBasketPosition",
29:             "OrderPosition",
30:             "FulfillmentCenter",
31:     };
32: 
33:     @Test
34:     public void testRequiredClassesDeclared() throws IOException {
35:         String basePackage = "thkoeln.archilab.ecommerce";
36:         String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";
37: 
38:         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
39:         MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );
40: 
41:         Set<String> foundClasses = new HashSet<>();
42: 
43:         Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
44:             try {
45:                 MetadataReader reader = readerFactory.getMetadataReader( resource );
46:                 foundClasses.add( reader.getClassMetadata().getClassName() );
47:             } catch (IOException e) {
48:                 e.printStackTrace();
49:             }
50:         } );
51: 
52:         Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
53:             boolean found = foundClasses.stream().anyMatch(className ->
54:                     className.startsWith(basePackage) && className.endsWith("." + requiredClass)
55:             );
56:             assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
57:         });
58:     }
59: }
60: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.boot.test.context.SpringBootTest;
6: import org.springframework.context.ApplicationContext;
7: 
8: import java.util.Arrays;
9: import java.util.HashMap;
10: import java.util.List;
11: import java.util.Map;
12: 
13: import static org.junit.jupiter.api.Assertions.*;
14: 
15: @SpringBootTest
16: public class BasicUseCaseImplementationPackageTest {
17: 
18:     @Autowired
19:     private ApplicationContext applicationContext;
20: 
21:     private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
22:         put("ClientRegistrationUseCases", Arrays.asList("client"));
23:         put("FulfillmentCenterUseCases", Arrays.asList("fulfillmentcenter"));
24:         put("ItemCatalogUseCases", Arrays.asList("item"));
25:         put("ShoppingBasketUseCases", Arrays.asList("shoppingbasket"));
26:         put("OrderUseCases", Arrays.asList("order"));
27:     }};
28:     private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
29:     private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";
30: 
31:     @Test
32:     public void testRequiredClassesDeclared() {
33:         for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
34:             String interfaceName = USECASE_PATH + "." + entry.getKey();
35:             List<String> correctTopLevelPackages = entry.getValue();
36:             Class<?> useCaseInterfaceClass = null;
37:             try {
38:                 useCaseInterfaceClass = Class.forName( interfaceName );
39:             } catch (ClassNotFoundException e) {
40:                 fail( "Use case interface " + interfaceName + " not found.", e );
41:                 continue;
42:             }
43:             String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
44:             assertEquals( 1, beans.length,
45:                     "There should be exactly 1 service implementation for the interface " +
46:                             entry.getKey() + ", but found " + beans.length );
47:             Object bean = applicationContext.getBean( beans[0] );
48:             boolean isValid = false;
49:             for ( String correctTopLevelPackage : correctTopLevelPackages ) {
50:                 String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
51:                 if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
52:                     isValid = true;
53:                     break;
54:                 }
55:             }
56:             assertTrue( isValid,
57:                     "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
58:                             + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
59:         }
60:     }
61: }
62: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: import org.springframework.data.repository.CrudRepository;
8: import org.springframework.stereotype.Service;
9: 
10: import jakarta.persistence.Entity;
11: import org.springframework.web.bind.annotation.RestController;
12: 
13: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
14: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
15: 
16: @ArchTag("layerRules")
17: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
18: @SuppressWarnings("PMD")
19: public class DDDRulesTest {
20: 
21:     @ArchTest
22:     static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
23:             noClasses().that().resideInAPackage( "..domain.." )
24:                     .should().dependOnClassesThat().resideInAPackage( "..application.." )
25:                     .allowEmptyShould( true );
26: 
27:     @ArchTest
28:     static final ArchRule entitiesMustResideInADomainPackage =
29:             classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
30:                     .as( "Entities must reside in a package '..domain..'" )
31:                     .allowEmptyShould( true );
32: 
33:     @ArchTest
34:     static final ArchRule entitiesMustNotAccessRepositories =
35:             noClasses().that().areAnnotatedWith( Entity.class )
36:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
37:                     .allowEmptyShould( true );
38: 
39:     @ArchTest
40:     static final ArchRule repositoriesMustResideInADomainPackage =
41:             classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
42:                     .as( "Repositories must reside in a package '..domain..'" )
43:                     .allowEmptyShould( true );
44: 
45:     @ArchTest
46:     static final ArchRule repositoryNamesMustHaveProperSuffix =
47:             classes().that().areAssignableTo( CrudRepository.class )
48:                     .should().haveSimpleNameEndingWith( "Repository" )
49:                     .allowEmptyShould( true );
50: 
51:     @ArchTest
52:     static final ArchRule servicesMustResideInAnApplicationPackage =
53:             classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
54:                     .as( "Application Services must reside in a package '..application..'" )
55:                     .allowEmptyShould( true );
56: 
57:     @ArchTest
58:     static final ArchRule serviceNamesMustHaveProperSuffix =
59:             classes().that().areAnnotatedWith( Service.class )
60:                     .should().haveSimpleNameEndingWith( "Service" )
61:                     .allowEmptyShould( true );
62: 
63:     @ArchTest
64:     static final ArchRule controllersMustResideInAnApplicationPackage =
65:             classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
66:                     .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );
67: 
68:     @ArchTest
69:     static final ArchRule controllersNamesMustHaveProperSuffix =
70:             classes().that().areAnnotatedWith( RestController.class )
71:                     .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );
72: 
73:     @ArchTest
74:     static final ArchRule controllersMustNotAccessRepositories =
75:             noClasses().that().areAnnotatedWith( RestController.class )
76:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
77:                     .allowEmptyShould( false );
78: }
79: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.importer.ClassFileImporter;
6: import com.tngtech.archunit.lang.ArchRule;
7: import com.tngtech.archunit.library.dependencies.SliceAssignment;
8: import com.tngtech.archunit.library.dependencies.SliceIdentifier;
9: import org.junit.jupiter.api.Test;
10: 
11: import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
12: 
13: public class NoCycleTest {
14:     private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");
15: 
16:     private SliceAssignment inAllClasses() {
17:         return new SliceAssignment() {
18:             @Override
19:             public String getDescription() {
20:                 return "every class in it's own slice";
21:             }
22: 
23:             @Override
24:             public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
25:                 return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
26:             }
27:         };
28:     }
29: 
30:     @Test
31:     public void testNoCyclicDependenciesBetweenClasses() {
32:         slices().assignedFrom(inAllClasses())
33:                 .namingSlices("$1[$2.$3]")
34:                 .should().beFreeOfCycles()
35:                 .check(importedClasses);
36:     }
37: 
38:     @Test
39:     public void testNoCyclicDependenciesBetweenPackages() {
40:         ArchRule rule = slices().matching("..solution.(*)..")
41:                 .should().beFreeOfCycles().allowEmptyShould( true );
42:         rule.check(importedClasses);
43:     }
44: }
45: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.base.DescribedPredicate;
4: import com.tngtech.archunit.core.domain.JavaClass;
5: import com.tngtech.archunit.core.domain.JavaField;
6: import com.tngtech.archunit.core.domain.JavaParameterizedType;
7: import com.tngtech.archunit.core.domain.JavaType;
8: import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
9: import com.tngtech.archunit.junit.AnalyzeClasses;
10: import com.tngtech.archunit.junit.ArchTag;
11: import com.tngtech.archunit.junit.ArchTest;
12: import com.tngtech.archunit.lang.ArchCondition;
13: import com.tngtech.archunit.lang.ArchRule;
14: import com.tngtech.archunit.lang.ConditionEvents;
15: import com.tngtech.archunit.lang.SimpleConditionEvent;
16: import jakarta.persistence.*;
17: import lombok.extern.slf4j.Slf4j;
18: import thkoeln.archilab.ecommerce.GenericId;
19: 
20: import java.util.List;
21: 
22: import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
23: import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
24: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;
25: 
26: @ArchTag("layerRules")
27: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
28: @SuppressWarnings("PMD")
29: @Slf4j
30: public class OnlyReferenceViaIDTest { //FULFILLMENT_CENTER
31:     private static final String SHOPPING_BASKET_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingbasket.domain";
32:     private static final String CLIENT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.client.domain";
33:     private static final String ITEM_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.item.domain";
34:     private static final String ORDER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.order.domain";
35:     private static final String FULFILLMENT_CENTER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain";
36: 
37:     @ArchTest
38:     static final ArchRule idFieldsMustUseGenericId =
39:             fields()
40:                     .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
41:                     .and().areAnnotatedWith( Id.class )
42:                     .should().haveRawType( assignableTo( GenericId.class ) )
43:                     .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
44:                     .allowEmptyShould( true );
45: 
46: 
47:     private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
48:             annotatedWith( ManyToOne.class )
49:                     .or( annotatedWith( OneToOne.class ) )
50:                     .or( annotatedWith( Embedded.class ) )
51:                     .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );
52: 
53:     private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
54:             annotatedWith( OneToMany.class )
55:                     .or( annotatedWith( ManyToMany.class ) )
56:                     .or( annotatedWith( ElementCollection.class ) )
57:                     .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );
58: 
59: 
60:     private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
61:         String description = "an entity or value object from same aggregate, or a domain primitive";
62:         return new DescribedPredicate<>( description ) {
63:             @Override
64:             public boolean test( JavaClass type ) {
65:                 // check if the class is an entity or value object, and resides in the allowed package
66:                 if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
67:                     return false;
68:                 }
69:                 // a GenericId is always allowed
70:                 if ( type.isAssignableTo( GenericId.class ) ) {
71:                     return true;
72:                 }
73:                 // a domain primitive is also always allowed
74:                 if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
75:                     return true;
76:                 }
77:                 return type.getPackageName().startsWith( allowedPackage );
78:             }
79:         };
80:     }
81: 
82: 
83:     @ArchTest
84:     static final ArchRule shoppingBasketToOneReferences =
85:             fields()
86:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
87:                     .and( isToOneAnnotation )
88:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) ) )
89:                     .allowEmptyShould( true );
90: 
91:     @ArchTest
92:     static final ArchRule clientToOneReferences =
93:             fields()
94:                     .that().areDeclaredInClassesThat().resideInAPackage( CLIENT_DOMAIN_PACKAGE )
95:                     .and( isToOneAnnotation )
96:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( CLIENT_DOMAIN_PACKAGE ) ) )
97:                     .allowEmptyShould( true );
98: 
99:     @ArchTest
100:     static final ArchRule itemToOneReferences =
101:             fields()
102:                     .that().areDeclaredInClassesThat().resideInAPackage( ITEM_DOMAIN_PACKAGE )
103:                     .and( isToOneAnnotation )
104:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( ITEM_DOMAIN_PACKAGE ) ) )
105:                     .allowEmptyShould( true );
106: 
107:     @ArchTest
108:     static final ArchRule orderToOneReferences =
109:             fields()
110:                     .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
111:                     .and( isToOneAnnotation )
112:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) ) )
113:                     .allowEmptyShould( true );
114: 
115:     @ArchTest
116:     static final ArchRule fulfillmentCenterToOneReferences =
117:             fields()
118:                     .that().areDeclaredInClassesThat().resideInAPackage( FULFILLMENT_CENTER_DOMAIN_PACKAGE )
119:                     .and( isToOneAnnotation )
120:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( FULFILLMENT_CENTER_DOMAIN_PACKAGE ) ) )
121:                     .allowEmptyShould( true );
122: 
123: 
124:     private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
125:         return new ArchCondition<JavaField>(
126:                 "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
127:             @Override
128:             public void check( JavaField field, ConditionEvents events ) {
129:                 JavaClass rawType = field.getRawType();
130:                 String rawTypeName = rawType.getFullName();
131:                 if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
132:                     events.add( SimpleConditionEvent.violated( field,
133:                             field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
134:                     return;
135:                 }
136:                 JavaType fieldType = field.getType();
137:                 if ( !( fieldType instanceof JavaParameterizedType ) ) {
138:                     events.add( SimpleConditionEvent.violated( field,
139:                             field.getFullName() + " is a raw List/Set without a type argument" ) );
140:                     return;
141:                 }
142:                 List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
143:                 if ( typeArguments.isEmpty() ) {
144:                     events.add( SimpleConditionEvent.violated( field,
145:                             field.getFullName() + " has no type arguments" ) );
146:                     return;
147:                 }
148:                 JavaType elementType = typeArguments.get( 0 );
149:                 if ( !( elementType instanceof JavaClass ) ) {
150:                     events.add( SimpleConditionEvent.violated( field,
151:                             field.getFullName() + " has an unknown element type" ) );
152:                     return;
153:                 }
154:                 JavaClass elementClass = (JavaClass) elementType;
155:                 boolean hasAnnotation =
156:                         elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
157:                 boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
158:                 boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
159:                 boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
160:                 boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
161:                 if ( !ok ) {
162:                     events.add( SimpleConditionEvent.violated( field,
163:                             field.getFullName() + " refers to " + elementClass.getFullName()
164:                                     + " which is not a DP, or an entity/value object in " + allowedPackage ) );
165:                 }
166:             }
167:         };
168:     }
169: 
170: 
171:     @ArchTest
172:     static final ArchRule shoppingBasketToManyReferences =
173:             fields()
174:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
175:                     .and( isToManyAnnotation )
176:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) )
177:                     .allowEmptyShould( true );
178: 
179:     @ArchTest
180:     static final ArchRule clientToManyReferences =
181:             fields()
182:                     .that().areDeclaredInClassesThat().resideInAPackage( CLIENT_DOMAIN_PACKAGE )
183:                     .and( isToManyAnnotation )
184:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( CLIENT_DOMAIN_PACKAGE ) )
185:                     .allowEmptyShould( true );
186: 
187:     @ArchTest
188:     static final ArchRule itemToManyReferences =
189:             fields()
190:                     .that().areDeclaredInClassesThat().resideInAPackage( ITEM_DOMAIN_PACKAGE )
191:                     .and( isToManyAnnotation )
192:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( ITEM_DOMAIN_PACKAGE ) )
193:                     .allowEmptyShould( true );
194: 
195:     @ArchTest
196:     static final ArchRule orderToManyReferences =
197:             fields()
198:                     .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
199:                     .and( isToManyAnnotation )
200:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) )
201:                     .allowEmptyShould( true );
202: 
203:     @ArchTest
204:     static final ArchRule fulfillmentCenterToManyReferences =
205:             fields()
206:                     .that().areDeclaredInClassesThat().resideInAPackage( FULFILLMENT_CENTER_DOMAIN_PACKAGE )
207:                     .and( isToManyAnnotation )
208:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( FULFILLMENT_CENTER_DOMAIN_PACKAGE ) )
209:                     .allowEmptyShould( true );
210: 
211: }
212: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: /**
4:  * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
5:  */
6: 
7: public class OwnTestsTest {
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClasses;
4: import com.tngtech.archunit.core.importer.ClassFileImporter;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: 
8: import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
9: 
10: public class PackageStructureTest {
11: 
12:     private static final String[] REQUIRED_PACKAGES = {"client", "shoppingbasket", "item", "order", "fulfillmentcenter"};
13:     private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
14:     private JavaClasses importedClasses;
15: 
16: 
17:     @BeforeEach
18:     public void setUp() {
19:         importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
20:     }
21: 
22:     @Test
23:     void testRequiredPackagesAreThere() {
24:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
25:             String packageName = BASE_PACKAGE + "." + requiredPackage;
26:             assertThat( importedClasses.containPackage( packageName ) )
27:                     .as( "Expected package %s not found!", packageName )
28:                     .isTrue();
29:         }
30:     }
31: 
32:     @Test
33:     void testRequiredDomainPackagesAreThere() {
34:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
35:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
36:             assertThat( importedClasses.containPackage( packageName ) )
37:                     .as( "Expected domain sub-package %s not found!", packageName )
38:                     .isTrue();
39:         }
40:     }
41: 
42:     @Test
43:     void testRequiredApplicationPackagesAreThere() {
44:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
45:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
46:             assertThat( importedClasses.containPackage( packageName ) )
47:                     .as( "Expected application sub-package %s not found!", packageName )
48:                     .isTrue();
49:         }
50:     }
51: 
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("domainPrimitivesUsageRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class DomainPrimitivesUsageRulesTest {
14:     private static final String EMAIL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.EmailAddress";
15:     private static final String MONEY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Money";
16:     private static final String PHYSICAL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress";
17: 
18:     @ArchTest
19:     static final ArchRule clientShouldReferenceEmailAddress =
20:             classes()
21:                     .that().haveSimpleName( "Client" )
22:                     .should().dependOnClassesThat().haveFullyQualifiedName( EMAIL_ADDRESS_CLASS )
23:                     .because( "Client should use EmailAddress instead of String" );
24: 
25:     @ArchTest
26:     static final ArchRule clientShouldReferencePhysicalAddress =
27:             classes()
28:                     .that().haveSimpleName( "Client" )
29:                     .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
30:                     .because( "Client should use PhysicalAddress instead of whatever else" );
31: 
32:     @ArchTest
33:     static final ArchRule fulfillmentCenterShouldReferencePhysicalAddress =
34:             classes()
35:                     .that().haveSimpleName( "FulfillmentCenter" )
36:                     .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
37:                     .because( "Client should use PhysicalAddress instead of whatever else" );
38: 
39:     @ArchTest
40:     static final ArchRule itemShouldReferenceMoney =
41:             classes()
42:                     .that().haveSimpleName( "Item" )
43:                     .should().dependOnClassesThat().haveFullyQualifiedName( MONEY_CLASS )
44:                     .because( "Item should use Money instead of float or whatever else" );
45: }
46: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\EmailAddressTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmailAddress;
10: 
11: class EmailAddressTest {
12: 
13:     @Test
14:     public void testToStringEmailAddress() {
15:         // given
16:         String input = "test@example.com";
17: 
18:         // when
19:         EmailAddressType instance = instantiateEmailAddress( input );
20: 
21:         // then
22:         assertEquals( input, instance.toString() );
23:     }
24: 
25:     @Test
26:     public void testEqualityEmailAddress() {
27:         // given
28:         // when
29:         EmailAddressType instance1 = instantiateEmailAddress( "test@example.com" );
30:         EmailAddressType instance2 = instantiateEmailAddress( "test@example.com" );
31:         EmailAddressType instance3 = instantiateEmailAddress( "different@example.com" );
32: 
33:         // then
34:         assertEquals( instance1, instance2 );
35:         assertNotEquals( instance1, instance3 );
36:     }
37: 
38:     @Test
39:     public void testImmutabilityEmailAddress() {
40:         // given
41:         // when
42:         EmailAddressType instance = instantiateEmailAddress( "test@example.com" );
43: 
44:         // then
45:         try {
46:             instance.getClass().getMethod( "setEmailAddress", String.class );
47:             fail( "setEmailAddress method should not exist" );
48:         } catch (NoSuchMethodException e) {
49:             // Success: the object is immutable
50:         }
51:     }
52: 
53: 
54: 
55:     @Test
56:     public void smokeTestForCopyConstructors() {
57:         // given
58:         EmailAddressType emailAddress =
59:                 instantiateEmailAddress( "peter.schmidt@web.de" );
60: 
61:         // when
62:         EmailAddressType emailAddressOtherIdentifyer =
63:                 emailAddress.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
64:         assertThrows( ShopException.class, () ->
65:                 emailAddress.sameDomainDifferentIdentifyer( "p...eter" ) );
66:         EmailAddressType emailAddressOtherDomain =
67:                 emailAddress.sameIdentifyerDifferentDomain( "web.ch" );
68:         assertThrows( ShopException.class, () ->
69:                 emailAddress.sameIdentifyerDifferentDomain( "web.edu" ) );
70: 
71:         // then
72:         assertEquals( "p.e.t.e.r@web.de", emailAddressOtherIdentifyer.toString() );
73:         assertEquals( "peter.schmidt@web.ch", emailAddressOtherDomain.toString() );
74:     }
75: 
76: 
77:     @Test
78:     public void testFactoryValidEmailAddress() {
79:         // given
80:         // when
81:         // then
82:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.com" ) );
83:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "99Z@example.com" ) );
84:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "GGGhh@s77.com" ) );
85:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "a@4.com" ) );
86:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "Max.Hammer@example.com" ) );
87:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "Max.Gideon.Hammer@example.com" ) );
88:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.this.com" ) );
89:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.de" ) );
90:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.at" ) );
91:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.ch" ) );
92:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.org" ) );
93:     }
94: 
95: 
96:     @Test
97:     public void testFactoryInvalidEmailAddress() {
98:         // given
99:         // when
100:         // then
101:         assertThrows( ShopException.class, () -> instantiateEmailAddress( null ) );
102:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "testexample.com" ) );
103:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@" ) );
104:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "@example.com" ) );
105:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "Max..Gideon.Hammer@example.com" ) );
106:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@examplecom" ) );
107:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example..com" ) );
108:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example@that.com" ) );
109:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test example@that.com" ) );
110:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test#example@that.com" ) );
111:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.biz" ) );
112:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.biz" ) );
113:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.42" ) );
114:     }
115: }
116: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\MoneyTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMoney;
9: 
10: class MoneyTest {
11: 
12:     @Test
13:     public void testGetAmountMoney() {
14:         // given
15:         Float inputAmount = 10.0f;
16: 
17:         // when
18:         MoneyType instance = instantiateMoney( inputAmount, "EUR" );
19: 
20:         // then
21:         assertEquals( inputAmount, instance.getAmount() );
22:     }
23: 
24:     @Test
25:     public void testGetCurrencyUnitMoney() {
26:         // given
27:         String inputCurrencyUnit = "EUR";
28: 
29:         // when
30:         MoneyType instance = instantiateMoney( 10.0f, inputCurrencyUnit );
31: 
32:         // then
33:         assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
34:     }
35: 
36:     @Test
37:     public void testAddToMoney() {
38:         // given
39:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
40:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
41:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
42: 
43:         // when
44:         MoneyType result12 = instance1.add( instance2 );
45:         MoneyType result13 = instance1.add( instance3 );
46: 
47:         // then
48:         assertEquals( 30.0f, result12.getAmount() );
49:         assertEquals( "EUR", result12.getCurrencyUnit() );
50:         assertEquals( 10.0f, result13.getAmount() );
51:         assertEquals( "EUR", result12.getCurrencyUnit() );
52:     }
53: 
54:     @Test
55:     public void testInvalidAddToMoney() {
56:         // given
57:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
58:         MoneyType instance2 = instantiateMoney( 20.0f, "CHF" );
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
63:     }
64: 
65:     @Test
66:     public void testSubtractFromMoney() {
67:         // given
68:         MoneyType instance1 = instantiateMoney( 30.0f, "EUR" );
69:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
70:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
71:         MoneyType instance4 = instantiateMoney( 30.0f, "EUR" );
72: 
73:         // when
74:         MoneyType result12 = instance1.subtract( instance2 );
75:         MoneyType result13 = instance1.subtract( instance3 );
76:         MoneyType result14 = instance1.subtract( instance4 );
77: 
78:         // then
79:         assertEquals( 10.0f, result12.getAmount() );
80:         assertEquals( "EUR", result12.getCurrencyUnit() );
81:         assertEquals( 30.0f, result13.getAmount() );
82:         assertEquals( "EUR", result13.getCurrencyUnit() );
83:         assertEquals( 0.0f, result14.getAmount() );
84:         assertEquals( "EUR", result14.getCurrencyUnit() );
85:     }
86: 
87:     @Test
88:     public void testInvalidSubtractFromMoney() {
89:         // given
90:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
91:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
92:         MoneyType instance3 = instantiateMoney( 5.0f, "CHF" );
93: 
94:         // when
95:         // then
96:         assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
97:         assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
98:     }
99: 
100:     @Test
101:     public void testMultiplyByMoney() {
102:         // given
103:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
104: 
105:         // when
106:         MoneyType result = instance.multiplyBy( 3 );
107: 
108:         // then
109:         assertEquals( 30.0f, result.getAmount() );
110:         assertEquals( "EUR", result.getCurrencyUnit() );
111:     }
112: 
113:     @Test
114:     public void testFactoryValidCurrencyUnitMoney() {
115:         // given
116:         // when
117:         // then
118:         assertDoesNotThrow( () -> instantiateMoney( 10.0f, "EUR" ) );
119:     }
120: 
121:     @Test
122:     public void testFactoryInvalidCurrencyUnitMoney() {
123:         // given
124:         // when
125:         // then
126:         assertThrows( ShopException.class, () -> instantiateMoney( -10.0f, "EUR" ) );
127:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, "USD" ) );
128:         assertThrows( ShopException.class, () -> instantiateMoney( null, "EUR" ) );
129:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, null ) );
130:     }
131: 
132:     @Test
133:     public void testLargerThanCurrencyUnitMoney() {
134:         // given
135:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
136:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
137:         MoneyType instance3 = instantiateMoney( 10.0f, "EUR" );
138:         MoneyType instance4 = instantiateMoney( 10.0f, "CHF" );
139: 
140:         // when
141:         // then
142:         assertTrue( instance2.largerThan( instance1 ) );
143:         assertFalse( instance1.largerThan( instance2 ) );
144:         assertFalse( instance1.largerThan( instance3 ) );
145:         assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
146:     }
147: 
148: 
149:     @Test
150:     public void testEqualityCurrencyUnitMoney() {
151:         // given
152:         // when
153:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
154:         MoneyType instance2 = instantiateMoney( 10.0f, "EUR" );
155:         MoneyType instance3 = instantiateMoney( 20.0f, "EUR" );
156: 
157:         // then
158:         assertEquals( instance1, instance2 );
159:         assertNotEquals( instance1, instance3 );
160:     }
161: 
162:     @Test
163:     public void testImmutabilityCurrencyUnitMoney() {
164:         // given
165:         // when
166:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
167: 
168:         // then
169:         try {
170:             instance.getClass().getMethod( "setAmount", Float.class );
171:             fail( "setAmount method should not exist" );
172:         } catch (NoSuchMethodException e) {
173:             // Success: the object is immutable
174:         }
175: 
176:         try {
177:             instance.getClass().getMethod( "setCurrencyUnit", String.class );
178:             fail( "setCurrencyUnit method should not exist" );
179:         } catch (NoSuchMethodException e) {
180:             // Success: the object is immutable
181:         }
182:     }
183: }
184: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\PhysicalAddressTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
11: 
12: class PhysicalAddressTest {
13: 
14:     @Test
15:     public void testGetterPhysicalAddress() {
16:         // given
17:         String street = "Irgendeinestraße 42";
18:         String city = "Irgendeinestadt";
19:         ZipCodeType plz = instantiateZipCode( "12345" );
20: 
21:         // when
22:         PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );
23: 
24:         // then
25:         assertEquals( street, instance.getStreet() );
26:         assertEquals( city, instance.getCity() );
27:         assertEquals( plz, instance.getZipCode() );
28:     }
29: 
30:     @Test
31:     public void testFactoryValidPhysicalAddress() {
32:         // given
33:         String street = "Irgendeinestraße 42";
34:         String city = "Irgendeinestadt";
35:         ZipCodeType plz = instantiateZipCode( "12345" );
36: 
37:         // when
38:         // then
39:         assertDoesNotThrow( () -> instantiatePhysicalAddress( street, city, plz ) );
40:     }
41: 
42:     @Test
43:     public void testFactoryInvalidPhysicalAddress() {
44:         // given
45:         String street = "Irgendeinestraße 42";
46:         String city = "Irgendeinestadt";
47:         ZipCodeType plz = instantiateZipCode( "12345" );
48: 
49:         // when
50:         // then
51:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( null, city, plz ) );
52:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( "", city, plz ) );
53:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, null, plz ) );
54:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, "", plz ) );
55:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, city, null ) );
56:     }
57: 
58:     @Test
59:     public void testEqualityPhysicalAddress() {
60:         // given
61:         String street = "Irgendeinestraße 42";
62:         String city = "Irgendeinestadt";
63:         ZipCodeType plz = instantiateZipCode( "12345" );
64: 
65:         // when
66:         PhysicalAddressType instance1 = instantiatePhysicalAddress( street, city, plz );
67:         PhysicalAddressType instance2 = instantiatePhysicalAddress( street, city, plz );
68:         PhysicalAddressType instance3 = instantiatePhysicalAddress( "Anderestr. 12", city, plz );
69:         PhysicalAddressType instance4 = instantiatePhysicalAddress( street, "AndereStadt", plz );
70:         PhysicalAddressType instance5 = instantiatePhysicalAddress( street, city, instantiateZipCode( "54321" ) );
71: 
72:         // then
73:         assertEquals( instance1, instance2 );
74:         assertNotEquals( instance1, instance3 );
75:         assertNotEquals( instance1, instance4 );
76:         assertNotEquals( instance1, instance5 );
77:     }
78: 
79:     @Test
80:     public void testImmutabilityPhysicalAddress() {
81:         // given
82:         String street = "Irgendeinestraße 42";
83:         String city = "Irgendeinestadt";
84:         ZipCodeType plz = instantiateZipCode( "12345" );
85: 
86:         // when
87:         PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );
88: 
89:         // then
90:         try {
91:             instance.getClass().getMethod( "setStreet", String.class );
92:             fail( "setStreet method should not exist" );
93:         } catch (NoSuchMethodException e) {
94:             // Success: the object is immutable
95:         }
96:         try {
97:             instance.getClass().getMethod( "setCity", String.class );
98:             fail( "setCity method should not exist" );
99: 
100:         } catch (NoSuchMethodException e) {
101:             // Success: the object is immutable
102:         }
103:         try {
104:             instance.getClass().getMethod( "setZipCode", ZipCodeType.class );
105:             fail( "setZipCode method should not exist" );
106:         } catch (NoSuchMethodException e) {
107:             // Success: the object is immutable
108:         }
109:     }
110: }
111: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\ZipCodeTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
8: 
9: import static org.junit.jupiter.api.Assertions.*;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
11: 
12: class ZipCodeTest {
13: 
14:     private String input1, input4;
15:     private ZipCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
16:             _04233, _02544, _99123, _56323, _79332;
17: 
18: 
19:     @BeforeEach
20:     public void setUp() {
21:         input1 = "12345";
22:         input4 = "49188";
23:         _12345 = FactoryMethodInvoker.instantiateZipCode( "12345" );
24:         _12345b = FactoryMethodInvoker.instantiateZipCode( "12345" );
25:         _23455 = FactoryMethodInvoker.instantiateZipCode( "23455" );
26:         _01234 = FactoryMethodInvoker.instantiateZipCode( "01234" );
27:         _01235 = FactoryMethodInvoker.instantiateZipCode( "01235" );
28:         _01238 = FactoryMethodInvoker.instantiateZipCode( "01238" );
29:         _01263 = FactoryMethodInvoker.instantiateZipCode( "01263" );
30:         _01213 = FactoryMethodInvoker.instantiateZipCode( "01213" );
31:         _01823 = FactoryMethodInvoker.instantiateZipCode( "01823" );
32:         _01312 = FactoryMethodInvoker.instantiateZipCode( "01312" );
33:         _04233 = FactoryMethodInvoker.instantiateZipCode( "04233" );
34:         _02544 = FactoryMethodInvoker.instantiateZipCode( "02544" );
35:         _99123 = FactoryMethodInvoker.instantiateZipCode( "99123" );
36:         _56323 = FactoryMethodInvoker.instantiateZipCode( "56323" );
37:         _79332 = FactoryMethodInvoker.instantiateZipCode( "79332" );
38: 
39:     }
40: 
41: 
42:     @Test
43:     public void testToStringZipCode() {
44:         // given
45:         // when
46:         ZipCodeType instance = instantiateZipCode( input1 );
47: 
48:         // then
49:         assertEquals( input1, instance.toString() );
50:     }
51: 
52:     @Test
53:     public void testFactoryValidZipCode() {
54:         // given
55:         // when
56:         // then
57:         assertDoesNotThrow( () -> instantiateZipCode( input1 ) );
58:     }
59: 
60:     @Test
61:     public void testFactoryInvalidZipCode() {
62:         // given
63:         // when
64:         // then
65:         assertThrows( ShopException.class, () -> instantiateZipCode( "123456" ) );
66:         assertThrows( ShopException.class, () -> instantiateZipCode( "1234" ) );
67:         assertThrows( ShopException.class, () -> instantiateZipCode( "20000" ) );
68:         assertThrows( ShopException.class, () -> instantiateZipCode( null ) );
69:     }
70: 
71:     @Test
72:     public void testEqualityZipCode() {
73:         // given
74:         // when
75:         ZipCodeType instance1a = instantiateZipCode( input1 );
76:         ZipCodeType instance1b = instantiateZipCode( input1 );
77:         ZipCodeType instance4 = instantiateZipCode( input4 );
78: 
79:         // then
80:         assertEquals( instance1a, instance1b );
81:         assertNotEquals( instance1a, instance4 );
82:     }
83: 
84:     @Test
85:     public void testImmutabilityZipCode() {
86:         // given
87:         // when
88:         ZipCodeType instance = instantiateZipCode( input1 );
89: 
90:         // then
91:         try {
92:             instance.getClass().getMethod( "setzipCode", String.class );
93:             fail( "setzipCode method should not exist" );
94:         } catch (NoSuchMethodException e) {
95:             // Success: the object is immutable
96:         }
97:     }
98: 
99: 
100:     @Test
101:     public void smokeTestForDifference() {
102:         // given
103:         ZipCodeType instance1a = instantiateZipCode( input1 );
104:         ZipCodeType instance1b = instantiateZipCode( input1 );
105:         ZipCodeType instance12479 = instantiateZipCode( "12479" );
106:         ZipCodeType instance21456 = instantiateZipCode( "21456" );
107: 
108:         // when
109:         int differenceAB = instance1a.difference( instance1b );
110:         int difference12 = instance1a.difference( instance12479 );
111:         int difference23 = instance12479.difference( instance21456 );
112: 
113:         // then
114:         assertEquals( 0, differenceAB );
115:         assertTrue( difference12 > 0 );
116:         assertTrue( difference23 > difference12 );
117:     }
118: 
119: 
120:     @Test
121:     public void testZipCodeFirstDigit() {
122:         // given
123:         ZipCodeType instance1 = instantiateZipCode( input1 );
124:         ZipCodeType instance4 = instantiateZipCode( input4 );
125: 
126:         // when
127:         // then
128:         assertEquals( 1, instance1.getFirstDigitZipCode() );
129:         assertEquals( 4, instance4.getFirstDigitZipCode() );
130:     }
131: 
132: 
133: 
134:     @Test
135:     public void testInvalidParameters() {
136:         // given
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 _12345.difference( null ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testSameZipCode() {
146:         // given
147:         // when
148:         int diff = _12345.difference( _12345b );
149: 
150:         // then
151:         assertEquals( 0, diff );
152:     }
153: 
154: 
155:     /**
156:      *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
157:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
158:      *        So, 56733 and 56734 have the same difference as 56733 and 56739.
159:      *      - The difference grows if more digits (counted from the right side) differ.
160:      *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
161:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
162:      *        53876 and 54876 have the same difference as 53876 and 57261.
163:      */
164:     @Test
165:     public void testZipCodeDifferenceInAllButFirstDigit() {
166:         // given
167:         // when
168:         int diff5a = _01234.difference( _01235 );
169:         int diff5b = _01234.difference( _01238 );
170:         int diff4a = _01234.difference( _01263 );
171:         int diff4b = _01234.difference( _01213 );
172:         int diff3a = _01234.difference( _01823 );
173:         int diff3b = _01234.difference( _01312 );
174:         int diff2a = _01234.difference( _04233 );
175:         int diff2b = _01234.difference( _02544 );
176: 
177:         // then
178:         assertEquals( diff5a, diff5b, "difference 01234-01235 must be the same as difference 01234-01238" );
179:         assertEquals( diff4a, diff4b, "difference 01234-01263 must be the same as difference 01234-01213" );
180:         assertEquals( diff3a, diff3b, "difference 01234-01823 must be the same as difference 01234-01312" );
181:         assertEquals( diff2a, diff2b, "difference 01234-04233 must be the same as difference 01234-02544" );
182: 
183:         assertTrue( diff5a < diff4a,
184:                 "difference 01234-01235 must be smaller than difference 01234-01263" );
185:         assertTrue( diff4a < diff3a,
186:                 "difference 01234-01263 must be smaller than difference 01234-01823" );
187:         assertTrue( diff3a < diff2a,
188:                 "difference 01234-01823 must be smaller than difference 01234-04233" );
189:     }
190: 
191: 
192:     /**
193:      *      - However, the difference between 5abcd and 6rstu must be smaller than the one
194:      *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
195:      *        one between 5abcd and 9rstu.
196:      *      - This last condition reflects the fact the first digits of a zip code marks a region
197:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
198:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
199:      *        other.
200:      */
201:     @Test
202:     public void testZipCodedifferenceInFirstDigit() {
203:         // given
204:         // when
205:         int diff1_1 = _01234.difference( _99123 );
206:         int diff1_2 = _01234.difference( _23455 );
207:         int diff1_5 = _01234.difference( _56323 );
208:         int diff1_3 = _01234.difference( _79332 );
209: 
210:         // then
211:         assertTrue( diff1_1 < diff1_2,
212:                 "difference 01234-99123 must be smaller than difference 01234-23455"  );
213:         assertTrue( diff1_2 < diff1_3,
214:                 "difference 01234-23455 must be smaller than difference 01234-79332" );
215:         assertTrue( diff1_3 < diff1_5,
216:                 "difference 01234-79332 must be smaller than difference 01234-56323"  );
217:     }
218: 
219: 
220: 
221: }
222: 
223: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
1: package thkoeln.archilab.ecommerce.tests.e1restcalls;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;
5: 
6: 
7: public class E1RestCallTableTest {
8: 
9:     private GenericTableSpecificationTests genericTableSpecificationTests = null;
10: 
11: 
12:     public E1RestCallTableTest() {
13:         this.genericTableSpecificationTests = new GenericTableSpecificationTests();
14:     }
15: 
16:     @Test
17:     public void restTest() throws Exception {
18:         genericTableSpecificationTests.testTableSpecification("E1" );
19:     }
20: }
21: 
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\fulfillmentcenter\FulfillmentCenterManagementTest.java ---
1: package thkoeln.archilab.ecommerce.tests.fulfillmentcenter;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
12: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
14: 
15: import java.util.UUID;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
19: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
20: 
21: 
22: /**
23:  * This test checks the management and lifecycle of fulfillment centers.
24:  */
25: @SpringBootTest
26: public class FulfillmentCenterManagementTest {
27:     @Autowired
28:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
29:     @Autowired
30:     private ItemCatalogUseCases itemCatalogUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private ItemTestHelper itemTestHelper;
35:     @Autowired
36:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
37: 
38:     private PhysicalAddressType somePhysicalAddress;
39:     private UUID nonExistingId1;
40:     private UUID nonExistingId2;
41: 
42: 
43:     @BeforeEach
44:     public void setUp() {
45:         purgatory.deleteEverything();
46:         itemTestHelper.addAllItems();
47: 
48:         somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
49:                 instantiateZipCode( "90001" ) );
50:         nonExistingId1 = UUID.randomUUID();
51:         nonExistingId2 = UUID.randomUUID();
52:     }
53: 
54: 
55:     @Test
56:     public void testAddInvalidFulfillmentCenter() {
57:         // given
58:         String name = "Lager1";
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class,
63:                 () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
64:                         null, somePhysicalAddress ) );
65:         assertThrows( ShopException.class,
66:                 () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
67:                         "", somePhysicalAddress ) );
68:         assertThrows( ShopException.class,
69:                 () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
70:                         name, null ) );
71:     }
72: 
73: 
74:     @Test
75:     public void testDeleteAllFulfillmentCentersWhenEmpty() {
76:         // given
77:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
78:         UUID itemId9 = itemTestHelper.getItemId( 9 );
79:         UUID fulfillmentCenterId1 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 1 );
80:         UUID fulfillmentCenterId2 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 2 );
81: 
82:         // when
83:         int numOf1 = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId1, itemId9 );
84:         int numOf2 = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId2, itemId9 );
85: 
86:         // then
87:         assertEquals( 0, numOf1 );
88:         assertEquals( 0, numOf2 );
89:         fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
90:         // ... ids must be invalid now
91:         assertThrows( ShopException.class,
92:                 () -> fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId1, itemId9 ) );
93:         assertThrows( ShopException.class,
94:                 () -> fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId2, itemId9 ) );
95:     }
96: 
97: 
98:     @Test
99:     public void testDeleteAllFulfillmentCentersWhenFull() {
100:         // given
101:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
102:         UUID itemId7 = itemTestHelper.getItemId( 7 );
103:         UUID fulfillmentCenterId1 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 1 );
104:         UUID fulfillmentCenterId2 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 2 );
105: 
106:         // when
107:         int numOf1 = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId1, itemId7 );
108:         int numOf2 = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId2, itemId7 );
109: 
110:         // then
111:         assertTrue( numOf1 == 3 );
112:         assertTrue( numOf2 == 3 );
113:         fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
114:         // ... ids must be invalid now
115:         assertThrows( ShopException.class,
116:                 () -> fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId1, itemId7 ) );
117:         assertThrows( ShopException.class,
118:                 () -> fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId2, itemId7 ) );
119:     }
120: 
121: 
122: 
123:     @Test
124:     public void testAddToStock() {
125:         // given
126:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
127:         UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in fulfillment center 0
128:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
129:         int originalStock5 =
130:                 fulfillmentCenterTestHelper.getFulfillmentCenterStock( 0, 5 );
131: 
132:         // when
133:         int stock5before = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId5 );
134:         fulfillmentCenterUseCases.addToStock( fulfillmentCenterId0, itemId5, 23 );
135:         int stock5after = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId5 );
136:         fulfillmentCenterUseCases.addToStock( fulfillmentCenterId0, itemId5, 0 );
137:         int stock5after2 = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId5 );
138: 
139:         // then
140:         assertEquals( originalStock5, stock5before );
141:         assertEquals( stock5before + 23, stock5after );
142:         assertEquals( stock5after, stock5after2 );
143:     }
144: 
145: 
146:     @Test
147:     public void testInvalidAddToStock() {
148:         // given
149:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
150:         UUID itemId2 = itemTestHelper.getItemId( 2 );
151:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
152: 
153:         // when
154:         // then
155:         assertThrows( ShopException.class,
156:                 () -> fulfillmentCenterUseCases.addToStock( nonExistingId1, nonExistingId2, 12 ) );
157:         assertThrows( ShopException.class,
158:                 () -> fulfillmentCenterUseCases.addToStock(
159:                         fulfillmentCenterId0, nonExistingId2, 12 ) );
160:         assertThrows( ShopException.class,
161:                 () -> fulfillmentCenterUseCases.addToStock(
162:                         nonExistingId1, itemId2, 12 ) );
163:         assertThrows( ShopException.class,
164:                 () -> fulfillmentCenterUseCases.addToStock(
165:                         fulfillmentCenterId0, itemId2, -1 ) );
166:     }
167: 
168: 
169:     @Test
170:     public void testRemoveFromStock() {
171:         // given
172:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
173:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
174:         UUID itemId0 = itemTestHelper.getItemId( 0 ); // 0 in fulfillment center 0
175:         UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in fulfillment center 0
176:         UUID itemId6 = itemTestHelper.getItemId( 6 ); // random >30 in fulfillment center 0
177:         int stock0before =
178:                 fulfillmentCenterTestHelper.getFulfillmentCenterStock( 0, 0 );
179:         int stock5before =
180:                 fulfillmentCenterTestHelper.getFulfillmentCenterStock( 0, 5 );
181:         int stock6before =
182:                 fulfillmentCenterTestHelper.getFulfillmentCenterStock( 0, 6 );
183: 
184:         // when
185:         fulfillmentCenterUseCases.removeFromStock( fulfillmentCenterId0, itemId5, 1 );
186:         int stock5after = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId5 );
187:         fulfillmentCenterUseCases.removeFromStock( fulfillmentCenterId0, itemId0, 0 );
188:         int stock0after = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId0 );
189:         fulfillmentCenterUseCases.removeFromStock(
190:                 fulfillmentCenterId0, itemId6, stock6before );
191:         int stock6after = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId6 );
192: 
193:         // then
194:         assertEquals( stock5before - 1, stock5after );
195:         assertEquals( stock0before, stock0after );
196:         assertEquals( 0, stock6after );
197:     }
198: 
199: 
200:     @Test
201:     public void testInvalidRemoveFromStock() {
202:         // given
203:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
204:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
205:         UUID itemId0 = itemTestHelper.getItemId( 0 ); // 0 in fulfillment center 0
206:         UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in fulfillment center 0
207:         int stock5before =
208:                 fulfillmentCenterTestHelper.getFulfillmentCenterStock( 0, 5 );
209: 
210:         // when
211:         // then
212:         assertThrows( ShopException.class,
213:                 () -> fulfillmentCenterUseCases.removeFromStock( nonExistingId1, nonExistingId2, 12 ) );
214:         assertThrows( ShopException.class,
215:                 () -> fulfillmentCenterUseCases.removeFromStock(
216:                         fulfillmentCenterId0, nonExistingId2, 12 ) );
217:         assertThrows( ShopException.class,
218:                 () -> fulfillmentCenterUseCases.removeFromStock(
219:                         nonExistingId1, itemId5, 12 ) );
220:         assertThrows( ShopException.class,
221:                 () -> fulfillmentCenterUseCases.removeFromStock(
222:                         fulfillmentCenterId0, itemId5, -1 ) );
223:         assertThrows( ShopException.class,
224:                 () -> fulfillmentCenterUseCases.removeFromStock(
225:                         fulfillmentCenterId0, itemId5, stock5before + 1 ) );
226:         assertThrows( ShopException.class,
227:                 () -> fulfillmentCenterUseCases.removeFromStock(
228:                         fulfillmentCenterId0, itemId0, 1 ) ); // already 0 in fulfillment center 0
229:     }
230: 
231: 
232:     @Test
233:     public void testChangeStock() {
234:         // given
235:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
236:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
237:         UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in fulfillment center 0
238: 
239:         // when
240:         fulfillmentCenterUseCases.changeStockTo( fulfillmentCenterId0, itemId5, 111 );
241:         int stock5after = fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId5 );
242: 
243:         // then
244:         assertEquals( 111, stock5after );
245:     }
246: 
247: 
248:     @Test
249:     public void testInvalidChangeStock() {
250:         // given
251:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
252:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
253:         UUID itemId6 = itemTestHelper.getItemId( 6 );
254: 
255:         // when
256:         // then
257:         assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeStockTo(
258:                 nonExistingId1, nonExistingId2, 12 ) );
259:         assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeStockTo(
260:                 nonExistingId1, itemId6, 12 ) );
261:         assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeStockTo(
262:                 fulfillmentCenterId0, nonExistingId2, 12 ) );
263:         assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeStockTo(
264:                 fulfillmentCenterId0, itemId6, -1 ) );
265:     }
266: 
267: 
268:     @Test
269:     public void testEmptyFulfillmentCenter() {
270:         // given
271:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
272:         UUID fulfillmentCenterId9 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 9 ); // empty fulfillment center
273: 
274:         // when
275:         int totalStock = 0;
276:         for ( int iItem = 0; iItem < itemTestHelper.numberOfItems(); iItem++ ) {
277:             UUID itemId = itemTestHelper.getItemId( iItem );
278:             totalStock += fulfillmentCenterUseCases.getAvailableStock(
279:                     fulfillmentCenterId9, itemId );
280:         }
281: 
282:         // then
283:         assertEquals( 0, totalStock );
284:     }
285: 
286: 
287: 
288: }
289: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\item\ItemCatalogTest.java ---
1: package thkoeln.archilab.ecommerce.tests.item;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
9: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
15: 
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.*;
19: 
20: 
21: @SpringBootTest
22: public class ItemCatalogTest {
23:     @Autowired
24:     private ClientRegistrationUseCases clientRegistrationUseCases;
25:     @Autowired
26:     private ShoppingBasketUseCases shoppingBasketUseCases;
27:     @Autowired
28:     private ItemCatalogUseCases itemCatalogUseCases;
29:     @Autowired
30:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private ClientTestHelper clientTestHelper;
35:     @Autowired
36:     private ItemTestHelper itemTestHelper;
37:     @Autowired
38:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
39: 
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         clientTestHelper.registerAllClients();
45:         itemTestHelper.addAllItems();
46:     }
47: 
48: 
49:     @Test
50:     public void testAddItemToCatalog() {
51:         // given
52:         UUID itemId4 = itemTestHelper.getItemId( 4 );
53:         MoneyType sellingPrice4 = itemTestHelper.getSellingPrice( 4 );
54: 
55:         // when
56:         MoneyType foundSellingPrice = itemCatalogUseCases.getSellingPrice( itemId4 );
57: 
58:         // then
59:         assertEquals( sellingPrice4, foundSellingPrice );
60:     }
61: 
62: 
63:     @Test
64:     public void testAddItemWithInvalidData() {
65:         // given
66:         String name = "SomeStuff";
67:         String description = "Some more explanation on the stuff";
68:         Float size = 5.0f;
69:         MoneyType buyingPrice =
70:                 FactoryMethodInvoker.instantiateMoney( 5.0f, "EUR" );
71:         MoneyType sellingPrice =
72:                 FactoryMethodInvoker.instantiateMoney( 10.0f, "EUR" );
73:         MoneyType tooLowSellingPrice =
74:                 FactoryMethodInvoker.instantiateMoney( 4.0f, "EUR" );
75: 
76:         // when / then
77:         assertThrows( ShopException.class, () ->
78:                 itemCatalogUseCases.addItemToCatalog(
79:                         null, description, size, buyingPrice, sellingPrice ) );
80:         assertThrows( ShopException.class, () ->
81:                 itemCatalogUseCases.addItemToCatalog(
82:                         "", description, size, buyingPrice, sellingPrice ) );
83:         assertThrows( ShopException.class, () ->
84:                 itemCatalogUseCases.addItemToCatalog(
85:                         name, null, size, buyingPrice, sellingPrice ) );
86:         assertThrows( ShopException.class, () ->
87:                 itemCatalogUseCases.addItemToCatalog(
88:                         name, "", size, buyingPrice, sellingPrice ) );
89:         assertThrows( ShopException.class, () ->
90:                 itemCatalogUseCases.addItemToCatalog(
91:                         name, description, size, null, sellingPrice ) );
92:         assertThrows( ShopException.class, () ->
93:                 itemCatalogUseCases.addItemToCatalog(
94:                         name, description, size, buyingPrice, null ) );
95:         assertThrows( ShopException.class, () ->
96:                 itemCatalogUseCases.addItemToCatalog(
97:                         name, description, size, buyingPrice, tooLowSellingPrice ) );
98:     }
99: 
100: 
101:     @Test
102:     public void testRemoveNonExistentItem() {
103:         // given item 2 is not in stock anywhere - should be removable
104:         UUID nonExistentItemId = UUID.randomUUID();
105: 
106:         // when
107:         // then
108:         assertThrows( ShopException.class,
109:                 () -> itemCatalogUseCases.removeItemFromCatalog( nonExistentItemId ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testRemoveItemWithNoStock() {
115:         // given item 0 is not in stock anywhere - should be removable
116:         UUID itemId0 = itemTestHelper.getItemId( 0 );
117:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
118: 
119:         // when
120:         assertDoesNotThrow( () -> itemCatalogUseCases.getSellingPrice( itemId0 ) );
121:         itemCatalogUseCases.removeItemFromCatalog( itemId0 );
122: 
123:         // then
124:         assertThrows( ShopException.class, () ->
125:                 itemCatalogUseCases.getSellingPrice( itemId0 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testRemoveItemThatIsInStock() {
131:         // given
132:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
133:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
134:         UUID itemId3 = itemTestHelper.getItemId( 3 );
135:         UUID itemId4 = itemTestHelper.getItemId( 4 );
136:         fulfillmentCenterUseCases.addToStock( fulfillmentCenterId0, itemId3, 3 );
137: 
138:         // then item 3 must not be removable, but item 4 must be removable
139:         assertThrows( ShopException.class,
140:                 () -> itemCatalogUseCases.removeItemFromCatalog( itemId3 ) );
141:         assertDoesNotThrow( () -> itemCatalogUseCases.removeItemFromCatalog( itemId4 ) );
142:     }
143: 
144: 
145:     @Test
146:     public void testRemoveItemThatIsInOrder() {
147:         // given
148:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
149:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
150:         UUID itemId4 = itemTestHelper.getItemId( 4 );
151:         EmailAddressType clientEmailAddress4 =
152:                 clientTestHelper.getClientEmailAddress( 4 );
153:         fulfillmentCenterUseCases.addToStock( fulfillmentCenterId0, itemId4, 4 );
154: 
155:         // when client 4 adds 4x item 4 to his shopping basket and checks out ...
156:         shoppingBasketUseCases.addItemToShoppingBasket(
157:                 clientEmailAddress4, itemId4, 4 );
158:         shoppingBasketUseCases.checkout( clientEmailAddress4 );
159: 
160:         // then item 4 must not be removable
161:         assertThrows( ShopException.class,
162:                 () -> itemCatalogUseCases.removeItemFromCatalog( itemId4 ) );
163:     }
164: 
165: 
166:     @Test
167:     public void testClearItemCatalog() {
168:         // given
169:         UUID itemId4 = itemTestHelper.getItemId( 4 );
170: 
171:         // when
172:         itemCatalogUseCases.deleteItemCatalog();
173: 
174:         // then
175:         assertThrows( ShopException.class, () -> itemCatalogUseCases.getSellingPrice( itemId4 ) );
176:     }
177: 
178: }
179: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\order\OrderTest.java ---
1: package thkoeln.archilab.ecommerce.tests.order;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: 
15: import java.util.Map;
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.assertEquals;
19: import static org.junit.jupiter.api.Assertions.assertThrows;
20: 
21: 
22: @SpringBootTest
23: public class OrderTest {
24:     @Autowired
25:     private ClientRegistrationUseCases clientRegistrationUseCases;
26:     @Autowired
27:     private ShoppingBasketUseCases shoppingBasketUseCases;
28:     @Autowired
29:     private ItemCatalogUseCases itemCatalogUseCases;
30:     @Autowired
31:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
32:     @Autowired
33:     private OrderUseCases orderUseCases;
34:     @Autowired
35:     private Purgatory purgatory;
36:     @Autowired
37:     private ClientTestHelper clientTestHelper;
38:     @Autowired
39:     private ItemTestHelper itemTestHelper;
40:     @Autowired
41:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
42: 
43:     private UUID nonExistingId1;
44:     private UUID nonExistingId2;
45: 
46:     @BeforeEach
47:     public void setUp() {
48:         purgatory.deleteEverything();
49:         clientTestHelper.registerAllClients();
50:         itemTestHelper.addAllItems();
51:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
52:         nonExistingId1 = UUID.randomUUID();
53:         nonExistingId2 = UUID.randomUUID();
54:     }
55: 
56: 
57:     @Test
58:     public void testOrderHistory() {
59:         // given
60:         UUID itemId1 = itemTestHelper.getItemId( 1 );
61:         UUID itemId2 = itemTestHelper.getItemId( 2 );
62:         EmailAddressType clientEmailAddress7 =
63:                 clientTestHelper.getClientEmailAddress( 7 );
64:         Map<UUID, Integer> orderHistoryBefore = orderUseCases.getOrderHistory( clientEmailAddress7 );
65: 
66:         // when
67:         shoppingBasketUseCases.addItemToShoppingBasket(
68:                 clientEmailAddress7, itemId1, 3 );
69:         shoppingBasketUseCases.addItemToShoppingBasket(
70:                 clientEmailAddress7, itemId2, 2 );
71:         shoppingBasketUseCases.checkout( clientEmailAddress7 );
72:         Map<UUID, Integer> orderHistory1 =
73:                 orderUseCases.getOrderHistory( clientEmailAddress7 );
74:         shoppingBasketUseCases.addItemToShoppingBasket(
75:                 clientEmailAddress7, itemId1, 6 );
76:         shoppingBasketUseCases.addItemToShoppingBasket(
77:                 clientEmailAddress7, itemId2, 2 );
78:         shoppingBasketUseCases.checkout( clientEmailAddress7 );
79:         Map<UUID, Integer> orderHistory2 =
80:                 orderUseCases.getOrderHistory( clientEmailAddress7 );
81:         shoppingBasketUseCases.addItemToShoppingBasket(
82:                 clientEmailAddress7, itemId1, 1 );
83:         shoppingBasketUseCases.addItemToShoppingBasket(
84:                 clientEmailAddress7, itemId2, 6 );
85:         shoppingBasketUseCases.checkout( clientEmailAddress7 );
86:         Map<UUID, Integer> orderHistory3 =
87:                 orderUseCases.getOrderHistory( clientEmailAddress7 );
88: 
89:         // then
90:         assertEquals( 0, orderHistoryBefore.size() );
91:         assertEquals( 2, orderHistory1.size() );
92:         assertEquals( 2, orderHistory2.size() );
93:         assertEquals( 2, orderHistory3.size() );
94:         assertEquals( 3, orderHistory1.get( itemId1 ) );
95:         assertEquals( 2, orderHistory1.get( itemId2 ) );
96:         assertEquals( 9, orderHistory2.get( itemId1 ) );
97:         assertEquals( 4, orderHistory2.get( itemId2 ) );
98:         assertEquals( 10, orderHistory3.get( itemId1 ) );
99:         assertEquals( 10, orderHistory3.get( itemId2 ) );
100:     }
101: 
102: 
103:     @Test
104:     public void testForEmptyOrderHistory() {
105:         // given
106:         EmailAddressType clientEmailAddress4 =
107:                 clientTestHelper.getClientEmailAddress( 4 );
108:         // when
109:         Map<UUID, Integer> orderHistory =
110:                 orderUseCases.getOrderHistory( clientEmailAddress4 );
111:         // then
112:         assertEquals( 0, orderHistory.size() );
113:     }
114: 
115: 
116:     @Test
117:     public void testInvalidParamsForGetOrderQuantForItem() {
118:         // given
119:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
120: 
121:         // when / then
122:         assertThrows ( ShopException.class,
123:                 () -> orderUseCases.getOrderQuantForItem( null, null ) );
124:         assertThrows ( ShopException.class,
125:                 () -> orderUseCases.getOrderQuantForItem( nonExistingId1, null ) );
126:         assertThrows ( ShopException.class,
127:                 () -> orderUseCases.getOrderQuantForItem( null, nonExistingId2 ) );
128:         assertThrows ( ShopException.class,
129:                 () -> orderUseCases.getOrderQuantForItem( nonExistingId1, nonExistingId2 ) );
130:         assertThrows ( ShopException.class,
131:                 () -> orderUseCases.getOrderQuantForItem( fulfillmentCenterId0, null ) );
132:         assertThrows ( ShopException.class,
133:                 () -> orderUseCases.getOrderQuantForItem( fulfillmentCenterId0, nonExistingId2 ) );
134:     }
135: 
136: 
137:     @Test
138:     public void testInvalidParamsForGetFulfillmentCenterIdForOrder() {
139:         // given / when / then
140:         assertThrows ( ShopException.class,
141:                 () -> orderUseCases.getFulfillmentCenterIdForOrder( null ) );
142:         assertThrows ( ShopException.class,
143:                 () -> orderUseCases.getFulfillmentCenterIdForOrder( nonExistingId1 ) );
144:     }
145: }
146: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: 
6: import static org.junit.jupiter.api.Assertions.fail;
7: import com.fasterxml.jackson.databind.ObjectMapper;
8: import org.junit.jupiter.api.BeforeEach;
9: import org.junit.jupiter.api.Test;
10: import thkoeln.archilab.ecommerce.domainprimitives.*;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
12: 
13: import java.math.BigDecimal;
14: 
15: import static org.assertj.core.api.Assertions.assertThat;
16: 
17: 
18: 
19: public class DomainPrimitiveJSONSerializationTest {
20: 
21:     private ObjectMapper objectMapper;
22: 
23:     @BeforeEach
24:     public void setUp() {
25:         objectMapper = new ObjectMapper();
26:     }
27: 
28: 
29:     /**
30:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
31:      * EmailAddress.
32:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
33:      * on how to implement this test, and how to change property names.
34:      * @throws Exception
35:      */
36:     @Test
37:     public void test_EmailAddress_Serialization() throws Exception {
38:         // TODO: implement this test
39:         // given
40:         EmailAddressType email = EmailAddress.of("test@example.com");
41: 
42:         // when
43:         String json = objectMapper.writeValueAsString(email); // → "test@example.com"
44:         EmailAddress deserialized = objectMapper.readValue(json, EmailAddress.class);
45: 
46:         // then
47:         assertThat(json).contains("test@example.com");
48:         assertThat(deserialized).isEqualTo(email);
49:     }
50: 
51: 
52:     /**
53:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
54:      * ZipCode.
55:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
56:      * on how to implement this test, and how to change property names.
57:      * @throws Exception
58:      */
59:     @Test
60:     public void test_ZipCode_Serialization() throws Exception {
61:         // TODO: implement this test
62:         // given
63:         ZipCode zipCode = ZipCode.of("50667");
64: 
65:         // when
66:         String json = objectMapper.writeValueAsString(zipCode);
67:         ZipCode deserialized = objectMapper.readValue(json, ZipCode.class);
68: 
69:         // then
70:         assertThat(json).contains("50667");
71:         assertThat(deserialized).isEqualTo(zipCode);
72:     }
73: 
74: 
75:     /**
76:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
77:      * PhysicalAddress.
78:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
79:      * on how to implement this test, and how to change property names.
80:      * @throws Exception
81:      */
82:     @Test
83:     public void test_PhysicalAddress_Serialization() throws Exception {
84:         // TODO: implement this test
85:         // given
86:         PhysicalAddress address = PhysicalAddress.of("Bahnhofstr. 1", "Köln", ZipCode.of("50667"));
87: 
88:         // when
89:         String json = objectMapper.writeValueAsString(address);
90:         PhysicalAddress deserialized = objectMapper.readValue(json, PhysicalAddress.class);
91: 
92:         // then
93:         assertThat(json).contains("Bahnhofstr. 1", "Köln", "50667");
94:         assertThat(deserialized).isEqualTo(address);
95:     }
96: 
97: 
98:     /**
99:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
100:      * Money.
101:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
102:      * on how to implement this test, and how to change property names.
103:      * @throws Exception
104:      */
105:     @Test
106:     public void test_Money_Serialization() throws Exception {
107:         // TODO: implement this test
108:         // given
109:         Money money = Money.of(12.34f, "EUR");
110: 
111:         // when
112:         String json = objectMapper.writeValueAsString(money);
113:         Money deserialized = objectMapper.readValue(json, Money.class);
114: 
115:         // then
116:         assertThat(json).contains("12.34", "EUR");
117:         assertThat(deserialized).isEqualTo(money);
118:     }
119: 
120: }
121: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingBasketRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
11: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
12: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
15: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
16: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
17: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
18: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
19: 
20: import java.util.Locale;
21: import java.util.Map;
22: import java.util.UUID;
23: 
24: import static org.assertj.core.api.Assertions.assertThat;
25: 
26: 
27: @SpringBootTest
28: @Transactional
29: @AutoConfigureMockMvc
30: @Import(RESTTestHelperConfiguration.class)
31: public class OwnShoppingBasketRESTTest {
32:     @Autowired
33:     private Purgatory purgatory;
34:     @Autowired
35:     private ClientTestHelper clientTestHelper;
36:     @Autowired
37:     private ItemTestHelper itemTestHelper;
38:     @Autowired
39:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
40:     @Autowired
41:     private ShoppingBasketUseCases shoppingBasketUseCases;
42:     @Autowired
43:     private ShoppingBasketRESTHelper shoppingBasketRESTHelper;
44: 
45:     @BeforeEach
46:     public void setUp() {
47:         purgatory.deleteEverything();
48:         clientTestHelper.registerAllClients();
49:         itemTestHelper.addAllItems();
50:         fulfillmentCenterTestHelper.addAllFulfillmentCenters(true);
51:         Locale.setDefault(Locale.US);
52: 
53:         // ... add own setup code here
54:     }
55: 
56: 
57:     /**
58:      * Provide a test that implements a simple call to the REST endpoint (3):
59:      * <pre>
60:      *     GET /shoppingBaskets?clientId=<client id as uuid>
61:      * </pre>
62:      * - Use the {@link ClientTestHelper} to obtain to obtain the email address
63:      * of some example client.
64:      * - Use your shopping basket service to add entries to the shopping basket of that person.
65:      * - then use the `ShoppingBasketRESTHelper` to create the GET call, and check the results.
66:      * - (or do it by directly calling your REST controller, if you prefer)
67:      *
68:      * @throws Exception
69:      */
70:     @Test
71:     public void test_getQuery_ShoppingBasket() throws Exception {
72:         // TODO: implement this test
73:         // given
74:         EmailAddressType email = clientTestHelper.getClientEmailAddress(1);
75:         EmailAddress unused = (EmailAddress) email;
76:         UUID itemId = itemTestHelper.getItemId(1); // irgendein Item
77:         shoppingBasketUseCases.addItemToShoppingBasket(email, itemId, 3);
78: 
79:         Map<UUID, Integer> expectedQuantities = Map.of(itemId, 3);
80: 
81:         // when
82:         UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(email, expectedQuantities);
83: 
84:         // then
85:         assertThat(basketId).isNotNull();
86:     }
87: 
88: 
89:     /**
90:      * Provide a test that implements the addition of one item to the shopping basket via
91:      * REST endpoint (6):
92:      * <pre>
93:      *     POST /shoppingBaskets/{shoppingBasket-Id}/positions
94:      * </pre>
95:      * You can test now "the other way around" as in test_getQuery_ShoppingBasket():
96:      * - Use `ShoppingBasketRESTHelper` to add items via REST, then use shopping basket service methods
97:      * to check of the shopping basket contains the right stuff.
98:      * - (or do it by directly calling your REST controller, if you prefer)
99:      *
100:      * @throws Exception
101:      */
102:     @Test
103:     public void test_post_ShoppingBasketPositions() throws Exception {
104:         // given
105:         EmailAddressType email = clientTestHelper.getClientEmailAddress(1);
106:         UUID itemId = itemTestHelper.getItemId(1);
107:         shoppingBasketUseCases.addItemToShoppingBasket(email, itemId, 3);
108:         Map<UUID, Integer> expectedQuantities = Map.of(itemId, 3);
109: 
110:         EmailAddressType emailWithOtherDomain = email.sameIdentifyerDifferentDomain("example.com");
111:         assertThat(emailWithOtherDomain).isNotNull(); // echte Verwendung
112: 
113:         // when
114:         UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(email, expectedQuantities);
115: 
116:         // then
117:         assertThat(basketId).isNotNull();
118:     }
119: 
120: 
121:     /**
122:      * Provide a test that implements the deletion of one item in the shopping basket via
123:      * REST endpoint (10):
124:      * <pre>
125:      *     DELETE /shoppingBaskets/{shoppingBasket-Id}/positions/{item-Id}
126:      * </pre>
127:      * This should be just a slight variation of the test_post_ShoppingBasketPositions()
128:      * method, but instead of adding an item to the shopping basket, you delete it.
129:      *
130:      * @throws Exception
131:      */
132:     @Test
133:     public void test_delete_ShoppingBasketPositions() throws Exception {
134:         // TODO: implement this test
135:         // given – Beispielkunde und Item
136:         EmailAddressType email = clientTestHelper.getClientEmailAddress(3); // Emilia Fischer
137:         UUID itemId = itemTestHelper.getItemId(3);
138:         int quantity = 4;
139: 
140:         // Erstes Item hinzufügen )
141:         shoppingBasketUseCases.addItemToShoppingBasket(email, itemId, quantity);
142: 
143:         // Basket abfragen (Basket existiert sicher)
144:         UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(email, Map.of(itemId, quantity));
145: 
146:         // when – per REST-Call löschen
147:         shoppingBasketRESTHelper.deleteItemFromShoppingBasket(basketId, itemId);
148: 
149:         // then – sicherstellen, dass Basket leer ist
150:         shoppingBasketRESTHelper.getQueryShoppingBasket(email, Map.of()); // leer erwartet
151:     }
152: 
153: 
154:     /**
155:      * Provide a test that implements the checkout of a shopping basket that can be served
156:      * by just 1 fulfillment center, using the REST endpoint (11):
157:      * <pre>
158:      *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
159:      * </pre>
160:      * - Use your shopping basket service to add entries to the shopping basket of some example client,
161:      * - then use the `ShoppingBasketRESTHelper to post the checkout call, and to check the results.
162:      * - (or do it by directly calling your REST controller, if you prefer)
163:      *
164:      * @throws Exception
165:      */
166:     @Test
167:     public void test_checkout_1_fulfillmentCenter() throws Exception {
168:         // TODO: implement this test
169:         // given – Beispielkunde und Item
170:         EmailAddressType email = clientTestHelper.getClientEmailAddress(3); // Emilia Fischer
171:         UUID itemId = itemTestHelper.getItemId(3);
172:         int quantity = 2;
173: 
174:         // Schritt 1: Item zum Basket hinzufügen (via Service oder REST)
175:         shoppingBasketUseCases.addItemToShoppingBasket(email, itemId, quantity);
176:         Map<UUID, Integer> expectedItems = Map.of(itemId, quantity);
177:         UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(email, expectedItems);
178: 
179: 
180:         UUID fc0Id = fulfillmentCenterTestHelper.getFulfillmentCenterId(0);
181:         Map<UUID, Map<UUID, Integer>> expectedOrders = Map.of(
182:                 fc0Id, Map.of(itemId, quantity)
183:         );
184: 
185:         // when – Checkout durchführen
186:         shoppingBasketRESTHelper.checkout(basketId, clientTestHelper.getClientName(3), null, expectedOrders);
187: 
188:         // then – (indirekt getestet durch ShoppingBasketRESTHelper)
189: 
190:     }
191: 
192: 
193:     /**
194:      * Provide a test that implements the checkout of a shopping basket that can only be served
195:      * by using 2 fulfillment centers, using the REST endpoint (11):
196:      * <pre>
197:      *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
198:      * </pre>
199:      * This should be just a slight variation of thetest_checkout_1_fulfillmentCenter() test.
200:      *
201:      * @throws Exception
202:      */
203:     @Test
204:     public void test_checkout_2_fulfillmentCenters() throws Exception {
205:         // TODO: implement this test
206:         // given
207:         EmailAddressType email = clientTestHelper.getClientEmailAddress(4); // z. B. Jakob Klein
208:         UUID itemId = itemTestHelper.getItemId(8); // Item 8 = P8
209: 
210:         UUID fc7Id = fulfillmentCenterTestHelper.getFulfillmentCenterId(7); // FC7 hat den Großteil
211: 
212:         // Item 8 in den Warenkorb legen (6 Stück)
213:         shoppingBasketUseCases.addItemToShoppingBasket(email, itemId, 6);
214:         UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(email, Map.of(itemId, 6));
215: 
216:         // Erwartete Orders: alles von FC7
217:         Map<UUID, Map<UUID, Integer>> expectedOrders = Map.of(
218:                 fc7Id, Map.of(itemId, 6)
219:         );
220: 
221:         // when & then
222:         shoppingBasketRESTHelper.checkout(basketId, clientTestHelper.getClientName(4), null, expectedOrders);
223: 
224:     }
225: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\CheckoutAcceptanceTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingbasket;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: 
15: import java.util.*;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: 
19: /**
20:  * This test checks the management of stock across fulfillment centers. It focuses on the
21:  * cases where more than one fulfillment center are needed to serve the shopping basket of a client.
22:  */
23: @Slf4j
24: @SpringBootTest
25: public class CheckoutAcceptanceTest {
26:     @Autowired
27:     private ClientRegistrationUseCases clientRegistrationUseCases;
28:     @Autowired
29:     private ShoppingBasketUseCases shoppingBasketUseCases;
30:     @Autowired
31:     private ItemCatalogUseCases itemCatalogUseCases;
32:     @Autowired
33:     private OrderUseCases orderUseCases;
34:     @Autowired
35:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private ClientTestHelper clientTestHelper;
40:     @Autowired
41:     private ItemTestHelper itemTestHelper;
42:     @Autowired
43:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
44: 
45:     private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
46:                                 map8_11_14_quantity_3_3_4,
47:                                 map10_12_quantity_1_1, 
48:                                 map11_quantity_1, 
49:                                 map12_quantity_10,
50:                                 map8_9_10_11_quantity_2_1_4_2;
51:     private EmailAddressType clientEmailAddress3, clientEmailAddress6,
52:             clientEmailAddress2;
53:     private UUID itemId8, itemId9, itemId10, itemId11, itemId12,
54:             itemId14;
55: 
56: 
57:     @BeforeEach
58:     public void setUp() {
59:         purgatory.deleteEverything();
60:         clientTestHelper.registerAllClients();
61:         itemTestHelper.addAllItems();
62:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
63: 
64:         clientEmailAddress3 = clientTestHelper.getClientEmailAddress( 3 );
65:         clientEmailAddress6 = clientTestHelper.getClientEmailAddress( 6 );
66:         clientEmailAddress2 = clientTestHelper.getClientEmailAddress( 2 );
67: 
68:         itemId8 = itemTestHelper.getItemId( 8 );
69:         itemId9 = itemTestHelper.getItemId( 9 );
70:         itemId10 = itemTestHelper.getItemId( 10 );
71:         itemId11 = itemTestHelper.getItemId( 11 );
72:         itemId12 = itemTestHelper.getItemId( 12 );
73:         itemId14 = itemTestHelper.getItemId( 14 );
74: 
75:         map8_11_14_quantity_2_2_2 = new HashMap<>() {{
76:             put( itemId8, 2 );
77:             put( itemId11, 2 );
78:             put( itemId14, 2 );
79:         }};
80:         map8_11_14_quantity_3_3_4 = new HashMap<>() {{
81:             put( itemId8, 3 );
82:             put( itemId11, 3 );
83:             put( itemId14, 4 );
84:         }};
85:         map10_12_quantity_1_1 = new HashMap<>() {{
86:             put( itemId10, 1 );
87:             put( itemId12, 1 );
88:         }};
89:         map11_quantity_1 = new HashMap<>() {{
90:             put( itemId11, 1 );
91:         }};
92:         map12_quantity_10 = new HashMap<>() {{
93:             put( itemId12, 10 );
94:         }};
95:         map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
96:             put( itemId8, 2 );
97:             put( itemId9, 1 );
98:             put( itemId10, 4 );
99:             put( itemId11, 2 );
100:         }};
101: 
102:     }
103: 
104: 
105:     /**
106:      * Hint: to better understand the expected results of this test, see the distribution of stock
107:      * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
108:      */
109:     @Test
110:     public void testClosestSingleFulfillmentCenterWins() {
111:         log.info( "testClosestSingleFulfillmentCenterWins" );
112: 
113:         // given
114:         shoppingBasketUseCases.addItemToShoppingBasket(
115:                 clientEmailAddress3, itemId8, 2 );
116:         shoppingBasketUseCases.addItemToShoppingBasket(
117:                 clientEmailAddress3, itemId11, 2 );
118:         shoppingBasketUseCases.addItemToShoppingBasket(
119:                 clientEmailAddress3, itemId14, 2 );
120:         // that basket could have been served from fulfillment center 4 or 7, but 4 is closer to the client
121:         UUID fulfillmentCenterId4 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 4 );
122: 
123:         // when
124:         Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmailAddress3 );
125: 
126:         // then
127:         checkFulfillmentCenterIds( orderIds, fulfillmentCenterId4 );
128:         checkItemNumbers( orderIds, fulfillmentCenterId4, map8_11_14_quantity_2_2_2 );
129:     }
130: 
131: 
132:     /**
133:      * Hint: to better understand the expected results of this test, see the distribution of stock
134:      * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
135:      */
136:     @Test
137:     public void testFulfillmentCenterWithEnoughCapacityWins() {
138:         log.info( "testFulfillmentCenterWithEnoughCapacityWins" );
139: 
140:         // given
141:         shoppingBasketUseCases.addItemToShoppingBasket(
142:                 clientEmailAddress3, itemId8, 3 );
143:         shoppingBasketUseCases.addItemToShoppingBasket(
144:                 clientEmailAddress3, itemId11, 3 );
145:         shoppingBasketUseCases.addItemToShoppingBasket(
146:                 clientEmailAddress3, itemId14, 4 );
147:         // that basket could have been served from fulfillment center 4 or 7, 4 is closer to the client,
148:         // but only 7 has enough capacity
149:         UUID fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );
150: 
151:         // when
152:         Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmailAddress3 );
153: 
154:         // then
155:         checkFulfillmentCenterIds( orderIds, fulfillmentCenterId7 );
156:         checkItemNumbers( orderIds, fulfillmentCenterId7, map8_11_14_quantity_3_3_4 );
157:     }
158: 
159: 
160:     /**
161:      * Hint: to better understand the expected results of this test, see the distribution of stock
162:      * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
163:      */
164:     @Test
165:     public void testTwoFulfillmentCenters() {
166:         log.info( "testTwoFulfillmentCenters" );
167: 
168:         // given
169:         shoppingBasketUseCases.addItemToShoppingBasket(
170:                 clientEmailAddress6, itemId10, 1 );
171:         shoppingBasketUseCases.addItemToShoppingBasket(
172:                 clientEmailAddress6, itemId11, 1 );
173:         shoppingBasketUseCases.addItemToShoppingBasket(
174:                 clientEmailAddress6, itemId12, 1 );
175:         // that basket needs two deliveries (2 + 1 items) anyway, and there
176:         // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
177:         // closer. The smaller can then be served from 4 (closest), 7, or 8.
178:         UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
179:                 // should cover map10_12_quantity_1_1
180:         UUID fulfillmentCenterId4 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 4 );
181:                 // should cover map11_quantity_1
182: 
183:         // when
184:         Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmailAddress6 );
185: 
186:         // then
187:         checkFulfillmentCenterIds( orderIds, fulfillmentCenterId5, fulfillmentCenterId4 );
188:         checkItemNumbers( orderIds, fulfillmentCenterId5, map10_12_quantity_1_1 );
189:         checkItemNumbers( orderIds, fulfillmentCenterId4, map11_quantity_1 );
190:     }
191: 
192: 
193:     /**
194:      * Hint: to better understand the expected results of this test, see the distribution of stock
195:      * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
196:      */
197:     @Test
198:     public void testTwoBigDeliverys() {
199:         log.info( "testTwoBigDeliverys" );
200: 
201:         // given
202:         shoppingBasketUseCases.addItemToShoppingBasket(
203:                 clientEmailAddress2, itemId8, 2 );
204:         shoppingBasketUseCases.addItemToShoppingBasket(
205:                 clientEmailAddress2, itemId9, 1 );
206:         shoppingBasketUseCases.addItemToShoppingBasket(
207:                 clientEmailAddress2, itemId10, 4 );
208:         shoppingBasketUseCases.addItemToShoppingBasket(
209:                 clientEmailAddress2, itemId11, 2 );
210:         shoppingBasketUseCases.addItemToShoppingBasket(
211:                 clientEmailAddress2, itemId12, 10 );
212:         // when
213:         Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmailAddress2 );
214:         UUID fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );
215:                 // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 items
216:         UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
217:                 // should cover map12_quantity_10 - the only fulfillment center with enough capacity for 10 items
218: 
219:         // then
220:         checkFulfillmentCenterIds( orderIds, fulfillmentCenterId7, fulfillmentCenterId5 );
221:         checkItemNumbers( orderIds, fulfillmentCenterId7, map8_9_10_11_quantity_2_1_4_2 );
222:         checkItemNumbers( orderIds, fulfillmentCenterId5, map12_quantity_10 );
223:     }
224: 
225: 
226:     /**
227:      * Hint: to better understand the expected results of this test, see the distribution of stock
228:      * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
229:      */
230:     @Test
231:     public void testOnlyOneSolution() {
232:         log.info( "testOnlyOneSolution" );
233: 
234:         // given
235:         shoppingBasketUseCases.addItemToShoppingBasket(
236:                 clientEmailAddress6, itemId12, 10 );
237:         // when
238:         Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmailAddress6 );
239:         UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
240:         // should cover map12_quantity_10 - the only fulfillment center with enough capacity for 10 items
241: 
242:         // then
243:         checkFulfillmentCenterIds( orderIds, fulfillmentCenterId5 );
244:         checkItemNumbers( orderIds, fulfillmentCenterId5, map12_quantity_10 );
245:     }
246: 
247: 
248: 
249:     private void checkItemNumbers( Set<UUID> orderIds, UUID fulfillmentCenterId, Map<UUID, Integer> expectedMap ) {
250:         UUID fittingOrderId = null;
251:         for ( UUID orderId : orderIds ) {
252:             UUID foundFulfillmentCenterId = orderUseCases.getFulfillmentCenterIdForOrder( orderId );
253:             if ( foundFulfillmentCenterId.equals( fulfillmentCenterId ) ) {
254:                 fittingOrderId = orderId;
255:                 break;
256:             }
257:         }
258:         assertNotNull( fittingOrderId, "No fitting order found for fulfillment center " + fulfillmentCenterId );
259: 
260:         int totalExpected = 0;
261:         int totalActual = 0;
262:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
263:             totalExpected += entry.getValue();
264:         }
265:         log.info( "Check order numbers for item {} in fulfillment center {}", fittingOrderId, fulfillmentCenterId );
266:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
267:             UUID itemId = entry.getKey();
268:             Integer foundNumber =
269:                     orderUseCases.getOrderQuantForItem( fittingOrderId, itemId );
270:             assertEquals( entry.getValue(), foundNumber );
271:             totalActual += foundNumber;
272:         }
273:         // last check - do the total sums match?
274:         assertEquals( totalExpected, totalActual );
275:     }
276: 
277: 
278:     private void checkFulfillmentCenterIds( Set<UUID> orderIds, UUID... expectedFulfillmentCenterIds ) {
279:         assertEquals( expectedFulfillmentCenterIds.length, orderIds.size() );
280:         Set<UUID> foundFulfillmentCenterIds = new HashSet<>();
281:         for ( UUID orderId : orderIds ) {
282:             UUID fulfillmentCenterId = orderUseCases.getFulfillmentCenterIdForOrder( orderId );
283:             foundFulfillmentCenterIds.add( fulfillmentCenterId );
284:         }
285:         for ( UUID expectedFulfillmentCenterId : expectedFulfillmentCenterIds ) {
286:             assertTrue( foundFulfillmentCenterIds.contains( expectedFulfillmentCenterId ) );
287:         }
288:     }
289: 
290: }
291: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingbasket;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.ResultMatcher;
12: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
13: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
14: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
15: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
17: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
18: import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
19: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
20: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
21: 
22: import java.util.HashMap;
23: import java.util.Map;
24: import java.util.UUID;
25: 
26: import static org.junit.jupiter.api.Assertions.assertEquals;
27: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
28: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
29: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmailAddress;
30: 
31: 
32: @SpringBootTest
33: @Transactional
34: @AutoConfigureMockMvc
35: @Import( RESTTestHelperConfiguration.class )
36: public class ShoppingBasketRESTTest {
37:     @Autowired
38:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
39:     @Autowired
40:     private ShoppingBasketUseCases shoppingBasketUseCases;
41:     @Autowired
42:     private Purgatory purgatory;
43:     @Autowired
44:     private ClientTestHelper clientTestHelper;
45:     @Autowired
46:     private ItemTestHelper itemTestHelper;
47:     @Autowired
48:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
49:     @Autowired
50:     private MockMvc mockMvc;
51:     @Autowired
52:     private ShoppingBasketRESTHelper shoppingBasketRESTHelper;
53: 
54:     private EmailAddressType nonExistingEmailAddress;
55:     private final Map<UUID, Integer> emptyMap = new HashMap<>();
56: 
57:     private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
58:     private EmailAddressType
59:             clientEmailAddress0,
60:             clientEmailAddress3,
61:             clientEmailAddress6,
62:             clientEmailAddress8;
63:     private String clientName0, clientName8;
64:     private UUID itemId0, itemId1, itemId2, itemId3, itemId5,
65:                  itemId7, itemId9, itemId11, nonExistentItemId;
66:     private UUID fulfillmentCenterId0, fulfillmentCenterId3, fulfillmentCenterId7, fulfillmentCenterId8;
67: 
68: 
69:     private static final ResultMatcher NOT_FOUND = status().isNotFound();
70:     private static final ResultMatcher OK = status().isOk();
71:     private static final ResultMatcher CREATED = status().isCreated();
72:     private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
73:     private static final ResultMatcher CONFLICT = status().isConflict();
74: 
75:     @BeforeEach
76:     public void setUp() {
77:         purgatory.deleteEverything();
78:         clientTestHelper.registerAllClients();
79:         itemTestHelper.addAllItems();
80:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
81:         nonExistingEmailAddress = instantiateEmailAddress( "harry@sally.de" );
82: 
83:         clientEmailAddress0 = clientTestHelper.getClientEmailAddress( 0 );
84:         clientEmailAddress3 = clientTestHelper.getClientEmailAddress( 3 );
85:         clientEmailAddress6 = clientTestHelper.getClientEmailAddress( 6 );
86:         clientEmailAddress8 = clientTestHelper.getClientEmailAddress( 8 );
87:         clientName0 = clientTestHelper.getClientName( 0 );
88:         clientName8 = clientTestHelper.getClientName( 8 );
89: 
90:         itemId0 = itemTestHelper.getItemId( 0 );
91:         itemId1 = itemTestHelper.getItemId( 1 );
92:         itemId2 = itemTestHelper.getItemId( 2 );
93:         itemId3 = itemTestHelper.getItemId( 3 );
94:         itemId5 = itemTestHelper.getItemId( 5 );
95:         itemId7 = itemTestHelper.getItemId( 7 );
96:         itemId9 = itemTestHelper.getItemId( 9 );
97:         itemId11 = itemTestHelper.getItemId( 11 );
98:         nonExistentItemId = UUID.randomUUID();
99: 
100:         fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
101:         fulfillmentCenterId3 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 3 );
102:         fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );
103:         fulfillmentCenterId8 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 8 );
104: 
105:         map9_quantity_1 = new HashMap<>() {{
106:             put( itemId9, 1 );
107:         }};
108:         map5_quantity_2 = new HashMap<>() {{
109:             put( itemId5, 2 );
110:         }};
111:         map7_quantity_7 = new HashMap<>() {{
112:             put( itemId7, 7 );
113:         }};
114:         map9_11_quantity_2_2 = new HashMap<>() {{
115:             put( itemId9, 2 );
116:             put( itemId11, 2 );
117:         }};
118:     }
119: 
120: 
121:     @Test
122:     public void testInvalidShoppingBasketBaseUris() throws Exception {
123:         // given
124:         String allShoppingBasketsUri = "/shoppingBaskets";
125:         String randomIdUri = "/shoppingBaskets/" + UUID.randomUUID();
126:         String randomClientUUID = "/shoppingBaskets?clientId=" + UUID.randomUUID();
127:         String invalidClientUUID = "/shoppingBaskets?clientId=invalidUUID";
128:         String randomParamUri = "/shoppingBaskets?randomParam=randomValue";
129: 
130:         // when
131:         // then
132:         mockMvc.perform( get( allShoppingBasketsUri ) ).andExpect( status().isMethodNotAllowed() );
133:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
134:         mockMvc.perform( get( randomClientUUID ) ).andExpect( status().isNotFound() );
135:         mockMvc.perform( get( invalidClientUUID ) ).andExpect( status().isNotFound() );
136:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
137:     }
138: 
139: 
140:     @Test
141:     public void testInvalidPositionUris() throws Exception {
142:         // given
143:         UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress8, emptyMap );
144:         String randomPositionUri = "/shoppingBaskets/" + shoppingBasketId8.toString() + "/random";
145:         String randomItemUri = "/shoppingBaskets/" + shoppingBasketId8.toString()
146:                 + "/positions/" + UUID.randomUUID();
147: 
148:         // when
149:         // then
150:         mockMvc.perform( post( randomPositionUri ) ).andExpect( status().isNotFound() );
151:         mockMvc.perform( delete( randomItemUri ) ).andExpect( status().isNotFound() );
152:     }
153: 
154: 
155:     @Test
156:     public void testInvalidAddToShoppingBasket() throws Exception {
157:         // given
158:         Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
159:         expectedStartQuantityMap.put( itemId2, 19 );
160: 
161:         // when
162:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress0, emptyMap );
163:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId, itemId2, 6 );
164:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId, itemId2, 13 );
165: 
166:         // then
167:         shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress0, expectedStartQuantityMap );
168: 
169:         // ... and check a couple of invalid cases
170:         shoppingBasketRESTHelper.addItemToShoppingBasket(
171:                 shoppingBasketId, nonExistentItemId, 12, NOT_FOUND );
172:         shoppingBasketRESTHelper.addItemToShoppingBasket(
173:                 UUID.randomUUID(), itemId5, 12, NOT_FOUND );
174:         shoppingBasketRESTHelper.addItemToShoppingBasket(
175:                 shoppingBasketId, itemId5, -1, UNPROCESSABLE_ENTITY );
176: 
177:         // check if the shopping basket is still the same
178:         shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress0, expectedStartQuantityMap );
179:     }
180: 
181: 
182:     @Test
183:     public void testInvalidCheckout_unavailableItem() throws Exception {
184:         // given
185:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress0, emptyMap );
186: 
187:         // when
188:         // productId0 is not available in the requested quantity (or rather, not at all)
189:         shoppingBasketRESTHelper.addItemToShoppingBasket(
190:                 shoppingBasketId, itemId0, 1, CREATED );
191: 
192:         // check if the shopping basket is still the same
193:         shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
194:     }
195: 
196: 
197:     @Test
198:     public void testInvalidCheckout_tooLittleStock() throws Exception {
199:         // given
200:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress0, emptyMap );
201: 
202:         // when
203:         // There are only 10 pieces of productId1 available
204:         shoppingBasketRESTHelper.addItemToShoppingBasket(
205:                 shoppingBasketId, itemId1, 11, CREATED );
206: 
207:         // check if the shopping basket is still the same
208:         shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
209:     }
210: 
211: 
212: 
213:     @Test
214:     public void testDeleteItemFromShoppingBasket() throws Exception {
215:         // given
216:         UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress6, emptyMap );
217:         Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
218:         expectedQuantityMap1.put( itemId1, 1 );
219:         expectedQuantityMap1.put( itemId2, 2 );
220:         expectedQuantityMap1.put( itemId3, 3 );
221:         Map<UUID, Integer> quantityMap2 = new HashMap<>();
222:         quantityMap2.put( itemId1, 1 );
223:         quantityMap2.put( itemId3, 3 );
224: 
225:         // when
226:         // then
227:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId6, itemId1, 1 );
228:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId6, itemId2, 2 );
229:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId6, itemId3, 3 );
230:         shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress6, expectedQuantityMap1 );
231: 
232:         shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId6, itemId2 );
233:         shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress6, quantityMap2 );
234:     }
235: 
236: 
237:     @Test
238:     public void testNoDoubleDelete() throws Exception {
239:         // given
240:         UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress6, emptyMap );
241: 
242:         // when
243:         // then
244:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId6, itemId3, 3 );
245:         shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId6, itemId3 );
246:         shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress6, new HashMap<>() );
247:         shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId6, itemId3, NOT_FOUND );
248:     }
249: 
250: 
251:     @Test
252:     public void testAddRemoveItemsFromAndToShoppingBasket() throws Exception {
253:         // given
254:         UUID shoppingBasketId3 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress3, emptyMap );
255:         UUID shoppingBasketId5 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress6, emptyMap );
256: 
257:         // when
258:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId3, itemId1, 2 );
259:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId3, itemId2, 3 );
260:         shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId3, itemId1 );
261:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId3, itemId1, 1 );
262:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId3, itemId2, 6 );
263: 
264:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId5, itemId1, 2 );
265:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId5, itemId2, 8 );
266:         shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId5, itemId1 );
267:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId5, itemId1, 1 );
268:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId5, itemId2, 2 );
269: 
270:         // then
271:         // client3 has 1x itemId1 and 9x itemId2 expected in cart
272:         Map<UUID, Integer> expectedMap3 = new HashMap<>();
273:         expectedMap3.put( itemId1, 1 );
274:         expectedMap3.put( itemId2, 9 );
275:         shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress3, expectedMap3 );
276: 
277:         // client6 has 1x itemId1 and 10x itemId2 in cart
278:         Map<UUID, Integer> expectedMap5 = new HashMap<>();
279:         expectedMap5.put( itemId1, 1 );
280:         expectedMap5.put( itemId2, 10 );
281:         shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress6, expectedMap5 );
282:     }
283: 
284: 
285:     @Test
286:     public void testNoDoubleCheckout() throws Exception {
287:         // given
288:         UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmailAddress8, emptyMap );
289: 
290:         // when
291:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId2, 3 );
292: 
293:         // then
294:         shoppingBasketRESTHelper.checkout( shoppingBasketId8, clientName8, CREATED, null );
295:         shoppingBasketRESTHelper.checkout( shoppingBasketId8, null, CONFLICT, null );
296:     }
297: 
298: 
299:     @Test
300:     public void testCheckout_1_Order() throws Exception {
301:         // given:
302:         // Client 0 wants to buy 1x item 9. This is in fulfillment center 5, 7, and 8. Out of these,
303:         // fulfillment center 8 with zip code 89250 is closest to client 0 with zip code 02314.
304:         Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
305:             put( fulfillmentCenterId8, map9_quantity_1 );
306:         }};
307:         UUID shoppingBasketId0 = shoppingBasketRESTHelper.getQueryShoppingBasket(
308:                 clientEmailAddress0, null );
309:         int stock9before =
310:                 fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId8, itemId9 );
311: 
312:         // when
313:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId0, itemId9, 1 );
314:         shoppingBasketRESTHelper.checkout( shoppingBasketId0, clientName0, CREATED, expectedOrders );
315:         int stock9after =
316:                 fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId8, itemId9 );
317: 
318:         // then
319:         assertEquals( 1, stock9before - stock9after );
320:     }
321: 
322: 
323:     @Test
324:     public void testCheckout_3_Order() throws Exception {
325:         // given:
326:         // Client 8 (Felix Bauer) wants to buy 2x each of items 5, 9, 11; and 7x item 7.
327:         //       - items 9 and 11 can both be found in fulfillment centers 7 and 8. Fulfillment centers 7 (76532) is closer to
328:         //         the client (70173)
329:         //       - item 7 is available in fulfillment centers 1, 2, and 3, but only fulfillment center 3 has enough stock.
330:         //       - item 5 is only available in fulfillment center 0.
331:         Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
332:             put( fulfillmentCenterId0, map5_quantity_2 );
333:             put( fulfillmentCenterId3, map7_quantity_7 );
334:             put( fulfillmentCenterId7, map9_11_quantity_2_2 );
335:         }};
336:         UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket(
337:                 clientEmailAddress8, null );
338:         int stock5before =
339:                 fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId5 );
340:         int stock7before =
341:                 fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId3, itemId7 );
342:         int stock9before =
343:                 fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId7, itemId9 );
344:         int stock11before =
345:                 fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId7, itemId11 );
346: 
347:         // when
348:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId5, 2 );
349:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId7, 7 );
350:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId9, 2 );
351:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId11, 2 );
352:         shoppingBasketRESTHelper.checkout( shoppingBasketId8, clientName8, CREATED, expectedOrders );
353:         int stock5after =
354:                 fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId0, itemId5 );
355:         int stock7after =
356:                 fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId3, itemId7 );
357:         int stock9after =
358:                 fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId7, itemId9 );
359:         int stock11after =
360:                 fulfillmentCenterUseCases.getAvailableStock( fulfillmentCenterId7, itemId11 );
361: 
362:         // then
363:         assertEquals( 2, stock5before - stock5after );
364:         assertEquals( 7, stock7before - stock7after );
365:         assertEquals( 2, stock9before - stock9after );
366:         assertEquals( 2, stock11before - stock11after );
367:     }
368: 
369: 
370: }
371: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingbasket;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.InsufficientStockException;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
12: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
13: import thkoeln.archilab.ecommerce.usecases.*;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
16: 
17: 
18: import java.util.Map;
19: import java.util.UUID;
20: 
21: import static org.junit.jupiter.api.Assertions.*;
22: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
23: 
24: @SpringBootTest
25: public class ShoppingBasketTest {
26:     @Autowired
27:     private ClientRegistrationUseCases clientRegistrationUseCases;
28:     @Autowired
29:     private ShoppingBasketUseCases shoppingBasketUseCases;
30:     @Autowired
31:     private ItemCatalogUseCases itemCatalogUseCases;
32:     @Autowired
33:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
34:     @Autowired
35:     private OrderUseCases orderUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private ClientTestHelper clientTestHelper;
40:     @Autowired
41:     private ItemTestHelper itemTestHelper;
42:     @Autowired
43:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
44: 
45:     private EmailAddressType nonExistingEmailAddress;
46: 
47:     @BeforeEach
48:     public void setUp() {
49:         purgatory.deleteEverything();
50:         clientTestHelper.registerAllClients();
51:         itemTestHelper.addAllItems();
52: 
53:         nonExistingEmailAddress = instantiateEmailAddress( "this@nononono.de" );
54:     }
55: 
56: 
57:     @Test
58:     public void testInvalidAddToShoppingBasket() {
59:         // given
60:         UUID nonExistentItemId = UUID.randomUUID();
61:         UUID itemId5 = itemTestHelper.getItemId( 5 );
62:         UUID itemId0 = itemTestHelper.getItemId( 0 );
63:         EmailAddressType clientEmailAddress0 =
64:                 clientTestHelper.getClientEmailAddress( 0 );
65:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
66: 
67:         // then
68:         assertThrows( ShopException.class,
69:                 () -> shoppingBasketUseCases.addItemToShoppingBasket(
70:                         nonExistingEmailAddress, itemId0, 1 ) );
71:         assertThrows( ShopException.class,
72:                 () -> shoppingBasketUseCases.addItemToShoppingBasket(
73:                         null, itemId0, 1 ) );
74:         assertThrows( ShopException.class,
75:                 () -> shoppingBasketUseCases.addItemToShoppingBasket(
76:                         clientEmailAddress0, nonExistentItemId, 1 ) );
77:         assertThrows( ShopException.class,
78:                 () -> shoppingBasketUseCases.addItemToShoppingBasket(
79:                         clientEmailAddress0, null, 1 ) );
80:         assertThrows( ShopException.class,
81:                 () -> shoppingBasketUseCases.addItemToShoppingBasket(
82:                         clientEmailAddress0, itemId5, -1 ) );
83:     }
84: 
85: 
86:     @Test
87:     public void testInvalidRemoveFromShoppingBasket() {
88:         // given
89:         UUID nonExistentItemId = UUID.randomUUID();
90:         UUID itemId5 = itemTestHelper.getItemId( 5 );
91:         UUID itemId1 = itemTestHelper.getItemId( 1 );
92:         UUID itemId2 = itemTestHelper.getItemId( 2 );
93:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
94:         EmailAddressType clientEmailAddress0 =
95:                 clientTestHelper.getClientEmailAddress( 0 );
96:         shoppingBasketUseCases.addItemToShoppingBasket(
97:                 clientEmailAddress0, itemId1, 5 );
98:         shoppingBasketUseCases.addItemToShoppingBasket(
99:                 clientEmailAddress0, itemId2, 15 );
100: 
101:         // when
102:         shoppingBasketUseCases.removeItemFromShoppingBasket(
103:                 clientEmailAddress0, itemId1, 2 );
104:         shoppingBasketUseCases.removeItemFromShoppingBasket(
105:                 clientEmailAddress0, itemId2, 4 );
106:         shoppingBasketUseCases.removeItemFromShoppingBasket(
107:                 clientEmailAddress0, itemId2, 7 );
108:         // now we should have 3x itemId1 and 4x itemId2 in the shopping basket
109: 
110:         // then
111:         assertThrows( ShopException.class,
112:                 () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
113:                         clientEmailAddress0, nonExistentItemId, 12 ) );
114:         assertThrows( ShopException.class,
115:                 () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
116:                         nonExistingEmailAddress, itemId5, 12 ) );
117:         assertThrows( ShopException.class,
118:                 () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
119:                         clientEmailAddress0, itemId5, -1 ) );
120:         assertThrows( ShopException.class,
121:                 () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
122:                         clientEmailAddress0, itemId1, 4 ) );
123:         assertThrows( ShopException.class,
124:                 () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
125:                         clientEmailAddress0, itemId2, 5 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testAddRemoveItemsFromAndToShoppingBasket() {
131:         // given
132:         UUID itemId1 = itemTestHelper.getItemId( 1 );
133:         UUID itemId2 = itemTestHelper.getItemId( 2 );
134:         EmailAddressType clientEmailAddress3 =
135:                 clientTestHelper.getClientEmailAddress( 3 );
136:         EmailAddressType clientEmailAddress5 =
137:                 clientTestHelper.getClientEmailAddress( 5 );
138: 
139:         // when client 3 ...
140:         shoppingBasketUseCases.addItemToShoppingBasket(
141:                 clientEmailAddress3, itemId1, 2 );
142:         shoppingBasketUseCases.addItemToShoppingBasket(
143:                 clientEmailAddress3, itemId2, 3 );
144:         shoppingBasketUseCases.removeItemFromShoppingBasket(
145:                 clientEmailAddress3, itemId1, 2 );
146:         shoppingBasketUseCases.addItemToShoppingBasket(
147:                 clientEmailAddress3, itemId1, 1 );
148:         shoppingBasketUseCases.addItemToShoppingBasket(
149:                 clientEmailAddress3, itemId2, 6 );
150:         Map<UUID, Integer> cart3 = shoppingBasketUseCases.getShoppingBasketAsMap( clientEmailAddress3 );
151:         // client3 has 1x itemId1 and 9x itemId2 in cart
152: 
153:         // ... and when client 5 ...
154:         shoppingBasketUseCases.addItemToShoppingBasket(
155:                 clientEmailAddress5, itemId1, 2 );
156:         shoppingBasketUseCases.addItemToShoppingBasket(
157:                 clientEmailAddress5, itemId2, 8 );
158:         shoppingBasketUseCases.removeItemFromShoppingBasket(
159:                 clientEmailAddress5, itemId1, 1 );
160:         shoppingBasketUseCases.addItemToShoppingBasket(
161:                 clientEmailAddress5, itemId2, 2 );
162:         Map<UUID, Integer> cart5 = shoppingBasketUseCases.getShoppingBasketAsMap( clientEmailAddress5 );
163:         // client5 has 1x itemId1 and 10x itemId2 in cart
164: 
165:         // then
166:         assertEquals( 2, cart3.size() );
167:         assertEquals( 1, cart3.get( itemId1 ) );
168:         assertEquals( 9, cart3.get( itemId2 ) );
169: 
170:         assertEquals( 2, cart5.size() );
171:         assertEquals( 1, cart5.get( itemId1 ) );
172:         assertEquals( 10, cart5.get( itemId2 ) );
173:     }
174: 
175: 
176:     @Test
177:     public void testShoppingBasketValue() {
178:         // given
179:         UUID itemId3 = itemTestHelper.getItemId( 3 );
180:         UUID itemId6 = itemTestHelper.getItemId( 6 );
181:         UUID itemId8 = itemTestHelper.getItemId( 8 );
182:         MoneyType price3 = itemTestHelper.getSellingPrice( 3 );
183:         MoneyType price6 = itemTestHelper.getSellingPrice( 6 );
184:         MoneyType price8 = itemTestHelper.getSellingPrice( 8 );
185:         EmailAddressType clientEmailAddress3 =
186:                 clientTestHelper.getClientEmailAddress( 3 );
187: 
188:         // when
189:         shoppingBasketUseCases.addItemToShoppingBasket( clientEmailAddress3, itemId3, 3 );
190:         shoppingBasketUseCases.addItemToShoppingBasket( clientEmailAddress3, itemId6, 2 );
191:         shoppingBasketUseCases.addItemToShoppingBasket( clientEmailAddress3, itemId8, 5 );
192:         // client3 has 3x itemId3, 2x itemId6 and 5x itemId8 in cart
193:         MoneyType cartValue = shoppingBasketUseCases.getShoppingBasketAsMoneyValue( clientEmailAddress3 );
194: 
195:         // then
196:         assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
197:                 cartValue );
198:     }
199: 
200: 
201:     @Test
202:     public void testShoppingBasketValueInvalid() {
203:         // given
204:         // when
205:         // then
206:         assertThrows( ShopException.class,
207:                 () -> shoppingBasketUseCases.getShoppingBasketAsMoneyValue( nonExistingEmailAddress ) );
208:     }
209: 
210: 
211:     @Test
212:     public void testUnsuccessfulCheckout() {
213:         // given client buying item 0 (which is not in stock), and client 1 buying item 1
214:         // in a bigger quantity (11) than available (10)
215:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
216:         EmailAddressType clientEmailAddress0 =
217:                 clientTestHelper.getClientEmailAddress( 0 );
218:         EmailAddressType clientEmailAddress1 =
219:                 clientTestHelper.getClientEmailAddress( 1 );
220:         UUID itemId0 = itemTestHelper.getItemId( 0 );
221:         UUID itemId1 = itemTestHelper.getItemId( 1 );
222: 
223:         // when
224:         shoppingBasketUseCases.addItemToShoppingBasket(
225:                 clientEmailAddress0, itemId0, 1 );
226:         shoppingBasketUseCases.addItemToShoppingBasket(
227:                 clientEmailAddress1, itemId1, 11 );
228: 
229:         // then
230:         assertThrows( InsufficientStockException.class,
231:                 () -> shoppingBasketUseCases.checkout( clientEmailAddress0 ) );
232:         assertThrows( InsufficientStockException.class,
233:                 () -> shoppingBasketUseCases.checkout( clientEmailAddress1 ) );
234:     }
235: 
236: }
237: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
1: package thkoeln.archilab.ecommerce.tests.testtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.domain.JavaMethod;
6: import com.tngtech.archunit.core.importer.ClassFileImporter;
7: import com.tngtech.archunit.lang.ArchRule;
8: import org.junit.jupiter.api.BeforeEach;
9: import org.junit.jupiter.api.Test;
10: import org.springframework.web.bind.annotation.RestController;
11: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
12: import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
13: import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingBasketRESTTest;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
18: 
19: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
20: import static org.springframework.test.util.AssertionErrors.assertTrue;
21: 
22: /**
23:  * This test checks if there are the appropriate tests in the test class(es) for domain
24:  * primitives.
25:  */
26: 
27: public class RulesForOwnTests {
28:     private JavaClass dpTestClass, restTestClass;
29:     private JavaClasses dpTestClasses, restTestClasses;
30:     private static final String FULFILLMENT_CENTER_DOMAIN_PACKAGE =
31:             "thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain";
32:     private static final String FULFILLMENT_CENTER_CLASS_NAME =
33:             FULFILLMENT_CENTER_DOMAIN_PACKAGE + ".FulfillmentCenter";
34: 
35: 
36:     @BeforeEach
37:     public void setUp() throws Exception {
38:         dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
39:         restTestClass = new ClassFileImporter().importClass( OwnShoppingBasketRESTTest.class );
40: 
41:         dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
42:         restTestClasses = new ClassFileImporter().importClasses( OwnShoppingBasketRESTTest.class );
43:     }
44: 
45: 
46:     @Test
47:     public void ensureMinimumNumberOfTestMethods() {
48:         // given
49:         // when
50:         int dpTestMethodCount = getTestMethodCount( dpTestClass );
51:         int restTestMethodCount = getTestMethodCount( restTestClass );
52: 
53:         // then
54:         assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
55:                         + dpTestMethodCount,dpTestMethodCount >= 2 );
56:         assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
57:                         + restTestMethodCount, restTestMethodCount >= 5 );
58:     }
59: 
60:     private int getTestMethodCount( JavaClass testClass ) {
61:         int testMethodCount = 0;
62:         for ( JavaMethod method : testClass.getMethods() ) {
63:             if ( isTestMethod( method ) ) {
64:                 testMethodCount++;
65:             }
66:         }
67:         return testMethodCount;
68:     }
69: 
70:     private boolean isTestMethod( JavaMethod method ) {
71:         return method.isAnnotatedWith( Test.class );
72:     }
73: 
74: 
75:     @Test
76:     public void dpTestsShouldReferenceTheRightClasses() {
77:         ArchRule rule = classes()
78:                 .should().dependOnClassesThat()
79:                 .areAssignableTo( ZipCodeType.class )
80:                 .andShould().dependOnClassesThat()
81:                 .areAssignableTo( MoneyType.class )
82:                 .andShould().dependOnClassesThat()
83:                 .areAssignableTo( PhysicalAddressType.class )
84:                 .andShould().dependOnClassesThat()
85:                 .areAssignableTo( EmailAddressType.class )
86:                 .because( "DomainPrimitiveJSONSerializationTest should reference ZipCode, " +
87:                         "Money, EmailAddress, and PhysicalAddress!" );
88:         rule.check( dpTestClasses );
89:     }
90: 
91: 
92:     @Test
93:     public void restTestsShouldReferenceEmailAddress() {
94:         ArchRule rule = classes()
95:                 .should().dependOnClassesThat()
96:                 .areAssignableTo( EmailAddressType.class )
97:                 .because( "FulfillmentCenterComparatorUnitTest should reference EmailAddressType!" );
98:         rule.check( restTestClasses );
99:     }
100: 
101: 
102:     @Test
103:     public void restTestsShouldReferenceRESTControllers() {
104:         ArchRule rule = classes()
105:                 .should().dependOnClassesThat()
106:                 .areAnnotatedWith( RestController.class )
107:                 .orShould().dependOnClassesThat()
108:                 .areAssignableTo( ShoppingBasketRESTHelper.class )
109:                 .because( "FulfillmentCenterComparatorUnitTest should call REST controllers! " +
110:                         "(either directly or via the ShoppingBasketRESTHelper REST helper)" );
111:         rule.check( restTestClasses );
112:     }
113: 
114: }
115: 

[RESPONSE]:
## Code-Review: Smells in der gegebenen Codebase

### **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\EmailAddress.java**
- **EmailAddress.java Zeile 36–38**: **Duplication** (Original: Zeile 33–34) : Die Prüfung auf genau ein '@' wird doppelt durchgeführt (einmal via `count()` und einmal via `split()`), was redundante Validierung darstellt.

### **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientRegistrationService.java**
- **ClientRegistrationService.java Zeile 59**: **Duplication** (Original: Zeile 35) : Konvertierung von `EmailAddressType` zu `EmailAddress` wiederholt sich in mehreren Methoden.
- **ClientRegistrationService.java Zeile 78**: **Duplication** (Original: Zeile 35) : Weitere Wiederholung derselben Konvertierung.
- **ClientRegistrationService.java Zeile 63–67**: **Duplication** (Original: Zeile 40–44) : Erstellung einer `PhysicalAddress` aus den Interface-Typen ist in `changeAddress()` und `register()` nahezu identisch.

### **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\Client.java**
- **Client.java Zeile 66–80**: **Dead code** : Auskommentierter Code (ein REST-Endpoint-Entwurf), der nicht verwendet wird und entfernt werden sollte.

### **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterAdapterService.java**
- **FulfillmentCenterAdapterService.java Zeile 62–68**: **Duplication** (Original: Zeile 52–58) : Validierung von `fulfillmentCenterId`, `itemId` und `quantity` in `removeFromStock()` gleicht der in `addToStock()`.
- **FulfillmentCenterAdapterService.java Zeile 72–80**: **Duplication** (Original: Zeile 52–58) : Dieselbe Validierung wiederholt sich in `changeStockTo()`.

### **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterService.java**
- **FulfillmentCenterService.java Zeile 54**: **Duplication** (Original: Zeile 47) : Prüfung `itemQueryPort.itemExists(itemId)` in `remove()` ist identisch zu der in `add()`.
- **FulfillmentCenterService.java Zeile 61**: **Duplication** (Original: Zeile 47) : Dieselbe Prüfung in `setStock()`.
- **FulfillmentCenterService.java Zeile 68**: **Duplication** (Original: Zeile 47) : Dieselbe Prüfung in `getStock()`.
- **FulfillmentCenterService.java Zeile 33–43**: **Duplication** (Original: FulfillmentCenterQueryImplService.java Zeile 33–45) : Die Logik zum Finden eines Fulfillment-Centers anhand der PLZ (Validierung und Suche) dupliziert sich in `findByZip()`.

### **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\Item.java**
- **Item.java**: **Anemic Entity** : Die Klasse enthält ausschließlich Getter und einen einfachen Konstruktor, jedoch keine Domänenlogik (keine Verhaltensmethoden). Sie dient lediglich als Datencontainer.

### **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketAdapterService.java**
- **ShoppingBasketAdapterService.java Zeile 48–57**: **Duplication** (Original: Zeile 33–42) : Validierung von `clientEmailAddress`, `itemId` und `quantity` in `removeItemFromShoppingBasket()` entspricht der in `addItemToShoppingBasket()`.

### **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_df8e7cda-fb2b-4d96-9740-6dd403d22563\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java**
- **ShoppingBasketService.java Zeile 221–262**: **Duplication** (Original: Zeile 133–184) : Die Methode `checkoutMultipleDeliveriesWithOrders()` dupliziert fast vollständig die Logik von `checkoutMultipleDeliveries()`, lediglich mit dem Unterschied, dass sie `Order`-Objekte zurückgibt und den `clientName` setzt.

---
**ENDE**
Generated by deepseek-reasoner
-----------------------------------