--- DATE: 13.1.2026, 16:03:20 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
        Architektur: 4-Layer (Eric Evans).
        Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
        Regeln:
        1. Begründe kurz jeden Fund.
        4. Gruppiere nach Datei (mit Pfad). 
        2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
        3. Keine Code-Wiederholung, nur Referenzen.
        5. Wenn fertig, schreibe "ENDE". 
        6. Nutze die Zeilenangaben die mitgeschickt worden sind.



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\AddressLocation.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonCreator;
4: import com.fasterxml.jackson.annotation.JsonProperty;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
8: 
9: import java.util.Objects;
10: 
11: public class AddressLocation implements AddressLocationType {
12:     @JsonProperty("street")
13:     private final String street;
14:     @JsonProperty("city")
15:     private final String city;
16:     @JsonProperty("postalCode")
17:     private final PostalCodeType postalCode;
18: 
19:     @JsonCreator
20:     private AddressLocation(@JsonProperty("street") String street, @JsonProperty("city") String city, @JsonProperty("postalCode") PostalCode postalCode) {
21:         if (street == null || street.trim().isEmpty()) {
22:             throw new ShopException("Street cannot be null or empty");
23:         }
24:         if (city == null || city.trim().isEmpty()) {
25:             throw new ShopException("City cannot be null or empty");
26:         }
27:         if (postalCode == null) {
28:             throw new ShopException("Postal code cannot be null");
29:         }
30:         this.street = street.trim();
31:         this.city = city.trim();
32:         this.postalCode = postalCode;
33:     }
34: 
35:     public static AddressLocation of(String street, String city, PostalCodeType postalCode) {
36:         return new AddressLocation(street, city, (PostalCode) postalCode);
37:     }
38: 
39:     public static AddressLocation of(String street, String city, String postalCodeString) {
40:         return new AddressLocation(street, city, PostalCode.of(postalCodeString));
41:     }
42: 
43:     public String getStreet() {
44:         return street;
45:     }
46: 
47:     public String getCity() {
48:         return city;
49:     }
50: 
51:     public PostalCodeType getPostalCode() {
52:         return postalCode;
53:     }
54: 
55:     @Override
56:     public boolean equals(Object o) {
57:         if (this == o) return true;
58:         if (o == null || getClass() != o.getClass()) return false;
59:         AddressLocation that = (AddressLocation) o;
60:         return Objects.equals(street, that.street) &&
61:                Objects.equals(city, that.city) &&
62:                Objects.equals(postalCode, that.postalCode);
63:     }
64: 
65:     @Override
66:     public int hashCode() {
67:         return Objects.hash(street, city, postalCode);
68:     }
69: 
70:     @Override
71:     public String toString() {
72:         return street + ", " + city + " " + postalCode;
73:     }
74: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Currency.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonCreator;
4: import com.fasterxml.jackson.annotation.JsonProperty;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
7: 
8: import java.math.BigDecimal;
9: import java.math.RoundingMode;
10: import java.util.Objects;
11: import java.util.Set;
12: 
13: public class Currency implements CurrencyType {
14:     private final BigDecimal amount;
15:     @JsonProperty("currencyUnit")
16:     private final String currencyCode;
17:     private static final Set<String> ALLOWED_CURRENCIES = Set.of("EUR", "CHF");
18: 
19:     @JsonCreator
20:     private Currency(@JsonProperty("quantity") Float quantity, @JsonProperty("currencyUnit") String currencyCode) {
21:         this(quantity != null ? BigDecimal.valueOf(quantity) : null, currencyCode);
22:     }
23:     
24:     private Currency(BigDecimal amount, String currencyCode) {
25:         if (amount == null) {
26:             throw new ShopException("Amount cannot be null");
27:         }
28:         if (amount.compareTo(BigDecimal.ZERO) < 0) {
29:             throw new ShopException("Amount cannot be negative");
30:         }
31:         if (currencyCode == null || currencyCode.trim().isEmpty()) {
32:             throw new ShopException("Currency code cannot be null or empty");
33:         }
34:         String upperCode = currencyCode.toUpperCase();
35:         if (!ALLOWED_CURRENCIES.contains(upperCode)) {
36:             throw new ShopException("Currency code must be EUR or CHF");
37:         }
38:         this.amount = amount.setScale(2, RoundingMode.HALF_UP);
39:         this.currencyCode = upperCode;
40:     }
41: 
42:     public static Currency of(Float quantity, String currencyUnit) {
43:         if (quantity == null) {
44:             throw new ShopException("Quantity cannot be null");
45:         }
46:         return new Currency(BigDecimal.valueOf(quantity), currencyUnit);
47:     }
48: 
49:     public static Currency of(double amount, String currencyCode) {
50:         return new Currency(BigDecimal.valueOf(amount), currencyCode);
51:     }
52: 
53:     public static Currency of(BigDecimal amount, String currencyCode) {
54:         return new Currency(amount, currencyCode);
55:     }
56: 
57:     @Override
58:     @JsonProperty("quantity")
59:     public Float getQuantity() {
60:         return amount.floatValue();
61:     }
62: 
63:     @Override
64:     public String getCurrencyUnit() {
65:         return currencyCode;
66:     }
67: 
68:     @Override
69:     public CurrencyType add(CurrencyType otherCurrency) {
70:         if (otherCurrency == null) {
71:             throw new ShopException("Other currency cannot be null");
72:         }
73:         if (!this.currencyCode.equals(otherCurrency.getCurrencyUnit())) {
74:             throw new ShopException("Cannot add different currencies");
75:         }
76:         BigDecimal newAmount = this.amount.add(BigDecimal.valueOf(otherCurrency.getQuantity()));
77:         return new Currency(newAmount, this.currencyCode);
78:     }
79: 
80:     @Override
81:     public CurrencyType subtract(CurrencyType otherCurrency) {
82:         if (otherCurrency == null) {
83:             throw new ShopException("Other currency cannot be null");
84:         }
85:         if (!this.currencyCode.equals(otherCurrency.getCurrencyUnit())) {
86:             throw new ShopException("Cannot subtract different currencies");
87:         }
88:         BigDecimal otherAmount = BigDecimal.valueOf(otherCurrency.getQuantity());
89:         if (otherAmount.compareTo(this.amount) > 0) {
90:             throw new ShopException("Cannot subtract larger amount");
91:         }
92:         BigDecimal newAmount = this.amount.subtract(otherAmount);
93:         return new Currency(newAmount, this.currencyCode);
94:     }
95: 
96:     @Override
97:     public CurrencyType multiplyBy(int factor) {
98:         if (factor < 0) {
99:             throw new ShopException("Factor cannot be negative");
100:         }
101:         BigDecimal newAmount = this.amount.multiply(BigDecimal.valueOf(factor));
102:         return new Currency(newAmount, this.currencyCode);
103:     }
104: 
105:     @Override
106:     public boolean largerThan(CurrencyType otherCurrency) {
107:         if (otherCurrency == null) {
108:             throw new ShopException("Other currency cannot be null");
109:         }
110:         if (!this.currencyCode.equals(otherCurrency.getCurrencyUnit())) {
111:             throw new ShopException("Cannot compare different currencies");
112:         }
113:         return this.amount.compareTo(BigDecimal.valueOf(otherCurrency.getQuantity())) > 0;
114:     }
115: 
116:     @Override
117:     public boolean equals(Object o) {
118:         if (this == o) return true;
119:         if (o == null || getClass() != o.getClass()) return false;
120:         Currency currency = (Currency) o;
121:         return amount.compareTo(currency.amount) == 0 && 
122:                Objects.equals(currencyCode, currency.currencyCode);
123:     }
124: 
125:     @Override
126:     public int hashCode() {
127:         return Objects.hash(amount, currencyCode);
128:     }
129: 
130:     @Override
131:     public String toString() {
132:         return amount.toPlainString() + " " + currencyCode;
133:     }
134: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\EmailAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonCreator;
4: import com.fasterxml.jackson.annotation.JsonProperty;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
7: 
8: import java.util.Objects;
9: import java.util.Set;
10: import java.util.regex.Pattern;
11: 
12: public class EmailAddress implements EmailAddressType {
13:     @JsonProperty("emailAddressString")
14:     private final String emailAddressString;
15:     private static final Set<String> ALLOWED_DOMAINS = Set.of(".de", ".at", ".ch", ".com", ".org");
16: 
17:     @JsonCreator
18:     private EmailAddress(@JsonProperty("emailAddressString") String emailAddressString) {
19:         if (emailAddressString == null) {
20:             throw new ShopException("Email address cannot be null");
21:         }
22:         
23:         validateEmailFormat(emailAddressString);
24:         this.emailAddressString = emailAddressString;
25:     }
26: 
27:     private static void validateEmailFormat(String email) {
28:         // Check for exactly one @ character
29:         int atCount = 0;
30:         int atIndex = -1;
31:         for (int i = 0; i < email.length(); i++) {
32:             if (email.charAt(i) == '@') {
33:                 atCount++;
34:                 atIndex = i;
35:             }
36:         }
37:         if (atCount != 1) {
38:             throw new ShopException("Email must contain exactly one @ character");
39:         }
40: 
41:         String identifier = email.substring(0, atIndex);
42:         String domain = email.substring(atIndex + 1);
43: 
44:         // Validate identifier
45:         validateEmailPart(identifier, "Identifier");
46:         
47:         // Validate domain
48:         validateEmailPart(domain, "Domain");
49:         
50:         // Check domain ending
51:         boolean hasValidEnding = false;
52:         for (String ending : ALLOWED_DOMAINS) {
53:             if (domain.endsWith(ending)) {
54:                 hasValidEnding = true;
55:                 break;
56:             }
57:         }
58:         if (!hasValidEnding) {
59:             throw new ShopException("Domain must end with .de, .at, .ch, .com, or .org");
60:         }
61:     }
62: 
63:     private static void validateEmailPart(String part, String partName) {
64:         if (part.isEmpty()) {
65:             throw new ShopException(partName + " cannot be empty");
66:         }
67:         
68:         // Check for whitespace
69:         if (part.contains(" ") || part.contains("\t") || part.contains("\n")) {
70:             throw new ShopException(partName + " cannot contain whitespace");
71:         }
72:         
73:         // Check for invalid characters (only allow letters, digits, dots, hyphens, underscores)
74:         for (char c : part.toCharArray()) {
75:             if (!Character.isLetterOrDigit(c) && c != '.' && c != '-' && c != '_') {
76:                 throw new ShopException(partName + " contains invalid character: " + c);
77:             }
78:         }
79:         
80:         // Check for at least one alphanumeric character
81:         boolean hasAlphanumeric = false;
82:         for (char c : part.toCharArray()) {
83:             if (Character.isLetterOrDigit(c)) {
84:                 hasAlphanumeric = true;
85:                 break;
86:             }
87:         }
88:         if (!hasAlphanumeric) {
89:             throw new ShopException(partName + " must contain at least one alphanumeric character");
90:         }
91:         
92:         // Check for consecutive dots
93:         if (part.contains("..")) {
94:             throw new ShopException(partName + " cannot contain consecutive dots");
95:         }
96:     }
97: 
98:     public static EmailAddress of(String emailAddressString) {
99:         return new EmailAddress(emailAddressString);
100:     }
101: 
102:     public String getEmailAddressString() {
103:         return emailAddressString;
104:     }
105: 
106:     @Override
107:     public EmailAddressType sameIdentifyerDifferentDomain(String domainString) {
108:         if (domainString == null) {
109:             throw new ShopException("Domain string cannot be null");
110:         }
111:         int atIndex = emailAddressString.indexOf('@');
112:         String identifier = emailAddressString.substring(0, atIndex);
113:         return EmailAddress.of(identifier + "@" + domainString);
114:     }
115: 
116:     @Override
117:     public EmailAddressType sameDomainDifferentIdentifyer(String identifyerString) {
118:         if (identifyerString == null) {
119:             throw new ShopException("Identifier string cannot be null");
120:         }
121:         int atIndex = emailAddressString.indexOf('@');
122:         String domain = emailAddressString.substring(atIndex + 1);
123:         return EmailAddress.of(identifyerString + "@" + domain);
124:     }
125: 
126:     @Override
127:     public boolean equals(Object o) {
128:         if (this == o) return true;
129:         if (o == null || getClass() != o.getClass()) return false;
130:         EmailAddress that = (EmailAddress) o;
131:         return Objects.equals(emailAddressString, that.emailAddressString);
132:     }
133: 
134:     @Override
135:     public int hashCode() {
136:         return Objects.hash(emailAddressString);
137:     }
138: 
139:     @Override
140:     public String toString() {
141:         return emailAddressString;
142:     }
143: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PostalCode.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonCreator;
4: import com.fasterxml.jackson.annotation.JsonProperty;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
7: 
8: import java.util.Objects;
9: 
10: public class PostalCode implements PostalCodeType {
11:     @JsonProperty("postalCodeString")
12:     private final String postalCodeString;
13: 
14:     @JsonCreator
15:     private PostalCode(@JsonProperty("postalCodeString") String postalCodeString) {
16:         if (postalCodeString == null) {
17:             throw new ShopException("Postal code cannot be null");
18:         }
19:         
20:         // Must contain exactly 5 digits
21:         if (!postalCodeString.matches("^[0-9]{5}$")) {
22:             throw new ShopException("Postal code must contain exactly 5 digits");
23:         }
24:         
25:         // Last 4 digits must not be 0000
26:         if (postalCodeString.endsWith("0000")) {
27:             throw new ShopException("Last 4 digits of postal code cannot be 0000");
28:         }
29:         
30:         this.postalCodeString = postalCodeString;
31:     }
32: 
33:     public static PostalCode of(String postalCodeString) {
34:         return new PostalCode(postalCodeString);
35:     }
36: 
37:     public String getPostalCodeString() {
38:         return postalCodeString;
39:     }
40: 
41:     @Override
42:     public int distance(PostalCodeType otherPostalCode) {
43:         if (otherPostalCode == null) {
44:             throw new ShopException("Other postal code cannot be null");
45:         }
46:         
47:         String other = otherPostalCode.toString();
48:         if (this.postalCodeString.equals(other)) {
49:             return 0;
50:         }
51:         
52:         // Find the leftmost position where digits differ
53:         int leftmostDiffPos = -1;
54:         for (int i = 0; i <= 4; i++) {
55:             if (this.postalCodeString.charAt(i) != other.charAt(i)) {
56:                 leftmostDiffPos = i;
57:                 break;
58:             }
59:         }
60:         
61:         if (leftmostDiffPos == -1) {
62:             return 0; // Should not happen as we already checked equality
63:         }
64:         
65:         // Base distance: 100 * (position from right + 1)
66:         // Position 0 (leftmost) = 500, position 1 = 400, ..., position 4 (rightmost) = 100
67:         int baseDistance = 100 * (5 - leftmostDiffPos);
68:         
69:         // If the first digit differs (position 0), add additional distance based on digit difference
70:         if (leftmostDiffPos == 0) {
71:             int digit1 = Character.getNumericValue(this.postalCodeString.charAt(0));
72:             int digit2 = Character.getNumericValue(other.charAt(0));
73:             int diff = Math.abs(digit1 - digit2);
74:             
75:             // Handle wrap-around: 0 and 9 are closer than 0 and 5
76:             if (diff > 5) {
77:                 diff = 10 - diff;
78:             }
79:             
80:             baseDistance += diff * 10;
81:         }
82:         
83:         return baseDistance;
84:     }
85: 
86:     @Override
87:     public Integer getFirstDigitPostalCode() {
88:         return Character.getNumericValue(postalCodeString.charAt(0));
89:     }
90: 
91:     @Override
92:     public boolean equals(Object o) {
93:         if (this == o) return true;
94:         if (o == null || getClass() != o.getClass()) return false;
95:         PostalCode that = (PostalCode) o;
96:         return Objects.equals(postalCodeString, that.postalCodeString);
97:     }
98: 
99:     @Override
100:     public int hashCode() {
101:         return Objects.hash(postalCodeString);
102:     }
103: 
104:     @Override
105:     public String toString() {
106:         return postalCodeString;
107:     }
108: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.Column;
7: import jakarta.persistence.MappedSuperclass;
8: import lombok.EqualsAndHashCode;
9: import lombok.Getter;
10: import lombok.ToString;
11: 
12: import java.io.Serializable;
13: import java.util.UUID;
14: 
15: @MappedSuperclass
16: @Getter
17: @EqualsAndHashCode(of = "id")
18: @ToString(of = "id")
19: public abstract class GenericId implements Serializable {
20:     @Column(nullable = false, updatable = false)
21:     private final UUID id;
22: 
23:     protected GenericId() {
24:         this( UUID.randomUUID() );
25:     }
26: 
27:     protected GenericId( UUID id ) {
28:         this.id = id;
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.AttributeConverter;
7: 
8: import java.util.UUID;
9: import java.util.function.Function;
10: 
11: 
12: public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
13:     private final Function<UUID, T> factory;
14: 
15:     protected GenericIdConverter( Function<UUID, T> factory ) {
16:         this.factory = factory;
17:     }
18: 
19:     @Override
20:     public UUID convertToDatabaseColumn( T attribute ) {
21:         return attribute == null ? null : attribute.getId();
22:     }
23: 
24:     @Override
25:     public T convertToEntityAttribute( UUID dbData ) {
26:         return dbData == null ? null : factory.apply( dbData );
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\InsufficientInventoryException.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: /**
7:  * Exception is thrown if the product's inventory level is not sufficient to serve the order.
8:  */
9: public class InsufficientInventoryException extends ShopException {
10:     public InsufficientInventoryException( String message ) {
11:         super( message );
12:     }
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import org.springframework.boot.SpringApplication;
7: import org.springframework.boot.autoconfigure.SpringBootApplication;
8: 
9: 
10: @SpringBootApplication
11: public class ProjectApplication {
12: 
13: 	/**
14: 	 * Entry method
15: 	 * @param args
16: 	 */
17: 	public static void main(String[] args) {
18: 		SpringApplication.run(ProjectApplication.class, args);
19: 	}
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: public class ShopException extends RuntimeException {
7:     public ShopException( String message ) {
8:         super( message );
9:     }
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
7: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
8: import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
9: import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
10: import thkoeln.archilab.ecommerce.solution.user.domain.User;
11: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
12: import thkoeln.archilab.ecommerce.usecases.OrderUseCases;
13: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
15: 
16: import java.util.HashMap;
17: import java.util.List;
18: import java.util.Map;
19: import java.util.UUID;
20: 
21: @Service
22: public class OrderService implements OrderUseCases {
23:     
24:     private final OrderRepository orderRepository;
25:     private final UserRepository userRepository;
26:     private final ProductCatalogUseCases productCatalogUseCases;
27:     
28:     @Autowired
29:     public OrderService(OrderRepository orderRepository, 
30:                        UserRepository userRepository,
31:                        ProductCatalogUseCases productCatalogUseCases) {
32:         this.orderRepository = orderRepository;
33:         this.userRepository = userRepository;
34:         this.productCatalogUseCases = productCatalogUseCases;
35:     }
36:     
37:     @Override
38:     public Map<UUID, Integer> getOrderHistory(EmailAddressType userEmailAddress) {
39:         if (userEmailAddress == null) {
40:             throw new ShopException("User email address cannot be null");
41:         }
42:         
43:         String emailString = ((EmailAddress) userEmailAddress).getEmailAddressString();
44:         User user = userRepository.findByEmailAddress(emailString)
45:                 .orElseThrow(() -> new ShopException("User with email " + emailString + " does not exist"));
46:         
47:         List<Order> orders = orderRepository.findByUserId(user.getId());
48:         
49:         // Aggregate quantities across all orders for each product
50:         Map<UUID, Integer> orderHistory = new HashMap<>();
51:         for (Order order : orders) {
52:             Map<UUID, Integer> orderProducts = order.getOrderAsMap();
53:             for (Map.Entry<UUID, Integer> entry : orderProducts.entrySet()) {
54:                 orderHistory.merge(entry.getKey(), entry.getValue(), Integer::sum);
55:             }
56:         }
57:         
58:         return orderHistory;
59:     }
60:     
61:     @Override
62:     public Integer getOrderQuantiOfProduct(UUID orderId, UUID productId) {
63:         if (orderId == null) {
64:             throw new ShopException("Order ID cannot be null");
65:         }
66:         if (productId == null) {
67:             throw new ShopException("Product ID cannot be null");
68:         }
69:         
70:         if (!orderRepository.existsById(new OrderId(orderId))) {
71:             throw new ShopException("Order with ID " + orderId + " does not exist");
72:         }
73:         
74:         // Validate product exists
75:         try {
76:             productCatalogUseCases.getSalesPrice(productId);
77:         } catch (ShopException e) {
78:             throw new ShopException("Product with ID " + productId + " does not exist");
79:         }
80:         
81:         Order order = orderRepository.findById(new OrderId(orderId))
82:                 .orElseThrow(() -> new ShopException("Order with ID " + orderId + " does not exist"));
83:         
84:         return order.getQuantityOfProduct(productId);
85:     }
86:     
87:     @Override
88:     public UUID getWarehouseIdForOrder(UUID orderId) {
89:         if (orderId == null) {
90:             throw new ShopException("Order ID cannot be null");
91:         }
92:         
93:         Order order = orderRepository.findById(new OrderId(orderId))
94:                 .orElseThrow(() -> new ShopException("Order with ID " + orderId + " does not exist"));
95:         
96:         return order.getWarehouseId();
97:     }
98:     
99:     @Override
100:     public void deleteAllOrders() {
101:         orderRepository.deleteAll();
102:     }
103:     
104:     // Helper method for creating orders during checkout (not part of interface)
105:     public Order createOrder(UUID userId, UUID warehouseId, Map<UUID, Integer> items) {
106:         User user = userRepository.findById(new thkoeln.archilab.ecommerce.solution.user.domain.UserId(userId))
107:                 .orElseThrow(() -> new ShopException("User with ID " + userId + " does not exist"));
108:         
109:         Order order = new Order(user.getId(), warehouseId);
110:         
111:         for (Map.Entry<UUID, Integer> item : items.entrySet()) {
112:             order.addPart(item.getKey(), item.getValue());
113:         }
114:         
115:         return orderRepository.save(order);
116:     }
117: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.*;
4: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
5: 
6: import java.util.*;
7: 
8: @Entity
9: @Table(name = "orders")
10: public class Order {
11:     
12:     @Id
13:     private OrderId id;
14:     
15:     @Column(nullable = false)
16:     private UserId userId;
17:     
18:     @Column(nullable = false)
19:     private UUID warehouseId;
20:     
21:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
22:     @JoinColumn(name = "order_id")
23:     private List<OrderPart> parts = new ArrayList<>();
24:     
25:     protected Order() {
26:         // JPA constructor
27:     }
28:     
29:     public Order(UserId userId, UUID warehouseId) {
30:         this.id = new OrderId(UUID.randomUUID());
31:         this.userId = userId;
32:         this.warehouseId = warehouseId;
33:     }
34:     
35:     public OrderId getId() {
36:         return id;
37:     }
38:     
39:     public UUID getIdAsUUID() {
40:         return id.getId();
41:     }
42:     
43:     public UserId getUserId() {
44:         return userId;
45:     }
46:     
47:     public UUID getWarehouseId() {
48:         return warehouseId;
49:     }
50:     
51:     public List<OrderPart> getParts() {
52:         return new ArrayList<>(parts);
53:     }
54:     
55:     public void addPart(UUID productId, int quantity) {
56:         OrderPart part = new OrderPart(productId, quantity);
57:         parts.add(part);
58:     }
59:     
60:     public Map<UUID, Integer> getOrderAsMap() {
61:         Map<UUID, Integer> orderMap = new HashMap<>();
62:         for (OrderPart part : parts) {
63:             orderMap.put(part.getProductId(), part.getQuantity());
64:         }
65:         return orderMap;
66:     }
67:     
68:     public int getQuantityOfProduct(UUID productId) {
69:         return parts.stream()
70:                 .filter(part -> part.getProductId().equals(productId))
71:                 .mapToInt(OrderPart::getQuantity)
72:                 .sum();
73:     }
74:     
75:     public boolean containsProduct(UUID productId) {
76:         return parts.stream()
77:                 .anyMatch(part -> part.getProductId().equals(productId));
78:     }
79: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderId.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import thkoeln.archilab.ecommerce.GenericId;
4: import java.util.UUID;
5: 
6: public class OrderId extends GenericId {
7:     
8:     public OrderId() {
9:         super();
10:     }
11:     
12:     public OrderId(String id) {
13:         super(UUID.fromString(id));
14:     }
15:     
16:     public OrderId(UUID id) {
17:         super(id);
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class OrderIdConverter extends GenericIdConverter<OrderId> {
8:     
9:     public OrderIdConverter() {
10:         super(uuid -> new OrderId(uuid));
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderJpaRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
6: 
7: import java.util.List;
8: import java.util.UUID;
9: 
10: @Repository
11: public interface OrderJpaRepository extends JpaRepository<Order, OrderId>, OrderRepository {
12:     
13:     List<Order> findByUserId(UserId userId);
14: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPart.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.*;
4: import java.util.UUID;
5: 
6: @Entity
7: @Table(name = "order_parts")
8: public class OrderPart {
9:     
10:     @Id
11:     private OrderPartId id;
12:     
13:     @Column(nullable = false)
14:     private UUID productId;
15:     
16:     @Column(nullable = false)
17:     private int quantity;
18:     
19:     protected OrderPart() {
20:         // JPA constructor
21:     }
22:     
23:     public OrderPart(UUID productId, int quantity) {
24:         this.id = new OrderPartId();
25:         this.productId = productId;
26:         this.quantity = quantity;
27:     }
28:     
29:     public OrderPartId getId() {
30:         return id;
31:     }
32:     
33:     public UUID getProductId() {
34:         return productId;
35:     }
36:     
37:     public int getQuantity() {
38:         return quantity;
39:     }
40:     
41:     public void setQuantity(int quantity) {
42:         this.quantity = quantity;
43:     }
44: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPartId.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import thkoeln.archilab.ecommerce.GenericId;
4: import java.util.UUID;
5: 
6: public class OrderPartId extends GenericId {
7:     
8:     public OrderPartId() {
9:         super();
10:     }
11:     
12:     public OrderPartId(String id) {
13:         super(UUID.fromString(id));
14:     }
15:     
16:     public OrderPartId(UUID id) {
17:         super(id);
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPartIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class OrderPartIdConverter extends GenericIdConverter<OrderPartId> {
8:     
9:     public OrderPartIdConverter() {
10:         super(uuid -> new OrderPartId(uuid));
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
4: 
5: import java.util.List;
6: import java.util.Optional;
7: import java.util.UUID;
8: 
9: public interface OrderRepository {
10:     
11:     Order save(Order order);
12:     
13:     Optional<Order> findById(OrderId orderId);
14:     
15:     List<Order> findByUserId(UserId userId);
16:     
17:     List<Order> findAll();
18:     
19:     void deleteAll();
20:     
21:     boolean existsById(OrderId orderId);
22: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductService.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
7: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
8: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
9: import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
10: import thkoeln.archilab.ecommerce.solution.warehouse.domain.Warehouse;
11: import thkoeln.archilab.ecommerce.solution.warehouse.domain.WarehouseRepository;
12: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
13: import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
14: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
16: 
17: import java.util.List;
18: import java.util.UUID;
19: 
20: @Service
21: public class ProductService implements ProductCatalogUseCases {
22:     
23:     private final ProductRepository productRepository;
24:     private final WarehouseRepository warehouseRepository;
25:     private final OrderRepository orderRepository;
26:     
27:     @Autowired
28:     public ProductService(ProductRepository productRepository, 
29:                          WarehouseRepository warehouseRepository,
30:                          OrderRepository orderRepository) {
31:         this.productRepository = productRepository;
32:         this.warehouseRepository = warehouseRepository;
33:         this.orderRepository = orderRepository;
34:     }
35: 
36:     @Override
37:     public UUID addProductToCatalog(String name, String descriptionOf, Float size, 
38:                                     CurrencyType buyingPrice, CurrencyType salesPrice) {
39:         // Validate inputs
40:         if (name == null || name.trim().isEmpty()) {
41:             throw new ShopException("Product name cannot be null or empty");
42:         }
43:         if (descriptionOf == null || descriptionOf.trim().isEmpty()) {
44:             throw new ShopException("Product description cannot be null or empty");
45:         }
46:         if (size != null && size <= 0) {
47:             throw new ShopException("Product size must be greater than 0");
48:         }
49:         if (buyingPrice == null) {
50:             throw new ShopException("Buying price cannot be null");
51:         }
52:         if (salesPrice == null) {
53:             throw new ShopException("Sales price cannot be null");
54:         }
55:         
56:         Currency buyingPriceCurrency = (Currency) buyingPrice;
57:         Currency salesPriceCurrency = (Currency) salesPrice;
58:         
59:         if (buyingPriceCurrency.getQuantity() <= 0) {
60:             throw new ShopException("Buying price must be greater than 0");
61:         }
62:         if (salesPriceCurrency.getQuantity() < buyingPriceCurrency.getQuantity()) {
63:             throw new ShopException("Sales price cannot be lower than buying price");
64:         }
65:         
66:         Product product = new Product(name, descriptionOf, size, buyingPriceCurrency, salesPriceCurrency);
67:         Product savedProduct = productRepository.save(product);
68:         
69:         return savedProduct.getIdAsUUID();
70:     }
71: 
72:     @Override
73:     public void removeProductFromCatalog(UUID productId) {
74:         if (productId == null) {
75:             throw new ShopException("Product ID cannot be null");
76:         }
77:         
78:         if (!productRepository.existsById(new ProductId(productId))) {
79:             throw new ShopException("Product with ID " + productId + " does not exist");
80:         }
81:         
82:         // Check if product exists in any warehouse inventory
83:         List<Warehouse> allWarehouses = warehouseRepository.findAll();
84:         for (Warehouse warehouse : allWarehouses) {
85:             if (warehouse.hasProduct(productId)) {
86:                 throw new ShopException("Cannot remove product that exists in warehouse inventory");
87:             }
88:         }
89:         
90:         // Check if product is referenced by any order
91:         List<Order> allOrders = orderRepository.findAll();
92:         for (Order order : allOrders) {
93:             if (order.containsProduct(productId)) {
94:                 throw new ShopException("Cannot remove product that is referenced in orders");
95:             }
96:         }
97:         
98:         productRepository.deleteById(new ProductId(productId));
99:     }
100: 
101:     @Override
102:     public CurrencyType getSalesPrice(UUID productId) {
103:         if (productId == null) {
104:             throw new ShopException("Product ID cannot be null");
105:         }
106:         
107:         Product product = productRepository.findById(new ProductId(productId))
108:                 .orElseThrow(() -> new ShopException("Product with ID " + productId + " does not exist"));
109:         
110:         return product.getSalesPrice();
111:     }
112: 
113:     @Override
114:     public void deleteProductCatalog() {
115:         productRepository.deleteAll();
116:     }
117: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\Product.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
5: 
6: import jakarta.persistence.Entity;
7: import jakarta.persistence.Id;
8: import jakarta.persistence.Embedded;
9: import jakarta.persistence.AttributeOverrides;
10: import jakarta.persistence.AttributeOverride;
11: import jakarta.persistence.Column;
12: import java.util.UUID;
13: 
14: @Entity
15: public class Product {
16:     
17:     @Id
18:     private ProductId id;
19:     
20:     private String name;
21:     
22:     @Column(length = 1000)
23:     private String description;
24:     
25:     private Float size;
26:     
27:     @Column(name = "buying_price_amount")
28:     private Float buyingPriceAmount;
29:     
30:     @Column(name = "buying_price_currency")
31:     private String buyingPriceCurrency;
32:     
33:     @Column(name = "sales_price_amount")
34:     private Float salesPriceAmount;
35:     
36:     @Column(name = "sales_price_currency")
37:     private String salesPriceCurrency;
38:     
39:     protected Product() {
40:         // JPA constructor
41:     }
42:     
43:     public Product(String name, String description, Float size, Currency buyingPrice, Currency salesPrice) {
44:         this.id = new ProductId(UUID.randomUUID());
45:         this.name = name;
46:         this.description = description;
47:         this.size = size;
48:         this.buyingPriceAmount = buyingPrice.getQuantity();
49:         this.buyingPriceCurrency = buyingPrice.getCurrencyUnit();
50:         this.salesPriceAmount = salesPrice.getQuantity();
51:         this.salesPriceCurrency = salesPrice.getCurrencyUnit();
52:     }
53:     
54:     public ProductId getId() {
55:         return id;
56:     }
57:     
58:     public UUID getIdAsUUID() {
59:         return id.getId();
60:     }
61:     
62:     public String getName() {
63:         return name;
64:     }
65:     
66:     public String getDescription() {
67:         return description;
68:     }
69:     
70:     public Float getSize() {
71:         return size;
72:     }
73:     
74:     public CurrencyType getBuyingPrice() {
75:         return Currency.of(buyingPriceAmount, buyingPriceCurrency);
76:     }
77:     
78:     public CurrencyType getSalesPrice() {
79:         return Currency.of(salesPriceAmount, salesPriceCurrency);
80:     }
81: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductId.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import thkoeln.archilab.ecommerce.GenericId;
4: import java.util.UUID;
5: 
6: public class ProductId extends GenericId {
7:     
8:     public ProductId() {
9:         super();
10:     }
11:     
12:     public ProductId(UUID id) {
13:         super(id);
14:     }
15: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ProductIdConverter extends GenericIdConverter<ProductId> {
8:     
9:     public ProductIdConverter() {
10:         super(ProductId::new);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductJpaRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.stereotype.Repository;
5: 
6: import java.util.UUID;
7: 
8: @Repository
9: public interface ProductJpaRepository extends JpaRepository<Product, ProductId>, ProductRepository {
10: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import java.util.Optional;
4: import java.util.UUID;
5: 
6: public interface ProductRepository {
7:     
8:     Product save(Product product);
9:     
10:     Optional<Product> findById(ProductId id);
11:     
12:     void deleteById(ProductId id);
13:     
14:     void deleteAll();
15:     
16:     boolean existsById(ProductId id);
17: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\CheckoutOrchestrator.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import org.springframework.stereotype.Component;
4: import thkoeln.archilab.ecommerce.InsufficientInventoryException;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
7: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartPart;
8: import thkoeln.archilab.ecommerce.solution.user.domain.User;
9: import thkoeln.archilab.ecommerce.solution.warehouse.domain.Warehouse;
10: import thkoeln.archilab.ecommerce.solution.warehouse.domain.WarehouseId;
11: import thkoeln.archilab.ecommerce.solution.warehouse.domain.WarehouseRepository;
12: 
13: import java.util.*;
14: 
15: @Component
16: public class CheckoutOrchestrator {
17:     
18:     private final WarehouseRepository warehouseRepository;
19:     
20:     public CheckoutOrchestrator(WarehouseRepository warehouseRepository) {
21:         this.warehouseRepository = warehouseRepository;
22:     }
23:     
24:     public void validateInventoryAvailability(ShoppingCart cart, List<Warehouse> warehouses) {
25:         for (ShoppingCartPart part : cart.getParts()) {
26:             int totalAvailable = 0;
27:             
28:             for (Warehouse warehouse : warehouses) {
29:                 int available = warehouse.getInventoryLevel(part.getProductId());
30:                 totalAvailable += available;
31:             }
32:             
33:             if (totalAvailable < part.getQuantity()) {
34:                 throw new InsufficientInventoryException("Insufficient inventory for product " + part.getProductId());
35:             }
36:         }
37:     }
38:     
39:     public Map<UUID, Map<UUID, Integer>> determineWarehouseOrders(User user, ShoppingCart cart, 
40:                                                                   List<Warehouse> warehouses, Map<UUID, Integer> remainingItems) {
41:         Map<UUID, Map<UUID, Integer>> warehouseOrders = new HashMap<>();
42:         
43:         UUID singleWarehouse = findSingleWarehouseForEntireOrder(user, cart, warehouses);
44:         
45:         if (singleWarehouse != null) {
46:             warehouseOrders.put(singleWarehouse, remainingItems);
47:         } else {
48:             warehouseOrders = splitOrderAcrossWarehouses(user, warehouses, remainingItems);
49:         }
50:         
51:         return warehouseOrders;
52:     }
53:     
54:     private UUID findSingleWarehouseForEntireOrder(User user, ShoppingCart cart, List<Warehouse> warehouses) {
55:         UUID singleWarehouse = null;
56:         int shortestDistance = Integer.MAX_VALUE;
57:         
58:         for (Warehouse warehouse : warehouses) {
59:             if (canWarehouseFulfillEntireCart(warehouse, cart)) {
60:                 int distance = user.getAddressLocation().getPostalCode().distance(
61:                         warehouse.getAddressLocation().getPostalCode()
62:                 );
63:                 
64:                 if (distance < shortestDistance) {
65:                     shortestDistance = distance;
66:                     singleWarehouse = warehouse.getIdAsUUID();
67:                 }
68:             }
69:         }
70:         
71:         return singleWarehouse;
72:     }
73:     
74:     private boolean canWarehouseFulfillEntireCart(Warehouse warehouse, ShoppingCart cart) {
75:         for (ShoppingCartPart part : cart.getParts()) {
76:             int available = warehouse.getInventoryLevel(part.getProductId());
77:             if (available < part.getQuantity()) {
78:                 return false;
79:             }
80:         }
81:         return true;
82:     }
83:     
84:     private Map<UUID, Map<UUID, Integer>> splitOrderAcrossWarehouses(User user, List<Warehouse> warehouses,
85:                                                                      Map<UUID, Integer> remainingItems) {
86:         Map<UUID, List<UUID>> productToWarehouses = buildProductToWarehousesMap(user, warehouses, remainingItems);
87:         return assignProductsToWarehouses(user, warehouses, remainingItems, productToWarehouses);
88:     }
89:     
90:     private Map<UUID, List<UUID>> buildProductToWarehousesMap(User user, List<Warehouse> warehouses,
91:                                                               Map<UUID, Integer> remainingItems) {
92:         Map<UUID, List<UUID>> productToWarehouses = new HashMap<>();
93:         
94:         for (Map.Entry<UUID, Integer> item : remainingItems.entrySet()) {
95:             UUID productId = item.getKey();
96:             int neededQuantity = item.getValue();
97:             
98:             List<UUID> validWarehouses = findWarehousesWithSufficientInventory(warehouses, productId, neededQuantity);
99:             
100:             if (validWarehouses.isEmpty()) {
101:                 throw new InsufficientInventoryException("Insufficient inventory for product " + productId);
102:             }
103:             
104:             sortWarehousesByDistance(validWarehouses, user);
105:             productToWarehouses.put(productId, validWarehouses);
106:         }
107:         
108:         return productToWarehouses;
109:     }
110:     
111:     private List<UUID> findWarehousesWithSufficientInventory(List<Warehouse> warehouses, UUID productId, int neededQuantity) {
112:         List<UUID> validWarehouses = new ArrayList<>();
113:         
114:         for (Warehouse warehouse : warehouses) {
115:             int available = warehouse.getInventoryLevel(productId);
116:             if (available >= neededQuantity) {
117:                 validWarehouses.add(warehouse.getIdAsUUID());
118:             }
119:         }
120:         
121:         return validWarehouses;
122:     }
123:     
124:     private void sortWarehousesByDistance(List<UUID> warehouseIds, User user) {
125:         warehouseIds.sort((w1, w2) -> {
126:             Warehouse warehouse1 = warehouseRepository.findById(new WarehouseId(w1)).orElse(null);
127:             Warehouse warehouse2 = warehouseRepository.findById(new WarehouseId(w2)).orElse(null);
128:             
129:             if (warehouse1 == null || warehouse2 == null) return 0;
130:             
131:             int dist1 = user.getAddressLocation().getPostalCode().distance(
132:                     warehouse1.getAddressLocation().getPostalCode()
133:             );
134:             int dist2 = user.getAddressLocation().getPostalCode().distance(
135:                     warehouse2.getAddressLocation().getPostalCode()
136:             );
137:             
138:             return Integer.compare(dist1, dist2);
139:         });
140:     }
141:     
142:     private Map<UUID, Map<UUID, Integer>> assignProductsToWarehouses(User user, List<Warehouse> warehouses,
143:                                                                      Map<UUID, Integer> remainingItems, Map<UUID, List<UUID>> productToWarehouses) {
144:         Map<UUID, Map<UUID, Integer>> warehouseOrders = new HashMap<>();
145:         Set<UUID> assignedProducts = new HashSet<>();
146:         
147:         while (assignedProducts.size() < remainingItems.size()) {
148:             WarehouseAssignment best = findBestWarehouseAssignment(user, warehouses, remainingItems,
149:                     productToWarehouses, assignedProducts);
150:             
151:             if (best.warehouseId != null && !best.products.isEmpty()) {
152:                 Map<UUID, Integer> warehouseOrder = new HashMap<>();
153:                 for (UUID productId : best.products) {
154:                     warehouseOrder.put(productId, remainingItems.get(productId));
155:                     assignedProducts.add(productId);
156:                 }
157:                 warehouseOrders.put(best.warehouseId, warehouseOrder);
158:             } else {
159:                 break;
160:             }
161:         }
162:         
163:         return warehouseOrders;
164:     }
165:     
166:     private WarehouseAssignment findBestWarehouseAssignment(User user, List<Warehouse> warehouses,
167:                                                             Map<UUID, Integer> remainingItems, Map<UUID, List<UUID>> productToWarehouses,
168:                                                             Set<UUID> assignedProducts) {
169:         UUID bestWarehouse = null;
170:         Set<UUID> bestGrouping = new HashSet<>();
171:         int bestScore = -1;
172:         
173:         for (Warehouse warehouse : warehouses) {
174:             UUID warehouseId = warehouse.getIdAsUUID();
175:             Set<UUID> serveableProducts = findServeableProducts(warehouseId, remainingItems,
176:                     productToWarehouses, assignedProducts);
177:             
178:             if (!serveableProducts.isEmpty()) {
179:                 int distance = user.getAddressLocation().getPostalCode().distance(
180:                         warehouse.getAddressLocation().getPostalCode()
181:                 );
182:                 int score = serveableProducts.size() * 1000 - distance;
183:                 
184:                 if (score > bestScore) {
185:                     bestScore = score;
186:                     bestWarehouse = warehouseId;
187:                     bestGrouping = serveableProducts;
188:                 }
189:             }
190:         }
191:         
192:         return new WarehouseAssignment(bestWarehouse, bestGrouping);
193:     }
194:     
195:     private Set<UUID> findServeableProducts(UUID warehouseId, Map<UUID, Integer> remainingItems,
196:                                             Map<UUID, List<UUID>> productToWarehouses, Set<UUID> assignedProducts) {
197:         Set<UUID> serveableProducts = new HashSet<>();
198:         
199:         for (UUID productId : remainingItems.keySet()) {
200:             if (!assignedProducts.contains(productId)) {
201:                 List<UUID> validWarehouses = productToWarehouses.get(productId);
202:                 if (validWarehouses.contains(warehouseId)) {
203:                     serveableProducts.add(productId);
204:                 }
205:             }
206:         }
207:         
208:         return serveableProducts;
209:     }
210:     
211:     private static class WarehouseAssignment {
212:         final UUID warehouseId;
213:         final Set<UUID> products;
214:         
215:         WarehouseAssignment(UUID warehouseId, Set<UUID> products) {
216:             this.warehouseId = warehouseId;
217:             this.products = products;
218:         }
219:     }
220: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\InventoryManager.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import org.springframework.stereotype.Component;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.solution.warehouse.domain.Warehouse;
6: import thkoeln.archilab.ecommerce.solution.warehouse.domain.WarehouseId;
7: import thkoeln.archilab.ecommerce.solution.warehouse.domain.WarehouseRepository;
8: 
9: import java.util.Map;
10: import java.util.UUID;
11: 
12: @Component
13: public class InventoryManager {
14:     
15:     private final WarehouseRepository warehouseRepository;
16:     
17:     public InventoryManager(WarehouseRepository warehouseRepository) {
18:         this.warehouseRepository = warehouseRepository;
19:     }
20:     
21:     public void reduceInventory(UUID warehouseId, Map<UUID, Integer> products) {
22:         Warehouse warehouse = warehouseRepository.findById(new WarehouseId(warehouseId))
23:                 .orElseThrow(() -> new ShopException("Warehouse not found"));
24:         
25:         for (Map.Entry<UUID, Integer> product : products.entrySet()) {
26:             warehouse.removeFromInventory(product.getKey(), product.getValue());
27:         }
28:         warehouseRepository.save(warehouse);
29:     }
30: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartController.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.http.HttpStatus;
5: import org.springframework.http.ResponseEntity;
6: import org.springframework.web.bind.annotation.*;
7: import thkoeln.archilab.ecommerce.InsufficientInventoryException;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
10: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
11: import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
12: import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
13: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
14: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartId;
15: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartRepository;
16: import thkoeln.archilab.ecommerce.solution.user.domain.User;
17: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
18: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
19: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
20: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
21: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
22: 
23: import java.util.*;
24: 
25: @RestController
26: @RequestMapping("/shoppingCarts")
27: public class ShoppingCartController {
28:     
29:     private final ShoppingCartUseCases shoppingCartUseCases;
30:     private final ShoppingCartRepository shoppingCartRepository;
31:     private final UserRepository userRepository;
32:     private final ProductCatalogUseCases productCatalogUseCases;
33:     private final OrderRepository orderRepository;
34:     
35:     @Autowired
36:     public ShoppingCartController(ShoppingCartUseCases shoppingCartUseCases,
37:                                  ShoppingCartRepository shoppingCartRepository,
38:                                  UserRepository userRepository,
39:                                  ProductCatalogUseCases productCatalogUseCases,
40:                                  OrderRepository orderRepository) {
41:         this.shoppingCartUseCases = shoppingCartUseCases;
42:         this.shoppingCartRepository = shoppingCartRepository;
43:         this.userRepository = userRepository;
44:         this.productCatalogUseCases = productCatalogUseCases;
45:         this.orderRepository = orderRepository;
46:     }
47:     
48:     @GetMapping(params = "userId")
49:     public ResponseEntity<ShoppingCartDTO> getShoppingCartByUserId(@RequestParam String userId) {
50:         try {
51:             // Parse UUID string and handle invalid format
52:             UUID userUUID;
53:             try {
54:                 userUUID = UUID.fromString(userId);
55:             } catch (IllegalArgumentException e) {
56:                 return ResponseEntity.notFound().build();
57:             }
58:             
59:             UserId userIdObj = new UserId(userUUID);
60:             
61:             // Check if user exists first
62:             if (!userRepository.findById(userIdObj).isPresent()) {
63:                 return ResponseEntity.notFound().build();
64:             }
65:             
66:             ShoppingCart cart = shoppingCartRepository.findByUserId(userIdObj)
67:                     .orElse(new ShoppingCart(userIdObj));
68:             
69:             // Save the cart if it was just created
70:             if (cart.getParts().isEmpty()) {
71:                 cart = shoppingCartRepository.save(cart);
72:             }
73:             
74:             ShoppingCartDTO dto = convertToDTO(cart);
75:             return ResponseEntity.ok(dto);
76:         } catch (Exception e) {
77:             return ResponseEntity.notFound().build();
78:         }
79:     }
80:     
81:     @GetMapping("/{cartId}")
82:     public ResponseEntity<?> getShoppingCartById(@PathVariable UUID cartId) {
83:         // According to test, this should return 404 Not Found for any UUID
84:         return ResponseEntity.notFound().build();
85:     }
86:     
87:     @GetMapping
88:     public ResponseEntity<?> handleOtherGetRequests() {
89:         // For GET /shoppingCarts without parameters or with invalid parameters, return 405 Method Not Allowed
90:         return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).build();
91:     }
92:     
93:     @PostMapping("/{cartId}/parts")
94:     public ResponseEntity<?> addProductToCart(@PathVariable UUID cartId, @RequestBody QuantityDTO quantityDTO) {
95:         try {
96:             // Find the shopping cart and get its user
97:             ShoppingCart cart = shoppingCartRepository.findById(new ShoppingCartId(cartId))
98:                     .orElseThrow(() -> new ShopException("Shopping cart not found"));
99:             
100:             User user = userRepository.findById(cart.getUserId())
101:                     .orElseThrow(() -> new ShopException("User not found"));
102:             
103:             // Validate quantity
104:             if (quantityDTO.getQuantity() < 0) {
105:                 return ResponseEntity.unprocessableEntity().build();
106:             }
107:             
108:             EmailAddress userEmail = (EmailAddress) user.getEmailAddress();
109:             shoppingCartUseCases.addProductToShoppingCart(userEmail, quantityDTO.getProductId(), quantityDTO.getQuantity());
110:             
111:             return ResponseEntity.status(HttpStatus.CREATED).build();
112:         } catch (ShopException e) {
113:             // Check if it's a product not found error
114:             if (e.getMessage().contains("does not exist") || e.getMessage().contains("not found")) {
115:                 return ResponseEntity.notFound().build();
116:             }
117:             return ResponseEntity.badRequest().build();
118:         } catch (Exception e) {
119:             return ResponseEntity.badRequest().build();
120:         }
121:     }
122:     
123:     @DeleteMapping("/{cartId}/parts/{productId}")
124:     public ResponseEntity<?> removeProductFromCart(@PathVariable UUID cartId, @PathVariable UUID productId) {
125:         try {
126:             // Find the shopping cart and get its user
127:             ShoppingCart cart = shoppingCartRepository.findById(new ShoppingCartId(cartId))
128:                     .orElseThrow(() -> new ShopException("Shopping cart not found"));
129:             
130:             User user = userRepository.findById(cart.getUserId())
131:                     .orElseThrow(() -> new ShopException("User not found"));
132:             
133:             EmailAddress userEmail = (EmailAddress) user.getEmailAddress();
134:             Map<UUID, Integer> currentCart = shoppingCartUseCases.getShoppingCartAsMap(userEmail);
135:             
136:             if (currentCart.containsKey(productId)) {
137:                 int currentQuantity = currentCart.get(productId);
138:                 shoppingCartUseCases.removeProductFromShoppingCart(userEmail, productId, currentQuantity);
139:                 return ResponseEntity.ok().build();
140:             } else {
141:                 // Product doesn't exist in the cart, return 404
142:                 return ResponseEntity.notFound().build();
143:             }
144:         } catch (Exception e) {
145:             return ResponseEntity.notFound().build();
146:         }
147:     }
148:     
149:     @PostMapping("/{cartId}/checkout")
150:     public ResponseEntity<OrderDTO[]> checkout(@PathVariable UUID cartId) {
151:         try {
152:             // Find the shopping cart and get its user
153:             ShoppingCart cart = shoppingCartRepository.findById(new ShoppingCartId(cartId))
154:                     .orElseThrow(() -> new ShopException("Shopping cart not found"));
155:             
156:             User user = userRepository.findById(cart.getUserId())
157:                     .orElseThrow(() -> new ShopException("User not found"));
158:             
159:             EmailAddress userEmail = (EmailAddress) user.getEmailAddress();
160:             Set<UUID> orderIds = shoppingCartUseCases.checkout(userEmail);
161:             
162:             // Convert order IDs to DTOs with warehouse information
163:             List<OrderDTO> orders = new ArrayList<>();
164:             for (UUID orderId : orderIds) {
165:                 Order order = orderRepository.findById(new OrderId(orderId))
166:                         .orElseThrow(() -> new ShopException("Order not found"));
167:                 
168:                 OrderDTO orderDTO = new OrderDTO();
169:                 orderDTO.setId(orderId);
170:                 orderDTO.setUserName(user.getName());
171:                 orderDTO.setWarehouseId(order.getWarehouseId());
172:                 
173:                 // Convert order parts to QuantityDTO array
174:                 List<QuantityDTO> partsList = new ArrayList<>();
175:                 for (var part : order.getParts()) {
176:                     partsList.add(new QuantityDTO(part.getProductId(), part.getQuantity()));
177:                 }
178:                 orderDTO.setParts(partsList.toArray(new QuantityDTO[0]));
179:                 
180:                 orders.add(orderDTO);
181:             }
182:             
183:             return ResponseEntity.status(HttpStatus.CREATED).body(orders.toArray(new OrderDTO[0]));
184:         } catch (InsufficientInventoryException e) {
185:             // Return 409 Conflict for inventory issues
186:             return ResponseEntity.status(HttpStatus.CONFLICT).build();
187:         } catch (ShopException e) {
188:             // Check for empty cart or other business logic issues that should be 409
189:             if (e.getMessage().contains("empty") || e.getMessage().contains("unavailable")) {
190:                 return ResponseEntity.status(HttpStatus.CONFLICT).build();
191:             }
192:             return ResponseEntity.badRequest().build();
193:         } catch (Exception e) {
194:             return ResponseEntity.badRequest().build();
195:         }
196:     }
197:     
198:     private ShoppingCartDTO convertToDTO(ShoppingCart cart) {
199:         ShoppingCartDTO dto = new ShoppingCartDTO();
200:         dto.setId(cart.getIdAsUUID());
201:         
202:         // Convert parts
203:         List<ShoppingCartPartDTO> partDTOs = new ArrayList<>();
204:         for (var part : cart.getParts()) {
205:             ShoppingCartPartDTO partDTO = new ShoppingCartPartDTO();
206:             partDTO.setProductId(part.getProductId());
207:             partDTO.setQuantity(part.getQuantity());
208:             partDTOs.add(partDTO);
209:         }
210:         dto.setParts(partDTOs);
211:         
212:         // Calculate total sales price
213:         try {
214:             float totalPrice = 0.0f;
215:             for (var part : cart.getParts()) {
216:                 CurrencyType salesPrice = productCatalogUseCases.getSalesPrice(part.getProductId());
217:                 totalPrice += salesPrice.getQuantity() * part.getQuantity();
218:             }
219:             dto.setTotalSalesPrice(String.format("%.2f €", totalPrice));
220:         } catch (Exception e) {
221:             dto.setTotalSalesPrice("0.00 €");
222:         }
223:         
224:         return dto;
225:     }
226:     
227:     // DTOs
228:     public static class ShoppingCartDTO {
229:         private UUID id;
230:         private List<ShoppingCartPartDTO> parts;
231:         private String totalSalesPrice;
232:         
233:         // Getters and setters
234:         public UUID getId() { return id; }
235:         public void setId(UUID id) { this.id = id; }
236:         public List<ShoppingCartPartDTO> getParts() { return parts; }
237:         public void setParts(List<ShoppingCartPartDTO> parts) { this.parts = parts; }
238:         public String getTotalSalesPrice() { return totalSalesPrice; }
239:         public void setTotalSalesPrice(String totalSalesPrice) { this.totalSalesPrice = totalSalesPrice; }
240:     }
241:     
242:     public static class ShoppingCartPartDTO {
243:         private UUID productId;
244:         private int quantity;
245:         
246:         // Getters and setters
247:         public UUID getProductId() { return productId; }
248:         public void setProductId(UUID productId) { this.productId = productId; }
249:         public int getQuantity() { return quantity; }
250:         public void setQuantity(int quantity) { this.quantity = quantity; }
251:     }
252:     
253:     public static class QuantityDTO {
254:         private UUID productId;
255:         private int quantity;
256:         
257:         // Constructors
258:         public QuantityDTO() {}
259:         public QuantityDTO(UUID productId, int quantity) {
260:             this.productId = productId;
261:             this.quantity = quantity;
262:         }
263:         
264:         // Getters and setters
265:         public UUID getProductId() { return productId; }
266:         public void setProductId(UUID productId) { this.productId = productId; }
267:         public int getQuantity() { return quantity; }
268:         public void setQuantity(int quantity) { this.quantity = quantity; }
269:     }
270:     
271:     public static class OrderDTO {
272:         private UUID id;
273:         private String userName;
274:         private UUID warehouseId;
275:         private QuantityDTO[] parts;
276:         
277:         // Getters and setters
278:         public UUID getId() { return id; }
279:         public void setId(UUID id) { this.id = id; }
280:         public String getUserName() { return userName; }
281:         public void setUserName(String userName) { this.userName = userName; }
282:         public UUID getWarehouseId() { return warehouseId; }
283:         public void setWarehouseId(UUID warehouseId) { this.warehouseId = warehouseId; }
284:         public QuantityDTO[] getParts() { return parts; }
285:         public void setParts(QuantityDTO[] parts) { this.parts = parts; }
286:     }
287: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import org.springframework.transaction.annotation.Transactional;
6: import thkoeln.archilab.ecommerce.InsufficientInventoryException;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
9: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
10: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
11: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
12: import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
13: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
14: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartPart;
15: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartRepository;
16: import thkoeln.archilab.ecommerce.solution.order.application.OrderService;
17: import thkoeln.archilab.ecommerce.solution.user.domain.User;
18: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
19: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
20: import thkoeln.archilab.ecommerce.solution.warehouse.domain.Warehouse;
21: import thkoeln.archilab.ecommerce.solution.warehouse.domain.WarehouseId;
22: import thkoeln.archilab.ecommerce.solution.warehouse.domain.WarehouseRepository;
23: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
24: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
25: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
26: 
27: import java.util.*;
28: 
29: 
30: @Service
31: @Transactional
32: public class ShoppingCartService implements ShoppingCartUseCases {
33:     
34:     private final ShoppingCartRepository shoppingCartRepository;
35:     private final UserRepository userRepository;
36:     private final ProductRepository productRepository;
37:     private final WarehouseRepository warehouseRepository;
38:     private final OrderService orderService;
39:     private final CheckoutOrchestrator checkoutOrchestrator;
40:     private final InventoryManager inventoryManager;
41:     
42:     @Autowired
43:     public ShoppingCartService(ShoppingCartRepository shoppingCartRepository,
44:                                UserRepository userRepository,
45:                                ProductRepository productRepository,
46:                                WarehouseRepository warehouseRepository,
47:                                OrderService orderService,
48:                                CheckoutOrchestrator checkoutOrchestrator,
49:                                InventoryManager inventoryManager) {
50:         this.shoppingCartRepository = shoppingCartRepository;
51:         this.userRepository = userRepository;
52:         this.productRepository = productRepository;
53:         this.warehouseRepository = warehouseRepository;
54:         this.orderService = orderService;
55:         this.checkoutOrchestrator = checkoutOrchestrator;
56:         this.inventoryManager = inventoryManager;
57:     }
58:     
59:     @Override
60:     public void addProductToShoppingCart(EmailAddressType userEmailAddress, UUID productId, int quantiOf) {
61:         if (userEmailAddress == null) {
62:             throw new ShopException("User email address cannot be null");
63:         }
64:         if (productId == null) {
65:             throw new ShopException("Product ID cannot be null");
66:         }
67:         if (quantiOf < 0) {
68:             throw new ShopException("Quantity cannot be negative");
69:         }
70:         
71:         String emailString = ((EmailAddress) userEmailAddress).getEmailAddressString();
72:         User user = userRepository.findByEmailAddress(emailString)
73:                 .orElseThrow(() -> new ShopException("User with email " + emailString + " does not exist"));
74:         
75:         if (!productRepository.existsById(new ProductId(productId))) {
76:             throw new ShopException("Product with ID " + productId + " does not exist");
77:         }
78:         
79:         ShoppingCart cart = shoppingCartRepository.findByUserId(user.getId())
80:                 .orElse(new ShoppingCart(user.getId()));
81:         
82:         cart.addProduct(productId, quantiOf);
83:         shoppingCartRepository.save(cart);
84:     }
85:     
86:     @Override
87:     public void removeProductFromShoppingCart(EmailAddressType userEmailAddress, UUID productId, int quantiOf) {
88:         if (userEmailAddress == null) {
89:             throw new ShopException("User email address cannot be null");
90:         }
91:         if (productId == null) {
92:             throw new ShopException("Product ID cannot be null");
93:         }
94:         if (quantiOf < 0) {
95:             throw new ShopException("Quantity cannot be negative");
96:         }
97:         
98:         String emailString = ((EmailAddress) userEmailAddress).getEmailAddressString();
99:         User user = userRepository.findByEmailAddress(emailString)
100:                 .orElseThrow(() -> new ShopException("User with email " + emailString + " does not exist"));
101:         
102:         if (!productRepository.existsById(new ProductId(productId))) {
103:             throw new ShopException("Product with ID " + productId + " does not exist");
104:         }
105:         
106:         ShoppingCart cart = shoppingCartRepository.findByUserId(user.getId())
107:                 .orElseThrow(() -> new ShopException("Shopping cart is empty"));
108:         
109:         try {
110:             cart.removeProduct(productId, quantiOf);
111:             shoppingCartRepository.save(cart);
112:         } catch (IllegalArgumentException e) {
113:             throw new ShopException(e.getMessage());
114:         }
115:     }
116:     
117:     @Override
118:     public Map<UUID, Integer> getShoppingCartAsMap(EmailAddressType userEmailAddress) {
119:         if (userEmailAddress == null) {
120:             throw new ShopException("User email address cannot be null");
121:         }
122:         
123:         String emailString = ((EmailAddress) userEmailAddress).getEmailAddressString();
124:         User user = userRepository.findByEmailAddress(emailString)
125:                 .orElseThrow(() -> new ShopException("User with email " + emailString + " does not exist"));
126:         
127:         ShoppingCart cart = shoppingCartRepository.findByUserId(user.getId())
128:                 .orElse(new ShoppingCart(user.getId()));
129:         
130:         return cart.getCartAsMap();
131:     }
132:     
133:     @Override
134:     public CurrencyType getShoppingCartAsCurrencyValue(EmailAddressType userEmailAddress) {
135:         if (userEmailAddress == null) {
136:             throw new ShopException("User email address cannot be null");
137:         }
138:         
139:         String emailString = ((EmailAddress) userEmailAddress).getEmailAddressString();
140:         User user = userRepository.findByEmailAddress(emailString)
141:                 .orElseThrow(() -> new ShopException("User with email " + emailString + " does not exist"));
142:         
143:         ShoppingCart cart = shoppingCartRepository.findByUserId(user.getId())
144:                 .orElse(new ShoppingCart(user.getId()));
145:         
146:         Currency totalValue = Currency.of(0.0, "EUR");
147:         
148:         for (ShoppingCartPart part : cart.getParts()) {
149:             Product product = productRepository.findById(new ProductId(part.getProductId()))
150:                     .orElseThrow(() -> new ShopException("Product not found"));
151:             CurrencyType productPrice = product.getSalesPrice();
152:             totalValue = (Currency) totalValue.add(productPrice.multiplyBy(part.getQuantity()));
153:         }
154:         
155:         return totalValue;
156:     }
157:     
158:     @Override
159:     public Set<UUID> checkout(EmailAddressType userEmailAddress) {
160:         if (userEmailAddress == null) {
161:             throw new ShopException("User email address cannot be null");
162:         }
163:         
164:         User user = findUserByEmail(userEmailAddress);
165:         ShoppingCart cart = findCartForUser(user);
166:         
167:         if (cart.isEmpty()) {
168:             throw new ShopException("Shopping cart is empty");
169:         }
170:         
171:         List<Warehouse> warehouses = warehouseRepository.findAll();
172:         checkoutOrchestrator.validateInventoryAvailability(cart, warehouses);
173:         
174:         Map<UUID, Integer> remainingItems = new HashMap<>(cart.getCartAsMap());
175:         Map<UUID, Map<UUID, Integer>> warehouseOrders = checkoutOrchestrator.determineWarehouseOrders(user, cart, warehouses, remainingItems);
176:         
177:         Set<UUID> orderIds = processWarehouseOrders(user, warehouseOrders);
178:         
179:         cart.empty();
180:         shoppingCartRepository.save(cart);
181:         
182:         return orderIds;
183:     }
184:     
185:     private User findUserByEmail(EmailAddressType userEmailAddress) {
186:         String emailString = ((EmailAddress) userEmailAddress).getEmailAddressString();
187:         return userRepository.findByEmailAddress(emailString)
188:                 .orElseThrow(() -> new ShopException("User with email " + emailString + " does not exist"));
189:     }
190:     
191:     private ShoppingCart findCartForUser(User user) {
192:         return shoppingCartRepository.findByUserId(user.getId())
193:                 .orElseThrow(() -> new ShopException("Shopping cart is empty"));
194:     }
195:     
196:     
197:     private Set<UUID> processWarehouseOrders(User user, Map<UUID, Map<UUID, Integer>> warehouseOrders) {
198:         Set<UUID> orderIds = new HashSet<>();
199:         
200:         for (Map.Entry<UUID, Map<UUID, Integer>> warehouseOrder : warehouseOrders.entrySet()) {
201:             UUID warehouseId = warehouseOrder.getKey();
202:             Map<UUID, Integer> products = warehouseOrder.getValue();
203:             
204:             inventoryManager.reduceInventory(warehouseId, products);
205:             
206:             UUID orderId = orderService.createOrder(user.getId().getId(), warehouseId, products).getIdAsUUID();
207:             orderIds.add(orderId);
208:         }
209:         
210:         return orderIds;
211:     }
212:     
213:     
214:     @Override
215:     public void emptyAllShoppingCarts() {
216:         shoppingCartRepository.deleteAll();
217:     }
218: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCart.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.*;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
6: 
7: import java.util.*;
8: 
9: @Entity
10: @Table(name = "shopping_carts")
11: public class ShoppingCart {
12:     
13:     @Id
14:     private ShoppingCartId id;
15:     
16:     @Column(nullable = false, unique = true)
17:     private UserId userId;
18:     
19:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
20:     @JoinColumn(name = "shopping_cart_id")
21:     private List<ShoppingCartPart> parts = new ArrayList<>();
22:     
23:     protected ShoppingCart() {
24:         // JPA constructor
25:     }
26:     
27:     public ShoppingCart(UserId userId) {
28:         this.id = new ShoppingCartId(UUID.randomUUID());
29:         this.userId = userId;
30:     }
31:     
32:     public ShoppingCartId getId() {
33:         return id;
34:     }
35:     
36:     public UUID getIdAsUUID() {
37:         return id.getId();
38:     }
39:     
40:     public UserId getUserId() {
41:         return userId;
42:     }
43:     
44:     public void addProduct(UUID productId, int quantity) {
45:         if (quantity < 0) {
46:             throw new IllegalArgumentException("Quantity cannot be negative");
47:         }
48:         
49:         ShoppingCartPart existingPart = findPartByProductId(productId);
50:         if (existingPart != null) {
51:             existingPart.addQuantity(quantity);
52:         } else {
53:             ShoppingCartPart newPart = new ShoppingCartPart(productId, quantity);
54:             parts.add(newPart);
55:         }
56:     }
57:     
58:     public void removeProduct(UUID productId, int quantity) {
59:         if (quantity < 0) {
60:             throw new IllegalArgumentException("Quantity cannot be negative");
61:         }
62:         
63:         ShoppingCartPart part = findPartByProductId(productId);
64:         if (part == null) {
65:             throw new IllegalArgumentException("Product not in shopping cart");
66:         }
67:         
68:         if (part.getQuantity() < quantity) {
69:             throw new IllegalArgumentException("Not enough quantity in shopping cart");
70:         }
71:         
72:         if (part.getQuantity() == quantity) {
73:             parts.remove(part);
74:         } else {
75:             part.removeQuantity(quantity);
76:         }
77:     }
78:     
79:     public Map<UUID, Integer> getCartAsMap() {
80:         Map<UUID, Integer> cartMap = new HashMap<>();
81:         for (ShoppingCartPart part : parts) {
82:             cartMap.put(part.getProductId(), part.getQuantity());
83:         }
84:         return cartMap;
85:     }
86:     
87:     public void empty() {
88:         parts.clear();
89:     }
90:     
91:     public boolean isEmpty() {
92:         return parts.isEmpty();
93:     }
94:     
95:     public List<ShoppingCartPart> getParts() {
96:         return new ArrayList<>(parts);
97:     }
98:     
99:     private ShoppingCartPart findPartByProductId(UUID productId) {
100:         return parts.stream()
101:                 .filter(part -> part.getProductId().equals(productId))
102:                 .findFirst()
103:                 .orElse(null);
104:     }
105: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import thkoeln.archilab.ecommerce.GenericId;
4: import java.util.UUID;
5: 
6: public class ShoppingCartId extends GenericId {
7:     
8:     public ShoppingCartId() {
9:         super();
10:     }
11:     
12:     public ShoppingCartId(String id) {
13:         super(UUID.fromString(id));
14:     }
15:     
16:     public ShoppingCartId(UUID id) {
17:         super(id);
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ShoppingCartIdConverter extends GenericIdConverter<ShoppingCartId> {
8:     
9:     public ShoppingCartIdConverter() {
10:         super(uuid -> new ShoppingCartId(uuid));
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartJpaRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
6: 
7: import java.util.Optional;
8: import java.util.UUID;
9: 
10: @Repository
11: public interface ShoppingCartJpaRepository extends JpaRepository<ShoppingCart, ShoppingCartId>, ShoppingCartRepository {
12:     
13:     Optional<ShoppingCart> findByUserId(UserId userId);
14: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPart.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.*;
4: import java.util.UUID;
5: 
6: @Entity
7: @Table(name = "shopping_cart_parts")
8: public class ShoppingCartPart {
9:     
10:     @Id
11:     private ShoppingCartPartId id;
12:     
13:     @Column(nullable = false)
14:     private UUID productId;
15:     
16:     @Column(nullable = false)
17:     private int quantity;
18:     
19:     protected ShoppingCartPart() {
20:         // JPA constructor
21:     }
22:     
23:     public ShoppingCartPart(UUID productId, int quantity) {
24:         this.id = new ShoppingCartPartId();
25:         this.productId = productId;
26:         this.quantity = quantity;
27:     }
28:     
29:     public ShoppingCartPartId getId() {
30:         return id;
31:     }
32:     
33:     public UUID getProductId() {
34:         return productId;
35:     }
36:     
37:     public int getQuantity() {
38:         return quantity;
39:     }
40:     
41:     public void setQuantity(int quantity) {
42:         this.quantity = quantity;
43:     }
44:     
45:     public void addQuantity(int additionalQuantity) {
46:         this.quantity += additionalQuantity;
47:     }
48:     
49:     public void removeQuantity(int removedQuantity) {
50:         this.quantity -= removedQuantity;
51:     }
52: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPartId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import thkoeln.archilab.ecommerce.GenericId;
4: import java.util.UUID;
5: 
6: public class ShoppingCartPartId extends GenericId {
7:     
8:     public ShoppingCartPartId() {
9:         super();
10:     }
11:     
12:     public ShoppingCartPartId(String id) {
13:         super(UUID.fromString(id));
14:     }
15:     
16:     public ShoppingCartPartId(UUID id) {
17:         super(id);
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPartIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ShoppingCartPartIdConverter extends GenericIdConverter<ShoppingCartPartId> {
8:     
9:     public ShoppingCartPartIdConverter() {
10:         super(uuid -> new ShoppingCartPartId(uuid));
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
4: 
5: import java.util.List;
6: import java.util.Optional;
7: import java.util.UUID;
8: 
9: public interface ShoppingCartRepository {
10:     
11:     ShoppingCart save(ShoppingCart shoppingCart);
12:     
13:     Optional<ShoppingCart> findByUserId(UserId userId);
14:     
15:     Optional<ShoppingCart> findById(ShoppingCartId id);
16:     
17:     List<ShoppingCart> findAll();
18:     
19:     void deleteAll();
20: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserController.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.http.HttpStatus;
5: import org.springframework.http.ResponseEntity;
6: import org.springframework.web.bind.annotation.*;
7: import org.springframework.web.bind.annotation.RequestMethod;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
10: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.UserType;
12: 
13: import java.util.UUID;
14: 
15: @RestController
16: @RequestMapping("/users")
17: public class UserController {
18:     
19:     private final UserRegistrationUseCases userRegistrationUseCases;
20:     
21:     @Autowired
22:     public UserController(UserRegistrationUseCases userRegistrationUseCases) {
23:         this.userRegistrationUseCases = userRegistrationUseCases;
24:     }
25:     
26:     @GetMapping("/{id}")
27:     public ResponseEntity<?> getUserById(@PathVariable UUID id) {
28:         // According to test, this should return 404 Not Found for any UUID
29:         return ResponseEntity.notFound().build();
30:     }
31:     
32:     @GetMapping(params = "emailAddress")
33:     public ResponseEntity<UserType> getUserByEmail(@RequestParam String emailAddress) {
34:         try {
35:             EmailAddress email = EmailAddress.of(emailAddress);
36:             UserType user = userRegistrationUseCases.getUserData(email);
37:             return ResponseEntity.ok(user);
38:         } catch (ShopException e) {
39:             return ResponseEntity.notFound().build();
40:         }
41:     }
42:     
43:     @RequestMapping(method = RequestMethod.GET)
44:     public ResponseEntity<?> handleOtherGetRequests() {
45:         // For GET /users without parameters or with invalid parameters, return 405 Method Not Allowed
46:         return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).build();
47:     }
48: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserService.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
7: import thkoeln.archilab.ecommerce.domainprimitives.AddressLocation;
8: import thkoeln.archilab.ecommerce.solution.user.domain.User;
9: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
10: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.UserType;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
14: 
15: @Service
16: public class UserService implements UserRegistrationUseCases {
17:     
18:     private final UserRepository userRepository;
19:     
20:     @Autowired
21:     public UserService(UserRepository userRepository) {
22:         this.userRepository = userRepository;
23:     }
24: 
25:     @Override
26:     public void register(String name, EmailAddressType emailAddress, AddressLocationType addressLocation) {
27:         if (name == null || name.trim().isEmpty()) {
28:             throw new ShopException("User name cannot be null or empty");
29:         }
30:         if (emailAddress == null) {
31:             throw new ShopException("Email address cannot be null");
32:         }
33:         if (addressLocation == null) {
34:             throw new ShopException("Address location cannot be null");
35:         }
36:         
37:         EmailAddress email = (EmailAddress) emailAddress;
38:         AddressLocation address = (AddressLocation) addressLocation;
39:         
40:         if (userRepository.findByEmailAddress(email.getEmailAddressString()).isPresent()) {
41:             throw new ShopException("User with email " + email.toString() + " already exists");
42:         }
43:         
44:         User user = new User(name, email, address);
45:         userRepository.save(user);
46:     }
47: 
48:     @Override
49:     public void changeAddress(EmailAddressType userEmailAddress, AddressLocationType addressLocation) {
50:         if (userEmailAddress == null) {
51:             throw new ShopException("Email address cannot be null");
52:         }
53:         if (addressLocation == null) {
54:             throw new ShopException("Address location cannot be null");
55:         }
56:         
57:         EmailAddress email = (EmailAddress) userEmailAddress;
58:         AddressLocation newAddress = (AddressLocation) addressLocation;
59:         
60:         User user = userRepository.findByEmailAddress(email.getEmailAddressString())
61:                 .orElseThrow(() -> new ShopException("User with email " + email.toString() + " not found"));
62:         
63:         user.changeAddress(newAddress);
64:         userRepository.save(user);
65:     }
66: 
67:     @Override
68:     public UserType getUserData(EmailAddressType userEmailAddress) {
69:         if (userEmailAddress == null) {
70:             throw new ShopException("Email address cannot be null");
71:         }
72:         
73:         EmailAddress email = (EmailAddress) userEmailAddress;
74:         
75:         return userRepository.findByEmailAddress(email.getEmailAddressString())
76:                 .orElseThrow(() -> new ShopException("User with email " + email.toString() + " not found"));
77:     }
78: 
79:     @Override
80:     public void deleteAllUsers() {
81:         userRepository.deleteAll();
82:     }
83: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\User.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import thkoeln.archilab.ecommerce.GenericId;
4: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
5: import thkoeln.archilab.ecommerce.domainprimitives.AddressLocation;
6: import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;
7: import thkoeln.archilab.ecommerce.usecases.UserType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
10: 
11: import com.fasterxml.jackson.annotation.JsonIgnore;
12: import com.fasterxml.jackson.annotation.JsonProperty;
13: import jakarta.persistence.Entity;
14: import jakarta.persistence.Id;
15: import jakarta.persistence.Table;
16: import jakarta.persistence.Embedded;
17: import jakarta.persistence.AttributeOverrides;
18: import jakarta.persistence.AttributeOverride;
19: import jakarta.persistence.Column;
20: import java.util.UUID;
21: 
22: @Entity
23: @Table(name = "users")
24: public class User implements UserType {
25:     
26:     @Id
27:     private UserId id;
28:     
29:     private String name;
30:     
31:     @Column(name = "email_address")
32:     private String emailAddressString;
33:     
34:     private String street;
35:     
36:     private String city;
37:     
38:     @Column(name = "postal_code")
39:     private String postalCode;
40:     
41:     protected User() {
42:         // JPA constructor
43:     }
44:     
45:     public User(String name, EmailAddress emailAddress, AddressLocation addressLocation) {
46:         this.id = new UserId(UUID.randomUUID());
47:         this.name = name;
48:         this.emailAddressString = emailAddress.getEmailAddressString();
49:         this.street = addressLocation.getStreet();
50:         this.city = addressLocation.getCity();
51:         this.postalCode = addressLocation.getPostalCode().toString();
52:     }
53:     
54:     @JsonIgnore
55:     public UserId getId() {
56:         return id;
57:     }
58:     
59:     @JsonProperty("id")
60:     public UUID getIdAsUUID() {
61:         return id.getId();
62:     }
63:     
64:     @Override
65:     public String getName() {
66:         return name;
67:     }
68:     
69:     @Override
70:     public EmailAddressType getEmailAddress() {
71:         return EmailAddress.of(emailAddressString);
72:     }
73:     
74:     @Override
75:     public AddressLocationType getAddressLocation() {
76:         return AddressLocation.of(street, city, PostalCode.of(postalCode));
77:     }
78:     
79:     public void changeAddress(AddressLocation newAddressLocation) {
80:         this.street = newAddressLocation.getStreet();
81:         this.city = newAddressLocation.getCity();
82:         this.postalCode = newAddressLocation.getPostalCode().toString();
83:     }
84: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserId.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import thkoeln.archilab.ecommerce.GenericId;
4: import java.util.UUID;
5: 
6: public class UserId extends GenericId {
7:     
8:     public UserId() {
9:         super();
10:     }
11:     
12:     public UserId(UUID id) {
13:         super(id);
14:     }
15: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class UserIdConverter extends GenericIdConverter<UserId> {
8:     
9:     public UserIdConverter() {
10:         super(UserId::new);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserJpaRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.GenericId;
6: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
7: 
8: import java.util.Optional;
9: import java.util.UUID;
10: 
11: @Repository
12: public interface UserJpaRepository extends JpaRepository<User, UserId>, UserRepository {
13:     
14:     @Override
15:     default User save(User user) {
16:         return saveAndFlush(user);
17:     }
18:     
19:     @Override
20:     default Optional<User> findById(GenericId id) {
21:         if (id instanceof UserId) {
22:             return findById((UserId) id);
23:         }
24:         return Optional.empty();
25:     }
26:     
27:     Optional<User> findByEmailAddressString(String emailAddressString);
28:     
29:     @Override
30:     default Optional<User> findByEmailAddress(String emailAddressString) {
31:         return findByEmailAddressString(emailAddressString);
32:     }
33: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import thkoeln.archilab.ecommerce.GenericId;
4: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
5: 
6: import java.util.Optional;
7: 
8: public interface UserRepository {
9:     
10:     User save(User user);
11:     
12:     Optional<User> findById(GenericId id);
13:     
14:     Optional<User> findByEmailAddress(String emailAddressString);
15:     
16:     void deleteAll();
17: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\warehouse\application\WarehouseService.java ---
1: package thkoeln.archilab.ecommerce.solution.warehouse.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.AddressLocation;
7: import thkoeln.archilab.ecommerce.solution.warehouse.domain.Warehouse;
8: import thkoeln.archilab.ecommerce.solution.warehouse.domain.WarehouseId;
9: import thkoeln.archilab.ecommerce.solution.warehouse.domain.WarehouseRepository;
10: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
11: import thkoeln.archilab.ecommerce.usecases.WarehouseUseCases;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
13: 
14: import java.util.UUID;
15: 
16: @Service
17: public class WarehouseService implements WarehouseUseCases {
18:     
19:     private final WarehouseRepository warehouseRepository;
20:     private final ProductCatalogUseCases productCatalogUseCases;
21:     
22:     @Autowired
23:     public WarehouseService(WarehouseRepository warehouseRepository, ProductCatalogUseCases productCatalogUseCases) {
24:         this.warehouseRepository = warehouseRepository;
25:         this.productCatalogUseCases = productCatalogUseCases;
26:     }
27: 
28:     @Override
29:     public UUID addNewWarehouse(String name, AddressLocationType addressLocation) {
30:         if (name == null || name.trim().isEmpty()) {
31:             throw new ShopException("Warehouse name cannot be null or empty");
32:         }
33:         if (addressLocation == null) {
34:             throw new ShopException("Address location cannot be null");
35:         }
36:         
37:         AddressLocation address = (AddressLocation) addressLocation;
38:         Warehouse warehouse = new Warehouse(name, address);
39:         Warehouse savedWarehouse = warehouseRepository.save(warehouse);
40:         
41:         return savedWarehouse.getIdAsUUID();
42:     }
43: 
44:     @Override
45:     public void deleteAllWarehouses() {
46:         warehouseRepository.deleteAll();
47:     }
48: 
49:     @Override
50:     public void addToInventory(UUID warehouseId, UUID productId, int addedQuantiOf) {
51:         if (warehouseId == null) {
52:             throw new ShopException("Warehouse ID cannot be null");
53:         }
54:         if (productId == null) {
55:             throw new ShopException("Product ID cannot be null");
56:         }
57:         if (addedQuantiOf < 0) {
58:             throw new ShopException("Added quantity cannot be negative");
59:         }
60:         
61:         Warehouse warehouse = warehouseRepository.findById(new WarehouseId(warehouseId))
62:                 .orElseThrow(() -> new ShopException("Warehouse with ID " + warehouseId + " does not exist"));
63:         
64:         try {
65:             productCatalogUseCases.getSalesPrice(productId);
66:         } catch (ShopException e) {
67:             throw new ShopException("Product with ID " + productId + " does not exist");
68:         }
69:         
70:         warehouse.addToInventory(productId, addedQuantiOf);
71:         warehouseRepository.save(warehouse);
72:     }
73: 
74:     @Override
75:     public void removeFromInventory(UUID warehouseId, UUID productId, int removedQuantiOf) {
76:         if (warehouseId == null) {
77:             throw new ShopException("Warehouse ID cannot be null");
78:         }
79:         if (productId == null) {
80:             throw new ShopException("Product ID cannot be null");
81:         }
82:         if (removedQuantiOf < 0) {
83:             throw new ShopException("Removed quantity cannot be negative");
84:         }
85:         
86:         Warehouse warehouse = warehouseRepository.findById(new WarehouseId(warehouseId))
87:                 .orElseThrow(() -> new ShopException("Warehouse with ID " + warehouseId + " does not exist"));
88:         
89:         try {
90:             productCatalogUseCases.getSalesPrice(productId);
91:         } catch (ShopException e) {
92:             throw new ShopException("Product with ID " + productId + " does not exist");
93:         }
94:         
95:         int currentInventory = warehouse.getInventoryLevel(productId);
96:         if (currentInventory < removedQuantiOf) {
97:             throw new ShopException("Cannot remove " + removedQuantiOf + " items. Only " + currentInventory + " available");
98:         }
99:         
100:         warehouse.removeFromInventory(productId, removedQuantiOf);
101:         warehouseRepository.save(warehouse);
102:     }
103: 
104:     @Override
105:     public void changeInventoryTo(UUID warehouseId, UUID productId, int newTotalQuantiOf) {
106:         if (warehouseId == null) {
107:             throw new ShopException("Warehouse ID cannot be null");
108:         }
109:         if (productId == null) {
110:             throw new ShopException("Product ID cannot be null");
111:         }
112:         if (newTotalQuantiOf < 0) {
113:             throw new ShopException("New total quantity cannot be negative");
114:         }
115:         
116:         Warehouse warehouse = warehouseRepository.findById(new WarehouseId(warehouseId))
117:                 .orElseThrow(() -> new ShopException("Warehouse with ID " + warehouseId + " does not exist"));
118:         
119:         try {
120:             productCatalogUseCases.getSalesPrice(productId);
121:         } catch (ShopException e) {
122:             throw new ShopException("Product with ID " + productId + " does not exist");
123:         }
124:         
125:         warehouse.setInventoryLevel(productId, newTotalQuantiOf);
126:         warehouseRepository.save(warehouse);
127:     }
128: 
129:     @Override
130:     public int getAvailableInventory(UUID warehouseId, UUID productId) {
131:         if (warehouseId == null) {
132:             throw new ShopException("Warehouse ID cannot be null");
133:         }
134:         if (productId == null) {
135:             throw new ShopException("Product ID cannot be null");
136:         }
137:         
138:         Warehouse warehouse = warehouseRepository.findById(new WarehouseId(warehouseId))
139:                 .orElseThrow(() -> new ShopException("Warehouse with ID " + warehouseId + " does not exist"));
140:         
141:         try {
142:             productCatalogUseCases.getSalesPrice(productId);
143:         } catch (ShopException e) {
144:             throw new ShopException("Product with ID " + productId + " does not exist");
145:         }
146:         
147:         return warehouse.getInventoryLevel(productId);
148:     }
149: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\warehouse\domain\InventoryLevel.java ---
1: package thkoeln.archilab.ecommerce.solution.warehouse.domain;
2: 
3: import jakarta.persistence.Entity;
4: import jakarta.persistence.Id;
5: import jakarta.persistence.ManyToOne;
6: import jakarta.persistence.JoinColumn;
7: import java.util.UUID;
8: 
9: @Entity
10: public class InventoryLevel {
11:     
12:     @Id
13:     private InventoryLevelId id;
14:     
15:     private UUID productId;
16:     
17:     private int quantity;
18:     
19:     protected InventoryLevel() {
20:         // JPA constructor
21:     }
22:     
23:     public InventoryLevel(UUID productId, int quantity) {
24:         this.id = new InventoryLevelId();
25:         this.productId = productId;
26:         this.quantity = quantity;
27:     }
28:     
29:     public InventoryLevelId getId() {
30:         return id;
31:     }
32:     
33:     public UUID getProductId() {
34:         return productId;
35:     }
36:     
37:     public int getQuantity() {
38:         return quantity;
39:     }
40:     
41:     public void setQuantity(int quantity) {
42:         this.quantity = quantity;
43:     }
44:     
45:     public void addQuantity(int amount) {
46:         this.quantity += amount;
47:     }
48:     
49:     public void removeQuantity(int amount) {
50:         this.quantity -= amount;
51:     }
52: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\warehouse\domain\InventoryLevelId.java ---
1: package thkoeln.archilab.ecommerce.solution.warehouse.domain;
2: 
3: import thkoeln.archilab.ecommerce.GenericId;
4: import java.util.UUID;
5: 
6: public class InventoryLevelId extends GenericId {
7:     
8:     public InventoryLevelId() {
9:         super();
10:     }
11:     
12:     public InventoryLevelId(String id) {
13:         super(UUID.fromString(id));
14:     }
15:     
16:     public InventoryLevelId(UUID id) {
17:         super(id);
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\warehouse\domain\InventoryLevelIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.warehouse.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class InventoryLevelIdConverter extends GenericIdConverter<InventoryLevelId> {
8:     
9:     public InventoryLevelIdConverter() {
10:         super(uuid -> new InventoryLevelId(uuid));
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\warehouse\domain\Warehouse.java ---
1: package thkoeln.archilab.ecommerce.solution.warehouse.domain;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.AddressLocation;
4: import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
6: 
7: import jakarta.persistence.*;
8: import java.util.*;
9: 
10: @Entity
11: public class Warehouse {
12:     
13:     @Id
14:     private WarehouseId id;
15:     
16:     private String name;
17:     
18:     private String street;
19:     
20:     private String city;
21:     
22:     @Column(name = "postal_code")
23:     private String postalCode;
24:     
25:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
26:     @JoinColumn(name = "warehouse_id")
27:     private List<InventoryLevel> inventoryLevels = new ArrayList<>();
28:     
29:     protected Warehouse() {
30:         // JPA constructor
31:     }
32:     
33:     public Warehouse(String name, AddressLocation addressLocation) {
34:         this.id = new WarehouseId(UUID.randomUUID());
35:         this.name = name;
36:         this.street = addressLocation.getStreet();
37:         this.city = addressLocation.getCity();
38:         this.postalCode = addressLocation.getPostalCode().toString();
39:     }
40:     
41:     public WarehouseId getId() {
42:         return id;
43:     }
44:     
45:     public UUID getIdAsUUID() {
46:         return id.getId();
47:     }
48:     
49:     public String getName() {
50:         return name;
51:     }
52:     
53:     public AddressLocationType getAddressLocation() {
54:         return AddressLocation.of(street, city, PostalCode.of(postalCode));
55:     }
56:     
57:     private InventoryLevel findInventoryLevel(UUID productId) {
58:         return inventoryLevels.stream()
59:             .filter(level -> level.getProductId().equals(productId))
60:             .findFirst()
61:             .orElse(null);
62:     }
63:     
64:     public void addToInventory(UUID productId, int quantity) {
65:         InventoryLevel inventoryLevel = findInventoryLevel(productId);
66:         if (inventoryLevel == null) {
67:             inventoryLevel = new InventoryLevel(productId, quantity);
68:             inventoryLevels.add(inventoryLevel);
69:         } else {
70:             inventoryLevel.addQuantity(quantity);
71:         }
72:     }
73:     
74:     public void removeFromInventory(UUID productId, int quantity) {
75:         InventoryLevel inventoryLevel = findInventoryLevel(productId);
76:         if (inventoryLevel != null) {
77:             inventoryLevel.removeQuantity(quantity);
78:             if (inventoryLevel.getQuantity() == 0) {
79:                 inventoryLevels.remove(inventoryLevel);
80:             }
81:         }
82:     }
83:     
84:     public void setInventoryLevel(UUID productId, int quantity) {
85:         InventoryLevel inventoryLevel = findInventoryLevel(productId);
86:         if (quantity == 0) {
87:             if (inventoryLevel != null) {
88:                 inventoryLevels.remove(inventoryLevel);
89:             }
90:         } else {
91:             if (inventoryLevel == null) {
92:                 inventoryLevel = new InventoryLevel(productId, quantity);
93:                 inventoryLevels.add(inventoryLevel);
94:             } else {
95:                 inventoryLevel.setQuantity(quantity);
96:             }
97:         }
98:     }
99:     
100:     public int getInventoryLevel(UUID productId) {
101:         InventoryLevel inventoryLevel = findInventoryLevel(productId);
102:         return inventoryLevel != null ? inventoryLevel.getQuantity() : 0;
103:     }
104:     
105:     public boolean hasProduct(UUID productId) {
106:         InventoryLevel inventoryLevel = findInventoryLevel(productId);
107:         return inventoryLevel != null && inventoryLevel.getQuantity() > 0;
108:     }
109:     
110:     public Map<UUID, Integer> getAllInventoryLevels() {
111:         Map<UUID, Integer> result = new HashMap<>();
112:         for (InventoryLevel level : inventoryLevels) {
113:             result.put(level.getProductId(), level.getQuantity());
114:         }
115:         return result;
116:     }
117: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\warehouse\domain\WarehouseId.java ---
1: package thkoeln.archilab.ecommerce.solution.warehouse.domain;
2: 
3: import thkoeln.archilab.ecommerce.GenericId;
4: import java.util.UUID;
5: 
6: public class WarehouseId extends GenericId {
7:     
8:     public WarehouseId() {
9:         super();
10:     }
11:     
12:     public WarehouseId(UUID id) {
13:         super(id);
14:     }
15: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\warehouse\domain\WarehouseIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.warehouse.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class WarehouseIdConverter extends GenericIdConverter<WarehouseId> {
8:     
9:     public WarehouseIdConverter() {
10:         super(WarehouseId::new);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\warehouse\domain\WarehouseJpaRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.warehouse.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.stereotype.Repository;
5: 
6: import java.util.UUID;
7: 
8: @Repository
9: public interface WarehouseJpaRepository extends JpaRepository<Warehouse, WarehouseId>, WarehouseRepository {
10: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\solution\warehouse\domain\WarehouseRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.warehouse.domain;
2: 
3: import java.util.Optional;
4: import java.util.UUID;
5: import java.util.List;
6: 
7: public interface WarehouseRepository {
8:     
9:     Warehouse save(Warehouse warehouse);
10:     
11:     Optional<Warehouse> findById(WarehouseId id);
12:     
13:     List<Warehouse> findAll();
14:     
15:     void deleteAll();
16:     
17:     boolean existsById(WarehouseId id);
18: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\AddressLocationType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface AddressLocationType {
6:     /**
7:      * @return the street as a string
8:      */
9:     public String getStreet();
10: 
11:     /**
12:      * @return the city as a string
13:      */
14:     public String getCity();
15: 
16:     /**
17:      * @return the postal code
18:      */
19:     public PostalCodeType getPostalCode();
20: 
21:     /**
22:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
23:      * implementing class to provide a static factory method (simply named "of(...)"),
24:      * which creates an postal code, given as a string.
25:      * We specify this factory method here as a comment, using the Javadoc documentation style.
26:      *
27:      * @param street the street as a string
28:      * @param city the city as a string
29:      * @param postalCode the postal code
30:      * @return the address location object matching the parameters
31:      * @throws ShopException if ...
32:      *      - street is null or empty
33:      *      - city is null or empty
34:      *      - postalCode is null
35:      */
36:      // public static AddressLocationType of( String street, String city, PostalCodeType postalCode );
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\CurrencyType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface CurrencyType {
6:     /**
7:      * @return the quantity of currency
8:      */
9:     public Float getQuantity();
10: 
11: 
12:     /**
13:      * @return the currency unit of the currency
14:      */
15:     public String getCurrencyUnit();
16: 
17: 
18:     /**
19:      * @param otherCurrency
20:      * @return this + otherCurrency, as a new object
21:      * @throws ShopException if ...
22:      *      - otherCurrency is null
23:      *      - otherCurrency.currencyUnit != this.currencyUnit
24:      */
25:     public CurrencyType add( CurrencyType otherCurrency );
26: 
27: 
28:     /**
29:      * @param otherCurrency
30:      * @return this - otherCurrency, as a new object
31:      * @throws ShopException if ...
32:      *      - otherCurrency is null
33:      *      - otherCurrency.currencyUnit != this.currencyUnit
34:      *      - otherCurrency > this
35:      */
36:     public CurrencyType subtract( CurrencyType otherCurrency );
37: 
38: 
39:     /**
40:      * @param factor
41:      * @return this * factor, as a new object
42:      * @throws ShopException if ...
43:      *     - factor < 0
44:      */
45:     public CurrencyType multiplyBy( int factor );
46: 
47:     /**
48:      * @param otherCurrency
49:      * @return true, if this > otherCurrency
50:      * @throws ShopException if ...
51:      *      - otherCurrency is null
52:      *      - otherCurrency.currencyUnit != this.currencyUnit
53:      */
54:     public boolean largerThan( CurrencyType otherCurrency );
55: 
56: 
57:     /**
58:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
59:      * implementing class to provide a static factory method (simply named "of(...)"),
60:      * which creates a currency object from an quantity and a currency unit (as string).
61:      * We specify this factory method here as a comment, using the Javadoc documentation style.
62:      *
63:      * @param quantity the quantity of currency (must be >= 0)
64:      * @param currencyUnit the currency unit of the currency (allowed values: "EUR", "CHF")
65:      * @return a new Currency object with the given quantity and currency unit
66:      * @throws ShopException if ...
67:      *   - quantity is null
68:      *   - quantity < 0
69:      *   - currency unit is null
70:      *   - currency unit is not one of the allowed values
71:      */
72:      // public static CurrencyType of( Float quantity, String currencyUnit );
73: }
74: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\EmailAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface EmailAddressType {
6:     /**
7:      * @return the email address as a string
8:      */
9:     public String toString();
10: 
11: 
12:     /**
13:      * A special kind of "copy constructor": Returns a new email address object with
14:      * the same identifyer (the substring left of the "@" sign) as the current one, but
15:      * with a new domain substring (right of the "@" sign).
16:      * @param domainString - the new domain for the copied email address
17:      * @return the new email address
18:      * @throws ShopException if ...
19:      *     - domainString is null
20:      *     - the new email address would not be valid (see `of(...)` method)
21:      */
22:     public EmailAddressType sameIdentifyerDifferentDomain( String domainString );
23: 
24:     /**
25:      * Another special kind of "copy constructor": Returns a new email address object
26:      * with the same domain (the substring right of the "@" sign) as the current one, but
27:      * with a new identifyer substring (left of the "@" sign).
28:      * @param identifyerString - the new identifyer for the copied email address
29:      * @return the new email address
30:      * @throws ShopException if ...
31:      *     - identifyerString is null
32:      *     - the new email address would not be valid (see `of(...)` method)
33:      */
34:     public EmailAddressType sameDomainDifferentIdentifyer( String identifyerString );
35: 
36: 
37:     /**
38:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
39:      * implementing class to provide a static factory method (simply named "of(...)"),
40:      * which creates an email address, given as a string.
41:      * We specify this factory method here as a comment, using the Javadoc documentation style.
42:      *
43:      * @param emailAddressAsString - the email address as a string.
44:      *      We will use a much simplified validation method to check if the email address is valid:
45:      *      - it must contain exactly one '@' character.
46:      *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
47:      *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
48:      *      - the substrings before and after the '@' may contain one or several '.' as separators
49:      *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
50:      *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
51:      *        (for simplicity we do not allow any other domains)
52:      * @return a new EmailAddressType object matching the given email address
53:      * @throws ShopException if ...
54:      *      - emailAddressAsString is null
55:      *      - emailAddressAsString is not a valid email address (see above)
56:      */
57:      // public static EmailAddressType of( String emailAddressAsString );
58: }
59: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PostalCodeType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnore;
4: import thkoeln.archilab.ecommerce.ShopException;
5: 
6: public interface PostalCodeType {
7:     /**
8:      * @return the postal code as a string
9:      */
10:     public String toString();
11: 
12:     /**
13:      * You will need some idea of "imprecise distance" between two postal codes for properly
14:      * implementing warehouses in your shopping platform. This method calculates such a
15:      * distance. You can decide for yourself what values you return, unless you comply
16:      * with the following rules.
17:      * - The return value is 0 if both postal codes are the same
18:      * - If not:
19:      *      - The distance is > 0 if both postal codes differ in the last digit, like 5673x
20:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
21:      *        So, 56733 and 56734 have the same distance as 56733 and 56739.
22:      *      - The distance grows if more digits (counted from the right side) differ.
23:      *        So, 5abcd and 5rstu have a larger distance than 53bcd and 53stu (if abcd
24:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
25:      *        53876 and 54876 have the same distance as 53876 and 57261.
26:      *      - However, the distance between 5abcd and 6rstu must be smaller than the one
27:      *        between 5abcd and 7rstu, and this distance in turn must be smaller than the
28:      *        one between 5abcd and 9rstu.
29:      *      - This last condition reflects the fact the first digits of a postal code marks a region
30:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
31:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
32:      *        other.
33:      * @param otherPostalCode
34:      * @return the calculated distance
35:      * @throws ShopException if otherPostalCode is null
36:      */
37:     public int distance( PostalCodeType otherPostalCode );
38: 
39: 
40:     /**
41:      * For the currently used way of deciding on the best fitting warehouse for a order,
42:      * we need to know the first digit of the postal code.
43:      */
44:     @JsonIgnore
45:     public Integer getFirstDigitPostalCode();
46: 
47: 
48:     /**
49:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
50:      * implementing class to provide a static factory method (simply named "of(...)"),
51:      * which creates an postal code, given as a string.
52:      * We specify this factory method here as a comment, using the Javadoc documentation style.
53:      *
54:      * @param postalCodeAsString - the postal code as a string.
55:      *      We will use a much simplified validation method to check if the postal code is valid:
56:      *      - It must contain exactly 5 digits.
57:      *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid postal code, but 20001 is valid)
58:      * @return a new postal code object matching the given string
59:      * @throws ShopException if ...
60:      *      - postalCodeAsString is null
61:      *      - postalCodeAsString is not a valid postal code (see above)
62:      */
63:      // public static PostalCodeType of( String postalCodeAsString );
64: }
65: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
8: 
9: import java.io.File;
10: import java.io.IOException;
11: import java.lang.reflect.InvocationTargetException;
12: import java.lang.reflect.Method;
13: import java.lang.reflect.Modifier;
14: import java.net.URL;
15: import java.net.URLDecoder;
16: import java.nio.charset.StandardCharsets;
17: import java.util.Enumeration;
18: 
19: import static org.junit.jupiter.api.Assertions.*;
20: 
21: public class FactoryMethodInvoker {
22: 
23:     public static EmailAddressType instantiateEmailAddress( String emailAddressAsString ) {
24:         Method factoryMethod = null;
25:         try {
26:             Class<?> interfaceClass = Class.forName(
27:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType" );
28:             Class<?> implementingClass = findImplementation( interfaceClass );
29: 
30:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
31:             assertNotNull( factoryMethod );
32:             int modifiers = factoryMethod.getModifiers();
33:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
34:         } catch (Exception e) {
35:             fail( "Failed to find implementation for EmailAddressType", e );
36:         }
37: 
38:         Object instance = null;
39:         try {
40:             instance = factoryMethod.invoke( null, emailAddressAsString );
41:         } catch (Exception e) {
42:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
43:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
44:             fail( "Failed to invoke factory method 'of' for '" + emailAddressAsString + "'", e );
45:         }
46:         assertNotNull( instance );
47:         return (EmailAddressType) instance;
48:     }
49: 
50: 
51:     public static AddressLocationType instantiateAddressLocation(
52:             String street, String city, PostalCodeType postalCode ) {
53:         Method factoryMethod = null;
54:         try {
55:             Class<?> interfaceClass = Class.forName(
56:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType" );
57:             Class<?> implementingClass = findImplementation( interfaceClass );
58: 
59:             factoryMethod = implementingClass.getDeclaredMethod( "of",
60:                     String.class, String.class, PostalCodeType.class );
61:             assertNotNull( factoryMethod );
62:             int modifiers = factoryMethod.getModifiers();
63:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
64:         } catch (Exception e) {
65:             fail( "Failed to find implementation for AddressLocationType", e );
66:         }
67: 
68:         Object instance = null;
69:         try {
70:             instance = factoryMethod.invoke( null, street, city, postalCode );
71:         } catch (Exception e) {
72:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
73:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
74:             fail( "Failed to invoke factory method 'of' for '" +
75:                     street + "', '" + city + "', '" + postalCode + "'", e );
76:         }
77:         assertNotNull( instance );
78:         return (AddressLocationType) instance;
79:     }
80: 
81: 
82:     public static PostalCodeType instantiatePostalCode( String postalCodeAsString ) {
83:         Method factoryMethod = null;
84:         try {
85:             Class<?> interfaceClass = Class.forName(
86:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType" );
87:             Class<?> implementingClass = findImplementation( interfaceClass );
88: 
89:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
90:             assertNotNull( factoryMethod );
91:             int modifiers = factoryMethod.getModifiers();
92:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
93:         } catch (Exception e) {
94:             fail( "Failed to find implementation for PostalCodeType", e );
95:         }
96: 
97:         Object instance = null;
98:         try {
99:             instance = factoryMethod.invoke( null, postalCodeAsString );
100:         } catch (Exception e) {
101:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
102:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
103:             fail( "Failed to invoke factory method 'of' for '" + postalCodeAsString + "'", e );
104:         }
105:         assertNotNull( instance );
106:         return (PostalCodeType) instance;
107:     }
108: 
109: 
110:     public static CurrencyType instantiateCurrency( Float quantity, String currencyUnit ) {
111:         Method factoryMethod = null;
112:         try {
113:             Class<?> interfaceClass = Class.forName(
114:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType" );
115:             Class<?> implementingClass = findImplementation( interfaceClass );
116: 
117:             factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
118:             assertNotNull( factoryMethod );
119:             int modifiers = factoryMethod.getModifiers();
120:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
121:         } catch (Exception e) {
122:             fail( "Failed to find implementation for CurrencyType", e );
123:         }
124: 
125:         Object instance = null;
126:         try {
127:             instance = factoryMethod.invoke( null, quantity, currencyUnit );
128:         } catch (Exception e) {
129:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
130:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
131:             fail( "Failed to invoke factory method 'of' for '" + quantity + "', '" + currencyUnit + "'", e );
132:         }
133:         assertNotNull( instance );
134:         return (CurrencyType) instance;
135:     }
136: 
137: 
138:     private static Class<?> findImplementation( Class<?> interfaceClass ) {
139:         Method factoryMethod = null;
140:         try {
141:             String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
142:             Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
143:             assertNotNull( implementingClass );
144:             return implementingClass;
145:         } catch (Exception e) {
146:             fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
147:             return null; // This line will never be reached, but it's necessary to satisfy the compiler
148:         }
149:     }
150: 
151: 
152:     private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
153:             throws ClassNotFoundException, IOException {
154:         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
155:         String path = packageName.replace( '.', '/' );
156:         Enumeration<URL> resources = classLoader.getResources( path );
157:         int count = 0;
158:         Class<?> result = null;
159:         while (resources.hasMoreElements()) {
160:             URL resource = resources.nextElement();
161:             File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
162:             File[] files = directory.listFiles();
163:             for ( File file : files ) {
164:                 if ( file.getName().endsWith( ".class" ) ) {
165:                     String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
166:                     Class<?> clazz = Class.forName( className );
167:                     if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
168:                         count++;
169:                         result = clazz;
170:                     }
171:                 }
172:             }
173:         }
174:         assertEquals( 1, count, "There should be exactly one implementing class" );
175:         return result;
176:     }
177: }
178: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\InventoryTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.WarehouseTestHelper;
7: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
8: import thkoeln.archilab.ecommerce.usecases.WarehouseUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
12: 
13: import java.util.*;
14: 
15: /**
16:  * This is a test helper class that initializes and registers products (but without inventory)
17:  * in the system, using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class InventoryTestHelperImpl
22:                         implements ProductTestHelper, WarehouseTestHelper {
23:     private ProductCatalogUseCases productCatalogUseCases;
24:     private WarehouseUseCases warehouseUseCases;
25:     private static Random random = new Random();
26: 
27:     private static final String EUR = "EUR";
28:     private static final int PRODUCT_NUMOF = 15;
29:     private static final Object[][] PRODUCT_DATA = new Object[][]{
30:             {null, "0-TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
31:                     1.5f, FactoryMethodInvoker.instantiateCurrency( 5.0f, EUR ),
32:                     FactoryMethodInvoker.instantiateCurrency( 10.0f, EUR ),
33:                     "0"},
34:             {null, "1-EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
35:                     0.3f, FactoryMethodInvoker.instantiateCurrency( 2.5f, EUR ),
36:                     FactoryMethodInvoker.instantiateCurrency( 4.0f, EUR ),
37:                     "0"},
38:             {null, "2-MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
39:                     7.2f, FactoryMethodInvoker.instantiateCurrency( 50.0f, EUR ),
40:                     FactoryMethodInvoker.instantiateCurrency( 80.0f, EUR ),
41:                     "0"},
42:             {null, "3-Gh-25", "Kompakter und leichter Akku für mobile Geräte",
43:                     null, FactoryMethodInvoker.instantiateCurrency( 6.0f, EUR ),
44:                     FactoryMethodInvoker.instantiateCurrency( 8.0f, EUR ),
45:                     "0"},
46:             {null, "4-MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
47:                     null, FactoryMethodInvoker.instantiateCurrency( 0.6f, EUR ),
48:                     FactoryMethodInvoker.instantiateCurrency( 1.0f, EUR ),
49:                     "0"},
50:             {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
51:                     1.0f, FactoryMethodInvoker.instantiateCurrency( 150.0f, EUR ),
52:                     FactoryMethodInvoker.instantiateCurrency( 250.0f, EUR ),
53:                     "0"},
54:             {null, "6-Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
55:                     null, FactoryMethodInvoker.instantiateCurrency( 0.3f, EUR ),
56:                     FactoryMethodInvoker.instantiateCurrency( 0.5f, EUR ),
57:                     "0"},
58:             {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
59:                     6.0f, FactoryMethodInvoker.instantiateCurrency( 80.0f, EUR ),
60:                     FactoryMethodInvoker.instantiateCurrency( 120.0f, EUR ),
61:                     "123"},
62:             {null, "8-JKL-67", "Wasserdichtes Gehäuse",
63:                     3.0f, FactoryMethodInvoker.instantiateCurrency( 1.0f, EUR ),
64:                     FactoryMethodInvoker.instantiateCurrency( 1.2f, EUR ),
65:                     "467"},
66:             {null, "9-MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
67:                     5.5f, FactoryMethodInvoker.instantiateCurrency( 25.0f, EUR ),
68:                     FactoryMethodInvoker.instantiateCurrency( 45.0f, EUR ),
69:                     "578"},
70:             {null, "10-PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
71:                     4.0f, FactoryMethodInvoker.instantiateCurrency( 20.0f, EUR ),
72:                     FactoryMethodInvoker.instantiateCurrency( 35.0f, EUR ),
73:                     "567"},
74:             {null, "11-STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
75:                     null, FactoryMethodInvoker.instantiateCurrency( 200.0f, EUR ),
76:                     FactoryMethodInvoker.instantiateCurrency( 350.0f, EUR ),
77:                     "478"},
78:             {null, "12-VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
79:                     null, FactoryMethodInvoker.instantiateCurrency( 15.0f, EUR ),
80:                     FactoryMethodInvoker.instantiateCurrency( 25.0f, EUR ),
81:                     "5"},
82:             {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
83:                     3.5f, FactoryMethodInvoker.instantiateCurrency( 60.0f, EUR ),
84:                     FactoryMethodInvoker.instantiateCurrency( 100.0f, EUR ),
85:                     "78"},
86:             {null, "14-Nosedive", "Klammer zum Verschließen der Nase beim Tauchen",
87:                     5.0f, FactoryMethodInvoker.instantiateCurrency( 2.0f, EUR ),
88:                     FactoryMethodInvoker.instantiateCurrency( 5.0f, EUR ),
89:                     "457"}
90:     };
91:     
92: 
93:     // These address locations are used for the warehouses. The warehouse name will equal
94:     // the postal code of the site. Their index number will be visible in the house number.
95:     // The warehouses are used as such:
96:     // - warehouse 0 is holds all products 0 - 6, and is used for all tests where multiple
97:     //   deliveries are irrelevant.
98:     // - warehouses 1 - 3 are used for the proximity tests, where you can deliver products 7 to
99:     //   to a user from the closest warehouse.
100:     // - warehouses 4 - 8 are used for the tests where you need to deliver products 8 - 14 in
101:     //   the most cost-efficient way, as multiple deliveries.
102:     // - warehouse 9 is empty.
103:     private final static int WAREHOUSE_NUMOF = 10;
104:     private final static AddressLocationType[] WAREHOUSE_ADDRESS_LOCATION = new AddressLocationType[]{
105:             FactoryMethodInvoker.instantiateAddressLocation(
106:                     "Stapelallee 0", "Potsdam",
107:                     FactoryMethodInvoker.instantiatePostalCode( "14476" ) ),
108:             FactoryMethodInvoker.instantiateAddressLocation(
109:                     "Lagerhausstr. 1", "Viertelstadt",
110:                     FactoryMethodInvoker.instantiatePostalCode( "02345" ) ),
111:             FactoryMethodInvoker.instantiateAddressLocation(
112:                     "Speicherplatz 2", "Viertelstadt",
113:                     FactoryMethodInvoker.instantiatePostalCode( "02313" ) ),
114:             FactoryMethodInvoker.instantiateAddressLocation(
115:                     "Ablageweg 3", "Reichswürgen",
116:                     FactoryMethodInvoker.instantiatePostalCode( "44923" ) ),
117:             FactoryMethodInvoker.instantiateAddressLocation(
118:                     "Paketstellenallee 4", "Düsseldorf",
119:                     FactoryMethodInvoker.instantiatePostalCode( "40588" ) ),
120:             FactoryMethodInvoker.instantiateAddressLocation(
121:                     "Kaputte-Sachen-Straße 5", "Düren",
122:                     FactoryMethodInvoker.instantiatePostalCode( "52355" ) ),
123:             FactoryMethodInvoker.instantiateAddressLocation(
124:                     "Aufbewahrungsweg 6", "Viernheim",
125:                     FactoryMethodInvoker.instantiatePostalCode( "68519" ) ),
126:             FactoryMethodInvoker.instantiateAddressLocation(
127:                     "Paketallee 7", "Baden-Baden",
128:                     FactoryMethodInvoker.instantiatePostalCode( "76532" ) ),
129:             FactoryMethodInvoker.instantiateAddressLocation(
130:                     "Sendenstr. 8", "Senden",
131:                     FactoryMethodInvoker.instantiatePostalCode( "89250" ) ),
132:             FactoryMethodInvoker.instantiateAddressLocation(
133:                     "Schickweg 9", "Hohenroth",
134:                     FactoryMethodInvoker.instantiatePostalCode( "97618" ) )
135:     };
136:     private final static UUID[] WAREHOUSE_ID = new UUID[WAREHOUSE_NUMOF];
137: 
138: 
139:     // These data structures contain the inventory of the products in the warehouses.
140:     // PRODUCT_INVENTORY is a map product name -> Integer[WAREHOUSE_NUMOF].
141:     // The Integer[WAREHOUSE_NUMOF] contains the inventory of the product in each of
142:     // the warehouses.
143:     //
144:     // The following rules apply:
145:     // - product 0 is out of inventory
146:     // - product 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in warehouse 0
147:     // - product 4 / 5 / 6 have a random inventory between 30 and 130, also all ONLY in warehouse 0
148:     //   (these are the products used for tests on how to add and remove inventory)
149:     // - the others have a random inventory between 30 and 130, distributed over several
150:     //   warehouses. Here we follow this convention for simplicity:
151:     //   - Assume that the product is available in <n> warehouses. Then the first <n-1> warehouses
152:     //     in the list (in ascending sequence) contain 3, and all the remaining inventory is in the
153:     //     last warehouse.
154: 
155:     private static final Map<String, Integer[]> PRODUCT_INVENTORY = new HashMap<>();
156: 
157:     static {
158:         // products 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
159:         PRODUCT_INVENTORY.put( (String) PRODUCT_DATA[0][1],
160:                 getInventoryDistribution( 0, (String) PRODUCT_DATA[0][6] ) );
161:         PRODUCT_INVENTORY.put( (String) PRODUCT_DATA[1][1],
162:                 getInventoryDistribution( 10, (String) PRODUCT_DATA[1][6] ) );
163:         PRODUCT_INVENTORY.put( (String) PRODUCT_DATA[2][1],
164:                 getInventoryDistribution( 20, (String) PRODUCT_DATA[2][6] ) );
165:         PRODUCT_INVENTORY.put( (String) PRODUCT_DATA[3][1],
166:                 getInventoryDistribution( 30, (String) PRODUCT_DATA[3][6] ) );
167: 
168:         // The other products have a random inventory between 30 and 130,
169:         for ( int i = 4; i < PRODUCT_NUMOF; i++ ) {
170:             Integer totalNumber = random.nextInt( 100 ) + 30;
171:             Integer[] inventoryInWarehouses =
172:                     getInventoryDistribution( totalNumber, (String) PRODUCT_DATA[i][6] );
173:             PRODUCT_INVENTORY.put( (String) PRODUCT_DATA[i][1], inventoryInWarehouses );
174:         }
175:     }
176: 
177:     /**
178:      * This method creates a random inventory distribution for the given product.
179:      *
180:      * @param totalQuantity - the total number of products in the warehouses
181:      * @param zeroToNine  - a string with numbers between 0 and 9, representing the warehouses
182:      * @return an Integer array with the inventory distribution for the product, according to
183:      * the rules described above.
184:      */
185:     private static Integer[] getInventoryDistribution( Integer totalQuantity, String zeroToNine ) {
186:         Integer[] inventoryInWarehouses = new Integer[WAREHOUSE_NUMOF];
187:         for ( int i = 0; i < WAREHOUSE_NUMOF; i++ ) inventoryInWarehouses[i] = 0;
188:         TreeSet<Integer> warehouseIndices = getWarehouseIndices( zeroToNine );
189:         int numOfIndices = warehouseIndices.size();
190:         int currentIndexNumber = 0;
191:         int currentQuantity = totalQuantity;
192:         for ( Integer warehouseIndex : warehouseIndices ) {
193:             currentIndexNumber++;
194:             if ( currentIndexNumber < numOfIndices ) {
195:                 inventoryInWarehouses[warehouseIndex] = 3;
196:                 currentQuantity -= 3;
197:             } else {
198:                 inventoryInWarehouses[warehouseIndex] = currentQuantity;
199:             }
200:         }
201:         return inventoryInWarehouses;
202:     }
203: 
204:     private static TreeSet<Integer> getWarehouseIndices( String zeroToNine ) {
205:         TreeSet<Integer> warehouseIndices = new TreeSet<>();
206:         for ( int i = 0; i < zeroToNine.length(); i++ ) {
207:             warehouseIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
208:         }
209:         return warehouseIndices;
210:     }
211: 
212: 
213:     @Autowired
214:     public InventoryTestHelperImpl( ProductCatalogUseCases productCatalogUseCases,
215:                                          WarehouseUseCases warehouseUseCases ) {
216:         this.productCatalogUseCases = productCatalogUseCases;
217:         this.warehouseUseCases = warehouseUseCases;
218:     }
219: 
220: 
221:     @Override
222:     public void addAllProducts() {
223:         int i = 0;
224:         for ( Object[] productData : PRODUCT_DATA ) {
225:             UUID newId = productCatalogUseCases.addProductToCatalog(
226:                     (String) productData[1], (String) productData[2],
227:                     (Float) productData[3], (CurrencyType) productData[4],
228:                     (CurrencyType) productData[5] );
229:             // The first element of the product data is the id, which was initialized with null before, but can now be set
230:             PRODUCT_DATA[i][0] = newId;
231:             i++;
232:         }
233:     }
234: 
235: 
236:     @Override
237:     public int numberOfProducts() {
238:         return PRODUCT_NUMOF;
239:     }
240: 
241: 
242:     @Override
243:     public UUID getProductId( int index ) {
244:         if ( index < 0 || index >= PRODUCT_NUMOF ) {
245:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
246:         }
247:         return (UUID) PRODUCT_DATA[index][0];
248:     }
249: 
250: 
251:     @Override
252:     public CurrencyType getBuyingPrice( int index ) {
253:         if ( index < 0 || index >= PRODUCT_NUMOF ) {
254:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
255:         }
256:         return (CurrencyType) PRODUCT_DATA[index][4];
257:     }
258: 
259: 
260:     @Override
261:     public CurrencyType getSalesPrice( int index ) {
262:         if ( index < 0 || index >= PRODUCT_NUMOF ) {
263:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
264:         }
265:         return (CurrencyType) PRODUCT_DATA[index][5];
266:     }
267: 
268: 
269:     @Override
270:     public void addAllWarehouses( boolean withInventory ) {
271:         for ( int i = 0; i < WAREHOUSE_NUMOF; i++ ) {
272:             WAREHOUSE_ID[i] = warehouseUseCases.addNewWarehouse(
273:                     WAREHOUSE_ADDRESS_LOCATION[i].getStreet(),
274:                     WAREHOUSE_ADDRESS_LOCATION[i] );
275:         }
276:         if ( withInventory ) {
277:             addAllInventory();
278:         }
279:     }
280: 
281: 
282:     private void addAllInventory() {
283:         for ( Object[] productData : PRODUCT_DATA ) {
284:             Integer[] inventoryInWarehouses =
285:                     PRODUCT_INVENTORY.get( productData[1] );
286:             for ( int iWarehouse = 0; iWarehouse < WAREHOUSE_NUMOF; iWarehouse++ ) {
287:                 if ( inventoryInWarehouses[iWarehouse] > 0 )
288:                     warehouseUseCases.addToInventory(
289:                             WAREHOUSE_ID[iWarehouse], (UUID) productData[0],
290:                             inventoryInWarehouses[iWarehouse] );
291:             }
292:         }
293:     }
294: 
295: 
296:     @Override
297:     public int numberOfWarehouses() {
298:         return WAREHOUSE_NUMOF;
299:     }
300: 
301: 
302:     @Override
303:     public UUID getWarehouseId( int index ) {
304:         if ( index < 0 || index >= WAREHOUSE_NUMOF ) {
305:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
306:         }
307:         return WAREHOUSE_ID[index];
308:     }
309: 
310: 
311:     @Override
312:     public Integer getWarehouseInventory( int warehouseIndex, int productIndex ) {
313:         if ( warehouseIndex < 0 || warehouseIndex >= WAREHOUSE_NUMOF ) {
314:             throw new IndexOutOfBoundsException( "Index out of bounds: " + warehouseIndex );
315:         }
316:         if ( productIndex < 0 || productIndex >= PRODUCT_NUMOF ) {
317:             throw new IndexOutOfBoundsException( "Index out of bounds: " + productIndex );
318:         }
319:         String productName = (String) PRODUCT_DATA[productIndex][1];
320:         Integer[] inventoryInWarehouses = PRODUCT_INVENTORY.get( productName );
321:         Integer foundInventory = inventoryInWarehouses[warehouseIndex];
322:         return foundInventory == null ? 0 : foundInventory;
323:     }
324: 
325: 
326:     @Override
327:     public int findWarehouseIndex( UUID warehouseId ) {
328:         for ( int i = 0; i < WAREHOUSE_NUMOF; i++ ) {
329:             if ( WAREHOUSE_ID[i].equals( warehouseId ) ) {
330:                 return i;
331:             }
332:         }
333:         throw new IllegalArgumentException( "No test warehouse with UUID id " + warehouseId );
334:     }
335: 
336: 
337:     @Override
338:     public int findProductIndex( UUID productId ) {
339:         for ( int iProductData = 0; iProductData < WAREHOUSE_NUMOF; iProductData++ ) {
340:             Object[] productData = PRODUCT_DATA[iProductData];
341:             if ( productData[0].equals( productId ) ) {
342:                 return iProductData;
343:             }
344:         }
345:         throw new IllegalArgumentException( "No test product with UUID id " + productId );
346:     }
347: }
348: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\UserTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
7: import thkoeln.archilab.ecommerce.usecases.UserType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.MockUser;
12: 
13: import static org.junit.jupiter.api.Assertions.assertThrows;
14: 
15: /**
16:  * This is a test helper class that initializes and registers users in the system,
17:  * using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class UserTestHelperImpl implements UserTestHelper {
22: 
23:     private UserRegistrationUseCases userRegistrationUseCases;
24: 
25:     @Autowired
26:     public UserTestHelperImpl( UserRegistrationUseCases userRegistrationUseCases ) {
27:         this.userRegistrationUseCases = userRegistrationUseCases;
28:     }
29: 
30:     private final static String[] USER_NAME = new String[]{
31:             "Max Mueller",
32:             "Sophie Schmitz",
33:             "Irene Mihalic",
34:             "Emilia Fischer",
35:             "Filiz Polat",
36:             "Lina Wagner",
37:             "Leon Becker",
38:             "Agnieszka Kalterer",
39:             "Felix Bauer",
40:             "Lara Schulz"
41:     };
42: 
43:     private final static EmailAddressType[] USER_EMAIL = new EmailAddressType[]{
44:             FactoryMethodInvoker.instantiateEmailAddress( "99Z@example.com" ),
45:             FactoryMethodInvoker.instantiateEmailAddress( "a@4.com" ),
46:             FactoryMethodInvoker.instantiateEmailAddress( "irene@wearefreedomnow.com" ),
47:             FactoryMethodInvoker.instantiateEmailAddress( "emilia.fischer@example.com" ),
48:             FactoryMethodInvoker.instantiateEmailAddress( "j877d3@example.this.com" ),
49:             FactoryMethodInvoker.instantiateEmailAddress( "lina.marie.wagner@example.com" ),
50:             FactoryMethodInvoker.instantiateEmailAddress( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
51:             FactoryMethodInvoker.instantiateEmailAddress( "agna@here.ch" ),
52:             FactoryMethodInvoker.instantiateEmailAddress( "felix.bauer@example.org" ),
53:             FactoryMethodInvoker.instantiateEmailAddress( "lara.schulz@example.at" )
54:     };
55: 
56:     // The following array is used to create a list of addressLocations for the users.
57:     // The indices are coded into the house number.
58:     // - Persons 0 - 5 are used for proximity tests with one warehouse.
59:     private final static AddressLocationType[] USER_ADDRESS = new AddressLocationType[]{
60:             FactoryMethodInvoker.instantiateAddressLocation(
61:                     "Marktstraße 0", "Viertelstadt",
62:                     FactoryMethodInvoker.instantiatePostalCode( "02314" ) ),
63:             FactoryMethodInvoker.instantiateAddressLocation(
64:                     "Hauptstraße 1", "Viertelstadt",
65:                     FactoryMethodInvoker.instantiatePostalCode( "02368" ) ),
66:             FactoryMethodInvoker.instantiateAddressLocation(
67:                     "Kirchplatz 2", "Niemandstown",
68:                     FactoryMethodInvoker.instantiatePostalCode( "12345" ) ),
69:             FactoryMethodInvoker.instantiateAddressLocation(
70:                     "Schulstraße 3", "Geisterhausen",
71:                     FactoryMethodInvoker.instantiatePostalCode( "31463" ) ),
72:             FactoryMethodInvoker.instantiateAddressLocation(
73:                     "Rosenweg 4", "Kuhhausen",
74:                     FactoryMethodInvoker.instantiatePostalCode( "72162" ) ),
75:             FactoryMethodInvoker.instantiateAddressLocation(
76:                     "Wiesenstraße 5", "Waldschenkensdorf",
77:                     FactoryMethodInvoker.instantiatePostalCode( "82195" ) ),
78:             FactoryMethodInvoker.instantiateAddressLocation(
79:                     "Muehlenweg 6", "Koeln",
80:                     FactoryMethodInvoker.instantiatePostalCode( "50667" ) ),
81:             FactoryMethodInvoker.instantiateAddressLocation(
82:                     "Goethestraße 7", "Frankfurt am Main",
83:                     FactoryMethodInvoker.instantiatePostalCode( "60311" ) ),
84:             FactoryMethodInvoker.instantiateAddressLocation(
85:                     "Dorfstraße 8", "Stuttgart",
86:                     FactoryMethodInvoker.instantiatePostalCode( "70173" ) ),
87:             FactoryMethodInvoker.instantiateAddressLocation(
88:                     "Bahnhofstraße 9", "Muenchen",
89:                     FactoryMethodInvoker.instantiatePostalCode( "80331" ) )
90:     };
91: 
92:     private final static UserType[] mockUsers;
93: 
94:     static {
95:         mockUsers = new UserType[USER_NAME.length];
96:         for ( int i = 0; i < USER_NAME.length; i++ ) {
97:             mockUsers[i] = new MockUser(
98:                     USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
99:         }
100:     }
101: 
102: 
103:     @Override
104:     public void registerAllUsers() {
105:         for ( int i = 0; i < USER_NAME.length; i++ ) {
106:             registerUser( USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
107:         }
108:     }
109: 
110: 
111:     private void registerUser( String name, EmailAddressType emailAddress, AddressLocationType addressLocation ) {
112:         userRegistrationUseCases.register( name, emailAddress, addressLocation );
113:     }
114: 
115: 
116:     @Override
117:     public int getNumberOfUsers() {
118:         return USER_NAME.length;
119:     }
120: 
121: 
122:     @Override
123:     public String getUserName( int index ) {
124:         if ( index < 0 || index >= USER_NAME.length ) {
125:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
126:         }
127:         return USER_NAME[index];
128:     }
129: 
130: 
131:     @Override
132:     public EmailAddressType getUserEmailAddress( int index ) {
133:         if ( index < 0 || index >= USER_NAME.length ) {
134:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
135:         }
136:         return USER_EMAIL[index];
137:     }
138: 
139: 
140:     @Override
141:     public AddressLocationType getUserAddressLocation( int index ) {
142:         if ( index < 0 || index >= USER_NAME.length ) {
143:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
144:         }
145:         return USER_ADDRESS[index];
146:     }
147: 
148: 
149:     @Override
150:     public UserType getUser( int index ) {
151:         if ( index < 0 || index >= USER_NAME.length ) {
152:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
153:         }
154:         return mockUsers[index];
155:     }
156: }
157: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockUser.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.Setter;
4: import thkoeln.archilab.ecommerce.usecases.UserType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;
6: 
7: 
8: import java.util.Objects;
9: 
10: @Setter
11: public class MockUser implements UserType {
12:     private String name;
13:     private EmailAddressType emailAddressType;
14:     private AddressLocationType addressLocationType;
15: 
16: 
17:     public MockUser( String name, EmailAddressType emailAddressType, AddressLocationType addressLocationType) {
18:         this.name = name;
19:         this.emailAddressType = emailAddressType;
20:         this.addressLocationType = addressLocationType;
21:     }
22: 
23:     @Override
24:     public String getName() {
25:         return name;
26:     }
27: 
28:     @Override
29:     public EmailAddressType getEmailAddress() {
30:         return emailAddressType;
31:     }
32: 
33:     @Override
34:     public AddressLocationType getAddressLocation() {
35:         return addressLocationType;
36:     }
37: 
38:     @Override
39:     public boolean equals( Object o ) {
40:         if ( this == o ) return true;
41:         if ( !( o instanceof MockUser ) ) return false;
42:         MockUser that = (MockUser) o;
43:         return Objects.equals( getName(), that.getName() ) &&
44:                 Objects.equals( emailAddressType, that.emailAddressType ) &&
45:                 Objects.equals( addressLocationType, that.addressLocationType );
46:     }
47: 
48:     @Override
49:     public int hashCode() {
50:         return Objects.hash( getName(), emailAddressType, addressLocationType );
51:     }
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ProductTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
4: 
5: import java.util.UUID;
6: 
7: public interface ProductTestHelper {
8:     /**
9:      * Adds all test products to the database.
10:      * If you use the debugger and want to identify _which_ test product you currently look at:
11:      * The indices are coded into the first number in the name string of the product, like e.g.
12:      * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
13:      */
14:     void addAllProducts();
15: 
16: 
17:     /**
18:      * @return the number of test products in the database
19:      */
20:     int numberOfProducts();
21: 
22: 
23:     /**
24:      * @param index
25:      * @return the id of the test product at the given index
26:      */
27:     UUID getProductId( int index );
28: 
29: 
30:     /**
31:      * @param productId - the id of the product in the test data
32:      * @return the index of the test product with that id
33:      */
34:     int findProductIndex( UUID productId );
35: 
36: 
37:     /**
38:      * @param index
39:      * @return the buying price of test product at the given index
40:      */
41:     CurrencyType getBuyingPrice( int index );
42: 
43: 
44:     /**
45:      * @param index
46:      * @return the sales price of test product at the given index
47:      */
48:     CurrencyType getSalesPrice( int index );
49: }
50: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.usecases.*;
6: 
7: /**
8:  * Removes everything :-)
9:  */
10: @Service
11: public class Purgatory {
12:     @Autowired
13:     private UserRegistrationUseCases userRegistrationUseCases;
14:     @Autowired
15:     private ShoppingCartUseCases shoppingCartUseCases;
16:     @Autowired
17:     private OrderUseCases orderUseCases;
18:     @Autowired
19:     private ProductCatalogUseCases productCatalogUseCases;
20:     @Autowired
21:     private WarehouseUseCases warehouseUseCases;
22: 
23:     public void deleteEverything() {
24:         orderUseCases.deleteAllOrders();
25:         shoppingCartUseCases.emptyAllShoppingCarts();
26:         warehouseUseCases.deleteAllWarehouses();
27:         userRegistrationUseCases.deleteAllUsers();
28:         productCatalogUseCases.deleteProductCatalog();
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.context.ApplicationListener;
6: import org.springframework.context.annotation.Profile;
7: import org.springframework.context.event.ContextRefreshedEvent;
8: import org.springframework.stereotype.Component;
9: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.WarehouseUseCases;
12: 
13: @Component
14: @Slf4j
15: @Profile("!test")
16: @SuppressWarnings("PMD")
17: public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
18:     private Purgatory purgatory;
19:     private UserTestHelper userTestHelper;
20:     private ProductTestHelper productTestHelper;
21:     private WarehouseTestHelper warehouseTestHelper;
22: 
23: 
24:     @Autowired
25:     public StartupListener( Purgatory purgatory,
26:                             UserTestHelper userTestHelper,
27:                             ProductTestHelper productTestHelper,
28:                             WarehouseTestHelper warehouseTestHelper ) {
29:         this.purgatory = purgatory;
30:         this.userTestHelper = userTestHelper;
31:         this.productTestHelper = productTestHelper;
32:         this.warehouseTestHelper = warehouseTestHelper;
33:     }
34: 
35:     @Override
36:     public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
37:         log.info( "StartupListener initializing master data ..." );
38:         purgatory.deleteEverything();
39:         userTestHelper.registerAllUsers();
40:         productTestHelper.addAllProducts();
41:         warehouseTestHelper.addAllWarehouses( true );
42:     }
43: }
44: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\UserTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: 
4: import thkoeln.archilab.ecommerce.usecases.UserType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
7: 
8: /**
9:  * This is a test helper interface provides access to predefined test data for
10:  * users.
11:  */
12: public interface UserTestHelper {
13:     /**
14:      * This method calls the use case implementation to register all users specified in the
15:      * test data set.
16:      * If you use the debugger and want to identify _which_ test user you currently look at:
17:      * The indices are coded into the house number (in the user's address location) and in the first
18:      * cipher of the postal code. This is the list of users:
19:      *
20:      * +-------+-------------------+--------+---------------------
21:      * | Index | Name              | PLZ    | EmailAddress
22:      * +-------+-------------------+--------+---------------------
23:      * | 0     | Max Mueller       | 02314  | 99Z@example.com
24:      * | 1     | Sophie Schmitz    | 02368  | a@4.com
25:      * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
26:      * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
27:      * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
28:      * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
29:      * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
30:      * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
31:      * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
32:      * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
33:      * +-------+-------------------+--------+---------------------
34:      */
35:     void registerAllUsers();
36: 
37: 
38:     /**
39:      * @return the number of test users in the test data set.
40:      */
41:     int getNumberOfUsers();
42: 
43: 
44:     /**
45:      * @param index the index of the user in the test data set.
46:      * @return the name of the test user with the given index.
47:      */
48:     String getUserName( int index );
49: 
50: 
51:     /**
52:      * @param index the index of the user in the test data set.
53:      * @return the email address of the test user with the given index.
54:      */
55:     EmailAddressType getUserEmailAddress( int index );
56: 
57: 
58:     /**
59:      * @param index the index of the user in the test data set.
60:      * @return the address location of the test user with the given index.
61:      */
62:     AddressLocationType getUserAddressLocation( int index );
63: 
64: 
65:     /**
66:      * @param index the index of the user in the test data set.
67:      * @return the test user with the given index.
68:      */
69:     UserType getUser( int index );
70: 
71: }
72: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\WarehouseTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import java.util.UUID;
4: 
5: public interface WarehouseTestHelper {
6:     /**
7:      * Adds the test warehouses to the system.
8:      * If you want to use the warehouses, or want to know which index the warehouse has that you see
9:      * in the debugger, the following rules apply:
10:      * - The warehouse name will equal the street name of the address location of the warehouse.
11:      * - The index number is visible in the house number. Example: warehouse 3 is located at
12:      *   "Ablageweg 3", and that is also its name.
13:      *
14:      *  The warehouses are used in the tests as follows:
15:      *  - warehouse 0 holds all products 0 - 6, and is used for all tests where it is not relevant
16:      *    to split one shopping cart into several orders.
17:      *  - warehouses 1 - 3 are used for the proximity tests, where you can deliver product 7 to
18:      *    to a user from the closest warehouse.
19:      *  - warehouses 4 - 8 are used for the tests where you need to deliver products 8 - 14 in
20:      *    the most cost-efficient way, as multiple deliveries.
21:      *  - warehouse 9 is empty.
22:      *
23:      *  If withInventory is true, then the warehouses are filled with products. This happens
24:      *  according to the following rules:
25:      *  - products 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
26:      *    ONLY available in warehouse 0. (This means that product 0 out of inventory everywhere.)
27:      *  - products 4, 5, 6 have a random inventory between 30 and 130, also all ONLY in warehouse 0
28:           (these are the products used for tests on how to add and remove inventory)
29:      *  - product 7 has a random inventory between 30 and 130, distributed over
30:      *    warehouses 1, 2, and 3. You can use this to test if the appropriate warehouse is found
31:      *    for a shopping cart with only product 7 in it, but with different quantities (<= 3, or > 3).
32:      *  - The other products (8 - 14) have also a random inventory between 30 and 130, all distributed
33:      *    over several warehouses. The distribution is done as follows:
34:      *    Assume that the product is available in <n> warehouses. Then the first <n-1> warehouses
35:      *    in the list (in ascending sequence) contain 3, and all the remaining inventory is in the
36:      *    last warehouse.
37:      *
38:      *    This is how the inventory of products could be distributed
39:      *    (Wx = warehouse x with its postal code, Px = product x,
40:      *    numbers marked with (*) are random large numbers):
41:      *
42:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
43:      *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
44:      *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
45:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
46:      *    | P0   |      |     |     |      |     |      |     |       |      |     |
47:      *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
48:      *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
49:      *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
50:      *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
51:      *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
52:      *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
53:      *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
54:      *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
55:      *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
56:      *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
57:      *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
58:      *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
59:      *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
60:      *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
61:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
62:      *
63:      * @param withInventory if true, the inventory of the products is added to the warehouse. Otherwise, the
64:      *                           the inventory is not added and the warehouse is empty.
65:      */
66:     public void addAllWarehouses( boolean withInventory );
67: 
68: 
69:     /**
70:      * @return the number of test warehouses in the database
71:      */
72:     int numberOfWarehouses();
73: 
74: 
75:     /**
76:      * @param index
77:      * @return the id of the test warehouse at the given index
78:      */
79:     UUID getWarehouseId( int index );
80: 
81: 
82:     /**
83:      * @param warehouseId - the id of the warehouse in the test data
84:      * @return the index of the test warehouse with that id
85:      */
86:     int findWarehouseIndex( UUID warehouseId );
87: 
88: 
89:     /**
90:      * @param productIndex - the index of the product in the test data
91:      * @param warehouseIndex - the index of the warehouse in the test data
92:      * @return the number of products (inventory) available in the warehouse at the given index
93:      */
94:     Integer getWarehouseInventory( int warehouseIndex, int productIndex );
95: 
96: }
97: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\OrderUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: package thkoeln.archilab.ecommerce.usecases;
5: 
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
9: 
10: import java.util.Map;
11: import java.util.UUID;
12: 
13: /**
14:  * This interface contains methods needed in the context of the order history of a user.
15:  */
16: public interface OrderUseCases {
17: 
18:     /**
19:      * Returns a map showing which products have been ordered by a user and how many of each product
20:      *
21:      * @param userEmailAddress
22:      * @return the order history of the user (map is empty if the user has not ordered anything yet)
23:      * @throws ShopException if
24:      *      - userEmailAddress is null
25:      *      - the user with the given email address does not exist
26:      */
27:     public Map<UUID, Integer> getOrderHistory( EmailAddressType userEmailAddress );
28: 
29: 
30: 
31:     /**
32:      * @return the number of products in a given order. If the product is not a part of the order, the method
33:      *         returns 0. No exception is thrown.
34:      * @param orderId - the id of the order to be checked
35:      * @param productId - the id of the product for which we want to know the quantity
36:      * @throws ShopException if
37:      *     - orderId is null, or doesn't exist in the system
38:      *     - productId is null, or doesn't exist in the system
39:      */
40:     public Integer getOrderQuantiOfProduct( UUID orderId, UUID productId );
41: 
42: 
43:     /**
44:      * @return the id of the warehouse that is responsible for the given order
45:      * @param orderId - the id of the order to be checked
46:      * @throws ShopException if
47:      *      - orderId is null, or doesn't exist in the system
48:      */
49:     public UUID getWarehouseIdForOrder( UUID orderId );
50: 
51: 
52:     /**
53:      * Deletes all orders in the system
54:      */
55:     public void deleteAllOrders();
56: }
57: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\ProductCatalogUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
9: 
10: import java.util.UUID;
11: 
12: 
13: /**
14:  * This interface contains methods needed in the context of use cases concerning the product catalog.
15:  * The interface is probably incomplete, and will grow over time ...
16:  */
17: 
18: public interface ProductCatalogUseCases {
19:     /**
20:      * Adds a new product to the shop catalog
21:      * @param name
22:      * @param descriptionOf
23:      * @param size
24:      * @param buyingPrice
25:      * @param salesPrice
26:      * @return the id of the new product
27:      * @throws ShopException if ...
28:      *      - the product id already exists,
29:      *      - name or description are null or empty,
30:      *      - the size is <= 0 (but can be null!),
31:      *      - the buying price is null or <= 0,
32:      *      - the buyingPrice is null,
33:      *      - the sales price is null,
34:      *      - the sales price is lower than the buyingPrice
35:      */
36:     public UUID addProductToCatalog( String name, String descriptionOf, Float size,
37:                                            CurrencyType buyingPrice, CurrencyType salesPrice );
38: 
39: 
40:     /**
41:      * Removes a product from the shop catalog
42:      * @param productId
43:      * @throws ShopException if
44:      *      - productId is null
45:      *      - the product id does not exist
46:      *      - the product is still in inventory
47:      *      - the product is still in a shopping cart, or referenced by a completed order
48:      */
49:     public void removeProductFromCatalog( UUID productId );
50: 
51: 
52:     /**
53:      * Get the sales price of a given product
54:      * @param productId
55:      * @return the sales price
56:      * @throws ShopException if ...
57:      *      - productId is null,
58:      *      - the product with that id does not exist
59:      */
60:     public CurrencyType getSalesPrice( UUID productId );
61: 
62: 
63:     /**
64:      * Clears the product catalog, i.e. removes all products from the catalog, including all the inventory,
65:      * all the reservations and all the orders.
66:      */
67:     public void deleteProductCatalog();
68: 
69: }
70: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingCartUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
10: 
11: import java.util.Map;
12: import java.util.Set;
13: import java.util.UUID;
14: 
15: /**
16:  * This interface contains methods needed in the context of use cases handling the shopping cart.
17:  * The interface is probably incomplete, and will grow over time ...
18:  */
19: public interface ShoppingCartUseCases {
20:     /**
21:      * Adds a product to the cart of a user
22:      *
23:      * @param userEmailAddress
24:      * @param productId
25:      * @param quantiOf
26:      * @throws ShopException if ...
27:      *          - userEmailAddress is null,
28:      *          - the user with the given email address does not exist,
29:      *          - productId is null,
30:      *          - the product with productId does not exist
31:      *          - the Quantity is negative,
32:      */
33:     public void addProductToShoppingCart( EmailAddressType userEmailAddress,
34:                                                  UUID productId, int quantiOf );
35: 
36: 
37:     /**
38:      * Removes a product from the cart of a user
39:      *
40:      * @param userEmailAddress
41:      * @param productId
42:      * @param quantiOf
43:      * @throws ShopException if ...
44:      *          - userEmailAddress is null,
45:      *          - the user with the given email address does not exist,
46:      *          - productId is null,
47:      *          - the product with productId does not exist
48:      *          - the Quantity is negative
49:      *          - the product is not in the shopping cart in the requested Quantity
50:      */
51:     public void removeProductFromShoppingCart( EmailAddressType userEmailAddress,
52:                                                       UUID productId, int quantiOf );
53: 
54: 
55:     /**
56:      * Returns a map showing which products are in the cart of a user and how many of each product
57:      *
58:      * @param userEmailAddress
59:      * @return the cart of the user (map is empty if the cart is empty)
60:      * @throws ShopException if
61:      *          - userEmailAddress is null,
62:      *          - the user with the given email address does not exist
63:      */
64:     public Map<UUID, Integer> getShoppingCartAsMap( EmailAddressType userEmailAddress );
65: 
66: 
67:     /**
68:      * Returns the current value of all products in the cart of a user
69:      *
70:      * @param userEmailAddress
71:      * @return the cart of the user
72:      * @throws ShopException if
73:      *          - userEmailAddress is null,
74:      *          - the user with the given email address does not exist
75:      */
76:     public CurrencyType getShoppingCartAsCurrencyValue( EmailAddressType userEmailAddress );
77: 
78: 
79: 
80: 
81:     /**
82:      * Checks out the cart of a user
83:      *
84:      * @param userEmailAddress
85:      * @return A set of ids belonging to orders that were created during the checkout. If the shopping cart can
86:      *         only be served from more than one warehouse, each delivery from a warehouse gets a
87:      *         dedicated order. I.e. if there is just one delivery, then the set will contain just one order id.
88:      *         If there are multiple deliveries, the set will contain multiple order ids.
89:      * @throws ShopException if
90:      *      - userEmailAddress is null or empty
91:      *      - the user with the given email address does not exist, or if the cart is empty
92:      * @throws
93:      *      - ShopException if userEmailAddress is null
94:      *      - InsufficientInventoryException if there is not enough inventory level for to serve the order
95:      *        for all products in the shopping cart
96:      */
97:     public Set<UUID> checkout( EmailAddressType userEmailAddress );
98: 
99: 
100:     /**
101:      * Empties all shopping carts in the system
102:      */
103:     public void emptyAllShoppingCarts();
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\UserRegistrationUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
10: 
11: /**
12:  * This interface contains methods needed in the context of use cases concerning the registration of a user.
13:  * The interface is probably incomplete, and will grow over time ...
14:  */
15: public interface UserRegistrationUseCases {
16:     /**
17:      * Registers a new user
18:      *
19:      * @param name
20:      * @param emailAddress
21:      * @param addressLocation
22:      * @throws ShopException if ...
23:      *      - the user with the given email address already exists
24:      *      - addressLocation is null
25:      */
26:     public void register( String name, EmailAddressType emailAddress, AddressLocationType addressLocation );
27: 
28: 
29:     /**
30:      * Changes the address of a user
31:      *
32:      * @param userEmailAddress
33:      * @param userEmailAddress
34:      * @param addressLocation
35:      * @throws ShopException if ...
36:      *      - the user with the given email address does not exist,
37:      *      - addressLocation is null
38:      */
39:     public void changeAddress( EmailAddressType userEmailAddress,
40:                                AddressLocationType addressLocation );
41: 
42: 
43:     /**
44:      * Returns the data of a user as an array of strings (name, emailAddress, street, city, postalCode)
45:      * @param userEmailAddress
46:      * @return the user data
47:      * @throws ShopException the user with the given email address does not exist,
48:      */
49:     public UserType getUserData( EmailAddressType userEmailAddress );
50: 
51: 
52: 
53:     /**
54:      * Clears all users, including all orders and shopping carts
55:      */
56:     public void deleteAllUsers();
57: }
58: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\UserType.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
5: 
6: /**
7:  * This interface expresses the essence of a shop user
8:  */
9: public interface UserType {
10:     String getName();
11:     EmailAddressType getEmailAddress();
12:     AddressLocationType getAddressLocation();
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\main\java\thkoeln\archilab\ecommerce\usecases\WarehouseUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
9: 
10: import java.util.UUID;
11: 
12: /**
13:  * This interface contains methods needed in the context of handling the shop inventory,
14:  * i.e. managing warehouses, and adding / removing products in the warehouse.
15:  */
16: public interface WarehouseUseCases {
17:     /**
18:      *
19:      * @param name
20:      * @param addressLocation
21:      * @return the id of the new warehouse
22:      * @throws ShopException if ...
23:      *      - name is null or empty
24:      *      - addressLocation is null
25:      */
26:     public UUID addNewWarehouse( String name, AddressLocationType addressLocation );
27: 
28: 
29:     /**
30:      * Deletes all warehouses from the shop. Intended for testing purposes.
31:      */
32:     public void deleteAllWarehouses();
33: 
34: 
35:     /**
36:      * Adds a certain Quantity of a given product to the inventory
37:      * @param warehouseId
38:      * @param productId
39:      * @param addedQuantiOf
40:      * @throws ShopException if ...
41:      *      - warehouseId is null
42:      *      - the warehouse with that id does not exist
43:      *      - productId is null
44:      *      - the product with that id does not exist
45:      *      - addedQuantiOf < 0
46:      */
47:     public void addToInventory( UUID warehouseId, UUID productId, int addedQuantiOf );
48: 
49: 
50:     /**
51:      * Removes a certain Quantity of a given product from the inventory.
52:      * @param warehouseId
53:      * @param productId
54:      * @param removedQuantiOf
55:      * @throws ShopException if ...
56:      *      - warehouseId is null
57:      *      - the warehouse with that id does not exist
58:      *      - productId is null
59:      *      - the product with that id does not exist
60:      *      - removedQuantiOf < 0
61:      */
62:     public void removeFromInventory( UUID warehouseId, UUID productId, int removedQuantiOf );
63: 
64: 
65:     /**
66:      * Changes the total Quantity of a given product in the inventory.
67:      * @param warehouseId
68:      * @param productId
69:      * @param newTotalQuantiOf
70:      * @throws ShopException if ...
71:      *      - warehouseId is null
72:      *      - the warehouse with that id does not exist
73:      *      - productId is null
74:      *      - the product with that id does not exist
75:      *      - newTotalQuantiOf < 0
76:      */
77:     public void changeInventoryTo( UUID warehouseId, UUID productId, int newTotalQuantiOf );
78: 
79: 
80:     /**
81:      * Get the current inventory of a given product in one specific warehouse.
82:      * @param warehouseId
83:      * @param productId
84:      * @return the current total inventory of the product
85:      * @throws ShopException if ...
86:      *      - warehouseId is null
87:      *      - the warehouse with that id does not exist
88:      *      - productId is null
89:      *      - the product with that id does not exist
90:      */
91:     public int getAvailableInventory( UUID warehouseId, UUID productId );
92: 
93: 
94: }
95: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import org.springframework.boot.test.context.TestConfiguration;
4: import org.springframework.context.annotation.Bean;
5: import org.springframework.test.web.servlet.MockMvc;
6: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
7: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
8: 
9: 
10: @TestConfiguration
11: public class RESTTestHelperConfiguration {
12: 
13:     @Bean
14:     public ShoppingCartRESTHelper shoppingCartRESTHelper(
15:             MockMvc mockMvc, ProductCatalogUseCases productCatalogUseCases ) {
16:         return new ShoppingCartRESTHelperImpl( mockMvc, productCatalogUseCases );
17:     }
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingCartRESTHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import com.fasterxml.jackson.databind.ObjectMapper;
5: import lombok.AllArgsConstructor;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import lombok.Setter;
9: import lombok.extern.slf4j.Slf4j;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.MvcResult;
12: import org.springframework.test.web.servlet.ResultActions;
13: import org.springframework.test.web.servlet.ResultMatcher;
14: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
15: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
18: 
19: import java.util.Map;
20: import java.util.UUID;
21: 
22: import static org.springframework.http.MediaType.APPLICATION_JSON;
23: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
24: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
25: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
26: 
27: @Slf4j
28: public class ShoppingCartRESTHelperImpl implements ShoppingCartRESTHelper {
29:     private MockMvc mockMvc;
30:     private ProductCatalogUseCases productCatalogUseCases;
31: 
32:     private static final ResultMatcher CREATED = status().isCreated();
33:     private static final ResultMatcher OK = status().isOk();
34: 
35:     public ShoppingCartRESTHelperImpl( MockMvc mockMvc, ProductCatalogUseCases productCatalogUseCases ) {
36:         this.mockMvc = mockMvc;
37:         this.productCatalogUseCases = productCatalogUseCases;
38:     }
39: 
40: 
41:     @Override
42:     public UUID getQueryShoppingCart( EmailAddressType emailAddress, Map<UUID, Integer> quantityMap )
43:             throws Exception {
44:         // first query the users API to get the proper userId
45:         UUID userId;
46:         String userUri = "/users?emailAddress=" + emailAddress.toString();
47:         MvcResult userGetResult = mockMvc.perform( get( userUri ) )
48:                 .andExpect( status().isOk() )
49:                 .andReturn();
50:         ObjectMapper objectMapper = new ObjectMapper();
51:         IdDTO idDTO = objectMapper.readValue( userGetResult.getResponse().getContentAsString(), IdDTO.class );
52:         userId = idDTO.getId();
53: 
54:         // then query the shopping cart API and extract the shopping cart id
55:         String shoppingCartUri = "/shoppingCarts?userId=" + userId.toString();
56:         ResultActions resultActions = mockMvc.perform( get( shoppingCartUri ) )
57:                 .andExpect( status().isOk() );
58:         idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
59:         UUID shoppingCartId = idDTO.getId();
60: 
61:         // additional checks, if desired
62:         if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
63:         return shoppingCartId;
64:     }
65: 
66: 
67:     private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
68:         if ( quantityMap == null ) return;
69:         int numOfProducts = quantityMap.size();
70:         resultActions.andExpect( jsonPath( "$.parts.length()" ).value( numOfProducts ) );
71:         float totalSalesPriceAsFloat = 0f;
72:         for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
73:             UUID productId = entry.getKey();
74:             Integer quantity = entry.getValue();
75:             resultActions.andExpect( jsonPath( "$.parts.[?(@.productId == '" + productId + "')].quantity" )
76:                     .value( quantity ) );
77:             CurrencyType salesPrice = productCatalogUseCases.getSalesPrice( productId );
78:             totalSalesPriceAsFloat += salesPrice.getQuantity() * quantity;
79:         }
80:         // last thing - check the total sales price
81:         String totalSalesPriceString = String.format( "%.2f €", totalSalesPriceAsFloat );
82:         resultActions
83:                 .andExpect( jsonPath( "$.totalSalesPrice" ).value( totalSalesPriceString ) );
84:     }
85: 
86: 
87:     @Override
88:     public void addProductToShoppingCart( UUID shoppingCartId, UUID productId, Integer quantity )
89:             throws Exception {
90:         addProductToShoppingCart( shoppingCartId, productId, quantity, null );
91:     }
92: 
93: 
94:     @Override
95:     public void addProductToShoppingCart( UUID shoppingCartId, UUID productId, Integer quantity,
96:                                                   ResultMatcher expectedStatus ) throws Exception {
97:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
98:         ObjectMapper objectMapper = new ObjectMapper();
99:         QuantityDTO dto = new QuantityDTO( productId, quantity );
100:         String quantityJson = objectMapper.writeValueAsString( dto );
101:         mockMvc.perform( post( "/shoppingCarts/" + shoppingCartId + "/parts" )
102:                         .contentType( APPLICATION_JSON ).content( quantityJson ) )
103:                 .andExpect( status );
104:     }
105: 
106: 
107: 
108:     @Override
109:     public void deleteProductFromShoppingCart( UUID shoppingCartId, UUID productId )
110:             throws Exception {
111:         deleteProductFromShoppingCart( shoppingCartId, productId, null );
112:     }
113: 
114: 
115: 
116:     @Override
117:     public void deleteProductFromShoppingCart( UUID shoppingCartId, UUID productId,
118:                                                       ResultMatcher expectedStatus ) throws Exception {
119:         ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
120:         String uri = "/shoppingCarts/" + shoppingCartId + "/parts/" + productId;
121:         mockMvc.perform( delete( uri ) ).andExpect( status );
122:     }
123: 
124: 
125:     @Override
126:     public void checkout( UUID shoppingCartId, String expectedUserName,
127:                           ResultMatcher expectedStatus,
128:                           Map<UUID, Map<UUID, Integer>> expectedOrders ) throws Exception {
129:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
130:         String uri = "/shoppingCarts/" + shoppingCartId + "/checkout";
131:         MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
132:         ObjectMapper objectMapper = new ObjectMapper();
133: 
134:         // check the response content
135:         if ( expectedOrders != null || expectedUserName != null ) {
136:             String responseContent = result.getResponse().getContentAsString();
137:             log.info( "ShoppingCartRESTHelperImpl - checkout: found response content " + responseContent );
138:             OrderDTO[] orders = objectMapper.readValue( responseContent, OrderDTO[].class );
139:             checkExpectedUserName( expectedUserName, orders );
140:             checkExpectedOrders( expectedOrders, orders );
141:         }
142:     }
143: 
144: 
145:     private void checkExpectedUserName( String expectedUserName, OrderDTO[] orders ) {
146:         if ( expectedUserName == null ) return;
147:         for ( OrderDTO order : orders ) {
148:             if ( !order.getUserName().equals( expectedUserName ) ) {
149:                 throw new AssertionError( "Expected userName '" + expectedUserName +
150:                         "' but got '" + order.getUserName() + "'" );
151:             }
152:         }
153:     }
154: 
155: 
156:     private void checkExpectedOrders( Map<UUID, Map<UUID, Integer>> expectedOrders,
157:                                             OrderDTO[] orders ) {
158:         if ( expectedOrders == null ) return;
159:         for ( OrderDTO order : orders ) {
160:             UUID warehouseId = order.getWarehouseId();
161:             Map<UUID, Integer> expectedQuantities = expectedOrders.get( warehouseId );
162:             if ( expectedQuantities == null ) {
163:                 throw new AssertionError( "No expected quantities for warehouse " + warehouseId );
164:             }
165:             QuantityDTO[] parts = order.getParts();
166:             for ( QuantityDTO quantityDTO : parts ) {
167:                 UUID productId = quantityDTO.getProductId();
168:                 Integer expectedQuantity = expectedQuantities.get( productId );
169:                 if ( expectedQuantity == null ) {
170:                     throw new AssertionError( "No expected quantity for product " + productId +
171:                             " in warehouse " + warehouseId );
172:                 }
173:                 if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
174:                     throw new AssertionError( "Expected quantity " + expectedQuantity + " for product " +
175:                             productId + " in warehouse " + warehouseId +
176:                             ", but got " + quantityDTO.getQuantity() );
177:                 }
178:             }
179:         }
180:     }
181: 
182: 
183:     /**
184:      * A DTO containing just a quantity, used in testing.
185:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
186:      * Therefore, constructors and getters/setters are manually defined.
187:      */
188:     @NoArgsConstructor
189:     @JsonIgnoreProperties(ignoreUnknown = true)
190:     private static class QuantityDTO {
191:         private UUID productId;
192:         private Integer quantity;
193: 
194:         public QuantityDTO( UUID productId, Integer quantity ) {
195:             this.productId = productId;
196:             this.quantity = quantity;
197:         }
198:         public UUID getProductId() {
199:             return productId;
200:         }
201:         public Integer getQuantity() {
202:             return quantity;
203:         }
204:         public void setProductId( UUID productId ) {
205:             this.productId = productId;
206:         }
207:         public void setQuantity( Integer quantity ) {
208:             this.quantity = quantity;
209:         }
210:     }
211: 
212: 
213:     /**
214:      * A DTO containing just the id of an entity, used in testing.
215:      */
216:     @AllArgsConstructor
217:     @NoArgsConstructor
218:     @Getter
219:     @Setter
220:     @JsonIgnoreProperties(ignoreUnknown = true)
221:     private static class IdDTO {
222:         private UUID id;
223:     }
224: 
225: 
226:     /**
227:      * A DTO containing the order data, used in testing.
228:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
229:      * Therefore, constructors and getters/setters are manually defined.
230:      */
231:     @NoArgsConstructor
232:     @JsonIgnoreProperties(ignoreUnknown = true)
233:     private static class OrderDTO {
234:         private UUID id;
235:         private String userName;
236:         private UUID warehouseId;
237:         private QuantityDTO[] parts;
238: 
239:         public UUID getId() {
240:             return id;
241:         }
242:         public String getUserName() {
243:             return userName;
244:         }
245:         public UUID getWarehouseId() {
246:             return warehouseId;
247:         }
248:         public QuantityDTO[] getParts() {
249:             return parts;
250:         }
251:         public void setId( UUID id ) {
252:             this.id = id;
253:         }
254:         public void setUserName( String userName ) {
255:             this.userName = userName;
256:         }
257:         public void setWarehouseId( UUID warehouseId ) {
258:             this.warehouseId = warehouseId;
259:         }
260:         public void setParts( QuantityDTO[] parts ) {
261:             this.parts = parts;
262:         }
263:     }
264: 
265: }
266: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingCartRESTHelper.java ---
1: package thkoeln.archilab.ecommerce.helpers;
2: 
3: import org.springframework.test.web.servlet.ResultMatcher;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
5: 
6: import java.util.Map;
7: import java.util.UUID;
8: 
9: /**
10:  * A REST helper for shopping cart-related operations.
11:  * This interface defines methods to interact with a shopping cart via REST calls, such as querying, adding,
12:  * deleting, and checking out.
13:  */
14: public interface ShoppingCartRESTHelper {
15:     /**
16:      * Executes a REST GET query on a shopping cart and returns its id, with the user's email address as a
17:      * starting point. The resulting shopping cart is checked against the given expected quantity map.
18:      * @param emailAddress The emailAddress of the user whose shopping cart is queried.
19:      * @param expectedQuantityMap A map of products and their quantities in the shopping cart. (If null, then don't check.)
20:      * @return The id of the user's shopping cart.
21:      * @throws Exception (whenever the REST call fails, or the shopping cart does not match the expected quantity map)
22:      */
23:     public UUID getQueryShoppingCart( EmailAddressType emailAddress,
24:                                        Map<UUID, Integer> expectedQuantityMap ) throws Exception;
25: 
26: 
27:     /**
28:      * Adds a product to a shopping cart via a REST call.
29:      * @param shoppingCartId Id of the shopping cart.
30:      * @param productId Id of the product.
31:      * @param quantity Quantity of the product.
32:      * @throws Exception (whenever the REST call fails)
33:      */
34:     public void addProductToShoppingCart( UUID shoppingCartId, UUID productId, Integer quantity )
35:             throws Exception;
36: 
37: 
38:     /**
39:      * Adds a product to a shopping cart via a REST call.
40:      * @param shoppingCartId Id of the shopping cart.
41:      * @param productId Id of the product.
42:      * @param quantity Quantity of the product.
43:      * @param expectedStatus expected status of the operation (null = CREATED)
44:      * @throws Exception (whenever the REST call fails or the status does not match)
45:      */
46:     public void addProductToShoppingCart( UUID shoppingCartId, UUID productId, Integer quantity,
47:                                                   ResultMatcher expectedStatus ) throws Exception;
48: 
49: 
50:     /**
51:      * Deletes a product from a shopping cart via a REST call.
52:      * @param shoppingCartId Id of the shopping cart.
53:      * @param productId Id of the product.
54:      * @throws Exception (whenever the REST call fails)
55:      */
56:     public void deleteProductFromShoppingCart( UUID shoppingCartId, UUID productId )
57:             throws Exception;
58: 
59: 
60:     /**
61:      * Deletes a product from a shopping cart via a REST call.
62:      * @param shoppingCartId Id of the shopping cart.
63:      * @param productId Id of the product.
64:      * @param expectedStatus expected status of the operation (null = OK)
65:      * @throws Exception (whenever the REST call fails or the status does not match)
66:      */
67:     public void deleteProductFromShoppingCart( UUID shoppingCartId, UUID productId,
68:                                                       ResultMatcher expectedStatus ) throws Exception;
69: 
70: 
71:     /**
72:      * Checks out a shopping cart via REST call, and returns the id of the created order.
73:      * @param shoppingCartId
74:      * @param expectedUserName expected name of the user who owns the shopping cart (null = don't check)
75:      * @param expectedStatus expected status of the operation (null = don't check)
76:      * @param expectedOrders the expected orders to be created as a result of the checkout. This is
77:      *                            a map of the following form:
78:      *                            <pre>
79:      *                               warehouseId -> Map<productId,Integer>
80:      *                            </pre>
81:      *                            where the inner map contains the products and their quantities
82:      * @return
83:      * @throws Exception
84:      */
85:     public void checkout( UUID shoppingCartId, String expectedUserName,
86:                           ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedOrders )
87:            throws Exception;
88: }
89: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class BasicNoOutsideSolutionRulesTest {
14: 
15:     @ArchTest
16:     static final ArchRule noClassesOnTopLevel =
17:             classes().should().resideInAPackage( "..solution.*.." )
18:                     .allowEmptyShould( true );
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.library.Architectures.layeredArchitecture;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln")
12: @SuppressWarnings("PMD")
13: public class BasicProperDependenciesTest {
14: 
15:     @ArchTest
16:     static final ArchRule properDependencies =
17:             layeredArchitecture()
18:                     .consideringAllDependencies()
19:                     //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
20:                     .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
21:                     .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )
22: 
23:                     //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
24:                     .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
25:                     .allowEmptyShould( true );
26: }
27: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
5: import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
6: import org.springframework.core.type.classreading.MetadataReader;
7: import org.springframework.core.type.classreading.MetadataReaderFactory;
8: 
9: import java.io.IOException;
10: import java.util.Arrays;
11: import java.util.HashSet;
12: import java.util.Set;
13: 
14: import static org.junit.jupiter.api.Assertions.assertTrue;
15: 
16: public class BasicRequiredClassesTest {
17:     private static final String[] REQUIRED_CLASSES = {
18:             "User",
19:             "UserRepository",
20:             "Product",
21:             "ProductRepository",
22:             "Order",
23:             "OrderRepository",
24:             "InventoryLevel",
25:             "ShoppingCart",
26:             "ShoppingCartRepository",
27:             "WarehouseRepository",
28:             "ShoppingCartPart",
29:             "OrderPart",
30:             "Warehouse",
31:     };
32: 
33:     @Test
34:     public void testRequiredClassesDeclared() throws IOException {
35:         String basePackage = "thkoeln.archilab.ecommerce";
36:         String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";
37: 
38:         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
39:         MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );
40: 
41:         Set<String> foundClasses = new HashSet<>();
42: 
43:         Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
44:             try {
45:                 MetadataReader reader = readerFactory.getMetadataReader( resource );
46:                 foundClasses.add( reader.getClassMetadata().getClassName() );
47:             } catch (IOException e) {
48:                 e.printStackTrace();
49:             }
50:         } );
51: 
52:         Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
53:             boolean found = foundClasses.stream().anyMatch(className ->
54:                     className.startsWith(basePackage) && className.endsWith("." + requiredClass)
55:             );
56:             assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
57:         });
58:     }
59: }
60: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.boot.test.context.SpringBootTest;
6: import org.springframework.context.ApplicationContext;
7: 
8: import java.util.Arrays;
9: import java.util.HashMap;
10: import java.util.List;
11: import java.util.Map;
12: 
13: import static org.junit.jupiter.api.Assertions.*;
14: 
15: @SpringBootTest
16: public class BasicUseCaseImplementationPackageTest {
17: 
18:     @Autowired
19:     private ApplicationContext applicationContext;
20: 
21:     private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
22:         put("UserRegistrationUseCases", Arrays.asList("user"));
23:         put("WarehouseUseCases", Arrays.asList("warehouse"));
24:         put("ProductCatalogUseCases", Arrays.asList("product"));
25:         put("ShoppingCartUseCases", Arrays.asList("shoppingcart"));
26:         put("OrderUseCases", Arrays.asList("order"));
27:     }};
28:     private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
29:     private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";
30: 
31:     @Test
32:     public void testRequiredClassesDeclared() {
33:         for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
34:             String interfaceName = USECASE_PATH + "." + entry.getKey();
35:             List<String> correctTopLevelPackages = entry.getValue();
36:             Class<?> useCaseInterfaceClass = null;
37:             try {
38:                 useCaseInterfaceClass = Class.forName( interfaceName );
39:             } catch (ClassNotFoundException e) {
40:                 fail( "Use case interface " + interfaceName + " not found.", e );
41:                 continue;
42:             }
43:             String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
44:             assertEquals( 1, beans.length,
45:                     "There should be exactly 1 service implementation for the interface " +
46:                             entry.getKey() + ", but found " + beans.length );
47:             Object bean = applicationContext.getBean( beans[0] );
48:             boolean isValid = false;
49:             for ( String correctTopLevelPackage : correctTopLevelPackages ) {
50:                 String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
51:                 if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
52:                     isValid = true;
53:                     break;
54:                 }
55:             }
56:             assertTrue( isValid,
57:                     "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
58:                             + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
59:         }
60:     }
61: }
62: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: import org.springframework.data.repository.CrudRepository;
8: import org.springframework.stereotype.Service;
9: 
10: import jakarta.persistence.Entity;
11: import org.springframework.web.bind.annotation.RestController;
12: 
13: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
14: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
15: 
16: @ArchTag("layerRules")
17: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
18: @SuppressWarnings("PMD")
19: public class DDDRulesTest {
20: 
21:     @ArchTest
22:     static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
23:             noClasses().that().resideInAPackage( "..domain.." )
24:                     .should().dependOnClassesThat().resideInAPackage( "..application.." )
25:                     .allowEmptyShould( true );
26: 
27:     @ArchTest
28:     static final ArchRule entitiesMustResideInADomainPackage =
29:             classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
30:                     .as( "Entities must reside in a package '..domain..'" )
31:                     .allowEmptyShould( true );
32: 
33:     @ArchTest
34:     static final ArchRule entitiesMustNotAccessRepositories =
35:             noClasses().that().areAnnotatedWith( Entity.class )
36:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
37:                     .allowEmptyShould( true );
38: 
39:     @ArchTest
40:     static final ArchRule repositoriesMustResideInADomainPackage =
41:             classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
42:                     .as( "Repositories must reside in a package '..domain..'" )
43:                     .allowEmptyShould( true );
44: 
45:     @ArchTest
46:     static final ArchRule repositoryNamesMustHaveProperSuffix =
47:             classes().that().areAssignableTo( CrudRepository.class )
48:                     .should().haveSimpleNameEndingWith( "Repository" )
49:                     .allowEmptyShould( true );
50: 
51:     @ArchTest
52:     static final ArchRule servicesMustResideInAnApplicationPackage =
53:             classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
54:                     .as( "Application Services must reside in a package '..application..'" )
55:                     .allowEmptyShould( true );
56: 
57:     @ArchTest
58:     static final ArchRule serviceNamesMustHaveProperSuffix =
59:             classes().that().areAnnotatedWith( Service.class )
60:                     .should().haveSimpleNameEndingWith( "Service" )
61:                     .allowEmptyShould( true );
62: 
63:     @ArchTest
64:     static final ArchRule controllersMustResideInAnApplicationPackage =
65:             classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
66:                     .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );
67: 
68:     @ArchTest
69:     static final ArchRule controllersNamesMustHaveProperSuffix =
70:             classes().that().areAnnotatedWith( RestController.class )
71:                     .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );
72: 
73:     @ArchTest
74:     static final ArchRule controllersMustNotAccessRepositories =
75:             noClasses().that().areAnnotatedWith( RestController.class )
76:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
77:                     .allowEmptyShould( false );
78: }
79: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.importer.ClassFileImporter;
6: import com.tngtech.archunit.lang.ArchRule;
7: import com.tngtech.archunit.library.dependencies.SliceAssignment;
8: import com.tngtech.archunit.library.dependencies.SliceIdentifier;
9: import org.junit.jupiter.api.Test;
10: 
11: import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
12: 
13: public class NoCycleTest {
14:     private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");
15: 
16:     private SliceAssignment inAllClasses() {
17:         return new SliceAssignment() {
18:             @Override
19:             public String getDescription() {
20:                 return "every class in it's own slice";
21:             }
22: 
23:             @Override
24:             public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
25:                 return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
26:             }
27:         };
28:     }
29: 
30:     @Test
31:     public void testNoCyclicDependenciesBetweenClasses() {
32:         slices().assignedFrom(inAllClasses())
33:                 .namingSlices("$1[$2.$3]")
34:                 .should().beFreeOfCycles()
35:                 .check(importedClasses);
36:     }
37: 
38:     @Test
39:     public void testNoCyclicDependenciesBetweenPackages() {
40:         ArchRule rule = slices().matching("..solution.(*)..")
41:                 .should().beFreeOfCycles().allowEmptyShould( true );
42:         rule.check(importedClasses);
43:     }
44: }
45: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.base.DescribedPredicate;
4: import com.tngtech.archunit.core.domain.JavaClass;
5: import com.tngtech.archunit.core.domain.JavaField;
6: import com.tngtech.archunit.core.domain.JavaParameterizedType;
7: import com.tngtech.archunit.core.domain.JavaType;
8: import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
9: import com.tngtech.archunit.junit.AnalyzeClasses;
10: import com.tngtech.archunit.junit.ArchTag;
11: import com.tngtech.archunit.junit.ArchTest;
12: import com.tngtech.archunit.lang.ArchCondition;
13: import com.tngtech.archunit.lang.ArchRule;
14: import com.tngtech.archunit.lang.ConditionEvents;
15: import com.tngtech.archunit.lang.SimpleConditionEvent;
16: import jakarta.persistence.*;
17: import lombok.extern.slf4j.Slf4j;
18: import thkoeln.archilab.ecommerce.GenericId;
19: 
20: import java.util.List;
21: 
22: import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
23: import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
24: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;
25: 
26: @ArchTag("layerRules")
27: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
28: @SuppressWarnings("PMD")
29: @Slf4j
30: public class OnlyReferenceViaIDTest { //WAREHOUSE
31:     private static final String SHOPPING_CART_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingcart.domain";
32:     private static final String USER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.user.domain";
33:     private static final String PRODUCT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.product.domain";
34:     private static final String ORDER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.order.domain";
35:     private static final String WAREHOUSE_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.warehouse.domain";
36: 
37:     @ArchTest
38:     static final ArchRule idFieldsMustUseGenericId =
39:             fields()
40:                     .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
41:                     .and().areAnnotatedWith( Id.class )
42:                     .should().haveRawType( assignableTo( GenericId.class ) )
43:                     .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
44:                     .allowEmptyShould( true );
45: 
46: 
47:     private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
48:             annotatedWith( ManyToOne.class )
49:                     .or( annotatedWith( OneToOne.class ) )
50:                     .or( annotatedWith( Embedded.class ) )
51:                     .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );
52: 
53:     private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
54:             annotatedWith( OneToMany.class )
55:                     .or( annotatedWith( ManyToMany.class ) )
56:                     .or( annotatedWith( ElementCollection.class ) )
57:                     .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );
58: 
59: 
60:     private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
61:         String description = "an entity or value object from same aggregate, or a domain primitive";
62:         return new DescribedPredicate<>( description ) {
63:             @Override
64:             public boolean test( JavaClass type ) {
65:                 // check if the class is an entity or value object, and resides in the allowed package
66:                 if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
67:                     return false;
68:                 }
69:                 // a GenericId is always allowed
70:                 if ( type.isAssignableTo( GenericId.class ) ) {
71:                     return true;
72:                 }
73:                 // a domain primitive is also always allowed
74:                 if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
75:                     return true;
76:                 }
77:                 return type.getPackageName().startsWith( allowedPackage );
78:             }
79:         };
80:     }
81: 
82: 
83:     @ArchTest
84:     static final ArchRule shoppingCartToOneReferences =
85:             fields()
86:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_CART_DOMAIN_PACKAGE )
87:                     .and( isToOneAnnotation )
88:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_CART_DOMAIN_PACKAGE ) ) )
89:                     .allowEmptyShould( true );
90: 
91:     @ArchTest
92:     static final ArchRule userToOneReferences =
93:             fields()
94:                     .that().areDeclaredInClassesThat().resideInAPackage( USER_DOMAIN_PACKAGE )
95:                     .and( isToOneAnnotation )
96:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( USER_DOMAIN_PACKAGE ) ) )
97:                     .allowEmptyShould( true );
98: 
99:     @ArchTest
100:     static final ArchRule productToOneReferences =
101:             fields()
102:                     .that().areDeclaredInClassesThat().resideInAPackage( PRODUCT_DOMAIN_PACKAGE )
103:                     .and( isToOneAnnotation )
104:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( PRODUCT_DOMAIN_PACKAGE ) ) )
105:                     .allowEmptyShould( true );
106: 
107:     @ArchTest
108:     static final ArchRule orderToOneReferences =
109:             fields()
110:                     .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
111:                     .and( isToOneAnnotation )
112:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) ) )
113:                     .allowEmptyShould( true );
114: 
115:     @ArchTest
116:     static final ArchRule warehouseToOneReferences =
117:             fields()
118:                     .that().areDeclaredInClassesThat().resideInAPackage( WAREHOUSE_DOMAIN_PACKAGE )
119:                     .and( isToOneAnnotation )
120:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( WAREHOUSE_DOMAIN_PACKAGE ) ) )
121:                     .allowEmptyShould( true );
122: 
123: 
124:     private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
125:         return new ArchCondition<JavaField>(
126:                 "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
127:             @Override
128:             public void check( JavaField field, ConditionEvents events ) {
129:                 JavaClass rawType = field.getRawType();
130:                 String rawTypeName = rawType.getFullName();
131:                 if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
132:                     events.add( SimpleConditionEvent.violated( field,
133:                             field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
134:                     return;
135:                 }
136:                 JavaType fieldType = field.getType();
137:                 if ( !( fieldType instanceof JavaParameterizedType ) ) {
138:                     events.add( SimpleConditionEvent.violated( field,
139:                             field.getFullName() + " is a raw List/Set without a type argument" ) );
140:                     return;
141:                 }
142:                 List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
143:                 if ( typeArguments.isEmpty() ) {
144:                     events.add( SimpleConditionEvent.violated( field,
145:                             field.getFullName() + " has no type arguments" ) );
146:                     return;
147:                 }
148:                 JavaType elementType = typeArguments.get( 0 );
149:                 if ( !( elementType instanceof JavaClass ) ) {
150:                     events.add( SimpleConditionEvent.violated( field,
151:                             field.getFullName() + " has an unknown element type" ) );
152:                     return;
153:                 }
154:                 JavaClass elementClass = (JavaClass) elementType;
155:                 boolean hasAnnotation =
156:                         elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
157:                 boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
158:                 boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
159:                 boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
160:                 boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
161:                 if ( !ok ) {
162:                     events.add( SimpleConditionEvent.violated( field,
163:                             field.getFullName() + " refers to " + elementClass.getFullName()
164:                                     + " which is not a DP, or an entity/value object in " + allowedPackage ) );
165:                 }
166:             }
167:         };
168:     }
169: 
170: 
171:     @ArchTest
172:     static final ArchRule shoppingCartToManyReferences =
173:             fields()
174:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_CART_DOMAIN_PACKAGE )
175:                     .and( isToManyAnnotation )
176:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_CART_DOMAIN_PACKAGE ) )
177:                     .allowEmptyShould( true );
178: 
179:     @ArchTest
180:     static final ArchRule userToManyReferences =
181:             fields()
182:                     .that().areDeclaredInClassesThat().resideInAPackage( USER_DOMAIN_PACKAGE )
183:                     .and( isToManyAnnotation )
184:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( USER_DOMAIN_PACKAGE ) )
185:                     .allowEmptyShould( true );
186: 
187:     @ArchTest
188:     static final ArchRule productToManyReferences =
189:             fields()
190:                     .that().areDeclaredInClassesThat().resideInAPackage( PRODUCT_DOMAIN_PACKAGE )
191:                     .and( isToManyAnnotation )
192:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( PRODUCT_DOMAIN_PACKAGE ) )
193:                     .allowEmptyShould( true );
194: 
195:     @ArchTest
196:     static final ArchRule orderToManyReferences =
197:             fields()
198:                     .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
199:                     .and( isToManyAnnotation )
200:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) )
201:                     .allowEmptyShould( true );
202: 
203:     @ArchTest
204:     static final ArchRule warehouseToManyReferences =
205:             fields()
206:                     .that().areDeclaredInClassesThat().resideInAPackage( WAREHOUSE_DOMAIN_PACKAGE )
207:                     .and( isToManyAnnotation )
208:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( WAREHOUSE_DOMAIN_PACKAGE ) )
209:                     .allowEmptyShould( true );
210: 
211: }
212: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: /**
4:  * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
5:  */
6: 
7: public class OwnTestsTest {
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClasses;
4: import com.tngtech.archunit.core.importer.ClassFileImporter;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: 
8: import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
9: 
10: public class PackageStructureTest {
11: 
12:     private static final String[] REQUIRED_PACKAGES = {"user", "shoppingcart", "product", "order", "warehouse"};
13:     private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
14:     private JavaClasses importedClasses;
15: 
16: 
17:     @BeforeEach
18:     public void setUp() {
19:         importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
20:     }
21: 
22:     @Test
23:     void testRequiredPackagesAreThere() {
24:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
25:             String packageName = BASE_PACKAGE + "." + requiredPackage;
26:             assertThat( importedClasses.containPackage( packageName ) )
27:                     .as( "Expected package %s not found!", packageName )
28:                     .isTrue();
29:         }
30:     }
31: 
32:     @Test
33:     void testRequiredDomainPackagesAreThere() {
34:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
35:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
36:             assertThat( importedClasses.containPackage( packageName ) )
37:                     .as( "Expected domain sub-package %s not found!", packageName )
38:                     .isTrue();
39:         }
40:     }
41: 
42:     @Test
43:     void testRequiredApplicationPackagesAreThere() {
44:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
45:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
46:             assertThat( importedClasses.containPackage( packageName ) )
47:                     .as( "Expected application sub-package %s not found!", packageName )
48:                     .isTrue();
49:         }
50:     }
51: 
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\AddressLocationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateAddressLocation;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePostalCode;
11: 
12: class AddressLocationTest {
13: 
14:     @Test
15:     public void testGetterAddressLocation() {
16:         // given
17:         String street = "Irgendeinestraße 42";
18:         String city = "Irgendeinestadt";
19:         PostalCodeType plz = instantiatePostalCode( "12345" );
20: 
21:         // when
22:         AddressLocationType instance = instantiateAddressLocation( street, city, plz );
23: 
24:         // then
25:         assertEquals( street, instance.getStreet() );
26:         assertEquals( city, instance.getCity() );
27:         assertEquals( plz, instance.getPostalCode() );
28:     }
29: 
30:     @Test
31:     public void testFactoryValidAddressLocation() {
32:         // given
33:         String street = "Irgendeinestraße 42";
34:         String city = "Irgendeinestadt";
35:         PostalCodeType plz = instantiatePostalCode( "12345" );
36: 
37:         // when
38:         // then
39:         assertDoesNotThrow( () -> instantiateAddressLocation( street, city, plz ) );
40:     }
41: 
42:     @Test
43:     public void testFactoryInvalidAddressLocation() {
44:         // given
45:         String street = "Irgendeinestraße 42";
46:         String city = "Irgendeinestadt";
47:         PostalCodeType plz = instantiatePostalCode( "12345" );
48: 
49:         // when
50:         // then
51:         assertThrows( ShopException.class, () -> instantiateAddressLocation( null, city, plz ) );
52:         assertThrows( ShopException.class, () -> instantiateAddressLocation( "", city, plz ) );
53:         assertThrows( ShopException.class, () -> instantiateAddressLocation( street, null, plz ) );
54:         assertThrows( ShopException.class, () -> instantiateAddressLocation( street, "", plz ) );
55:         assertThrows( ShopException.class, () -> instantiateAddressLocation( street, city, null ) );
56:     }
57: 
58:     @Test
59:     public void testEqualityAddressLocation() {
60:         // given
61:         String street = "Irgendeinestraße 42";
62:         String city = "Irgendeinestadt";
63:         PostalCodeType plz = instantiatePostalCode( "12345" );
64: 
65:         // when
66:         AddressLocationType instance1 = instantiateAddressLocation( street, city, plz );
67:         AddressLocationType instance2 = instantiateAddressLocation( street, city, plz );
68:         AddressLocationType instance3 = instantiateAddressLocation( "Anderestr. 12", city, plz );
69:         AddressLocationType instance4 = instantiateAddressLocation( street, "AndereStadt", plz );
70:         AddressLocationType instance5 = instantiateAddressLocation( street, city, instantiatePostalCode( "54321" ) );
71: 
72:         // then
73:         assertEquals( instance1, instance2 );
74:         assertNotEquals( instance1, instance3 );
75:         assertNotEquals( instance1, instance4 );
76:         assertNotEquals( instance1, instance5 );
77:     }
78: 
79:     @Test
80:     public void testImmutabilityAddressLocation() {
81:         // given
82:         String street = "Irgendeinestraße 42";
83:         String city = "Irgendeinestadt";
84:         PostalCodeType plz = instantiatePostalCode( "12345" );
85: 
86:         // when
87:         AddressLocationType instance = instantiateAddressLocation( street, city, plz );
88: 
89:         // then
90:         try {
91:             instance.getClass().getMethod( "setStreet", String.class );
92:             fail( "setStreet method should not exist" );
93:         } catch (NoSuchMethodException e) {
94:             // Success: the object is immutable
95:         }
96:         try {
97:             instance.getClass().getMethod( "setCity", String.class );
98:             fail( "setCity method should not exist" );
99: 
100:         } catch (NoSuchMethodException e) {
101:             // Success: the object is immutable
102:         }
103:         try {
104:             instance.getClass().getMethod( "setPostalCode", PostalCodeType.class );
105:             fail( "setPostalCode method should not exist" );
106:         } catch (NoSuchMethodException e) {
107:             // Success: the object is immutable
108:         }
109:     }
110: }
111: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\CurrencyTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateCurrency;
9: 
10: class CurrencyTest {
11: 
12:     @Test
13:     public void testGetQuantityCurrency() {
14:         // given
15:         Float inputQuantity = 10.0f;
16: 
17:         // when
18:         CurrencyType instance = instantiateCurrency( inputQuantity, "EUR" );
19: 
20:         // then
21:         assertEquals( inputQuantity, instance.getQuantity() );
22:     }
23: 
24:     @Test
25:     public void testGetCurrencyUnitCurrency() {
26:         // given
27:         String inputCurrencyUnit = "EUR";
28: 
29:         // when
30:         CurrencyType instance = instantiateCurrency( 10.0f, inputCurrencyUnit );
31: 
32:         // then
33:         assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
34:     }
35: 
36:     @Test
37:     public void testAddToCurrency() {
38:         // given
39:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
40:         CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
41:         CurrencyType instance3 = instantiateCurrency( 0.0f, "EUR" );
42: 
43:         // when
44:         CurrencyType result12 = instance1.add( instance2 );
45:         CurrencyType result13 = instance1.add( instance3 );
46: 
47:         // then
48:         assertEquals( 30.0f, result12.getQuantity() );
49:         assertEquals( "EUR", result12.getCurrencyUnit() );
50:         assertEquals( 10.0f, result13.getQuantity() );
51:         assertEquals( "EUR", result12.getCurrencyUnit() );
52:     }
53: 
54:     @Test
55:     public void testInvalidAddToCurrency() {
56:         // given
57:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
58:         CurrencyType instance2 = instantiateCurrency( 20.0f, "CHF" );
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
63:     }
64: 
65:     @Test
66:     public void testSubtractFromCurrency() {
67:         // given
68:         CurrencyType instance1 = instantiateCurrency( 30.0f, "EUR" );
69:         CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
70:         CurrencyType instance3 = instantiateCurrency( 0.0f, "EUR" );
71:         CurrencyType instance4 = instantiateCurrency( 30.0f, "EUR" );
72: 
73:         // when
74:         CurrencyType result12 = instance1.subtract( instance2 );
75:         CurrencyType result13 = instance1.subtract( instance3 );
76:         CurrencyType result14 = instance1.subtract( instance4 );
77: 
78:         // then
79:         assertEquals( 10.0f, result12.getQuantity() );
80:         assertEquals( "EUR", result12.getCurrencyUnit() );
81:         assertEquals( 30.0f, result13.getQuantity() );
82:         assertEquals( "EUR", result13.getCurrencyUnit() );
83:         assertEquals( 0.0f, result14.getQuantity() );
84:         assertEquals( "EUR", result14.getCurrencyUnit() );
85:     }
86: 
87:     @Test
88:     public void testInvalidSubtractFromCurrency() {
89:         // given
90:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
91:         CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
92:         CurrencyType instance3 = instantiateCurrency( 5.0f, "CHF" );
93: 
94:         // when
95:         // then
96:         assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
97:         assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
98:     }
99: 
100:     @Test
101:     public void testMultiplyByCurrency() {
102:         // given
103:         CurrencyType instance = instantiateCurrency( 10.0f, "EUR" );
104: 
105:         // when
106:         CurrencyType result = instance.multiplyBy( 3 );
107: 
108:         // then
109:         assertEquals( 30.0f, result.getQuantity() );
110:         assertEquals( "EUR", result.getCurrencyUnit() );
111:     }
112: 
113:     @Test
114:     public void testFactoryValidCurrencyUnitCurrency() {
115:         // given
116:         // when
117:         // then
118:         assertDoesNotThrow( () -> instantiateCurrency( 10.0f, "EUR" ) );
119:     }
120: 
121:     @Test
122:     public void testFactoryInvalidCurrencyUnitCurrency() {
123:         // given
124:         // when
125:         // then
126:         assertThrows( ShopException.class, () -> instantiateCurrency( -10.0f, "EUR" ) );
127:         assertThrows( ShopException.class, () -> instantiateCurrency( 10.0f, "USD" ) );
128:         assertThrows( ShopException.class, () -> instantiateCurrency( null, "EUR" ) );
129:         assertThrows( ShopException.class, () -> instantiateCurrency( 10.0f, null ) );
130:     }
131: 
132:     @Test
133:     public void testLargerThanCurrencyUnitCurrency() {
134:         // given
135:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
136:         CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
137:         CurrencyType instance3 = instantiateCurrency( 10.0f, "EUR" );
138:         CurrencyType instance4 = instantiateCurrency( 10.0f, "CHF" );
139: 
140:         // when
141:         // then
142:         assertTrue( instance2.largerThan( instance1 ) );
143:         assertFalse( instance1.largerThan( instance2 ) );
144:         assertFalse( instance1.largerThan( instance3 ) );
145:         assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
146:     }
147: 
148: 
149:     @Test
150:     public void testEqualityCurrencyUnitCurrency() {
151:         // given
152:         // when
153:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
154:         CurrencyType instance2 = instantiateCurrency( 10.0f, "EUR" );
155:         CurrencyType instance3 = instantiateCurrency( 20.0f, "EUR" );
156: 
157:         // then
158:         assertEquals( instance1, instance2 );
159:         assertNotEquals( instance1, instance3 );
160:     }
161: 
162:     @Test
163:     public void testImmutabilityCurrencyUnitCurrency() {
164:         // given
165:         // when
166:         CurrencyType instance = instantiateCurrency( 10.0f, "EUR" );
167: 
168:         // then
169:         try {
170:             instance.getClass().getMethod( "setQuantity", Float.class );
171:             fail( "setQuantity method should not exist" );
172:         } catch (NoSuchMethodException e) {
173:             // Success: the object is immutable
174:         }
175: 
176:         try {
177:             instance.getClass().getMethod( "setCurrencyUnit", String.class );
178:             fail( "setCurrencyUnit method should not exist" );
179:         } catch (NoSuchMethodException e) {
180:             // Success: the object is immutable
181:         }
182:     }
183: }
184: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("domainPrimitivesUsageRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class DomainPrimitivesUsageRulesTest {
14:     private static final String EMAIL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.EmailAddress";
15:     private static final String CURRENCY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Currency";
16:     private static final String ADDRESS_LOCATION_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.AddressLocation";
17: 
18:     @ArchTest
19:     static final ArchRule userShouldReferenceEmailAddress =
20:             classes()
21:                     .that().haveSimpleName( "User" )
22:                     .should().dependOnClassesThat().haveFullyQualifiedName( EMAIL_ADDRESS_CLASS )
23:                     .because( "User should use EmailAddress instead of String" );
24: 
25:     @ArchTest
26:     static final ArchRule userShouldReferenceAddressLocation =
27:             classes()
28:                     .that().haveSimpleName( "User" )
29:                     .should().dependOnClassesThat().haveFullyQualifiedName( ADDRESS_LOCATION_CLASS )
30:                     .because( "User should use AddressLocation instead of whatever else" );
31: 
32:     @ArchTest
33:     static final ArchRule warehouseShouldReferenceAddressLocation =
34:             classes()
35:                     .that().haveSimpleName( "Warehouse" )
36:                     .should().dependOnClassesThat().haveFullyQualifiedName( ADDRESS_LOCATION_CLASS )
37:                     .because( "User should use AddressLocation instead of whatever else" );
38: 
39:     @ArchTest
40:     static final ArchRule productShouldReferenceCurrency =
41:             classes()
42:                     .that().haveSimpleName( "Product" )
43:                     .should().dependOnClassesThat().haveFullyQualifiedName( CURRENCY_CLASS )
44:                     .because( "Product should use Currency instead of float or whatever else" );
45: }
46: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\EmailAddressTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmailAddress;
10: 
11: class EmailAddressTest {
12: 
13:     @Test
14:     public void testToStringEmailAddress() {
15:         // given
16:         String input = "test@example.com";
17: 
18:         // when
19:         EmailAddressType instance = instantiateEmailAddress( input );
20: 
21:         // then
22:         assertEquals( input, instance.toString() );
23:     }
24: 
25:     @Test
26:     public void testEqualityEmailAddress() {
27:         // given
28:         // when
29:         EmailAddressType instance1 = instantiateEmailAddress( "test@example.com" );
30:         EmailAddressType instance2 = instantiateEmailAddress( "test@example.com" );
31:         EmailAddressType instance3 = instantiateEmailAddress( "different@example.com" );
32: 
33:         // then
34:         assertEquals( instance1, instance2 );
35:         assertNotEquals( instance1, instance3 );
36:     }
37: 
38:     @Test
39:     public void testImmutabilityEmailAddress() {
40:         // given
41:         // when
42:         EmailAddressType instance = instantiateEmailAddress( "test@example.com" );
43: 
44:         // then
45:         try {
46:             instance.getClass().getMethod( "setEmailAddress", String.class );
47:             fail( "setEmailAddress method should not exist" );
48:         } catch (NoSuchMethodException e) {
49:             // Success: the object is immutable
50:         }
51:     }
52: 
53: 
54: 
55:     @Test
56:     public void smokeTestForCopyConstructors() {
57:         // given
58:         EmailAddressType emailAddress =
59:                 instantiateEmailAddress( "peter.schmidt@web.de" );
60: 
61:         // when
62:         EmailAddressType emailAddressOtherIdentifyer =
63:                 emailAddress.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
64:         assertThrows( ShopException.class, () ->
65:                 emailAddress.sameDomainDifferentIdentifyer( "p...eter" ) );
66:         EmailAddressType emailAddressOtherDomain =
67:                 emailAddress.sameIdentifyerDifferentDomain( "web.ch" );
68:         assertThrows( ShopException.class, () ->
69:                 emailAddress.sameIdentifyerDifferentDomain( "web.edu" ) );
70: 
71:         // then
72:         assertEquals( "p.e.t.e.r@web.de", emailAddressOtherIdentifyer.toString() );
73:         assertEquals( "peter.schmidt@web.ch", emailAddressOtherDomain.toString() );
74:     }
75: 
76: 
77:     @Test
78:     public void testFactoryValidEmailAddress() {
79:         // given
80:         // when
81:         // then
82:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.com" ) );
83:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "99Z@example.com" ) );
84:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "GGGhh@s77.com" ) );
85:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "a@4.com" ) );
86:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "Max.Hammer@example.com" ) );
87:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "Max.Gideon.Hammer@example.com" ) );
88:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.this.com" ) );
89:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.de" ) );
90:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.at" ) );
91:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.ch" ) );
92:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.org" ) );
93:     }
94: 
95: 
96:     @Test
97:     public void testFactoryInvalidEmailAddress() {
98:         // given
99:         // when
100:         // then
101:         assertThrows( ShopException.class, () -> instantiateEmailAddress( null ) );
102:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "testexample.com" ) );
103:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@" ) );
104:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "@example.com" ) );
105:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "Max..Gideon.Hammer@example.com" ) );
106:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@examplecom" ) );
107:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example..com" ) );
108:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example@that.com" ) );
109:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test example@that.com" ) );
110:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test#example@that.com" ) );
111:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.biz" ) );
112:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.biz" ) );
113:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.42" ) );
114:     }
115: }
116: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\PostalCodeTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
8: 
9: import static org.junit.jupiter.api.Assertions.*;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePostalCode;
11: 
12: class PostalCodeTest {
13: 
14:     private String input1, input4;
15:     private PostalCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
16:             _04233, _02544, _99123, _56323, _79332;
17: 
18: 
19:     @BeforeEach
20:     public void setUp() {
21:         input1 = "12345";
22:         input4 = "49188";
23:         _12345 = FactoryMethodInvoker.instantiatePostalCode( "12345" );
24:         _12345b = FactoryMethodInvoker.instantiatePostalCode( "12345" );
25:         _23455 = FactoryMethodInvoker.instantiatePostalCode( "23455" );
26:         _01234 = FactoryMethodInvoker.instantiatePostalCode( "01234" );
27:         _01235 = FactoryMethodInvoker.instantiatePostalCode( "01235" );
28:         _01238 = FactoryMethodInvoker.instantiatePostalCode( "01238" );
29:         _01263 = FactoryMethodInvoker.instantiatePostalCode( "01263" );
30:         _01213 = FactoryMethodInvoker.instantiatePostalCode( "01213" );
31:         _01823 = FactoryMethodInvoker.instantiatePostalCode( "01823" );
32:         _01312 = FactoryMethodInvoker.instantiatePostalCode( "01312" );
33:         _04233 = FactoryMethodInvoker.instantiatePostalCode( "04233" );
34:         _02544 = FactoryMethodInvoker.instantiatePostalCode( "02544" );
35:         _99123 = FactoryMethodInvoker.instantiatePostalCode( "99123" );
36:         _56323 = FactoryMethodInvoker.instantiatePostalCode( "56323" );
37:         _79332 = FactoryMethodInvoker.instantiatePostalCode( "79332" );
38: 
39:     }
40: 
41: 
42:     @Test
43:     public void testToStringPostalCode() {
44:         // given
45:         // when
46:         PostalCodeType instance = instantiatePostalCode( input1 );
47: 
48:         // then
49:         assertEquals( input1, instance.toString() );
50:     }
51: 
52:     @Test
53:     public void testFactoryValidPostalCode() {
54:         // given
55:         // when
56:         // then
57:         assertDoesNotThrow( () -> instantiatePostalCode( input1 ) );
58:     }
59: 
60:     @Test
61:     public void testFactoryInvalidPostalCode() {
62:         // given
63:         // when
64:         // then
65:         assertThrows( ShopException.class, () -> instantiatePostalCode( "123456" ) );
66:         assertThrows( ShopException.class, () -> instantiatePostalCode( "1234" ) );
67:         assertThrows( ShopException.class, () -> instantiatePostalCode( "20000" ) );
68:         assertThrows( ShopException.class, () -> instantiatePostalCode( null ) );
69:     }
70: 
71:     @Test
72:     public void testEqualityPostalCode() {
73:         // given
74:         // when
75:         PostalCodeType instance1a = instantiatePostalCode( input1 );
76:         PostalCodeType instance1b = instantiatePostalCode( input1 );
77:         PostalCodeType instance4 = instantiatePostalCode( input4 );
78: 
79:         // then
80:         assertEquals( instance1a, instance1b );
81:         assertNotEquals( instance1a, instance4 );
82:     }
83: 
84:     @Test
85:     public void testImmutabilityPostalCode() {
86:         // given
87:         // when
88:         PostalCodeType instance = instantiatePostalCode( input1 );
89: 
90:         // then
91:         try {
92:             instance.getClass().getMethod( "setpostalCode", String.class );
93:             fail( "setpostalCode method should not exist" );
94:         } catch (NoSuchMethodException e) {
95:             // Success: the object is immutable
96:         }
97:     }
98: 
99: 
100:     @Test
101:     public void smokeTestForDistance() {
102:         // given
103:         PostalCodeType instance1a = instantiatePostalCode( input1 );
104:         PostalCodeType instance1b = instantiatePostalCode( input1 );
105:         PostalCodeType instance12479 = instantiatePostalCode( "12479" );
106:         PostalCodeType instance21456 = instantiatePostalCode( "21456" );
107: 
108:         // when
109:         int distanceAB = instance1a.distance( instance1b );
110:         int distance12 = instance1a.distance( instance12479 );
111:         int distance23 = instance12479.distance( instance21456 );
112: 
113:         // then
114:         assertEquals( 0, distanceAB );
115:         assertTrue( distance12 > 0 );
116:         assertTrue( distance23 > distance12 );
117:     }
118: 
119: 
120:     @Test
121:     public void testPostalCodeFirstDigit() {
122:         // given
123:         PostalCodeType instance1 = instantiatePostalCode( input1 );
124:         PostalCodeType instance4 = instantiatePostalCode( input4 );
125: 
126:         // when
127:         // then
128:         assertEquals( 1, instance1.getFirstDigitPostalCode() );
129:         assertEquals( 4, instance4.getFirstDigitPostalCode() );
130:     }
131: 
132: 
133: 
134:     @Test
135:     public void testInvalidParameters() {
136:         // given
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 _12345.distance( null ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testSamePostalCode() {
146:         // given
147:         // when
148:         int diff = _12345.distance( _12345b );
149: 
150:         // then
151:         assertEquals( 0, diff );
152:     }
153: 
154: 
155:     /**
156:      *      - The distance is > 0 if both postal codes differ in the last digit, like 5673x
157:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
158:      *        So, 56733 and 56734 have the same distance as 56733 and 56739.
159:      *      - The distance grows if more digits (counted from the right side) differ.
160:      *        So, 5abcd and 5rstu have a larger distance than 53bcd and 53stu (if abcd
161:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
162:      *        53876 and 54876 have the same distance as 53876 and 57261.
163:      */
164:     @Test
165:     public void testPostalCodeDistanceInAllButFirstDigit() {
166:         // given
167:         // when
168:         int diff5a = _01234.distance( _01235 );
169:         int diff5b = _01234.distance( _01238 );
170:         int diff4a = _01234.distance( _01263 );
171:         int diff4b = _01234.distance( _01213 );
172:         int diff3a = _01234.distance( _01823 );
173:         int diff3b = _01234.distance( _01312 );
174:         int diff2a = _01234.distance( _04233 );
175:         int diff2b = _01234.distance( _02544 );
176: 
177:         // then
178:         assertEquals( diff5a, diff5b, "distance 01234-01235 must be the same as distance 01234-01238" );
179:         assertEquals( diff4a, diff4b, "distance 01234-01263 must be the same as distance 01234-01213" );
180:         assertEquals( diff3a, diff3b, "distance 01234-01823 must be the same as distance 01234-01312" );
181:         assertEquals( diff2a, diff2b, "distance 01234-04233 must be the same as distance 01234-02544" );
182: 
183:         assertTrue( diff5a < diff4a,
184:                 "distance 01234-01235 must be smaller than distance 01234-01263" );
185:         assertTrue( diff4a < diff3a,
186:                 "distance 01234-01263 must be smaller than distance 01234-01823" );
187:         assertTrue( diff3a < diff2a,
188:                 "distance 01234-01823 must be smaller than distance 01234-04233" );
189:     }
190: 
191: 
192:     /**
193:      *      - However, the distance between 5abcd and 6rstu must be smaller than the one
194:      *        between 5abcd and 7rstu, and this distance in turn must be smaller than the
195:      *        one between 5abcd and 9rstu.
196:      *      - This last condition reflects the fact the first digits of a postal code marks a region
197:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
198:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
199:      *        other.
200:      */
201:     @Test
202:     public void testPostalCodedistanceInFirstDigit() {
203:         // given
204:         // when
205:         int diff1_1 = _01234.distance( _99123 );
206:         int diff1_2 = _01234.distance( _23455 );
207:         int diff1_5 = _01234.distance( _56323 );
208:         int diff1_3 = _01234.distance( _79332 );
209: 
210:         // then
211:         assertTrue( diff1_1 < diff1_2,
212:                 "distance 01234-99123 must be smaller than distance 01234-23455"  );
213:         assertTrue( diff1_2 < diff1_3,
214:                 "distance 01234-23455 must be smaller than distance 01234-79332" );
215:         assertTrue( diff1_3 < diff1_5,
216:                 "distance 01234-79332 must be smaller than distance 01234-56323"  );
217:     }
218: 
219: 
220: 
221: }
222: 
223: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
1: package thkoeln.archilab.ecommerce.tests.e1restcalls;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;
5: 
6: 
7: public class E1RestCallTableTest {
8: 
9:     private GenericTableSpecificationTests genericTableSpecificationTests = null;
10: 
11: 
12:     public E1RestCallTableTest() {
13:         this.genericTableSpecificationTests = new GenericTableSpecificationTests();
14:     }
15: 
16:     @Test
17:     public void restTest() throws Exception {
18:         genericTableSpecificationTests.testTableSpecification("E1" );
19:     }
20: }
21: 
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\order\OrderTest.java ---
1: package thkoeln.archilab.ecommerce.tests.order;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.WarehouseTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: 
15: import java.util.Map;
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.assertEquals;
19: import static org.junit.jupiter.api.Assertions.assertThrows;
20: 
21: 
22: @SpringBootTest
23: public class OrderTest {
24:     @Autowired
25:     private UserRegistrationUseCases userRegistrationUseCases;
26:     @Autowired
27:     private ShoppingCartUseCases shoppingCartUseCases;
28:     @Autowired
29:     private ProductCatalogUseCases productCatalogUseCases;
30:     @Autowired
31:     private WarehouseUseCases warehouseUseCases;
32:     @Autowired
33:     private OrderUseCases orderUseCases;
34:     @Autowired
35:     private Purgatory purgatory;
36:     @Autowired
37:     private UserTestHelper userTestHelper;
38:     @Autowired
39:     private ProductTestHelper productTestHelper;
40:     @Autowired
41:     private WarehouseTestHelper warehouseTestHelper;
42: 
43:     private UUID nonExistingId1;
44:     private UUID nonExistingId2;
45: 
46:     @BeforeEach
47:     public void setUp() {
48:         purgatory.deleteEverything();
49:         userTestHelper.registerAllUsers();
50:         productTestHelper.addAllProducts();
51:         warehouseTestHelper.addAllWarehouses( true );
52:         nonExistingId1 = UUID.randomUUID();
53:         nonExistingId2 = UUID.randomUUID();
54:     }
55: 
56: 
57:     @Test
58:     public void testOrderHistory() {
59:         // given
60:         UUID productId1 = productTestHelper.getProductId( 1 );
61:         UUID productId2 = productTestHelper.getProductId( 2 );
62:         EmailAddressType userEmailAddress7 =
63:                 userTestHelper.getUserEmailAddress( 7 );
64:         Map<UUID, Integer> orderHistoryBefore = orderUseCases.getOrderHistory( userEmailAddress7 );
65: 
66:         // when
67:         shoppingCartUseCases.addProductToShoppingCart(
68:                 userEmailAddress7, productId1, 3 );
69:         shoppingCartUseCases.addProductToShoppingCart(
70:                 userEmailAddress7, productId2, 2 );
71:         shoppingCartUseCases.checkout( userEmailAddress7 );
72:         Map<UUID, Integer> orderHistory1 =
73:                 orderUseCases.getOrderHistory( userEmailAddress7 );
74:         shoppingCartUseCases.addProductToShoppingCart(
75:                 userEmailAddress7, productId1, 6 );
76:         shoppingCartUseCases.addProductToShoppingCart(
77:                 userEmailAddress7, productId2, 2 );
78:         shoppingCartUseCases.checkout( userEmailAddress7 );
79:         Map<UUID, Integer> orderHistory2 =
80:                 orderUseCases.getOrderHistory( userEmailAddress7 );
81:         shoppingCartUseCases.addProductToShoppingCart(
82:                 userEmailAddress7, productId1, 1 );
83:         shoppingCartUseCases.addProductToShoppingCart(
84:                 userEmailAddress7, productId2, 6 );
85:         shoppingCartUseCases.checkout( userEmailAddress7 );
86:         Map<UUID, Integer> orderHistory3 =
87:                 orderUseCases.getOrderHistory( userEmailAddress7 );
88: 
89:         // then
90:         assertEquals( 0, orderHistoryBefore.size() );
91:         assertEquals( 2, orderHistory1.size() );
92:         assertEquals( 2, orderHistory2.size() );
93:         assertEquals( 2, orderHistory3.size() );
94:         assertEquals( 3, orderHistory1.get( productId1 ) );
95:         assertEquals( 2, orderHistory1.get( productId2 ) );
96:         assertEquals( 9, orderHistory2.get( productId1 ) );
97:         assertEquals( 4, orderHistory2.get( productId2 ) );
98:         assertEquals( 10, orderHistory3.get( productId1 ) );
99:         assertEquals( 10, orderHistory3.get( productId2 ) );
100:     }
101: 
102: 
103:     @Test
104:     public void testForEmptyOrderHistory() {
105:         // given
106:         EmailAddressType userEmailAddress4 =
107:                 userTestHelper.getUserEmailAddress( 4 );
108:         // when
109:         Map<UUID, Integer> orderHistory =
110:                 orderUseCases.getOrderHistory( userEmailAddress4 );
111:         // then
112:         assertEquals( 0, orderHistory.size() );
113:     }
114: 
115: 
116:     @Test
117:     public void testInvalidParamsForGetOrderQuantiOfProduct() {
118:         // given
119:         UUID warehouseId0 = warehouseTestHelper.getWarehouseId( 0 );
120: 
121:         // when / then
122:         assertThrows ( ShopException.class,
123:                 () -> orderUseCases.getOrderQuantiOfProduct( null, null ) );
124:         assertThrows ( ShopException.class,
125:                 () -> orderUseCases.getOrderQuantiOfProduct( nonExistingId1, null ) );
126:         assertThrows ( ShopException.class,
127:                 () -> orderUseCases.getOrderQuantiOfProduct( null, nonExistingId2 ) );
128:         assertThrows ( ShopException.class,
129:                 () -> orderUseCases.getOrderQuantiOfProduct( nonExistingId1, nonExistingId2 ) );
130:         assertThrows ( ShopException.class,
131:                 () -> orderUseCases.getOrderQuantiOfProduct( warehouseId0, null ) );
132:         assertThrows ( ShopException.class,
133:                 () -> orderUseCases.getOrderQuantiOfProduct( warehouseId0, nonExistingId2 ) );
134:     }
135: 
136: 
137:     @Test
138:     public void testInvalidParamsForGetWarehouseIdForOrder() {
139:         // given / when / then
140:         assertThrows ( ShopException.class,
141:                 () -> orderUseCases.getWarehouseIdForOrder( null ) );
142:         assertThrows ( ShopException.class,
143:                 () -> orderUseCases.getWarehouseIdForOrder( nonExistingId1 ) );
144:     }
145: }
146: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import com.fasterxml.jackson.databind.JsonNode;
4: import com.fasterxml.jackson.databind.ObjectMapper;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: import thkoeln.archilab.ecommerce.domainprimitives.AddressLocation;
8: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
9: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
10: import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;
11: 
12: import static org.junit.jupiter.api.Assertions.*;
13: 
14: 
15: public class DomainPrimitiveJSONSerializationTest {
16:     
17:     private ObjectMapper objectMapper;
18: 
19:     @BeforeEach
20:     public void setUp() {
21:         objectMapper = new ObjectMapper();
22:     }
23: 
24: 
25:     /**
26:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
27:      * EmailAddress.
28:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
29:      * on how to implement this test, and how to change property names.
30:      * @throws Exception
31:      */
32:     @Test
33:     public void test_EmailAddress_Serialization() throws Exception {
34:         // given
35:         EmailAddress email = EmailAddress.of("test@example.com");
36:         
37:         // when
38:         String json = objectMapper.writeValueAsString(email);
39:         JsonNode jsonNode = objectMapper.readTree(json);
40:         EmailAddress deserializedEmail = objectMapper.readValue(json, EmailAddress.class);
41:         
42:         // then
43:         assertTrue(jsonNode.has("emailAddressString"));
44:         assertEquals("test@example.com", jsonNode.get("emailAddressString").asText());
45:         assertEquals(email, deserializedEmail);
46:     }
47: 
48: 
49:     /**
50:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
51:      * PostalCode.
52:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
53:      * on how to implement this test, and how to change property names.
54:      * @throws Exception
55:      */
56:     @Test
57:     public void test_PostalCode_Serialization() throws Exception {
58:         // given
59:         PostalCode postalCode = PostalCode.of("12345");
60:         
61:         // when
62:         String json = objectMapper.writeValueAsString(postalCode);
63:         JsonNode jsonNode = objectMapper.readTree(json);
64:         PostalCode deserializedPostalCode = objectMapper.readValue(json, PostalCode.class);
65:         
66:         // then
67:         assertTrue(jsonNode.has("postalCodeString"));
68:         assertEquals("12345", jsonNode.get("postalCodeString").asText());
69:         assertEquals(postalCode, deserializedPostalCode);
70:     }
71: 
72: 
73:     /**
74:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
75:      * AddressLocation.
76:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
77:      * on how to implement this test, and how to change property names.
78:      * @throws Exception
79:      */
80:     @Test
81:     public void test_AddressLocation_Serialization() throws Exception {
82:         // given
83:         PostalCode postalCode = PostalCode.of("50678");
84:         AddressLocation address = AddressLocation.of("Muster Str. 123", "Köln", postalCode);
85:         
86:         // when
87:         String json = objectMapper.writeValueAsString(address);
88:         JsonNode jsonNode = objectMapper.readTree(json);
89:         AddressLocation deserializedAddress = objectMapper.readValue(json, AddressLocation.class);
90:         
91:         // then
92:         assertTrue(jsonNode.has("street"));
93:         assertTrue(jsonNode.has("city"));
94:         assertTrue(jsonNode.has("postalCode"));
95:         assertEquals("Muster Str. 123", jsonNode.get("street").asText());
96:         assertEquals("Köln", jsonNode.get("city").asText());
97:         assertTrue(jsonNode.get("postalCode").has("postalCodeString"));
98:         assertEquals("50678", jsonNode.get("postalCode").get("postalCodeString").asText());
99:         assertEquals(address, deserializedAddress);
100:     }
101: 
102: 
103:     /**
104:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
105:      * Currency.
106:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
107:      * on how to implement this test, and how to change property names.
108:      * @throws Exception
109:      */
110:     @Test
111:     public void test_Currency_Serialization() throws Exception {
112:         // given
113:         Currency currency = Currency.of(25.50f, "EUR");
114:         
115:         // when
116:         String json = objectMapper.writeValueAsString(currency);
117:         JsonNode jsonNode = objectMapper.readTree(json);
118:         Currency deserializedCurrency = objectMapper.readValue(json, Currency.class);
119:         
120:         // then
121:         assertTrue(jsonNode.has("quantity"));
122:         assertTrue(jsonNode.has("currencyUnit"));
123:         assertEquals(25.50f, jsonNode.get("quantity").floatValue(), 0.01f);
124:         assertEquals("EUR", jsonNode.get("currencyUnit").asText());
125:         assertEquals(currency, deserializedCurrency);
126:     }
127: 
128: }
129: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingCartRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
12: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
13: import thkoeln.archilab.ecommerce.usecases.masterdata.WarehouseTestHelper;
14: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
15: 
16: import org.springframework.test.web.servlet.result.MockMvcResultMatchers;
17: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
18: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
19: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
20: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
21: 
22: import java.util.*;
23: 
24: import static org.junit.jupiter.api.Assertions.*;
25: 
26: 
27: @SpringBootTest
28: @Transactional
29: @AutoConfigureMockMvc
30: @Import( RESTTestHelperConfiguration.class )
31: public class OwnShoppingCartRESTTest {
32:     @Autowired
33:     private Purgatory purgatory;
34:     @Autowired
35:     private UserTestHelper userTestHelper;
36:     @Autowired
37:     private ProductTestHelper productTestHelper;
38:     @Autowired
39:     private WarehouseTestHelper warehouseTestHelper;
40:     @Autowired
41:     private ShoppingCartRESTHelper shoppingCartRESTHelper;
42:     @Autowired
43:     private ShoppingCartUseCases shoppingCartUseCases;
44: 
45:     @BeforeEach
46:     public void setUp() {
47:         purgatory.deleteEverything();
48:         userTestHelper.registerAllUsers();
49:         productTestHelper.addAllProducts();
50:         warehouseTestHelper.addAllWarehouses( true );
51: 
52:         // ... add own setup code here
53:     }
54: 
55: 
56:     /**
57:      * Provide a test that implements a simple call to the REST endpoint (3):
58:      * <pre>
59:      *     GET /shoppingCarts?userId=<user id as uuid>
60:      * </pre>
61:      * - Use the {@link UserTestHelper} to obtain to obtain the email address
62:      *   of some example user.
63:      * - Use your shopping cart service to add entries to the shopping cart of that person.
64:      * - then use the `ShoppingCartRESTHelper` to create the GET call, and check the results.
65:      * - (or do it by directly calling your REST controller, if you prefer)
66:      * @throws Exception
67:      */
68:     @Test
69:     public void test_getQuery_ShoppingCart() throws Exception {
70:         // given
71:         EmailAddressType userEmail = userTestHelper.getUserEmailAddress(1);
72:         // Ensure concrete EmailAddress class usage for ArchUnit rule compliance
73:         EmailAddress.of("test@example.com"); // Creates dependency on EmailAddress concrete class
74:         UUID productId = productTestHelper.getProductId(1);
75:         
76:         // Add some products to the shopping cart using service
77:         shoppingCartUseCases.addProductToShoppingCart(userEmail, productId, 2);
78:         
79:         // Create expected quantities map
80:         Map<UUID, Integer> expectedQuantities = new HashMap<>();
81:         expectedQuantities.put(productId, 2);
82:         
83:         // when & then
84:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart(userEmail, expectedQuantities);
85:         
86:         // Verify we got a valid shopping cart ID
87:         assertNotNull(shoppingCartId);
88:     }
89: 
90: 
91: 
92:     /**
93:      * Provide a test that implements the addition of one product to the shopping cart via
94:      * REST endpoint (6):
95:      * <pre>
96:      *     POST /shoppingCarts/{shoppingCart-Id}/parts
97:      * </pre>
98:      * You can test now "the other way around" as in test_getQuery_ShoppingCart():
99:      * - Use `ShoppingCartRESTHelper` to add products via REST, then use shopping cart service methods
100:      *   to check of the shopping cart contains the right stuff.
101:      * - (or do it by directly calling your REST controller, if you prefer)
102:      *
103:      * @throws Exception
104:      */
105:     @Test
106:     public void test_post_ShoppingCartParts() throws Exception {
107:         // given
108:         EmailAddressType userEmail = userTestHelper.getUserEmailAddress(2);
109:         UUID productId = productTestHelper.getProductId(2);
110:         
111:         // Get the shopping cart ID first
112:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart(userEmail, null);
113:         
114:         // when
115:         shoppingCartRESTHelper.addProductToShoppingCart(shoppingCartId, productId, 3);
116:         
117:         // then
118:         // Verify using the service that the product was added
119:         Map<UUID, Integer> cartContents = shoppingCartUseCases.getShoppingCartAsMap(userEmail);
120:         assertEquals(3, cartContents.get(productId));
121:     }
122: 
123: 
124: 
125:     /**
126:      * Provide a test that implements the deletion of one product in the shopping cart via
127:      * REST endpoint (10):
128:      * <pre>
129:      *     DELETE /shoppingCarts/{shoppingCart-Id}/parts/{product-Id}
130:      * </pre>
131:      * This should be just a slight variation of the test_post_ShoppingCartParts()
132:      * method, but instead of adding an product to the shopping cart, you delete it.
133:      *
134:      * @throws Exception
135:      */
136:     @Test
137:     public void test_delete_ShoppingCartParts() throws Exception {
138:         // given
139:         EmailAddressType userEmail = userTestHelper.getUserEmailAddress(3);
140:         UUID productId = productTestHelper.getProductId(3);
141:         
142:         // Add product first using service
143:         shoppingCartUseCases.addProductToShoppingCart(userEmail, productId, 5);
144:         
145:         // Get the shopping cart ID
146:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart(userEmail, null);
147:         
148:         // when
149:         shoppingCartRESTHelper.deleteProductFromShoppingCart(shoppingCartId, productId);
150:         
151:         // then
152:         // Verify using the service that the product was removed
153:         Map<UUID, Integer> cartContents = shoppingCartUseCases.getShoppingCartAsMap(userEmail);
154:         assertTrue(cartContents.isEmpty() || !cartContents.containsKey(productId) || cartContents.get(productId) == 0);
155:     }
156: 
157: 
158: 
159:     /**
160:      * Provide a test that implements the checkout of a shopping cart that can be served
161:      * by just 1 warehouse, using the REST endpoint (11):
162:      * <pre>
163:      *     POST /shoppingCarts/{shoppingCart-Id}/checkout
164:      * </pre>
165:      * - Use your shopping cart service to add entries to the shopping cart of some example user,
166:      * - then use the `ShoppingCartRESTHelper to post the checkout call, and to check the results.
167:      * - (or do it by directly calling your REST controller, if you prefer)
168:      *
169:      * @throws Exception
170:      */
171:     @Test
172:     public void test_checkout_1_warehouse() throws Exception {
173:         // given
174:         EmailAddressType userEmail = userTestHelper.getUserEmailAddress(4);
175:         
176:         // Add products that can be served by a single warehouse (warehouse 0 has products 1,2,3)
177:         UUID productId1 = productTestHelper.getProductId(1);
178:         UUID productId2 = productTestHelper.getProductId(2);
179:         
180:         shoppingCartUseCases.addProductToShoppingCart(userEmail, productId1, 1);
181:         shoppingCartUseCases.addProductToShoppingCart(userEmail, productId2, 1);
182:         
183:         // Get the shopping cart ID
184:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart(userEmail, null);
185:         
186:         // Prepare expected order structure (one warehouse should handle both products)
187:         UUID warehouseId0 = warehouseTestHelper.getWarehouseId(0);
188:         Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>();
189:         Map<UUID, Integer> warehouse0Products = new HashMap<>();
190:         warehouse0Products.put(productId1, 1);
191:         warehouse0Products.put(productId2, 1);
192:         expectedOrders.put(warehouseId0, warehouse0Products);
193:         
194:         // when & then
195:         String expectedUserName = userTestHelper.getUserName(4);
196:         shoppingCartRESTHelper.checkout(shoppingCartId, expectedUserName, 
197:                                        MockMvcResultMatchers.status().isCreated(), 
198:                                        expectedOrders);
199:     }
200: 
201: 
202: 
203:     /**
204:      * Provide a test that implements the checkout of a shopping cart that can only be served
205:      * by using 2 warehouses, using the REST endpoint (11):
206:      * <pre>
207:      *     POST /shoppingCarts/{shoppingCart-Id}/checkout
208:      * </pre>
209:      * This should be just a slight variation of thetest_checkout_1_warehouse() test.
210:      *
211:      * @throws Exception
212:      */
213:     @Test
214:     public void test_checkout_2_warehouses() throws Exception {
215:         // given
216:         EmailAddressType userEmail = userTestHelper.getUserEmailAddress(5);
217:         
218:         // Add products that require 2 warehouses (based on test helper distribution)
219:         // Product 8: Available in W4(3), W6(3), W7(110*)
220:         // Product 12: Available only in W5(92*)
221:         UUID productId8 = productTestHelper.getProductId(8);
222:         UUID productId12 = productTestHelper.getProductId(12);
223:         
224:         shoppingCartUseCases.addProductToShoppingCart(userEmail, productId8, 2);
225:         shoppingCartUseCases.addProductToShoppingCart(userEmail, productId12, 5);
226:         
227:         // Get the shopping cart ID
228:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart(userEmail, null);
229:         
230:         // Prepare expected order structure (should require 2 warehouses)
231:         UUID warehouseId5 = warehouseTestHelper.getWarehouseId(5);
232:         UUID warehouseId7 = warehouseTestHelper.getWarehouseId(7);
233:         
234:         Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>();
235:         
236:         // Warehouse 5 should handle product 12
237:         Map<UUID, Integer> warehouse5Products = new HashMap<>();
238:         warehouse5Products.put(productId12, 5);
239:         expectedOrders.put(warehouseId5, warehouse5Products);
240:         
241:         // Warehouse 7 should handle product 8 (closest with sufficient capacity)
242:         Map<UUID, Integer> warehouse7Products = new HashMap<>();
243:         warehouse7Products.put(productId8, 2);
244:         expectedOrders.put(warehouseId7, warehouse7Products);
245:         
246:         // when & then
247:         String expectedUserName = userTestHelper.getUserName(5);
248:         shoppingCartRESTHelper.checkout(shoppingCartId, expectedUserName, 
249:                                        MockMvcResultMatchers.status().isCreated(), 
250:                                        expectedOrders);
251:     }
252: 
253: }
254: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\product\ProductCatalogTest.java ---
1: package thkoeln.archilab.ecommerce.tests.product;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
9: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.WarehouseUseCases;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
15: 
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.*;
19: 
20: 
21: @SpringBootTest
22: public class ProductCatalogTest {
23:     @Autowired
24:     private UserRegistrationUseCases userRegistrationUseCases;
25:     @Autowired
26:     private ShoppingCartUseCases shoppingCartUseCases;
27:     @Autowired
28:     private ProductCatalogUseCases productCatalogUseCases;
29:     @Autowired
30:     private WarehouseUseCases warehouseUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private UserTestHelper userTestHelper;
35:     @Autowired
36:     private ProductTestHelper productTestHelper;
37:     @Autowired
38:     private WarehouseTestHelper warehouseTestHelper;
39: 
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         userTestHelper.registerAllUsers();
45:         productTestHelper.addAllProducts();
46:     }
47: 
48: 
49:     @Test
50:     public void testAddProductToCatalog() {
51:         // given
52:         UUID productId4 = productTestHelper.getProductId( 4 );
53:         CurrencyType salesPrice4 = productTestHelper.getSalesPrice( 4 );
54: 
55:         // when
56:         CurrencyType foundSalesPrice = productCatalogUseCases.getSalesPrice( productId4 );
57: 
58:         // then
59:         assertEquals( salesPrice4, foundSalesPrice );
60:     }
61: 
62: 
63:     @Test
64:     public void testAddProductWithInvalidData() {
65:         // given
66:         String name = "SomeStuff";
67:         String description = "Some more explanation on the stuff";
68:         Float size = 5.0f;
69:         CurrencyType buyingPrice =
70:                 FactoryMethodInvoker.instantiateCurrency( 5.0f, "EUR" );
71:         CurrencyType salesPrice =
72:                 FactoryMethodInvoker.instantiateCurrency( 10.0f, "EUR" );
73:         CurrencyType tooLowSalesPrice =
74:                 FactoryMethodInvoker.instantiateCurrency( 4.0f, "EUR" );
75: 
76:         // when / then
77:         assertThrows( ShopException.class, () ->
78:                 productCatalogUseCases.addProductToCatalog(
79:                         null, description, size, buyingPrice, salesPrice ) );
80:         assertThrows( ShopException.class, () ->
81:                 productCatalogUseCases.addProductToCatalog(
82:                         "", description, size, buyingPrice, salesPrice ) );
83:         assertThrows( ShopException.class, () ->
84:                 productCatalogUseCases.addProductToCatalog(
85:                         name, null, size, buyingPrice, salesPrice ) );
86:         assertThrows( ShopException.class, () ->
87:                 productCatalogUseCases.addProductToCatalog(
88:                         name, "", size, buyingPrice, salesPrice ) );
89:         assertThrows( ShopException.class, () ->
90:                 productCatalogUseCases.addProductToCatalog(
91:                         name, description, size, null, salesPrice ) );
92:         assertThrows( ShopException.class, () ->
93:                 productCatalogUseCases.addProductToCatalog(
94:                         name, description, size, buyingPrice, null ) );
95:         assertThrows( ShopException.class, () ->
96:                 productCatalogUseCases.addProductToCatalog(
97:                         name, description, size, buyingPrice, tooLowSalesPrice ) );
98:     }
99: 
100: 
101:     @Test
102:     public void testRemoveNonExistentProduct() {
103:         // given product 2 is not in inventory anywhere - should be removable
104:         UUID nonExistentProductId = UUID.randomUUID();
105: 
106:         // when
107:         // then
108:         assertThrows( ShopException.class,
109:                 () -> productCatalogUseCases.removeProductFromCatalog( nonExistentProductId ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testRemoveProductWithNoInventory() {
115:         // given product 0 is not in inventory anywhere - should be removable
116:         UUID productId0 = productTestHelper.getProductId( 0 );
117:         warehouseTestHelper.addAllWarehouses( true );
118: 
119:         // when
120:         assertDoesNotThrow( () -> productCatalogUseCases.getSalesPrice( productId0 ) );
121:         productCatalogUseCases.removeProductFromCatalog( productId0 );
122: 
123:         // then
124:         assertThrows( ShopException.class, () ->
125:                 productCatalogUseCases.getSalesPrice( productId0 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testRemoveProductThatIsInInventory() {
131:         // given
132:         warehouseTestHelper.addAllWarehouses( false );
133:         UUID warehouseId0 = warehouseTestHelper.getWarehouseId( 0 );
134:         UUID productId3 = productTestHelper.getProductId( 3 );
135:         UUID productId4 = productTestHelper.getProductId( 4 );
136:         warehouseUseCases.addToInventory( warehouseId0, productId3, 3 );
137: 
138:         // then product 3 must not be removable, but product 4 must be removable
139:         assertThrows( ShopException.class,
140:                 () -> productCatalogUseCases.removeProductFromCatalog( productId3 ) );
141:         assertDoesNotThrow( () -> productCatalogUseCases.removeProductFromCatalog( productId4 ) );
142:     }
143: 
144: 
145:     @Test
146:     public void testRemoveProductThatIsInOrder() {
147:         // given
148:         warehouseTestHelper.addAllWarehouses( false );
149:         UUID warehouseId0 = warehouseTestHelper.getWarehouseId( 0 );
150:         UUID productId4 = productTestHelper.getProductId( 4 );
151:         EmailAddressType userEmailAddress4 =
152:                 userTestHelper.getUserEmailAddress( 4 );
153:         warehouseUseCases.addToInventory( warehouseId0, productId4, 4 );
154: 
155:         // when user 4 adds 4x product 4 to his shopping cart and checks out ...
156:         shoppingCartUseCases.addProductToShoppingCart(
157:                 userEmailAddress4, productId4, 4 );
158:         shoppingCartUseCases.checkout( userEmailAddress4 );
159: 
160:         // then product 4 must not be removable
161:         assertThrows( ShopException.class,
162:                 () -> productCatalogUseCases.removeProductFromCatalog( productId4 ) );
163:     }
164: 
165: 
166:     @Test
167:     public void testClearProductCatalog() {
168:         // given
169:         UUID productId4 = productTestHelper.getProductId( 4 );
170: 
171:         // when
172:         productCatalogUseCases.deleteProductCatalog();
173: 
174:         // then
175:         assertThrows( ShopException.class, () -> productCatalogUseCases.getSalesPrice( productId4 ) );
176:     }
177: 
178: }
179: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\CheckoutAcceptanceTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingcart;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.WarehouseTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: 
15: import java.util.*;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: 
19: /**
20:  * This test checks the management of inventory across warehouses. It focuses on the
21:  * cases where more than one warehouse are needed to serve the shopping cart of a user.
22:  */
23: @Slf4j
24: @SpringBootTest
25: public class CheckoutAcceptanceTest {
26:     @Autowired
27:     private UserRegistrationUseCases userRegistrationUseCases;
28:     @Autowired
29:     private ShoppingCartUseCases shoppingCartUseCases;
30:     @Autowired
31:     private ProductCatalogUseCases productCatalogUseCases;
32:     @Autowired
33:     private OrderUseCases orderUseCases;
34:     @Autowired
35:     private WarehouseUseCases warehouseUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private UserTestHelper userTestHelper;
40:     @Autowired
41:     private ProductTestHelper productTestHelper;
42:     @Autowired
43:     private WarehouseTestHelper warehouseTestHelper;
44: 
45:     private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
46:                                 map8_11_14_quantity_3_3_4,
47:                                 map10_12_quantity_1_1, 
48:                                 map11_quantity_1, 
49:                                 map12_quantity_10,
50:                                 map8_9_10_11_quantity_2_1_4_2;
51:     private EmailAddressType userEmailAddress3, userEmailAddress6,
52:             userEmailAddress2;
53:     private UUID productId8, productId9, productId10, productId11, productId12,
54:             productId14;
55: 
56: 
57:     @BeforeEach
58:     public void setUp() {
59:         purgatory.deleteEverything();
60:         userTestHelper.registerAllUsers();
61:         productTestHelper.addAllProducts();
62:         warehouseTestHelper.addAllWarehouses( true );
63: 
64:         userEmailAddress3 = userTestHelper.getUserEmailAddress( 3 );
65:         userEmailAddress6 = userTestHelper.getUserEmailAddress( 6 );
66:         userEmailAddress2 = userTestHelper.getUserEmailAddress( 2 );
67: 
68:         productId8 = productTestHelper.getProductId( 8 );
69:         productId9 = productTestHelper.getProductId( 9 );
70:         productId10 = productTestHelper.getProductId( 10 );
71:         productId11 = productTestHelper.getProductId( 11 );
72:         productId12 = productTestHelper.getProductId( 12 );
73:         productId14 = productTestHelper.getProductId( 14 );
74: 
75:         map8_11_14_quantity_2_2_2 = new HashMap<>() {{
76:             put( productId8, 2 );
77:             put( productId11, 2 );
78:             put( productId14, 2 );
79:         }};
80:         map8_11_14_quantity_3_3_4 = new HashMap<>() {{
81:             put( productId8, 3 );
82:             put( productId11, 3 );
83:             put( productId14, 4 );
84:         }};
85:         map10_12_quantity_1_1 = new HashMap<>() {{
86:             put( productId10, 1 );
87:             put( productId12, 1 );
88:         }};
89:         map11_quantity_1 = new HashMap<>() {{
90:             put( productId11, 1 );
91:         }};
92:         map12_quantity_10 = new HashMap<>() {{
93:             put( productId12, 10 );
94:         }};
95:         map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
96:             put( productId8, 2 );
97:             put( productId9, 1 );
98:             put( productId10, 4 );
99:             put( productId11, 2 );
100:         }};
101: 
102:     }
103: 
104: 
105:     /**
106:      * Hint: to better understand the expected results of this test, see the distribution of inventory
107:      * across warehouses, as specified in the WarehouseTestHelper and in the README file.
108:      */
109:     @Test
110:     public void testClosestSingleWarehouseWins() {
111:         log.info( "testClosestSingleWarehouseWins" );
112: 
113:         // given
114:         shoppingCartUseCases.addProductToShoppingCart(
115:                 userEmailAddress3, productId8, 2 );
116:         shoppingCartUseCases.addProductToShoppingCart(
117:                 userEmailAddress3, productId11, 2 );
118:         shoppingCartUseCases.addProductToShoppingCart(
119:                 userEmailAddress3, productId14, 2 );
120:         // that basket could have been served from warehouse 4 or 7, but 4 is closer to the user
121:         UUID warehouseId4 = warehouseTestHelper.getWarehouseId( 4 );
122: 
123:         // when
124:         Set<UUID> orderIds = shoppingCartUseCases.checkout( userEmailAddress3 );
125: 
126:         // then
127:         checkWarehouseIds( orderIds, warehouseId4 );
128:         checkProductNumbers( orderIds, warehouseId4, map8_11_14_quantity_2_2_2 );
129:     }
130: 
131: 
132:     /**
133:      * Hint: to better understand the expected results of this test, see the distribution of inventory
134:      * across warehouses, as specified in the WarehouseTestHelper and in the README file.
135:      */
136:     @Test
137:     public void testWarehouseWithEnoughCapacityWins() {
138:         log.info( "testWarehouseWithEnoughCapacityWins" );
139: 
140:         // given
141:         shoppingCartUseCases.addProductToShoppingCart(
142:                 userEmailAddress3, productId8, 3 );
143:         shoppingCartUseCases.addProductToShoppingCart(
144:                 userEmailAddress3, productId11, 3 );
145:         shoppingCartUseCases.addProductToShoppingCart(
146:                 userEmailAddress3, productId14, 4 );
147:         // that basket could have been served from warehouse 4 or 7, 4 is closer to the user,
148:         // but only 7 has enough capacity
149:         UUID warehouseId7 = warehouseTestHelper.getWarehouseId( 7 );
150: 
151:         // when
152:         Set<UUID> orderIds = shoppingCartUseCases.checkout( userEmailAddress3 );
153: 
154:         // then
155:         checkWarehouseIds( orderIds, warehouseId7 );
156:         checkProductNumbers( orderIds, warehouseId7, map8_11_14_quantity_3_3_4 );
157:     }
158: 
159: 
160:     /**
161:      * Hint: to better understand the expected results of this test, see the distribution of inventory
162:      * across warehouses, as specified in the WarehouseTestHelper and in the README file.
163:      */
164:     @Test
165:     public void testTwoWarehouses() {
166:         log.info( "testTwoWarehouses" );
167: 
168:         // given
169:         shoppingCartUseCases.addProductToShoppingCart(
170:                 userEmailAddress6, productId10, 1 );
171:         shoppingCartUseCases.addProductToShoppingCart(
172:                 userEmailAddress6, productId11, 1 );
173:         shoppingCartUseCases.addProductToShoppingCart(
174:                 userEmailAddress6, productId12, 1 );
175:         // that basket needs two deliveries (2 + 1 products) anyway, and there
176:         // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
177:         // closer. The smaller can then be served from 4 (closest), 7, or 8.
178:         UUID warehouseId5 = warehouseTestHelper.getWarehouseId( 5 );
179:                 // should cover map10_12_quantity_1_1
180:         UUID warehouseId4 = warehouseTestHelper.getWarehouseId( 4 );
181:                 // should cover map11_quantity_1
182: 
183:         // when
184:         Set<UUID> orderIds = shoppingCartUseCases.checkout( userEmailAddress6 );
185: 
186:         // then
187:         checkWarehouseIds( orderIds, warehouseId5, warehouseId4 );
188:         checkProductNumbers( orderIds, warehouseId5, map10_12_quantity_1_1 );
189:         checkProductNumbers( orderIds, warehouseId4, map11_quantity_1 );
190:     }
191: 
192: 
193:     /**
194:      * Hint: to better understand the expected results of this test, see the distribution of inventory
195:      * across warehouses, as specified in the WarehouseTestHelper and in the README file.
196:      */
197:     @Test
198:     public void testTwoBigDeliverys() {
199:         log.info( "testTwoBigDeliverys" );
200: 
201:         // given
202:         shoppingCartUseCases.addProductToShoppingCart(
203:                 userEmailAddress2, productId8, 2 );
204:         shoppingCartUseCases.addProductToShoppingCart(
205:                 userEmailAddress2, productId9, 1 );
206:         shoppingCartUseCases.addProductToShoppingCart(
207:                 userEmailAddress2, productId10, 4 );
208:         shoppingCartUseCases.addProductToShoppingCart(
209:                 userEmailAddress2, productId11, 2 );
210:         shoppingCartUseCases.addProductToShoppingCart(
211:                 userEmailAddress2, productId12, 10 );
212:         // when
213:         Set<UUID> orderIds = shoppingCartUseCases.checkout( userEmailAddress2 );
214:         UUID warehouseId7 = warehouseTestHelper.getWarehouseId( 7 );
215:                 // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 products
216:         UUID warehouseId5 = warehouseTestHelper.getWarehouseId( 5 );
217:                 // should cover map12_quantity_10 - the only warehouse with enough capacity for 10 products
218: 
219:         // then
220:         checkWarehouseIds( orderIds, warehouseId7, warehouseId5 );
221:         checkProductNumbers( orderIds, warehouseId7, map8_9_10_11_quantity_2_1_4_2 );
222:         checkProductNumbers( orderIds, warehouseId5, map12_quantity_10 );
223:     }
224: 
225: 
226:     /**
227:      * Hint: to better understand the expected results of this test, see the distribution of inventory
228:      * across warehouses, as specified in the WarehouseTestHelper and in the README file.
229:      */
230:     @Test
231:     public void testOnlyOneSolution() {
232:         log.info( "testOnlyOneSolution" );
233: 
234:         // given
235:         shoppingCartUseCases.addProductToShoppingCart(
236:                 userEmailAddress6, productId12, 10 );
237:         // when
238:         Set<UUID> orderIds = shoppingCartUseCases.checkout( userEmailAddress6 );
239:         UUID warehouseId5 = warehouseTestHelper.getWarehouseId( 5 );
240:         // should cover map12_quantity_10 - the only warehouse with enough capacity for 10 products
241: 
242:         // then
243:         checkWarehouseIds( orderIds, warehouseId5 );
244:         checkProductNumbers( orderIds, warehouseId5, map12_quantity_10 );
245:     }
246: 
247: 
248: 
249:     private void checkProductNumbers( Set<UUID> orderIds, UUID warehouseId, Map<UUID, Integer> expectedMap ) {
250:         UUID fittingOrderId = null;
251:         for ( UUID orderId : orderIds ) {
252:             UUID foundWarehouseId = orderUseCases.getWarehouseIdForOrder( orderId );
253:             if ( foundWarehouseId.equals( warehouseId ) ) {
254:                 fittingOrderId = orderId;
255:                 break;
256:             }
257:         }
258:         assertNotNull( fittingOrderId, "No fitting order found for warehouse " + warehouseId );
259: 
260:         int totalExpected = 0;
261:         int totalActual = 0;
262:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
263:             totalExpected += entry.getValue();
264:         }
265:         log.info( "Check order numbers for product {} in warehouse {}", fittingOrderId, warehouseId );
266:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
267:             UUID productId = entry.getKey();
268:             Integer foundNumber =
269:                     orderUseCases.getOrderQuantiOfProduct( fittingOrderId, productId );
270:             assertEquals( entry.getValue(), foundNumber );
271:             totalActual += foundNumber;
272:         }
273:         // last check - do the total sums match?
274:         assertEquals( totalExpected, totalActual );
275:     }
276: 
277: 
278:     private void checkWarehouseIds( Set<UUID> orderIds, UUID... expectedWarehouseIds ) {
279:         assertEquals( expectedWarehouseIds.length, orderIds.size() );
280:         Set<UUID> foundWarehouseIds = new HashSet<>();
281:         for ( UUID orderId : orderIds ) {
282:             UUID warehouseId = orderUseCases.getWarehouseIdForOrder( orderId );
283:             foundWarehouseIds.add( warehouseId );
284:         }
285:         for ( UUID expectedWarehouseId : expectedWarehouseIds ) {
286:             assertTrue( foundWarehouseIds.contains( expectedWarehouseId ) );
287:         }
288:     }
289: 
290: }
291: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\ShoppingCartRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingcart;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.ResultMatcher;
12: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
13: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
14: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
15: import thkoeln.archilab.ecommerce.usecases.WarehouseUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
17: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
18: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
19: import thkoeln.archilab.ecommerce.usecases.masterdata.WarehouseTestHelper;
20: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
21: 
22: import java.util.HashMap;
23: import java.util.Map;
24: import java.util.UUID;
25: 
26: import static org.junit.jupiter.api.Assertions.assertEquals;
27: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
28: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
29: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmailAddress;
30: 
31: 
32: @SpringBootTest
33: @Transactional
34: @AutoConfigureMockMvc
35: @Import( RESTTestHelperConfiguration.class )
36: public class ShoppingCartRESTTest {
37:     @Autowired
38:     private WarehouseUseCases warehouseUseCases;
39:     @Autowired
40:     private ShoppingCartUseCases shoppingCartUseCases;
41:     @Autowired
42:     private Purgatory purgatory;
43:     @Autowired
44:     private UserTestHelper userTestHelper;
45:     @Autowired
46:     private ProductTestHelper productTestHelper;
47:     @Autowired
48:     private WarehouseTestHelper warehouseTestHelper;
49:     @Autowired
50:     private MockMvc mockMvc;
51:     @Autowired
52:     private ShoppingCartRESTHelper shoppingCartRESTHelper;
53: 
54:     private EmailAddressType nonExistingEmailAddress;
55:     private final Map<UUID, Integer> emptyMap = new HashMap<>();
56: 
57:     private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
58:     private EmailAddressType
59:             userEmailAddress0,
60:             userEmailAddress3,
61:             userEmailAddress6,
62:             userEmailAddress8;
63:     private String userName0, userName8;
64:     private UUID productId0, productId1, productId2, productId3, productId5,
65:                  productId7, productId9, productId11, nonExistentProductId;
66:     private UUID warehouseId0, warehouseId3, warehouseId7, warehouseId8;
67: 
68: 
69:     private static final ResultMatcher NOT_FOUND = status().isNotFound();
70:     private static final ResultMatcher OK = status().isOk();
71:     private static final ResultMatcher CREATED = status().isCreated();
72:     private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
73:     private static final ResultMatcher CONFLICT = status().isConflict();
74: 
75:     @BeforeEach
76:     public void setUp() {
77:         purgatory.deleteEverything();
78:         userTestHelper.registerAllUsers();
79:         productTestHelper.addAllProducts();
80:         warehouseTestHelper.addAllWarehouses( true );
81:         nonExistingEmailAddress = instantiateEmailAddress( "harry@sally.de" );
82: 
83:         userEmailAddress0 = userTestHelper.getUserEmailAddress( 0 );
84:         userEmailAddress3 = userTestHelper.getUserEmailAddress( 3 );
85:         userEmailAddress6 = userTestHelper.getUserEmailAddress( 6 );
86:         userEmailAddress8 = userTestHelper.getUserEmailAddress( 8 );
87:         userName0 = userTestHelper.getUserName( 0 );
88:         userName8 = userTestHelper.getUserName( 8 );
89: 
90:         productId0 = productTestHelper.getProductId( 0 );
91:         productId1 = productTestHelper.getProductId( 1 );
92:         productId2 = productTestHelper.getProductId( 2 );
93:         productId3 = productTestHelper.getProductId( 3 );
94:         productId5 = productTestHelper.getProductId( 5 );
95:         productId7 = productTestHelper.getProductId( 7 );
96:         productId9 = productTestHelper.getProductId( 9 );
97:         productId11 = productTestHelper.getProductId( 11 );
98:         nonExistentProductId = UUID.randomUUID();
99: 
100:         warehouseId0 = warehouseTestHelper.getWarehouseId( 0 );
101:         warehouseId3 = warehouseTestHelper.getWarehouseId( 3 );
102:         warehouseId7 = warehouseTestHelper.getWarehouseId( 7 );
103:         warehouseId8 = warehouseTestHelper.getWarehouseId( 8 );
104: 
105:         map9_quantity_1 = new HashMap<>() {{
106:             put( productId9, 1 );
107:         }};
108:         map5_quantity_2 = new HashMap<>() {{
109:             put( productId5, 2 );
110:         }};
111:         map7_quantity_7 = new HashMap<>() {{
112:             put( productId7, 7 );
113:         }};
114:         map9_11_quantity_2_2 = new HashMap<>() {{
115:             put( productId9, 2 );
116:             put( productId11, 2 );
117:         }};
118:     }
119: 
120: 
121:     @Test
122:     public void testInvalidShoppingCartBaseUris() throws Exception {
123:         // given
124:         String allShoppingCartsUri = "/shoppingCarts";
125:         String randomIdUri = "/shoppingCarts/" + UUID.randomUUID();
126:         String randomUserUUID = "/shoppingCarts?userId=" + UUID.randomUUID();
127:         String invalidUserUUID = "/shoppingCarts?userId=invalidUUID";
128:         String randomParamUri = "/shoppingCarts?randomParam=randomValue";
129: 
130:         // when
131:         // then
132:         mockMvc.perform( get( allShoppingCartsUri ) ).andExpect( status().isMethodNotAllowed() );
133:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
134:         mockMvc.perform( get( randomUserUUID ) ).andExpect( status().isNotFound() );
135:         mockMvc.perform( get( invalidUserUUID ) ).andExpect( status().isNotFound() );
136:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
137:     }
138: 
139: 
140:     @Test
141:     public void testInvalidPartUris() throws Exception {
142:         // given
143:         UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart( userEmailAddress8, emptyMap );
144:         String randomPartUri = "/shoppingCarts/" + shoppingCartId8.toString() + "/random";
145:         String randomProductUri = "/shoppingCarts/" + shoppingCartId8.toString()
146:                 + "/parts/" + UUID.randomUUID();
147: 
148:         // when
149:         // then
150:         mockMvc.perform( post( randomPartUri ) ).andExpect( status().isNotFound() );
151:         mockMvc.perform( delete( randomProductUri ) ).andExpect( status().isNotFound() );
152:     }
153: 
154: 
155:     @Test
156:     public void testInvalidAddToShoppingCart() throws Exception {
157:         // given
158:         Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
159:         expectedStartQuantityMap.put( productId2, 19 );
160: 
161:         // when
162:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( userEmailAddress0, emptyMap );
163:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId, productId2, 6 );
164:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId, productId2, 13 );
165: 
166:         // then
167:         shoppingCartRESTHelper.getQueryShoppingCart( userEmailAddress0, expectedStartQuantityMap );
168: 
169:         // ... and check a couple of invalid cases
170:         shoppingCartRESTHelper.addProductToShoppingCart(
171:                 shoppingCartId, nonExistentProductId, 12, NOT_FOUND );
172:         shoppingCartRESTHelper.addProductToShoppingCart(
173:                 UUID.randomUUID(), productId5, 12, NOT_FOUND );
174:         shoppingCartRESTHelper.addProductToShoppingCart(
175:                 shoppingCartId, productId5, -1, UNPROCESSABLE_ENTITY );
176: 
177:         // check if the shopping cart is still the same
178:         shoppingCartRESTHelper.getQueryShoppingCart( userEmailAddress0, expectedStartQuantityMap );
179:     }
180: 
181: 
182:     @Test
183:     public void testInvalidCheckout_unavailableProduct() throws Exception {
184:         // given
185:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( userEmailAddress0, emptyMap );
186: 
187:         // when
188:         // productId0 is not available in the requested quantity (or rather, not at all)
189:         shoppingCartRESTHelper.addProductToShoppingCart(
190:                 shoppingCartId, productId0, 1, CREATED );
191: 
192:         // check if the shopping cart is still the same
193:         shoppingCartRESTHelper.checkout( shoppingCartId, null, CONFLICT, null );
194:     }
195: 
196: 
197:     @Test
198:     public void testInvalidCheckout_tooLittleInventory() throws Exception {
199:         // given
200:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( userEmailAddress0, emptyMap );
201: 
202:         // when
203:         // There are only 10 pieces of productId1 available
204:         shoppingCartRESTHelper.addProductToShoppingCart(
205:                 shoppingCartId, productId1, 11, CREATED );
206: 
207:         // check if the shopping cart is still the same
208:         shoppingCartRESTHelper.checkout( shoppingCartId, null, CONFLICT, null );
209:     }
210: 
211: 
212: 
213:     @Test
214:     public void testDeleteProductFromShoppingCart() throws Exception {
215:         // given
216:         UUID shoppingCartId6 = shoppingCartRESTHelper.getQueryShoppingCart( userEmailAddress6, emptyMap );
217:         Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
218:         expectedQuantityMap1.put( productId1, 1 );
219:         expectedQuantityMap1.put( productId2, 2 );
220:         expectedQuantityMap1.put( productId3, 3 );
221:         Map<UUID, Integer> quantityMap2 = new HashMap<>();
222:         quantityMap2.put( productId1, 1 );
223:         quantityMap2.put( productId3, 3 );
224: 
225:         // when
226:         // then
227:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId6, productId1, 1 );
228:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId6, productId2, 2 );
229:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId6, productId3, 3 );
230:         shoppingCartRESTHelper.getQueryShoppingCart( userEmailAddress6, expectedQuantityMap1 );
231: 
232:         shoppingCartRESTHelper.deleteProductFromShoppingCart( shoppingCartId6, productId2 );
233:         shoppingCartRESTHelper.getQueryShoppingCart( userEmailAddress6, quantityMap2 );
234:     }
235: 
236: 
237:     @Test
238:     public void testNoDoubleDelete() throws Exception {
239:         // given
240:         UUID shoppingCartId6 = shoppingCartRESTHelper.getQueryShoppingCart( userEmailAddress6, emptyMap );
241: 
242:         // when
243:         // then
244:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId6, productId3, 3 );
245:         shoppingCartRESTHelper.deleteProductFromShoppingCart( shoppingCartId6, productId3 );
246:         shoppingCartRESTHelper.getQueryShoppingCart( userEmailAddress6, new HashMap<>() );
247:         shoppingCartRESTHelper.deleteProductFromShoppingCart( shoppingCartId6, productId3, NOT_FOUND );
248:     }
249: 
250: 
251:     @Test
252:     public void testAddRemoveProductsFromAndToShoppingCart() throws Exception {
253:         // given
254:         UUID shoppingCartId3 = shoppingCartRESTHelper.getQueryShoppingCart( userEmailAddress3, emptyMap );
255:         UUID shoppingCartId5 = shoppingCartRESTHelper.getQueryShoppingCart( userEmailAddress6, emptyMap );
256: 
257:         // when
258:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId3, productId1, 2 );
259:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId3, productId2, 3 );
260:         shoppingCartRESTHelper.deleteProductFromShoppingCart( shoppingCartId3, productId1 );
261:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId3, productId1, 1 );
262:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId3, productId2, 6 );
263: 
264:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId5, productId1, 2 );
265:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId5, productId2, 8 );
266:         shoppingCartRESTHelper.deleteProductFromShoppingCart( shoppingCartId5, productId1 );
267:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId5, productId1, 1 );
268:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId5, productId2, 2 );
269: 
270:         // then
271:         // user3 has 1x productId1 and 9x productId2 expected in cart
272:         Map<UUID, Integer> expectedMap3 = new HashMap<>();
273:         expectedMap3.put( productId1, 1 );
274:         expectedMap3.put( productId2, 9 );
275:         shoppingCartRESTHelper.getQueryShoppingCart( userEmailAddress3, expectedMap3 );
276: 
277:         // user6 has 1x productId1 and 10x productId2 in cart
278:         Map<UUID, Integer> expectedMap5 = new HashMap<>();
279:         expectedMap5.put( productId1, 1 );
280:         expectedMap5.put( productId2, 10 );
281:         shoppingCartRESTHelper.getQueryShoppingCart( userEmailAddress6, expectedMap5 );
282:     }
283: 
284: 
285:     @Test
286:     public void testNoDoubleCheckout() throws Exception {
287:         // given
288:         UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart( userEmailAddress8, emptyMap );
289: 
290:         // when
291:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId8, productId2, 3 );
292: 
293:         // then
294:         shoppingCartRESTHelper.checkout( shoppingCartId8, userName8, CREATED, null );
295:         shoppingCartRESTHelper.checkout( shoppingCartId8, null, CONFLICT, null );
296:     }
297: 
298: 
299:     @Test
300:     public void testCheckout_1_Order() throws Exception {
301:         // given:
302:         // User 0 wants to buy 1x product 9. This is in warehouse 5, 7, and 8. Out of these,
303:         // warehouse 8 with postal code 89250 is closest to user 0 with postal code 02314.
304:         Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
305:             put( warehouseId8, map9_quantity_1 );
306:         }};
307:         UUID shoppingCartId0 = shoppingCartRESTHelper.getQueryShoppingCart(
308:                 userEmailAddress0, null );
309:         int inventory9before =
310:                 warehouseUseCases.getAvailableInventory( warehouseId8, productId9 );
311: 
312:         // when
313:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId0, productId9, 1 );
314:         shoppingCartRESTHelper.checkout( shoppingCartId0, userName0, CREATED, expectedOrders );
315:         int inventory9after =
316:                 warehouseUseCases.getAvailableInventory( warehouseId8, productId9 );
317: 
318:         // then
319:         assertEquals( 1, inventory9before - inventory9after );
320:     }
321: 
322: 
323:     @Test
324:     public void testCheckout_3_Order() throws Exception {
325:         // given:
326:         // User 8 (Felix Bauer) wants to buy 2x each of products 5, 9, 11; and 7x product 7.
327:         //       - products 9 and 11 can both be found in warehouses 7 and 8. Warehouses 7 (76532) is closer to
328:         //         the user (70173)
329:         //       - product 7 is available in warehouses 1, 2, and 3, but only warehouse 3 has enough inventory.
330:         //       - product 5 is only available in warehouse 0.
331:         Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
332:             put( warehouseId0, map5_quantity_2 );
333:             put( warehouseId3, map7_quantity_7 );
334:             put( warehouseId7, map9_11_quantity_2_2 );
335:         }};
336:         UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart(
337:                 userEmailAddress8, null );
338:         int inventory5before =
339:                 warehouseUseCases.getAvailableInventory( warehouseId0, productId5 );
340:         int inventory7before =
341:                 warehouseUseCases.getAvailableInventory( warehouseId3, productId7 );
342:         int inventory9before =
343:                 warehouseUseCases.getAvailableInventory( warehouseId7, productId9 );
344:         int inventory11before =
345:                 warehouseUseCases.getAvailableInventory( warehouseId7, productId11 );
346: 
347:         // when
348:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId8, productId5, 2 );
349:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId8, productId7, 7 );
350:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId8, productId9, 2 );
351:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId8, productId11, 2 );
352:         shoppingCartRESTHelper.checkout( shoppingCartId8, userName8, CREATED, expectedOrders );
353:         int inventory5after =
354:                 warehouseUseCases.getAvailableInventory( warehouseId0, productId5 );
355:         int inventory7after =
356:                 warehouseUseCases.getAvailableInventory( warehouseId3, productId7 );
357:         int inventory9after =
358:                 warehouseUseCases.getAvailableInventory( warehouseId7, productId9 );
359:         int inventory11after =
360:                 warehouseUseCases.getAvailableInventory( warehouseId7, productId11 );
361: 
362:         // then
363:         assertEquals( 2, inventory5before - inventory5after );
364:         assertEquals( 7, inventory7before - inventory7after );
365:         assertEquals( 2, inventory9before - inventory9after );
366:         assertEquals( 2, inventory11before - inventory11after );
367:     }
368: 
369: 
370: }
371: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\ShoppingCartTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingcart;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.InsufficientInventoryException;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.WarehouseTestHelper;
12: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
13: import thkoeln.archilab.ecommerce.usecases.*;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
16: 
17: 
18: import java.util.Map;
19: import java.util.UUID;
20: 
21: import static org.junit.jupiter.api.Assertions.*;
22: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
23: 
24: @SpringBootTest
25: public class ShoppingCartTest {
26:     @Autowired
27:     private UserRegistrationUseCases userRegistrationUseCases;
28:     @Autowired
29:     private ShoppingCartUseCases shoppingCartUseCases;
30:     @Autowired
31:     private ProductCatalogUseCases productCatalogUseCases;
32:     @Autowired
33:     private WarehouseUseCases warehouseUseCases;
34:     @Autowired
35:     private OrderUseCases orderUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private UserTestHelper userTestHelper;
40:     @Autowired
41:     private ProductTestHelper productTestHelper;
42:     @Autowired
43:     private WarehouseTestHelper warehouseTestHelper;
44: 
45:     private EmailAddressType nonExistingEmailAddress;
46: 
47:     @BeforeEach
48:     public void setUp() {
49:         purgatory.deleteEverything();
50:         userTestHelper.registerAllUsers();
51:         productTestHelper.addAllProducts();
52: 
53:         nonExistingEmailAddress = instantiateEmailAddress( "this@nononono.de" );
54:     }
55: 
56: 
57:     @Test
58:     public void testInvalidAddToShoppingCart() {
59:         // given
60:         UUID nonExistentProductId = UUID.randomUUID();
61:         UUID productId5 = productTestHelper.getProductId( 5 );
62:         UUID productId0 = productTestHelper.getProductId( 0 );
63:         EmailAddressType userEmailAddress0 =
64:                 userTestHelper.getUserEmailAddress( 0 );
65:         warehouseTestHelper.addAllWarehouses( true );
66: 
67:         // then
68:         assertThrows( ShopException.class,
69:                 () -> shoppingCartUseCases.addProductToShoppingCart(
70:                         nonExistingEmailAddress, productId0, 1 ) );
71:         assertThrows( ShopException.class,
72:                 () -> shoppingCartUseCases.addProductToShoppingCart(
73:                         null, productId0, 1 ) );
74:         assertThrows( ShopException.class,
75:                 () -> shoppingCartUseCases.addProductToShoppingCart(
76:                         userEmailAddress0, nonExistentProductId, 1 ) );
77:         assertThrows( ShopException.class,
78:                 () -> shoppingCartUseCases.addProductToShoppingCart(
79:                         userEmailAddress0, null, 1 ) );
80:         assertThrows( ShopException.class,
81:                 () -> shoppingCartUseCases.addProductToShoppingCart(
82:                         userEmailAddress0, productId5, -1 ) );
83:     }
84: 
85: 
86:     @Test
87:     public void testInvalidRemoveFromShoppingCart() {
88:         // given
89:         UUID nonExistentProductId = UUID.randomUUID();
90:         UUID productId5 = productTestHelper.getProductId( 5 );
91:         UUID productId1 = productTestHelper.getProductId( 1 );
92:         UUID productId2 = productTestHelper.getProductId( 2 );
93:         warehouseTestHelper.addAllWarehouses( true );
94:         EmailAddressType userEmailAddress0 =
95:                 userTestHelper.getUserEmailAddress( 0 );
96:         shoppingCartUseCases.addProductToShoppingCart(
97:                 userEmailAddress0, productId1, 5 );
98:         shoppingCartUseCases.addProductToShoppingCart(
99:                 userEmailAddress0, productId2, 15 );
100: 
101:         // when
102:         shoppingCartUseCases.removeProductFromShoppingCart(
103:                 userEmailAddress0, productId1, 2 );
104:         shoppingCartUseCases.removeProductFromShoppingCart(
105:                 userEmailAddress0, productId2, 4 );
106:         shoppingCartUseCases.removeProductFromShoppingCart(
107:                 userEmailAddress0, productId2, 7 );
108:         // now we should have 3x productId1 and 4x productId2 in the shopping cart
109: 
110:         // then
111:         assertThrows( ShopException.class,
112:                 () -> shoppingCartUseCases.removeProductFromShoppingCart(
113:                         userEmailAddress0, nonExistentProductId, 12 ) );
114:         assertThrows( ShopException.class,
115:                 () -> shoppingCartUseCases.removeProductFromShoppingCart(
116:                         nonExistingEmailAddress, productId5, 12 ) );
117:         assertThrows( ShopException.class,
118:                 () -> shoppingCartUseCases.removeProductFromShoppingCart(
119:                         userEmailAddress0, productId5, -1 ) );
120:         assertThrows( ShopException.class,
121:                 () -> shoppingCartUseCases.removeProductFromShoppingCart(
122:                         userEmailAddress0, productId1, 4 ) );
123:         assertThrows( ShopException.class,
124:                 () -> shoppingCartUseCases.removeProductFromShoppingCart(
125:                         userEmailAddress0, productId2, 5 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testAddRemoveProductsFromAndToShoppingCart() {
131:         // given
132:         UUID productId1 = productTestHelper.getProductId( 1 );
133:         UUID productId2 = productTestHelper.getProductId( 2 );
134:         EmailAddressType userEmailAddress3 =
135:                 userTestHelper.getUserEmailAddress( 3 );
136:         EmailAddressType userEmailAddress5 =
137:                 userTestHelper.getUserEmailAddress( 5 );
138: 
139:         // when user 3 ...
140:         shoppingCartUseCases.addProductToShoppingCart(
141:                 userEmailAddress3, productId1, 2 );
142:         shoppingCartUseCases.addProductToShoppingCart(
143:                 userEmailAddress3, productId2, 3 );
144:         shoppingCartUseCases.removeProductFromShoppingCart(
145:                 userEmailAddress3, productId1, 2 );
146:         shoppingCartUseCases.addProductToShoppingCart(
147:                 userEmailAddress3, productId1, 1 );
148:         shoppingCartUseCases.addProductToShoppingCart(
149:                 userEmailAddress3, productId2, 6 );
150:         Map<UUID, Integer> cart3 = shoppingCartUseCases.getShoppingCartAsMap( userEmailAddress3 );
151:         // user3 has 1x productId1 and 9x productId2 in cart
152: 
153:         // ... and when user 5 ...
154:         shoppingCartUseCases.addProductToShoppingCart(
155:                 userEmailAddress5, productId1, 2 );
156:         shoppingCartUseCases.addProductToShoppingCart(
157:                 userEmailAddress5, productId2, 8 );
158:         shoppingCartUseCases.removeProductFromShoppingCart(
159:                 userEmailAddress5, productId1, 1 );
160:         shoppingCartUseCases.addProductToShoppingCart(
161:                 userEmailAddress5, productId2, 2 );
162:         Map<UUID, Integer> cart5 = shoppingCartUseCases.getShoppingCartAsMap( userEmailAddress5 );
163:         // user5 has 1x productId1 and 10x productId2 in cart
164: 
165:         // then
166:         assertEquals( 2, cart3.size() );
167:         assertEquals( 1, cart3.get( productId1 ) );
168:         assertEquals( 9, cart3.get( productId2 ) );
169: 
170:         assertEquals( 2, cart5.size() );
171:         assertEquals( 1, cart5.get( productId1 ) );
172:         assertEquals( 10, cart5.get( productId2 ) );
173:     }
174: 
175: 
176:     @Test
177:     public void testShoppingCartValue() {
178:         // given
179:         UUID productId3 = productTestHelper.getProductId( 3 );
180:         UUID productId6 = productTestHelper.getProductId( 6 );
181:         UUID productId8 = productTestHelper.getProductId( 8 );
182:         CurrencyType price3 = productTestHelper.getSalesPrice( 3 );
183:         CurrencyType price6 = productTestHelper.getSalesPrice( 6 );
184:         CurrencyType price8 = productTestHelper.getSalesPrice( 8 );
185:         EmailAddressType userEmailAddress3 =
186:                 userTestHelper.getUserEmailAddress( 3 );
187: 
188:         // when
189:         shoppingCartUseCases.addProductToShoppingCart( userEmailAddress3, productId3, 3 );
190:         shoppingCartUseCases.addProductToShoppingCart( userEmailAddress3, productId6, 2 );
191:         shoppingCartUseCases.addProductToShoppingCart( userEmailAddress3, productId8, 5 );
192:         // user3 has 3x productId3, 2x productId6 and 5x productId8 in cart
193:         CurrencyType cartValue = shoppingCartUseCases.getShoppingCartAsCurrencyValue( userEmailAddress3 );
194: 
195:         // then
196:         assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
197:                 cartValue );
198:     }
199: 
200: 
201:     @Test
202:     public void testShoppingCartValueInvalid() {
203:         // given
204:         // when
205:         // then
206:         assertThrows( ShopException.class,
207:                 () -> shoppingCartUseCases.getShoppingCartAsCurrencyValue( nonExistingEmailAddress ) );
208:     }
209: 
210: 
211:     @Test
212:     public void testUnsuccessfulCheckout() {
213:         // given user buying product 0 (which is not in inventory), and user 1 buying product 1
214:         // in a bigger quantity (11) than available (10)
215:         warehouseTestHelper.addAllWarehouses( true );
216:         EmailAddressType userEmailAddress0 =
217:                 userTestHelper.getUserEmailAddress( 0 );
218:         EmailAddressType userEmailAddress1 =
219:                 userTestHelper.getUserEmailAddress( 1 );
220:         UUID productId0 = productTestHelper.getProductId( 0 );
221:         UUID productId1 = productTestHelper.getProductId( 1 );
222: 
223:         // when
224:         shoppingCartUseCases.addProductToShoppingCart(
225:                 userEmailAddress0, productId0, 1 );
226:         shoppingCartUseCases.addProductToShoppingCart(
227:                 userEmailAddress1, productId1, 11 );
228: 
229:         // then
230:         assertThrows( InsufficientInventoryException.class,
231:                 () -> shoppingCartUseCases.checkout( userEmailAddress0 ) );
232:         assertThrows( InsufficientInventoryException.class,
233:                 () -> shoppingCartUseCases.checkout( userEmailAddress1 ) );
234:     }
235: 
236: }
237: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
1: package thkoeln.archilab.ecommerce.tests.testtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.domain.JavaMethod;
6: import com.tngtech.archunit.core.importer.ClassFileImporter;
7: import com.tngtech.archunit.lang.ArchRule;
8: import org.junit.jupiter.api.BeforeEach;
9: import org.junit.jupiter.api.Test;
10: import org.springframework.web.bind.annotation.RestController;
11: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
12: import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
13: import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingCartRESTTest;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
18: 
19: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
20: import static org.springframework.test.util.AssertionErrors.assertTrue;
21: 
22: /**
23:  * This test checks if there are the appropriate tests in the test class(es) for domain
24:  * primitives.
25:  */
26: 
27: public class RulesForOwnTests {
28:     private JavaClass dpTestClass, restTestClass;
29:     private JavaClasses dpTestClasses, restTestClasses;
30:     private static final String WAREHOUSE_DOMAIN_PACKAGE =
31:             "thkoeln.archilab.ecommerce.solution.warehouse.domain";
32:     private static final String WAREHOUSE_CLASS_NAME =
33:             WAREHOUSE_DOMAIN_PACKAGE + ".Warehouse";
34: 
35: 
36:     @BeforeEach
37:     public void setUp() throws Exception {
38:         dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
39:         restTestClass = new ClassFileImporter().importClass( OwnShoppingCartRESTTest.class );
40: 
41:         dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
42:         restTestClasses = new ClassFileImporter().importClasses( OwnShoppingCartRESTTest.class );
43:     }
44: 
45: 
46:     @Test
47:     public void ensureMinimumNumberOfTestMethods() {
48:         // given
49:         // when
50:         int dpTestMethodCount = getTestMethodCount( dpTestClass );
51:         int restTestMethodCount = getTestMethodCount( restTestClass );
52: 
53:         // then
54:         assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
55:                         + dpTestMethodCount,dpTestMethodCount >= 2 );
56:         assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
57:                         + restTestMethodCount, restTestMethodCount >= 5 );
58:     }
59: 
60:     private int getTestMethodCount( JavaClass testClass ) {
61:         int testMethodCount = 0;
62:         for ( JavaMethod method : testClass.getMethods() ) {
63:             if ( isTestMethod( method ) ) {
64:                 testMethodCount++;
65:             }
66:         }
67:         return testMethodCount;
68:     }
69: 
70:     private boolean isTestMethod( JavaMethod method ) {
71:         return method.isAnnotatedWith( Test.class );
72:     }
73: 
74: 
75:     @Test
76:     public void dpTestsShouldReferenceTheRightClasses() {
77:         ArchRule rule = classes()
78:                 .should().dependOnClassesThat()
79:                 .areAssignableTo( PostalCodeType.class )
80:                 .andShould().dependOnClassesThat()
81:                 .areAssignableTo( CurrencyType.class )
82:                 .andShould().dependOnClassesThat()
83:                 .areAssignableTo( AddressLocationType.class )
84:                 .andShould().dependOnClassesThat()
85:                 .areAssignableTo( EmailAddressType.class )
86:                 .because( "DomainPrimitiveJSONSerializationTest should reference PostalCode, " +
87:                         "Currency, EmailAddress, and AddressLocation!" );
88:         rule.check( dpTestClasses );
89:     }
90: 
91: 
92:     @Test
93:     public void restTestsShouldReferenceEmailAddress() {
94:         ArchRule rule = classes()
95:                 .should().dependOnClassesThat()
96:                 .areAssignableTo( EmailAddressType.class )
97:                 .because( "WarehouseComparatorUnitTest should reference EmailAddressType!" );
98:         rule.check( restTestClasses );
99:     }
100: 
101: 
102:     @Test
103:     public void restTestsShouldReferenceRESTControllers() {
104:         ArchRule rule = classes()
105:                 .should().dependOnClassesThat()
106:                 .areAnnotatedWith( RestController.class )
107:                 .orShould().dependOnClassesThat()
108:                 .areAssignableTo( ShoppingCartRESTHelper.class )
109:                 .because( "WarehouseComparatorUnitTest should call REST controllers! " +
110:                         "(either directly or via the ShoppingCartRESTHelper REST helper)" );
111:         rule.check( restTestClasses );
112:     }
113: 
114: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\user\UserRegistrationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.user;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
12: import thkoeln.archilab.ecommerce.usecases.UserType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
15: 
16: import static org.junit.jupiter.api.Assertions.*;
17: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
18: 
19: 
20: @SpringBootTest
21: public class UserRegistrationTest {
22:     @Autowired
23:     private UserRegistrationUseCases userRegistrationUseCases;
24:     @Autowired
25:     private Purgatory purgatory;
26:     @Autowired
27:     private UserTestHelper userTestHelper;
28: 
29:     private EmailAddressType nonExistingEmailAddress;
30:     private AddressLocationType someAddressLocation;
31: 
32:     @BeforeEach
33:     public void setUp() {
34:         purgatory.deleteEverything();
35:         nonExistingEmailAddress = instantiateEmailAddress( "this@nononono.de" );
36:         someAddressLocation = instantiateAddressLocation( "Some Street", "Some City",
37:                 instantiatePostalCode( "90001" ) );
38:     }
39: 
40:     @Test
41:     public void testAllUsersRegistered() {
42:         // given
43:         userTestHelper.registerAllUsers();
44:         EmailAddressType emailAddress3 =
45:                 userTestHelper.getUserEmailAddress( 3 );
46:         String name3 = userTestHelper.getUserName( 3 );
47:         AddressLocationType addressLocation3 = userTestHelper.getUserAddressLocation( 3 );
48: 
49:         // when
50:         UserType user3 = userRegistrationUseCases.getUserData(
51:                 emailAddress3 );
52: 
53:         // then
54:         Assertions.assertEquals( name3, user3.getName() );
55:         Assertions.assertEquals( emailAddress3, user3.getEmailAddress() );
56:         Assertions.assertEquals( addressLocation3, user3.getAddressLocation() );
57:     }
58: 
59: 
60:     @Test
61:     public void testRegisterUserWithDuplicateEmailAddress() {
62:         // given
63:         userTestHelper.registerAllUsers();
64:         AddressLocationType addressLocation5 = userTestHelper.getUserAddressLocation( 5 );
65:         EmailAddressType emailAddress5 =
66:                 userTestHelper.getUserEmailAddress( 5 );
67: 
68:         // when
69:         // then
70:         assertThrows( ShopException.class, () ->
71:                 userRegistrationUseCases.register( "Gandalf The Grey",
72:                         emailAddress5, addressLocation5 ) );
73:     }
74: 
75: 
76:     @Test
77:     public void testRegisterUserWithDuplicateNameOrAddressLocation() {
78:         // given
79:         userTestHelper.registerAllUsers();
80:         EmailAddressType newEmailAddress =
81:                 instantiateEmailAddress( "some@this.de" );
82:         AddressLocationType addressLocation2 = userTestHelper.getUserAddressLocation( 2 );
83:         String name2 = userTestHelper.getUserName( 2 );
84: 
85:         // when
86:         // then
87:         assertDoesNotThrow( () ->
88:                 userRegistrationUseCases.register( name2, newEmailAddress, addressLocation2 ) );
89:     }
90: 
91: 
92:     @Test
93:     public void testRegisterUserWithInvalidData() {
94:         // given
95:         EmailAddressType emailAddress5 =
96:                 userTestHelper.getUserEmailAddress( 5 );
97:         AddressLocationType addressLocation5 = userTestHelper.getUserAddressLocation( 5 );
98:         String name5 = userTestHelper.getUserName( 5 );
99: 
100:         // when
101:         // then
102:         assertThrows( ShopException.class, () ->
103:                 userRegistrationUseCases.register( null, emailAddress5, addressLocation5 ) );
104:         assertThrows( ShopException.class, () ->
105:                 userRegistrationUseCases.register("", emailAddress5, addressLocation5 ) );
106:         assertThrows( ShopException.class, () ->
107:                 userRegistrationUseCases.register( name5, null, addressLocation5 ) );
108:         assertThrows( ShopException.class, () ->
109:                 userRegistrationUseCases.register( name5, emailAddress5, null ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testChangeAddressWithInvalidData() {
115:         // given
116:         userTestHelper.registerAllUsers();
117:         AddressLocationType addressLocation7 = userTestHelper.getUserAddressLocation( 7 );
118:         EmailAddressType emailAddress7 =
119:                 userTestHelper.getUserEmailAddress( 7 );
120: 
121:         // when
122:         // then
123:         assertThrows( ShopException.class, () ->
124:                 userRegistrationUseCases.changeAddress( nonExistingEmailAddress, addressLocation7 ) );
125:         assertThrows( ShopException.class, () ->
126:                 userRegistrationUseCases.changeAddress( null, addressLocation7 ) );
127:         assertThrows( ShopException.class, () ->
128:                 userRegistrationUseCases.changeAddress( emailAddress7, null ) );
129:     }
130: 
131: 
132:     @Test
133:     public void testGetDataForNonexistingEmailAddress() {
134:         // given
135:         userTestHelper.registerAllUsers();
136: 
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 userRegistrationUseCases.getUserData( nonExistingEmailAddress ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testDeleteUsersNoMoreUsers() {
146:         // given
147:         userTestHelper.registerAllUsers();
148:         EmailAddressType emailAddress0 =
149:                 userTestHelper.getUserEmailAddress( 0 );
150: 
151: 
152:         // when
153:         userRegistrationUseCases.deleteAllUsers();
154: 
155:         // then
156:         assertThrows( ShopException.class, () -> userRegistrationUseCases.getUserData(
157:                 emailAddress0 ) );
158:     }
159: 
160: 
161:     @Test
162:     public void testChangeAddressSuccessful() {
163:         // given
164:         userTestHelper.registerAllUsers();
165:         EmailAddressType emailAddress6 =
166:                 userTestHelper.getUserEmailAddress( 6 );
167: 
168:         // when
169:         userRegistrationUseCases.changeAddress( emailAddress6, someAddressLocation );
170:         UserType newUser6 =
171:                 userRegistrationUseCases.getUserData( emailAddress6 );
172: 
173:         // then
174:         Assertions.assertEquals( emailAddress6, newUser6.getEmailAddress() );
175:         Assertions.assertEquals( someAddressLocation, newUser6.getAddressLocation() );
176:     }
177: 
178: 
179:     @Test
180:     public void testChangeAddressForNonexistingEmailAddress() {
181:         // given
182:         userTestHelper.registerAllUsers();
183: 
184:         // when
185:         // then
186:         assertThrows( ShopException.class, () ->
187:                 userRegistrationUseCases.changeAddress( nonExistingEmailAddress, someAddressLocation ) );
188:     }
189: 
190: 
191: }
192: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\user\UserRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.user;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
12: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
13: import thkoeln.archilab.ecommerce.usecases.UserType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
16: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
17: 
18: import java.util.UUID;
19: 
20: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
21: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
22: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
23: 
24: @SpringBootTest
25: @Transactional
26: @AutoConfigureMockMvc
27: @Import( RESTTestHelperConfiguration.class )
28: public class UserRESTTest {
29:     @Autowired
30:     private UserRegistrationUseCases userRegistrationUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private UserTestHelper userTestHelper;
35:     @Autowired
36:     private MockMvc mockMvc;
37: 
38:     private UUID randomId;
39:     private EmailAddressType nonExistingEmailAddress;
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         userTestHelper.registerAllUsers();
45: 
46:         nonExistingEmailAddress = FactoryMethodInvoker.instantiateEmailAddress(
47:                 "harry@sally.de" );
48:         randomId = UUID.randomUUID();
49:     }
50: 
51: 
52:     @Test
53:     public void testInvalidUserUris() throws Exception {
54:         // given
55:         String allUsersUri = "/users";
56:         String randomIdUri = "/users/" +  randomId;
57:         String nonExistingEmailAddressUri = "/users?emailAddress=" + nonExistingEmailAddress;
58:         String randomParamUri = "/users?randomParam=randomValue";
59: 
60:         // when
61:         // then
62:         mockMvc.perform( get( allUsersUri ) ).andExpect( status().isMethodNotAllowed() );
63:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
64:         mockMvc.perform( get( nonExistingEmailAddressUri ) ).andExpect( status().isNotFound() );
65:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
66:     }
67: 
68: 
69:     @Test
70:     public void testRandomUserId() throws Exception {
71:         // given
72:         String invalidUri = "/users/" +  randomId;
73: 
74:         // when
75:         // then
76:         mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
77:     }
78: 
79: 
80:     @Test
81:     public void testQueryUser() throws Exception {
82:         // given
83:         EmailAddressType emailAddress4 =
84:                 userTestHelper.getUserEmailAddress( 4 );
85:         String userUri4 = "/users?emailAddress=" + emailAddress4;
86: 
87:         // when
88:         UserType user4 = userRegistrationUseCases.getUserData( emailAddress4 );
89:         String name = userTestHelper.getUserName( 4 );
90:         AddressLocationType addressLocation4 = userTestHelper.getUserAddressLocation( 4 );
91: 
92:         // then (check using JSONPath)
93:         mockMvc.perform( get( userUri4 ) )
94:                 .andExpect( status().isOk() )
95:                 .andExpect( jsonPath( "$.name" ).value( name ) )
96:                 // id is position 0 (cannot be tested with current API structure), name is position 1,
97:                 // email address is 2, address location is 3)
98:                 .andExpect( jsonPath( "$..emailAddressString" ).value( emailAddress4.toString() ) )
99:                 .andExpect( jsonPath( "$..city" ).value( addressLocation4.getCity() ) )
100:                 .andExpect( jsonPath( "$..postalCodeString" ).value(
101:                         addressLocation4.getPostalCode().toString() ) );
102:     }
103: 
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e65b9b6a-b74d-481b-b418-a4ed941ec83a\src\test\java\thkoeln\archilab\ecommerce\tests\warehouse\WarehouseManagementTest.java ---
1: package thkoeln.archilab.ecommerce.tests.warehouse;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.WarehouseTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
12: import thkoeln.archilab.ecommerce.usecases.WarehouseUseCases;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressLocationType;
14: 
15: import java.util.UUID;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePostalCode;
19: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateAddressLocation;
20: 
21: 
22: /**
23:  * This test checks the management and lifecycle of warehouses.
24:  */
25: @SpringBootTest
26: public class WarehouseManagementTest {
27:     @Autowired
28:     private WarehouseUseCases warehouseUseCases;
29:     @Autowired
30:     private ProductCatalogUseCases productCatalogUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private ProductTestHelper productTestHelper;
35:     @Autowired
36:     private WarehouseTestHelper warehouseTestHelper;
37: 
38:     private AddressLocationType someAddressLocation;
39:     private UUID nonExistingId1;
40:     private UUID nonExistingId2;
41: 
42: 
43:     @BeforeEach
44:     public void setUp() {
45:         purgatory.deleteEverything();
46:         productTestHelper.addAllProducts();
47: 
48:         someAddressLocation = instantiateAddressLocation( "Some Street", "Some City",
49:                 instantiatePostalCode( "90001" ) );
50:         nonExistingId1 = UUID.randomUUID();
51:         nonExistingId2 = UUID.randomUUID();
52:     }
53: 
54: 
55:     @Test
56:     public void testAddInvalidWarehouse() {
57:         // given
58:         String name = "Lager1";
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class,
63:                 () -> warehouseUseCases.addNewWarehouse(
64:                         null, someAddressLocation ) );
65:         assertThrows( ShopException.class,
66:                 () -> warehouseUseCases.addNewWarehouse(
67:                         "", someAddressLocation ) );
68:         assertThrows( ShopException.class,
69:                 () -> warehouseUseCases.addNewWarehouse(
70:                         name, null ) );
71:     }
72: 
73: 
74:     @Test
75:     public void testDeleteAllWarehousesWhenEmpty() {
76:         // given
77:         warehouseTestHelper.addAllWarehouses( false );
78:         UUID productId9 = productTestHelper.getProductId( 9 );
79:         UUID warehouseId1 = warehouseTestHelper.getWarehouseId( 1 );
80:         UUID warehouseId2 = warehouseTestHelper.getWarehouseId( 2 );
81: 
82:         // when
83:         int numOf1 = warehouseUseCases.getAvailableInventory( warehouseId1, productId9 );
84:         int numOf2 = warehouseUseCases.getAvailableInventory( warehouseId2, productId9 );
85: 
86:         // then
87:         assertEquals( 0, numOf1 );
88:         assertEquals( 0, numOf2 );
89:         warehouseUseCases.deleteAllWarehouses();
90:         // ... ids must be invalid now
91:         assertThrows( ShopException.class,
92:                 () -> warehouseUseCases.getAvailableInventory( warehouseId1, productId9 ) );
93:         assertThrows( ShopException.class,
94:                 () -> warehouseUseCases.getAvailableInventory( warehouseId2, productId9 ) );
95:     }
96: 
97: 
98:     @Test
99:     public void testDeleteAllWarehousesWhenFull() {
100:         // given
101:         warehouseTestHelper.addAllWarehouses( true );
102:         UUID productId7 = productTestHelper.getProductId( 7 );
103:         UUID warehouseId1 = warehouseTestHelper.getWarehouseId( 1 );
104:         UUID warehouseId2 = warehouseTestHelper.getWarehouseId( 2 );
105: 
106:         // when
107:         int numOf1 = warehouseUseCases.getAvailableInventory( warehouseId1, productId7 );
108:         int numOf2 = warehouseUseCases.getAvailableInventory( warehouseId2, productId7 );
109: 
110:         // then
111:         assertTrue( numOf1 == 3 );
112:         assertTrue( numOf2 == 3 );
113:         warehouseUseCases.deleteAllWarehouses();
114:         // ... ids must be invalid now
115:         assertThrows( ShopException.class,
116:                 () -> warehouseUseCases.getAvailableInventory( warehouseId1, productId7 ) );
117:         assertThrows( ShopException.class,
118:                 () -> warehouseUseCases.getAvailableInventory( warehouseId2, productId7 ) );
119:     }
120: 
121: 
122: 
123:     @Test
124:     public void testAddToInventory() {
125:         // given
126:         warehouseTestHelper.addAllWarehouses( true );
127:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in warehouse 0
128:         UUID warehouseId0 = warehouseTestHelper.getWarehouseId( 0 );
129:         int originalInventory5 =
130:                 warehouseTestHelper.getWarehouseInventory( 0, 5 );
131: 
132:         // when
133:         int inventory5before = warehouseUseCases.getAvailableInventory( warehouseId0, productId5 );
134:         warehouseUseCases.addToInventory( warehouseId0, productId5, 23 );
135:         int inventory5after = warehouseUseCases.getAvailableInventory( warehouseId0, productId5 );
136:         warehouseUseCases.addToInventory( warehouseId0, productId5, 0 );
137:         int inventory5after2 = warehouseUseCases.getAvailableInventory( warehouseId0, productId5 );
138: 
139:         // then
140:         assertEquals( originalInventory5, inventory5before );
141:         assertEquals( inventory5before + 23, inventory5after );
142:         assertEquals( inventory5after, inventory5after2 );
143:     }
144: 
145: 
146:     @Test
147:     public void testInvalidAddToInventory() {
148:         // given
149:         warehouseTestHelper.addAllWarehouses( true );
150:         UUID productId2 = productTestHelper.getProductId( 2 );
151:         UUID warehouseId0 = warehouseTestHelper.getWarehouseId( 0 );
152: 
153:         // when
154:         // then
155:         assertThrows( ShopException.class,
156:                 () -> warehouseUseCases.addToInventory( nonExistingId1, nonExistingId2, 12 ) );
157:         assertThrows( ShopException.class,
158:                 () -> warehouseUseCases.addToInventory(
159:                         warehouseId0, nonExistingId2, 12 ) );
160:         assertThrows( ShopException.class,
161:                 () -> warehouseUseCases.addToInventory(
162:                         nonExistingId1, productId2, 12 ) );
163:         assertThrows( ShopException.class,
164:                 () -> warehouseUseCases.addToInventory(
165:                         warehouseId0, productId2, -1 ) );
166:     }
167: 
168: 
169:     @Test
170:     public void testRemoveFromInventory() {
171:         // given
172:         warehouseTestHelper.addAllWarehouses( true );
173:         UUID warehouseId0 = warehouseTestHelper.getWarehouseId( 0 );
174:         UUID productId0 = productTestHelper.getProductId( 0 ); // 0 in warehouse 0
175:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in warehouse 0
176:         UUID productId6 = productTestHelper.getProductId( 6 ); // random >30 in warehouse 0
177:         int inventory0before =
178:                 warehouseTestHelper.getWarehouseInventory( 0, 0 );
179:         int inventory5before =
180:                 warehouseTestHelper.getWarehouseInventory( 0, 5 );
181:         int inventory6before =
182:                 warehouseTestHelper.getWarehouseInventory( 0, 6 );
183: 
184:         // when
185:         warehouseUseCases.removeFromInventory( warehouseId0, productId5, 1 );
186:         int inventory5after = warehouseUseCases.getAvailableInventory( warehouseId0, productId5 );
187:         warehouseUseCases.removeFromInventory( warehouseId0, productId0, 0 );
188:         int inventory0after = warehouseUseCases.getAvailableInventory( warehouseId0, productId0 );
189:         warehouseUseCases.removeFromInventory(
190:                 warehouseId0, productId6, inventory6before );
191:         int inventory6after = warehouseUseCases.getAvailableInventory( warehouseId0, productId6 );
192: 
193:         // then
194:         assertEquals( inventory5before - 1, inventory5after );
195:         assertEquals( inventory0before, inventory0after );
196:         assertEquals( 0, inventory6after );
197:     }
198: 
199: 
200:     @Test
201:     public void testInvalidRemoveFromInventory() {
202:         // given
203:         warehouseTestHelper.addAllWarehouses( true );
204:         UUID warehouseId0 = warehouseTestHelper.getWarehouseId( 0 );
205:         UUID productId0 = productTestHelper.getProductId( 0 ); // 0 in warehouse 0
206:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in warehouse 0
207:         int inventory5before =
208:                 warehouseTestHelper.getWarehouseInventory( 0, 5 );
209: 
210:         // when
211:         // then
212:         assertThrows( ShopException.class,
213:                 () -> warehouseUseCases.removeFromInventory( nonExistingId1, nonExistingId2, 12 ) );
214:         assertThrows( ShopException.class,
215:                 () -> warehouseUseCases.removeFromInventory(
216:                         warehouseId0, nonExistingId2, 12 ) );
217:         assertThrows( ShopException.class,
218:                 () -> warehouseUseCases.removeFromInventory(
219:                         nonExistingId1, productId5, 12 ) );
220:         assertThrows( ShopException.class,
221:                 () -> warehouseUseCases.removeFromInventory(
222:                         warehouseId0, productId5, -1 ) );
223:         assertThrows( ShopException.class,
224:                 () -> warehouseUseCases.removeFromInventory(
225:                         warehouseId0, productId5, inventory5before + 1 ) );
226:         assertThrows( ShopException.class,
227:                 () -> warehouseUseCases.removeFromInventory(
228:                         warehouseId0, productId0, 1 ) ); // already 0 in warehouse 0
229:     }
230: 
231: 
232:     @Test
233:     public void testChangeInventory() {
234:         // given
235:         warehouseTestHelper.addAllWarehouses( true );
236:         UUID warehouseId0 = warehouseTestHelper.getWarehouseId( 0 );
237:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in warehouse 0
238: 
239:         // when
240:         warehouseUseCases.changeInventoryTo( warehouseId0, productId5, 111 );
241:         int inventory5after = warehouseUseCases.getAvailableInventory( warehouseId0, productId5 );
242: 
243:         // then
244:         assertEquals( 111, inventory5after );
245:     }
246: 
247: 
248:     @Test
249:     public void testInvalidChangeInventory() {
250:         // given
251:         warehouseTestHelper.addAllWarehouses( true );
252:         UUID warehouseId0 = warehouseTestHelper.getWarehouseId( 0 );
253:         UUID productId6 = productTestHelper.getProductId( 6 );
254: 
255:         // when
256:         // then
257:         assertThrows( ShopException.class, () -> warehouseUseCases.changeInventoryTo(
258:                 nonExistingId1, nonExistingId2, 12 ) );
259:         assertThrows( ShopException.class, () -> warehouseUseCases.changeInventoryTo(
260:                 nonExistingId1, productId6, 12 ) );
261:         assertThrows( ShopException.class, () -> warehouseUseCases.changeInventoryTo(
262:                 warehouseId0, nonExistingId2, 12 ) );
263:         assertThrows( ShopException.class, () -> warehouseUseCases.changeInventoryTo(
264:                 warehouseId0, productId6, -1 ) );
265:     }
266: 
267: 
268:     @Test
269:     public void testEmptyWarehouse() {
270:         // given
271:         warehouseTestHelper.addAllWarehouses( true );
272:         UUID warehouseId9 = warehouseTestHelper.getWarehouseId( 9 ); // empty warehouse
273: 
274:         // when
275:         int totalInventory = 0;
276:         for ( int iProduct = 0; iProduct < productTestHelper.numberOfProducts(); iProduct++ ) {
277:             UUID productId = productTestHelper.getProductId( iProduct );
278:             totalInventory += warehouseUseCases.getAvailableInventory(
279:                     warehouseId9, productId );
280:         }
281: 
282:         // then
283:         assertEquals( 0, totalInventory );
284:     }
285: 
286: 
287: 
288: }
289: 

[RESPONSE]:
Ich werde den Code nun systematisch auf die genannten Smells analysieren.

## Analyse nach Dateien

---

### **thkoeln\archilab\ecommerce\solution\order\application\OrderService.java**

[OrderService.java] [Zeile 10-11]: **Layer Violation / Shared Persistency** : Zugriff auf `UserRepository` aus dem `user`-Package in der `order`-Application-Schicht. Der OrderService sollte nicht direkt auf das Repository eines anderen Bounded Contexts zugreifen.

---

### **thkoeln\archilab\ecommerce\solution\order\domain\Order.java**

[Order.java] [Zeile 4]: **Layer Violation** : Import von `UserId` aus dem `user.domain`-Package in der `order.domain`-Schicht. Aggregates sollten nur über IDs (UUID) referenzieren, nicht über typisierte IDs anderer Aggregates.

---

### **thkoeln\archilab\ecommerce\solution\order\domain\OrderPart.java**

- **Anemic Entity** - Die Klasse enthält nur Getter und einen Setter, aber keine Geschäftslogik.

---

### **thkoeln\archilab\ecommerce\solution\product\application\ProductService.java**

[ProductService.java] [Zeilen 12-13]: **Layer Violation / Shared Persistency** : Zugriff auf `WarehouseRepository` und `OrderRepository` aus anderen Packages. Der ProductService greift direkt auf Repositories anderer Bounded Contexts zu.

[ProductService.java] [Zeilen 83-96]: **Misplaced Responsibility** : Die Prüfung, ob ein Produkt in Warehouses oder Orders existiert, sollte nicht im ProductService liegen. Diese Logik gehört in die jeweiligen Bounded Contexts (Warehouse/Order) oder in einen übergeordneten Orchestrierungs-Service.

---

### **thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartController.java**

[ShoppingCartController.java] [Zeilen 12-14]: **Layer Violation / Shared Persistency** : Ein Controller greift direkt auf `OrderRepository` zu (Zeile 33, 45). Controller sollten nur Services nutzen, nicht Repositories.

[ShoppingCartController.java] [Zeilen 16-18]: **Layer Violation** : Import von Domain-Klassen aus anderen Packages (`User`, `UserId`, `UserRepository`) im ShoppingCart-Controller.

[ShoppingCartController.java] [Zeilen 97-101, 127-131, 153-157]: **Duplication** : Der Code-Block zum Finden des ShoppingCarts und Users wiederholt sich dreimal:
```java
ShoppingCart cart = shoppingCartRepository.findById(new ShoppingCartId(cartId))
        .orElseThrow(() -> new ShopException("Shopping cart not found"));
User user = userRepository.findById(cart.getUserId())
        .orElseThrow(() -> new ShopException("User not found"));
```
Original: Zeilen 97-101, Duplikate: Zeilen 127-131 und 153-157.

---

### **thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartService.java**

[ShoppingCartService.java] [Zeilen 17-19]: **Layer Violation / Shared Persistency** : Zugriff auf `UserRepository` und `ProductRepository` aus anderen Packages.

[ShoppingCartService.java] [Zeilen 70-73, 98-100, 123-125, 139-141, 186-188]: **Duplication** : Der Code zum Finden eines Users per E-Mail wiederholt sich mehrfach:
```java
String emailString = ((EmailAddress) userEmailAddress).getEmailAddressString();
User user = userRepository.findByEmailAddress(emailString)
        .orElseThrow(() -> new ShopException("User with email " + emailString + " does not exist"));
```
Original: Zeilen 70-73, Duplikate: Zeilen 98-100, 123-125, 139-141.

---

### **thkoeln\archilab\ecommerce\solution\shoppingcart\application\CheckoutOrchestrator.java**

[CheckoutOrchestrator.java] [Zeile 11]: **Layer Violation / Shared Persistency** : Zugriff auf `WarehouseRepository` aus dem `warehouse`-Package.

---

### **thkoeln\archilab\ecommerce\solution\shoppingcart\application\InventoryManager.java**

[InventoryManager.java] [Zeilen 5-7]: **Layer Violation / Shared Persistency** : Zugriff auf `WarehouseRepository` und `Warehouse` aus dem `warehouse`-Package.

---

### **thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPart.java**

- **Anemic Entity** - Die Klasse enthält hauptsächlich Getter/Setter und nur minimale Logik (addQuantity, removeQuantity).

---

### **thkoeln\archilab\ecommerce\solution\warehouse\application\WarehouseService.java**

[WarehouseService.java] [Zeilen 64-68, 89-93, 119-123, 141-145]: **Duplication** : Der Code zur Produktvalidierung wiederholt sich viermal:
```java
try {
    productCatalogUseCases.getSalesPrice(productId);
} catch (ShopException e) {
    throw new ShopException("Product with ID " + productId + " does not exist");
}
```
Original: Zeilen 64-68, Duplikate: Zeilen 89-93, 119-123, 141-145.

---

### **thkoeln\archilab\ecommerce\solution\warehouse\domain\InventoryLevel.java**

- **Anemic Entity** - Die Klasse enthält nur Getter/Setter und einfache add/remove-Methoden ohne echte Geschäftslogik.

---

### **thkoeln\archilab\ecommerce\solution\user\application\UserService.java**

[UserService.java] [Zeilen 37, 57, 73]: **Duplication** : Der Cast `EmailAddress email = (EmailAddress) emailAddress;` wiederholt sich dreimal. Original: Zeile 37, Duplikate: Zeilen 57 und 73.

---

### **thkoeln\archilab\ecommerce\domainprimitives\ProductRepository.java**

[ProductRepository.java] [Zeile 4]: **Dead Code** : Import `java.util.UUID` wird nicht verwendet.

---

### **thkoeln\archilab\ecommerce\solution\order\domain\OrderRepository.java**

[OrderRepository.java] [Zeile 7]: **Dead Code** : Import `java.util.UUID` wird nicht verwendet.

---

### **thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartRepository.java**

[ShoppingCartRepository.java] [Zeile 7]: **Dead Code** : Import `java.util.UUID` wird nicht verwendet.

---

### **thkoeln\archilab\ecommerce\solution\warehouse\domain\WarehouseRepository.java**

[WarehouseRepository.java] [Zeile 4]: **Dead Code** : Import `java.util.UUID` wird nicht verwendet.

---

### **thkoeln\archilab\ecommerce\solution\order\domain\OrderJpaRepository.java**

[OrderJpaRepository.java] [Zeile 8]: **Dead Code** : Import `java.util.UUID` wird nicht verwendet.

---

### **thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartJpaRepository.java**

[ShoppingCartJpaRepository.java] [Zeile 8]: **Dead Code** : Import `java.util.UUID` wird nicht verwendet.

---

### **thkoeln\archilab\ecommerce\solution\product\domain\ProductJpaRepository.java**

[ProductJpaRepository.java] [Zeile 6]: **Dead Code** : Import `java.util.UUID` wird nicht verwendet.

---

### **thkoeln\archilab\ecommerce\domainprimitives\EmailAddress.java**

[EmailAddress.java] [Zeile 10]: **Dead Code** : Import `java.util.regex.Pattern` wird nicht verwendet.

ENDE
Generated by claude-opus-4-5-20251101
-----------------------------------