--- DATE: 13.1.2026, 14:02:37 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
        Architektur: 4-Layer (Eric Evans).
        Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
        Regeln:
        1. Begründe kurz jeden Fund.
        4. Gruppiere nach Datei (mit Pfad). 
        2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
        3. Keine Code-Wiederholung, nur Referenzen.
        5. Wenn fertig, schreibe "ENDE". 
        6. Nutze die Zeilenangaben die mitgeschickt worden sind.



--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Email.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import jakarta.persistence.Embeddable;
5: import lombok.EqualsAndHashCode;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
10: 
11: @Embeddable
12: @EqualsAndHashCode
13: @Getter
14: @NoArgsConstructor
15: public class Email implements EmailType {
16: 
17:     @JsonProperty("emailString")
18:     private String email;
19: 
20:     public Email(String email) {
21:         validateEmail(email);
22:         this.email = email;
23:     }
24: 
25:     private void validateEmail(String email) {
26:         validateNotNull(email);
27:         validateNoSpaces(email);
28: 
29:         String[] parts = getEmailParts(email);
30:         if (parts.length != 2) {
31:             throw new ShopException("Email must contain exactly one '@'");
32:         }
33: 
34:         String identifier = parts[0];
35:         String domain = parts[1];
36: 
37:         if (!isValidIdentifier(identifier)) {
38:             throw new ShopException("Invalid email identifier part");
39:         }
40: 
41:         if (!isValidDomain(domain)) {
42:             throw new ShopException("Invalid email domain part");
43:         }
44:     }
45: 
46:     private void validateNoSpaces(String email) {
47:         if (!email.equals(email.trim())) {
48:             throw new ShopException("Email must not have leading or trailing spaces");
49:         }
50:     }
51: 
52:     private static void validateTLD(String domain) {
53:         if (!(domain.endsWith(".de") || domain.endsWith(".at") || domain.endsWith(".ch") ||
54:                 domain.endsWith(".com") || domain.endsWith(".org"))) {
55:             throw new ShopException("Email must end with a valid domain (.de, .at, .ch, .com, .org)");
56:         }
57:     }
58: 
59:     private static void validateNotNull(String email) {
60:         if (email == null || email.trim().isEmpty()) {
61:             throw new ShopException("Email cannot be null");
62:         }
63:     }
64: 
65:     private static String[] getEmailParts(String email) {
66:         return email.split("@", -1);
67:     }
68: 
69:     private boolean isValidIdentifier(String identifier) {
70:         if (identifier.isEmpty()) return false;
71:         if (identifier.contains(" ")) return false;
72:         if (identifier.contains("..")) return false;
73:         if (!identifier.matches("[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*")) return false;
74: 
75:         return true;
76:     }
77: 
78:     private boolean isValidDomain(String domain) {
79:         if (domain.isEmpty()) return false;
80:         if (domain.contains(" ")) return false;
81:         if (domain.contains("..")) return false;
82:         if (!domain.matches("[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*")) return false;
83:         validateTLD(domain);
84:         return true;
85:     }
86: 
87:     public String getIdentifier() {
88:         return email.split("@", -1)[0];
89:     }
90: 
91:     public String getDomain() {
92:         return email.split("@", -1)[1];
93:     }
94: 
95: 
96: 
97:     public static EmailType of( String emailAsString ) {
98:         return new Email( emailAsString );
99:     }
100: 
101:     /**
102:      * A special kind of "copy constructor": Returns a new email object with
103:      * the same identifyer (the substring left of the "@" sign) as the current one, but
104:      * with a new domain substring (right of the "@" sign).
105:      * @param domainString - the new domain for the copied email
106:      * @return the new email
107:      * @throws ShopException if ...
108:      *     - domainString is null
109:      *     - the new email would not be valid (see `of(...)` method)
110:      */
111:     @Override
112:     public EmailType sameIdentifyerDifferentDomain(String domainString) {
113:         validateNotNull(domainString);
114: 
115:         String identifier = getIdentifier();
116:         String newEmail = identifier + "@" + domainString;
117: 
118:         return new Email(newEmail);
119:         
120:     }
121: 
122:     /**
123:      * Another special kind of "copy constructor": Returns a new email object
124:      * with the same domain (the substring right of the "@" sign) as the current one, but
125:      * with a new identifyer substring (left of the "@" sign).
126:      * @param identifyerString - the new identifyer for the copied email
127:      * @return the new email
128:      * @throws ShopException if ...
129:      *     - identifyerString is null
130:      *     - the new email would not be valid (see `of(...)` method)
131:      */
132:     @Override
133:     public EmailType sameDomainDifferentIdentifyer(String identifyerString) {
134:         validateNotNull(identifyerString);
135: 
136:         String domain = getDomain();
137:         String newEmail = identifyerString + "@" + domain;
138: 
139:         return new Email(newEmail);
140:     }
141: 
142:     @Override
143:     public String toString() {
144:         return email;
145:     }
146: }
147: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\EmptyCartException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public class EmptyCartException extends ShopException {
6:     public EmptyCartException(String message) {
7:         super(message);
8:     }
9: }
10: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import jakarta.persistence.Embeddable;
5: import lombok.EqualsAndHashCode;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
10: 
11: @Embeddable
12: @EqualsAndHashCode
13: @Getter
14: @NoArgsConstructor
15: public class Money implements MoneyType {
16: 
17:     private Float amount;
18: 
19:     @JsonProperty("currency")
20:     private String currencyUnit;
21: 
22:     public Money(Float amount, String currencyUnit) {
23:         validateAmount(amount);
24:         validateCurrencyUnit(currencyUnit);
25: 
26:         this.amount = amount;
27:         this.currencyUnit = currencyUnit;
28:     }
29: 
30:     private static void validateCurrencyUnit(String currencyUnit) {
31:         if (currencyUnit == null || currencyUnit.trim().isEmpty()) {
32:             throw new ShopException("Currency unit cannot be null or empty");
33:         }
34:         if (!currencyUnit.equals("EUR") && !currencyUnit.equals("CHF")) {
35:             throw new ShopException("Currency unit must be 'EUR' or 'CHF'");
36:         }
37:     }
38: 
39:     private static void validateAmount(Float amount) {
40:         if (amount == null) {
41:             throw new ShopException("Amount cannot be null");
42:         }
43:         if (amount < 0) {
44:             throw new ShopException("Amount cannot be negative");
45:         }
46:     }
47: 
48: 
49:     @Override
50:     public Float getAmount() {
51:         return amount;
52:     }
53: 
54:     @Override
55:     public String getCurrencyUnit() {
56:         return currencyUnit;
57:     }
58: 
59:     /**
60:      * @param otherMoney
61:      * @return this + otherMoney, as a new object
62:      * @throws ShopException if ...
63:      *      - otherMoney is null
64:      *      - otherMoney.currencyUnit != this.currencyUnit
65:      */
66:     @Override
67:     public MoneyType add(MoneyType otherMoney) {
68:         validateMoneyNotNull(otherMoney);
69:         checkSameCurrencyUnit(otherMoney);
70: 
71:         return new Money(this.amount + otherMoney.getAmount(), this.currencyUnit);
72:     }
73: 
74:     private static void validateMoneyNotNull(MoneyType otherMoney) {
75:         if (otherMoney == null) {
76:             throw new ShopException("otherMoney cannot be null");
77:         }
78:     }
79: 
80:     private void checkSameCurrencyUnit(MoneyType otherMoney) {
81:         if (!this.currencyUnit.equals(otherMoney.getCurrencyUnit())) {
82:             throw new ShopException("Currency units do not match");
83:         }
84:     }
85: 
86:     /**
87:      * @param otherMoney
88:      * @return this - otherMoney, as a new object
89:      * @throws ShopException if ...
90:      *      - otherMoney is null
91:      *      - otherMoney.currencyUnit != this.currencyUnit
92:      *      - otherMoney > this
93:      */
94:     @Override
95:     public MoneyType subtract(MoneyType otherMoney) {
96:         validateMoneyNotNull(otherMoney);
97:         checkSameCurrencyUnit(otherMoney);
98: 
99:         if (this.amount < otherMoney.getAmount()) {
100:             throw new ShopException("Cannot subtract a larger amount from a smaller one");
101:         }
102: 
103:         return new Money(this.amount - otherMoney.getAmount(), this.currencyUnit);
104:     }
105: 
106:     /**
107:      * @param factor
108:      * @return this * factor, as a new object
109:      * @throws ShopException if ...
110:      *     - factor < 0
111:      */
112:     @Override
113:     public MoneyType multiplyBy(int factor) {
114:         if (factor < 0) {
115:             throw new ShopException("Factor cannot be negative");
116:         }
117: 
118:         return new Money(this.amount * factor, this.currencyUnit);
119:     }
120: 
121:     /**
122:      * @param otherMoney
123:      * @return true, if this > otherMoney
124:      * @throws ShopException if ...
125:      *      - otherMoney is null
126:      *      - otherMoney.currencyUnit != this.currencyUnit
127:      */
128:     @Override
129:     public boolean largerThan(MoneyType otherMoney) {
130:         validateMoneyNotNull(otherMoney);
131:         checkSameCurrencyUnit(otherMoney);
132: 
133:         return this.amount > otherMoney.getAmount();
134:     }
135:     /**
136:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
137:      * implementing class to provide a static factory method (simply named "of(...)"),
138:      * which creates a money object from an amount and a currency unit (as string).
139:      * We specify this factory method here as a comment, using the Javadoc documentation style.
140:      *
141:      * @param amount the amount of money (must be >= 0)
142:      * @param currencyUnit the currency unit of the money (allowed values: "EUR", "CHF")
143:      * @return a new Money object with the given amount and currency unit
144:      * @throws ShopException if ...
145:      *   - amount is null
146:      *   - amount < 0
147:      *   - currency unit is null
148:      *   - currency unit is not one of the allowed values
149:      */
150:     public static MoneyType of( Float amount, String currencyUnit ){
151:         validateAmount(amount);
152:         validateCurrencyUnit(currencyUnit);
153: 
154:         return new Money(amount, currencyUnit);
155:     }
156: 
157:     @Override
158:     public String toString() {
159:         return amount + " " + currencyUnit;
160:     }
161: 
162: }
163: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PhysicalAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Access;
4: import jakarta.persistence.AccessType;
5: import jakarta.persistence.Embeddable;
6: import lombok.EqualsAndHashCode;
7: import lombok.Getter;
8: import lombok.NoArgsConstructor;
9: import thkoeln.archilab.ecommerce.ShopException;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
12: 
13: @Embeddable
14: @EqualsAndHashCode
15: @Getter
16: @NoArgsConstructor
17: @Access(AccessType.FIELD)
18: public class PhysicalAddress implements PhysicalAddressType {
19: 
20:     private String street;
21:     private String city;
22:     private ZipCode zipCode;
23: 
24:     public PhysicalAddress(String street, String city, ZipCode zipCode) {
25:         validateStreet(street);
26:         validateCity(city);
27:         validateZipCode(zipCode);
28: 
29:         this.street = street;
30:         this.city = city;
31:         this.zipCode = zipCode;
32:     }
33: 
34:     private void validateZipCode(ZipCodeType zipCode) {
35:         if (zipCode == null) {
36:             throw new ShopException("Zip code must not be null");
37:         }
38:     }
39:     private void validateCity(String city) {
40:         if (city == null || city.trim().isEmpty()) {
41:             throw new ShopException("City must not be null or empty");
42:         }
43:     }
44: 
45:     private void validateStreet(String street) {
46:         if (street == null || street.trim().isEmpty()) {
47:             throw new ShopException("Street must not be null or empty");
48:         }
49:     }
50: 
51:     @Override
52:     public String getStreet() {
53:         return street;
54:     }
55: 
56:     @Override
57:     public String getCity() {
58:         return city;
59:     }
60: 
61:     @Override
62:     public ZipCodeType getZipCode() {
63:         return zipCode;
64:     }
65: 
66:     public static PhysicalAddressType of( String street, String city, ZipCodeType zipCode ){
67:         if (!(zipCode instanceof ZipCode zipCodeImpl)) {
68:             throw new ShopException("Only ZipCode instances are supported");
69:         }
70: 
71:         return new PhysicalAddress(street, city, zipCodeImpl);
72:     }
73: }
74: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import jakarta.persistence.Embeddable;
5: import lombok.EqualsAndHashCode;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
10: 
11: @Embeddable
12: @EqualsAndHashCode
13: @Getter
14: @NoArgsConstructor
15: public class ZipCode implements ZipCodeType {
16: 
17:     @JsonProperty("zipCodeString")
18:     private String zipCode;
19: 
20:     public ZipCode(String zipCode) {
21:         validateZipCodeNotNull(zipCode);
22:         validateZipCodeFormat(zipCode);
23:         this.zipCode = zipCode;
24:     }
25: 
26: 
27:     /**
28:      * You will need some idea of "imprecise difference" between two zip codes for properly
29:      * implementing storage units in your shopping platform. This method calculates such a
30:      * difference. You can decide for yourself what values you return, unless you comply
31:      * with the following rules.
32:      * - The return value is 0 if both zip codes are the same
33:      * - If not:
34:      *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
35:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
36:      *        So, 56733 and 56734 have the same difference as 56733 and 56739.
37:      *      - The difference grows if more digits (counted from the right side) differ.
38:      *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
39:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
40:      *        53876 and 54876 have the same difference as 53876 and 57261.
41:      *      - However, the difference between 5abcd and 6rstu must be smaller than the one
42:      *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
43:      *        one between 5abcd and 9rstu.
44:      *      - This last condition reflects the fact the first digits of a zip code marks a region
45:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
46:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
47:      *        other.
48:      * @param otherZipCode
49:      * @return the calculated difference
50:      * @throws ShopException if otherZipCode is null
51:      */
52:     @Override
53:     public int difference(ZipCodeType otherZipCode) {
54:         if (otherZipCode == null) {
55:             throw new ShopException("Other zip code must not be null");
56:         }
57: 
58:         String other = otherZipCode.toString();
59: 
60:         if (this.zipCode.equals(other)) {
61:             return 0;
62:         }
63: 
64:         // Abweichung in den Stellen 1–4 (Ziffern 2. bis 5.)
65:         int diffLevel = 0;
66:         for (int i = 1; i < 5; i++) {
67:             if (this.zipCode.charAt(i) != other.charAt(i)) {
68:                 diffLevel = 5 - i;
69:                 break;
70:             }
71:         }
72: 
73:         int thisRegion = Character.getNumericValue(this.zipCode.charAt(0));
74:         int otherRegion = Character.getNumericValue(other.charAt(0));
75:         int regionDiff = regionDistance(thisRegion, otherRegion);
76: 
77:         return diffLevel + regionDiff * 10;
78:     }
79: 
80:     private int regionDistance(int a, int b) {
81:         int diff = Math.abs(a - b);
82:         return Math.min(diff, 10 - diff); // zyklisch: 0 und 9 sind benachbart
83:     }
84: 
85: 
86: 
87:     /**
88:      * For the currently used way of deciding on the best fitting storage unit for a purchase,
89:      * we need to know the first digit of the zip code.
90:      */
91:     @Override
92:     public Integer getFirstDigitZipCode() {
93:         String zipCodeString = this.toString();
94:         return Integer.parseInt(zipCodeString.substring(0, 1));
95:     }
96: 
97:     /**
98:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
99:      * implementing class to provide a static factory method (simply named "of(...)"),
100:      * which creates an zip code, given as a string.
101:      * We specify this factory method here as a comment, using the Javadoc documentation style.
102:      *
103:      * @param zipCodeAsString - the zip code as a string.
104:      *      We will use a much simplified validation method to check if the zip code is valid:
105:      *      - It must contain exactly 5 digits.
106:      *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid zip code, but 20001 is valid)
107:      * @return a new zip code object matching the given string
108:      * @throws ShopException if ...
109:      *      - zipCodeAsString is null
110:      *      - zipCodeAsString is not a valid zip code (see above)
111:      */
112:     public static ZipCodeType of( String zipCodeAsString ){
113:         validateZipCodeNotNull(zipCodeAsString);
114:         validateZipCodeFormat(zipCodeAsString);
115:         return new ZipCode(zipCodeAsString);
116:     }
117: 
118:     private static void validateZipCodeFormat(String zipCodeAsString) {
119:         if (!zipCodeAsString.matches("\\d{5}")) {
120:             throw new ShopException("Zip code must contain exactly 5 digits");
121:         }
122:         if (zipCodeAsString.substring(1, 5).equals("0000")) {
123:             throw new ShopException("Zip code cannot end with 0000");
124:         }
125:     }
126: 
127:     private static void validateZipCodeNotNull(String zipCodeAsString) {
128:         if (zipCodeAsString == null) {
129:             throw new ShopException("Zip code cannot be null");
130:         }
131:     }
132: 
133:     @Override
134:     public String toString() {
135:         return zipCode;
136:     }
137: }
138: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, CIDE Institute, TH Köln
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.Column;
7: import jakarta.persistence.MappedSuperclass;
8: import lombok.EqualsAndHashCode;
9: import lombok.Getter;
10: import lombok.ToString;
11: 
12: import java.io.Serializable;
13: import java.util.UUID;
14: 
15: @MappedSuperclass
16: @Getter
17: @EqualsAndHashCode(of = "id")
18: @ToString(of = "id")
19: public abstract class GenericId implements Serializable {
20:     @Column(nullable = false, updatable = false)
21:     private final UUID id;
22: 
23:     protected GenericId() {
24:         this( UUID.randomUUID() );
25:     }
26: 
27:     protected GenericId( UUID id ) {
28:         this.id = id;
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, CIDE Institute, TH Köln
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.AttributeConverter;
7: import jakarta.persistence.Converter;
8: 
9: import java.util.UUID;
10: import java.util.function.Function;
11: 
12: 
13: @Converter
14: public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
15:     private final Function<UUID, T> factory;
16: 
17:     protected GenericIdConverter( Function<UUID, T> factory ) {
18:         this.factory = factory;
19:     }
20: 
21:     @Override
22:     public UUID convertToDatabaseColumn( T attribute ) {
23:         return attribute == null ? null : attribute.getId();
24:     }
25: 
26:     @Override
27:     public T convertToEntityAttribute( UUID dbData ) {
28:         return dbData == null ? null : factory.apply( dbData );
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\InsufficientStockException.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, CIDE Institute, TH Köln
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: /**
7:  * Exception is thrown if the product's stock level is not sufficient to serve the purchase.
8:  */
9: public class InsufficientStockException extends ShopException {
10:     public InsufficientStockException( String message ) {
11:         super( message );
12:     }
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, CIDE Institute, TH Köln
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import org.springframework.boot.SpringApplication;
7: import org.springframework.boot.autoconfigure.SpringBootApplication;
8: 
9: 
10: @SpringBootApplication
11: public class ProjectApplication {
12: 
13: 	/**
14: 	 * Entry method
15: 	 * @param args
16: 	 */
17: 	public static void main(String[] args) {
18: 		SpringApplication.run(ProjectApplication.class, args);
19: 	}
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, CIDE Institute, TH Köln
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: public class ShopException extends RuntimeException {
7:     public ShopException( String message ) {
8:         super( message );
9:     }
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\applicationServices\ProductCatalogService.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application.applicationServices;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Money;
7: import thkoeln.archilab.ecommerce.solution.product.domain.entities.Product;
8: import thkoeln.archilab.ecommerce.solution.product.domain.repositories.ProductRepository;
9: import thkoeln.archilab.ecommerce.solution.product.domain.valueObjects.ProductId;
10: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
12: 
13: import java.util.UUID;
14: 
15: 
16: @Service
17: public class ProductCatalogService implements ProductCatalogUseCases {
18:     private final ProductRepository productRepository;
19:     private final PurchaseProductUsageChecker purchaseChecker;
20:     private final ShoppingCartProductUsageChecker cartChecker;
21:     private final StorageUnitProductUsageChecker stockChecker;
22:     @Autowired
23:     public ProductCatalogService(ProductRepository productRepository,
24:                                  PurchaseProductUsageChecker purchaseChecker,
25:                                  ShoppingCartProductUsageChecker cartChecker,
26:                                  StorageUnitProductUsageChecker stockChecker) {
27:         this.productRepository = productRepository;
28:         this.purchaseChecker = purchaseChecker;
29:         this.cartChecker = cartChecker;
30:         this.stockChecker = stockChecker;
31:     }
32: 
33:     /**
34:      * Adds a new product to the shop catalog
35:      * @param name
36:      * @param descriptionOf
37:      * @param size
38:      * @param buyingPrice
39:      * @param salesPrice
40:      * @return the id of the new product
41:      * @throws ShopException if ...
42:      *         - the product id already exists,
43:      *         - name or description are null or empty,
44:      *         - the size is <= 0 (but can be null!),
45:      *         - the buying price is null or <= 0,
46:      *         - the sales price is null or <= 0,
47:      *         - the sales price is lower than the buying price
48:      */
49:     @Override
50:     public UUID addProductToCatalog(String name, String descriptionOf, Float size, MoneyType buyingPrice, MoneyType salesPrice) {
51: 
52:         if (buyingPrice == null) {
53:             throw new ShopException("Buying price must not be null");
54:         }
55:         if (salesPrice == null) {
56:             throw new ShopException("Sales price must not be null");
57:         }
58:         if (name == null || name.isEmpty()) {
59:             throw new ShopException("Name must not be null or empty");
60:         }
61:         if (descriptionOf == null || descriptionOf.isEmpty()) {
62:             throw new ShopException("Description must not be null or empty");
63:         }
64:         if (size != null && size <= 0) {
65:             throw new ShopException("Size must be greater than 0, or null");
66:         }
67:         if (buyingPrice.largerThan(salesPrice)) {
68:             throw new ShopException("Sales price must not be larger than buying price");
69:         }
70: 
71:         Product product = new Product(
72:                 name,
73:                 descriptionOf,
74:                 size != null ? size.doubleValue() : null,
75:                 (Money) buyingPrice,
76:                 (Money) salesPrice
77:         );
78: 
79:         ensureProductIdDoesNotExist(product.getId().getId());
80:         productRepository.save(product);
81:         return product.getId().getId();
82:     }
83: 
84:     /**
85:      * Removes a product from the shop catalog
86:      * @param productId
87:      * @throws ShopException if
88:      *      - the product id does not exist
89:      *      - the product is still in stock
90:      *      - the product is still in a shopping cart, or referenced by a completed purchase
91:      */
92:     @Override
93:     public void removeProductFromCatalog(UUID productId) {
94:         ensureProductIdDoesExist(productId);
95:         ensureProductNotInStock(productId);
96:         ensureProductNotInShoppingCart(productId);
97:         ensureProductNotInPurchase(productId);
98: 
99:         productRepository.deleteById(new ProductId(productId));
100:     }
101: 
102:     /**
103:      * Get the sales price of a given product
104:      * @param productId
105:      * @return the sales price
106:      * @throws ShopException if the product id does not exist
107:      */
108:     @Override
109:     public MoneyType getSalesPrice(UUID productId) {
110:         return getExistingProductOrThrow(productId).getSellingPrice();
111:     }
112: 
113:     /**
114:      * Clears the product catalog, i.e. removes all products from the catalog, including all the stock,
115:      * all the reservations and all the purchases.
116:      */
117:     @Override
118:     public void deleteProductCatalog() {
119:         productRepository.deleteAll();
120:     }
121: 
122:     private void ensureProductIdDoesNotExist(UUID id) {
123:         if (productRepository.existsById(new ProductId(id))) {
124:             throw new ShopException("Product ID already exists");
125:         }
126:     }
127: 
128:     public void ensureProductIdDoesExist(UUID productId) {
129:         if (!productRepository.existsById(new ProductId(productId))) {
130:             throw new ShopException("Product ID does not exist");
131:         }
132:     }
133: 
134:     public Product getExistingProductOrThrow(UUID productId) {
135:         return productRepository.findById(new ProductId(productId))
136:                 .orElseThrow(() -> new ShopException("Product with this ID does not exist"));
137:     }
138: 
139:     public void ensureProductNotInPurchase(UUID productId) {
140:         if (purchaseChecker.isProductInPurchase(productId)) {
141:             throw new ShopException("Product is already in a purchase");
142:         }
143:     }
144: 
145:     public void ensureProductNotInShoppingCart(UUID productId) {
146:         if (cartChecker.isProductInShoppingCart(productId)) {
147:             throw new ShopException("Product is already in a shopping cart");
148:         }
149:     }
150: 
151:     public void ensureProductNotInStock(UUID productId) {
152:         if (stockChecker.isProductInStock(productId)) {
153:             throw new ShopException("Product is in stock");
154:         }
155:     }
156: }
157: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\applicationServices\PurchaseProductUsageChecker.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application.applicationServices;
2: 
3: import java.util.UUID;
4: 
5: public interface PurchaseProductUsageChecker {
6:     boolean isProductInPurchase(UUID productId);
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\applicationServices\ShoppingCartProductUsageChecker.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application.applicationServices;
2: 
3: import java.util.UUID;
4: 
5: public interface ShoppingCartProductUsageChecker {
6:     boolean isProductInShoppingCart(UUID productId);
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\applicationServices\StorageUnitProductUsageChecker.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application.applicationServices;
2: 
3: import java.util.UUID;
4: 
5: public interface StorageUnitProductUsageChecker {
6:     boolean isProductInStock(UUID productId);
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\entities\Product.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain.entities;
2: 
3: import jakarta.persistence.EmbeddedId;
4: import jakarta.persistence.Entity;
5: import lombok.*;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.domainprimitives.Money;
8: import thkoeln.archilab.ecommerce.solution.product.domain.valueObjects.ProductId;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
10: 
11: 
12: @Entity
13: @Getter
14: @Setter
15: @AllArgsConstructor
16: @NoArgsConstructor
17: public class Product {
18:     @Setter(AccessLevel.PRIVATE)    // only for JPA
19:     @EmbeddedId
20:     private ProductId id;
21: 
22:     private String name;
23:     private String description;
24:     private Double size;
25:     private Money buyingPrice;
26:     private Money sellingPrice;
27: 
28:     public Product(String name, String descriptionOf, Double size, Money buyingPrice, Money salesPrice) {
29: 
30:         validateName(name);
31:         validateDescription(descriptionOf);
32:         validateSize(size);
33: 
34:         this.id = new ProductId();
35:         this.name = name;
36:         this.description = descriptionOf;
37:         this.size = size;
38:         this.buyingPrice = buyingPrice;
39:         this.sellingPrice = salesPrice;
40:     }
41: 
42: 
43:     private void validateName(String name) {
44:         if (name == null || name.trim().isEmpty()) {
45:             throw new ShopException("Name must not be null or empty");
46:         }
47:     }
48: 
49:     private void validateDescription(String description) {
50:         if (description == null || description.trim().isEmpty()) {
51:             throw new ShopException("Description must not be null or empty");
52:         }
53:     }
54: 
55:     private void validateSize(Double size) {
56:         if (size != null && size <= 0) {
57:             throw new ShopException("Size must be greater than 0");
58:         }
59:     }
60: }
61: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\repositories\ProductRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain.repositories;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import thkoeln.archilab.ecommerce.solution.product.domain.entities.Product;
5: import thkoeln.archilab.ecommerce.solution.product.domain.valueObjects.ProductId;
6: 
7: public interface ProductRepository extends CrudRepository<Product, ProductId> {
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\valueObjects\ProductId.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain.valueObjects;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.io.Serializable;
11: import java.util.UUID;
12: 
13: @Embeddable
14: @NoArgsConstructor(access = AccessLevel.PUBLIC)
15: @AttributeOverride(name = "id", column = @Column(name = "product_id"))
16: public class ProductId extends GenericId implements Serializable {
17:     public ProductId(UUID id) {
18:         super(id);
19:     }
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\valueObjects\ProductIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain.valueObjects;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ProductIdConverter extends GenericIdConverter<ProductId> {
8:     public ProductIdConverter() {
9:         super(ProductId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\applicationServices\PurchaseCheckerService.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.application.applicationServices;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.product.application.applicationServices.PurchaseProductUsageChecker;
6: import thkoeln.archilab.ecommerce.solution.product.domain.valueObjects.ProductId;
7: import thkoeln.archilab.ecommerce.solution.purchase.domain.entities.Purchase;
8: import thkoeln.archilab.ecommerce.solution.purchase.domain.repositories.PurchaseRepository;
9: import thkoeln.archilab.ecommerce.solution.purchase.domain.valueObjects.PurchasePart;
10: 
11: import java.util.List;
12: import java.util.UUID;
13: 
14: @Service
15: public class PurchaseCheckerService implements PurchaseProductUsageChecker {
16: 
17:     private final PurchaseRepository purchaseRepository;
18: 
19:     @Autowired
20:     public PurchaseCheckerService(PurchaseRepository purchaseRepository) {
21:         this.purchaseRepository = purchaseRepository;
22:     }
23: 
24:     @Override
25:     public boolean isProductInPurchase(UUID productId) {
26:         List<Purchase> purchases = (List<Purchase>) purchaseRepository.findAll();
27:         for (Purchase purchase : purchases) {
28:             for (PurchasePart part : purchase.getPurchaseParts()) {
29:                 if (part.getProduct().getId().equals(new ProductId(productId))) {
30:                     return true;
31:                 }
32:             }
33:         }
34:         return false;
35:     }
36: }
37: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\applicationServices\PurchaseService.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.application.applicationServices;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Email;
7: import thkoeln.archilab.ecommerce.solution.purchase.domain.entities.Purchase;
8: import thkoeln.archilab.ecommerce.solution.purchase.domain.repositories.PurchaseRepository;
9: import thkoeln.archilab.ecommerce.solution.purchase.domain.valueObjects.PurchaseId;
10: import thkoeln.archilab.ecommerce.solution.purchase.domain.valueObjects.PurchasePart;
11: import thkoeln.archilab.ecommerce.solution.user.application.applicationServices.UserRegistrationService;
12: import thkoeln.archilab.ecommerce.solution.user.domain.entities.User;
13: import thkoeln.archilab.ecommerce.usecases.PurchaseUseCases;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
15: 
16: import java.util.*;
17: 
18: 
19: @Service
20: public class PurchaseService implements PurchaseUseCases {
21:     private final PurchaseRepository purchaseRepository;
22:     private final UserRegistrationService userRegistrationService;
23:     @Autowired
24:     public PurchaseService( PurchaseRepository purchaseRepository, UserRegistrationService userRegistrationService) {
25:         this.purchaseRepository = purchaseRepository;
26:         this.userRegistrationService = userRegistrationService;
27:     }
28: 
29: 
30:     /**
31:      * Returns a map showing which products have been purchased by a user and how many of each product
32:      *
33:      * @param userEmail
34:      * @return the purchase history of the user (map is empty if the user has not purchased anything yet)
35:      * @throws ShopException if
36:      *      - userEmail is null or empty
37:      *      - the user with the given email does not exist
38:      */
39:     @Override
40:     public Map<UUID, Integer> getPurchaseHistory(EmailType userEmail) {
41: 
42:         Map<UUID, Integer> purchaseHistory = new HashMap<>();
43: 
44:         User user = userRegistrationService.getExistingUserOrThrow((Email) userEmail);
45: 
46:         purchaseRepository.findAll().forEach(purchase -> {
47:             if (purchase.getUser().getId().equals(user.getId())) {
48:                 purchase.getPurchaseParts().forEach(
49:                         purchasePart -> {
50:                             UUID productId = purchasePart.getProduct().getId().getId();
51:                             int quantity = purchasePart.getQuantity();
52:                             purchaseHistory.put(productId, purchaseHistory.getOrDefault(productId, 0) + quantity);
53:                         }
54:                 );
55:             }
56:         });
57: 
58:         return purchaseHistory;
59:     }
60: 
61: 
62:     /**
63:      * @return the number of products in a given purchase. If the product is not a part of the purchase, the method
64:      *         returns 0. No exception is thrown.
65:      * @param purchaseId - the id of the purchase to be checked
66:      * @param productId - the id of the product for which we want to know the quantity
67:      * @throws ShopException if
68:      *     - purchaseId is null, or doesn't exist in the system
69:      *     - productId is null, or doesn't exist in the system
70:      */
71:     @Override
72:     public Integer getPurchaseQuantityOfProduct(UUID purchaseId, UUID productId) {
73: 
74:         PurchaseId purchaseId1 = new PurchaseId(purchaseId);
75:         Purchase purchase = purchaseRepository.findById(purchaseId1)
76:                 .orElseThrow(() -> new ShopException("Purchase with ID " + purchaseId + " does not exist."));
77: 
78:         List<PurchasePart> parts = purchase.getPurchaseParts();
79:         for (PurchasePart part : parts) {
80:             if (part.getProduct().getId().getId().equals(productId)) {
81:                 return part.getQuantity();
82:             }
83:         }
84: 
85:         return 0;
86:     }
87: 
88: 
89: 
90:     /**
91:      * @return the id of the storage unit that is responsible for the given purchase
92:      * @param purchaseId - the id of the purchase to be checked
93:      * @throws ShopException if
94:      *      - purchaseId is null, or doesn't exist in the system
95:      */
96:     @Override
97:     public UUID getStorageUnitIdForPurchase(UUID purchaseId) {
98: 
99:         PurchaseId purchaseId1 = new PurchaseId(purchaseId);
100:         Purchase purchase = purchaseRepository.findById(purchaseId1)
101:                 .orElseThrow(() -> new ShopException("Purchase with ID " + purchaseId + " does not exist."));
102: 
103:         return purchase.getStorageUnit().getId().getId();
104:     }
105: 
106:     @Override
107:     public void deleteAllPurchases() {
108:         purchaseRepository.deleteAll();
109:     }
110: 
111:     public Purchase getPurchaseById(UUID purchaseId) {
112:         PurchaseId id = new PurchaseId(purchaseId);
113:         return purchaseRepository.findById(id)
114:                 .orElseThrow(() -> new ShopException("Purchase with ID " + purchaseId + " does not exist."));
115:     }
116: 
117: 
118: }
119: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\entities\Purchase.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain.entities;
2: 
3: import jakarta.persistence.*;
4: import lombok.*;
5: import thkoeln.archilab.ecommerce.solution.purchase.domain.valueObjects.PurchaseId;
6: import thkoeln.archilab.ecommerce.solution.purchase.domain.valueObjects.PurchasePart;
7: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnit;
8: import thkoeln.archilab.ecommerce.solution.user.domain.entities.User;
9: 
10: import java.util.List;
11: 
12: @Entity
13: @Getter
14: @Setter
15: @AllArgsConstructor
16: @NoArgsConstructor
17: public class Purchase {
18:     @Setter(AccessLevel.PRIVATE)    // only for JPA
19:     @EmbeddedId
20:     private PurchaseId id;
21: 
22:     @ManyToOne
23:     private User user;
24: 
25:     @ElementCollection(fetch = FetchType.EAGER)
26:     private List<PurchasePart> purchaseParts;
27: 
28:     @ManyToOne
29:     private StorageUnit storageUnit;
30: 
31:     public Purchase(User user, List<PurchasePart> purchaseParts, StorageUnit storageUnit) {
32:         this.id = new PurchaseId();
33:         this.user = user;
34:         this.purchaseParts = purchaseParts;
35:         this.storageUnit = storageUnit;
36:     }
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\repositories\PurchaseRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain.repositories;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import thkoeln.archilab.ecommerce.solution.purchase.domain.entities.Purchase;
5: import thkoeln.archilab.ecommerce.solution.purchase.domain.valueObjects.PurchaseId;
6: 
7: 
8: public interface PurchaseRepository extends CrudRepository<Purchase, PurchaseId> {
9: }
10: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\valueObjects\PurchaseId.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain.valueObjects;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.io.Serializable;
11: import java.util.UUID;
12: 
13: @Embeddable
14: @NoArgsConstructor(access = AccessLevel.PUBLIC)
15: @AttributeOverride(name = "id", column = @Column(name = "purchase_id"))
16: public class PurchaseId extends GenericId implements Serializable {
17:     public PurchaseId(UUID id) {
18:         super(id);
19:     }
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\valueObjects\PurchaseIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain.valueObjects;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class PurchaseIdConverter extends GenericIdConverter<PurchaseId> {
8:     public PurchaseIdConverter() {
9:         super(PurchaseId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\valueObjects\PurchasePart.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain.valueObjects;
2: 
3: import jakarta.persistence.Embeddable;
4: import jakarta.persistence.FetchType;
5: import jakarta.persistence.ManyToOne;
6: import lombok.AllArgsConstructor;
7: import lombok.EqualsAndHashCode;
8: import lombok.Getter;
9: import lombok.NoArgsConstructor;
10: import thkoeln.archilab.ecommerce.solution.product.domain.entities.Product;
11: 
12: @Embeddable
13: @EqualsAndHashCode
14: @Getter
15: @AllArgsConstructor
16: @NoArgsConstructor
17: public class PurchasePart {
18:     private int quantity;
19: 
20:     @ManyToOne(fetch = FetchType.EAGER)
21:     private Product product;
22: }
23: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\applicationServices\ShoppingCartCheckerService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application.applicationServices;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.product.application.applicationServices.ShoppingCartProductUsageChecker;
6: import thkoeln.archilab.ecommerce.solution.product.domain.valueObjects.ProductId;
7: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.entities.ShoppingCart;
8: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.repositories.ShoppingCartRepository;
9: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.valueObjects.ShoppingCartPart;
10: 
11: import java.util.List;
12: import java.util.UUID;
13: 
14: @Service
15: public class ShoppingCartCheckerService implements ShoppingCartProductUsageChecker {
16: 
17:     private final ShoppingCartRepository shoppingCartRepository;
18: 
19:     @Autowired
20:     public ShoppingCartCheckerService(ShoppingCartRepository shoppingCartRepository) {
21:         this.shoppingCartRepository = shoppingCartRepository;
22:     }
23: 
24:     @Override
25:     public boolean isProductInShoppingCart(UUID productId) {
26:         List<ShoppingCart> carts = (List<ShoppingCart>) shoppingCartRepository.findAll();
27:         for (ShoppingCart cart : carts) {
28:             for (ShoppingCartPart part : cart.getShoppingCartParts()) {
29:                 if (part.getProduct().getId().equals(new ProductId(productId))) {
30:                     return true;
31:                 }
32:             }
33:         }
34:         return false;
35:     }
36: }
37: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartController.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.http.HttpStatus;
5: import org.springframework.http.ResponseEntity;
6: import org.springframework.web.bind.annotation.*;
7: import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
8: import thkoeln.archilab.ecommerce.InsufficientStockException;
9: import thkoeln.archilab.ecommerce.ShopException;
10: import thkoeln.archilab.ecommerce.domainprimitives.Email;
11: import thkoeln.archilab.ecommerce.domainprimitives.EmptyCartException;
12: import thkoeln.archilab.ecommerce.domainprimitives.Money;
13: import thkoeln.archilab.ecommerce.solution.purchase.application.applicationServices.PurchaseService;
14: import thkoeln.archilab.ecommerce.solution.purchase.domain.entities.Purchase;
15: import thkoeln.archilab.ecommerce.solution.purchase.domain.valueObjects.PurchasePart;
16: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.entities.ShoppingCart;
17: import thkoeln.archilab.ecommerce.solution.user.application.applicationServices.UserRegistrationService;
18: import thkoeln.archilab.ecommerce.usecases.UserType;
19: 
20: import java.net.URI;
21: import java.util.*;
22: import java.util.stream.Collectors;
23: 
24: @RestController
25: public class ShoppingCartController {
26:     private final ShoppingCartService shoppingCartService;
27:     private final PurchaseService purchaseService;
28: 
29:     @Autowired
30:     public ShoppingCartController(ShoppingCartService shoppingCartService, PurchaseService purchaseService) {
31:         this.shoppingCartService = shoppingCartService;
32:         this.purchaseService = purchaseService;
33: 
34:     }
35: 
36:     @GetMapping(value = "/shoppingCarts", params = "userId", produces = "application/json")
37:     public ResponseEntity<ShoppingCartDTO> getCartForUser(@RequestParam UUID userId) {
38: 
39:         ShoppingCart cart;
40:         try {
41:             cart = shoppingCartService.getCartByUserId(userId);
42:         } catch (Exception e) {
43:             return ResponseEntity.notFound().build(); // Not Found if the user does not exist
44:         }
45: 
46:         if (cart == null) {
47:             cart = shoppingCartService.createCartIfNotExists(userId);
48:         }
49:         ShoppingCartDTO dto = mapToDTO(cart);
50:         return ResponseEntity.ok(dto);
51:     }
52: 
53:     @GetMapping(value = "/shoppingCarts", produces = "application/json")
54:     public ResponseEntity<Void> handleMissingUserIdParam() {
55:         return ResponseEntity.status(405).build(); // Method Not Allowed
56:     }
57: 
58:     private ShoppingCartDTO mapToDTO(ShoppingCart cart) {
59:         List<ShoppingCartPartDTO> partDTOs = cart.getShoppingCartParts().stream()
60:                 .map(part -> new ShoppingCartPartDTO(part.getProduct().getId().getId(), part.getQuantity()))
61:                 .collect(Collectors.toList());
62: 
63:         String formattedPrice = formatPrice( (Money) shoppingCartService.getShoppingCartAsMoneyValue( (Email) cart.getUser().getEmail()));
64: 
65:         return new ShoppingCartDTO(cart.getId().getId(), formattedPrice, partDTOs);
66:     }
67: 
68:     private String formatPrice(Money money) {
69:         Float amount = money.getAmount(); // z. B. 21.34
70:         String currency = money.getCurrencyUnit(); // z. B. "EUR"
71: 
72:         String symbol = switch (currency) {
73:             case "EUR" -> "€";
74:             case "CHF" -> "CHF";
75:             default -> currency;
76:         };
77: 
78:         return String.format(Locale.getDefault(), "%.2f %s", amount, symbol);
79:     }
80: 
81:     @PostMapping("/shoppingCarts/{shoppingCartId}/parts")
82:     public ResponseEntity<Void> addPartToCart(
83:             @PathVariable UUID shoppingCartId,
84:             @RequestBody ShoppingCartPartDTO partDTO
85:             ) {
86:         if(partDTO.getProductId() == null || partDTO.getQuantity() <= 0) {
87:             return ResponseEntity.unprocessableEntity().build(); // Bad Request if productId is null or quantity is invalid
88:         }
89:         try {
90:             UserType user = shoppingCartService.getUserByShoppingCartId(shoppingCartId);
91:             shoppingCartService.addProductToShoppingCart(user.getEmail(), partDTO.getProductId(), partDTO.getQuantity());
92:         } catch (Exception e) {
93:             return ResponseEntity.notFound().build(); // Not Found if the shopping cart or product does not exist
94:         }
95:             return new ResponseEntity<>(HttpStatus.CREATED);
96:     }
97: 
98:     @ExceptionHandler(MethodArgumentTypeMismatchException.class)
99:     public ResponseEntity<Void> handleInvalidUUID(MethodArgumentTypeMismatchException ex) {
100:         if ("userId".equals(ex.getName()) && ex.getRequiredType() == UUID.class) {
101:             return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
102:         }
103:         return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
104:     }
105: 
106:     @DeleteMapping("/shoppingCarts/{shoppingCartId}/parts/{productId}")
107:     public ResponseEntity<Void> removeProductFromCart(
108:             @PathVariable UUID shoppingCartId,
109:             @PathVariable UUID productId
110:     ) {
111:         try {
112:             UserType user = shoppingCartService.getUserByShoppingCartId(shoppingCartId);
113:             shoppingCartService.removeProductFromShoppingCart(user.getEmail(), productId);
114:             return ResponseEntity.ok().build(); // 204: Erfolgreich gelöscht, keine Rückgabe
115:         } catch (ShopException e) {
116:             return ResponseEntity.notFound().build(); // z. B. wenn cart oder Produkt nicht existiert
117:         }
118:     }
119: 
120:     @PostMapping("/shoppingCarts/{shoppingCartId}/checkout")
121:     public ResponseEntity<List<Map<String, Object>>> checkoutCart(@PathVariable UUID shoppingCartId) {
122:         try {
123:             UserType user = shoppingCartService.getUserByShoppingCartId(shoppingCartId);
124:             Set<UUID> purchaseIds = shoppingCartService.checkout(user.getEmail());
125: 
126:             List<Map<String, Object>> responseList = new ArrayList<>();
127:             for (UUID purchaseId : purchaseIds) {
128:                 Purchase purchase = purchaseService.getPurchaseById(purchaseId);
129: 
130:                 Map<String, Object> purchaseMap = new LinkedHashMap<>();
131:                 purchaseMap.put("id", purchase.getId().getId());
132:                 purchaseMap.put("userName", purchase.getUser().getName());
133:                 purchaseMap.put("storageUnitId", purchase.getStorageUnit().getId().getId());
134: 
135:                 List<Map<String, Object>> partsList = new ArrayList<>();
136:                 for (PurchasePart part : purchase.getPurchaseParts()) {
137:                     Map<String, Object> partMap = new LinkedHashMap<>();
138:                     partMap.put("productId", part.getProduct().getId().getId());
139:                     partMap.put("quantity", part.getQuantity());
140:                     partsList.add(partMap);
141:                 }
142: 
143:                 purchaseMap.put("parts", partsList);
144:                 responseList.add(purchaseMap);
145:             }
146: 
147:             return ResponseEntity.created(URI.create("/purchases")).body(responseList); // 201: Created with body
148:         } catch (EmptyCartException e) {
149:             return ResponseEntity.status(HttpStatus.CONFLICT).build();
150:         } catch (InsufficientStockException e) {
151:             return ResponseEntity.status(HttpStatus.CONFLICT).build(); // <-- 409 für Lagerkonflikte
152:         } catch (ShopException e) {
153:             return ResponseEntity.status(HttpStatus.CONFLICT).build(); // z. B. leerer Warenkorb o. Ä.
154:         }
155:     }
156: 
157: 
158: }
159: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import jakarta.persistence.ElementCollection;
4: import jakarta.persistence.EmbeddedId;
5: import jakarta.persistence.FetchType;
6: import jakarta.persistence.OneToOne;
7: import lombok.*;
8: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.entities.ShoppingCart;
9: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.valueObjects.ShoppingCartId;
10: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.valueObjects.ShoppingCartPart;
11: import thkoeln.archilab.ecommerce.solution.user.domain.entities.User;
12: 
13: import java.util.List;
14: import java.util.UUID;
15: 
16: @Data
17: @NoArgsConstructor
18: public class ShoppingCartDTO {
19:     private UUID id;
20:     private String totalSalesPrice;
21:     private List<ShoppingCartPartDTO> parts;
22: 
23:     public ShoppingCartDTO(UUID id, String totalSalesPrice, List<ShoppingCartPartDTO> parts) {
24:         this.id = id;
25:         this.totalSalesPrice = totalSalesPrice;
26:         this.parts = parts;
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartPartDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Data;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.solution.product.domain.entities.Product;
7: 
8: import java.util.UUID;
9: 
10: @Data
11: @NoArgsConstructor
12: @AllArgsConstructor
13: public class ShoppingCartPartDTO {
14:     private UUID productId;
15:     private int quantity;
16: 
17:     public ShoppingCartPartDTO(Product product, int quantity) {
18:         this.productId = product.getId().getId(); // <- hole UUID aus ProductId
19:         this.quantity = quantity;
20:     }
21: 
22: 
23: }
24: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.InsufficientStockException;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.domainprimitives.Email;
8: import thkoeln.archilab.ecommerce.domainprimitives.EmptyCartException;
9: import thkoeln.archilab.ecommerce.domainprimitives.Money;
10: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
11: import thkoeln.archilab.ecommerce.solution.product.application.applicationServices.ProductCatalogService;
12: import thkoeln.archilab.ecommerce.solution.product.domain.entities.Product;
13: import thkoeln.archilab.ecommerce.solution.product.domain.valueObjects.ProductId;
14: import thkoeln.archilab.ecommerce.solution.purchase.domain.entities.Purchase;
15: import thkoeln.archilab.ecommerce.solution.purchase.domain.repositories.PurchaseRepository;
16: import thkoeln.archilab.ecommerce.solution.purchase.domain.valueObjects.PurchasePart;
17: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.entities.ShoppingCart;
18: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.repositories.ShoppingCartRepository;
19: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.valueObjects.ShoppingCartId;
20: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.valueObjects.ShoppingCartPart;
21: import thkoeln.archilab.ecommerce.solution.storageunit.application.applicationServices.StorageUnitService;
22: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnit;
23: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitComparator;
24: import thkoeln.archilab.ecommerce.solution.user.application.applicationServices.UserRegistrationService;
25: import thkoeln.archilab.ecommerce.solution.user.domain.entities.User;
26: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
27: import thkoeln.archilab.ecommerce.usecases.UserType;
28: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
29: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
30: 
31: import java.util.*;
32: 
33: @Service
34: public class ShoppingCartService implements ShoppingCartUseCases {
35: 
36:     private final ShoppingCartRepository shoppingCartRepository;
37:     private final UserRegistrationService userRegistrationService;
38:     private final ProductCatalogService productCatalogService;
39:     private final StorageUnitService storageUnitService;
40:     private final PurchaseRepository purchaseRepository;
41: 
42:     @Autowired
43:     public ShoppingCartService(ShoppingCartRepository shoppingCartRepository, UserRegistrationService userRegistrationService, ProductCatalogService productCatalogService, StorageUnitService storageUnitService, PurchaseRepository purchaseRepository) {
44:         this.shoppingCartRepository = shoppingCartRepository;
45:         this.userRegistrationService = userRegistrationService;
46:         this.productCatalogService = productCatalogService;
47:         this.storageUnitService = storageUnitService;
48:         this.purchaseRepository = purchaseRepository;
49:     }
50: 
51:     /**
52:      * Adds a product to the cart of a user
53:      *
54:      * @param userEmail
55:      * @param productId
56:      * @param quantityOf
57:      * @throws ShopException if ...
58:      *                       - userEmail is null or empty,
59:      *                       - the user with the given email does not exist,
60:      *                       - productId is null,
61:      *                       - the product with productId does not exist
62:      *                       - the Quantity is negative,
63:      */
64:     @Override
65:     public void addProductToShoppingCart(EmailType userEmail, UUID productId, int quantityOf) {
66:         userRegistrationService.ensureUserExists((Email) userEmail);
67:         productCatalogService.ensureProductIdDoesExist(productId);
68: 
69:         ShoppingCart shoppingCart = shoppingCartRepository.findByUserEmail((Email) userEmail);
70:         if (shoppingCart == null) {
71:             User user = userRegistrationService.getExistingUserOrThrow((Email) userEmail);
72:             shoppingCart = new ShoppingCart(user, new ArrayList<>());
73:         }
74: 
75:         List<ShoppingCartPart> parts = shoppingCart.getShoppingCartParts();
76:         List<ShoppingCartPart> updatedParts = new ArrayList<>();
77: 
78:         boolean productFound = false;
79: 
80:         for (ShoppingCartPart part : parts) {
81:             if (part.getProduct().getId().equals(new ProductId(productId))) {
82:                 updatedParts.add(new ShoppingCartPart(part.getProduct(), part.getQuantity() + quantityOf));
83:                 productFound = true;
84:             } else {
85:                 updatedParts.add(part);
86:             }
87:         }
88: 
89:         if (!productFound) {
90:             updatedParts.add(new ShoppingCartPart(productCatalogService.getExistingProductOrThrow(productId), quantityOf));
91:         }
92: 
93:         shoppingCart.setShoppingCartParts(updatedParts);
94:         shoppingCartRepository.save(shoppingCart);
95:     }
96: 
97:     /**
98:      * Removes a product from the cart of a user
99:      *
100:      * @param userEmail
101:      * @param productId
102:      * @param quantityOf
103:      * @throws ShopException if ...
104:      *                       - userEmail is null or empty,
105:      *                       - the user with the given email does not exist,
106:      *                       - productId is null,
107:      *                       - the product with productId does not exist
108:      *                       - the Quantity is negative
109:      *                       - the product is not in the shopping cart in the requested Quantity
110:      */
111:     @Override
112:     public void removeProductFromShoppingCart(EmailType userEmail, UUID productId, int quantityOf) {
113:         userRegistrationService.ensureUserExists((Email) userEmail);
114:         productCatalogService.ensureProductIdDoesExist(productId);
115: 
116:         ShoppingCart shoppingCart = shoppingCartRepository.findByUserEmail((Email) userEmail);
117:         if (shoppingCart == null) {
118:             throw new ShopException("Shopping cart not found for user: " + userEmail);
119:         }
120: 
121:         List<ShoppingCartPart> parts = shoppingCart.getShoppingCartParts();
122:         List<ShoppingCartPart> updatedParts = new ArrayList<>();
123: 
124:         boolean productFound = false;
125: 
126:         for (ShoppingCartPart part : parts) {
127:             if (part.getProduct().getId().equals(new ProductId(productId))) {
128:                 if (part.getQuantity() < quantityOf) {
129:                     throw new ShopException("Not enough quantity in shopping cart");
130:                 }
131:                 updatedParts.add(new ShoppingCartPart(part.getProduct(), part.getQuantity() - quantityOf));
132:                 productFound = true;
133:             } else {
134:                 updatedParts.add(part);
135:             }
136:         }
137: 
138:         if (!productFound) {
139:             throw new ShopException("Product not found in shopping cart");
140:         }
141: 
142:         shoppingCart.setShoppingCartParts(updatedParts);
143:         shoppingCartRepository.save(shoppingCart);
144:     }
145: 
146:     public void removeProductFromShoppingCart(EmailType userEmail, UUID productId) {
147:         userRegistrationService.ensureUserExists((Email) userEmail);
148:         productCatalogService.ensureProductIdDoesExist(productId);
149: 
150:         ShoppingCart shoppingCart = shoppingCartRepository.findByUserEmail((Email) userEmail);
151:         if (shoppingCart == null) {
152:             throw new ShopException("Shopping cart not found for user: " + userEmail);
153:         }
154: 
155:         List<ShoppingCartPart> parts = shoppingCart.getShoppingCartParts();
156:         List<ShoppingCartPart> updatedParts = new ArrayList<>();
157: 
158:         boolean productFound = false;
159: 
160:         for (ShoppingCartPart part : parts) {
161:             if (part.getProduct().getId().equals(new ProductId(productId))) {
162:                 productFound = true;
163:                 continue;
164:             } else {
165:                 updatedParts.add(part);
166:             }
167:         }
168: 
169:         if (!productFound) {
170:             throw new ShopException("Product not found in shopping cart");
171:         }
172: 
173:         shoppingCart.setShoppingCartParts(updatedParts);
174:         shoppingCartRepository.save(shoppingCart);
175:     }
176: 
177:     /**
178:      * Returns a map showing which products are in the cart of a user and how many of each product
179:      *
180:      * @param userEmail
181:      * @return the cart of the user (map is empty if the cart is empty)
182:      * @throws ShopException if
183:      *                       - the user with the given email does not exist
184:      */
185:     @Override
186:     public Map<UUID, Integer> getShoppingCartAsMap(EmailType userEmail) {
187:         userRegistrationService.ensureUserExists((Email) userEmail);
188: 
189:         ShoppingCart shoppingCart = shoppingCartRepository.findByUserEmail((Email) userEmail);
190:         if (shoppingCart == null) {
191:             throw new ShopException("Shopping cart not found for user: " + userEmail);
192:         }
193:         Map<UUID, Integer> shoppingCartMap = new HashMap<>();
194: 
195:         for (ShoppingCartPart part : shoppingCart.getShoppingCartParts()) {
196:             shoppingCartMap.put(part.getProduct().getId().getId(), part.getQuantity());
197:         }
198:         return shoppingCartMap;
199:     }
200: 
201:     /**
202:      * Returns the current value of all products in the cart of a user
203:      *
204:      * @param userEmail
205:      * @return the cart of the user
206:      * @throws ShopException if the user with the given email does not exist
207:      */
208:     @Override
209:     public MoneyType getShoppingCartAsMoneyValue(EmailType userEmail) {
210:         userRegistrationService.ensureUserExists((Email) userEmail);
211: 
212: 
213:         ShoppingCart shoppingCart = shoppingCartRepository.findByUserEmail((Email) userEmail);
214:         if (shoppingCart == null) {
215:             throw new ShopException("Shopping cart not found for user: " + userEmail);
216:         }
217: 
218:         MoneyType totalValue = new Money((float) 0, "EUR");
219:         for (ShoppingCartPart part : shoppingCart.getShoppingCartParts()) {
220:             totalValue = totalValue.add(part.getProduct().getSellingPrice().multiplyBy(part.getQuantity()));
221:         }
222:         return totalValue;
223:     }
224: 
225: 
226:     @Override
227:     public Set<UUID> checkout(EmailType userEmail) {
228:         userRegistrationService.ensureUserExists((Email) userEmail);
229:         User user = userRegistrationService.getExistingUserOrThrow((Email) userEmail);
230:         ShoppingCart shoppingCart = shoppingCartRepository.findByUserEmail((Email) userEmail);
231:         ensureShoppingCartNotEmpty(shoppingCart);
232: 
233:         // 1. Erstelle Map<ProductId, Integer> aus dem Warenkorb
234:         Map<ProductId, Integer> remainingParts = new HashMap<>();
235:         for (ShoppingCartPart part : shoppingCart.getShoppingCartParts()) {
236:             remainingParts.put(part.getProduct().getId(), part.getQuantity());
237:         }
238: 
239:         Set<UUID> purchaseIds = new HashSet<>();
240:         List<StorageUnit> allStorageUnits = storageUnitService.getAllStorageUnits();
241: 
242:         while (!remainingParts.isEmpty()) {
243:             // 2. Sortiere StorageUnits mit Comparator
244:             allStorageUnits.sort(new StorageUnitComparator(remainingParts, (ZipCode) user.getAddress().getZipCode()));
245:             StorageUnit bestStorageUnit = allStorageUnits.get(0);
246: 
247:             Set<ProductId> fulfillable = bestStorageUnit.fulfillableShoppingCartParts(remainingParts);
248:             if (fulfillable.isEmpty()) {
249:                 throw new InsufficientStockException("No storage unit can fulfill remaining shopping cart parts.");
250:             }
251: 
252:             List<PurchasePart> purchaseParts = new ArrayList<>();
253: 
254:             for (ProductId productId : fulfillable) {
255:                 int quantity = remainingParts.get(productId);
256:                 storageUnitService.removeFromStock(bestStorageUnit.getId().getId(), productId.getId(), quantity);
257: 
258:                 Product product = shoppingCart.getShoppingCartParts().stream()
259:                         .filter(part -> part.getProduct().getId().equals(productId))
260:                         .findFirst()
261:                         .orElseThrow()
262:                         .getProduct();
263: 
264:                 purchaseParts.add(new PurchasePart(quantity, product));
265:             }
266: 
267:             Purchase purchase = new Purchase(user, purchaseParts, bestStorageUnit);
268:             purchaseRepository.save(purchase);
269:             purchaseIds.add(purchase.getId().getId());
270: 
271:             // Entferne ausgelieferte Produkte aus der Map
272:             fulfillable.forEach(remainingParts::remove);
273:         }
274: 
275:         shoppingCartRepository.delete(shoppingCart);
276:         return purchaseIds;
277:     }
278: 
279: 
280:     @Override
281:     public void emptyAllShoppingCarts() {
282:         shoppingCartRepository.deleteAll();
283:     }
284: 
285:     private void ensureShoppingCartNotEmpty(ShoppingCart shoppingCart) {
286:         if (shoppingCart == null || shoppingCart.getShoppingCartParts().isEmpty()) {
287:             throw new EmptyCartException("Shopping cart is empty");
288:         }
289:     }
290: 
291:     public ShoppingCart getCartByUserId(UUID userId) {
292:         User user = userRegistrationService.getExistingUserByIdOrThrow(userId);
293:         ShoppingCart cart = shoppingCartRepository.findByUserEmail((Email) user.getEmail());
294:         if (cart == null) {
295:             return null;
296:         }
297:         return cart;
298:     }
299: 
300:     public User getUserByShoppingCartId(UUID shoppingCartId) {
301:         ShoppingCart cart = shoppingCartRepository.findById(new ShoppingCartId(shoppingCartId))
302:                 .orElseThrow(() -> new ShopException("Shopping cart not found for ID: " + shoppingCartId));
303:         return cart.getUser();
304:     }
305: 
306:     public ShoppingCart getCartByUserEmail(Email email) {
307:         ShoppingCart cart = shoppingCartRepository.findByUserEmail((Email) email);
308:         if (cart == null) {
309:             throw new ShopException("Shopping cart not found for user: " + email);
310:         }
311:         return cart;
312:     }
313: 
314:     public ShoppingCart createCartIfNotExists(UUID userId) {
315:         User user = userRegistrationService.getExistingUserByIdOrThrow(userId);
316:         ShoppingCart shoppingCart = shoppingCartRepository.findByUserEmail((Email) user.getEmail());
317:         if (shoppingCart != null) {
318:             return shoppingCart;
319:         }
320:         shoppingCart = new ShoppingCart(user, new ArrayList<>());
321:         shoppingCartRepository.save(shoppingCart);
322:         return shoppingCart;
323:     }
324:     public ShoppingCart createCartIfNotExists(EmailType email) {
325:         User user = userRegistrationService.getExistingUserOrThrow((Email) email);
326:         ShoppingCart shoppingCart = shoppingCartRepository.findByUserEmail((Email) user.getEmail());
327:         if (shoppingCart != null) {
328:             return shoppingCart;
329:         }
330:         shoppingCart = new ShoppingCart(user, new ArrayList<>());
331:         shoppingCartRepository.save(shoppingCart);
332:         return shoppingCart;
333:     }
334: }
335: 
336: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\entities\ShoppingCart.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain.entities;
2: 
3: import jakarta.persistence.*;
4: import lombok.*;
5: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.valueObjects.ShoppingCartId;
6: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.valueObjects.ShoppingCartPart;
7: import thkoeln.archilab.ecommerce.solution.user.domain.entities.User;
8: import thkoeln.archilab.ecommerce.usecases.UserType;
9: 
10: import java.util.Collections;
11: import java.util.List;
12: 
13: @Entity
14: @Setter
15: @Getter
16: @AllArgsConstructor
17: @NoArgsConstructor
18: public class ShoppingCart {
19:     @Setter(AccessLevel.PRIVATE)    // only for JPA
20:     @EmbeddedId
21:     private ShoppingCartId id;
22: 
23:     @OneToOne
24:     private User user;
25: 
26:     @ElementCollection(fetch = FetchType.EAGER)
27:     private List<ShoppingCartPart> shoppingCartParts;
28: 
29:     public ShoppingCart(User user, List<ShoppingCartPart> shoppingCartParts) {
30:         this.id = new ShoppingCartId();
31:         this.user = user;
32:         this.shoppingCartParts = shoppingCartParts;
33:     }
34: 
35:     public ShoppingCart(UserType user) {
36:         this.id = new ShoppingCartId();
37:         this.user = (User) user;
38:         this.shoppingCartParts = Collections.emptyList();
39:     }
40: }
41: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\repositories\ShoppingCartRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain.repositories;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import thkoeln.archilab.ecommerce.domainprimitives.Email;
5: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.entities.ShoppingCart;
6: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.valueObjects.ShoppingCartId;
7: 
8: 
9: public interface ShoppingCartRepository extends CrudRepository<ShoppingCart, ShoppingCartId> {
10:     ShoppingCart findByUserEmail(Email email);
11: 
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\valueObjects\ShoppingCartId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain.valueObjects;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.io.Serializable;
11: import java.util.UUID;
12: 
13: @Embeddable
14: @NoArgsConstructor(access = AccessLevel.PUBLIC)
15: @AttributeOverride(name = "id", column = @Column(name = "shoppingcart_id"))
16: public class ShoppingCartId extends GenericId implements Serializable {
17:     public ShoppingCartId(UUID id) {
18:         super(id);
19:     }
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\valueObjects\ShoppingCartIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain.valueObjects;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ShoppingCartIdConverter extends GenericIdConverter<ShoppingCartId> {
8:     public ShoppingCartIdConverter() {
9:         super(ShoppingCartId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\valueObjects\ShoppingCartPart.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain.valueObjects;
2: 
3: import jakarta.persistence.Embeddable;
4: import jakarta.persistence.FetchType;
5: import jakarta.persistence.ManyToOne;
6: import lombok.AllArgsConstructor;
7: import lombok.EqualsAndHashCode;
8: import lombok.Getter;
9: import lombok.NoArgsConstructor;
10: import thkoeln.archilab.ecommerce.ShopException;
11: import thkoeln.archilab.ecommerce.solution.product.domain.entities.Product;
12: 
13: @Embeddable
14: @EqualsAndHashCode
15: @Getter
16: @NoArgsConstructor
17: public class ShoppingCartPart {
18:     private int quantity;
19: 
20:     @ManyToOne(fetch = FetchType.EAGER)
21:     private Product product;
22: 
23:     public ShoppingCartPart(Product product, int quantity) {
24:         checkQuantityLargerThenZero(quantity);
25: 
26:         this.product = product;
27:         this.quantity = quantity;
28:     }
29: 
30:     private static void checkQuantityLargerThenZero(int quantity) {
31:         if (quantity < 0) {
32:             throw new ShopException("Quantity cannot be negative");
33:         }
34:     }
35: 
36: }
37: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\applicationServices\StorageUnitCheckerService.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.application.applicationServices;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.product.application.applicationServices.StorageUnitProductUsageChecker;
6: import thkoeln.archilab.ecommerce.solution.product.domain.valueObjects.ProductId;
7: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnit;
8: import thkoeln.archilab.ecommerce.solution.storageunit.domain.repositories.StorageUnitRepository;
9: import thkoeln.archilab.ecommerce.solution.storageunit.domain.valueObjects.StockLevel;
10: 
11: import java.util.List;
12: import java.util.UUID;
13: 
14: @Service
15: public class StorageUnitCheckerService implements StorageUnitProductUsageChecker {
16: 
17:     private final StorageUnitRepository storageUnitRepository;
18: 
19:     @Autowired
20:     public StorageUnitCheckerService(StorageUnitRepository storageUnitRepository) {
21:         this.storageUnitRepository = storageUnitRepository;
22:     }
23: 
24:     @Override
25:     public boolean isProductInStock(UUID productId) {
26:         List<StorageUnit> units = (List<StorageUnit>) storageUnitRepository.findAll();
27:         for (StorageUnit unit : units) {
28:             for (StockLevel level : unit.getStockLevels()) {
29:                 if (level.getProduct().getId().equals(new ProductId(productId))) {
30:                     return true;
31:                 }
32:             }
33:         }
34:         return false;
35:     }
36: }

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\applicationServices\StorageUnitService.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.application.applicationServices;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.InsufficientStockException;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
8: import thkoeln.archilab.ecommerce.solution.product.application.applicationServices.ProductCatalogService;
9: import thkoeln.archilab.ecommerce.solution.product.domain.entities.Product;
10: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnit;
11: import thkoeln.archilab.ecommerce.solution.storageunit.domain.repositories.StorageUnitRepository;
12: import thkoeln.archilab.ecommerce.solution.storageunit.domain.valueObjects.StockLevel;
13: import thkoeln.archilab.ecommerce.solution.storageunit.domain.valueObjects.StorageUnitId;
14: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
16: 
17: import java.util.ArrayList;
18: import java.util.List;
19: import java.util.UUID;
20: 
21: @Service
22: public class StorageUnitService implements StorageUnitUseCases {
23: 
24:     private final StorageUnitRepository storageUnitRepository;
25:     private final ProductCatalogService productCatalogService;
26:     @Autowired
27:     public StorageUnitService(StorageUnitRepository storageUnitRepository, ProductCatalogService productCatalogService) {
28:         this.storageUnitRepository = storageUnitRepository;
29:         this.productCatalogService = productCatalogService;
30:     }
31: 
32: 
33: 
34:     /**
35:      *
36:      * @param name
37:      * @param physicalAddress
38:      * @return the id of the new storage unit
39:      * @throws ShopException if ...
40:      *      - name is null or empty
41:      *      - physicalAddress is null
42:      */
43: 
44:     @Override
45:     public UUID addNewStorageUnit(String name, PhysicalAddressType physicalAddress) {
46: 
47:         if (name == null || name.trim().isEmpty()) {
48:             throw new ShopException("Name must not be null or empty");
49:         }
50:         if (physicalAddress == null) {
51:             throw new ShopException("Address must not be null");
52:         }
53: 
54:         StorageUnit storageUnit = new StorageUnit(
55:                 name,
56:                 (PhysicalAddress) physicalAddress,
57:                 new ArrayList<>()
58:         );
59: 
60:         storageUnitRepository.save(storageUnit);
61:         return storageUnit.getId().getId();
62:     }
63: 
64:     /**
65:      * Deletes all storage units from the shop. Intended for testing purposes.
66:      */
67:     @Override
68:     public void deleteAllStorageUnits() {
69:         storageUnitRepository.deleteAll();
70:     }
71: 
72:     /**
73:      * Find the suitable storage unit to serve the purchase for a user.
74:      * @param zipCode the zip code of the user who wants to buy
75:      * @return the id of the storage unit that is suitable for the purchase (or any of the fitting storage units,
76:      *         if there are several storage units with the same zip code range)
77:      * @throws ShopException if ...
78:      *     - zipCode is null, empty, or not a valid zip code
79:      *     - no storage unit is available for the given zipCode
80:      */
81: 
82:     /*
83:     @Override
84:     public UUID findSuitableStorageUnit(String zipCode) {
85: 
86:         int firstDigit = Integer.parseInt(zipCode.substring(0, 1));
87:         ArrayList <StorageUnit> storageUnits = new ArrayList<>();
88: 
89:         storageUnitRepository.findAll().forEach(
90:                 storageUnit -> {
91:                     if (storageUnit.getFromZipCodeFirstDigit() <= firstDigit
92:                             && storageUnit.getToZipCodeFirstDigit() >= firstDigit) {
93:                         storageUnits.add(storageUnit);
94:                     }
95:                 }
96:         );
97: 
98:         if (storageUnits.isEmpty()) {
99:             throw new ShopException("No storage unit available for the given zip code");
100:         }
101:         return storageUnits.get(0).getId().getId();
102:     }
103: */
104: 
105:     /**
106:      * Adds a certain Quantity of a given product to the stock
107:      * @param storageUnitId
108:      * @param productId
109:      * @param addedQuantityOf
110:      * @throws ShopException if ...
111:      *      - storageUnitId is null
112:      *      - the storage unit with that id does not exist
113:      *      - productId is null
114:      *      - the product with that id does not exist
115:      *      - addedQuantityOf < 0
116:      */
117:     @Override
118:     public void addToStock(UUID storageUnitId, UUID productId, int addedQuantityOf) {
119: 
120:         if(addedQuantityOf < 0) {
121:             throw new ShopException("Added quantity must be greater than or equal to zero");
122:         }
123: 
124:         productCatalogService.ensureProductIdDoesExist(productId);
125: 
126:         Product product = productCatalogService.getExistingProductOrThrow(productId);
127:         StorageUnit storageUnit = getExistingStorageUnitOrThrow(storageUnitId);
128: 
129:         List<StockLevel> stockLevels = storageUnit.getStockLevels();
130:         List<StockLevel> updatedStockLevels = new ArrayList<>();
131: 
132:         boolean productFound = false;
133: 
134:         for (StockLevel stockLevel : stockLevels) {
135:             if (stockLevel.getProduct().getId().getId().equals(productId)) {
136:                 productFound = true;
137:                 updatedStockLevels.add(new StockLevel(stockLevel.getQuantityOfProducts() + addedQuantityOf, product));
138:             } else {
139:                 updatedStockLevels.add(stockLevel);
140:             }
141:         }
142: 
143:         if (!productFound) {
144:             updatedStockLevels.add(new StockLevel(addedQuantityOf, product));
145:         }
146: 
147:         storageUnit.setStockLevels(updatedStockLevels);
148:         storageUnitRepository.save(storageUnit);
149:     }
150: 
151: 
152:     /**
153:      * Removes a certain Quantity of a given product from the stock.
154:      * @param storageUnitId
155:      * @param productId
156:      * @param removedQuantityOf
157:      * @throws ShopException if ...
158:      *      - storageUnitId is null
159:      *      - the storage unit with that id does not exist
160:      *      - productId is null
161:      *      - the product with that id does not exist
162:      *      - removedQuantityOf < 0
163:      */
164:     @Override
165:     public void removeFromStock(UUID storageUnitId, UUID productId, int removedQuantityOf) {
166: 
167:         if (removedQuantityOf == 0) {
168:             return;
169:         }
170: 
171:         if(removedQuantityOf < 0) {
172:             throw new ShopException("Added quantity must be greater than or equal to zero");
173:         }
174: 
175:         productCatalogService.ensureProductIdDoesExist(productId);
176: 
177:         Product product = productCatalogService.getExistingProductOrThrow(productId);
178:         StorageUnit storageUnit = getExistingStorageUnitOrThrow(storageUnitId);
179: 
180:         List<StockLevel> stockLevels = storageUnit.getStockLevels();
181: 
182:         List<StockLevel> updatedStockLevels = new ArrayList<>();
183: 
184:         boolean productFound = false;
185: 
186:         for (StockLevel stockLevel : stockLevels) {
187:             if (stockLevel.getProduct().getId().getId().equals(productId)) {
188:                 productFound = true;
189: 
190:                 int updatedQuantity = stockLevel.getQuantityOfProducts() - removedQuantityOf;
191: 
192:                 if (updatedQuantity >= 0) {
193:                     updatedStockLevels.add(new StockLevel(updatedQuantity, product));
194:                 } else {
195:                     throw new InsufficientStockException("Not enough stock to remove the requested quantity");
196:                 }
197:             } else {
198:                 updatedStockLevels.add(stockLevel);
199:             }
200:         }
201: 
202:         if (!productFound) {
203:             throw new InsufficientStockException("Product not found in the stock.");
204:         }
205: 
206:         storageUnit.setStockLevels(updatedStockLevels);
207:         storageUnitRepository.save(storageUnit);
208:     }
209: 
210:     /**
211:      * Changes the total Quantity of a given product in the stock.
212:      * @param storageUnitId
213:      * @param productId
214:      * @param newTotalQuantityOf
215:      * @throws ShopException if ...
216:      *      - storageUnitId is null
217:      *      - the storage unit with that id does not exist
218:      *      - productId is null
219:      *      - the product with that id does not exist
220:      *      - newTotalQuantityOf < 0
221:      */
222:     @Override
223:     public void changeStockTo(UUID storageUnitId, UUID productId, int newTotalQuantityOf) {
224:         ensureStorageUnitExists(storageUnitId);
225:         productCatalogService.ensureProductIdDoesExist(productId);
226: 
227:         Product product = productCatalogService.getExistingProductOrThrow(productId);
228:         StorageUnit storageUnit = getExistingStorageUnitOrThrow(storageUnitId);
229: 
230:         List<StockLevel> stockLevels = storageUnit.getStockLevels();
231:         List<StockLevel> updatedStockLevels = new ArrayList<>();
232:         boolean productFound = false;
233: 
234:         for (StockLevel stockLevel : stockLevels) {
235:             if (stockLevel.getProduct().getId().getId().equals(productId)) {
236:                 updatedStockLevels.add(new StockLevel(newTotalQuantityOf, product));
237:                 productFound = true;
238:             } else {
239:                 updatedStockLevels.add(stockLevel);
240:             }
241:         }
242: 
243:         if (!productFound) {
244:             updatedStockLevels.add(new StockLevel(newTotalQuantityOf, product));
245:         }
246: 
247:         storageUnit.setStockLevels(updatedStockLevels);
248:         storageUnitRepository.save(storageUnit);
249:     }
250: 
251:     /**
252:      * Get the current stock of a given product in one specific storage unit.
253:      * @param storageUnitId
254:      * @param productId
255:      * @return the current total stock of the product
256:      * @throws ShopException if ...
257:      *      - storageUnitId is null
258:      *      - the storage unit with that id does not exist
259:      *      - productId is null
260:      *      - the product with that id does not exist
261:      */
262:     @Override
263:     public int getAvailableStock(UUID storageUnitId, UUID productId) {
264:         productCatalogService.ensureProductIdDoesExist(productId);
265: 
266:         Product product = productCatalogService.getExistingProductOrThrow(productId);
267:         StorageUnit storageUnit = getExistingStorageUnitOrThrow(storageUnitId);
268: 
269:         for (StockLevel stockLevel : storageUnit.getStockLevels()) {
270:             if (stockLevel.getProduct().getId().getId().equals(product.getId().getId())) {
271:                 return stockLevel.getQuantityOfProducts();
272:             }
273:         }
274:         return 0;
275:     }
276: 
277:     public StorageUnit getExistingStorageUnitOrThrow(UUID storageUnitId) {
278:         StorageUnit storageUnit = storageUnitRepository.findById(new StorageUnitId(storageUnitId)).orElse(null);
279:         if (storageUnit == null) {
280:             throw new ShopException("Storage unit with this id does not exist");
281:         }
282:         return storageUnit;
283:     }
284: 
285:     private void ensureStorageUnitExists(UUID storageUnitId) {
286:         if (storageUnitRepository.findById(new StorageUnitId(storageUnitId)).isEmpty()) {
287:             throw new ShopException("Storage unit with this id does not exist");
288:         }
289:     }
290: 
291:     public List<StorageUnit> getAllStorageUnits() {
292:         return (List<StorageUnit>) storageUnitRepository.findAll();
293:     }
294: }
295: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\repositories\StorageUnitRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain.repositories;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnit;
5: import thkoeln.archilab.ecommerce.solution.storageunit.domain.valueObjects.StorageUnitId;
6: 
7: public interface StorageUnitRepository extends CrudRepository<StorageUnit, StorageUnitId> {
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnit.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.*;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
7: import thkoeln.archilab.ecommerce.solution.product.domain.valueObjects.ProductId;
8: import thkoeln.archilab.ecommerce.solution.storageunit.domain.valueObjects.Adress;
9: import thkoeln.archilab.ecommerce.solution.storageunit.domain.valueObjects.StockLevel;
10: import thkoeln.archilab.ecommerce.solution.storageunit.domain.valueObjects.StorageUnitId;
11: 
12: import java.util.*;
13: 
14: @Entity
15: @Getter
16: @Setter
17: @AllArgsConstructor
18: @NoArgsConstructor
19: public class StorageUnit {
20: 
21:     @Setter(AccessLevel.PRIVATE)    // only for JPA
22:     @EmbeddedId
23:     private StorageUnitId id;
24: 
25:     private String name;
26: 
27:     private int fromZipCodeFirstDigit;
28: 
29:     private int toZipCodeFirstDigit;
30: 
31:     @Embedded
32:     private PhysicalAddress adress;
33: 
34:     @ElementCollection(fetch = FetchType.EAGER)
35:     private List<StockLevel> stockLevels;
36: 
37:     public StorageUnit(String name, PhysicalAddress adress, ArrayList<StockLevel> stockLevels) {
38:         validateStorageUnitName(name);
39:         validateStockLevels(stockLevels);
40: 
41:         this.id = new StorageUnitId();
42:         this.name = name;
43:         this.adress = adress;
44:         this.stockLevels = stockLevels;
45:     }
46: 
47:     public Set<ProductId> fulfillableShoppingCartParts(Map<ProductId, Integer> productQuantityMap) {
48:         Set<ProductId> fulfillableProducts = new HashSet<>();
49: 
50:         for (Map.Entry<ProductId, Integer> entry : productQuantityMap.entrySet()) {
51:             ProductId productId = entry.getKey();
52:             int requiredQuantity = entry.getValue();
53: 
54:             for (StockLevel stockLevel : this.stockLevels) {
55:                 if (stockLevel.getProduct().getId().equals(productId) &&
56:                         stockLevel.getQuantityOfProducts() >= requiredQuantity) {
57:                     fulfillableProducts.add(productId);
58:                     break;
59:                 }
60:             }
61:         }
62: 
63:         return fulfillableProducts;
64:     }
65: 
66:     private void validateStorageUnitName(String name) {
67:         if (name == null || name.trim().isEmpty()) {
68:             throw new ShopException("Name cannot be null or empty");
69:         }
70:     }
71: 
72: 
73:     private void validateStockLevels(List<StockLevel> stockLevels) {
74:         if (stockLevels == null) {
75:             throw new ShopException("Stock levels must not be null");
76:         }
77:     }
78: 
79: 
80: }
81: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitComparator.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
4: import thkoeln.archilab.ecommerce.solution.product.domain.valueObjects.ProductId;
5: 
6: import java.util.Comparator;
7: import java.util.Map;
8: import java.util.Set;
9: 
10: public class StorageUnitComparator implements Comparator<StorageUnit> {
11:     private final Map<ProductId, Integer> shoppingCart;
12:     private final ZipCode userZip;
13: 
14:     public StorageUnitComparator(Map<ProductId, Integer> shoppingCart, ZipCode userZip) {
15:         this.shoppingCart = shoppingCart;
16:         this.userZip = userZip;
17:     }
18: 
19:     @Override
20:     public int compare(StorageUnit s1, StorageUnit s2) {
21:         Set<ProductId> s1Fulfillable = s1.fulfillableShoppingCartParts(shoppingCart);
22:         Set<ProductId> s2Fulfillable = s2.fulfillableShoppingCartParts(shoppingCart);
23: 
24:         int s1Count = s1Fulfillable.size();
25:         int s2Count = s2Fulfillable.size();
26: 
27:         if (s1Count != s2Count) {
28:             return Integer.compare(s2Count, s1Count); // Mehr erfüllte Produkte zuerst
29:         }
30: 
31:         // Bei Gleichstand: Nähe der Postleitzahl
32:         int s1ZipDiff = s1.getAdress().getZipCode().difference(userZip);
33:         int s2ZipDiff = s2.getAdress().getZipCode().difference(userZip);
34: 
35:         return Integer.compare(s1ZipDiff, s2ZipDiff); // Kleinere Entfernung zuerst
36:     }
37: }
38: 
39: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\valueObjects\Adress.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain.valueObjects;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.AllArgsConstructor;
5: import lombok.EqualsAndHashCode;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.ShopException;
9: 
10: @Embeddable
11: @EqualsAndHashCode
12: @Getter
13: @NoArgsConstructor
14: public class Adress {
15:     private String street;
16:     private String city;
17:     private String zipCode;
18: 
19:     public Adress(String street, String city, String zipCode) {
20:         validateStreet(street);
21:         validateCity(city);
22:         validateZipCode(zipCode);
23: 
24:         this.street = street;
25:         this.city = city;
26:         this.zipCode = zipCode;
27:     }
28: 
29:     private void validateStreet(String street) {
30:         if (street == null || street.trim().isEmpty()) {
31:             throw new ShopException("Street must not be null or empty");
32:         }
33:     }
34: 
35:     private void validateCity(String city) {
36:         if (city == null || city.trim().isEmpty()) {
37:             throw new ShopException("City must not be null or empty");
38:         }
39:     }
40: 
41:     private void validateZipCode(String zipCode) {
42:         if (zipCode == null || zipCode.trim().isEmpty()) {
43:             throw new ShopException("Zip code must not be null or empty");
44:         }
45:         if (!zipCode.matches("\\d{5}")) {
46:             throw new ShopException("Zip code must be a 5-digit number");
47:         }
48:     }
49: }
50: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\valueObjects\StockLevel.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain.valueObjects;
2: 
3: import jakarta.persistence.Embeddable;
4: import jakarta.persistence.FetchType;
5: import jakarta.persistence.ManyToOne;
6: import lombok.AllArgsConstructor;
7: import lombok.EqualsAndHashCode;
8: import lombok.Getter;
9: import lombok.NoArgsConstructor;
10: import thkoeln.archilab.ecommerce.ShopException;
11: import thkoeln.archilab.ecommerce.solution.product.domain.entities.Product;
12: 
13: @Embeddable
14: @EqualsAndHashCode
15: @Getter
16: @NoArgsConstructor
17: public class StockLevel {
18:     private int quantityOfProducts;
19: 
20:     @ManyToOne(fetch = FetchType.EAGER)
21:     private Product product;
22: 
23: 
24:     public StockLevel(int quantityOfProducts,  Product product) {
25:         validateQuantity(quantityOfProducts);
26: 
27:         this.quantityOfProducts = quantityOfProducts;
28:         this.product = product;
29:     }
30: 
31:     private void validateQuantity(int addedQuantityOf) {
32:         if (addedQuantityOf < 0) {
33:             throw new ShopException("addedQuantityOf is not valid");
34:         }
35:     }
36: 
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\valueObjects\StorageUnitId.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain.valueObjects;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.io.Serializable;
11: import java.util.UUID;
12: 
13: @Embeddable
14: @NoArgsConstructor(access = AccessLevel.PUBLIC)
15: @AttributeOverride(name = "id", column = @Column(name = "storageunit_id"))
16: public class StorageUnitId extends GenericId implements Serializable {
17:     public StorageUnitId(UUID id) {
18:         super(id);
19:     }
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\valueObjects\StorageUnitIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain.valueObjects;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class StorageUnitIdConverter extends GenericIdConverter<StorageUnitId> {
8:     public StorageUnitIdConverter() {
9:         super(StorageUnitId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\applicationServices\UserRegistrationService.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application.applicationServices;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Email;
7: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
8: import thkoeln.archilab.ecommerce.solution.user.domain.entities.User;
9: import thkoeln.archilab.ecommerce.solution.user.domain.repositories.UserRepository;
10: import thkoeln.archilab.ecommerce.solution.user.domain.valueObjects.UserId;
11: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
12: import thkoeln.archilab.ecommerce.usecases.UserType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
15: 
16: import java.util.UUID;
17: 
18: @Service
19: public class UserRegistrationService implements UserRegistrationUseCases {
20:     private final UserRepository userRepository;
21:     @Autowired
22:     public UserRegistrationService(UserRepository userRepository) {
23:         this.userRepository = userRepository;
24:     }
25: 
26:     @Override
27:     public void register(String name, EmailType email, PhysicalAddressType physicalAddress) {
28:         ensureUserDoesNotExist((Email) email);
29:         if (name == null || name.trim().isEmpty()) {
30:             throw new ShopException("Name cannot be null or empty");
31:         }
32:         if (email == null ) {
33:             throw new ShopException("Email cannot be null");
34:         }
35:         if (physicalAddress == null) {
36:             throw new ShopException("Physical address cannot be null");
37:         }
38: 
39:         User user = new User( name, (Email) email, (PhysicalAddress) physicalAddress);
40:         userRepository.save(user);
41:     }
42: 
43:     @Override
44:     public void changeAddress(EmailType userEmail, PhysicalAddressType physicalAddresse) {
45: 
46:         User user = getExistingUserOrThrow((Email) userEmail);
47: 
48:         if (physicalAddresse == null) {
49:             throw new ShopException("Physical address cannot be null");
50:         }
51: 
52:         user.setAddress((PhysicalAddress) physicalAddresse);
53:         userRepository.save(user);
54:     }
55: 
56:     @Override
57:     public UserType getUserData(EmailType userEmail) {
58:         return getExistingUserOrThrow((Email) userEmail);
59:     }
60: 
61:     @Override
62:     public void deleteAllUsers() {
63:         userRepository.deleteAll();
64:     }
65: 
66:     public void ensureUserDoesNotExist(Email email) {
67:         if (userRepository.findByEmail(email) != null) {
68:             throw new ShopException("User with this email already exists");
69:         }
70:     }
71:     public void ensureUserExists(Email email) {
72:         if (userRepository.findByEmail(email) == null) {
73:             throw new ShopException("User with this email does not exist");
74:         }
75:     }
76:     public User getExistingUserOrThrow(Email email) {
77:         User user = userRepository.findByEmail(email);
78:         if (user == null) {
79:             throw new ShopException("User with this email does not exist");
80:         }
81:         return user;
82:     }
83: 
84:     public User getExistingUserByIdOrThrow(UUID userId) {
85:         User user = userRepository.findById(new UserId(userId)).orElseThrow();
86:         return user;
87:     }
88: }
89: 
90: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserController.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.http.HttpStatus;
5: import org.springframework.http.ResponseEntity;
6: import org.springframework.web.bind.annotation.GetMapping;
7: import org.springframework.web.bind.annotation.RequestParam;
8: import org.springframework.web.bind.annotation.RestController;
9: import thkoeln.archilab.ecommerce.ShopException;
10: import thkoeln.archilab.ecommerce.domainprimitives.Email;
11: import thkoeln.archilab.ecommerce.solution.user.application.applicationServices.UserRegistrationService;
12: import thkoeln.archilab.ecommerce.solution.user.domain.entities.User;
13: 
14: @RestController
15: public class UserController {
16:     private final UserRegistrationService userRegistrationService;
17: 
18:     @Autowired
19:     public UserController(UserRegistrationService userRegistrationService) {
20:         this.userRegistrationService = userRegistrationService;
21:     }
22: 
23:     @GetMapping(value = "/users", params = "email")
24:     public ResponseEntity<UserDTO> getUserFilteredByRequestParameter(
25:             @RequestParam(name = "email") String emailString) {
26:         User user;
27:         try {
28:             user = userRegistrationService.getExistingUserOrThrow(new Email(emailString));
29:         } catch (ShopException e) {
30:             return new ResponseEntity<>(HttpStatus.NOT_FOUND);
31:         }
32: 
33:         UserDTO userDTO = UserDTO.fromDomainObject(user);
34:         return ResponseEntity.ok(userDTO);
35:     }
36: 
37:     @GetMapping(value = "/users")
38:     public ResponseEntity<Void> handleMissingEmailParam() {
39:         return ResponseEntity.status(405).build();  // 405 = Method Not Allowed
40:     }
41: }
42: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import jakarta.persistence.Embedded;
4: import jakarta.persistence.EmbeddedId;
5: import lombok.*;
6: import thkoeln.archilab.ecommerce.domainprimitives.Email;
7: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
8: import thkoeln.archilab.ecommerce.solution.user.domain.entities.User;
9: import thkoeln.archilab.ecommerce.solution.user.domain.valueObjects.UserId;
10: 
11: import java.util.UUID;
12: 
13: 
14: @Data
15: @NoArgsConstructor
16: @AllArgsConstructor
17: public class UserDTO {
18:     private UUID id;
19:     private String name;
20:     private Email email;
21:     private PhysicalAddress address;
22: 
23:     public static UserDTO fromDomainObject(User user) {
24:         UserDTO userDTO = new UserDTO();
25:         userDTO.id = user.getId().getId();
26:         userDTO.name = user.getName();
27:         userDTO.email = (Email) user.getEmail();
28:         userDTO.address = (PhysicalAddress) user.getPhysicalAddress();
29:         return userDTO;
30:     }
31: }
32: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\entities\User.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain.entities;
2: 
3: import jakarta.persistence.*;
4: import lombok.*;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Email;
7: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
8: import thkoeln.archilab.ecommerce.solution.user.domain.valueObjects.UserId;
9: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
10: import thkoeln.archilab.ecommerce.usecases.UserType;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
13: 
14: @Entity
15: @Getter
16: @Setter
17: @AllArgsConstructor
18: @NoArgsConstructor
19: @Table(name = "UserTable")
20: public class User implements UserType {
21: 
22: 
23:     @Setter(AccessLevel.PRIVATE)    // only for JPA
24:     @EmbeddedId
25:     private UserId id;
26: 
27:     private String name;
28: 
29:     @Embedded
30:     private Email email;
31:     @Embedded
32:     private PhysicalAddress address;
33: 
34:     public User(String name, Email email, PhysicalAddress address) {
35:         validateUserName(name);
36: 
37:         this.id = new UserId();
38:         this.name = name;
39:         this.email = email;
40:         this.address = address;
41:     }
42: 
43: 
44:     private void validateUserName(String name) {
45:         if (name == null || name.trim().isEmpty()) {
46:             throw new ShopException("Name cannot be null or empty");
47:         }
48:     }
49: 
50:     @Override
51:     public PhysicalAddressType getPhysicalAddress() {
52:         return address;
53:     }
54: 
55:     @Override
56:     public EmailType getEmail() {
57:         return email;
58:     }
59: 
60:     @Override
61:     public String getName() {
62:         return name;
63:     }
64: }
65: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\repositories\UserRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain.repositories;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import thkoeln.archilab.ecommerce.domainprimitives.Email;
5: import thkoeln.archilab.ecommerce.solution.user.domain.entities.User;
6: import thkoeln.archilab.ecommerce.solution.user.domain.valueObjects.UserId;
7: 
8: public interface UserRepository extends CrudRepository<User, UserId> {
9:     User findByEmail(Email email);
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\valueObjects\Adress.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain.valueObjects;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.AllArgsConstructor;
5: import lombok.EqualsAndHashCode;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.ShopException;
9: 
10: @Embeddable
11: @EqualsAndHashCode
12: @Getter
13: @NoArgsConstructor
14: public class Adress {
15:     private String street;
16:     private String city;
17:     private String zipCode;
18: 
19:     public Adress(String street, String city, String zipCode) {
20:         validateStreet(street);
21:         validateCity(city);
22:         validateZipCode(zipCode);
23: 
24:         this.street = street;
25:         this.city = city;
26:         this.zipCode = zipCode;
27:     }
28: 
29:     private void validateStreet(String street) {
30:         if (street == null || street.trim().isEmpty()) {
31:             throw new ShopException("Street must not be null or empty");
32:         }
33:     }
34: 
35:     private void validateCity(String city) {
36:         if (city == null || city.trim().isEmpty()) {
37:             throw new ShopException("City must not be null or empty");
38:         }
39:     }
40: 
41:     private void validateZipCode(String zipCode) {
42:         if (zipCode == null || zipCode.trim().isEmpty()) {
43:             throw new ShopException("Zip code must not be null or empty");
44:         }
45:         if (!zipCode.matches("\\d{5}")) {
46:             throw new ShopException("Zip code must be a 5-digit number");
47:         }
48:     }
49: }
50: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\valueObjects\UserId.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain.valueObjects;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.io.Serializable;
11: import java.util.UUID;
12: 
13: @Embeddable
14: @NoArgsConstructor(access = AccessLevel.PUBLIC)
15: @AttributeOverride(name = "id", column = @Column(name = "user_id"))
16: public class UserId extends GenericId implements Serializable {
17:     public UserId(UUID id) {
18:         super(id);
19:     }
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\valueObjects\UserIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain.valueObjects;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class UserIdConverter extends GenericIdConverter<UserId> {
8:     public UserIdConverter() {
9:         super(UserId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\EmailType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface EmailType {
6:     /**
7:      * @return the email as a string
8:      */
9:     public String toString();
10: 
11: 
12:     /**
13:      * A special kind of "copy constructor": Returns a new email object with
14:      * the same identifyer (the substring left of the "@" sign) as the current one, but
15:      * with a new domain substring (right of the "@" sign).
16:      * @param domainString - the new domain for the copied email
17:      * @return the new email
18:      * @throws ShopException if ...
19:      *     - domainString is null
20:      *     - the new email would not be valid (see `of(...)` method)
21:      */
22:     public EmailType sameIdentifyerDifferentDomain( String domainString );
23: 
24:     /**
25:      * Another special kind of "copy constructor": Returns a new email object
26:      * with the same domain (the substring right of the "@" sign) as the current one, but
27:      * with a new identifyer substring (left of the "@" sign).
28:      * @param identifyerString - the new identifyer for the copied email
29:      * @return the new email
30:      * @throws ShopException if ...
31:      *     - identifyerString is null
32:      *     - the new email would not be valid (see `of(...)` method)
33:      */
34:     public EmailType sameDomainDifferentIdentifyer( String identifyerString );
35: 
36: 
37:     /**
38:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
39:      * implementing class to provide a static factory method (simply named "of(...)"),
40:      * which creates an email, given as a string.
41:      * We specify this factory method here as a comment, using the Javadoc documentation style.
42:      *
43:      * @param emailAsString - the email as a string.
44:      *      We will use a much simplified validation method to check if the email is valid:
45:      *      - it must contain exactly one '@' character.
46:      *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
47:      *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
48:      *      - the substrings before and after the '@' may contain one or several '.' as separators
49:      *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
50:      *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
51:      *        (for simplicity we do not allow any other domains)
52:      * @return a new EmailType object matching the given email
53:      * @throws ShopException if ...
54:      *      - emailAsString is null
55:      *      - emailAsString is not a valid email (see above)
56:      */
57:      // public static EmailType of( String emailAsString );
58: }
59: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MoneyType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface MoneyType {
6:     /**
7:      * @return the amount of money
8:      */
9:     public Float getAmount();
10: 
11: 
12:     /**
13:      * @return the currency unit of the money
14:      */
15:     public String getCurrencyUnit();
16: 
17: 
18:     /**
19:      * @param otherMoney
20:      * @return this + otherMoney, as a new object
21:      * @throws ShopException if ...
22:      *      - otherMoney is null
23:      *      - otherMoney.currencyUnit != this.currencyUnit
24:      */
25:     public MoneyType add( MoneyType otherMoney );
26: 
27: 
28:     /**
29:      * @param otherMoney
30:      * @return this - otherMoney, as a new object
31:      * @throws ShopException if ...
32:      *      - otherMoney is null
33:      *      - otherMoney.currencyUnit != this.currencyUnit
34:      *      - otherMoney > this
35:      */
36:     public MoneyType subtract( MoneyType otherMoney );
37: 
38: 
39:     /**
40:      * @param factor
41:      * @return this * factor, as a new object
42:      * @throws ShopException if ...
43:      *     - factor < 0
44:      */
45:     public MoneyType multiplyBy( int factor );
46: 
47:     /**
48:      * @param otherMoney
49:      * @return true, if this > otherMoney
50:      * @throws ShopException if ...
51:      *      - otherMoney is null
52:      *      - otherMoney.currencyUnit != this.currencyUnit
53:      */
54:     public boolean largerThan( MoneyType otherMoney );
55: 
56: 
57:     /**
58:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
59:      * implementing class to provide a static factory method (simply named "of(...)"),
60:      * which creates a money object from an amount and a currency unit (as string).
61:      * We specify this factory method here as a comment, using the Javadoc documentation style.
62:      *
63:      * @param amount the amount of money (must be >= 0)
64:      * @param currencyUnit the currency unit of the money (allowed values: "EUR", "CHF")
65:      * @return a new Money object with the given amount and currency unit
66:      * @throws ShopException if ...
67:      *   - amount is null
68:      *   - amount < 0
69:      *   - currency unit is null
70:      *   - currency unit is not one of the allowed values
71:      */
72:      // public static MoneyType of( Float amount, String currencyUnit );
73: }
74: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PhysicalAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface PhysicalAddressType {
6:     /**
7:      * @return the street as a string
8:      */
9:     public String getStreet();
10: 
11:     /**
12:      * @return the city as a string
13:      */
14:     public String getCity();
15: 
16:     /**
17:      * @return the zip code
18:      */
19:     public ZipCodeType getZipCode();
20: 
21:     /**
22:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
23:      * implementing class to provide a static factory method (simply named "of(...)"),
24:      * which creates an zip code, given as a string.
25:      * We specify this factory method here as a comment, using the Javadoc documentation style.
26:      *
27:      * @param street the street as a string
28:      * @param city the city as a string
29:      * @param zipCode the zip code
30:      * @return the physical address object matching the parameters
31:      * @throws ShopException if ...
32:      *      - street is null or empty
33:      *      - city is null or empty
34:      *      - zipCode is null
35:      */
36:      // public static PhysicalAddressType of( String street, String city, ZipCodeType zipCode );
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\ZipCodeType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnore;
4: import thkoeln.archilab.ecommerce.ShopException;
5: 
6: public interface ZipCodeType {
7:     /**
8:      * @return the zip code as a string
9:      */
10:     public String toString();
11: 
12:     /**
13:      * You will need some idea of "imprecise difference" between two zip codes for properly
14:      * implementing storage units in your shopping platform. This method calculates such a
15:      * difference. You can decide for yourself what values you return, unless you comply
16:      * with the following rules.
17:      * - The return value is 0 if both zip codes are the same
18:      * - If not:
19:      *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
20:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
21:      *        So, 56733 and 56734 have the same difference as 56733 and 56739.
22:      *      - The difference grows if more digits (counted from the right side) differ.
23:      *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
24:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
25:      *        53876 and 54876 have the same difference as 53876 and 57261.
26:      *      - However, the difference between 5abcd and 6rstu must be smaller than the one
27:      *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
28:      *        one between 5abcd and 9rstu.
29:      *      - This last condition reflects the fact the first digits of a zip code marks a region
30:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
31:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
32:      *        other.
33:      * @param otherZipCode
34:      * @return the calculated difference
35:      * @throws ShopException if otherZipCode is null
36:      */
37:     public int difference( ZipCodeType otherZipCode );
38: 
39: 
40:     /**
41:      * For the currently used way of deciding on the best fitting storage unit for a purchase,
42:      * we need to know the first digit of the zip code.
43:      */
44:     @JsonIgnore
45:     public Integer getFirstDigitZipCode();
46: 
47: 
48:     /**
49:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
50:      * implementing class to provide a static factory method (simply named "of(...)"),
51:      * which creates an zip code, given as a string.
52:      * We specify this factory method here as a comment, using the Javadoc documentation style.
53:      *
54:      * @param zipCodeAsString - the zip code as a string.
55:      *      We will use a much simplified validation method to check if the zip code is valid:
56:      *      - It must contain exactly 5 digits.
57:      *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid zip code, but 20001 is valid)
58:      * @return a new zip code object matching the given string
59:      * @throws ShopException if ...
60:      *      - zipCodeAsString is null
61:      *      - zipCodeAsString is not a valid zip code (see above)
62:      */
63:      // public static ZipCodeType of( String zipCodeAsString );
64: }
65: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
8: 
9: import java.io.File;
10: import java.io.IOException;
11: import java.lang.reflect.InvocationTargetException;
12: import java.lang.reflect.Method;
13: import java.lang.reflect.Modifier;
14: import java.net.URL;
15: import java.net.URLDecoder;
16: import java.nio.charset.StandardCharsets;
17: import java.util.Enumeration;
18: 
19: import static org.junit.jupiter.api.Assertions.*;
20: 
21: public class FactoryMethodInvoker {
22: 
23:     public static EmailType instantiateEmail( String emailAsString ) {
24:         Method factoryMethod = null;
25:         try {
26:             Class<?> interfaceClass = Class.forName(
27:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType" );
28:             Class<?> implementingClass = findImplementation( interfaceClass );
29: 
30:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
31:             assertNotNull( factoryMethod );
32:             int modifiers = factoryMethod.getModifiers();
33:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
34:         } catch (Exception e) {
35:             fail( "Failed to find implementation for EmailType", e );
36:         }
37: 
38:         Object instance = null;
39:         try {
40:             instance = factoryMethod.invoke( null, emailAsString );
41:         } catch (Exception e) {
42:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
43:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
44:             fail( "Failed to invoke factory method 'of' for '" + emailAsString + "'", e );
45:         }
46:         assertNotNull( instance );
47:         return (EmailType) instance;
48:     }
49: 
50: 
51:     public static PhysicalAddressType instantiatePhysicalAddress(
52:             String street, String city, ZipCodeType zipCode ) {
53:         Method factoryMethod = null;
54:         try {
55:             Class<?> interfaceClass = Class.forName(
56:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType" );
57:             Class<?> implementingClass = findImplementation( interfaceClass );
58: 
59:             factoryMethod = implementingClass.getDeclaredMethod( "of",
60:                     String.class, String.class, ZipCodeType.class );
61:             assertNotNull( factoryMethod );
62:             int modifiers = factoryMethod.getModifiers();
63:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
64:         } catch (Exception e) {
65:             fail( "Failed to find implementation for PhysicalAddressType", e );
66:         }
67: 
68:         Object instance = null;
69:         try {
70:             instance = factoryMethod.invoke( null, street, city, zipCode );
71:         } catch (Exception e) {
72:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
73:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
74:             fail( "Failed to invoke factory method 'of' for '" +
75:                     street + "', '" + city + "', '" + zipCode + "'", e );
76:         }
77:         assertNotNull( instance );
78:         return (PhysicalAddressType) instance;
79:     }
80: 
81: 
82:     public static ZipCodeType instantiateZipCode( String zipCodeAsString ) {
83:         Method factoryMethod = null;
84:         try {
85:             Class<?> interfaceClass = Class.forName(
86:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType" );
87:             Class<?> implementingClass = findImplementation( interfaceClass );
88: 
89:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
90:             assertNotNull( factoryMethod );
91:             int modifiers = factoryMethod.getModifiers();
92:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
93:         } catch (Exception e) {
94:             fail( "Failed to find implementation for ZipCodeType", e );
95:         }
96: 
97:         Object instance = null;
98:         try {
99:             instance = factoryMethod.invoke( null, zipCodeAsString );
100:         } catch (Exception e) {
101:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
102:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
103:             fail( "Failed to invoke factory method 'of' for '" + zipCodeAsString + "'", e );
104:         }
105:         assertNotNull( instance );
106:         return (ZipCodeType) instance;
107:     }
108: 
109: 
110:     public static MoneyType instantiateMoney( Float amount, String currencyUnit ) {
111:         Method factoryMethod = null;
112:         try {
113:             Class<?> interfaceClass = Class.forName(
114:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType" );
115:             Class<?> implementingClass = findImplementation( interfaceClass );
116: 
117:             factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
118:             assertNotNull( factoryMethod );
119:             int modifiers = factoryMethod.getModifiers();
120:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
121:         } catch (Exception e) {
122:             fail( "Failed to find implementation for MoneyType", e );
123:         }
124: 
125:         Object instance = null;
126:         try {
127:             instance = factoryMethod.invoke( null, amount, currencyUnit );
128:         } catch (Exception e) {
129:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
130:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
131:             fail( "Failed to invoke factory method 'of' for '" + amount + "', '" + currencyUnit + "'", e );
132:         }
133:         assertNotNull( instance );
134:         return (MoneyType) instance;
135:     }
136: 
137: 
138:     private static Class<?> findImplementation( Class<?> interfaceClass ) {
139:         Method factoryMethod = null;
140:         try {
141:             String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
142:             Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
143:             assertNotNull( implementingClass );
144:             return implementingClass;
145:         } catch (Exception e) {
146:             fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
147:             return null; // This line will never be reached, but it's necessary to satisfy the compiler
148:         }
149:     }
150: 
151: 
152:     private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
153:             throws ClassNotFoundException, IOException {
154:         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
155:         String path = packageName.replace( '.', '/' );
156:         Enumeration<URL> resources = classLoader.getResources( path );
157:         int count = 0;
158:         Class<?> result = null;
159:         while (resources.hasMoreElements()) {
160:             URL resource = resources.nextElement();
161:             File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
162:             File[] files = directory.listFiles();
163:             for ( File file : files ) {
164:                 if ( file.getName().endsWith( ".class" ) ) {
165:                     String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
166:                     Class<?> clazz = Class.forName( className );
167:                     if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
168:                         count++;
169:                         result = clazz;
170:                     }
171:                 }
172:             }
173:         }
174:         assertEquals( 1, count, "There should be exactly one implementing class" );
175:         return result;
176:     }
177: }
178: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\StockTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
7: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
8: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
12: 
13: import java.util.*;
14: 
15: /**
16:  * This is a test helper class that initializes and registers products (but without stock)
17:  * in the system, using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class StockTestHelperImpl
22:                         implements ProductTestHelper, StorageUnitTestHelper {
23:     private ProductCatalogUseCases productCatalogUseCases;
24:     private StorageUnitUseCases storageUnitUseCases;
25:     private static Random random = new Random();
26: 
27:     private static final String EUR = "EUR";
28:     private static final int PRODUCT_NUMOF = 15;
29:     private static final Object[][] PRODUCT_DATA = new Object[][]{
30:             {null, "0-TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
31:                     1.5f, FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
32:                     FactoryMethodInvoker.instantiateMoney( 10.0f, EUR ),
33:                     "0"},
34:             {null, "1-EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
35:                     0.3f, FactoryMethodInvoker.instantiateMoney( 2.5f, EUR ),
36:                     FactoryMethodInvoker.instantiateMoney( 4.0f, EUR ),
37:                     "0"},
38:             {null, "2-MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
39:                     7.2f, FactoryMethodInvoker.instantiateMoney( 50.0f, EUR ),
40:                     FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
41:                     "0"},
42:             {null, "3-Gh-25", "Kompakter und leichter Akku für mobile Geräte",
43:                     null, FactoryMethodInvoker.instantiateMoney( 6.0f, EUR ),
44:                     FactoryMethodInvoker.instantiateMoney( 8.0f, EUR ),
45:                     "0"},
46:             {null, "4-MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
47:                     null, FactoryMethodInvoker.instantiateMoney( 0.6f, EUR ),
48:                     FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
49:                     "0"},
50:             {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
51:                     1.0f, FactoryMethodInvoker.instantiateMoney( 150.0f, EUR ),
52:                     FactoryMethodInvoker.instantiateMoney( 250.0f, EUR ),
53:                     "0"},
54:             {null, "6-Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
55:                     null, FactoryMethodInvoker.instantiateMoney( 0.3f, EUR ),
56:                     FactoryMethodInvoker.instantiateMoney( 0.5f, EUR ),
57:                     "0"},
58:             {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
59:                     6.0f, FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
60:                     FactoryMethodInvoker.instantiateMoney( 120.0f, EUR ),
61:                     "123"},
62:             {null, "8-JKL-67", "Wasserdichtes Gehäuse",
63:                     3.0f, FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
64:                     FactoryMethodInvoker.instantiateMoney( 1.2f, EUR ),
65:                     "467"},
66:             {null, "9-MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
67:                     5.5f, FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
68:                     FactoryMethodInvoker.instantiateMoney( 45.0f, EUR ),
69:                     "578"},
70:             {null, "10-PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
71:                     4.0f, FactoryMethodInvoker.instantiateMoney( 20.0f, EUR ),
72:                     FactoryMethodInvoker.instantiateMoney( 35.0f, EUR ),
73:                     "567"},
74:             {null, "11-STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
75:                     null, FactoryMethodInvoker.instantiateMoney( 200.0f, EUR ),
76:                     FactoryMethodInvoker.instantiateMoney( 350.0f, EUR ),
77:                     "478"},
78:             {null, "12-VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
79:                     null, FactoryMethodInvoker.instantiateMoney( 15.0f, EUR ),
80:                     FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
81:                     "5"},
82:             {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
83:                     3.5f, FactoryMethodInvoker.instantiateMoney( 60.0f, EUR ),
84:                     FactoryMethodInvoker.instantiateMoney( 100.0f, EUR ),
85:                     "78"},
86:             {null, "14-Nosedive", "Klammer zum Verschließen der Nase beim Tauchen",
87:                     5.0f, FactoryMethodInvoker.instantiateMoney( 2.0f, EUR ),
88:                     FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
89:                     "457"}
90:     };
91:     
92: 
93:     // These physical addresss are used for the storage units. The storage unit name will equal
94:     // the zip code of the site. Their index number will be visible in the house number.
95:     // The storage units are used as such:
96:     // - storage unit 0 is holds all products 0 - 6, and is used for all tests where multiple
97:     //   shipments are irrelevant.
98:     // - storage units 1 - 3 are used for the proximity tests, where you can deliver products 7 to
99:     //   to a user from the closest storage unit.
100:     // - storage units 4 - 8 are used for the tests where you need to deliver products 8 - 14 in
101:     //   the most cost-efficient way, as multiple shipments.
102:     // - storage unit 9 is empty.
103:     private final static int STORAGE_UNIT_NUMOF = 10;
104:     private final static PhysicalAddressType[] STORAGE_UNIT_PHYSICAL_ADDRESS = new PhysicalAddressType[]{
105:             FactoryMethodInvoker.instantiatePhysicalAddress(
106:                     "Stapelallee 0", "Potsdam",
107:                     FactoryMethodInvoker.instantiateZipCode( "14476" ) ),
108:             FactoryMethodInvoker.instantiatePhysicalAddress(
109:                     "Lagerhausstr. 1", "Viertelstadt",
110:                     FactoryMethodInvoker.instantiateZipCode( "02345" ) ),
111:             FactoryMethodInvoker.instantiatePhysicalAddress(
112:                     "Speicherplatz 2", "Viertelstadt",
113:                     FactoryMethodInvoker.instantiateZipCode( "02313" ) ),
114:             FactoryMethodInvoker.instantiatePhysicalAddress(
115:                     "Ablageweg 3", "Reichswürgen",
116:                     FactoryMethodInvoker.instantiateZipCode( "44923" ) ),
117:             FactoryMethodInvoker.instantiatePhysicalAddress(
118:                     "Paketstellenallee 4", "Düsseldorf",
119:                     FactoryMethodInvoker.instantiateZipCode( "40588" ) ),
120:             FactoryMethodInvoker.instantiatePhysicalAddress(
121:                     "Kaputte-Sachen-Straße 5", "Düren",
122:                     FactoryMethodInvoker.instantiateZipCode( "52355" ) ),
123:             FactoryMethodInvoker.instantiatePhysicalAddress(
124:                     "Aufbewahrungsweg 6", "Viernheim",
125:                     FactoryMethodInvoker.instantiateZipCode( "68519" ) ),
126:             FactoryMethodInvoker.instantiatePhysicalAddress(
127:                     "Paketallee 7", "Baden-Baden",
128:                     FactoryMethodInvoker.instantiateZipCode( "76532" ) ),
129:             FactoryMethodInvoker.instantiatePhysicalAddress(
130:                     "Sendenstr. 8", "Senden",
131:                     FactoryMethodInvoker.instantiateZipCode( "89250" ) ),
132:             FactoryMethodInvoker.instantiatePhysicalAddress(
133:                     "Schickweg 9", "Hohenroth",
134:                     FactoryMethodInvoker.instantiateZipCode( "97618" ) )
135:     };
136:     private final static UUID[] STORAGE_UNIT_ID = new UUID[STORAGE_UNIT_NUMOF];
137: 
138: 
139:     // These data structures contain the stock of the products in the storage units.
140:     // PRODUCT_STOCK is a map product name -> Integer[STORAGE_UNIT_NUMOF].
141:     // The Integer[STORAGE_UNIT_NUMOF] contains the stock of the product in each of
142:     // the storage units.
143:     //
144:     // The following rules apply:
145:     // - product 0 is out of stock
146:     // - product 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in storage unit 0
147:     // - product 4 / 5 / 6 have a random stock between 30 and 130, also all ONLY in storage unit 0
148:     //   (these are the products used for tests on how to add and remove stock)
149:     // - the others have a random stock between 30 and 130, distributed over several
150:     //   storage units. Here we follow this convention for simplicity:
151:     //   - Assume that the product is available in <n> storage units. Then the first <n-1> storage units
152:     //     in the list (in ascending sequence) contain 3, and all the remaining stock is in the
153:     //     last storage unit.
154: 
155:     private static final Map<String, Integer[]> PRODUCT_STOCK = new HashMap<>();
156: 
157:     static {
158:         // products 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
159:         PRODUCT_STOCK.put( (String) PRODUCT_DATA[0][1],
160:                 getStockDistribution( 0, (String) PRODUCT_DATA[0][6] ) );
161:         PRODUCT_STOCK.put( (String) PRODUCT_DATA[1][1],
162:                 getStockDistribution( 10, (String) PRODUCT_DATA[1][6] ) );
163:         PRODUCT_STOCK.put( (String) PRODUCT_DATA[2][1],
164:                 getStockDistribution( 20, (String) PRODUCT_DATA[2][6] ) );
165:         PRODUCT_STOCK.put( (String) PRODUCT_DATA[3][1],
166:                 getStockDistribution( 30, (String) PRODUCT_DATA[3][6] ) );
167: 
168:         // The other products have a random stock between 30 and 130,
169:         for ( int i = 4; i < PRODUCT_NUMOF; i++ ) {
170:             Integer totalNumber = random.nextInt( 100 ) + 30;
171:             Integer[] stockInStorageUnits =
172:                     getStockDistribution( totalNumber, (String) PRODUCT_DATA[i][6] );
173:             PRODUCT_STOCK.put( (String) PRODUCT_DATA[i][1], stockInStorageUnits );
174:         }
175:     }
176: 
177:     /**
178:      * This method creates a random stock distribution for the given product.
179:      *
180:      * @param totalQuantity - the total number of products in the storage units
181:      * @param zeroToNine  - a string with numbers between 0 and 9, representing the storage units
182:      * @return an Integer array with the stock distribution for the product, according to
183:      * the rules described above.
184:      */
185:     private static Integer[] getStockDistribution( Integer totalQuantity, String zeroToNine ) {
186:         Integer[] stockInStorageUnits = new Integer[STORAGE_UNIT_NUMOF];
187:         for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) stockInStorageUnits[i] = 0;
188:         TreeSet<Integer> storageUnitIndices = getStorageUnitIndices( zeroToNine );
189:         int numOfIndices = storageUnitIndices.size();
190:         int currentIndexNumber = 0;
191:         int currentQuantity = totalQuantity;
192:         for ( Integer storageUnitIndex : storageUnitIndices ) {
193:             currentIndexNumber++;
194:             if ( currentIndexNumber < numOfIndices ) {
195:                 stockInStorageUnits[storageUnitIndex] = 3;
196:                 currentQuantity -= 3;
197:             } else {
198:                 stockInStorageUnits[storageUnitIndex] = currentQuantity;
199:             }
200:         }
201:         return stockInStorageUnits;
202:     }
203: 
204:     private static TreeSet<Integer> getStorageUnitIndices( String zeroToNine ) {
205:         TreeSet<Integer> storageUnitIndices = new TreeSet<>();
206:         for ( int i = 0; i < zeroToNine.length(); i++ ) {
207:             storageUnitIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
208:         }
209:         return storageUnitIndices;
210:     }
211: 
212: 
213:     @Autowired
214:     public StockTestHelperImpl( ProductCatalogUseCases productCatalogUseCases,
215:                                          StorageUnitUseCases storageUnitUseCases ) {
216:         this.productCatalogUseCases = productCatalogUseCases;
217:         this.storageUnitUseCases = storageUnitUseCases;
218:     }
219: 
220: 
221:     @Override
222:     public void addAllProducts() {
223:         int i = 0;
224:         for ( Object[] productData : PRODUCT_DATA ) {
225:             UUID newId = productCatalogUseCases.addProductToCatalog(
226:                     (String) productData[1], (String) productData[2],
227:                     (Float) productData[3], (MoneyType) productData[4],
228:                     (MoneyType) productData[5] );
229:             // The first element of the product data is the id, which was initialized with null before, but can now be set
230:             PRODUCT_DATA[i][0] = newId;
231:             i++;
232:         }
233:     }
234: 
235: 
236:     @Override
237:     public int numberOfProducts() {
238:         return PRODUCT_NUMOF;
239:     }
240: 
241: 
242:     @Override
243:     public UUID getProductId( int index ) {
244:         if ( index < 0 || index >= PRODUCT_NUMOF ) {
245:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
246:         }
247:         return (UUID) PRODUCT_DATA[index][0];
248:     }
249: 
250: 
251:     @Override
252:     public MoneyType getBuyingPrice( int index ) {
253:         if ( index < 0 || index >= PRODUCT_NUMOF ) {
254:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
255:         }
256:         return (MoneyType) PRODUCT_DATA[index][4];
257:     }
258: 
259: 
260:     @Override
261:     public MoneyType getSalesPrice( int index ) {
262:         if ( index < 0 || index >= PRODUCT_NUMOF ) {
263:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
264:         }
265:         return (MoneyType) PRODUCT_DATA[index][5];
266:     }
267: 
268: 
269:     @Override
270:     public void addAllStorageUnits( boolean withStock ) {
271:         for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) {
272:             STORAGE_UNIT_ID[i] = storageUnitUseCases.addNewStorageUnit(
273:                     STORAGE_UNIT_PHYSICAL_ADDRESS[i].getStreet(),
274:                     STORAGE_UNIT_PHYSICAL_ADDRESS[i] );
275:         }
276:         if ( withStock ) {
277:             addAllStock();
278:         }
279:     }
280: 
281: 
282:     private void addAllStock() {
283:         for ( Object[] productData : PRODUCT_DATA ) {
284:             Integer[] stockInStorageUnits =
285:                     PRODUCT_STOCK.get( productData[1] );
286:             for ( int iStorageUnit = 0; iStorageUnit < STORAGE_UNIT_NUMOF; iStorageUnit++ ) {
287:                 if ( stockInStorageUnits[iStorageUnit] > 0 )
288:                     storageUnitUseCases.addToStock(
289:                             STORAGE_UNIT_ID[iStorageUnit], (UUID) productData[0],
290:                             stockInStorageUnits[iStorageUnit] );
291:             }
292:         }
293:     }
294: 
295: 
296:     @Override
297:     public int numberOfStorageUnits() {
298:         return STORAGE_UNIT_NUMOF;
299:     }
300: 
301: 
302:     @Override
303:     public UUID getStorageUnitId( int index ) {
304:         if ( index < 0 || index >= STORAGE_UNIT_NUMOF ) {
305:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
306:         }
307:         return STORAGE_UNIT_ID[index];
308:     }
309: 
310: 
311:     @Override
312:     public Integer getStorageUnitStock( int storageUnitIndex, int productIndex ) {
313:         if ( storageUnitIndex < 0 || storageUnitIndex >= STORAGE_UNIT_NUMOF ) {
314:             throw new IndexOutOfBoundsException( "Index out of bounds: " + storageUnitIndex );
315:         }
316:         if ( productIndex < 0 || productIndex >= PRODUCT_NUMOF ) {
317:             throw new IndexOutOfBoundsException( "Index out of bounds: " + productIndex );
318:         }
319:         String productName = (String) PRODUCT_DATA[productIndex][1];
320:         Integer[] stockInStorageUnits = PRODUCT_STOCK.get( productName );
321:         Integer foundStock = stockInStorageUnits[storageUnitIndex];
322:         return foundStock == null ? 0 : foundStock;
323:     }
324: 
325: 
326:     @Override
327:     public int findStorageUnitIndex( UUID storageUnitId ) {
328:         for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) {
329:             if ( STORAGE_UNIT_ID[i].equals( storageUnitId ) ) {
330:                 return i;
331:             }
332:         }
333:         throw new IllegalArgumentException( "No test storage unit with UUID id " + storageUnitId );
334:     }
335: 
336: 
337:     @Override
338:     public int findProductIndex( UUID productId ) {
339:         for ( int iProductData = 0; iProductData < STORAGE_UNIT_NUMOF; iProductData++ ) {
340:             Object[] productData = PRODUCT_DATA[iProductData];
341:             if ( productData[0].equals( productId ) ) {
342:                 return iProductData;
343:             }
344:         }
345:         throw new IllegalArgumentException( "No test product with UUID id " + productId );
346:     }
347: }
348: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\UserTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
7: import thkoeln.archilab.ecommerce.usecases.UserType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.MockUser;
12: 
13: import static org.junit.jupiter.api.Assertions.assertThrows;
14: 
15: /**
16:  * This is a test helper class that initializes and registers users in the system,
17:  * using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class UserTestHelperImpl implements UserTestHelper {
22: 
23:     private UserRegistrationUseCases userRegistrationUseCases;
24: 
25:     @Autowired
26:     public UserTestHelperImpl( UserRegistrationUseCases userRegistrationUseCases ) {
27:         this.userRegistrationUseCases = userRegistrationUseCases;
28:     }
29: 
30:     private final static String[] USER_NAME = new String[]{
31:             "Max Mueller",
32:             "Sophie Schmitz",
33:             "Irene Mihalic",
34:             "Emilia Fischer",
35:             "Filiz Polat",
36:             "Lina Wagner",
37:             "Leon Becker",
38:             "Agnieszka Kalterer",
39:             "Felix Bauer",
40:             "Lara Schulz"
41:     };
42: 
43:     private final static EmailType[] USER_EMAIL = new EmailType[]{
44:             FactoryMethodInvoker.instantiateEmail( "99Z@example.com" ),
45:             FactoryMethodInvoker.instantiateEmail( "a@4.com" ),
46:             FactoryMethodInvoker.instantiateEmail( "irene@wearefreedomnow.com" ),
47:             FactoryMethodInvoker.instantiateEmail( "emilia.fischer@example.com" ),
48:             FactoryMethodInvoker.instantiateEmail( "j877d3@example.this.com" ),
49:             FactoryMethodInvoker.instantiateEmail( "lina.marie.wagner@example.com" ),
50:             FactoryMethodInvoker.instantiateEmail( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
51:             FactoryMethodInvoker.instantiateEmail( "agna@here.ch" ),
52:             FactoryMethodInvoker.instantiateEmail( "felix.bauer@example.org" ),
53:             FactoryMethodInvoker.instantiateEmail( "lara.schulz@example.at" )
54:     };
55: 
56:     // The following array is used to create a list of physicalAddresss for the users.
57:     // The indices are coded into the house number.
58:     // - Persons 0 - 5 are used for proximity tests with one storage unit.
59:     private final static PhysicalAddressType[] USER_ADDRESS = new PhysicalAddressType[]{
60:             FactoryMethodInvoker.instantiatePhysicalAddress(
61:                     "Marktstraße 0", "Viertelstadt",
62:                     FactoryMethodInvoker.instantiateZipCode( "02314" ) ),
63:             FactoryMethodInvoker.instantiatePhysicalAddress(
64:                     "Hauptstraße 1", "Viertelstadt",
65:                     FactoryMethodInvoker.instantiateZipCode( "02368" ) ),
66:             FactoryMethodInvoker.instantiatePhysicalAddress(
67:                     "Kirchplatz 2", "Niemandstown",
68:                     FactoryMethodInvoker.instantiateZipCode( "12345" ) ),
69:             FactoryMethodInvoker.instantiatePhysicalAddress(
70:                     "Schulstraße 3", "Geisterhausen",
71:                     FactoryMethodInvoker.instantiateZipCode( "31463" ) ),
72:             FactoryMethodInvoker.instantiatePhysicalAddress(
73:                     "Rosenweg 4", "Kuhhausen",
74:                     FactoryMethodInvoker.instantiateZipCode( "72162" ) ),
75:             FactoryMethodInvoker.instantiatePhysicalAddress(
76:                     "Wiesenstraße 5", "Waldschenkensdorf",
77:                     FactoryMethodInvoker.instantiateZipCode( "82195" ) ),
78:             FactoryMethodInvoker.instantiatePhysicalAddress(
79:                     "Muehlenweg 6", "Koeln",
80:                     FactoryMethodInvoker.instantiateZipCode( "50667" ) ),
81:             FactoryMethodInvoker.instantiatePhysicalAddress(
82:                     "Goethestraße 7", "Frankfurt am Main",
83:                     FactoryMethodInvoker.instantiateZipCode( "60311" ) ),
84:             FactoryMethodInvoker.instantiatePhysicalAddress(
85:                     "Dorfstraße 8", "Stuttgart",
86:                     FactoryMethodInvoker.instantiateZipCode( "70173" ) ),
87:             FactoryMethodInvoker.instantiatePhysicalAddress(
88:                     "Bahnhofstraße 9", "Muenchen",
89:                     FactoryMethodInvoker.instantiateZipCode( "80331" ) )
90:     };
91: 
92:     private final static UserType[] mockUsers;
93: 
94:     static {
95:         mockUsers = new UserType[USER_NAME.length];
96:         for ( int i = 0; i < USER_NAME.length; i++ ) {
97:             mockUsers[i] = new MockUser(
98:                     USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
99:         }
100:     }
101: 
102: 
103:     @Override
104:     public void registerAllUsers() {
105:         for ( int i = 0; i < USER_NAME.length; i++ ) {
106:             registerUser( USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
107:         }
108:     }
109: 
110: 
111:     private void registerUser( String name, EmailType email, PhysicalAddressType physicalAddress ) {
112:         userRegistrationUseCases.register( name, email, physicalAddress );
113:     }
114: 
115: 
116:     @Override
117:     public int getNumberOfUsers() {
118:         return USER_NAME.length;
119:     }
120: 
121: 
122:     @Override
123:     public String getUserName( int index ) {
124:         if ( index < 0 || index >= USER_NAME.length ) {
125:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
126:         }
127:         return USER_NAME[index];
128:     }
129: 
130: 
131:     @Override
132:     public EmailType getUserEmail( int index ) {
133:         if ( index < 0 || index >= USER_NAME.length ) {
134:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
135:         }
136:         return USER_EMAIL[index];
137:     }
138: 
139: 
140:     @Override
141:     public PhysicalAddressType getUserPhysicalAddress( int index ) {
142:         if ( index < 0 || index >= USER_NAME.length ) {
143:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
144:         }
145:         return USER_ADDRESS[index];
146:     }
147: 
148: 
149:     @Override
150:     public UserType getUser( int index ) {
151:         if ( index < 0 || index >= USER_NAME.length ) {
152:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
153:         }
154:         return mockUsers[index];
155:     }
156: }
157: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockUser.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.Setter;
4: import thkoeln.archilab.ecommerce.usecases.UserType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;
6: 
7: 
8: import java.util.Objects;
9: 
10: @Setter
11: public class MockUser implements UserType {
12:     private String name;
13:     private EmailType emailType;
14:     private PhysicalAddressType physicalAddressType;
15: 
16: 
17:     public MockUser( String name, EmailType emailType, PhysicalAddressType physicalAddressType) {
18:         this.name = name;
19:         this.emailType = emailType;
20:         this.physicalAddressType = physicalAddressType;
21:     }
22: 
23:     @Override
24:     public String getName() {
25:         return name;
26:     }
27: 
28:     @Override
29:     public EmailType getEmail() {
30:         return emailType;
31:     }
32: 
33:     @Override
34:     public PhysicalAddressType getPhysicalAddress() {
35:         return physicalAddressType;
36:     }
37: 
38:     @Override
39:     public boolean equals( Object o ) {
40:         if ( this == o ) return true;
41:         if ( !( o instanceof MockUser ) ) return false;
42:         MockUser that = (MockUser) o;
43:         return Objects.equals( getName(), that.getName() ) &&
44:                 Objects.equals( emailType, that.emailType ) &&
45:                 Objects.equals( physicalAddressType, that.physicalAddressType );
46:     }
47: 
48:     @Override
49:     public int hashCode() {
50:         return Objects.hash( getName(), emailType, physicalAddressType );
51:     }
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ProductTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
4: 
5: import java.util.UUID;
6: 
7: public interface ProductTestHelper {
8:     /**
9:      * Adds all test products to the database.
10:      * If you use the debugger and want to identify _which_ test product you currently look at:
11:      * The indices are coded into the first number in the name string of the product, like e.g.
12:      * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
13:      */
14:     void addAllProducts();
15: 
16: 
17:     /**
18:      * @return the number of test products in the database
19:      */
20:     int numberOfProducts();
21: 
22: 
23:     /**
24:      * @param index
25:      * @return the id of the test product at the given index
26:      */
27:     UUID getProductId( int index );
28: 
29: 
30:     /**
31:      * @param productId - the id of the product in the test data
32:      * @return the index of the test product with that id
33:      */
34:     int findProductIndex( UUID productId );
35: 
36: 
37:     /**
38:      * @param index
39:      * @return the buying price of test product at the given index
40:      */
41:     MoneyType getBuyingPrice( int index );
42: 
43: 
44:     /**
45:      * @param index
46:      * @return the sales price of test product at the given index
47:      */
48:     MoneyType getSalesPrice( int index );
49: }
50: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.usecases.*;
6: 
7: /**
8:  * Removes everything :-)
9:  */
10: @Service
11: public class Purgatory {
12:     @Autowired
13:     private UserRegistrationUseCases userRegistrationUseCases;
14:     @Autowired
15:     private ShoppingCartUseCases shoppingCartUseCases;
16:     @Autowired
17:     private PurchaseUseCases purchaseUseCases;
18:     @Autowired
19:     private ProductCatalogUseCases productCatalogUseCases;
20:     @Autowired
21:     private StorageUnitUseCases storageUnitUseCases;
22: 
23:     public void deleteEverything() {
24:         purchaseUseCases.deleteAllPurchases();
25:         shoppingCartUseCases.emptyAllShoppingCarts();
26:         storageUnitUseCases.deleteAllStorageUnits();
27:         userRegistrationUseCases.deleteAllUsers();
28:         productCatalogUseCases.deleteProductCatalog();
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.context.ApplicationListener;
6: import org.springframework.context.annotation.Profile;
7: import org.springframework.context.event.ContextRefreshedEvent;
8: import org.springframework.stereotype.Component;
9: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
12: 
13: @Component
14: @Slf4j
15: @Profile("!test")
16: @SuppressWarnings("PMD")
17: public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
18:     private Purgatory purgatory;
19:     private UserTestHelper userTestHelper;
20:     private ProductTestHelper productTestHelper;
21:     private StorageUnitTestHelper storageUnitTestHelper;
22: 
23: 
24:     @Autowired
25:     public StartupListener( Purgatory purgatory,
26:                             UserTestHelper userTestHelper,
27:                             ProductTestHelper productTestHelper,
28:                             StorageUnitTestHelper storageUnitTestHelper ) {
29:         this.purgatory = purgatory;
30:         this.userTestHelper = userTestHelper;
31:         this.productTestHelper = productTestHelper;
32:         this.storageUnitTestHelper = storageUnitTestHelper;
33:     }
34: 
35:     @Override
36:     public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
37:         log.info( "StartupListener initializing master data ..." );
38:         purgatory.deleteEverything();
39:         userTestHelper.registerAllUsers();
40:         productTestHelper.addAllProducts();
41:         storageUnitTestHelper.addAllStorageUnits( true );
42:     }
43: }
44: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StorageUnitTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import java.util.UUID;
4: 
5: public interface StorageUnitTestHelper {
6:     /**
7:      * Adds the test storage units to the system.
8:      * If you want to use the storage units, or want to know which index the storage unit has that you see
9:      * in the debugger, the following rules apply:
10:      * - The storage unit name will equal the street name of the physical address of the storage unit.
11:      * - The index number is visible in the house number. Example: storage unit 3 is located at
12:      *   "Ablageweg 3", and that is also its name.
13:      *
14:      *  The storage units are used in the tests as follows:
15:      *  - storage unit 0 holds all products 0 - 6, and is used for all tests where it is not relevant
16:      *    to split one shopping cart into several purchases.
17:      *  - storage units 1 - 3 are used for the proximity tests, where you can deliver product 7 to
18:      *    to a user from the closest storage unit.
19:      *  - storage units 4 - 8 are used for the tests where you need to deliver products 8 - 14 in
20:      *    the most cost-efficient way, as multiple shipments.
21:      *  - storage unit 9 is empty.
22:      *
23:      *  If withStock is true, then the storage units are filled with products. This happens
24:      *  according to the following rules:
25:      *  - products 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
26:      *    ONLY available in storage unit 0. (This means that product 0 out of stock everywhere.)
27:      *  - products 4, 5, 6 have a random stock between 30 and 130, also all ONLY in storage unit 0
28:           (these are the products used for tests on how to add and remove stock)
29:      *  - product 7 has a random stock between 30 and 130, distributed over
30:      *    storage units 1, 2, and 3. You can use this to test if the appropriate storage unit is found
31:      *    for a shopping cart with only product 7 in it, but with different quantities (<= 3, or > 3).
32:      *  - The other products (8 - 14) have also a random stock between 30 and 130, all distributed
33:      *    over several storage units. The distribution is done as follows:
34:      *    Assume that the product is available in <n> storage units. Then the first <n-1> storage units
35:      *    in the list (in ascending sequence) contain 3, and all the remaining stock is in the
36:      *    last storage unit.
37:      *
38:      *    This is how the stock of products could be distributed
39:      *    (Wx = storage unit x with its zip code, Px = product x,
40:      *    numbers marked with (*) are random large numbers):
41:      *
42:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
43:      *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
44:      *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
45:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
46:      *    | P0   |      |     |     |      |     |      |     |       |      |     |
47:      *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
48:      *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
49:      *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
50:      *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
51:      *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
52:      *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
53:      *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
54:      *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
55:      *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
56:      *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
57:      *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
58:      *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
59:      *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
60:      *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
61:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
62:      *
63:      * @param withStock if true, the stock of the products is added to the storage unit. Otherwise, the
64:      *                           the stock is not added and the storage unit is empty.
65:      */
66:     public void addAllStorageUnits( boolean withStock );
67: 
68: 
69:     /**
70:      * @return the number of test storage units in the database
71:      */
72:     int numberOfStorageUnits();
73: 
74: 
75:     /**
76:      * @param index
77:      * @return the id of the test storage unit at the given index
78:      */
79:     UUID getStorageUnitId( int index );
80: 
81: 
82:     /**
83:      * @param storageUnitId - the id of the storage unit in the test data
84:      * @return the index of the test storage unit with that id
85:      */
86:     int findStorageUnitIndex( UUID storageUnitId );
87: 
88: 
89:     /**
90:      * @param productIndex - the index of the product in the test data
91:      * @param storageUnitIndex - the index of the storage unit in the test data
92:      * @return the number of products (stock) available in the storage unit at the given index
93:      */
94:     Integer getStorageUnitStock( int storageUnitIndex, int productIndex );
95: 
96: }
97: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\UserTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: 
4: import thkoeln.archilab.ecommerce.usecases.UserType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
7: 
8: /**
9:  * This is a test helper interface provides access to predefined test data for
10:  * users.
11:  */
12: public interface UserTestHelper {
13:     /**
14:      * This method calls the use case implementation to register all users specified in the
15:      * test data set.
16:      * If you use the debugger and want to identify _which_ test user you currently look at:
17:      * The indices are coded into the house number (in the user's physical address) and in the first
18:      * cipher of the zip code. This is the list of users:
19:      *
20:      * +-------+-------------------+--------+---------------------
21:      * | Index | Name              | PLZ    | Email
22:      * +-------+-------------------+--------+---------------------
23:      * | 0     | Max Mueller       | 02314  | 99Z@example.com
24:      * | 1     | Sophie Schmitz    | 02368  | a@4.com
25:      * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
26:      * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
27:      * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
28:      * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
29:      * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
30:      * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
31:      * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
32:      * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
33:      * +-------+-------------------+--------+---------------------
34:      */
35:     void registerAllUsers();
36: 
37: 
38:     /**
39:      * @return the number of test users in the test data set.
40:      */
41:     int getNumberOfUsers();
42: 
43: 
44:     /**
45:      * @param index the index of the user in the test data set.
46:      * @return the name of the test user with the given index.
47:      */
48:     String getUserName( int index );
49: 
50: 
51:     /**
52:      * @param index the index of the user in the test data set.
53:      * @return the email of the test user with the given index.
54:      */
55:     EmailType getUserEmail( int index );
56: 
57: 
58:     /**
59:      * @param index the index of the user in the test data set.
60:      * @return the physical address of the test user with the given index.
61:      */
62:     PhysicalAddressType getUserPhysicalAddress( int index );
63: 
64: 
65:     /**
66:      * @param index the index of the user in the test data set.
67:      * @return the test user with the given index.
68:      */
69:     UserType getUser( int index );
70: 
71: }
72: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\ProductCatalogUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, CIDE Institute, TH Köln
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: 
10: import java.util.UUID;
11: 
12: 
13: /**
14:  * This interface contains methods needed in the context of use cases concerning the product catalog.
15:  * The interface is probably incomplete, and will grow over time ...
16:  */
17: 
18: public interface ProductCatalogUseCases {
19:     /**
20:      * Adds a new product to the shop catalog
21:      * @param name
22:      * @param descriptionOf
23:      * @param size
24:      * @param buyingPrice
25:      * @param salesPrice
26:      * @return the id of the new product
27:      * @throws ShopException if ...
28:      *      - the product id already exists,
29:      *      - name or description are null or empty,
30:      *      - the size is <= 0 (but can be null!),
31:      *      - the buying price is null or <= 0,
32:      *      - the buyingPrice is null,
33:      *      - the sales price is null,
34:      *      - the sales price is lower than the buyingPrice
35:      */
36:     public UUID addProductToCatalog( String name, String descriptionOf, Float size,
37:                                            MoneyType buyingPrice, MoneyType salesPrice );
38: 
39: 
40:     /**
41:      * Removes a product from the shop catalog
42:      * @param productId
43:      * @throws ShopException if
44:      *      - productId is null
45:      *      - the product id does not exist
46:      *      - the product is still in stock
47:      *      - the product is still in a shopping cart, or referenced by a completed purchase
48:      */
49:     public void removeProductFromCatalog( UUID productId );
50: 
51: 
52:     /**
53:      * Get the sales price of a given product
54:      * @param productId
55:      * @return the sales price
56:      * @throws ShopException if ...
57:      *      - productId is null,
58:      *      - the product with that id does not exist
59:      */
60:     public MoneyType getSalesPrice( UUID productId );
61: 
62: 
63:     /**
64:      * Clears the product catalog, i.e. removes all products from the catalog, including all the stock,
65:      * all the reservations and all the purchases.
66:      */
67:     public void deleteProductCatalog();
68: 
69: }
70: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\PurchaseUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, CIDE Institute, TH Köln
3:  */
4: package thkoeln.archilab.ecommerce.usecases;
5: 
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
9: 
10: import java.util.Map;
11: import java.util.UUID;
12: 
13: /**
14:  * This interface contains methods needed in the context of the purchase history of a user.
15:  */
16: public interface PurchaseUseCases {
17: 
18:     /**
19:      * Returns a map showing which products have been purchased by a user and how many of each product
20:      *
21:      * @param userEmail
22:      * @return the purchase history of the user (map is empty if the user has not purchased anything yet)
23:      * @throws ShopException if
24:      *      - userEmail is null
25:      *      - the user with the given email does not exist
26:      */
27:     public Map<UUID, Integer> getPurchaseHistory( EmailType userEmail );
28: 
29: 
30: 
31:     /**
32:      * @return the number of products in a given purchase. If the product is not a part of the purchase, the method
33:      *         returns 0. No exception is thrown.
34:      * @param purchaseId - the id of the purchase to be checked
35:      * @param productId - the id of the product for which we want to know the quantity
36:      * @throws ShopException if
37:      *     - purchaseId is null, or doesn't exist in the system
38:      *     - productId is null, or doesn't exist in the system
39:      */
40:     public Integer getPurchaseQuantityOfProduct( UUID purchaseId, UUID productId );
41: 
42: 
43:     /**
44:      * @return the id of the storage unit that is responsible for the given purchase
45:      * @param purchaseId - the id of the purchase to be checked
46:      * @throws ShopException if
47:      *      - purchaseId is null, or doesn't exist in the system
48:      */
49:     public UUID getStorageUnitIdForPurchase( UUID purchaseId );
50: 
51: 
52:     /**
53:      * Deletes all purchases in the system
54:      */
55:     public void deleteAllPurchases();
56: }
57: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingCartUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, CIDE Institute, TH Köln
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
10: 
11: import java.util.Map;
12: import java.util.Set;
13: import java.util.UUID;
14: 
15: /**
16:  * This interface contains methods needed in the context of use cases handling the shopping cart.
17:  * The interface is probably incomplete, and will grow over time ...
18:  */
19: public interface ShoppingCartUseCases {
20:     /**
21:      * Adds a product to the cart of a user
22:      *
23:      * @param userEmail
24:      * @param productId
25:      * @param quantityOf
26:      * @throws ShopException if ...
27:      *          - userEmail is null,
28:      *          - the user with the given email does not exist,
29:      *          - productId is null,
30:      *          - the product with productId does not exist
31:      *          - the Quantity is negative,
32:      */
33:     public void addProductToShoppingCart( EmailType userEmail,
34:                                                  UUID productId, int quantityOf );
35: 
36: 
37:     /**
38:      * Removes a product from the cart of a user
39:      *
40:      * @param userEmail
41:      * @param productId
42:      * @param quantityOf
43:      * @throws ShopException if ...
44:      *          - userEmail is null,
45:      *          - the user with the given email does not exist,
46:      *          - productId is null,
47:      *          - the product with productId does not exist
48:      *          - the Quantity is negative
49:      *          - the product is not in the shopping cart in the requested Quantity
50:      */
51:     public void removeProductFromShoppingCart( EmailType userEmail,
52:                                                       UUID productId, int quantityOf );
53: 
54: 
55:     /**
56:      * Returns a map showing which products are in the cart of a user and how many of each product
57:      *
58:      * @param userEmail
59:      * @return the cart of the user (map is empty if the cart is empty)
60:      * @throws ShopException if
61:      *          - userEmail is null,
62:      *          - the user with the given email does not exist
63:      */
64:     public Map<UUID, Integer> getShoppingCartAsMap( EmailType userEmail );
65: 
66: 
67:     /**
68:      * Returns the current value of all products in the cart of a user
69:      *
70:      * @param userEmail
71:      * @return the cart of the user
72:      * @throws ShopException if
73:      *          - userEmail is null,
74:      *          - the user with the given email does not exist
75:      */
76:     public MoneyType getShoppingCartAsMoneyValue( EmailType userEmail );
77: 
78: 
79: 
80: 
81:     /**
82:      * Checks out the cart of a user
83:      *
84:      * @param userEmail
85:      * @return A set of ids belonging to purchases that were created during the checkout. If the shopping cart can
86:      *         only be served from more than one storage unit, each shipment from a storage unit gets a
87:      *         dedicated purchase. I.e. if there is just one shipment, then the set will contain just one purchase id.
88:      *         If there are multiple shipments, the set will contain multiple purchase ids.
89:      * @throws ShopException if
90:      *      - userEmail is null or empty
91:      *      - the user with the given email does not exist, or if the cart is empty
92:      * @throws
93:      *      - ShopException if userEmail is null
94:      *      - InsufficientStockException if there is not enough stock level for to serve the purchase
95:      *        for all products in the shopping cart
96:      */
97:     public Set<UUID> checkout( EmailType userEmail );
98: 
99: 
100:     /**
101:      * Empties all shopping carts in the system
102:      */
103:     public void emptyAllShoppingCarts();
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\StorageUnitUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, CIDE Institute, TH Köln
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
9: 
10: import java.util.UUID;
11: 
12: /**
13:  * This interface contains methods needed in the context of handling the shop stock,
14:  * i.e. managing storage units, and adding / removing products in the storage unit.
15:  */
16: public interface StorageUnitUseCases {
17:     /**
18:      *
19:      * @param name
20:      * @param physicalAddress
21:      * @return the id of the new storage unit
22:      * @throws ShopException if ...
23:      *      - name is null or empty
24:      *      - physicalAddress is null
25:      */
26:     public UUID addNewStorageUnit( String name, PhysicalAddressType physicalAddress );
27: 
28: 
29:     /**
30:      * Deletes all storage units from the shop. Intended for testing purposes.
31:      */
32:     public void deleteAllStorageUnits();
33: 
34: 
35:     /**
36:      * Adds a certain Quantity of a given product to the stock
37:      * @param storageUnitId
38:      * @param productId
39:      * @param addedQuantityOf
40:      * @throws ShopException if ...
41:      *      - storageUnitId is null
42:      *      - the storage unit with that id does not exist
43:      *      - productId is null
44:      *      - the product with that id does not exist
45:      *      - addedQuantityOf < 0
46:      */
47:     public void addToStock( UUID storageUnitId, UUID productId, int addedQuantityOf );
48: 
49: 
50:     /**
51:      * Removes a certain Quantity of a given product from the stock.
52:      * @param storageUnitId
53:      * @param productId
54:      * @param removedQuantityOf
55:      * @throws ShopException if ...
56:      *      - storageUnitId is null
57:      *      - the storage unit with that id does not exist
58:      *      - productId is null
59:      *      - the product with that id does not exist
60:      *      - removedQuantityOf < 0
61:      */
62:     public void removeFromStock( UUID storageUnitId, UUID productId, int removedQuantityOf );
63: 
64: 
65:     /**
66:      * Changes the total Quantity of a given product in the stock.
67:      * @param storageUnitId
68:      * @param productId
69:      * @param newTotalQuantityOf
70:      * @throws ShopException if ...
71:      *      - storageUnitId is null
72:      *      - the storage unit with that id does not exist
73:      *      - productId is null
74:      *      - the product with that id does not exist
75:      *      - newTotalQuantityOf < 0
76:      */
77:     public void changeStockTo( UUID storageUnitId, UUID productId, int newTotalQuantityOf );
78: 
79: 
80:     /**
81:      * Get the current stock of a given product in one specific storage unit.
82:      * @param storageUnitId
83:      * @param productId
84:      * @return the current total stock of the product
85:      * @throws ShopException if ...
86:      *      - storageUnitId is null
87:      *      - the storage unit with that id does not exist
88:      *      - productId is null
89:      *      - the product with that id does not exist
90:      */
91:     public int getAvailableStock( UUID storageUnitId, UUID productId );
92: 
93: 
94: }
95: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\UserRegistrationUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, CIDE Institute, TH Köln
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: 
11: /**
12:  * This interface contains methods needed in the context of use cases concerning the registration of a user.
13:  * The interface is probably incomplete, and will grow over time ...
14:  */
15: public interface UserRegistrationUseCases {
16:     /**
17:      * Registers a new user
18:      *
19:      * @param name
20:      * @param email
21:      * @param physicalAddress
22:      * @throws ShopException if ...
23:      *      - the user with the given email already exists
24:      *      - physicalAddress is null
25:      */
26:     public void register( String name, EmailType email, PhysicalAddressType physicalAddress );
27: 
28: 
29:     /**
30:      * Changes the address of a user
31:      *
32:      * @param userEmail
33:      * @param userEmail
34:      * @param physicalAddress
35:      * @throws ShopException if ...
36:      *      - the user with the given email does not exist,
37:      *      - physicalAddress is null
38:      */
39:     public void changeAddress( EmailType userEmail,
40:                                PhysicalAddressType physicalAddress );
41: 
42: 
43:     /**
44:      * Returns the data of a user as an array of strings (name, email, street, city, zipCode)
45:      * @param userEmail
46:      * @return the user data
47:      * @throws ShopException the user with the given email does not exist,
48:      */
49:     public UserType getUserData( EmailType userEmail );
50: 
51: 
52: 
53:     /**
54:      * Clears all users, including all purchases and shopping carts
55:      */
56:     public void deleteAllUsers();
57: }
58: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\main\java\thkoeln\archilab\ecommerce\usecases\UserType.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
5: 
6: /**
7:  * This interface expresses the essence of a shop user
8:  */
9: public interface UserType {
10:     String getName();
11:     EmailType getEmail();
12:     PhysicalAddressType getPhysicalAddress();
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import org.springframework.boot.test.context.TestConfiguration;
4: import org.springframework.context.annotation.Bean;
5: import org.springframework.test.web.servlet.MockMvc;
6: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
7: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
8: 
9: 
10: @TestConfiguration
11: public class RESTTestHelperConfiguration {
12: 
13:     @Bean
14:     public ShoppingCartRESTHelper shoppingCartRESTHelper(
15:             MockMvc mockMvc, ProductCatalogUseCases productCatalogUseCases ) {
16:         return new ShoppingCartRESTHelperImpl( mockMvc, productCatalogUseCases );
17:     }
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingCartRESTHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import com.fasterxml.jackson.databind.ObjectMapper;
5: import lombok.AllArgsConstructor;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import lombok.Setter;
9: import lombok.extern.slf4j.Slf4j;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.MvcResult;
12: import org.springframework.test.web.servlet.ResultActions;
13: import org.springframework.test.web.servlet.ResultMatcher;
14: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
15: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
18: 
19: import java.util.Map;
20: import java.util.UUID;
21: 
22: import static org.springframework.http.MediaType.APPLICATION_JSON;
23: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
24: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
25: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
26: 
27: @Slf4j
28: public class ShoppingCartRESTHelperImpl implements ShoppingCartRESTHelper {
29:     private MockMvc mockMvc;
30:     private ProductCatalogUseCases productCatalogUseCases;
31: 
32:     private static final ResultMatcher CREATED = status().isCreated();
33:     private static final ResultMatcher OK = status().isOk();
34: 
35:     public ShoppingCartRESTHelperImpl( MockMvc mockMvc, ProductCatalogUseCases productCatalogUseCases ) {
36:         this.mockMvc = mockMvc;
37:         this.productCatalogUseCases = productCatalogUseCases;
38:     }
39: 
40: 
41:     @Override
42:     public UUID getQueryShoppingCart( EmailType email, Map<UUID, Integer> quantityMap )
43:             throws Exception {
44:         // first query the users API to get the proper userId
45:         UUID userId;
46:         String userUri = "/users?email=" + email.toString();
47:         MvcResult userGetResult = mockMvc.perform( get( userUri ) )
48:                 .andExpect( status().isOk() )
49:                 .andReturn();
50:         ObjectMapper objectMapper = new ObjectMapper();
51:         IdDTO idDTO = objectMapper.readValue( userGetResult.getResponse().getContentAsString(), IdDTO.class );
52:         userId = idDTO.getId();
53: 
54:         // then query the shopping cart API and extract the shopping cart id
55:         String shoppingCartUri = "/shoppingCarts?userId=" + userId.toString();
56:         ResultActions resultActions = mockMvc.perform( get( shoppingCartUri ) )
57:                 .andExpect( status().isOk() );
58:         idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
59:         UUID shoppingCartId = idDTO.getId();
60: 
61:         // additional checks, if desired
62:         if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
63:         return shoppingCartId;
64:     }
65: 
66: 
67:     private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
68:         if ( quantityMap == null ) return;
69:         int numOfProducts = quantityMap.size();
70:         resultActions.andExpect( jsonPath( "$.parts.length()" ).value( numOfProducts ) );
71:         float totalSalesPriceAsFloat = 0f;
72:         for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
73:             UUID productId = entry.getKey();
74:             Integer quantity = entry.getValue();
75:             resultActions.andExpect( jsonPath( "$.parts.[?(@.productId == '" + productId + "')].quantity" )
76:                     .value( quantity ) );
77:             MoneyType salesPrice = productCatalogUseCases.getSalesPrice( productId );
78:             totalSalesPriceAsFloat += salesPrice.getAmount() * quantity;
79:         }
80:         // last thing - check the total sales price
81:         String totalSalesPriceString = String.format( "%.2f €", totalSalesPriceAsFloat );
82:         resultActions
83:                 .andExpect( jsonPath( "$.totalSalesPrice" ).value( totalSalesPriceString ) );
84:     }
85: 
86: 
87:     @Override
88:     public void addProductToShoppingCart( UUID shoppingCartId, UUID productId, Integer quantity )
89:             throws Exception {
90:         addProductToShoppingCart( shoppingCartId, productId, quantity, null );
91:     }
92: 
93: 
94:     @Override
95:     public void addProductToShoppingCart( UUID shoppingCartId, UUID productId, Integer quantity,
96:                                                   ResultMatcher expectedStatus ) throws Exception {
97:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
98:         ObjectMapper objectMapper = new ObjectMapper();
99:         QuantityDTO dto = new QuantityDTO( productId, quantity );
100:         String quantityJson = objectMapper.writeValueAsString( dto );
101:         mockMvc.perform( post( "/shoppingCarts/" + shoppingCartId + "/parts" )
102:                         .contentType( APPLICATION_JSON ).content( quantityJson ) )
103:                 .andExpect( status );
104:     }
105: 
106: 
107: 
108:     @Override
109:     public void deleteProductFromShoppingCart( UUID shoppingCartId, UUID productId )
110:             throws Exception {
111:         deleteProductFromShoppingCart( shoppingCartId, productId, null );
112:     }
113: 
114: 
115: 
116:     @Override
117:     public void deleteProductFromShoppingCart( UUID shoppingCartId, UUID productId,
118:                                                       ResultMatcher expectedStatus ) throws Exception {
119:         ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
120:         String uri = "/shoppingCarts/" + shoppingCartId + "/parts/" + productId;
121:         mockMvc.perform( delete( uri ) ).andExpect( status );
122:     }
123: 
124: 
125:     @Override
126:     public void checkout( UUID shoppingCartId, String expectedUserName,
127:                           ResultMatcher expectedStatus,
128:                           Map<UUID, Map<UUID, Integer>> expectedPurchases ) throws Exception {
129:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
130:         String uri = "/shoppingCarts/" + shoppingCartId + "/checkout";
131:         MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
132:         ObjectMapper objectMapper = new ObjectMapper();
133: 
134:         // check the response content
135:         if ( expectedPurchases != null || expectedUserName != null ) {
136:             String responseContent = result.getResponse().getContentAsString();
137:             log.info( "ShoppingCartRESTHelperImpl - checkout: found response content " + responseContent );
138:             PurchaseDTO[] purchases = objectMapper.readValue( responseContent, PurchaseDTO[].class );
139:             checkExpectedUserName( expectedUserName, purchases );
140:             checkExpectedPurchases( expectedPurchases, purchases );
141:         }
142:     }
143: 
144: 
145:     private void checkExpectedUserName( String expectedUserName, PurchaseDTO[] purchases ) {
146:         if ( expectedUserName == null ) return;
147:         for ( PurchaseDTO purchase : purchases ) {
148:             if ( !purchase.getUserName().equals( expectedUserName ) ) {
149:                 throw new AssertionError( "Expected userName '" + expectedUserName +
150:                         "' but got '" + purchase.getUserName() + "'" );
151:             }
152:         }
153:     }
154: 
155: 
156:     private void checkExpectedPurchases( Map<UUID, Map<UUID, Integer>> expectedPurchases,
157:                                             PurchaseDTO[] purchases ) {
158:         if ( expectedPurchases == null ) return;
159:         for ( PurchaseDTO purchase : purchases ) {
160:             UUID storageUnitId = purchase.getStorageUnitId();
161:             Map<UUID, Integer> expectedQuantities = expectedPurchases.get( storageUnitId );
162:             if ( expectedQuantities == null ) {
163:                 throw new AssertionError( "No expected quantities for storage unit " + storageUnitId );
164:             }
165:             QuantityDTO[] parts = purchase.getParts();
166:             for ( QuantityDTO quantityDTO : parts ) {
167:                 UUID productId = quantityDTO.getProductId();
168:                 Integer expectedQuantity = expectedQuantities.get( productId );
169:                 if ( expectedQuantity == null ) {
170:                     throw new AssertionError( "No expected quantity for product " + productId +
171:                             " in storage unit " + storageUnitId );
172:                 }
173:                 if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
174:                     throw new AssertionError( "Expected quantity " + expectedQuantity + " for product " +
175:                             productId + " in storage unit " + storageUnitId +
176:                             ", but got " + quantityDTO.getQuantity() );
177:                 }
178:             }
179:         }
180:     }
181: 
182: 
183:     /**
184:      * A DTO containing just a quantity, used in testing.
185:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
186:      * Therefore, constructors and getters/setters are manually defined.
187:      */
188:     @NoArgsConstructor
189:     @JsonIgnoreProperties(ignoreUnknown = true)
190:     private static class QuantityDTO {
191:         private UUID productId;
192:         private Integer quantity;
193: 
194:         public QuantityDTO( UUID productId, Integer quantity ) {
195:             this.productId = productId;
196:             this.quantity = quantity;
197:         }
198:         public UUID getProductId() {
199:             return productId;
200:         }
201:         public Integer getQuantity() {
202:             return quantity;
203:         }
204:         public void setProductId( UUID productId ) {
205:             this.productId = productId;
206:         }
207:         public void setQuantity( Integer quantity ) {
208:             this.quantity = quantity;
209:         }
210:     }
211: 
212: 
213:     /**
214:      * A DTO containing just the id of an entity, used in testing.
215:      */
216:     @AllArgsConstructor
217:     @NoArgsConstructor
218:     @Getter
219:     @Setter
220:     @JsonIgnoreProperties(ignoreUnknown = true)
221:     private static class IdDTO {
222:         private UUID id;
223:     }
224: 
225: 
226:     /**
227:      * A DTO containing the purchase data, used in testing.
228:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
229:      * Therefore, constructors and getters/setters are manually defined.
230:      */
231:     @NoArgsConstructor
232:     @JsonIgnoreProperties(ignoreUnknown = true)
233:     private static class PurchaseDTO {
234:         private UUID id;
235:         private String userName;
236:         private UUID storageUnitId;
237:         private QuantityDTO[] parts;
238: 
239:         public UUID getId() {
240:             return id;
241:         }
242:         public String getUserName() {
243:             return userName;
244:         }
245:         public UUID getStorageUnitId() {
246:             return storageUnitId;
247:         }
248:         public QuantityDTO[] getParts() {
249:             return parts;
250:         }
251:         public void setId( UUID id ) {
252:             this.id = id;
253:         }
254:         public void setUserName( String userName ) {
255:             this.userName = userName;
256:         }
257:         public void setStorageUnitId( UUID storageUnitId ) {
258:             this.storageUnitId = storageUnitId;
259:         }
260:         public void setParts( QuantityDTO[] parts ) {
261:             this.parts = parts;
262:         }
263:     }
264: 
265: }
266: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingCartRESTHelper.java ---
1: package thkoeln.archilab.ecommerce.helpers;
2: 
3: import org.springframework.test.web.servlet.ResultMatcher;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
5: 
6: import java.util.Map;
7: import java.util.UUID;
8: 
9: /**
10:  * A REST helper for shopping cart-related operations.
11:  * This interface defines methods to interact with a shopping cart via REST calls, such as querying, adding,
12:  * deleting, and checking out.
13:  */
14: public interface ShoppingCartRESTHelper {
15:     /**
16:      * Executes a REST GET query on a shopping cart and returns its id, with the user's email as a
17:      * starting point. The resulting shopping cart is checked against the given expected quantity map.
18:      * @param email The email of the user whose shopping cart is queried.
19:      * @param expectedQuantityMap A map of products and their quantities in the shopping cart. (If null, then don't check.)
20:      * @return The id of the user's shopping cart.
21:      * @throws Exception (whenever the REST call fails, or the shopping cart does not match the expected quantity map)
22:      */
23:     public UUID getQueryShoppingCart( EmailType email,
24:                                        Map<UUID, Integer> expectedQuantityMap ) throws Exception;
25: 
26: 
27:     /**
28:      * Adds a product to a shopping cart via a REST call.
29:      * @param shoppingCartId Id of the shopping cart.
30:      * @param productId Id of the product.
31:      * @param quantity Quantity of the product.
32:      * @throws Exception (whenever the REST call fails)
33:      */
34:     public void addProductToShoppingCart( UUID shoppingCartId, UUID productId, Integer quantity )
35:             throws Exception;
36: 
37: 
38:     /**
39:      * Adds a product to a shopping cart via a REST call.
40:      * @param shoppingCartId Id of the shopping cart.
41:      * @param productId Id of the product.
42:      * @param quantity Quantity of the product.
43:      * @param expectedStatus expected status of the operation (null = CREATED)
44:      * @throws Exception (whenever the REST call fails or the status does not match)
45:      */
46:     public void addProductToShoppingCart( UUID shoppingCartId, UUID productId, Integer quantity,
47:                                                   ResultMatcher expectedStatus ) throws Exception;
48: 
49: 
50:     /**
51:      * Deletes a product from a shopping cart via a REST call.
52:      * @param shoppingCartId Id of the shopping cart.
53:      * @param productId Id of the product.
54:      * @throws Exception (whenever the REST call fails)
55:      */
56:     public void deleteProductFromShoppingCart( UUID shoppingCartId, UUID productId )
57:             throws Exception;
58: 
59: 
60:     /**
61:      * Deletes a product from a shopping cart via a REST call.
62:      * @param shoppingCartId Id of the shopping cart.
63:      * @param productId Id of the product.
64:      * @param expectedStatus expected status of the operation (null = OK)
65:      * @throws Exception (whenever the REST call fails or the status does not match)
66:      */
67:     public void deleteProductFromShoppingCart( UUID shoppingCartId, UUID productId,
68:                                                       ResultMatcher expectedStatus ) throws Exception;
69: 
70: 
71:     /**
72:      * Checks out a shopping cart via REST call, and returns the id of the created purchase.
73:      * @param shoppingCartId
74:      * @param expectedUserName expected name of the user who owns the shopping cart (null = don't check)
75:      * @param expectedStatus expected status of the operation (null = don't check)
76:      * @param expectedPurchases the expected purchases to be created as a result of the checkout. This is
77:      *                            a map of the following form:
78:      *                            <pre>
79:      *                               storageUnitId -> Map<productId,Integer>
80:      *                            </pre>
81:      *                            where the inner map contains the products and their quantities
82:      * @return
83:      * @throws Exception
84:      */
85:     public void checkout( UUID shoppingCartId, String expectedUserName,
86:                           ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedPurchases )
87:            throws Exception;
88: }
89: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class BasicNoOutsideSolutionRulesTest {
14: 
15:     @ArchTest
16:     static final ArchRule noClassesOnTopLevel =
17:             classes().should().resideInAPackage( "..solution.*.." )
18:                     .allowEmptyShould( true );
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.library.Architectures.layeredArchitecture;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln")
12: @SuppressWarnings("PMD")
13: public class BasicProperDependenciesTest {
14: 
15:     @ArchTest
16:     static final ArchRule properDependencies =
17:             layeredArchitecture()
18:                     .consideringAllDependencies()
19:                     //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
20:                     .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
21:                     .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )
22: 
23:                     //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
24:                     .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
25:                     .allowEmptyShould( true );
26: }
27: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
5: import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
6: import org.springframework.core.type.classreading.MetadataReader;
7: import org.springframework.core.type.classreading.MetadataReaderFactory;
8: 
9: import java.io.IOException;
10: import java.util.Arrays;
11: import java.util.HashSet;
12: import java.util.Set;
13: 
14: import static org.junit.jupiter.api.Assertions.assertTrue;
15: 
16: public class BasicRequiredClassesTest {
17:     private static final String[] REQUIRED_CLASSES = {
18:             "User",
19:             "UserRepository",
20:             "Product",
21:             "ProductRepository",
22:             "Purchase",
23:             "PurchaseRepository",
24:             "StockLevel",
25:             "ShoppingCart",
26:             "ShoppingCartRepository",
27:             "StorageUnitRepository",
28:             "ShoppingCartPart",
29:             "PurchasePart",
30:             "StorageUnit",
31:     };
32: 
33:     @Test
34:     public void testRequiredClassesDeclared() throws IOException {
35:         String basePackage = "thkoeln.archilab.ecommerce";
36:         String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";
37: 
38:         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
39:         MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );
40: 
41:         Set<String> foundClasses = new HashSet<>();
42: 
43:         Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
44:             try {
45:                 MetadataReader reader = readerFactory.getMetadataReader( resource );
46:                 foundClasses.add( reader.getClassMetadata().getClassName() );
47:             } catch (IOException e) {
48:                 e.printStackTrace();
49:             }
50:         } );
51: 
52:         Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
53:             boolean found = foundClasses.stream().anyMatch(className ->
54:                     className.startsWith(basePackage) && className.endsWith("." + requiredClass)
55:             );
56:             assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
57:         });
58:     }
59: }
60: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.boot.test.context.SpringBootTest;
6: import org.springframework.context.ApplicationContext;
7: 
8: import java.util.Arrays;
9: import java.util.HashMap;
10: import java.util.List;
11: import java.util.Map;
12: 
13: import static org.junit.jupiter.api.Assertions.*;
14: 
15: @SpringBootTest
16: public class BasicUseCaseImplementationPackageTest {
17: 
18:     @Autowired
19:     private ApplicationContext applicationContext;
20: 
21:     private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
22:         put("UserRegistrationUseCases", Arrays.asList("user"));
23:         put("StorageUnitUseCases", Arrays.asList("storageunit"));
24:         put("ProductCatalogUseCases", Arrays.asList("product"));
25:         put("ShoppingCartUseCases", Arrays.asList("shoppingcart"));
26:         put("PurchaseUseCases", Arrays.asList("purchase"));
27:     }};
28:     private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
29:     private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";
30: 
31:     @Test
32:     public void testRequiredClassesDeclared() {
33:         for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
34:             String interfaceName = USECASE_PATH + "." + entry.getKey();
35:             List<String> correctTopLevelPackages = entry.getValue();
36:             Class<?> useCaseInterfaceClass = null;
37:             try {
38:                 useCaseInterfaceClass = Class.forName( interfaceName );
39:             } catch (ClassNotFoundException e) {
40:                 fail( "Use case interface " + interfaceName + " not found.", e );
41:                 continue;
42:             }
43:             String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
44:             assertEquals( 1, beans.length,
45:                     "There should be exactly 1 service implementation for the interface " +
46:                             entry.getKey() + ", but found " + beans.length );
47:             Object bean = applicationContext.getBean( beans[0] );
48:             boolean isValid = false;
49:             for ( String correctTopLevelPackage : correctTopLevelPackages ) {
50:                 String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
51:                 if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
52:                     isValid = true;
53:                     break;
54:                 }
55:             }
56:             assertTrue( isValid,
57:                     "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
58:                             + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
59:         }
60:     }
61: }
62: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: import org.springframework.data.repository.CrudRepository;
8: import org.springframework.stereotype.Service;
9: 
10: import jakarta.persistence.Entity;
11: import org.springframework.web.bind.annotation.RestController;
12: 
13: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
14: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
15: 
16: @ArchTag("layerRules")
17: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
18: @SuppressWarnings("PMD")
19: public class DDDRulesTest {
20: 
21:     @ArchTest
22:     static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
23:             noClasses().that().resideInAPackage( "..domain.." )
24:                     .should().dependOnClassesThat().resideInAPackage( "..application.." )
25:                     .allowEmptyShould( true );
26: 
27:     @ArchTest
28:     static final ArchRule entitiesMustResideInADomainPackage =
29:             classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
30:                     .as( "Entities must reside in a package '..domain..'" )
31:                     .allowEmptyShould( true );
32: 
33:     @ArchTest
34:     static final ArchRule entitiesMustNotAccessRepositories =
35:             noClasses().that().areAnnotatedWith( Entity.class )
36:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
37:                     .allowEmptyShould( true );
38: 
39:     @ArchTest
40:     static final ArchRule repositoriesMustResideInADomainPackage =
41:             classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
42:                     .as( "Repositories must reside in a package '..domain..'" )
43:                     .allowEmptyShould( true );
44: 
45:     @ArchTest
46:     static final ArchRule repositoryNamesMustHaveProperSuffix =
47:             classes().that().areAssignableTo( CrudRepository.class )
48:                     .should().haveSimpleNameEndingWith( "Repository" )
49:                     .allowEmptyShould( true );
50: 
51:     @ArchTest
52:     static final ArchRule servicesMustResideInAnApplicationPackage =
53:             classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
54:                     .as( "Application Services must reside in a package '..application..'" )
55:                     .allowEmptyShould( true );
56: 
57:     @ArchTest
58:     static final ArchRule serviceNamesMustHaveProperSuffix =
59:             classes().that().areAnnotatedWith( Service.class )
60:                     .should().haveSimpleNameEndingWith( "Service" )
61:                     .allowEmptyShould( true );
62: 
63:     @ArchTest
64:     static final ArchRule controllersMustResideInAnApplicationPackage =
65:             classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
66:                     .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );
67: 
68:     @ArchTest
69:     static final ArchRule controllersNamesMustHaveProperSuffix =
70:             classes().that().areAnnotatedWith( RestController.class )
71:                     .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );
72: 
73:     @ArchTest
74:     static final ArchRule controllersMustNotAccessRepositories =
75:             noClasses().that().areAnnotatedWith( RestController.class )
76:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
77:                     .allowEmptyShould( false );
78: }
79: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.importer.ClassFileImporter;
6: import com.tngtech.archunit.lang.ArchRule;
7: import com.tngtech.archunit.library.dependencies.SliceAssignment;
8: import com.tngtech.archunit.library.dependencies.SliceIdentifier;
9: import org.junit.jupiter.api.Test;
10: 
11: import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
12: 
13: public class NoCycleTest {
14:     private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");
15: 
16:     private SliceAssignment inAllClasses() {
17:         return new SliceAssignment() {
18:             @Override
19:             public String getDescription() {
20:                 return "every class in it's own slice";
21:             }
22: 
23:             @Override
24:             public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
25:                 return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
26:             }
27:         };
28:     }
29: 
30:     @Test
31:     public void testNoCyclicDependenciesBetweenClasses() {
32:         slices().assignedFrom(inAllClasses())
33:                 .namingSlices("$1[$2.$3]")
34:                 .should().beFreeOfCycles()
35:                 .check(importedClasses);
36:     }
37: 
38:     @Test
39:     public void testNoCyclicDependenciesBetweenPackages() {
40:         ArchRule rule = slices().matching("..solution.(*)..")
41:                 .should().beFreeOfCycles().allowEmptyShould( true );
42:         rule.check(importedClasses);
43:     }
44: }
45: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.base.DescribedPredicate;
4: import com.tngtech.archunit.core.domain.JavaClass;
5: import com.tngtech.archunit.core.domain.JavaField;
6: import com.tngtech.archunit.core.domain.JavaParameterizedType;
7: import com.tngtech.archunit.core.domain.JavaType;
8: import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
9: import com.tngtech.archunit.junit.AnalyzeClasses;
10: import com.tngtech.archunit.junit.ArchTag;
11: import com.tngtech.archunit.junit.ArchTest;
12: import com.tngtech.archunit.lang.ArchCondition;
13: import com.tngtech.archunit.lang.ArchRule;
14: import com.tngtech.archunit.lang.ConditionEvents;
15: import com.tngtech.archunit.lang.SimpleConditionEvent;
16: import jakarta.persistence.*;
17: import lombok.extern.slf4j.Slf4j;
18: import thkoeln.archilab.ecommerce.GenericId;
19: 
20: import java.util.List;
21: 
22: import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
23: import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
24: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;
25: 
26: @ArchTag("layerRules")
27: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
28: @SuppressWarnings("PMD")
29: @Slf4j
30: public class OnlyReferenceViaIDTest { //STORAGE_UNIT
31:     private static final String SHOPPING_CART_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingcart.domain";
32:     private static final String USER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.user.domain";
33:     private static final String PRODUCT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.product.domain";
34:     private static final String PURCHASE_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.purchase.domain";
35:     private static final String STORAGE_UNIT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.storageunit.domain";
36: 
37:     @ArchTest
38:     static final ArchRule idFieldsMustUseGenericId =
39:             fields()
40:                     .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
41:                     .and().areAnnotatedWith( Id.class )
42:                     .should().haveRawType( assignableTo( GenericId.class ) )
43:                     .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
44:                     .allowEmptyShould( true );
45: 
46: 
47:     private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
48:             annotatedWith( ManyToOne.class )
49:                     .or( annotatedWith( OneToOne.class ) )
50:                     .or( annotatedWith( Embedded.class ) )
51:                     .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );
52: 
53:     private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
54:             annotatedWith( OneToMany.class )
55:                     .or( annotatedWith( ManyToMany.class ) )
56:                     .or( annotatedWith( ElementCollection.class ) )
57:                     .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );
58: 
59: 
60:     private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
61:         String description = "an entity or value object from same aggregate, or a domain primitive";
62:         return new DescribedPredicate<>( description ) {
63:             @Override
64:             public boolean test( JavaClass type ) {
65:                 // check if the class is an entity or value object, and resides in the allowed package
66:                 if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
67:                     return false;
68:                 }
69:                 // a GenericId is always allowed
70:                 if ( type.isAssignableTo( GenericId.class ) ) {
71:                     return true;
72:                 }
73:                 // a domain primitive is also always allowed
74:                 if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
75:                     return true;
76:                 }
77:                 return type.getPackageName().startsWith( allowedPackage );
78:             }
79:         };
80:     }
81: 
82: 
83:     @ArchTest
84:     static final ArchRule shoppingCartToOneReferences =
85:             fields()
86:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_CART_DOMAIN_PACKAGE )
87:                     .and( isToOneAnnotation )
88:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_CART_DOMAIN_PACKAGE ) ) )
89:                     .allowEmptyShould( true );
90: 
91:     @ArchTest
92:     static final ArchRule userToOneReferences =
93:             fields()
94:                     .that().areDeclaredInClassesThat().resideInAPackage( USER_DOMAIN_PACKAGE )
95:                     .and( isToOneAnnotation )
96:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( USER_DOMAIN_PACKAGE ) ) )
97:                     .allowEmptyShould( true );
98: 
99:     @ArchTest
100:     static final ArchRule productToOneReferences =
101:             fields()
102:                     .that().areDeclaredInClassesThat().resideInAPackage( PRODUCT_DOMAIN_PACKAGE )
103:                     .and( isToOneAnnotation )
104:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( PRODUCT_DOMAIN_PACKAGE ) ) )
105:                     .allowEmptyShould( true );
106: 
107:     @ArchTest
108:     static final ArchRule purchaseToOneReferences =
109:             fields()
110:                     .that().areDeclaredInClassesThat().resideInAPackage( PURCHASE_DOMAIN_PACKAGE )
111:                     .and( isToOneAnnotation )
112:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( PURCHASE_DOMAIN_PACKAGE ) ) )
113:                     .allowEmptyShould( true );
114: 
115:     @ArchTest
116:     static final ArchRule storageUnitToOneReferences =
117:             fields()
118:                     .that().areDeclaredInClassesThat().resideInAPackage( STORAGE_UNIT_DOMAIN_PACKAGE )
119:                     .and( isToOneAnnotation )
120:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( STORAGE_UNIT_DOMAIN_PACKAGE ) ) )
121:                     .allowEmptyShould( true );
122: 
123: 
124:     private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
125:         return new ArchCondition<JavaField>(
126:                 "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
127:             @Override
128:             public void check( JavaField field, ConditionEvents events ) {
129:                 JavaClass rawType = field.getRawType();
130:                 String rawTypeName = rawType.getFullName();
131:                 if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
132:                     events.add( SimpleConditionEvent.violated( field,
133:                             field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
134:                     return;
135:                 }
136:                 JavaType fieldType = field.getType();
137:                 if ( !( fieldType instanceof JavaParameterizedType ) ) {
138:                     events.add( SimpleConditionEvent.violated( field,
139:                             field.getFullName() + " is a raw List/Set without a type argument" ) );
140:                     return;
141:                 }
142:                 List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
143:                 if ( typeArguments.isEmpty() ) {
144:                     events.add( SimpleConditionEvent.violated( field,
145:                             field.getFullName() + " has no type arguments" ) );
146:                     return;
147:                 }
148:                 JavaType elementType = typeArguments.get( 0 );
149:                 if ( !( elementType instanceof JavaClass ) ) {
150:                     events.add( SimpleConditionEvent.violated( field,
151:                             field.getFullName() + " has an unknown element type" ) );
152:                     return;
153:                 }
154:                 JavaClass elementClass = (JavaClass) elementType;
155:                 boolean hasAnnotation =
156:                         elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
157:                 boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
158:                 boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
159:                 boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
160:                 boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
161:                 if ( !ok ) {
162:                     events.add( SimpleConditionEvent.violated( field,
163:                             field.getFullName() + " refers to " + elementClass.getFullName()
164:                                     + " which is not a DP, or an entity/value object in " + allowedPackage ) );
165:                 }
166:             }
167:         };
168:     }
169: 
170: 
171:     @ArchTest
172:     static final ArchRule shoppingCartToManyReferences =
173:             fields()
174:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_CART_DOMAIN_PACKAGE )
175:                     .and( isToManyAnnotation )
176:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_CART_DOMAIN_PACKAGE ) )
177:                     .allowEmptyShould( true );
178: 
179:     @ArchTest
180:     static final ArchRule userToManyReferences =
181:             fields()
182:                     .that().areDeclaredInClassesThat().resideInAPackage( USER_DOMAIN_PACKAGE )
183:                     .and( isToManyAnnotation )
184:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( USER_DOMAIN_PACKAGE ) )
185:                     .allowEmptyShould( true );
186: 
187:     @ArchTest
188:     static final ArchRule productToManyReferences =
189:             fields()
190:                     .that().areDeclaredInClassesThat().resideInAPackage( PRODUCT_DOMAIN_PACKAGE )
191:                     .and( isToManyAnnotation )
192:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( PRODUCT_DOMAIN_PACKAGE ) )
193:                     .allowEmptyShould( true );
194: 
195:     @ArchTest
196:     static final ArchRule purchaseToManyReferences =
197:             fields()
198:                     .that().areDeclaredInClassesThat().resideInAPackage( PURCHASE_DOMAIN_PACKAGE )
199:                     .and( isToManyAnnotation )
200:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( PURCHASE_DOMAIN_PACKAGE ) )
201:                     .allowEmptyShould( true );
202: 
203:     @ArchTest
204:     static final ArchRule storageUnitToManyReferences =
205:             fields()
206:                     .that().areDeclaredInClassesThat().resideInAPackage( STORAGE_UNIT_DOMAIN_PACKAGE )
207:                     .and( isToManyAnnotation )
208:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( STORAGE_UNIT_DOMAIN_PACKAGE ) )
209:                     .allowEmptyShould( true );
210: 
211: }
212: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: /**
4:  * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
5:  */
6: 
7: public class OwnTestsTest {
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClasses;
4: import com.tngtech.archunit.core.importer.ClassFileImporter;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: 
8: import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
9: 
10: public class PackageStructureTest {
11: 
12:     private static final String[] REQUIRED_PACKAGES = {"user", "shoppingcart", "product", "purchase", "storageunit"};
13:     private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
14:     private JavaClasses importedClasses;
15: 
16: 
17:     @BeforeEach
18:     public void setUp() {
19:         importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
20:     }
21: 
22:     @Test
23:     void testRequiredPackagesAreThere() {
24:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
25:             String packageName = BASE_PACKAGE + "." + requiredPackage;
26:             assertThat( importedClasses.containPackage( packageName ) )
27:                     .as( "Expected package %s not found!", packageName )
28:                     .isTrue();
29:         }
30:     }
31: 
32:     @Test
33:     void testRequiredDomainPackagesAreThere() {
34:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
35:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
36:             assertThat( importedClasses.containPackage( packageName ) )
37:                     .as( "Expected domain sub-package %s not found!", packageName )
38:                     .isTrue();
39:         }
40:     }
41: 
42:     @Test
43:     void testRequiredApplicationPackagesAreThere() {
44:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
45:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
46:             assertThat( importedClasses.containPackage( packageName ) )
47:                     .as( "Expected application sub-package %s not found!", packageName )
48:                     .isTrue();
49:         }
50:     }
51: 
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("domainPrimitivesUsageRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class DomainPrimitivesUsageRulesTest {
14:     private static final String EMAIL_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Email";
15:     private static final String MONEY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Money";
16:     private static final String PHYSICAL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress";
17: 
18:     @ArchTest
19:     static final ArchRule userShouldReferenceEmail =
20:             classes()
21:                     .that().haveSimpleName( "User" )
22:                     .should().dependOnClassesThat().haveFullyQualifiedName( EMAIL_CLASS )
23:                     .because( "User should use Email instead of String" );
24: 
25:     @ArchTest
26:     static final ArchRule userShouldReferencePhysicalAddress =
27:             classes()
28:                     .that().haveSimpleName( "User" )
29:                     .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
30:                     .because( "User should use PhysicalAddress instead of whatever else" );
31: 
32:     @ArchTest
33:     static final ArchRule storageUnitShouldReferencePhysicalAddress =
34:             classes()
35:                     .that().haveSimpleName( "StorageUnit" )
36:                     .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
37:                     .because( "User should use PhysicalAddress instead of whatever else" );
38: 
39:     @ArchTest
40:     static final ArchRule productShouldReferenceMoney =
41:             classes()
42:                     .that().haveSimpleName( "Product" )
43:                     .should().dependOnClassesThat().haveFullyQualifiedName( MONEY_CLASS )
44:                     .because( "Product should use Money instead of float or whatever else" );
45: }
46: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\EmailTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmail;
10: 
11: class EmailTest {
12: 
13:     @Test
14:     public void testToStringEmail() {
15:         // given
16:         String input = "test@example.com";
17: 
18:         // when
19:         EmailType instance = instantiateEmail( input );
20: 
21:         // then
22:         assertEquals( input, instance.toString() );
23:     }
24: 
25:     @Test
26:     public void testEqualityEmail() {
27:         // given
28:         // when
29:         EmailType instance1 = instantiateEmail( "test@example.com" );
30:         EmailType instance2 = instantiateEmail( "test@example.com" );
31:         EmailType instance3 = instantiateEmail( "different@example.com" );
32: 
33:         // then
34:         assertEquals( instance1, instance2 );
35:         assertNotEquals( instance1, instance3 );
36:     }
37: 
38:     @Test
39:     public void testImmutabilityEmail() {
40:         // given
41:         // when
42:         EmailType instance = instantiateEmail( "test@example.com" );
43: 
44:         // then
45:         try {
46:             instance.getClass().getMethod( "setEmail", String.class );
47:             fail( "setEmail method should not exist" );
48:         } catch (NoSuchMethodException e) {
49:             // Success: the object is immutable
50:         }
51:     }
52: 
53: 
54: 
55:     @Test
56:     public void smokeTestForCopyConstructors() {
57:         // given
58:         EmailType email =
59:                 instantiateEmail( "peter.schmidt@web.de" );
60: 
61:         // when
62:         EmailType emailOtherIdentifyer =
63:                 email.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
64:         assertThrows( ShopException.class, () ->
65:                 email.sameDomainDifferentIdentifyer( "p...eter" ) );
66:         EmailType emailOtherDomain =
67:                 email.sameIdentifyerDifferentDomain( "web.ch" );
68:         assertThrows( ShopException.class, () ->
69:                 email.sameIdentifyerDifferentDomain( "web.edu" ) );
70: 
71:         // then
72:         assertEquals( "p.e.t.e.r@web.de", emailOtherIdentifyer.toString() );
73:         assertEquals( "peter.schmidt@web.ch", emailOtherDomain.toString() );
74:     }
75: 
76: 
77:     @Test
78:     public void testFactoryValidEmail() {
79:         // given
80:         // when
81:         // then
82:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.com" ) );
83:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "99Z@example.com" ) );
84:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "GGGhh@s77.com" ) );
85:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "a@4.com" ) );
86:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "Max.Hammer@example.com" ) );
87:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "Max.Gideon.Hammer@example.com" ) );
88:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.this.com" ) );
89:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.de" ) );
90:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.at" ) );
91:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.ch" ) );
92:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.org" ) );
93:     }
94: 
95: 
96:     @Test
97:     public void testFactoryInvalidEmail() {
98:         // given
99:         // when
100:         // then
101:         assertThrows( ShopException.class, () -> instantiateEmail( null ) );
102:         assertThrows( ShopException.class, () -> instantiateEmail( "testexample.com" ) );
103:         assertThrows( ShopException.class, () -> instantiateEmail( "test@" ) );
104:         assertThrows( ShopException.class, () -> instantiateEmail( "@example.com" ) );
105:         assertThrows( ShopException.class, () -> instantiateEmail( "Max..Gideon.Hammer@example.com" ) );
106:         assertThrows( ShopException.class, () -> instantiateEmail( "test@examplecom" ) );
107:         assertThrows( ShopException.class, () -> instantiateEmail( "test@example..com" ) );
108:         assertThrows( ShopException.class, () -> instantiateEmail( "test@example@that.com" ) );
109:         assertThrows( ShopException.class, () -> instantiateEmail( "test example@that.com" ) );
110:         assertThrows( ShopException.class, () -> instantiateEmail( "test#example@that.com" ) );
111:         assertThrows( ShopException.class, () -> instantiateEmail( "test@example.biz" ) );
112:         assertThrows( ShopException.class, () -> instantiateEmail( "test@example.biz" ) );
113:         assertThrows( ShopException.class, () -> instantiateEmail( "test@example.42" ) );
114:     }
115: }
116: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\MoneyTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMoney;
9: 
10: class MoneyTest {
11: 
12:     @Test
13:     public void testGetAmountMoney() {
14:         // given
15:         Float inputAmount = 10.0f;
16: 
17:         // when
18:         MoneyType instance = instantiateMoney( inputAmount, "EUR" );
19: 
20:         // then
21:         assertEquals( inputAmount, instance.getAmount() );
22:     }
23: 
24:     @Test
25:     public void testGetCurrencyUnitMoney() {
26:         // given
27:         String inputCurrencyUnit = "EUR";
28: 
29:         // when
30:         MoneyType instance = instantiateMoney( 10.0f, inputCurrencyUnit );
31: 
32:         // then
33:         assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
34:     }
35: 
36:     @Test
37:     public void testAddToMoney() {
38:         // given
39:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
40:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
41:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
42: 
43:         // when
44:         MoneyType result12 = instance1.add( instance2 );
45:         MoneyType result13 = instance1.add( instance3 );
46: 
47:         // then
48:         assertEquals( 30.0f, result12.getAmount() );
49:         assertEquals( "EUR", result12.getCurrencyUnit() );
50:         assertEquals( 10.0f, result13.getAmount() );
51:         assertEquals( "EUR", result12.getCurrencyUnit() );
52:     }
53: 
54:     @Test
55:     public void testInvalidAddToMoney() {
56:         // given
57:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
58:         MoneyType instance2 = instantiateMoney( 20.0f, "CHF" );
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
63:     }
64: 
65:     @Test
66:     public void testSubtractFromMoney() {
67:         // given
68:         MoneyType instance1 = instantiateMoney( 30.0f, "EUR" );
69:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
70:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
71:         MoneyType instance4 = instantiateMoney( 30.0f, "EUR" );
72: 
73:         // when
74:         MoneyType result12 = instance1.subtract( instance2 );
75:         MoneyType result13 = instance1.subtract( instance3 );
76:         MoneyType result14 = instance1.subtract( instance4 );
77: 
78:         // then
79:         assertEquals( 10.0f, result12.getAmount() );
80:         assertEquals( "EUR", result12.getCurrencyUnit() );
81:         assertEquals( 30.0f, result13.getAmount() );
82:         assertEquals( "EUR", result13.getCurrencyUnit() );
83:         assertEquals( 0.0f, result14.getAmount() );
84:         assertEquals( "EUR", result14.getCurrencyUnit() );
85:     }
86: 
87:     @Test
88:     public void testInvalidSubtractFromMoney() {
89:         // given
90:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
91:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
92:         MoneyType instance3 = instantiateMoney( 5.0f, "CHF" );
93: 
94:         // when
95:         // then
96:         assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
97:         assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
98:     }
99: 
100:     @Test
101:     public void testMultiplyByMoney() {
102:         // given
103:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
104: 
105:         // when
106:         MoneyType result = instance.multiplyBy( 3 );
107: 
108:         // then
109:         assertEquals( 30.0f, result.getAmount() );
110:         assertEquals( "EUR", result.getCurrencyUnit() );
111:     }
112: 
113:     @Test
114:     public void testFactoryValidCurrencyUnitMoney() {
115:         // given
116:         // when
117:         // then
118:         assertDoesNotThrow( () -> instantiateMoney( 10.0f, "EUR" ) );
119:     }
120: 
121:     @Test
122:     public void testFactoryInvalidCurrencyUnitMoney() {
123:         // given
124:         // when
125:         // then
126:         assertThrows( ShopException.class, () -> instantiateMoney( -10.0f, "EUR" ) );
127:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, "USD" ) );
128:         assertThrows( ShopException.class, () -> instantiateMoney( null, "EUR" ) );
129:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, null ) );
130:     }
131: 
132:     @Test
133:     public void testLargerThanCurrencyUnitMoney() {
134:         // given
135:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
136:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
137:         MoneyType instance3 = instantiateMoney( 10.0f, "EUR" );
138:         MoneyType instance4 = instantiateMoney( 10.0f, "CHF" );
139: 
140:         // when
141:         // then
142:         assertTrue( instance2.largerThan( instance1 ) );
143:         assertFalse( instance1.largerThan( instance2 ) );
144:         assertFalse( instance1.largerThan( instance3 ) );
145:         assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
146:     }
147: 
148: 
149:     @Test
150:     public void testEqualityCurrencyUnitMoney() {
151:         // given
152:         // when
153:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
154:         MoneyType instance2 = instantiateMoney( 10.0f, "EUR" );
155:         MoneyType instance3 = instantiateMoney( 20.0f, "EUR" );
156: 
157:         // then
158:         assertEquals( instance1, instance2 );
159:         assertNotEquals( instance1, instance3 );
160:     }
161: 
162:     @Test
163:     public void testImmutabilityCurrencyUnitMoney() {
164:         // given
165:         // when
166:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
167: 
168:         // then
169:         try {
170:             instance.getClass().getMethod( "setAmount", Float.class );
171:             fail( "setAmount method should not exist" );
172:         } catch (NoSuchMethodException e) {
173:             // Success: the object is immutable
174:         }
175: 
176:         try {
177:             instance.getClass().getMethod( "setCurrencyUnit", String.class );
178:             fail( "setCurrencyUnit method should not exist" );
179:         } catch (NoSuchMethodException e) {
180:             // Success: the object is immutable
181:         }
182:     }
183: }
184: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\PhysicalAddressTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
11: 
12: class PhysicalAddressTest {
13: 
14:     @Test
15:     public void testGetterPhysicalAddress() {
16:         // given
17:         String street = "Irgendeinestraße 42";
18:         String city = "Irgendeinestadt";
19:         ZipCodeType plz = instantiateZipCode( "12345" );
20: 
21:         // when
22:         PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );
23: 
24:         // then
25:         assertEquals( street, instance.getStreet() );
26:         assertEquals( city, instance.getCity() );
27:         assertEquals( plz, instance.getZipCode() );
28:     }
29: 
30:     @Test
31:     public void testFactoryValidPhysicalAddress() {
32:         // given
33:         String street = "Irgendeinestraße 42";
34:         String city = "Irgendeinestadt";
35:         ZipCodeType plz = instantiateZipCode( "12345" );
36: 
37:         // when
38:         // then
39:         assertDoesNotThrow( () -> instantiatePhysicalAddress( street, city, plz ) );
40:     }
41: 
42:     @Test
43:     public void testFactoryInvalidPhysicalAddress() {
44:         // given
45:         String street = "Irgendeinestraße 42";
46:         String city = "Irgendeinestadt";
47:         ZipCodeType plz = instantiateZipCode( "12345" );
48: 
49:         // when
50:         // then
51:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( null, city, plz ) );
52:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( "", city, plz ) );
53:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, null, plz ) );
54:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, "", plz ) );
55:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, city, null ) );
56:     }
57: 
58:     @Test
59:     public void testEqualityPhysicalAddress() {
60:         // given
61:         String street = "Irgendeinestraße 42";
62:         String city = "Irgendeinestadt";
63:         ZipCodeType plz = instantiateZipCode( "12345" );
64: 
65:         // when
66:         PhysicalAddressType instance1 = instantiatePhysicalAddress( street, city, plz );
67:         PhysicalAddressType instance2 = instantiatePhysicalAddress( street, city, plz );
68:         PhysicalAddressType instance3 = instantiatePhysicalAddress( "Anderestr. 12", city, plz );
69:         PhysicalAddressType instance4 = instantiatePhysicalAddress( street, "AndereStadt", plz );
70:         PhysicalAddressType instance5 = instantiatePhysicalAddress( street, city, instantiateZipCode( "54321" ) );
71: 
72:         // then
73:         assertEquals( instance1, instance2 );
74:         assertNotEquals( instance1, instance3 );
75:         assertNotEquals( instance1, instance4 );
76:         assertNotEquals( instance1, instance5 );
77:     }
78: 
79:     @Test
80:     public void testImmutabilityPhysicalAddress() {
81:         // given
82:         String street = "Irgendeinestraße 42";
83:         String city = "Irgendeinestadt";
84:         ZipCodeType plz = instantiateZipCode( "12345" );
85: 
86:         // when
87:         PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );
88: 
89:         // then
90:         try {
91:             instance.getClass().getMethod( "setStreet", String.class );
92:             fail( "setStreet method should not exist" );
93:         } catch (NoSuchMethodException e) {
94:             // Success: the object is immutable
95:         }
96:         try {
97:             instance.getClass().getMethod( "setCity", String.class );
98:             fail( "setCity method should not exist" );
99: 
100:         } catch (NoSuchMethodException e) {
101:             // Success: the object is immutable
102:         }
103:         try {
104:             instance.getClass().getMethod( "setZipCode", ZipCodeType.class );
105:             fail( "setZipCode method should not exist" );
106:         } catch (NoSuchMethodException e) {
107:             // Success: the object is immutable
108:         }
109:     }
110: }
111: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\ZipCodeTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
8: 
9: import static org.junit.jupiter.api.Assertions.*;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
11: 
12: class ZipCodeTest {
13: 
14:     private String input1, input4;
15:     private ZipCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
16:             _04233, _02544, _99123, _56323, _79332;
17: 
18: 
19:     @BeforeEach
20:     public void setUp() {
21:         input1 = "12345";
22:         input4 = "49188";
23:         _12345 = FactoryMethodInvoker.instantiateZipCode( "12345" );
24:         _12345b = FactoryMethodInvoker.instantiateZipCode( "12345" );
25:         _23455 = FactoryMethodInvoker.instantiateZipCode( "23455" );
26:         _01234 = FactoryMethodInvoker.instantiateZipCode( "01234" );
27:         _01235 = FactoryMethodInvoker.instantiateZipCode( "01235" );
28:         _01238 = FactoryMethodInvoker.instantiateZipCode( "01238" );
29:         _01263 = FactoryMethodInvoker.instantiateZipCode( "01263" );
30:         _01213 = FactoryMethodInvoker.instantiateZipCode( "01213" );
31:         _01823 = FactoryMethodInvoker.instantiateZipCode( "01823" );
32:         _01312 = FactoryMethodInvoker.instantiateZipCode( "01312" );
33:         _04233 = FactoryMethodInvoker.instantiateZipCode( "04233" );
34:         _02544 = FactoryMethodInvoker.instantiateZipCode( "02544" );
35:         _99123 = FactoryMethodInvoker.instantiateZipCode( "99123" );
36:         _56323 = FactoryMethodInvoker.instantiateZipCode( "56323" );
37:         _79332 = FactoryMethodInvoker.instantiateZipCode( "79332" );
38: 
39:     }
40: 
41: 
42:     @Test
43:     public void testToStringZipCode() {
44:         // given
45:         // when
46:         ZipCodeType instance = instantiateZipCode( input1 );
47: 
48:         // then
49:         assertEquals( input1, instance.toString() );
50:     }
51: 
52:     @Test
53:     public void testFactoryValidZipCode() {
54:         // given
55:         // when
56:         // then
57:         assertDoesNotThrow( () -> instantiateZipCode( input1 ) );
58:     }
59: 
60:     @Test
61:     public void testFactoryInvalidZipCode() {
62:         // given
63:         // when
64:         // then
65:         assertThrows( ShopException.class, () -> instantiateZipCode( "123456" ) );
66:         assertThrows( ShopException.class, () -> instantiateZipCode( "1234" ) );
67:         assertThrows( ShopException.class, () -> instantiateZipCode( "20000" ) );
68:         assertThrows( ShopException.class, () -> instantiateZipCode( null ) );
69:     }
70: 
71:     @Test
72:     public void testEqualityZipCode() {
73:         // given
74:         // when
75:         ZipCodeType instance1a = instantiateZipCode( input1 );
76:         ZipCodeType instance1b = instantiateZipCode( input1 );
77:         ZipCodeType instance4 = instantiateZipCode( input4 );
78: 
79:         // then
80:         assertEquals( instance1a, instance1b );
81:         assertNotEquals( instance1a, instance4 );
82:     }
83: 
84:     @Test
85:     public void testImmutabilityZipCode() {
86:         // given
87:         // when
88:         ZipCodeType instance = instantiateZipCode( input1 );
89: 
90:         // then
91:         try {
92:             instance.getClass().getMethod( "setzipCode", String.class );
93:             fail( "setzipCode method should not exist" );
94:         } catch (NoSuchMethodException e) {
95:             // Success: the object is immutable
96:         }
97:     }
98: 
99: 
100:     @Test
101:     public void smokeTestForDifference() {
102:         // given
103:         ZipCodeType instance1a = instantiateZipCode( input1 );
104:         ZipCodeType instance1b = instantiateZipCode( input1 );
105:         ZipCodeType instance12479 = instantiateZipCode( "12479" );
106:         ZipCodeType instance21456 = instantiateZipCode( "21456" );
107: 
108:         // when
109:         int differenceAB = instance1a.difference( instance1b );
110:         int difference12 = instance1a.difference( instance12479 );
111:         int difference23 = instance12479.difference( instance21456 );
112: 
113:         // then
114:         assertEquals( 0, differenceAB );
115:         assertTrue( difference12 > 0 );
116:         assertTrue( difference23 > difference12 );
117:     }
118: 
119: 
120:     @Test
121:     public void testZipCodeFirstDigit() {
122:         // given
123:         ZipCodeType instance1 = instantiateZipCode( input1 );
124:         ZipCodeType instance4 = instantiateZipCode( input4 );
125: 
126:         // when
127:         // then
128:         assertEquals( 1, instance1.getFirstDigitZipCode() );
129:         assertEquals( 4, instance4.getFirstDigitZipCode() );
130:     }
131: 
132: 
133: 
134:     @Test
135:     public void testInvalidParameters() {
136:         // given
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 _12345.difference( null ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testSameZipCode() {
146:         // given
147:         // when
148:         int diff = _12345.difference( _12345b );
149: 
150:         // then
151:         assertEquals( 0, diff );
152:     }
153: 
154: 
155:     /**
156:      *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
157:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
158:      *        So, 56733 and 56734 have the same difference as 56733 and 56739.
159:      *      - The difference grows if more digits (counted from the right side) differ.
160:      *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
161:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
162:      *        53876 and 54876 have the same difference as 53876 and 57261.
163:      */
164:     @Test
165:     public void testZipCodeDifferenceInAllButFirstDigit() {
166:         // given
167:         // when
168:         int diff5a = _01234.difference( _01235 );
169:         int diff5b = _01234.difference( _01238 );
170:         int diff4a = _01234.difference( _01263 );
171:         int diff4b = _01234.difference( _01213 );
172:         int diff3a = _01234.difference( _01823 );
173:         int diff3b = _01234.difference( _01312 );
174:         int diff2a = _01234.difference( _04233 );
175:         int diff2b = _01234.difference( _02544 );
176: 
177:         // then
178:         assertEquals( diff5a, diff5b, "difference 01234-01235 must be the same as difference 01234-01238" );
179:         assertEquals( diff4a, diff4b, "difference 01234-01263 must be the same as difference 01234-01213" );
180:         assertEquals( diff3a, diff3b, "difference 01234-01823 must be the same as difference 01234-01312" );
181:         assertEquals( diff2a, diff2b, "difference 01234-04233 must be the same as difference 01234-02544" );
182: 
183:         assertTrue( diff5a < diff4a,
184:                 "difference 01234-01235 must be smaller than difference 01234-01263" );
185:         assertTrue( diff4a < diff3a,
186:                 "difference 01234-01263 must be smaller than difference 01234-01823" );
187:         assertTrue( diff3a < diff2a,
188:                 "difference 01234-01823 must be smaller than difference 01234-04233" );
189:     }
190: 
191: 
192:     /**
193:      *      - However, the difference between 5abcd and 6rstu must be smaller than the one
194:      *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
195:      *        one between 5abcd and 9rstu.
196:      *      - This last condition reflects the fact the first digits of a zip code marks a region
197:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
198:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
199:      *        other.
200:      */
201:     @Test
202:     public void testZipCodedifferenceInFirstDigit() {
203:         // given
204:         // when
205:         int diff1_1 = _01234.difference( _99123 );
206:         int diff1_2 = _01234.difference( _23455 );
207:         int diff1_5 = _01234.difference( _56323 );
208:         int diff1_3 = _01234.difference( _79332 );
209: 
210:         // then
211:         assertTrue( diff1_1 < diff1_2,
212:                 "difference 01234-99123 must be smaller than difference 01234-23455"  );
213:         assertTrue( diff1_2 < diff1_3,
214:                 "difference 01234-23455 must be smaller than difference 01234-79332" );
215:         assertTrue( diff1_3 < diff1_5,
216:                 "difference 01234-79332 must be smaller than difference 01234-56323"  );
217:     }
218: 
219: 
220: 
221: }
222: 
223: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
1: package thkoeln.archilab.ecommerce.tests.e1restcalls;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;
5: 
6: 
7: public class E1RestCallTableTest {
8: 
9:     private GenericTableSpecificationTests genericTableSpecificationTests = null;
10: 
11: 
12:     public E1RestCallTableTest() {
13:         this.genericTableSpecificationTests = new GenericTableSpecificationTests();
14:     }
15: 
16:     @Test
17:     public void restTest() throws Exception {
18:         genericTableSpecificationTests.testTableSpecification("E1" );
19:     }
20: }
21: 
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import com.fasterxml.jackson.databind.ObjectMapper;
4: import com.jayway.jsonpath.JsonPath;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: import thkoeln.archilab.ecommerce.domainprimitives.Email;
8: import thkoeln.archilab.ecommerce.domainprimitives.Money;
9: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
10: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
11: 
12: import static org.junit.jupiter.api.Assertions.assertEquals;
13: import static org.junit.jupiter.api.Assertions.fail;
14: 
15: 
16: public class DomainPrimitiveJSONSerializationTest {
17: 
18:     @BeforeEach
19:     public void setUp() {
20:         // ... add own setup code here
21:     }
22: 
23: 
24:     /**
25:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
26:      * Email.
27:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
28:      * on how to implement this test, and how to change property names.
29:      * @throws Exception
30:      */
31:     @Test
32:     public void test_Email_Serialization() throws Exception {
33:         // given
34:         Email email = new Email("test@example.com");
35:         ObjectMapper mapper = new ObjectMapper();
36: 
37:         // when
38:         String json = mapper.writeValueAsString(email);
39: 
40:         // then
41:         String emailString = JsonPath.read(json, "$.emailString");
42:         assertEquals("test@example.com", emailString);
43:     }
44: 
45: 
46:     /**
47:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
48:      * ZipCode.
49:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
50:      * on how to implement this test, and how to change property names.
51:      * @throws Exception
52:      */
53:     @Test
54:     public void test_ZipCode_Serialization() throws Exception {
55:         // given
56:         ZipCode zipCode = new ZipCode("50667");
57:         ObjectMapper mapper = new ObjectMapper();
58: 
59:         // when
60:         String json = mapper.writeValueAsString(zipCode);
61: 
62:         // then
63:         String zipCodeString = JsonPath.read(json, "$.zipCodeString");
64:         assertEquals("50667", zipCodeString);
65:     }
66: 
67: 
68:     /**
69:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
70:      * PhysicalAddress.
71:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
72:      * on how to implement this test, and how to change property names.
73:      * @throws Exception
74:      */
75:     @Test
76:     public void test_PhysicalAddress_Serialization() throws Exception {
77:         // given
78:         ZipCode zipCode = new ZipCode("50667");
79:         PhysicalAddress address = new PhysicalAddress("Domstraße 1", "Köln", zipCode);
80:         ObjectMapper mapper = new ObjectMapper();
81: 
82:         // when
83:         String json = mapper.writeValueAsString(address);
84: 
85:         // then
86:         String street = JsonPath.read(json, "$.street");
87:         String city = JsonPath.read(json, "$.city");
88:         String zipCodeString = JsonPath.read(json, "$.zipCode.zipCodeString");
89: 
90:         assertEquals("Domstraße 1", street);
91:         assertEquals("Köln", city);
92:         assertEquals("50667", zipCodeString);
93:     }
94: 
95: 
96:     /**
97:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
98:      * Money.
99:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
100:      * on how to implement this test, and how to change property names.
101:      * @throws Exception
102:      */
103:     @Test
104:     public void test_Money_Serialization() throws Exception {
105:         // given
106:         Money money = new Money(19.99F, "EUR");
107:         ObjectMapper mapper = new ObjectMapper();
108: 
109:         // when
110:         String json = mapper.writeValueAsString(money);
111: 
112:         // then
113:         Double amount = JsonPath.read(json, "$.amount");
114:         String currency = JsonPath.read(json, "$.currency");
115:         assertEquals(19.99, amount, 0.001);
116:         assertEquals("EUR", currency);
117:     }
118: 
119: }
120: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingCartRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import thkoeln.archilab.ecommerce.domainprimitives.Email;
11: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
12: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
13: import thkoeln.archilab.ecommerce.solution.shoppingcart.application.ShoppingCartService;
14: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.entities.ShoppingCart;
15: import thkoeln.archilab.ecommerce.usecases.UserType;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
17: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
18: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
19: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
20: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
21: 
22: import java.util.Map;
23: import java.util.UUID;
24: 
25: import static org.junit.jupiter.api.Assertions.assertEquals;
26: 
27: 
28: @SpringBootTest
29: @Transactional
30: @AutoConfigureMockMvc
31: @Import(RESTTestHelperConfiguration.class)
32: public class OwnShoppingCartRESTTest {
33:     @Autowired
34:     private Purgatory purgatory;
35:     @Autowired
36:     private UserTestHelper userTestHelper;
37:     @Autowired
38:     private ProductTestHelper productTestHelper;
39:     @Autowired
40:     private StorageUnitTestHelper storageUnitTestHelper;
41:     @Autowired
42:     private ShoppingCartRESTHelper shoppingCartRESTHelper;
43:     @Autowired
44:     private ShoppingCartService shoppingCartService;
45: 
46:     @BeforeEach
47:     public void setUp() {
48:         purgatory.deleteEverything();
49:         userTestHelper.registerAllUsers();
50:         productTestHelper.addAllProducts();
51:         storageUnitTestHelper.addAllStorageUnits(true);
52: 
53:     }
54: 
55: 
56:     /**
57:      * Provide a test that implements a simple call to the REST endpoint (3):
58:      * <pre>
59:      *     GET /shoppingCarts?userId=<user id as uuid>
60:      * </pre>
61:      * - Use the {@link UserTestHelper} to obtain to obtain the email
62:      * of some example user.
63:      * - Use your shopping cart service to add entries to the shopping cart of that person.
64:      * - then use the `ShoppingCartRESTHelper` to create the GET call, and check the results.
65:      * - (or do it by directly calling your REST controller, if you prefer)
66:      *
67:      * @throws Exception
68:      */
69:     @Test
70:     public void test_getQuery_ShoppingCart() throws Exception {
71:         // given
72:         EmailType email = userTestHelper.getUserEmail(1);
73:         Email mail = (Email) Email.of(email.toString());
74:         UUID product = productTestHelper.getProductId(1);
75:         int quantity = 2;
76:         // when
77:         shoppingCartService.addProductToShoppingCart(mail, product, quantity);
78:         // then
79:         shoppingCartRESTHelper.getQueryShoppingCart(email, shoppingCartService.getShoppingCartAsMap(email)); // null = don't check the quantity map
80:     }
81: 
82: 
83:     /**
84:      * Provide a test that implements the addition of one product to the shopping cart via
85:      * REST endpoint (6):
86:      * <pre>
87:      *     POST /shoppingCarts/{shoppingCart-Id}/parts
88:      * </pre>
89:      * You can test now "the other way around" as in test_getQuery_ShoppingCart():
90:      * - Use `ShoppingCartRESTHelper` to add products via REST, then use shopping cart service methods
91:      * to check of the shopping cart contains the right stuff.
92:      * - (or do it by directly calling your REST controller, if you prefer)
93:      *
94:      * @throws Exception
95:      */
96:     @Test
97:     public void test_post_ShoppingCartParts() throws Exception {
98:         // given
99:         EmailType email = userTestHelper.getUserEmail(1);
100:         UUID productId1 = productTestHelper.getProductId(1);
101:         int quantity1 = 3;
102:         UUID productId2 = productTestHelper.getProductId(2);
103:         int quantity2 = 1;
104: 
105:         shoppingCartService.createCartIfNotExists(email);
106: 
107:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart(email, null); // null = don't check the quantity map
108: 
109:         // when – Produkte via REST hinzufügen
110:         shoppingCartRESTHelper.addProductToShoppingCart(shoppingCartId, productId1, quantity1);
111:         shoppingCartRESTHelper.addProductToShoppingCart(shoppingCartId, productId2, quantity2);
112: 
113:         // then – überprüfen, ob sie drin sind
114:         Map<UUID, Integer> shoppingCart = shoppingCartService.getShoppingCartAsMap(email);
115:         assertEquals(quantity1, shoppingCart.get(productId1));
116:         assertEquals(quantity2, shoppingCart.get(productId2));
117:     }
118: 
119: 
120: 
121:     /**
122:      * Provide a test that implements the deletion of one product in the shopping cart via
123:      * REST endpoint (10):
124:      * <pre>
125:      *     DELETE /shoppingCarts/{shoppingCart-Id}/parts/{product-Id}
126:      * </pre>
127:      * This should be just a slight variation of the test_post_ShoppingCartParts()
128:      * method, but instead of adding an product to the shopping cart, you delete it.
129:      *
130:      * @throws Exception
131:      */
132:     @Test
133:     public void test_delete_ShoppingCartParts() throws Exception {
134:         // given
135:         UUID productId = productTestHelper.getProductId(1);
136:         int quantity = 3;
137: 
138:         ShoppingCart shoppingCart = shoppingCartService.createCartIfNotExists(userTestHelper.getUserEmail(1));
139: 
140:         // Produkt hinzufügen
141:         shoppingCartRESTHelper.addProductToShoppingCart(shoppingCart.getId().getId(), productId, quantity);
142: 
143:         // sicherstellen, dass es im Warenkorb ist
144:         Map<UUID, Integer> expectedQuantityMap = Map.of(productId, quantity);
145:         shoppingCartRESTHelper.getQueryShoppingCart(userTestHelper.getUserEmail(1), expectedQuantityMap);
146: 
147:         // when – Produkt entfernen
148:         shoppingCartRESTHelper.deleteProductFromShoppingCart(shoppingCart.getId().getId(), productId);
149: 
150:         // then – überprüfen, dass Produkt entfernt wurde
151:         shoppingCartRESTHelper.getQueryShoppingCart(userTestHelper.getUserEmail(1), Map.of());
152:     }
153: 
154: 
155:     /**
156:      * Provide a test that implements the checkout of a shopping cart that can be served
157:      * by just 1 storage unit, using the REST endpoint (11):
158:      * <pre>
159:      *     POST /shoppingCarts/{shoppingCart-Id}/checkout
160:      * </pre>
161:      * - Use your shopping cart service to add entries to the shopping cart of some example user,
162:      * - then use the `ShoppingCartRESTHelper to post the checkout call, and to check the results.
163:      * - (or do it by directly calling your REST controller, if you prefer)
164:      *
165:      * @throws Exception
166:      */
167:     @Test
168:     public void test_checkout_1_storageUnit() throws Exception {
169:         // given
170:         UserType user = userTestHelper.getUser(1);
171:         UUID productId = productTestHelper.getProductId(1);
172:         int quantity = 3;
173: 
174:         ShoppingCart shoppingCart = shoppingCartService.createCartIfNotExists(userTestHelper.getUserEmail(1));
175: 
176:         shoppingCartRESTHelper.addProductToShoppingCart(shoppingCart.getId().getId(), productId, quantity);
177:         // when
178:         shoppingCartRESTHelper.checkout(
179:                 shoppingCart.getId().getId(),
180:                 user.getName(),
181:                 null,
182:                 Map.of(storageUnitTestHelper.getStorageUnitId(0), Map.of(productId, quantity)
183:                 )
184:         );
185: 
186:     }
187: 
188: 
189:     /**
190:      * Provide a test that implements the checkout of a shopping cart that can only be served
191:      * by using 2 storage units, using the REST endpoint (11):
192:      * <pre>
193:      *     POST /shoppingCarts/{shoppingCart-Id}/checkout
194:      * </pre>
195:      * This should be just a slight variation of thetest_checkout_1_storageUnit() test.
196:      *
197:      * @throws Exception
198:      */
199:     @Test
200:     public void test_checkout_2_storageUnits() throws Exception {
201:         // given
202:         UserType user = userTestHelper.getUser(2);
203:         UUID productId1 = productTestHelper.getProductId(1);
204:         UUID productId2 = productTestHelper.getProductId(7);
205: 
206:         int quantity1 = 2;
207:         int quantity2 = 3;
208: 
209:         ShoppingCart shoppingCart = shoppingCartService.createCartIfNotExists(userTestHelper.getUserEmail(2));
210: 
211:         // Produkte hinzufügen
212:         shoppingCartRESTHelper.addProductToShoppingCart(shoppingCart.getId().getId(), productId1, quantity1);
213:         shoppingCartRESTHelper.addProductToShoppingCart(shoppingCart.getId().getId(), productId2, quantity2);
214: 
215:         // when + then
216:         shoppingCartRESTHelper.checkout(
217:                 shoppingCart.getId().getId(),
218:                 user.getName(),
219:                 null,
220:                 Map.of(
221:                         storageUnitTestHelper.getStorageUnitId(0), Map.of(productId1, quantity1),
222:                         storageUnitTestHelper.getStorageUnitId(1), Map.of(productId2, quantity2)
223:                 )
224:         );
225:     }
226: 
227: }
228: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\product\ProductCatalogTest.java ---
1: package thkoeln.archilab.ecommerce.tests.product;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
9: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
14: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
15: 
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.*;
19: 
20: 
21: @SpringBootTest
22: public class ProductCatalogTest {
23:     @Autowired
24:     private UserRegistrationUseCases userRegistrationUseCases;
25:     @Autowired
26:     private ShoppingCartUseCases shoppingCartUseCases;
27:     @Autowired
28:     private ProductCatalogUseCases productCatalogUseCases;
29:     @Autowired
30:     private StorageUnitUseCases storageUnitUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private UserTestHelper userTestHelper;
35:     @Autowired
36:     private ProductTestHelper productTestHelper;
37:     @Autowired
38:     private StorageUnitTestHelper storageUnitTestHelper;
39: 
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         userTestHelper.registerAllUsers();
45:         productTestHelper.addAllProducts();
46:     }
47: 
48: 
49:     @Test
50:     public void testAddProductToCatalog() {
51:         // given
52:         UUID productId4 = productTestHelper.getProductId( 4 );
53:         MoneyType salesPrice4 = productTestHelper.getSalesPrice( 4 );
54: 
55:         // when
56:         MoneyType foundSalesPrice = productCatalogUseCases.getSalesPrice( productId4 );
57: 
58:         // then
59:         assertEquals( salesPrice4, foundSalesPrice );
60:     }
61: 
62: 
63:     @Test
64:     public void testAddProductWithInvalidData() {
65:         // given
66:         String name = "SomeStuff";
67:         String description = "Some more explanation on the stuff";
68:         Float size = 5.0f;
69:         MoneyType buyingPrice =
70:                 FactoryMethodInvoker.instantiateMoney( 5.0f, "EUR" );
71:         MoneyType salesPrice =
72:                 FactoryMethodInvoker.instantiateMoney( 10.0f, "EUR" );
73:         MoneyType tooLowSalesPrice =
74:                 FactoryMethodInvoker.instantiateMoney( 4.0f, "EUR" );
75: 
76:         // when / then
77:         assertThrows( ShopException.class, () ->
78:                 productCatalogUseCases.addProductToCatalog(
79:                         null, description, size, buyingPrice, salesPrice ) );
80:         assertThrows( ShopException.class, () ->
81:                 productCatalogUseCases.addProductToCatalog(
82:                         "", description, size, buyingPrice, salesPrice ) );
83:         assertThrows( ShopException.class, () ->
84:                 productCatalogUseCases.addProductToCatalog(
85:                         name, null, size, buyingPrice, salesPrice ) );
86:         assertThrows( ShopException.class, () ->
87:                 productCatalogUseCases.addProductToCatalog(
88:                         name, "", size, buyingPrice, salesPrice ) );
89:         assertThrows( ShopException.class, () ->
90:                 productCatalogUseCases.addProductToCatalog(
91:                         name, description, size, null, salesPrice ) );
92:         assertThrows( ShopException.class, () ->
93:                 productCatalogUseCases.addProductToCatalog(
94:                         name, description, size, buyingPrice, null ) );
95:         assertThrows( ShopException.class, () ->
96:                 productCatalogUseCases.addProductToCatalog(
97:                         name, description, size, buyingPrice, tooLowSalesPrice ) );
98:     }
99: 
100: 
101:     @Test
102:     public void testRemoveNonExistentProduct() {
103:         // given product 2 is not in stock anywhere - should be removable
104:         UUID nonExistentProductId = UUID.randomUUID();
105: 
106:         // when
107:         // then
108:         assertThrows( ShopException.class,
109:                 () -> productCatalogUseCases.removeProductFromCatalog( nonExistentProductId ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testRemoveProductWithNoStock() {
115:         // given product 0 is not in stock anywhere - should be removable
116:         UUID productId0 = productTestHelper.getProductId( 0 );
117:         storageUnitTestHelper.addAllStorageUnits( true );
118: 
119:         // when
120:         assertDoesNotThrow( () -> productCatalogUseCases.getSalesPrice( productId0 ) );
121:         productCatalogUseCases.removeProductFromCatalog( productId0 );
122: 
123:         // then
124:         assertThrows( ShopException.class, () ->
125:                 productCatalogUseCases.getSalesPrice( productId0 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testRemoveProductThatIsInStock() {
131:         // given
132:         storageUnitTestHelper.addAllStorageUnits( false );
133:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
134:         UUID productId3 = productTestHelper.getProductId( 3 );
135:         UUID productId4 = productTestHelper.getProductId( 4 );
136:         storageUnitUseCases.addToStock( storageUnitId0, productId3, 3 );
137: 
138:         // then product 3 must not be removable, but product 4 must be removable
139:         assertThrows( ShopException.class,
140:                 () -> productCatalogUseCases.removeProductFromCatalog( productId3 ) );
141:         assertDoesNotThrow( () -> productCatalogUseCases.removeProductFromCatalog( productId4 ) );
142:     }
143: 
144: 
145:     @Test
146:     public void testRemoveProductThatIsInPurchase() {
147:         // given
148:         storageUnitTestHelper.addAllStorageUnits( false );
149:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
150:         UUID productId4 = productTestHelper.getProductId( 4 );
151:         EmailType userEmail4 =
152:                 userTestHelper.getUserEmail( 4 );
153:         storageUnitUseCases.addToStock( storageUnitId0, productId4, 4 );
154: 
155:         // when user 4 adds 4x product 4 to his shopping cart and checks out ...
156:         shoppingCartUseCases.addProductToShoppingCart(
157:                 userEmail4, productId4, 4 );
158:         shoppingCartUseCases.checkout( userEmail4 );
159: 
160:         // then product 4 must not be removable
161:         assertThrows( ShopException.class,
162:                 () -> productCatalogUseCases.removeProductFromCatalog( productId4 ) );
163:     }
164: 
165: 
166:     @Test
167:     public void testClearProductCatalog() {
168:         // given
169:         UUID productId4 = productTestHelper.getProductId( 4 );
170: 
171:         // when
172:         productCatalogUseCases.deleteProductCatalog();
173: 
174:         // then
175:         assertThrows( ShopException.class, () -> productCatalogUseCases.getSalesPrice( productId4 ) );
176:     }
177: 
178: }
179: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\purchase\PurchaseTest.java ---
1: package thkoeln.archilab.ecommerce.tests.purchase;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
14: 
15: import java.util.Map;
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.assertEquals;
19: import static org.junit.jupiter.api.Assertions.assertThrows;
20: 
21: 
22: @SpringBootTest
23: public class PurchaseTest {
24:     @Autowired
25:     private UserRegistrationUseCases userRegistrationUseCases;
26:     @Autowired
27:     private ShoppingCartUseCases shoppingCartUseCases;
28:     @Autowired
29:     private ProductCatalogUseCases productCatalogUseCases;
30:     @Autowired
31:     private StorageUnitUseCases storageUnitUseCases;
32:     @Autowired
33:     private PurchaseUseCases purchaseUseCases;
34:     @Autowired
35:     private Purgatory purgatory;
36:     @Autowired
37:     private UserTestHelper userTestHelper;
38:     @Autowired
39:     private ProductTestHelper productTestHelper;
40:     @Autowired
41:     private StorageUnitTestHelper storageUnitTestHelper;
42: 
43:     private UUID nonExistingId1;
44:     private UUID nonExistingId2;
45: 
46:     @BeforeEach
47:     public void setUp() {
48:         purgatory.deleteEverything();
49:         userTestHelper.registerAllUsers();
50:         productTestHelper.addAllProducts();
51:         storageUnitTestHelper.addAllStorageUnits( true );
52:         nonExistingId1 = UUID.randomUUID();
53:         nonExistingId2 = UUID.randomUUID();
54:     }
55: 
56: 
57:     @Test
58:     public void testPurchaseHistory() {
59:         // given
60:         UUID productId1 = productTestHelper.getProductId( 1 );
61:         UUID productId2 = productTestHelper.getProductId( 2 );
62:         EmailType userEmail7 =
63:                 userTestHelper.getUserEmail( 7 );
64:         Map<UUID, Integer> purchaseHistoryBefore = purchaseUseCases.getPurchaseHistory( userEmail7 );
65: 
66:         // when
67:         shoppingCartUseCases.addProductToShoppingCart(
68:                 userEmail7, productId1, 3 );
69:         shoppingCartUseCases.addProductToShoppingCart(
70:                 userEmail7, productId2, 2 );
71:         shoppingCartUseCases.checkout( userEmail7 );
72:         Map<UUID, Integer> purchaseHistory1 =
73:                 purchaseUseCases.getPurchaseHistory( userEmail7 );
74:         shoppingCartUseCases.addProductToShoppingCart(
75:                 userEmail7, productId1, 6 );
76:         shoppingCartUseCases.addProductToShoppingCart(
77:                 userEmail7, productId2, 2 );
78:         shoppingCartUseCases.checkout( userEmail7 );
79:         Map<UUID, Integer> purchaseHistory2 =
80:                 purchaseUseCases.getPurchaseHistory( userEmail7 );
81:         shoppingCartUseCases.addProductToShoppingCart(
82:                 userEmail7, productId1, 1 );
83:         shoppingCartUseCases.addProductToShoppingCart(
84:                 userEmail7, productId2, 6 );
85:         shoppingCartUseCases.checkout( userEmail7 );
86:         Map<UUID, Integer> purchaseHistory3 =
87:                 purchaseUseCases.getPurchaseHistory( userEmail7 );
88: 
89:         // then
90:         assertEquals( 0, purchaseHistoryBefore.size() );
91:         assertEquals( 2, purchaseHistory1.size() );
92:         assertEquals( 2, purchaseHistory2.size() );
93:         assertEquals( 2, purchaseHistory3.size() );
94:         assertEquals( 3, purchaseHistory1.get( productId1 ) );
95:         assertEquals( 2, purchaseHistory1.get( productId2 ) );
96:         assertEquals( 9, purchaseHistory2.get( productId1 ) );
97:         assertEquals( 4, purchaseHistory2.get( productId2 ) );
98:         assertEquals( 10, purchaseHistory3.get( productId1 ) );
99:         assertEquals( 10, purchaseHistory3.get( productId2 ) );
100:     }
101: 
102: 
103:     @Test
104:     public void testForEmptyPurchaseHistory() {
105:         // given
106:         EmailType userEmail4 =
107:                 userTestHelper.getUserEmail( 4 );
108:         // when
109:         Map<UUID, Integer> purchaseHistory =
110:                 purchaseUseCases.getPurchaseHistory( userEmail4 );
111:         // then
112:         assertEquals( 0, purchaseHistory.size() );
113:     }
114: 
115: 
116:     @Test
117:     public void testInvalidParamsForGetPurchaseQuantityOfProduct() {
118:         // given
119:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
120: 
121:         // when / then
122:         assertThrows ( ShopException.class,
123:                 () -> purchaseUseCases.getPurchaseQuantityOfProduct( null, null ) );
124:         assertThrows ( ShopException.class,
125:                 () -> purchaseUseCases.getPurchaseQuantityOfProduct( nonExistingId1, null ) );
126:         assertThrows ( ShopException.class,
127:                 () -> purchaseUseCases.getPurchaseQuantityOfProduct( null, nonExistingId2 ) );
128:         assertThrows ( ShopException.class,
129:                 () -> purchaseUseCases.getPurchaseQuantityOfProduct( nonExistingId1, nonExistingId2 ) );
130:         assertThrows ( ShopException.class,
131:                 () -> purchaseUseCases.getPurchaseQuantityOfProduct( storageUnitId0, null ) );
132:         assertThrows ( ShopException.class,
133:                 () -> purchaseUseCases.getPurchaseQuantityOfProduct( storageUnitId0, nonExistingId2 ) );
134:     }
135: 
136: 
137:     @Test
138:     public void testInvalidParamsForGetStorageUnitIdForPurchase() {
139:         // given / when / then
140:         assertThrows ( ShopException.class,
141:                 () -> purchaseUseCases.getStorageUnitIdForPurchase( null ) );
142:         assertThrows ( ShopException.class,
143:                 () -> purchaseUseCases.getStorageUnitIdForPurchase( nonExistingId1 ) );
144:     }
145: }
146: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\CheckoutAcceptanceTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingcart;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
14: 
15: import java.util.*;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: 
19: /**
20:  * This test checks the management of stock across storage units. It focuses on the
21:  * cases where more than one storage unit are needed to serve the shopping cart of a user.
22:  */
23: @Slf4j
24: @SpringBootTest
25: public class CheckoutAcceptanceTest {
26:     @Autowired
27:     private UserRegistrationUseCases userRegistrationUseCases;
28:     @Autowired
29:     private ShoppingCartUseCases shoppingCartUseCases;
30:     @Autowired
31:     private ProductCatalogUseCases productCatalogUseCases;
32:     @Autowired
33:     private PurchaseUseCases purchaseUseCases;
34:     @Autowired
35:     private StorageUnitUseCases storageUnitUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private UserTestHelper userTestHelper;
40:     @Autowired
41:     private ProductTestHelper productTestHelper;
42:     @Autowired
43:     private StorageUnitTestHelper storageUnitTestHelper;
44: 
45:     private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
46:                                 map8_11_14_quantity_3_3_4,
47:                                 map10_12_quantity_1_1, 
48:                                 map11_quantity_1, 
49:                                 map12_quantity_10,
50:                                 map8_9_10_11_quantity_2_1_4_2;
51:     private EmailType userEmail3, userEmail6,
52:             userEmail2;
53:     private UUID productId8, productId9, productId10, productId11, productId12,
54:             productId14;
55: 
56: 
57:     @BeforeEach
58:     public void setUp() {
59:         purgatory.deleteEverything();
60:         userTestHelper.registerAllUsers();
61:         productTestHelper.addAllProducts();
62:         storageUnitTestHelper.addAllStorageUnits( true );
63: 
64:         userEmail3 = userTestHelper.getUserEmail( 3 );
65:         userEmail6 = userTestHelper.getUserEmail( 6 );
66:         userEmail2 = userTestHelper.getUserEmail( 2 );
67: 
68:         productId8 = productTestHelper.getProductId( 8 );
69:         productId9 = productTestHelper.getProductId( 9 );
70:         productId10 = productTestHelper.getProductId( 10 );
71:         productId11 = productTestHelper.getProductId( 11 );
72:         productId12 = productTestHelper.getProductId( 12 );
73:         productId14 = productTestHelper.getProductId( 14 );
74: 
75:         map8_11_14_quantity_2_2_2 = new HashMap<>() {{
76:             put( productId8, 2 );
77:             put( productId11, 2 );
78:             put( productId14, 2 );
79:         }};
80:         map8_11_14_quantity_3_3_4 = new HashMap<>() {{
81:             put( productId8, 3 );
82:             put( productId11, 3 );
83:             put( productId14, 4 );
84:         }};
85:         map10_12_quantity_1_1 = new HashMap<>() {{
86:             put( productId10, 1 );
87:             put( productId12, 1 );
88:         }};
89:         map11_quantity_1 = new HashMap<>() {{
90:             put( productId11, 1 );
91:         }};
92:         map12_quantity_10 = new HashMap<>() {{
93:             put( productId12, 10 );
94:         }};
95:         map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
96:             put( productId8, 2 );
97:             put( productId9, 1 );
98:             put( productId10, 4 );
99:             put( productId11, 2 );
100:         }};
101: 
102:     }
103: 
104: 
105:     /**
106:      * Hint: to better understand the expected results of this test, see the distribution of stock
107:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
108:      */
109:     @Test
110:     public void testClosestSingleStorageUnitWins() {
111:         log.info( "testClosestSingleStorageUnitWins" );
112: 
113:         // given
114:         shoppingCartUseCases.addProductToShoppingCart(
115:                 userEmail3, productId8, 2 );
116:         shoppingCartUseCases.addProductToShoppingCart(
117:                 userEmail3, productId11, 2 );
118:         shoppingCartUseCases.addProductToShoppingCart(
119:                 userEmail3, productId14, 2 );
120:         // that basket could have been served from storage unit 4 or 7, but 4 is closer to the user
121:         UUID storageUnitId4 = storageUnitTestHelper.getStorageUnitId( 4 );
122: 
123:         // when
124:         Set<UUID> purchaseIds = shoppingCartUseCases.checkout( userEmail3 );
125: 
126:         // then
127:         checkStorageUnitIds( purchaseIds, storageUnitId4 );
128:         checkProductNumbers( purchaseIds, storageUnitId4, map8_11_14_quantity_2_2_2 );
129:     }
130: 
131: 
132:     /**
133:      * Hint: to better understand the expected results of this test, see the distribution of stock
134:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
135:      */
136:     @Test
137:     public void testStorageUnitWithEnoughCapacityWins() {
138:         log.info( "testStorageUnitWithEnoughCapacityWins" );
139: 
140:         // given
141:         shoppingCartUseCases.addProductToShoppingCart(
142:                 userEmail3, productId8, 3 );
143:         shoppingCartUseCases.addProductToShoppingCart(
144:                 userEmail3, productId11, 3 );
145:         shoppingCartUseCases.addProductToShoppingCart(
146:                 userEmail3, productId14, 4 );
147:         // that basket could have been served from storage unit 4 or 7, 4 is closer to the user,
148:         // but only 7 has enough capacity
149:         UUID storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );
150: 
151:         // when
152:         Set<UUID> purchaseIds = shoppingCartUseCases.checkout( userEmail3 );
153: 
154:         // then
155:         checkStorageUnitIds( purchaseIds, storageUnitId7 );
156:         checkProductNumbers( purchaseIds, storageUnitId7, map8_11_14_quantity_3_3_4 );
157:     }
158: 
159: 
160:     /**
161:      * Hint: to better understand the expected results of this test, see the distribution of stock
162:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
163:      */
164:     @Test
165:     public void testTwoStorageUnits() {
166:         log.info( "testTwoStorageUnits" );
167: 
168:         // given
169:         shoppingCartUseCases.addProductToShoppingCart(
170:                 userEmail6, productId10, 1 );
171:         shoppingCartUseCases.addProductToShoppingCart(
172:                 userEmail6, productId11, 1 );
173:         shoppingCartUseCases.addProductToShoppingCart(
174:                 userEmail6, productId12, 1 );
175:         // that basket needs two shipments (2 + 1 products) anyway, and there
176:         // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
177:         // closer. The smaller can then be served from 4 (closest), 7, or 8.
178:         UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
179:                 // should cover map10_12_quantity_1_1
180:         UUID storageUnitId4 = storageUnitTestHelper.getStorageUnitId( 4 );
181:                 // should cover map11_quantity_1
182: 
183:         // when
184:         Set<UUID> purchaseIds = shoppingCartUseCases.checkout( userEmail6 );
185: 
186:         // then
187:         checkStorageUnitIds( purchaseIds, storageUnitId5, storageUnitId4 );
188:         checkProductNumbers( purchaseIds, storageUnitId5, map10_12_quantity_1_1 );
189:         checkProductNumbers( purchaseIds, storageUnitId4, map11_quantity_1 );
190:     }
191: 
192: 
193:     /**
194:      * Hint: to better understand the expected results of this test, see the distribution of stock
195:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
196:      */
197:     @Test
198:     public void testTwoBigShipments() {
199:         log.info( "testTwoBigShipments" );
200: 
201:         // given
202:         shoppingCartUseCases.addProductToShoppingCart(
203:                 userEmail2, productId8, 2 );
204:         shoppingCartUseCases.addProductToShoppingCart(
205:                 userEmail2, productId9, 1 );
206:         shoppingCartUseCases.addProductToShoppingCart(
207:                 userEmail2, productId10, 4 );
208:         shoppingCartUseCases.addProductToShoppingCart(
209:                 userEmail2, productId11, 2 );
210:         shoppingCartUseCases.addProductToShoppingCart(
211:                 userEmail2, productId12, 10 );
212:         // when
213:         Set<UUID> purchaseIds = shoppingCartUseCases.checkout( userEmail2 );
214:         UUID storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );
215:                 // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 products
216:         UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
217:                 // should cover map12_quantity_10 - the only storage unit with enough capacity for 10 products
218: 
219:         // then
220:         checkStorageUnitIds( purchaseIds, storageUnitId7, storageUnitId5 );
221:         checkProductNumbers( purchaseIds, storageUnitId7, map8_9_10_11_quantity_2_1_4_2 );
222:         checkProductNumbers( purchaseIds, storageUnitId5, map12_quantity_10 );
223:     }
224: 
225: 
226:     /**
227:      * Hint: to better understand the expected results of this test, see the distribution of stock
228:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
229:      */
230:     @Test
231:     public void testOnlyOneSolution() {
232:         log.info( "testOnlyOneSolution" );
233: 
234:         // given
235:         shoppingCartUseCases.addProductToShoppingCart(
236:                 userEmail6, productId12, 10 );
237:         // when
238:         Set<UUID> purchaseIds = shoppingCartUseCases.checkout( userEmail6 );
239:         UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
240:         // should cover map12_quantity_10 - the only storage unit with enough capacity for 10 products
241: 
242:         // then
243:         checkStorageUnitIds( purchaseIds, storageUnitId5 );
244:         checkProductNumbers( purchaseIds, storageUnitId5, map12_quantity_10 );
245:     }
246: 
247: 
248: 
249:     private void checkProductNumbers( Set<UUID> purchaseIds, UUID storageUnitId, Map<UUID, Integer> expectedMap ) {
250:         UUID fittingPurchaseId = null;
251:         for ( UUID purchaseId : purchaseIds ) {
252:             UUID foundStorageUnitId = purchaseUseCases.getStorageUnitIdForPurchase( purchaseId );
253:             if ( foundStorageUnitId.equals( storageUnitId ) ) {
254:                 fittingPurchaseId = purchaseId;
255:                 break;
256:             }
257:         }
258:         assertNotNull( fittingPurchaseId, "No fitting purchase found for storage unit " + storageUnitId );
259: 
260:         int totalExpected = 0;
261:         int totalActual = 0;
262:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
263:             totalExpected += entry.getValue();
264:         }
265:         log.info( "Check purchase numbers for product {} in storage unit {}", fittingPurchaseId, storageUnitId );
266:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
267:             UUID productId = entry.getKey();
268:             Integer foundNumber =
269:                     purchaseUseCases.getPurchaseQuantityOfProduct( fittingPurchaseId, productId );
270:             assertEquals( entry.getValue(), foundNumber );
271:             totalActual += foundNumber;
272:         }
273:         // last check - do the total sums match?
274:         assertEquals( totalExpected, totalActual );
275:     }
276: 
277: 
278:     private void checkStorageUnitIds( Set<UUID> purchaseIds, UUID... expectedStorageUnitIds ) {
279:         assertEquals( expectedStorageUnitIds.length, purchaseIds.size() );
280:         Set<UUID> foundStorageUnitIds = new HashSet<>();
281:         for ( UUID purchaseId : purchaseIds ) {
282:             UUID storageUnitId = purchaseUseCases.getStorageUnitIdForPurchase( purchaseId );
283:             foundStorageUnitIds.add( storageUnitId );
284:         }
285:         for ( UUID expectedStorageUnitId : expectedStorageUnitIds ) {
286:             assertTrue( foundStorageUnitIds.contains( expectedStorageUnitId ) );
287:         }
288:     }
289: 
290: }
291: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\ShoppingCartRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingcart;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.ResultMatcher;
12: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
13: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
14: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
15: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
17: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
18: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
19: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
20: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
21: 
22: import java.util.HashMap;
23: import java.util.Map;
24: import java.util.UUID;
25: 
26: import static org.junit.jupiter.api.Assertions.assertEquals;
27: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
28: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
29: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmail;
30: 
31: 
32: @SpringBootTest
33: @Transactional
34: @AutoConfigureMockMvc
35: @Import( RESTTestHelperConfiguration.class )
36: public class ShoppingCartRESTTest {
37:     @Autowired
38:     private StorageUnitUseCases storageUnitUseCases;
39:     @Autowired
40:     private ShoppingCartUseCases shoppingCartUseCases;
41:     @Autowired
42:     private Purgatory purgatory;
43:     @Autowired
44:     private UserTestHelper userTestHelper;
45:     @Autowired
46:     private ProductTestHelper productTestHelper;
47:     @Autowired
48:     private StorageUnitTestHelper storageUnitTestHelper;
49:     @Autowired
50:     private MockMvc mockMvc;
51:     @Autowired
52:     private ShoppingCartRESTHelper shoppingCartRESTHelper;
53: 
54:     private EmailType nonExistingEmail;
55:     private final Map<UUID, Integer> emptyMap = new HashMap<>();
56: 
57:     private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
58:     private EmailType
59:             userEmail0,
60:             userEmail3,
61:             userEmail6,
62:             userEmail8;
63:     private String userName0, userName8;
64:     private UUID productId0, productId1, productId2, productId3, productId5,
65:                  productId7, productId9, productId11, nonExistentProductId;
66:     private UUID storageUnitId0, storageUnitId3, storageUnitId7, storageUnitId8;
67: 
68: 
69:     private static final ResultMatcher NOT_FOUND = status().isNotFound();
70:     private static final ResultMatcher OK = status().isOk();
71:     private static final ResultMatcher CREATED = status().isCreated();
72:     private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
73:     private static final ResultMatcher CONFLICT = status().isConflict();
74: 
75:     @BeforeEach
76:     public void setUp() {
77:         purgatory.deleteEverything();
78:         userTestHelper.registerAllUsers();
79:         productTestHelper.addAllProducts();
80:         storageUnitTestHelper.addAllStorageUnits( true );
81:         nonExistingEmail = instantiateEmail( "harry@sally.de" );
82: 
83:         userEmail0 = userTestHelper.getUserEmail( 0 );
84:         userEmail3 = userTestHelper.getUserEmail( 3 );
85:         userEmail6 = userTestHelper.getUserEmail( 6 );
86:         userEmail8 = userTestHelper.getUserEmail( 8 );
87:         userName0 = userTestHelper.getUserName( 0 );
88:         userName8 = userTestHelper.getUserName( 8 );
89: 
90:         productId0 = productTestHelper.getProductId( 0 );
91:         productId1 = productTestHelper.getProductId( 1 );
92:         productId2 = productTestHelper.getProductId( 2 );
93:         productId3 = productTestHelper.getProductId( 3 );
94:         productId5 = productTestHelper.getProductId( 5 );
95:         productId7 = productTestHelper.getProductId( 7 );
96:         productId9 = productTestHelper.getProductId( 9 );
97:         productId11 = productTestHelper.getProductId( 11 );
98:         nonExistentProductId = UUID.randomUUID();
99: 
100:         storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
101:         storageUnitId3 = storageUnitTestHelper.getStorageUnitId( 3 );
102:         storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );
103:         storageUnitId8 = storageUnitTestHelper.getStorageUnitId( 8 );
104: 
105:         map9_quantity_1 = new HashMap<>() {{
106:             put( productId9, 1 );
107:         }};
108:         map5_quantity_2 = new HashMap<>() {{
109:             put( productId5, 2 );
110:         }};
111:         map7_quantity_7 = new HashMap<>() {{
112:             put( productId7, 7 );
113:         }};
114:         map9_11_quantity_2_2 = new HashMap<>() {{
115:             put( productId9, 2 );
116:             put( productId11, 2 );
117:         }};
118:     }
119: 
120: 
121:     @Test
122:     public void testInvalidShoppingCartBaseUris() throws Exception {
123:         // given
124:         String allShoppingCartsUri = "/shoppingCarts";
125:         String randomIdUri = "/shoppingCarts/" + UUID.randomUUID();
126:         String randomUserUUID = "/shoppingCarts?userId=" + UUID.randomUUID();
127:         String invalidUserUUID = "/shoppingCarts?userId=invalidUUID";
128:         String randomParamUri = "/shoppingCarts?randomParam=randomValue";
129: 
130:         // when
131:         // then
132:         mockMvc.perform( get( allShoppingCartsUri ) ).andExpect( status().isMethodNotAllowed() );
133:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
134:         mockMvc.perform( get( randomUserUUID ) ).andExpect( status().isNotFound() );
135:         mockMvc.perform( get( invalidUserUUID ) ).andExpect( status().isNotFound() );
136:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
137:     }
138: 
139: 
140:     @Test
141:     public void testInvalidPartUris() throws Exception {
142:         // given
143:         UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail8, emptyMap );
144:         String randomPartUri = "/shoppingCarts/" + shoppingCartId8.toString() + "/random";
145:         String randomProductUri = "/shoppingCarts/" + shoppingCartId8.toString()
146:                 + "/parts/" + UUID.randomUUID();
147: 
148:         // when
149:         // then
150:         mockMvc.perform( post( randomPartUri ) ).andExpect( status().isNotFound() );
151:         mockMvc.perform( delete( randomProductUri ) ).andExpect( status().isNotFound() );
152:     }
153: 
154: 
155:     @Test
156:     public void testInvalidAddToShoppingCart() throws Exception {
157:         // given
158:         Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
159:         expectedStartQuantityMap.put( productId2, 19 );
160: 
161:         // when
162:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( userEmail0, emptyMap );
163:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId, productId2, 6 );
164:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId, productId2, 13 );
165: 
166:         // then
167:         shoppingCartRESTHelper.getQueryShoppingCart( userEmail0, expectedStartQuantityMap );
168: 
169:         // ... and check a couple of invalid cases
170:         shoppingCartRESTHelper.addProductToShoppingCart(
171:                 shoppingCartId, nonExistentProductId, 12, NOT_FOUND );
172:         shoppingCartRESTHelper.addProductToShoppingCart(
173:                 UUID.randomUUID(), productId5, 12, NOT_FOUND );
174:         shoppingCartRESTHelper.addProductToShoppingCart(
175:                 shoppingCartId, productId5, -1, UNPROCESSABLE_ENTITY );
176: 
177:         // check if the shopping cart is still the same
178:         shoppingCartRESTHelper.getQueryShoppingCart( userEmail0, expectedStartQuantityMap );
179:     }
180: 
181: 
182:     @Test
183:     public void testInvalidCheckout_unavailableProduct() throws Exception {
184:         // given
185:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( userEmail0, emptyMap );
186: 
187:         // when
188:         // productId0 is not available in the requested quantity (or rather, not at all)
189:         shoppingCartRESTHelper.addProductToShoppingCart(
190:                 shoppingCartId, productId0, 1, CREATED );
191: 
192:         // check if the shopping cart is still the same
193:         shoppingCartRESTHelper.checkout( shoppingCartId, null, CONFLICT, null );
194:     }
195: 
196: 
197:     @Test
198:     public void testInvalidCheckout_tooLittleStock() throws Exception {
199:         // given
200:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( userEmail0, emptyMap );
201: 
202:         // when
203:         // There are only 10 pieces of productId1 available
204:         shoppingCartRESTHelper.addProductToShoppingCart(
205:                 shoppingCartId, productId1, 11, CREATED );
206: 
207:         // check if the shopping cart is still the same
208:         shoppingCartRESTHelper.checkout( shoppingCartId, null, CONFLICT, null );
209:     }
210: 
211: 
212: 
213:     @Test
214:     public void testDeleteProductFromShoppingCart() throws Exception {
215:         // given
216:         UUID shoppingCartId6 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, emptyMap );
217:         Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
218:         expectedQuantityMap1.put( productId1, 1 );
219:         expectedQuantityMap1.put( productId2, 2 );
220:         expectedQuantityMap1.put( productId3, 3 );
221:         Map<UUID, Integer> quantityMap2 = new HashMap<>();
222:         quantityMap2.put( productId1, 1 );
223:         quantityMap2.put( productId3, 3 );
224: 
225:         // when
226:         // then
227:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId6, productId1, 1 );
228:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId6, productId2, 2 );
229:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId6, productId3, 3 );
230:         shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, expectedQuantityMap1 );
231: 
232:         shoppingCartRESTHelper.deleteProductFromShoppingCart( shoppingCartId6, productId2 );
233:         shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, quantityMap2 );
234:     }
235: 
236: 
237:     @Test
238:     public void testNoDoubleDelete() throws Exception {
239:         // given
240:         UUID shoppingCartId6 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, emptyMap );
241: 
242:         // when
243:         // then
244:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId6, productId3, 3 );
245:         shoppingCartRESTHelper.deleteProductFromShoppingCart( shoppingCartId6, productId3 );
246:         shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, new HashMap<>() );
247:         shoppingCartRESTHelper.deleteProductFromShoppingCart( shoppingCartId6, productId3, NOT_FOUND );
248:     }
249: 
250: 
251:     @Test
252:     public void testAddRemoveProductsFromAndToShoppingCart() throws Exception {
253:         // given
254:         UUID shoppingCartId3 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail3, emptyMap );
255:         UUID shoppingCartId5 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, emptyMap );
256: 
257:         // when
258:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId3, productId1, 2 );
259:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId3, productId2, 3 );
260:         shoppingCartRESTHelper.deleteProductFromShoppingCart( shoppingCartId3, productId1 );
261:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId3, productId1, 1 );
262:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId3, productId2, 6 );
263: 
264:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId5, productId1, 2 );
265:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId5, productId2, 8 );
266:         shoppingCartRESTHelper.deleteProductFromShoppingCart( shoppingCartId5, productId1 );
267:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId5, productId1, 1 );
268:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId5, productId2, 2 );
269: 
270:         // then
271:         // user3 has 1x productId1 and 9x productId2 expected in cart
272:         Map<UUID, Integer> expectedMap3 = new HashMap<>();
273:         expectedMap3.put( productId1, 1 );
274:         expectedMap3.put( productId2, 9 );
275:         shoppingCartRESTHelper.getQueryShoppingCart( userEmail3, expectedMap3 );
276: 
277:         // user6 has 1x productId1 and 10x productId2 in cart
278:         Map<UUID, Integer> expectedMap5 = new HashMap<>();
279:         expectedMap5.put( productId1, 1 );
280:         expectedMap5.put( productId2, 10 );
281:         shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, expectedMap5 );
282:     }
283: 
284: 
285:     @Test
286:     public void testNoDoubleCheckout() throws Exception {
287:         // given
288:         UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail8, emptyMap );
289: 
290:         // when
291:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId8, productId2, 3 );
292: 
293:         // then
294:         shoppingCartRESTHelper.checkout( shoppingCartId8, userName8, CREATED, null );
295:         shoppingCartRESTHelper.checkout( shoppingCartId8, null, CONFLICT, null );
296:     }
297: 
298: 
299:     @Test
300:     public void testCheckout_1_Purchase() throws Exception {
301:         // given:
302:         // User 0 wants to buy 1x product 9. This is in storage unit 5, 7, and 8. Out of these,
303:         // storage unit 8 with zip code 89250 is closest to user 0 with zip code 02314.
304:         Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>() {{
305:             put( storageUnitId8, map9_quantity_1 );
306:         }};
307:         UUID shoppingCartId0 = shoppingCartRESTHelper.getQueryShoppingCart(
308:                 userEmail0, null );
309:         int stock9before =
310:                 storageUnitUseCases.getAvailableStock( storageUnitId8, productId9 );
311: 
312:         // when
313:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId0, productId9, 1 );
314:         shoppingCartRESTHelper.checkout( shoppingCartId0, userName0, CREATED, expectedPurchases );
315:         int stock9after =
316:                 storageUnitUseCases.getAvailableStock( storageUnitId8, productId9 );
317: 
318:         // then
319:         assertEquals( 1, stock9before - stock9after );
320:     }
321: 
322: 
323:     @Test
324:     public void testCheckout_3_Purchase() throws Exception {
325:         // given:
326:         // User 8 (Felix Bauer) wants to buy 2x each of products 5, 9, 11; and 7x product 7.
327:         //       - products 9 and 11 can both be found in storage units 7 and 8. Storage units 7 (76532) is closer to
328:         //         the user (70173)
329:         //       - product 7 is available in storage units 1, 2, and 3, but only storage unit 3 has enough stock.
330:         //       - product 5 is only available in storage unit 0.
331:         Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>() {{
332:             put( storageUnitId0, map5_quantity_2 );
333:             put( storageUnitId3, map7_quantity_7 );
334:             put( storageUnitId7, map9_11_quantity_2_2 );
335:         }};
336:         UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart(
337:                 userEmail8, null );
338:         int stock5before =
339:                 storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
340:         int stock7before =
341:                 storageUnitUseCases.getAvailableStock( storageUnitId3, productId7 );
342:         int stock9before =
343:                 storageUnitUseCases.getAvailableStock( storageUnitId7, productId9 );
344:         int stock11before =
345:                 storageUnitUseCases.getAvailableStock( storageUnitId7, productId11 );
346: 
347:         // when
348:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId8, productId5, 2 );
349:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId8, productId7, 7 );
350:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId8, productId9, 2 );
351:         shoppingCartRESTHelper.addProductToShoppingCart( shoppingCartId8, productId11, 2 );
352:         shoppingCartRESTHelper.checkout( shoppingCartId8, userName8, CREATED, expectedPurchases );
353:         int stock5after =
354:                 storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
355:         int stock7after =
356:                 storageUnitUseCases.getAvailableStock( storageUnitId3, productId7 );
357:         int stock9after =
358:                 storageUnitUseCases.getAvailableStock( storageUnitId7, productId9 );
359:         int stock11after =
360:                 storageUnitUseCases.getAvailableStock( storageUnitId7, productId11 );
361: 
362:         // then
363:         assertEquals( 2, stock5before - stock5after );
364:         assertEquals( 7, stock7before - stock7after );
365:         assertEquals( 2, stock9before - stock9after );
366:         assertEquals( 2, stock11before - stock11after );
367:     }
368: 
369: 
370: }
371: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\ShoppingCartTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingcart;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.InsufficientStockException;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
12: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
13: import thkoeln.archilab.ecommerce.usecases.*;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
16: 
17: 
18: import java.util.Map;
19: import java.util.UUID;
20: 
21: import static org.junit.jupiter.api.Assertions.*;
22: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
23: 
24: @SpringBootTest
25: public class ShoppingCartTest {
26:     @Autowired
27:     private UserRegistrationUseCases userRegistrationUseCases;
28:     @Autowired
29:     private ShoppingCartUseCases shoppingCartUseCases;
30:     @Autowired
31:     private ProductCatalogUseCases productCatalogUseCases;
32:     @Autowired
33:     private StorageUnitUseCases storageUnitUseCases;
34:     @Autowired
35:     private PurchaseUseCases purchaseUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private UserTestHelper userTestHelper;
40:     @Autowired
41:     private ProductTestHelper productTestHelper;
42:     @Autowired
43:     private StorageUnitTestHelper storageUnitTestHelper;
44: 
45:     private EmailType nonExistingEmail;
46: 
47:     @BeforeEach
48:     public void setUp() {
49:         purgatory.deleteEverything();
50:         userTestHelper.registerAllUsers();
51:         productTestHelper.addAllProducts();
52: 
53:         nonExistingEmail = instantiateEmail( "this@nononono.de" );
54:     }
55: 
56: 
57:     @Test
58:     public void testInvalidAddToShoppingCart() {
59:         // given
60:         UUID nonExistentProductId = UUID.randomUUID();
61:         UUID productId5 = productTestHelper.getProductId( 5 );
62:         UUID productId0 = productTestHelper.getProductId( 0 );
63:         EmailType userEmail0 =
64:                 userTestHelper.getUserEmail( 0 );
65:         storageUnitTestHelper.addAllStorageUnits( true );
66: 
67:         // then
68:         assertThrows( ShopException.class,
69:                 () -> shoppingCartUseCases.addProductToShoppingCart(
70:                         nonExistingEmail, productId0, 1 ) );
71:         assertThrows( ShopException.class,
72:                 () -> shoppingCartUseCases.addProductToShoppingCart(
73:                         null, productId0, 1 ) );
74:         assertThrows( ShopException.class,
75:                 () -> shoppingCartUseCases.addProductToShoppingCart(
76:                         userEmail0, nonExistentProductId, 1 ) );
77:         assertThrows( ShopException.class,
78:                 () -> shoppingCartUseCases.addProductToShoppingCart(
79:                         userEmail0, null, 1 ) );
80:         assertThrows( ShopException.class,
81:                 () -> shoppingCartUseCases.addProductToShoppingCart(
82:                         userEmail0, productId5, -1 ) );
83:     }
84: 
85: 
86:     @Test
87:     public void testInvalidRemoveFromShoppingCart() {
88:         // given
89:         UUID nonExistentProductId = UUID.randomUUID();
90:         UUID productId5 = productTestHelper.getProductId( 5 );
91:         UUID productId1 = productTestHelper.getProductId( 1 );
92:         UUID productId2 = productTestHelper.getProductId( 2 );
93:         storageUnitTestHelper.addAllStorageUnits( true );
94:         EmailType userEmail0 =
95:                 userTestHelper.getUserEmail( 0 );
96:         shoppingCartUseCases.addProductToShoppingCart(
97:                 userEmail0, productId1, 5 );
98:         shoppingCartUseCases.addProductToShoppingCart(
99:                 userEmail0, productId2, 15 );
100: 
101:         // when
102:         shoppingCartUseCases.removeProductFromShoppingCart(
103:                 userEmail0, productId1, 2 );
104:         shoppingCartUseCases.removeProductFromShoppingCart(
105:                 userEmail0, productId2, 4 );
106:         shoppingCartUseCases.removeProductFromShoppingCart(
107:                 userEmail0, productId2, 7 );
108:         // now we should have 3x productId1 and 4x productId2 in the shopping cart
109: 
110:         // then
111:         assertThrows( ShopException.class,
112:                 () -> shoppingCartUseCases.removeProductFromShoppingCart(
113:                         userEmail0, nonExistentProductId, 12 ) );
114:         assertThrows( ShopException.class,
115:                 () -> shoppingCartUseCases.removeProductFromShoppingCart(
116:                         nonExistingEmail, productId5, 12 ) );
117:         assertThrows( ShopException.class,
118:                 () -> shoppingCartUseCases.removeProductFromShoppingCart(
119:                         userEmail0, productId5, -1 ) );
120:         assertThrows( ShopException.class,
121:                 () -> shoppingCartUseCases.removeProductFromShoppingCart(
122:                         userEmail0, productId1, 4 ) );
123:         assertThrows( ShopException.class,
124:                 () -> shoppingCartUseCases.removeProductFromShoppingCart(
125:                         userEmail0, productId2, 5 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testAddRemoveProductsFromAndToShoppingCart() {
131:         // given
132:         UUID productId1 = productTestHelper.getProductId( 1 );
133:         UUID productId2 = productTestHelper.getProductId( 2 );
134:         EmailType userEmail3 =
135:                 userTestHelper.getUserEmail( 3 );
136:         EmailType userEmail5 =
137:                 userTestHelper.getUserEmail( 5 );
138: 
139:         // when user 3 ...
140:         shoppingCartUseCases.addProductToShoppingCart(
141:                 userEmail3, productId1, 2 );
142:         shoppingCartUseCases.addProductToShoppingCart(
143:                 userEmail3, productId2, 3 );
144:         shoppingCartUseCases.removeProductFromShoppingCart(
145:                 userEmail3, productId1, 2 );
146:         shoppingCartUseCases.addProductToShoppingCart(
147:                 userEmail3, productId1, 1 );
148:         shoppingCartUseCases.addProductToShoppingCart(
149:                 userEmail3, productId2, 6 );
150:         Map<UUID, Integer> cart3 = shoppingCartUseCases.getShoppingCartAsMap( userEmail3 );
151:         // user3 has 1x productId1 and 9x productId2 in cart
152: 
153:         // ... and when user 5 ...
154:         shoppingCartUseCases.addProductToShoppingCart(
155:                 userEmail5, productId1, 2 );
156:         shoppingCartUseCases.addProductToShoppingCart(
157:                 userEmail5, productId2, 8 );
158:         shoppingCartUseCases.removeProductFromShoppingCart(
159:                 userEmail5, productId1, 1 );
160:         shoppingCartUseCases.addProductToShoppingCart(
161:                 userEmail5, productId2, 2 );
162:         Map<UUID, Integer> cart5 = shoppingCartUseCases.getShoppingCartAsMap( userEmail5 );
163:         // user5 has 1x productId1 and 10x productId2 in cart
164: 
165:         // then
166:         assertEquals( 2, cart3.size() );
167:         assertEquals( 1, cart3.get( productId1 ) );
168:         assertEquals( 9, cart3.get( productId2 ) );
169: 
170:         assertEquals( 2, cart5.size() );
171:         assertEquals( 1, cart5.get( productId1 ) );
172:         assertEquals( 10, cart5.get( productId2 ) );
173:     }
174: 
175: 
176:     @Test
177:     public void testShoppingCartValue() {
178:         // given
179:         UUID productId3 = productTestHelper.getProductId( 3 );
180:         UUID productId6 = productTestHelper.getProductId( 6 );
181:         UUID productId8 = productTestHelper.getProductId( 8 );
182:         MoneyType price3 = productTestHelper.getSalesPrice( 3 );
183:         MoneyType price6 = productTestHelper.getSalesPrice( 6 );
184:         MoneyType price8 = productTestHelper.getSalesPrice( 8 );
185:         EmailType userEmail3 =
186:                 userTestHelper.getUserEmail( 3 );
187: 
188:         // when
189:         shoppingCartUseCases.addProductToShoppingCart( userEmail3, productId3, 3 );
190:         shoppingCartUseCases.addProductToShoppingCart( userEmail3, productId6, 2 );
191:         shoppingCartUseCases.addProductToShoppingCart( userEmail3, productId8, 5 );
192:         // user3 has 3x productId3, 2x productId6 and 5x productId8 in cart
193:         MoneyType cartValue = shoppingCartUseCases.getShoppingCartAsMoneyValue( userEmail3 );
194: 
195:         // then
196:         assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
197:                 cartValue );
198:     }
199: 
200: 
201:     @Test
202:     public void testShoppingCartValueInvalid() {
203:         // given
204:         // when
205:         // then
206:         assertThrows( ShopException.class,
207:                 () -> shoppingCartUseCases.getShoppingCartAsMoneyValue( nonExistingEmail ) );
208:     }
209: 
210: 
211:     @Test
212:     public void testUnsuccessfulCheckout() {
213:         // given user buying product 0 (which is not in stock), and user 1 buying product 1
214:         // in a bigger quantity (11) than available (10)
215:         storageUnitTestHelper.addAllStorageUnits( true );
216:         EmailType userEmail0 =
217:                 userTestHelper.getUserEmail( 0 );
218:         EmailType userEmail1 =
219:                 userTestHelper.getUserEmail( 1 );
220:         UUID productId0 = productTestHelper.getProductId( 0 );
221:         UUID productId1 = productTestHelper.getProductId( 1 );
222: 
223:         // when
224:         shoppingCartUseCases.addProductToShoppingCart(
225:                 userEmail0, productId0, 1 );
226:         shoppingCartUseCases.addProductToShoppingCart(
227:                 userEmail1, productId1, 11 );
228: 
229:         // then
230:         assertThrows( InsufficientStockException.class,
231:                 () -> shoppingCartUseCases.checkout( userEmail0 ) );
232:         assertThrows( InsufficientStockException.class,
233:                 () -> shoppingCartUseCases.checkout( userEmail1 ) );
234:     }
235: 
236: }
237: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\storageunit\StorageUnitManagementTest.java ---
1: package thkoeln.archilab.ecommerce.tests.storageunit;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
12: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
14: 
15: import java.util.UUID;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
19: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
20: 
21: 
22: /**
23:  * This test checks the management and lifecycle of storage units.
24:  */
25: @SpringBootTest
26: public class StorageUnitManagementTest {
27:     @Autowired
28:     private StorageUnitUseCases storageUnitUseCases;
29:     @Autowired
30:     private ProductCatalogUseCases productCatalogUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private ProductTestHelper productTestHelper;
35:     @Autowired
36:     private StorageUnitTestHelper storageUnitTestHelper;
37: 
38:     private PhysicalAddressType somePhysicalAddress;
39:     private UUID nonExistingId1;
40:     private UUID nonExistingId2;
41: 
42: 
43:     @BeforeEach
44:     public void setUp() {
45:         purgatory.deleteEverything();
46:         productTestHelper.addAllProducts();
47: 
48:         somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
49:                 instantiateZipCode( "90001" ) );
50:         nonExistingId1 = UUID.randomUUID();
51:         nonExistingId2 = UUID.randomUUID();
52:     }
53: 
54: 
55:     @Test
56:     public void testAddInvalidStorageUnit() {
57:         // given
58:         String name = "Lager1";
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class,
63:                 () -> storageUnitUseCases.addNewStorageUnit(
64:                         null, somePhysicalAddress ) );
65:         assertThrows( ShopException.class,
66:                 () -> storageUnitUseCases.addNewStorageUnit(
67:                         "", somePhysicalAddress ) );
68:         assertThrows( ShopException.class,
69:                 () -> storageUnitUseCases.addNewStorageUnit(
70:                         name, null ) );
71:     }
72: 
73: 
74:     @Test
75:     public void testDeleteAllStorageUnitsWhenEmpty() {
76:         // given
77:         storageUnitTestHelper.addAllStorageUnits( false );
78:         UUID productId9 = productTestHelper.getProductId( 9 );
79:         UUID storageUnitId1 = storageUnitTestHelper.getStorageUnitId( 1 );
80:         UUID storageUnitId2 = storageUnitTestHelper.getStorageUnitId( 2 );
81: 
82:         // when
83:         int numOf1 = storageUnitUseCases.getAvailableStock( storageUnitId1, productId9 );
84:         int numOf2 = storageUnitUseCases.getAvailableStock( storageUnitId2, productId9 );
85: 
86:         // then
87:         assertEquals( 0, numOf1 );
88:         assertEquals( 0, numOf2 );
89:         storageUnitUseCases.deleteAllStorageUnits();
90:         // ... ids must be invalid now
91:         assertThrows( ShopException.class,
92:                 () -> storageUnitUseCases.getAvailableStock( storageUnitId1, productId9 ) );
93:         assertThrows( ShopException.class,
94:                 () -> storageUnitUseCases.getAvailableStock( storageUnitId2, productId9 ) );
95:     }
96: 
97: 
98:     @Test
99:     public void testDeleteAllStorageUnitsWhenFull() {
100:         // given
101:         storageUnitTestHelper.addAllStorageUnits( true );
102:         UUID productId7 = productTestHelper.getProductId( 7 );
103:         UUID storageUnitId1 = storageUnitTestHelper.getStorageUnitId( 1 );
104:         UUID storageUnitId2 = storageUnitTestHelper.getStorageUnitId( 2 );
105: 
106:         // when
107:         int numOf1 = storageUnitUseCases.getAvailableStock( storageUnitId1, productId7 );
108:         int numOf2 = storageUnitUseCases.getAvailableStock( storageUnitId2, productId7 );
109: 
110:         // then
111:         assertTrue( numOf1 == 3 );
112:         assertTrue( numOf2 == 3 );
113:         storageUnitUseCases.deleteAllStorageUnits();
114:         // ... ids must be invalid now
115:         assertThrows( ShopException.class,
116:                 () -> storageUnitUseCases.getAvailableStock( storageUnitId1, productId7 ) );
117:         assertThrows( ShopException.class,
118:                 () -> storageUnitUseCases.getAvailableStock( storageUnitId2, productId7 ) );
119:     }
120: 
121: 
122: 
123:     @Test
124:     public void testAddToStock() {
125:         // given
126:         storageUnitTestHelper.addAllStorageUnits( true );
127:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in storage unit 0
128:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
129:         int originalStock5 =
130:                 storageUnitTestHelper.getStorageUnitStock( 0, 5 );
131: 
132:         // when
133:         int stock5before = storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
134:         storageUnitUseCases.addToStock( storageUnitId0, productId5, 23 );
135:         int stock5after = storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
136:         storageUnitUseCases.addToStock( storageUnitId0, productId5, 0 );
137:         int stock5after2 = storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
138: 
139:         // then
140:         assertEquals( originalStock5, stock5before );
141:         assertEquals( stock5before + 23, stock5after );
142:         assertEquals( stock5after, stock5after2 );
143:     }
144: 
145: 
146:     @Test
147:     public void testInvalidAddToStock() {
148:         // given
149:         storageUnitTestHelper.addAllStorageUnits( true );
150:         UUID productId2 = productTestHelper.getProductId( 2 );
151:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
152: 
153:         // when
154:         // then
155:         assertThrows( ShopException.class,
156:                 () -> storageUnitUseCases.addToStock( nonExistingId1, nonExistingId2, 12 ) );
157:         assertThrows( ShopException.class,
158:                 () -> storageUnitUseCases.addToStock(
159:                         storageUnitId0, nonExistingId2, 12 ) );
160:         assertThrows( ShopException.class,
161:                 () -> storageUnitUseCases.addToStock(
162:                         nonExistingId1, productId2, 12 ) );
163:         assertThrows( ShopException.class,
164:                 () -> storageUnitUseCases.addToStock(
165:                         storageUnitId0, productId2, -1 ) );
166:     }
167: 
168: 
169:     @Test
170:     public void testRemoveFromStock() {
171:         // given
172:         storageUnitTestHelper.addAllStorageUnits( true );
173:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
174:         UUID productId0 = productTestHelper.getProductId( 0 ); // 0 in storage unit 0
175:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in storage unit 0
176:         UUID productId6 = productTestHelper.getProductId( 6 ); // random >30 in storage unit 0
177:         int stock0before =
178:                 storageUnitTestHelper.getStorageUnitStock( 0, 0 );
179:         int stock5before =
180:                 storageUnitTestHelper.getStorageUnitStock( 0, 5 );
181:         int stock6before =
182:                 storageUnitTestHelper.getStorageUnitStock( 0, 6 );
183: 
184:         // when
185:         storageUnitUseCases.removeFromStock( storageUnitId0, productId5, 1 );
186:         int stock5after = storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
187:         storageUnitUseCases.removeFromStock( storageUnitId0, productId0, 0 );
188:         int stock0after = storageUnitUseCases.getAvailableStock( storageUnitId0, productId0 );
189:         storageUnitUseCases.removeFromStock(
190:                 storageUnitId0, productId6, stock6before );
191:         int stock6after = storageUnitUseCases.getAvailableStock( storageUnitId0, productId6 );
192: 
193:         // then
194:         assertEquals( stock5before - 1, stock5after );
195:         assertEquals( stock0before, stock0after );
196:         assertEquals( 0, stock6after );
197:     }
198: 
199: 
200:     @Test
201:     public void testInvalidRemoveFromStock() {
202:         // given
203:         storageUnitTestHelper.addAllStorageUnits( true );
204:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
205:         UUID productId0 = productTestHelper.getProductId( 0 ); // 0 in storage unit 0
206:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in storage unit 0
207:         int stock5before =
208:                 storageUnitTestHelper.getStorageUnitStock( 0, 5 );
209: 
210:         // when
211:         // then
212:         assertThrows( ShopException.class,
213:                 () -> storageUnitUseCases.removeFromStock( nonExistingId1, nonExistingId2, 12 ) );
214:         assertThrows( ShopException.class,
215:                 () -> storageUnitUseCases.removeFromStock(
216:                         storageUnitId0, nonExistingId2, 12 ) );
217:         assertThrows( ShopException.class,
218:                 () -> storageUnitUseCases.removeFromStock(
219:                         nonExistingId1, productId5, 12 ) );
220:         assertThrows( ShopException.class,
221:                 () -> storageUnitUseCases.removeFromStock(
222:                         storageUnitId0, productId5, -1 ) );
223:         assertThrows( ShopException.class,
224:                 () -> storageUnitUseCases.removeFromStock(
225:                         storageUnitId0, productId5, stock5before + 1 ) );
226:         assertThrows( ShopException.class,
227:                 () -> storageUnitUseCases.removeFromStock(
228:                         storageUnitId0, productId0, 1 ) ); // already 0 in storage unit 0
229:     }
230: 
231: 
232:     @Test
233:     public void testChangeStock() {
234:         // given
235:         storageUnitTestHelper.addAllStorageUnits( true );
236:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
237:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in storage unit 0
238: 
239:         // when
240:         storageUnitUseCases.changeStockTo( storageUnitId0, productId5, 111 );
241:         int stock5after = storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
242: 
243:         // then
244:         assertEquals( 111, stock5after );
245:     }
246: 
247: 
248:     @Test
249:     public void testInvalidChangeStock() {
250:         // given
251:         storageUnitTestHelper.addAllStorageUnits( true );
252:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
253:         UUID productId6 = productTestHelper.getProductId( 6 );
254: 
255:         // when
256:         // then
257:         assertThrows( ShopException.class, () -> storageUnitUseCases.changeStockTo(
258:                 nonExistingId1, nonExistingId2, 12 ) );
259:         assertThrows( ShopException.class, () -> storageUnitUseCases.changeStockTo(
260:                 nonExistingId1, productId6, 12 ) );
261:         assertThrows( ShopException.class, () -> storageUnitUseCases.changeStockTo(
262:                 storageUnitId0, nonExistingId2, 12 ) );
263:         assertThrows( ShopException.class, () -> storageUnitUseCases.changeStockTo(
264:                 storageUnitId0, productId6, -1 ) );
265:     }
266: 
267: 
268:     @Test
269:     public void testEmptyStorageUnit() {
270:         // given
271:         storageUnitTestHelper.addAllStorageUnits( true );
272:         UUID storageUnitId9 = storageUnitTestHelper.getStorageUnitId( 9 ); // empty storage unit
273: 
274:         // when
275:         int totalStock = 0;
276:         for ( int iProduct = 0; iProduct < productTestHelper.numberOfProducts(); iProduct++ ) {
277:             UUID productId = productTestHelper.getProductId( iProduct );
278:             totalStock += storageUnitUseCases.getAvailableStock(
279:                     storageUnitId9, productId );
280:         }
281: 
282:         // then
283:         assertEquals( 0, totalStock );
284:     }
285: 
286: 
287: 
288: }
289: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
1: package thkoeln.archilab.ecommerce.tests.testtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.domain.JavaMethod;
6: import com.tngtech.archunit.core.importer.ClassFileImporter;
7: import com.tngtech.archunit.lang.ArchRule;
8: import org.junit.jupiter.api.BeforeEach;
9: import org.junit.jupiter.api.Test;
10: import org.springframework.web.bind.annotation.RestController;
11: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
12: import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
13: import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingCartRESTTest;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
18: 
19: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
20: import static org.springframework.test.util.AssertionErrors.assertTrue;
21: 
22: /**
23:  * This test checks if there are the appropriate tests in the test class(es) for domain
24:  * primitives.
25:  */
26: 
27: public class RulesForOwnTests {
28:     private JavaClass dpTestClass, restTestClass;
29:     private JavaClasses dpTestClasses, restTestClasses;
30:     private static final String STORAGE_UNIT_DOMAIN_PACKAGE =
31:             "thkoeln.archilab.ecommerce.solution.storageunit.domain";
32:     private static final String STORAGE_UNIT_CLASS_NAME =
33:             STORAGE_UNIT_DOMAIN_PACKAGE + ".StorageUnit";
34: 
35: 
36:     @BeforeEach
37:     public void setUp() throws Exception {
38:         dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
39:         restTestClass = new ClassFileImporter().importClass( OwnShoppingCartRESTTest.class );
40: 
41:         dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
42:         restTestClasses = new ClassFileImporter().importClasses( OwnShoppingCartRESTTest.class );
43:     }
44: 
45: 
46:     @Test
47:     public void ensureMinimumNumberOfTestMethods() {
48:         // given
49:         // when
50:         int dpTestMethodCount = getTestMethodCount( dpTestClass );
51:         int restTestMethodCount = getTestMethodCount( restTestClass );
52: 
53:         // then
54:         assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
55:                         + dpTestMethodCount,dpTestMethodCount >= 2 );
56:         assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
57:                         + restTestMethodCount, restTestMethodCount >= 5 );
58:     }
59: 
60:     private int getTestMethodCount( JavaClass testClass ) {
61:         int testMethodCount = 0;
62:         for ( JavaMethod method : testClass.getMethods() ) {
63:             if ( isTestMethod( method ) ) {
64:                 testMethodCount++;
65:             }
66:         }
67:         return testMethodCount;
68:     }
69: 
70:     private boolean isTestMethod( JavaMethod method ) {
71:         return method.isAnnotatedWith( Test.class );
72:     }
73: 
74: 
75:     @Test
76:     public void dpTestsShouldReferenceTheRightClasses() {
77:         ArchRule rule = classes()
78:                 .should().dependOnClassesThat()
79:                 .areAssignableTo( ZipCodeType.class )
80:                 .andShould().dependOnClassesThat()
81:                 .areAssignableTo( MoneyType.class )
82:                 .andShould().dependOnClassesThat()
83:                 .areAssignableTo( PhysicalAddressType.class )
84:                 .andShould().dependOnClassesThat()
85:                 .areAssignableTo( EmailType.class )
86:                 .because( "DomainPrimitiveJSONSerializationTest should reference ZipCode, " +
87:                         "Money, Email, and PhysicalAddress!" );
88:         rule.check( dpTestClasses );
89:     }
90: 
91: 
92:     @Test
93:     public void restTestsShouldReferenceEmail() {
94:         ArchRule rule = classes()
95:                 .should().dependOnClassesThat()
96:                 .areAssignableTo( EmailType.class )
97:                 .because( "StorageUnitComparatorUnitTest should reference EmailType!" );
98:         rule.check( restTestClasses );
99:     }
100: 
101: 
102:     @Test
103:     public void restTestsShouldReferenceRESTControllers() {
104:         ArchRule rule = classes()
105:                 .should().dependOnClassesThat()
106:                 .areAnnotatedWith( RestController.class )
107:                 .orShould().dependOnClassesThat()
108:                 .areAssignableTo( ShoppingCartRESTHelper.class )
109:                 .because( "StorageUnitComparatorUnitTest should call REST controllers! " +
110:                         "(either directly or via the ShoppingCartRESTHelper REST helper)" );
111:         rule.check( restTestClasses );
112:     }
113: 
114: }
115: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\user\UserRegistrationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.user;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
12: import thkoeln.archilab.ecommerce.usecases.UserType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
15: 
16: import static org.junit.jupiter.api.Assertions.*;
17: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
18: 
19: 
20: @SpringBootTest
21: public class UserRegistrationTest {
22:     @Autowired
23:     private UserRegistrationUseCases userRegistrationUseCases;
24:     @Autowired
25:     private Purgatory purgatory;
26:     @Autowired
27:     private UserTestHelper userTestHelper;
28: 
29:     private EmailType nonExistingEmail;
30:     private PhysicalAddressType somePhysicalAddress;
31: 
32:     @BeforeEach
33:     public void setUp() {
34:         purgatory.deleteEverything();
35:         nonExistingEmail = instantiateEmail( "this@nononono.de" );
36:         somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
37:                 instantiateZipCode( "90001" ) );
38:     }
39: 
40:     @Test
41:     public void testAllUsersRegistered() {
42:         // given
43:         userTestHelper.registerAllUsers();
44:         EmailType email3 =
45:                 userTestHelper.getUserEmail( 3 );
46:         String name3 = userTestHelper.getUserName( 3 );
47:         PhysicalAddressType physicalAddress3 = userTestHelper.getUserPhysicalAddress( 3 );
48: 
49:         // when
50:         UserType user3 = userRegistrationUseCases.getUserData(
51:                 email3 );
52: 
53:         // then
54:         Assertions.assertEquals( name3, user3.getName() );
55:         Assertions.assertEquals( email3, user3.getEmail() );
56:         Assertions.assertEquals( physicalAddress3, user3.getPhysicalAddress() );
57:     }
58: 
59: 
60:     @Test
61:     public void testRegisterUserWithDuplicateEmail() {
62:         // given
63:         userTestHelper.registerAllUsers();
64:         PhysicalAddressType physicalAddress5 = userTestHelper.getUserPhysicalAddress( 5 );
65:         EmailType email5 =
66:                 userTestHelper.getUserEmail( 5 );
67: 
68:         // when
69:         // then
70:         assertThrows( ShopException.class, () ->
71:                 userRegistrationUseCases.register( "Gandalf The Grey",
72:                         email5, physicalAddress5 ) );
73:     }
74: 
75: 
76:     @Test
77:     public void testRegisterUserWithDuplicateNameOrPhysicalAddress() {
78:         // given
79:         userTestHelper.registerAllUsers();
80:         EmailType newEmail =
81:                 instantiateEmail( "some@this.de" );
82:         PhysicalAddressType physicalAddress2 = userTestHelper.getUserPhysicalAddress( 2 );
83:         String name2 = userTestHelper.getUserName( 2 );
84: 
85:         // when
86:         // then
87:         assertDoesNotThrow( () ->
88:                 userRegistrationUseCases.register( name2, newEmail, physicalAddress2 ) );
89:     }
90: 
91: 
92:     @Test
93:     public void testRegisterUserWithInvalidData() {
94:         // given
95:         EmailType email5 =
96:                 userTestHelper.getUserEmail( 5 );
97:         PhysicalAddressType physicalAddress5 = userTestHelper.getUserPhysicalAddress( 5 );
98:         String name5 = userTestHelper.getUserName( 5 );
99: 
100:         // when
101:         // then
102:         assertThrows( ShopException.class, () ->
103:                 userRegistrationUseCases.register( null, email5, physicalAddress5 ) );
104:         assertThrows( ShopException.class, () ->
105:                 userRegistrationUseCases.register("", email5, physicalAddress5 ) );
106:         assertThrows( ShopException.class, () ->
107:                 userRegistrationUseCases.register( name5, null, physicalAddress5 ) );
108:         assertThrows( ShopException.class, () ->
109:                 userRegistrationUseCases.register( name5, email5, null ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testChangeAddressWithInvalidData() {
115:         // given
116:         userTestHelper.registerAllUsers();
117:         PhysicalAddressType physicalAddress7 = userTestHelper.getUserPhysicalAddress( 7 );
118:         EmailType email7 =
119:                 userTestHelper.getUserEmail( 7 );
120: 
121:         // when
122:         // then
123:         assertThrows( ShopException.class, () ->
124:                 userRegistrationUseCases.changeAddress( nonExistingEmail, physicalAddress7 ) );
125:         assertThrows( ShopException.class, () ->
126:                 userRegistrationUseCases.changeAddress( null, physicalAddress7 ) );
127:         assertThrows( ShopException.class, () ->
128:                 userRegistrationUseCases.changeAddress( email7, null ) );
129:     }
130: 
131: 
132:     @Test
133:     public void testGetDataForNonexistingEmail() {
134:         // given
135:         userTestHelper.registerAllUsers();
136: 
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 userRegistrationUseCases.getUserData( nonExistingEmail ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testDeleteUsersNoMoreUsers() {
146:         // given
147:         userTestHelper.registerAllUsers();
148:         EmailType email0 =
149:                 userTestHelper.getUserEmail( 0 );
150: 
151: 
152:         // when
153:         userRegistrationUseCases.deleteAllUsers();
154: 
155:         // then
156:         assertThrows( ShopException.class, () -> userRegistrationUseCases.getUserData(
157:                 email0 ) );
158:     }
159: 
160: 
161:     @Test
162:     public void testChangeAddressSuccessful() {
163:         // given
164:         userTestHelper.registerAllUsers();
165:         EmailType email6 =
166:                 userTestHelper.getUserEmail( 6 );
167: 
168:         // when
169:         userRegistrationUseCases.changeAddress( email6, somePhysicalAddress );
170:         UserType newUser6 =
171:                 userRegistrationUseCases.getUserData( email6 );
172: 
173:         // then
174:         Assertions.assertEquals( email6, newUser6.getEmail() );
175:         Assertions.assertEquals( somePhysicalAddress, newUser6.getPhysicalAddress() );
176:     }
177: 
178: 
179:     @Test
180:     public void testChangeAddressForNonexistingEmail() {
181:         // given
182:         userTestHelper.registerAllUsers();
183: 
184:         // when
185:         // then
186:         assertThrows( ShopException.class, () ->
187:                 userRegistrationUseCases.changeAddress( nonExistingEmail, somePhysicalAddress ) );
188:     }
189: 
190: 
191: }
192: 

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_2767082b-b468-438e-b617-5205499d6937\src\test\java\thkoeln\archilab\ecommerce\tests\user\UserRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.user;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
12: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
13: import thkoeln.archilab.ecommerce.usecases.UserType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
16: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
17: 
18: import java.util.UUID;
19: 
20: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
21: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
22: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
23: 
24: @SpringBootTest
25: @Transactional
26: @AutoConfigureMockMvc
27: @Import( RESTTestHelperConfiguration.class )
28: public class UserRESTTest {
29:     @Autowired
30:     private UserRegistrationUseCases userRegistrationUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private UserTestHelper userTestHelper;
35:     @Autowired
36:     private MockMvc mockMvc;
37: 
38:     private UUID randomId;
39:     private EmailType nonExistingEmail;
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         userTestHelper.registerAllUsers();
45: 
46:         nonExistingEmail = FactoryMethodInvoker.instantiateEmail(
47:                 "harry@sally.de" );
48:         randomId = UUID.randomUUID();
49:     }
50: 
51: 
52:     @Test
53:     public void testInvalidUserUris() throws Exception {
54:         // given
55:         String allUsersUri = "/users";
56:         String randomIdUri = "/users/" +  randomId;
57:         String nonExistingEmailUri = "/users?email=" + nonExistingEmail;
58:         String randomParamUri = "/users?randomParam=randomValue";
59: 
60:         // when
61:         // then
62:         mockMvc.perform( get( allUsersUri ) ).andExpect( status().isMethodNotAllowed() );
63:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
64:         mockMvc.perform( get( nonExistingEmailUri ) ).andExpect( status().isNotFound() );
65:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
66:     }
67: 
68: 
69:     @Test
70:     public void testRandomUserId() throws Exception {
71:         // given
72:         String invalidUri = "/users/" +  randomId;
73: 
74:         // when
75:         // then
76:         mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
77:     }
78: 
79: 
80:     @Test
81:     public void testQueryUser() throws Exception {
82:         // given
83:         EmailType email4 =
84:                 userTestHelper.getUserEmail( 4 );
85:         String userUri4 = "/users?email=" + email4;
86: 
87:         // when
88:         UserType user4 = userRegistrationUseCases.getUserData( email4 );
89:         String name = userTestHelper.getUserName( 4 );
90:         PhysicalAddressType physicalAddress4 = userTestHelper.getUserPhysicalAddress( 4 );
91: 
92:         // then (check using JSONPath)
93:         mockMvc.perform( get( userUri4 ) )
94:                 .andExpect( status().isOk() )
95:                 .andExpect( jsonPath( "$.name" ).value( name ) )
96:                 // id is position 0 (cannot be tested with current API structure), name is position 1,
97:                 // email is 2, physical address is 3)
98:                 .andExpect( jsonPath( "$..emailString" ).value( email4.toString() ) )
99:                 .andExpect( jsonPath( "$..city" ).value( physicalAddress4.getCity() ) )
100:                 .andExpect( jsonPath( "$..zipCodeString" ).value(
101:                         physicalAddress4.getZipCode().toString() ) );
102:     }
103: 
104: }
105: 

[RESPONSE]:

Generated by deepseek-reasoner
-----------------------------------