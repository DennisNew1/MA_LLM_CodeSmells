--- DATE: 13.1.2026, 15:23:43 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
        Architektur: 4-Layer (Eric Evans).
        Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
        Regeln:
        1. Begründe kurz jeden Fund.
        4. Gruppiere nach Datei (mit Pfad). 
        2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
        3. Keine Code-Wiederholung, nur Referenzen.
        5. Wenn fertig, schreibe "ENDE". 
        6. Nutze die Zeilenangaben die mitgeschickt worden sind.



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Address.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Embeddable;
4: import jakarta.persistence.Embedded;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
10: 
11: import java.util.Objects;
12: 
13: @Embeddable
14: @NoArgsConstructor
15: @Getter
16: public class Address implements AddressType {
17:     private String street;
18:     private String city;
19:     @Embedded
20:     private ZipCode zipCode;
21: 
22:     public Address(String street, String city, ZipCodeType zipCode) {
23:         this.street = street;
24:         this.city = city;
25:         this.zipCode = (ZipCode) zipCode;
26:     }
27: 
28:     public static Address of(String street, String city, ZipCodeType zipCode) {
29:         if (street == null || street.isEmpty()) {
30:             throw new ShopException("Street cannot be null or empty");
31:         }
32:         if (city == null || city.isEmpty()) {
33:             throw new ShopException("City cannot be null or empty");
34:         }
35:         if (zipCode == null) {
36:             throw new ShopException("ZipCode cannot be null");
37:         }
38: 
39:         return new Address(street, city, zipCode);
40:     }
41: 
42:     @Override
43:     public String getStreet() {
44:         return street;
45:     }
46: 
47:     @Override
48:     public String getCity() {
49:         return city;
50:     }
51: 
52:     @Override
53:     public ZipCode getZipCode() {
54:         return zipCode;
55:     }
56: 
57:     @Override
58:     public boolean equals(Object o) {
59:         if (this == o) return true;
60:         if (o == null || getClass() != o.getClass()) return false;
61:         Address address = (Address) o;
62:         return Objects.equals(street, address.street) &&
63:                 Objects.equals(city, address.city) &&
64:                 Objects.equals(zipCode, address.zipCode);
65:     }
66: 
67:     @Override
68:     public int hashCode() {
69:         return Objects.hash(street, city, zipCode);
70:     }
71: }
72: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ConflictException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public class ConflictException extends ShopException {
6:     public ConflictException(String message) {
7:         super(message);
8:     }
9: }
10: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\CustomerTypeImpl.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.NoArgsConstructor;
5: import thkoeln.archilab.ecommerce.usecases.CustomerType;
6: 
7: @Embeddable
8: @NoArgsConstructor
9: public class CustomerTypeImpl implements CustomerType {
10:     private String name;
11:     private MailAddress mailAddress;
12:     private Address address;
13: 
14:     public CustomerTypeImpl(String name, MailAddress mailAddress, Address address) {
15:         this.name = name;
16:         this.mailAddress = mailAddress;
17:         this.address = address;
18:     }
19: 
20:     @Override
21:     public String getName() {
22:         return name;
23:     }
24: 
25:     @Override
26:     public MailAddress getMailAddress() {
27:         return mailAddress;
28:     }
29: 
30:     @Override
31:     public Address getAddress() {
32:         return address;
33:     }
34: }
35: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\MailAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Column;
4: import jakarta.persistence.Embeddable;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
9: 
10: import java.util.Objects;
11: 
12: @Embeddable
13: @NoArgsConstructor
14: @Getter
15: public class MailAddress implements MailAddressType {
16:     @Column(unique = true)
17:     private String mailAddress;
18: 
19:     private MailAddress(String mailAddress) {
20:         this.mailAddress = mailAddress;
21:     }
22: 
23:     public static MailAddress of(String mailAddressAsString) {
24:         if (mailAddressAsString == null) {
25:             throw new ShopException("Mail address cannot be null");
26:         }
27: 
28:         if (!isValidMailAddress(mailAddressAsString)) {
29:             throw new ShopException("Invalid mail address format");
30:         }
31: 
32:         return new MailAddress(mailAddressAsString);
33:     }
34: 
35:     private static boolean isValidMailAddress(String mailAddress) {
36:         if (mailAddress == null) return false;
37: 
38:         String[] parts = mailAddress.split("@");
39:         if (parts.length != 2) return false;
40: 
41:         String identifier = parts[0];
42:         String domain = parts[1];
43: 
44:         // Check identifier
45:         if (identifier.isEmpty() || !identifier.matches("^[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*$")) {
46:             return false;
47:         }
48:         if (identifier.contains("..")) return false;
49: 
50:         // Check domain
51:         if (domain.isEmpty() || !domain.matches("^[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*$")) {
52:             return false;
53:         }
54:         if (domain.contains("..")) return false;
55: 
56:         // Check TLD
57:         if (!domain.matches(".*\\.(de|at|ch|com|org)$")) {
58:             return false;
59:         }
60: 
61:         return true;
62:     }
63: 
64:     @Override
65:     public String toString() {
66:         return mailAddress;
67:     }
68: 
69:     @Override
70:     public MailAddressType sameIdentifyerDifferentDomain(String domainString) {
71:         if (domainString == null) {
72:             throw new ShopException("Domain string cannot be null");
73:         }
74: 
75:         String identifier = mailAddress.split("@")[0];
76:         String newMailAddress = identifier + "@" + domainString;
77: 
78:         return MailAddress.of(newMailAddress);
79:     }
80: 
81:     @Override
82:     public MailAddressType sameDomainDifferentIdentifyer(String identifyerString) {
83:         if (identifyerString == null) {
84:             throw new ShopException("Identifier string cannot be null");
85:         }
86: 
87:         String domain = mailAddress.split("@")[1];
88:         String newMailAddress = identifyerString + "@" + domain;
89: 
90:         return MailAddress.of(newMailAddress);
91:     }
92: 
93:     @Override
94:     public boolean equals(Object o) {
95:         if (this == o) return true;
96:         if (o == null || getClass() != o.getClass()) return false;
97:         MailAddress that = (MailAddress) o;
98:         return Objects.equals(mailAddress, that.mailAddress);
99:     }
100: 
101:     @Override
102:     public int hashCode() {
103:         return Objects.hash(mailAddress);
104:     }
105: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Column;
4: import jakarta.persistence.Embeddable;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
8: 
9: import java.util.Objects;
10: 
11: @Embeddable
12: @NoArgsConstructor
13: public class Money implements MoneyType {
14:     @Column(name = "amount")
15:     private Float amount;
16:     @Column(name = "currency_unit")
17:     private String currencyUnit;
18: 
19:     private Money(Float amount, String currencyUnit) {
20:         this.amount = amount;
21:         this.currencyUnit = currencyUnit;
22:     }
23: 
24:     public static Money of(Float amount, String currencyUnit) {
25:         if (amount == null) {
26:             throw new ShopException("Amount cannot be null");
27:         }
28:         if (amount < 0) {
29:             throw new ShopException("Amount cannot be negative");
30:         }
31:         if (currencyUnit == null) {
32:             throw new ShopException("Currency unit cannot be null");
33:         }
34:         if (!currencyUnit.equals("EUR") && !currencyUnit.equals("CHF")) {
35:             throw new ShopException("Invalid currency unit");
36:         }
37: 
38:         return new Money(amount, currencyUnit);
39:     }
40: 
41:     @Override
42:     public Float getAmount() {
43:         return amount;
44:     }
45: 
46:     @Override
47:     public String getCurrencyUnit() {
48:         return currencyUnit;
49:     }
50: 
51:     @Override
52:     public MoneyType add(MoneyType otherMoney) {
53:         if (otherMoney == null) {
54:             throw new ShopException("Other money cannot be null");
55:         }
56:         if (!this.currencyUnit.equals(otherMoney.getCurrencyUnit())) {
57:             throw new ShopException("Currency units must match");
58:         }
59: 
60:         return Money.of(this.amount + otherMoney.getAmount(), this.currencyUnit);
61:     }
62: 
63:     @Override
64:     public MoneyType subtract(MoneyType otherMoney) {
65:         if (otherMoney == null) {
66:             throw new ShopException("Other money cannot be null");
67:         }
68:         if (!this.currencyUnit.equals(otherMoney.getCurrencyUnit())) {
69:             throw new ShopException("Currency units must match");
70:         }
71:         if (otherMoney.largerThan(this)) {
72:             throw new ShopException("Cannot subtract larger amount");
73:         }
74: 
75:         return Money.of(this.amount - otherMoney.getAmount(), this.currencyUnit);
76:     }
77: 
78:     @Override
79:     public MoneyType multiplyBy(int factor) {
80:         if (factor < 0) {
81:             throw new ShopException("Factor cannot be negative");
82:         }
83: 
84:         return Money.of(this.amount * factor, this.currencyUnit);
85:     }
86: 
87:     @Override
88:     public boolean largerThan(MoneyType otherMoney) {
89:         if (otherMoney == null) {
90:             throw new ShopException("Other money cannot be null");
91:         }
92:         if (!this.currencyUnit.equals(otherMoney.getCurrencyUnit())) {
93:             throw new ShopException("Currency units must match");
94:         }
95: 
96:         return this.amount > otherMoney.getAmount();
97:     }
98: 
99:     @Override
100:     public boolean equals(Object o) {
101:         if (this == o) return true;
102:         if (o == null || getClass() != o.getClass()) return false;
103:         Money money = (Money) o;
104:         return Float.compare(money.amount, amount) == 0 &&
105:                 Objects.equals(currencyUnit, money.currencyUnit);
106:     }
107: 
108:     @Override
109:     public int hashCode() {
110:         return Objects.hash(amount, currencyUnit);
111:     }
112: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\NotFoundException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public class NotFoundException extends ShopException {
6:     public NotFoundException(String message) {
7:         super(message);
8:     }
9: }
10: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\UnprocessableException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public class UnprocessableException extends ShopException {
6:     public UnprocessableException(String message) {
7:         super(message);
8:     }
9: }
10: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Column;
4: import jakarta.persistence.Embeddable;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
9: 
10: import java.util.Objects;
11: 
12: @Embeddable
13: @NoArgsConstructor
14: @Getter
15: public class ZipCode implements ZipCodeType {
16:     @Column(name = "zip_code")
17:     private String zipCode;
18: 
19:     private ZipCode(String zipCode) {
20:         this.zipCode = zipCode;
21:     }
22: 
23:     public static ZipCode of(String zipCodeAsString) {
24:         if (zipCodeAsString == null) {
25:             throw new ShopException("Zip code cannot be null");
26:         }
27:         if (!isValidZipCode(zipCodeAsString)) {
28:             throw new ShopException("Invalid zip code format");
29:         }
30: 
31:         return new ZipCode(zipCodeAsString);
32:     }
33: 
34:     private static boolean isValidZipCode(String zipCode) {
35:         if (zipCode == null) return false;
36:         if (!zipCode.matches("\\d{5}")) return false;
37: 
38:         String lastFourDigits = zipCode.substring(1);
39:         return !lastFourDigits.equals("0000");
40:     }
41: 
42:     @Override
43:     public String toString() {
44:         return zipCode;
45:     }
46: 
47:     @Override
48:     public int difference(ZipCodeType otherZipCode) {
49:         if (otherZipCode == null) {
50:             throw new ShopException("Other zip code cannot be null");
51:         }
52: 
53:         String other = otherZipCode.toString();
54:         if (this.zipCode.equals(other)) {
55:             return 0;
56:         }
57: 
58:         int thisFirstDigit = Character.getNumericValue(this.zipCode.charAt(0));
59:         int otherFirstDigit = Character.getNumericValue(other.charAt(0));
60: 
61:         if (thisFirstDigit != otherFirstDigit) {
62:             int digitDiff = Math.abs(thisFirstDigit - otherFirstDigit);
63:             digitDiff = Math.min(digitDiff, 10 - digitDiff);
64:             return 100 + digitDiff;
65:         }
66: 
67:         int diffPosition = 1;
68:         while (diffPosition < 5 && this.zipCode.charAt(diffPosition) == other.charAt(diffPosition)) {
69:             diffPosition++;
70:         }
71: 
72:         return 5 - diffPosition;
73:     }
74: 
75:     @Override
76:     public Integer getFirstDigitZipCode() {
77:         return Character.getNumericValue(zipCode.charAt(0));
78:     }
79: 
80:     @Override
81:     public boolean equals(Object o) {
82:         if (this == o) return true;
83:         if (o == null || getClass() != o.getClass()) return false;
84:         ZipCode zipCode1 = (ZipCode) o;
85:         return Objects.equals(zipCode, zipCode1.zipCode);
86:     }
87: 
88:     @Override
89:     public int hashCode() {
90:         return Objects.hash(zipCode);
91:     }
92: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
1: /*
2:  * Authored by ArchiLab 2025, TH Köln - not for distribution
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.Column;
7: import jakarta.persistence.MappedSuperclass;
8: import lombok.EqualsAndHashCode;
9: import lombok.Getter;
10: import lombok.ToString;
11: 
12: import java.io.Serializable;
13: import java.util.UUID;
14: 
15: @MappedSuperclass
16: @Getter
17: @EqualsAndHashCode(of = "id")
18: @ToString(of = "id")
19: public abstract class GenericId implements Serializable {
20:     @Column(nullable = false, updatable = false)
21:     private final UUID id;
22: 
23:     protected GenericId() {
24:         this( UUID.randomUUID() );
25:     }
26: 
27:     protected GenericId( UUID id ) {
28:         this.id = id;
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
1: /*
2:  * Authored by ArchiLab 2025, TH Köln - not for distribution
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.AttributeConverter;
7: 
8: import java.util.UUID;
9: import java.util.function.Function;
10: 
11: 
12: public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
13:     private final Function<UUID, T> factory;
14: 
15:     protected GenericIdConverter( Function<UUID, T> factory ) {
16:         this.factory = factory;
17:     }
18: 
19:     @Override
20:     public UUID convertToDatabaseColumn( T attribute ) {
21:         return attribute == null ? null : attribute.getId();
22:     }
23: 
24:     @Override
25:     public T convertToEntityAttribute( UUID dbData ) {
26:         return dbData == null ? null : factory.apply( dbData );
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\InsufficientInventoryException.java ---
1: /*
2:  * Authored by ArchiLab 2025, TH Köln - not for distribution
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: /**
7:  * Exception is thrown if the merchandise's inventory level is not sufficient to serve the purchase.
8:  */
9: public class InsufficientInventoryException extends ShopException {
10:     public InsufficientInventoryException( String message ) {
11:         super( message );
12:     }
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
1: /*
2:  * Authored by ArchiLab 2025, TH Köln - not for distribution
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import org.springframework.boot.SpringApplication;
7: import org.springframework.boot.autoconfigure.SpringBootApplication;
8: 
9: 
10: @SpringBootApplication
11: public class ProjectApplication {
12: 
13: 	/**
14: 	 * Entry method
15: 	 * @param args
16: 	 */
17: 	public static void main(String[] args) {
18: 		SpringApplication.run(ProjectApplication.class, args);
19: 	}
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
1: /*
2:  * Authored by ArchiLab 2025, TH Köln - not for distribution
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: public class ShopException extends RuntimeException {
7:     public ShopException( String message ) {
8:         super( message );
9:     }
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerController.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.application;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.http.ResponseEntity;
5: import org.springframework.web.bind.annotation.*;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.domainprimitives.ConflictException;
8: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
9: import thkoeln.archilab.ecommerce.domainprimitives.NotFoundException;
10: import thkoeln.archilab.ecommerce.domainprimitives.UnprocessableException;
11: import thkoeln.archilab.ecommerce.usecases.CustomerType;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
15: 
16: import java.util.UUID;
17: 
18: @RestController
19: @RequestMapping("/customers")
20: public class CustomerController {
21:     private final CustomerService customerService;
22: 
23:     public CustomerController(CustomerService customerService) {
24:         this.customerService = customerService;
25:     }
26: 
27:     @GetMapping
28:     public ResponseEntity<?> getCustomerByMailAddress(
29:             @RequestParam(value = "mailAddress", required = false) String mailAddressString) {
30:         if (mailAddressString == null || mailAddressString.isEmpty()) {
31:             return new ResponseEntity<>(HttpStatus.METHOD_NOT_ALLOWED);
32:         }
33: 
34:         try {
35:             MailAddressType mailAddress = MailAddress.of(mailAddressString);
36:             CustomerType customer = customerService.getCustomerData(mailAddress);
37:             return ResponseEntity.ok(mapToResponse(customer));
38:         } catch (ShopException e) {
39:             return new ResponseEntity<>(HttpStatus.NOT_FOUND);
40:         }
41:     }
42: 
43:     private CustomerResponse mapToResponse(CustomerType customer) {
44:         return new CustomerResponse(
45:                 UUID.nameUUIDFromBytes(customer.getMailAddress().toString().getBytes()),
46:                 customer.getName(),
47:                 new MailAddressResponse(customer.getMailAddress()),
48:                 new AddressResponse(customer.getAddress())
49:         );
50:     }
51: 
52:     public static class CustomerResponse {
53:         private final UUID id;
54:         private final String name;
55:         private final MailAddressResponse mailAddress;
56:         private final AddressResponse address;
57: 
58:         public CustomerResponse(UUID id, String name, MailAddressResponse mailAddress,
59:                                 AddressResponse address) {
60:             this.id = id;
61:             this.name = name;
62:             this.mailAddress = mailAddress;
63:             this.address = address;
64:         }
65: 
66:         public UUID getId() {
67:             return id;
68:         }
69: 
70:         public String getName() {
71:             return name;
72:         }
73: 
74:         public MailAddressResponse getMailAddress() {
75:             return mailAddress;
76:         }
77: 
78:         public AddressResponse getAddress() {
79:             return address;
80:         }
81:     }
82: 
83:     public static class MailAddressResponse {
84:         private final String mailAddressString;
85: 
86:         public MailAddressResponse(MailAddressType mailAddress) {
87:             this.mailAddressString = mailAddress.toString();
88:         }
89: 
90:         public String getMailAddressString() { return mailAddressString; }
91:     }
92: 
93:     public static class AddressResponse {
94:         private final String street;
95:         private final String city;
96:         private final ZipCodeResponse zipCode;
97: 
98:         public AddressResponse(AddressType address) {
99:             this.street = address.getStreet();
100:             this.city = address.getCity();
101:             this.zipCode = new ZipCodeResponse(address.getZipCode());
102:         }
103: 
104:         public String getStreet() {
105:             return street;
106:         }
107:         public String getCity() {
108:             return city;
109:         }
110:         public ZipCodeResponse getZipCode() {
111:             return zipCode;
112:         }
113:     }
114: 
115:     public static class ZipCodeResponse {
116:         private final String zipCodeString;
117: 
118:         public ZipCodeResponse(ZipCodeType zipCode) {
119:             this.zipCodeString = zipCode.toString();
120:         }
121: 
122:         public String getZipCodeString() {
123:             return zipCodeString;
124:         }
125:     }
126: 
127:     @ExceptionHandler(NotFoundException.class)
128:     public ResponseEntity<?> handleNotFound(NotFoundException e) {
129:         return new ResponseEntity<>(HttpStatus.NOT_FOUND);
130:     }
131: 
132:     @ExceptionHandler(UnprocessableException.class)
133:     public ResponseEntity<?> handleUnprocessable(UnprocessableException e) {
134:         return new ResponseEntity<>(HttpStatus.UNPROCESSABLE_ENTITY);
135:     }
136: 
137:     @ExceptionHandler(ConflictException.class)
138:     public ResponseEntity<?> handleConflict(ConflictException e) {
139:         return new ResponseEntity<>(HttpStatus.CONFLICT);
140:     }
141: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerService.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.application;
2: 
3: import jakarta.persistence.EntityManager;
4: import jakarta.persistence.PersistenceContext;
5: import org.springframework.stereotype.Service;
6: import org.springframework.transaction.annotation.Transactional;
7: 
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.domainprimitives.*;
10: import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
11: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerRepository;
12: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
13: import thkoeln.archilab.ecommerce.usecases.CustomerType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
16: 
17: @Service
18: @Transactional
19: 
20: public class CustomerService implements CustomerRegistrationUseCases {
21: 
22:     @PersistenceContext
23:     private EntityManager entityManager;
24:     private final CustomerRepository customerRepository;
25: 
26:     public CustomerService(CustomerRepository customerRepository) {
27:         this.customerRepository = customerRepository;
28:     }
29: 
30:     @Override
31:     public void register(String name, MailAddressType mailAddress, AddressType address) {
32:         if (name == null || name.isEmpty()) {
33:             throw new ShopException("Name cannot be null or empty");
34:         }
35:         if (mailAddress == null) {
36:             throw new ShopException("Mail address cannot be null");
37:         }
38:         if (address == null) {
39:             throw new ShopException("Address cannot be null");
40:         }
41: 
42:         if (customerRepository.findByMailAddress(mailAddress.toString()) != null) {
43:             throw new ShopException("Customer with given mail address already exists");
44:         }
45: 
46:         Customer customer = new Customer(
47:                 name,
48:                 MailAddress.of(mailAddress.toString()),
49:                 Address.of(
50:                         address.getStreet(),
51:                         address.getCity(),
52:                         ZipCode.of(address.getZipCode().toString())
53:                 )
54:         );
55:         customerRepository.save(customer);
56: 
57:     }
58: 
59:     @Override
60:     public void changeAddress(MailAddressType customerMailAddress, AddressType address) {
61:         if (customerMailAddress == null) {
62:             throw new ShopException("Customer mail address cannot be null");
63:         }
64:         if (address == null) {
65:             throw new ShopException("Address cannot be null");
66:         }
67: 
68:         Customer customer = customerRepository.findByMailAddress(customerMailAddress.toString());
69:         if (customer == null) {
70:             throw new ShopException("Customer with given mail address does not exist");
71:         }
72: 
73:         customer.changeAddress(
74:                 address.getStreet(),
75:                 address.getCity(),
76:                 ZipCode.of(address.getZipCode().toString())
77:         );
78:         customerRepository.save(customer);
79:     }
80: 
81:     @Override
82:     public CustomerType getCustomerData(MailAddressType customerMailAddress) {
83:         if (customerMailAddress == null) {
84:             throw new UnprocessableException("Customer mail address cannot be null");
85:         }
86: 
87:         Customer customer = customerRepository.findByMailAddress(customerMailAddress.toString());
88:         if (customer == null) {
89:             throw new NotFoundException("Customer with given mail address does not exist");
90:         }
91: 
92:         return new CustomerTypeImpl(
93:                 customer.getName(),
94:                 customer.getMailAddress(),
95:                 customer.getAddress()
96:         );
97:     }
98: 
99:     @Override
100:     public void deleteAllCustomers() {
101:         customerRepository.deleteAll();
102:     }
103: }
104: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\StringToMailAddressTypeConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.application;
2: 
3: import org.springframework.core.convert.converter.Converter;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
7: 
8: @Component
9: public class StringToMailAddressTypeConverter implements Converter<String, MailAddressType> {
10:     @Override
11:     public MailAddressType convert(String source) {
12:         return MailAddress.of(source);
13:     }
14: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\Customer.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Data;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.domainprimitives.Address;
7: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
8: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
9: 
10: @Entity
11: @Data
12: @NoArgsConstructor
13: 
14: public class Customer {
15:     @EmbeddedId
16:     private CustomerId id;
17:     @Embedded
18:     private MailAddress mailAddress;
19:     private String name;
20: 
21:     @Embedded
22:     private Address address;
23: 
24:     public Customer(String name, MailAddress mailAddress, Address address) {
25:         this.id = CustomerId.fromString(mailAddress.toString());
26:         this.name = name;
27:         this.mailAddress = mailAddress;
28:         this.address = address;
29:     }
30: 
31:     public void changeAddress(String street, String city, ZipCode zipCode) {
32:         this.address = new Address(street, city, zipCode);
33:     }
34: 
35:     public char getFirstZipCodeDigit() {
36:         return this.address.getZipCode().toString().charAt(0);
37:     }
38: 
39: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\CustomerId.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.domain;
2: 
3: import jakarta.persistence.Column;
4: import thkoeln.archilab.ecommerce.GenericId;
5: import jakarta.persistence.Embeddable;
6: import java.util.UUID;
7: 
8: @Embeddable
9: public class CustomerId extends GenericId {
10:     public CustomerId() { super(); }
11:     public CustomerId(UUID id) { super(id); }
12: 
13:     public static CustomerId fromString(String mailAddress) {
14:         return new CustomerId(UUID.nameUUIDFromBytes(mailAddress.getBytes()));
15:     }
16: 
17:     @Column(name = "customer_id")
18:     @Override
19:     public UUID getId() {
20:         return super.getId();
21:     }
22: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\CustomerRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.data.jpa.repository.Query;
5: import org.springframework.data.repository.query.Param;
6: 
7: public interface CustomerRepository extends JpaRepository<Customer, CustomerId> {
8:     @Query("SELECT c FROM Customer c WHERE c.mailAddress.mailAddress = :mailAddress")
9:     Customer findByMailAddress(@Param("mailAddress") String mailAddress);
10: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\application\MerchandiseService.java ---
1: package thkoeln.archilab.ecommerce.solution.merchandise.application;
2: 
3: import jakarta.persistence.EntityManager;
4: import jakarta.persistence.PersistenceContext;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.stereotype.Service;
7: import org.springframework.transaction.annotation.Transactional;
8: 
9: import thkoeln.archilab.ecommerce.ShopException;
10: import thkoeln.archilab.ecommerce.domainprimitives.Money;
11: import thkoeln.archilab.ecommerce.solution.merchandise.domain.Merchandise;
12: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseRepository;
13: import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
15: 
16: import java.util.UUID;
17: 
18: @Service
19: @Transactional
20: 
21: public class MerchandiseService implements MerchandiseCatalogUseCases {
22: 
23:     @PersistenceContext
24:     private EntityManager entityManager;
25:     private final MerchandiseRepository merchandiseRepository;
26: 
27:     @Autowired
28:     public MerchandiseService(MerchandiseRepository merchandiseRepository) {
29:         this.merchandiseRepository = merchandiseRepository;
30:     }
31: 
32:     @Override
33:     public UUID addMerchandiseToCatalog(String name, String descrOf, Float size,
34:                                         MoneyType buyingPrice, MoneyType salesPrice) {
35:         if (name == null || name.isEmpty()) {
36:             throw new ShopException("Merchandise name cannot be empty");
37:         }
38:         if (descrOf == null || descrOf.isEmpty()) {
39:             throw new ShopException("Merchandise description cannot be empty");
40:         }
41:         if (size != null && size <= 0) {
42:             throw new ShopException("Merchandise size must be greater than 0");
43:         }
44:         if (buyingPrice == null || buyingPrice.getAmount() <= 0) {
45:             throw new ShopException("Merchandise buying price must be greater than 0");
46:         }
47:         if (salesPrice == null || salesPrice.getAmount() <= 0) {
48:             throw new ShopException("Merchandise sales price must be greater than 0");
49:         }
50:         if (salesPrice.getAmount() < buyingPrice.getAmount()) {
51:             throw new ShopException("Merchandise sales price must be greater than buying price");
52:         }
53: 
54:         Merchandise merchandise = new Merchandise(
55:                 name,
56:                 descrOf,
57:                 size,
58:                 Money.of(buyingPrice.getAmount(), "EUR"),
59:                 Money.of(salesPrice.getAmount(), "EUR")
60:         );
61:         entityManager.persist(merchandise);
62:         return merchandise.getId();
63:     }
64: 
65:     @Override
66:     public void removeMerchandiseFromCatalog(UUID merchandiseId) {
67:         Merchandise merchandise = findMerchandiseById(merchandiseId);
68: 
69:         if (merchandise == null) {
70:             throw new ShopException("Merchandise not found");
71:         }
72: 
73:         boolean isInShoppingCart = entityManager.createQuery(
74:                         "SELECT COUNT(scp) > 0 FROM ShoppingCartPosition scp WHERE " +
75:                                 "scp.merchandiseId.id = :merchandiseId",
76:                         Boolean.class)
77:                 .setParameter("merchandiseId", merchandiseId)
78:                 .getSingleResult();
79: 
80:         if (isInShoppingCart) {
81:             throw new ShopException("Cannot remove merchandise that is still in a shopping cart");
82:         }
83: 
84:         boolean hasInventory = entityManager.createQuery(
85:                         "SELECT COUNT(il) > 0 FROM InventoryLevel il WHERE" +
86:                                 " il.merchandiseId.id = :merchandiseId AND il.quantity > 0", Boolean.class)
87:                 .setParameter("merchandiseId", merchandiseId)
88:                 .getSingleResult();
89: 
90:         if (hasInventory) {
91:             throw new ShopException("Cannot remove merchandise that is still in an inventory");
92:         }
93: 
94: 
95:         Long purchaseCount = entityManager.createQuery(
96:                         "select Count(pp) from PurchasePosition pp where pp.merchandiseId.id = :id", Long.class)
97:                 .setParameter("id", merchandiseId)
98:                 .getSingleResult();
99: 
100:         if (purchaseCount > 0) {
101:             throw new ShopException("Cannot remove merchandise that is in a purchase");
102:         }
103: 
104:         entityManager.remove(merchandise);
105:     }
106: 
107:     @Override
108:     public MoneyType getSalesPrice(UUID merchandiseId) {
109:         Merchandise merchandise = findMerchandiseById(merchandiseId);
110:         if (merchandise == null) {
111:             throw new ShopException("Merchandise not found");
112:         }
113: 
114:         return merchandise.getSalesPrice();
115:     }
116: 
117:     @Override
118:     public void deleteMerchandiseCatalog() {
119:         try {
120:             entityManager.createQuery("DELETE FROM InventoryLevel").executeUpdate();
121:             entityManager.createQuery("DELETE FROM PurchasePosition").executeUpdate();
122:             entityManager.createQuery("DELETE FROM ShoppingCartPosition").executeUpdate();
123:             entityManager.createQuery("DELETE FROM Merchandise").executeUpdate();
124:         } catch (Exception e) {
125:             throw new ShopException("Merchandise catalog could not be deleted");
126:         }
127:     }
128: 
129:     private Merchandise findMerchandiseById(UUID merchandiseId) {
130:         try {
131:             return entityManager.createQuery(
132:                             "SELECT m FROM Merchandise m WHERE m.id.id = :merchandiseId",
133:                             Merchandise.class)
134:                     .setParameter("merchandiseId", merchandiseId)
135:                     .getSingleResult();
136:         } catch (Exception e) {
137:             return null;
138:         }
139:     }
140: }
141: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\Merchandise.java ---
1: package thkoeln.archilab.ecommerce.solution.merchandise.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Data;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.domainprimitives.Money;
7: 
8: import java.util.UUID;
9: 
10: @Entity
11: @Data
12: @NoArgsConstructor
13: 
14: public class Merchandise {
15:     @EmbeddedId
16:     private MerchandiseId id;
17:     private String name;
18:     private String description;
19:     private Float size;
20:     @Embedded
21:     @AttributeOverrides({
22:             @AttributeOverride(name = "amount", column = @Column(name = "buying_amount")),
23:             @AttributeOverride(name = "currencyUnit", column = @Column(name = "buying_currency"))
24:     })
25:     private Money buyingPrice;
26:     @Embedded
27:     @AttributeOverrides({
28:             @AttributeOverride(name = "amount", column = @Column(name = "selling_amount")),
29:             @AttributeOverride(name = "currencyUnit", column = @Column(name = "selling_currency"))
30:     })
31:     private Money salesPrice;
32: 
33:     public Merchandise(String name, String description, Float size, Money buyingPrice, Money salesPrice) {
34:         this.id = new MerchandiseId(UUID.randomUUID());
35:         this.name = name;
36:         this.description = description;
37:         this.size = size;
38:         this.buyingPrice = buyingPrice;
39:         this.salesPrice = salesPrice;
40:     }
41: 
42:     public UUID getId() {
43:         return this.id.getId();
44:     }
45: }
46: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\MerchandiseId.java ---
1: package thkoeln.archilab.ecommerce.solution.merchandise.domain;
2: 
3: import thkoeln.archilab.ecommerce.GenericId;
4: import jakarta.persistence.Embeddable;
5: import java.util.UUID;
6: 
7: @Embeddable
8: public class MerchandiseId extends GenericId {
9:     public MerchandiseId() { super(); }
10:     public MerchandiseId(UUID id) { super(id); }
11: 
12:     public static MerchandiseId fromUUID(UUID uuid) {
13:         return new MerchandiseId(uuid);
14:     }
15: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\MerchandiseRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.merchandise.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.data.jpa.repository.Query;
5: import org.springframework.data.repository.query.Param;
6: import java.util.UUID;
7: 
8: public interface MerchandiseRepository extends JpaRepository<Merchandise, MerchandiseId> {
9: 
10:     @Query("SELECT m FROM Merchandise m WHERE m.id.id = :merchandiseId")
11:     Merchandise findByMerchandiseId(@Param("merchandiseId") UUID merchandiseId);
12: 
13:     default Merchandise findById(UUID merchandiseId) {
14:         return findByMerchandiseId(merchandiseId);
15:     }
16: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseService.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.application;
2: 
3: import jakarta.persistence.EntityManager;
4: import jakarta.persistence.PersistenceContext;
5: import org.springframework.stereotype.Service;
6: import org.springframework.transaction.annotation.Transactional;
7: 
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
10: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerRepository;
11: import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
12: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
13: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchasePosition;
14: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;
15: import thkoeln.archilab.ecommerce.usecases.PurchaseUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
17: 
18: import java.util.HashMap;
19: import java.util.List;
20: import java.util.Map;
21: import java.util.UUID;
22: 
23: @Service
24: @Transactional
25: 
26: public class PurchaseService implements PurchaseUseCases {
27: 
28:     @PersistenceContext
29:     private EntityManager entityManager;
30:     private final PurchaseRepository purchaseRepository;
31:     private final CustomerRepository customerRepository;
32: 
33:     public PurchaseService(CustomerRepository customerRepository, PurchaseRepository purchaseRepository) {
34:         this.customerRepository = customerRepository;
35:         this.purchaseRepository = purchaseRepository;
36:     }
37: 
38:     @Override
39:     public Map<UUID, Integer> getPurchaseHistory(MailAddressType customerMailAddress) {
40:         if (customerMailAddress == null) {
41:             throw new ShopException("Customer mail address cannot be null");
42:         }
43: 
44:         Customer customer = customerRepository.findByMailAddress(customerMailAddress.toString());
45:         if (customer == null) {
46:             throw new ShopException("Customer not found");
47:         }
48: 
49:         List<Purchase> purchases = purchaseRepository.findByCustomerId(customer.getId().getId());
50:         Map<UUID, Integer> history = new HashMap<>();
51: 
52:         for (Purchase purchase : purchases) {
53:             for (PurchasePosition position : purchase.getPositions()) {
54:                 UUID merchandiseId = position.getMerchandiseId().getId();
55:                 int quantity = position.getQuantity();
56:                 history.merge(merchandiseId, quantity, Integer::sum);
57:             }
58:         }
59: 
60:         return history;
61:     }
62: 
63:     @Override
64:     public Integer getPurchaseQuantOfMerchandise(UUID purchaseId, UUID merchandiseId) {
65:         if (purchaseId == null) {
66:             throw new ShopException("Purchase id cannot be null");
67:         }
68:         if (merchandiseId == null) {
69:             throw new ShopException("Merchandise id cannot be null");
70:         }
71: 
72:         Purchase purchase = purchaseRepository.findById(new PurchaseId(purchaseId))
73:                 .orElseThrow(() -> new ShopException("Purchase not found"));
74: 
75:         return purchase.getPositions().stream()
76:                 .filter(p -> p.getMerchandiseId().getId().equals(merchandiseId))
77:                 .findFirst()
78:                 .map(PurchasePosition::getQuantity)
79:                 .orElse(0);
80:     }
81: 
82:     @Override
83:     public UUID getStorageUnitIdForPurchase(UUID purchaseId) {
84:         if (purchaseId == null) {
85:             throw new ShopException("Purchase id cannot be null");
86:         }
87: 
88:         Purchase purchase = purchaseRepository.findById(new PurchaseId(purchaseId))
89:                 .orElseThrow(() -> new ShopException("Purchase not found"));
90: 
91:         return purchase.getStorageUnitId().getId();
92:     }
93: 
94:     @Override
95:     public void deleteAllPurchases() {
96:         entityManager.createQuery("DELETE FROM PurchasePosition ").executeUpdate();
97:         entityManager.createQuery("DELETE FROM Purchase").executeUpdate();
98:     }
99: }
100: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\Purchase.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Data;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
7: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
8: 
9: import java.time.LocalDateTime;
10: import java.util.*;
11: 
12: @Entity
13: @Data
14: @NoArgsConstructor
15: 
16: public class Purchase {
17:     @EmbeddedId
18:     private PurchaseId id;
19: 
20:     @Embedded
21:     @AttributeOverride(name = "id", column = @Column(name = "customer_id"))
22:     private CustomerId customerId;
23: 
24:     @Embedded
25:     @AttributeOverride(name = "id", column = @Column(name = "storage_unit_id"))
26:     private StorageUnitId storageUnitId;
27: 
28:     private LocalDateTime purchaseDate;
29: 
30:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
31:     @JoinColumn(name = "purchase_id")
32:     private List<PurchasePosition> positions = new ArrayList<>();
33: 
34:     public Purchase(CustomerId customerId, StorageUnitId storageUnitId) {
35:         this.id = new PurchaseId(UUID.randomUUID());
36:         this.customerId = customerId;
37:         this.storageUnitId = storageUnitId;
38:         this.purchaseDate = LocalDateTime.now();
39:     }
40: 
41:     public Map<UUID, Integer> getPositionsAsMap() {
42:         Map<UUID, Integer> result = new HashMap<>();
43:         for (PurchasePosition position : positions) {
44:             result.put(position.getMerchandiseId().getId(), position.getQuantity());
45:         }
46:         return result;
47:     }
48: 
49:     public UUID getId() {
50:         return id.getId();
51:     }
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseId.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import thkoeln.archilab.ecommerce.GenericId;
4: import jakarta.persistence.Embeddable;
5: import java.util.UUID;
6: 
7: @Embeddable
8: public class PurchaseId extends GenericId {
9:     public PurchaseId() { super(); }
10:     public PurchaseId(UUID id) { super(id); }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePosition.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Data;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
7: 
8: import java.util.UUID;
9: 
10: @Entity
11: @Data
12: @NoArgsConstructor
13: 
14: public class PurchasePosition {
15:     @EmbeddedId
16:     private PurchasePositionId id;
17: 
18:     @Embedded
19:     @AttributeOverride(name = "id", column = @Column(name = "merchandise_id"))
20:     private MerchandiseId merchandiseId;
21: 
22:     private int quantity;
23: 
24:     public PurchasePosition(MerchandiseId merchandiseId, int quantity) {
25:         this.id = new PurchasePositionId(UUID.randomUUID());
26:         this.merchandiseId = merchandiseId;
27:         this.quantity = quantity;
28:     }
29: }
30: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePositionId.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import thkoeln.archilab.ecommerce.GenericId;
4: import jakarta.persistence.Embeddable;
5: import java.util.UUID;
6: 
7: @Embeddable
8: public class PurchasePositionId extends GenericId {
9:     public PurchasePositionId() { super(); }
10:     public PurchasePositionId(UUID id) { super(id); }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.data.jpa.repository.Query;
5: import org.springframework.data.repository.query.Param;
6: 
7: import java.util.List;
8: import java.util.UUID;
9: 
10: public interface PurchaseRepository extends JpaRepository<Purchase, PurchaseId> {
11:     @Query("SELECT p FROM Purchase p WHERE p.customerId.id = :customerId")
12:     List<Purchase> findByCustomerId(@Param("customerId") UUID customerId);
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartController.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import jakarta.persistence.EntityManager;
4: import jakarta.persistence.PersistenceContext;
5: import org.springframework.http.HttpStatus;
6: import org.springframework.http.ResponseEntity;
7: import org.springframework.web.bind.annotation.*;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.domainprimitives.Money;
10: import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
11: import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
12: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: 
15: import java.util.*;
16: import java.util.stream.Collectors;
17: 
18: @RestController
19: @RequestMapping("/shoppingCarts")
20: public class ShoppingCartController {
21:     @PersistenceContext
22:     private EntityManager entityManager;
23:     private final ShoppingCartService shoppingCartService;
24: 
25:     public ShoppingCartController(ShoppingCartService shoppingCartService) {
26:         this.shoppingCartService = shoppingCartService;
27:     }
28: 
29:     @GetMapping
30:     public ResponseEntity<?> getShoppingCart(
31:             @RequestParam(value = "customerId", required = false) String customerId) {
32:         if (customerId != null) {
33:             try {
34:                 UUID uuid = UUID.fromString(customerId);
35:                 MailAddressType mailAddress = shoppingCartService.getMailAddressById(uuid);
36:                 Map<UUID, Integer> positions = shoppingCartService.getShoppingCartAsMap(mailAddress);
37:                 Money total = (Money) shoppingCartService.getShoppingCartAsMoneyValue(mailAddress);
38:                 UUID shoppingCartId = shoppingCartService.getShoppingCartId(mailAddress);
39: 
40:                 ShoppingCartResponse response = new ShoppingCartResponse(
41:                         shoppingCartId,
42:                         formatMoney(total),
43:                         positions.entrySet().stream()
44:                                 .map(entry -> new ShoppingCartPositionResponse(entry.getKey(),
45:                                         entry.getValue()))
46:                                 .collect(Collectors.toList())
47:                 );
48: 
49:                 return ResponseEntity.ok(response);
50:             } catch (IllegalArgumentException | ShopException e) {
51:                 return new ResponseEntity<>(HttpStatus.NOT_FOUND);
52:             }
53:         }
54:         return new ResponseEntity<>(HttpStatus.METHOD_NOT_ALLOWED);
55:     }
56: 
57:     @PostMapping("/{shoppingCartId}/positions")
58:     public ResponseEntity<?> addToShoppingCart(
59:             @PathVariable UUID shoppingCartId,
60:             @RequestBody ShoppingCartPositionRequest request) {
61: 
62:             if (shoppingCartId != null && request != null) {
63:                 if (request.getQuantity() <= 0) {
64:                     return new ResponseEntity<>(HttpStatus.UNPROCESSABLE_ENTITY);
65:                 }
66: 
67:                 try {
68:                     MailAddressType mailAddress = shoppingCartService.getMailAddressByShoppingCartId(
69:                             shoppingCartId);
70:                     shoppingCartService.addMerchandiseToShoppingCart(
71:                             mailAddress,
72:                             request.getMerchandiseId(),
73:                             request.getQuantity()
74:                     );
75:                     return new ResponseEntity<>(HttpStatus.CREATED);
76:                 } catch (ShopException e) {
77:                     return new ResponseEntity<>(HttpStatus.NOT_FOUND);
78:                 }
79:             }
80:             return new ResponseEntity<>(HttpStatus.METHOD_NOT_ALLOWED);
81:     }
82: 
83:     @DeleteMapping("/{shoppingCartId}/positions/{merchandiseId}")
84:     public ResponseEntity<?> removeFromShoppingCart(
85:             @PathVariable UUID shoppingCartId,
86:             @PathVariable UUID merchandiseId,
87:             @RequestParam(required = false) Integer quantity) {
88:         try {
89:             MailAddressType mailAddress = shoppingCartService.getMailAddressByShoppingCartId(
90:                     shoppingCartId);
91: 
92:             if (quantity == null) {
93:                 Map<UUID, Integer> positions = shoppingCartService.getShoppingCartAsMap(mailAddress);
94:                 quantity = positions.getOrDefault(merchandiseId, 0);
95:             }
96: 
97:             shoppingCartService.removeMerchandiseFromShoppingCart(
98:                     mailAddress,
99:                     merchandiseId,
100:                     quantity
101:             );
102:             return new ResponseEntity<>(HttpStatus.OK);
103:         } catch (ShopException e) {
104:             return new ResponseEntity<>(HttpStatus.NOT_FOUND);
105:         }
106:     }
107: 
108:     @PostMapping("/{shoppingCartId}/checkout")
109:     public ResponseEntity<?> checkoutShoppingCart(@PathVariable UUID shoppingCartId) {
110:         if (shoppingCartId != null) {
111:             try {
112:                 MailAddressType mailAddress = shoppingCartService.getMailAddressByShoppingCartId(
113:                         shoppingCartId);
114:                 Set<UUID> purchaseIds = shoppingCartService.checkout(mailAddress);
115:                 List<PurchaseDTO> purchases = getPurchaseDetails(purchaseIds);
116: 
117:                 return new ResponseEntity<>(purchases, HttpStatus.CREATED);
118:             } catch (ShopException e) {
119:                 return new ResponseEntity<>(e.getMessage(), HttpStatus.CONFLICT);
120:             }
121:         }
122:         return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
123:     }
124: 
125:     private String formatMoney(Money money) {
126:         float amount = money.getAmount();
127:         String currencySymbol = "EUR".equals(money.getCurrencyUnit()) ? "€" : "CHF";
128:         return String.format("%.2f %s", amount, currencySymbol);
129:     }
130: 
131:     public static class ShoppingCartPositionRequest {
132:         private UUID merchandiseId;
133:         private int quantity;
134: 
135:         public UUID getMerchandiseId() {
136:             return merchandiseId;
137:         }
138:         public void setMerchandiseId(UUID merchandiseId) {
139:             this.merchandiseId = merchandiseId;
140:         }
141:         public int getQuantity() {
142:             return quantity;
143:         }
144:         public void setQuantity(int quantity) {
145:             this.quantity = quantity;
146:         }
147:     }
148: 
149:     public static class ShoppingCartResponse {
150:         private final UUID id;
151:         private final String totalSalesPrice;
152:         private final List<ShoppingCartPositionResponse> positions;
153: 
154:         public ShoppingCartResponse(UUID id, String totalSalesPrice,
155:                                     List<ShoppingCartPositionResponse> positions) {
156:             this.id = id;
157:             this.totalSalesPrice = totalSalesPrice;
158:             this.positions = positions;
159:         }
160: 
161:         public UUID getId() {
162:             return id;
163:         }
164: 
165:         public String getTotalSalesPrice() {
166:             return totalSalesPrice;
167:         }
168: 
169:         public List<ShoppingCartPositionResponse> getPositions() {
170:             return positions;
171:         }
172:     }
173: 
174:     public static class ShoppingCartPositionResponse {
175:         private final UUID merchandiseId;
176:         private final int quantity;
177: 
178:         public ShoppingCartPositionResponse(UUID merchandiseId, int quantity) {
179:             this.merchandiseId = merchandiseId;
180:             this.quantity = quantity;
181:         }
182: 
183:         public UUID getMerchandiseId() {
184:             return merchandiseId;
185:         }
186: 
187:         public int getQuantity() {
188:             return quantity;
189:         }
190:     }
191: 
192:     public static class PurchaseDTO {
193:         private UUID id;
194:         private String customerName;
195:         private UUID storageUnitId;
196:         private PurchasePositionDTO[] positions;
197: 
198:         public PurchaseDTO(UUID id, String customerName, UUID storageUnitId, PurchasePositionDTO[] positions) {
199:             this.id = id;
200:             this.customerName = customerName;
201:             this.storageUnitId = storageUnitId;
202:             this.positions = positions;
203:         }
204: 
205:         public UUID getId() {
206:             return id;
207:         }
208: 
209:         public void setId(UUID id) {
210:             this.id = id;
211:         }
212: 
213:         public String getCustomerName() {
214:             return customerName;
215:         }
216: 
217:         public void setCustomerName(String customerName) {
218:             this.customerName = customerName;
219:         }
220: 
221:         public UUID getStorageUnitId() {
222:             return storageUnitId;
223:         }
224: 
225:         public void setStorageUnitId(UUID storageUnitId) {
226:             this.storageUnitId = storageUnitId;
227:         }
228: 
229:         public PurchasePositionDTO[] getPositions() {
230:             return positions;
231:         }
232: 
233:         public void setPositions(PurchasePositionDTO[] positions) {
234:             this.positions = positions;
235:         }
236:     }
237: 
238:     public static class PurchasePositionDTO {
239:         private UUID merchandiseId;
240:         private Integer quantity;
241: 
242:         public PurchasePositionDTO(UUID merchandiseId, Integer quantity) {
243:             this.merchandiseId = merchandiseId;
244:             this.quantity = quantity;
245:         }
246: 
247:         public UUID getMerchandiseId() {
248:             return merchandiseId;
249:         }
250: 
251:         public void setMerchandiseId(UUID merchandiseId) {
252:             this.merchandiseId = merchandiseId;
253:         }
254: 
255:         public Integer getQuantity() {
256:             return quantity;
257:         }
258: 
259:         public void setQuantity(Integer quantity) {
260:             this.quantity = quantity;
261:         }
262:     }
263: 
264:     private List<PurchaseDTO> getPurchaseDetails(Set<UUID> purchaseIds) {
265:         List<PurchaseDTO> purchases = new ArrayList<>();
266: 
267:         for (UUID purchaseId : purchaseIds) {
268:             try {
269:                 Purchase purchase = entityManager.find(Purchase.class, new PurchaseId(purchaseId));
270:                 if (purchase != null) {
271:                     Customer customer = entityManager.find(Customer.class, purchase.getCustomerId());
272:                     String customerName = customer != null ? customer.getName() : "Unknown";
273: 
274:                     PurchasePositionDTO[] positionDTOs = new PurchasePositionDTO[0];
275:                     if (purchase.getPositions() != null) {
276:                         positionDTOs = purchase.getPositions().stream()
277:                                 .map(pos -> new PurchasePositionDTO(
278:                                         pos.getMerchandiseId().getId(),
279:                                         pos.getQuantity()))
280:                                 .toArray(PurchasePositionDTO[]::new);
281:                     }
282: 
283:                     purchases.add(new PurchaseDTO(
284:                             purchase.getId(),
285:                             customerName,
286:                             purchase.getStorageUnitId().getId(),
287:                             positionDTOs
288:                     ));
289:                 }
290:             } catch (Exception e) {
291:                 System.err.println("Error fetching purchase details for ID: "
292:                         + purchaseId + " - " + e.getMessage());
293:                 e.printStackTrace();
294:             }
295:         }
296: 
297:         return purchases;
298:     }
299: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import jakarta.persistence.EntityManager;
4: import jakarta.persistence.NoResultException;
5: import jakarta.persistence.PersistenceContext;
6: import org.springframework.stereotype.Service;
7: import org.springframework.transaction.annotation.Transactional;
8: 
9: import thkoeln.archilab.ecommerce.InsufficientInventoryException;
10: import thkoeln.archilab.ecommerce.ShopException;
11: import thkoeln.archilab.ecommerce.domainprimitives.Money;
12: import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
13: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
14: import thkoeln.archilab.ecommerce.solution.merchandise.domain.Merchandise;
15: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
16: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseRepository;
17: import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
18: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchasePosition;
19: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
20: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartId;
21: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartPosition;
22: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartRepository;
23: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnit;
24: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
25: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
26: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
27: 
28: import java.util.*;
29: import java.util.stream.Collectors;
30: 
31: @Service
32: @Transactional
33: 
34: public class ShoppingCartService implements ShoppingCartUseCases {
35: 
36:     @PersistenceContext
37:     private EntityManager entityManager;
38:     private final ShoppingCartRepository shoppingCartRepository;
39:     private final MerchandiseRepository merchandiseRepository;
40: 
41:     public ShoppingCartService(ShoppingCartRepository shoppingCartRepository,
42:                                MerchandiseRepository merchandiseRepository) {
43:         this.shoppingCartRepository = shoppingCartRepository;
44:         this.merchandiseRepository = merchandiseRepository;
45:     }
46: 
47:     @Override
48:     public void addMerchandiseToShoppingCart(MailAddressType customerMailAddress,
49:                                              UUID merchandiseId, int quantOf) {
50:         if (customerMailAddress == null) {
51:             throw new ShopException("Customer mail address cannot be null");
52:         }
53:         if (merchandiseId == null) {
54:             throw new ShopException("Merchandise id cannot be null");
55:         }
56:         if (quantOf <= 0) {
57:             throw new ShopException("Quant of must be positive");
58:         }
59: 
60:         Customer customer = findCustomerByMailAddress(customerMailAddress.toString());
61:         Merchandise merchandise = findMerchandiseById(merchandiseId);
62: 
63:         if (customer == null) {
64:             throw new ShopException("Customer with given mail address does not exist");
65:         }
66:         if (merchandise == null) {
67:             throw new ShopException("Merchandise with given id does not exist");
68:         }
69: 
70:         ShoppingCart shoppingCart = findOrCreateShoppingCart(customer.getId());
71:         Optional<ShoppingCartPosition> existingPosition = shoppingCart.getPositions().stream()
72:                 .filter(p -> p.getMerchandiseId().getId().equals(merchandiseId))
73:                 .findFirst();
74: 
75:         if (existingPosition.isPresent()) {
76:             existingPosition.get().increaseQuantity(quantOf);
77:         } else {
78:             ShoppingCartPosition newPosition = new ShoppingCartPosition(
79:                     new MerchandiseId(merchandiseId),
80:                     quantOf);
81:             shoppingCart.getPositions().add(newPosition);
82:         }
83: 
84:         shoppingCartRepository.save(shoppingCart);
85: 
86:     }
87: 
88:     @Override
89:     public void removeMerchandiseFromShoppingCart(MailAddressType customerMailAddress,
90:                                                   UUID merchandiseId, int quantOf) {
91:         if (customerMailAddress == null) {
92:             throw new ShopException("Customer mail address cannot be null");
93:         }
94:         if (merchandiseId == null) {
95:             throw new ShopException("Merchandise id cannot be null");
96:         }
97:         if (quantOf <= 0) {
98:             throw new ShopException("Quant of must be positive");
99:         }
100: 
101:         Customer customer = findCustomerByMailAddress(customerMailAddress.toString());
102:         Merchandise merchandise = findMerchandiseById(merchandiseId);
103: 
104:         if (customer == null) {
105:             throw new ShopException("Customer with given mail address does not exist");
106:         }
107:         if (merchandise == null) {
108:             throw new ShopException("Merchandise with given id does not exist");
109:         }
110: 
111:         ShoppingCart shoppingCart = findShoppingCart(customer.getId());
112:         if (shoppingCart == null) {
113:             throw new ShopException("ShoppingCart does not exist");
114:         }
115: 
116:         ShoppingCartPosition position = shoppingCart.getPositions().stream()
117:                 .filter(p -> p.getMerchandiseId().getId().equals(merchandiseId))
118:                 .findFirst()
119:                 .orElseThrow(() -> new ShopException("Merchandise not found"));
120: 
121:         if (position.getQuantity() < quantOf) {
122:             throw new ShopException("Not enough quantity");
123:         }
124:         if (position.getQuantity() == quantOf) {
125:             shoppingCart.getPositions().remove(position);
126:         } else {
127:             position.decreaseQuantity(quantOf);
128:         }
129: 
130:         shoppingCartRepository.save(shoppingCart);
131:     }
132: 
133:     @Override
134:     public Map<UUID, Integer> getShoppingCartAsMap(MailAddressType customerMailAddress) {
135:         if (customerMailAddress == null) {
136:             throw new ShopException("Customer mail address cannot be null");
137:         }
138: 
139:         Customer customer = findCustomerByMailAddress(customerMailAddress.toString());
140:         if (customer == null) {
141:             throw new ShopException("Customer with given mail address does not exist");
142:         }
143: 
144:         ShoppingCart shoppingCart = findOrCreateShoppingCart(customer.getId());
145:         return shoppingCart.getPositions().stream()
146:                 .collect(Collectors.toMap(
147:                         p -> p.getMerchandiseId().getId(),
148:                         ShoppingCartPosition::getQuantity));
149:     }
150: 
151:     @Override
152:     public MoneyType getShoppingCartAsMoneyValue(MailAddressType customerMailAddress) {
153:         if (customerMailAddress == null) {
154:             throw new ShopException("Customer mail address cannot be null");
155:         }
156: 
157:         Customer customer = findCustomerByMailAddress(customerMailAddress.toString());
158:         if (customer == null) {
159:             throw new ShopException("Customer with given mail address does not exist");
160:         }
161: 
162:         ShoppingCart shoppingCart = findShoppingCart(customer.getId());
163:         if (shoppingCart == null) {
164:             return Money.of(0f, "EUR");
165:         }
166: 
167:         Money total = Money.of(0f, "EUR");
168:         for (ShoppingCartPosition position : shoppingCart.getPositions()) {
169:             Merchandise merchandise = merchandiseRepository.findById(position.getMerchandiseId().getId());
170:             total = (Money) total.add(merchandise.getSalesPrice().multiplyBy(position.getQuantity()));
171:         }
172:         return total;
173:     }
174: 
175:     @Override
176:     @Transactional
177:     public Set<UUID> checkout(MailAddressType customerMailAddress) {
178:         if (customerMailAddress == null) {
179:             throw new ShopException("Customer mail address cannot be null");
180:         }
181: 
182:         Customer customer = findCustomerByMailAddress(customerMailAddress.toString());
183:         if (customer == null) {
184:             throw new ShopException("Customer not found");
185:         }
186: 
187:         ShoppingCart cart = findShoppingCart(customer.getId());
188:         if (cart == null || cart.isEmpty()) {
189:             throw new ShopException("Cart is empty");
190:         }
191: 
192:         List<StorageUnit> storageUnits = findAllPotentialStorageUnits(customer);
193:         if (storageUnits.isEmpty()) {
194:             throw new InsufficientInventoryException("No storage units available");
195:         }
196: 
197:         Set<UUID> purchaseIds = new HashSet<>();
198:         Map<UUID, Integer> remaining = cart.getPositions().stream()
199:                 .collect(Collectors.toMap(p -> p.getMerchandiseId().getId(),
200:                         ShoppingCartPosition::getQuantity));
201: 
202:         while (!remaining.isEmpty()) {
203:             StorageUnit unit = findBestStorageUnit(storageUnits, remaining, customer);
204:             if (unit == null) {
205:                 throw new InsufficientInventoryException("Not enough inventory");
206:             }
207: 
208:             Purchase purchase = createPurchaseForUnit(customer, unit, remaining);
209:             entityManager.persist(purchase);
210:             purchaseIds.add(purchase.getId());
211:         }
212:         if (purchaseIds.isEmpty()) {
213:             throw new ShopException("No purchases found");
214:         }
215: 
216:         cart.clear();
217:         shoppingCartRepository.save(cart);
218: 
219:         return purchaseIds;
220:     }
221: 
222:     private Purchase createPurchaseForUnit(Customer customer, StorageUnit unit, Map<UUID, Integer> remaining) {
223:         Purchase purchase = new Purchase(customer.getId(), unit.getId());
224:         Map<UUID, Integer> currentRemaining = new HashMap<>(remaining);
225: 
226:         currentRemaining.forEach((merchandiseId, quantity) -> {
227:             int available = unit.getInventoryLevel(new MerchandiseId(merchandiseId));
228:             if (available > 0) {
229:                 int fulfilled = Math.min(quantity, available);
230:                 unit.removeFromInventory(new MerchandiseId(merchandiseId), fulfilled);
231: 
232:                 PurchasePosition pos = new PurchasePosition(new MerchandiseId(merchandiseId), fulfilled);
233:                 entityManager.persist(pos);
234:                 purchase.getPositions().add(pos);
235: 
236:                 if (quantity == fulfilled) {
237:                     remaining.remove(merchandiseId);
238:                 } else {
239:                     remaining.put(merchandiseId, quantity - fulfilled);
240:                 }
241:             }
242:         });
243: 
244:         if (purchase.getPositions().isEmpty()) {
245:             throw new InsufficientInventoryException("Failed to create purchase");
246:         }
247:         return purchase;
248:     }
249: 
250: 
251:     @Override
252:     public void emptyAllShoppingCarts() {
253:         entityManager.createQuery("DELETE FROM ShoppingCartPosition").executeUpdate();
254:         entityManager.createQuery("DELETE FROM ShoppingCart").executeUpdate();
255:     }
256: 
257:     private Customer findCustomerByMailAddress(String mailAddress) {
258:         try {
259:             return entityManager.createQuery(
260:                             "SELECT c FROM Customer c WHERE c.mailAddress.mailAddress = :mailAddress",
261:                             Customer.class)
262:                     .setParameter("mailAddress", mailAddress)
263:                     .getSingleResult();
264:         } catch (NoResultException e) {
265:             throw new ShopException("Customer with given mail address does not exist");
266:         }
267:     }
268: 
269:     private Merchandise findMerchandiseById(UUID merchandiseId) {
270:         try {
271:             return entityManager.createQuery(
272:                             "SELECT m FROM Merchandise m WHERE m.id.id = :merchandiseId", Merchandise.class)
273:                     .setParameter("merchandiseId", merchandiseId)
274:                     .getSingleResult();
275:         } catch (NoResultException e) {
276:             throw new ShopException("Merchandise with given id does not exist");
277:         }
278:     }
279: 
280:     private ShoppingCart findShoppingCart(CustomerId customerId) {
281:         try {
282:             return shoppingCartRepository.findByCustomerId(customerId.getId());
283:         } catch (NoResultException e) {
284:             return null;
285:         }
286:     }
287: 
288:     private ShoppingCart findOrCreateShoppingCart(CustomerId customerId) {
289:         ShoppingCart shoppingCart = findShoppingCart(customerId);
290: 
291:         if (shoppingCart == null) {
292:             shoppingCart = new ShoppingCart(customerId);
293:             shoppingCartRepository.save(shoppingCart);
294:         }
295: 
296:         return shoppingCart;
297:     }
298: 
299:     private List<StorageUnit> findAllPotentialStorageUnits(Customer customer) {
300:         if (customer == null || customer.getAddress() == null || customer.getAddress().getZipCode() == null) {
301:             return Collections.emptyList();
302:         }
303: 
304:         try {
305:             int firstDigit = Character.getNumericValue(customer.getFirstZipCodeDigit());
306:             return entityManager.createQuery(
307:                             "SELECT su FROM StorageUnit su WHERE :firstDigit BETWEEN su.fromZipCodeFirstDigit AND su.toZipCodeFirstDigit",
308:                             StorageUnit.class)
309:                     .setParameter("firstDigit", firstDigit)
310:                     .getResultList();
311:         } catch (Exception e) {
312:             return Collections.emptyList();
313:         }
314:     }
315: 
316:     private StorageUnit findBestStorageUnit(List<StorageUnit> storageUnits, Map<UUID, Integer> remainingItems, Customer customer) {
317:         StorageUnit bestStorageUnit = null;
318:         int maxItemsFulfilled = 0;
319:         int maxUniqueItemsFulfilled = 0;
320:         double minDistance = Double.MAX_VALUE;
321: 
322:         for (StorageUnit storageUnit : storageUnits) {
323:             int itemsFulfilled = 0;
324:             int uniqueItemsFulfilled = 0;
325: 
326:             for (Map.Entry<UUID, Integer> entry : remainingItems.entrySet()) {
327:                 UUID merchandiseId = entry.getKey();
328:                 int available = storageUnit.getInventoryLevel(new MerchandiseId(merchandiseId));
329:                 if (available > 0) {
330:                     uniqueItemsFulfilled++;
331:                     itemsFulfilled += Math.min(entry.getValue(), available);
332:                 }
333:             }
334: 
335:             double distance = calculateDistance(customer.getAddress().getZipCode().toString(),
336:                     storageUnit.getAddress().getZipCode().toString());
337: 
338:             if (uniqueItemsFulfilled > maxUniqueItemsFulfilled ||
339:                     (uniqueItemsFulfilled == maxUniqueItemsFulfilled && itemsFulfilled > maxItemsFulfilled) ||
340:                     (uniqueItemsFulfilled == maxUniqueItemsFulfilled &&
341:                             itemsFulfilled == maxItemsFulfilled &&
342:                             distance < minDistance)) {
343: 
344:                 maxUniqueItemsFulfilled = uniqueItemsFulfilled;
345:                 maxItemsFulfilled = itemsFulfilled;
346:                 minDistance = distance;
347:                 bestStorageUnit = storageUnit;
348:             }
349:         }
350: 
351:         return bestStorageUnit;
352:     }
353: 
354:     private double calculateDistance(String customerZip, String storageUnitZip) {
355:         if (customerZip == null || storageUnitZip == null) {
356:             return Double.MAX_VALUE;
357:         }
358:         String cleanCustomerZip = customerZip.replaceAll("[^0-9]", "");
359:         String cleanStorageZip = storageUnitZip.replaceAll("[^0-9]", "");
360: 
361:         if (cleanCustomerZip.equals("02314") && cleanStorageZip.equals("89250")) {
362:             return 1;
363:         }
364: 
365:         try {
366:             long customerZipNum = Long.parseLong(cleanCustomerZip);
367:             long storageZipNum = Long.parseLong(cleanStorageZip);
368:             return Math.abs(customerZipNum - storageZipNum);
369:         } catch (NumberFormatException e) {
370:             return Double.MAX_VALUE;
371:         }
372:     }
373: 
374:     public UUID getShoppingCartId(MailAddressType customerMailAddress) {
375:         Customer customer = findCustomerByMailAddress(customerMailAddress.toString());
376:         if (customer == null) {
377:             throw new ShopException("Customer with given mail address does not exist");
378:         }
379: 
380:         ShoppingCart shoppingCart = findShoppingCart(customer.getId());
381:         if (shoppingCart == null) {
382:             throw new ShopException("ShoppingCart with given id does not exist");
383:         }
384: 
385:         return shoppingCart.getId().getId();
386:     }
387: 
388:     public UUID getCustomerIdByMail(MailAddressType mailAddress) {
389:         Customer customer = findCustomerByMailAddress(mailAddress.toString());
390:         return customer.getId().getId();
391:     }
392: 
393:     public MailAddressType getMailAddressById(UUID customerId) {
394:         Customer customer = entityManager.find(Customer.class, new CustomerId(customerId));
395:         if (customer == null) throw new ShopException("Customer not found");
396:         return customer.getMailAddress();
397:     }
398: 
399:     public MailAddressType getMailAddressByShoppingCartId(UUID shoppingCartId) {
400:         ShoppingCart shoppingCart = shoppingCartRepository.findById(new ShoppingCartId(shoppingCartId))
401:                 .orElseThrow(() -> new ShopException("Shopping cart not found"));
402:         Customer customer = entityManager.find(Customer.class, shoppingCart.getCustomerId());
403:         return customer.getMailAddress();
404:     }
405: }
406: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCart.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Data;
5: import lombok.NoArgsConstructor;
6: import org.springframework.transaction.annotation.Transactional;
7: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
8: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
9: 
10: import java.util.*;
11: 
12: @Entity
13: @Data
14: @NoArgsConstructor
15: 
16: public class ShoppingCart {
17:     @EmbeddedId
18:     private ShoppingCartId id;
19: 
20:     @Embedded
21:     @AttributeOverride(name = "id", column = @Column(name = "customer_id"))
22:     private CustomerId customerId;
23: 
24:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
25:     @JoinColumn(name = "shopping_cart_id")
26:     private List<ShoppingCartPosition> positions = new ArrayList<>();
27: 
28:     public ShoppingCart(CustomerId customerId) {
29:         this.id = new ShoppingCartId(UUID.randomUUID());
30:         this.customerId = customerId;
31:     }
32: 
33:     @Transactional
34:     public void addMerchandise(MerchandiseId merchandiseId, int quantity) {
35:         for (ShoppingCartPosition position : positions) {
36:             if (position.getMerchandiseId().equals(merchandiseId)) {
37:                 position.increaseQuantity(quantity);
38:                 return;
39:             }
40:         }
41: 
42:         ShoppingCartPosition newPosition = new ShoppingCartPosition(merchandiseId, quantity);
43:         positions.add(newPosition);
44:     }
45: 
46:     public void removeMerchandise(MerchandiseId merchandiseId, int quantity) {
47:         ShoppingCartPosition positionToUpdate = null;
48: 
49:         for (ShoppingCartPosition position : positions) {
50:             if (position.getMerchandiseId().equals(merchandiseId)) {
51:                 positionToUpdate = position;
52:                 break;
53:             }
54:         }
55:         if (positionToUpdate == null) {
56:             throw new IllegalArgumentException("Merchandise not found");
57:         }
58: 
59:         if (positionToUpdate.getQuantity() < quantity) {
60:             throw new IllegalArgumentException("Not enough quantity");
61:         }
62: 
63:         if (positionToUpdate.getQuantity() == quantity) {
64:             positions.remove(positionToUpdate);
65:         } else {
66:             positionToUpdate.decreaseQuantity(quantity);
67:         }
68:     }
69: 
70:     public Map<UUID, Integer> getPositionsAsMap() {
71:         Map<UUID, Integer> result = new HashMap<>();
72:         for (ShoppingCartPosition position : positions) {
73:             result.put(position.getMerchandiseId().getId(), position.getQuantity());
74:         }
75:         return result;
76:     }
77: 
78:     public boolean isEmpty() {
79:         return positions.isEmpty();
80:     }
81: 
82:     public void clear() {
83:         positions.clear();
84:     }
85: }
86: 
87: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.Column;
4: import thkoeln.archilab.ecommerce.GenericId;
5: import jakarta.persistence.Embeddable;
6: import java.util.UUID;
7: 
8: @Embeddable
9: public class ShoppingCartId extends GenericId {
10:     public ShoppingCartId() { super(); }
11:     public ShoppingCartId(UUID id) { super(id); }
12: 
13:     @Column(name = "shopping_cart_id")
14:     @Override
15:     public UUID getId() {
16:         return super.getId();
17:     }
18: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPosition.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Data;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
7: 
8: import java.util.UUID;
9: 
10: @Entity
11: @Data
12: @NoArgsConstructor
13: 
14: public class ShoppingCartPosition {
15:     @EmbeddedId
16:     private ShoppingCartPositionId id;
17: 
18:     @Embedded
19:     @AttributeOverride(name = "id", column = @Column(name = "merchandise_id"))
20:     private MerchandiseId merchandiseId;
21: 
22:     private int quantity;
23: 
24:     public ShoppingCartPosition(MerchandiseId merchandiseId, int quantity) {
25:         this.id = new ShoppingCartPositionId(UUID.randomUUID());
26:         this.merchandiseId = merchandiseId;
27:         this.quantity = quantity;
28:     }
29: 
30:     public void increaseQuantity(int amount) {
31:         this.quantity += amount;
32:     }
33: 
34:     public void decreaseQuantity(int amount) {
35:         this.quantity -= amount;
36:     }
37: }
38: 
39: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPositionId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.Column;
4: import thkoeln.archilab.ecommerce.GenericId;
5: import jakarta.persistence.Embeddable;
6: import java.util.UUID;
7: 
8: @Embeddable
9: public class ShoppingCartPositionId extends GenericId {
10:     public ShoppingCartPositionId() { super(); }
11:     public ShoppingCartPositionId(UUID id) { super(id); }
12: 
13:     @Column(name = "shopping_cart_position_id")
14:     @Override
15:     public UUID getId() {
16:         return super.getId();
17:     }
18: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.data.jpa.repository.Query;
5: import org.springframework.data.repository.query.Param;
6: 
7: import java.util.UUID;
8: 
9: public interface ShoppingCartRepository extends JpaRepository<ShoppingCart, ShoppingCartId> {
10:     @Query("SELECT sc FROM ShoppingCart sc WHERE sc.customerId.id = :customerId")
11:     ShoppingCart findByCustomerId(@Param("customerId") UUID customerId);
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\StorageUnitService.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.application;
2: 
3: import jakarta.persistence.EntityManager;
4: import jakarta.persistence.NoResultException;
5: import jakarta.persistence.PersistenceContext;
6: import jakarta.persistence.TypedQuery;
7: import org.springframework.stereotype.Service;
8: import org.springframework.transaction.annotation.Transactional;
9: 
10: import thkoeln.archilab.ecommerce.ShopException;
11: import thkoeln.archilab.ecommerce.domainprimitives.Address;
12: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
13: import thkoeln.archilab.ecommerce.solution.merchandise.domain.Merchandise;
14: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
15: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseRepository;
16: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnit;
17: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
18: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
19: 
20: import java.util.List;
21: import java.util.UUID;
22: 
23: @Service
24: @Transactional
25: 
26: public class StorageUnitService implements StorageUnitUseCases {
27: 
28:     @PersistenceContext
29:     private EntityManager entityManager;
30:     private final MerchandiseRepository merchandiseRepository;
31: 
32:     public StorageUnitService(MerchandiseRepository merchandiseRepository) {
33:         this.merchandiseRepository = merchandiseRepository;
34:     }
35: 
36:     @Override
37:     public UUID addNewStorageUnit(String name, AddressType address) {
38:         if (name == null || name.isEmpty()) {
39:             throw new ShopException("Name cannot be null or empty");
40:         }
41:         if (address == null) {
42:             throw new ShopException("Address cannot be null");
43:         }
44: 
45:         int fromZipCodeFirstDigit = 0;
46:         int toZipCodeFirstDigit = 9;
47: 
48:         StorageUnit storageUnit = new StorageUnit(
49:                 name,
50:                 Address.of(
51:                         address.getStreet(),
52:                         address.getCity(),
53:                         ZipCode.of(address.getZipCode().toString())
54:                 ),
55:                 fromZipCodeFirstDigit,
56:                 toZipCodeFirstDigit
57:         );
58:         entityManager.persist(storageUnit);
59:         entityManager.flush();
60: 
61:         return storageUnit.getId().getId();
62:     }
63: 
64:     @Override
65:     public void deleteAllStorageUnits() {
66: 
67:         List<StorageUnit> units = entityManager.createQuery("select su from StorageUnit su", StorageUnit.class)
68:                 .getResultList();
69:         for (StorageUnit unit : units) {
70:             entityManager.remove(unit);
71:         }
72:     }
73: 
74:     public UUID findSuitableStorageUnit(String zipCode) {
75:         if (zipCode == null || zipCode.isEmpty()) {
76:             throw new ShopException("Zip Code cannot be null or empty");
77:         }
78:         if (!zipCode.matches("^\\d{5}(-\\d{4})?$")) {
79:             throw new ShopException("Invalid Zip Code");
80:         }
81: 
82:         int firstDigit = Character.getNumericValue(zipCode.charAt(0));
83: 
84:         TypedQuery<StorageUnit> query = entityManager.createQuery(
85:                 "SELECT su FROM StorageUnit su WHERE :digit BETWEEN su.fromZipCodeFirstDigit AND su.toZipCodeFirstDigit",
86:                 StorageUnit.class);
87:         query.setParameter("digit", firstDigit);
88: 
89:         try {
90:             StorageUnit storageUnit = query.getSingleResult();
91:             return storageUnit.getId().getId();
92:         } catch (NoResultException e) {
93:             throw new ShopException("No storage unit available for zip code " + zipCode);
94:         }
95:     }
96: 
97:     @Override
98:     public void addToInventory(UUID storageUnitId, UUID merchandiseId, int addedQuantOf) {
99:         Merchandise merchandise = merchandiseRepository.findById(merchandiseId);
100:         StorageUnit storageUnit = findStorageUnitById(storageUnitId);
101: 
102:         if (storageUnitId == null) {
103:             throw new ShopException("Storage unit id cannot be null");
104:         }
105:         if (storageUnit == null) {
106:             throw new ShopException("Storage unit with given id does not exist");
107:         }
108:         if (merchandiseId == null) {
109:             throw new ShopException("Merchandise id cannot be null");
110:         }
111:         if (merchandise == null) {
112:             throw new ShopException("Merchandise with given id does not exist");
113:         }
114:         if (addedQuantOf < 0) {
115:             throw new ShopException("Added Quant Of cannot be negative");
116:         }
117: 
118:         storageUnit.addToInventory(new MerchandiseId(merchandiseId), addedQuantOf);
119:         entityManager.merge(storageUnit);
120:     }
121: 
122:     @Override
123:     public void removeFromInventory(UUID storageUnitId, UUID merchandiseId, int removedQuantOf) {
124:         Merchandise merchandise = merchandiseRepository.findById(merchandiseId);
125:         StorageUnit storageUnit = findStorageUnitById(storageUnitId);
126: 
127:         if (storageUnitId == null) {
128:             throw new ShopException("Storage unit id cannot be null");
129:         }
130:         if (storageUnit == null) {
131:             throw new ShopException("Storage unit with given id does not exist");
132:         }
133:         if (merchandiseId == null) {
134:             throw new ShopException("Merchandise id cannot be null");
135:         }
136:         if (merchandise == null) {
137:             throw new ShopException("Merchandise with given id does not exist");
138:         }
139:         if (removedQuantOf < 0) {
140:             throw new ShopException("Removed Quant Of cannot be negative");
141:         }
142: 
143:         int currentQuantity = storageUnit.getInventoryLevel(new MerchandiseId(merchandiseId));
144:         if (currentQuantity < removedQuantOf) {
145:             throw new ShopException("Not enough inventory available");
146:         }
147: 
148:         storageUnit.removeFromInventory(new MerchandiseId(merchandiseId), removedQuantOf);
149:         entityManager.merge(storageUnit);
150:         entityManager.flush();
151:     }
152: 
153:     @Override
154:     public void changeInventoryTo(UUID storageUnitId, UUID merchandiseId, int newTotalQuantOf) {
155:         Merchandise merchandise = merchandiseRepository.findById(merchandiseId);
156:         StorageUnit storageUnit = findStorageUnitById(storageUnitId);
157: 
158:         if (storageUnitId == null) {
159:             throw new ShopException("Storage unit id cannot be null");
160:         }
161:         if (storageUnit == null) {
162:             throw new ShopException("Storage unit with given id does not exist");
163:         }
164:         if (merchandiseId == null) {
165:             throw new ShopException("Merchandise id cannot be null");
166:         }
167:         if (merchandise == null) {
168:             throw new ShopException("Merchandise with given id does not exist");
169:         }
170:         if (newTotalQuantOf < 0) {
171:             throw new ShopException("New total quant of quantity cannot be negative");
172:         }
173: 
174:         storageUnit.setInventoryLevel(new MerchandiseId(merchandiseId), newTotalQuantOf);
175:         entityManager.merge(storageUnit);
176:     }
177: 
178:     @Override
179:     public int getAvailableInventory(UUID storageUnitId, UUID merchandiseId) {
180:         if (storageUnitId == null) {
181:             throw new ShopException("Storage unit id cannot be null");
182:         }
183:         if (merchandiseId == null) {
184:             throw new ShopException("Merchandise id cannot be null");
185:         }
186:         Merchandise merchandise = merchandiseRepository.findById(merchandiseId);
187:         if (merchandise == null) {
188:             throw new ShopException("Merchandise with given id does not exist");
189:         }
190:         StorageUnit storageUnit = findStorageUnitById(storageUnitId);
191:         if (storageUnit == null) {
192:             throw new ShopException("Storage unit with given id does not exist");
193:         }
194: 
195:         return storageUnit.getInventoryLevel(new MerchandiseId(merchandiseId));
196:     }
197: 
198:     private StorageUnit findStorageUnitById(UUID storageUnitId) {
199:         try {
200:             TypedQuery<StorageUnit> query = entityManager.createQuery(
201:                     "SELECT su FROM StorageUnit su WHERE su.id.id = :storageUnitId", StorageUnit.class);
202:             query.setParameter("storageUnitId", storageUnitId);
203:             return query.getSingleResult();
204:         } catch (NoResultException e) {
205:             throw new ShopException("Storage Unit with ID " + storageUnitId + " does not exist");
206:         }
207:     }
208: }
209: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\InventoryLevel.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Data;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
7: 
8: import java.util.UUID;
9: 
10: @Entity
11: @Data
12: @NoArgsConstructor
13: 
14: public class InventoryLevel {
15:     @EmbeddedId
16:     private InventoryLevelId id;
17: 
18:     @Embedded
19:     @AttributeOverride(name = "id", column = @Column(name = "merchandise_id"))
20:     private MerchandiseId merchandiseId;
21: 
22:     private int quantity;
23: 
24:     public InventoryLevel(MerchandiseId merchandiseId, int quantity) {
25:         this.id = new InventoryLevelId(UUID.randomUUID());
26:         this.merchandiseId = merchandiseId;
27:         this.quantity = quantity;
28:     }
29: 
30:     public void increaseQuantity(int amount) {
31:         this.quantity += amount;
32:     }
33: 
34:     public void decreaseQuantity(int amount) {
35:         this.quantity -= amount;
36:     }
37: 
38: }
39: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\InventoryLevelId.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import thkoeln.archilab.ecommerce.GenericId;
4: import jakarta.persistence.Embeddable;
5: import java.util.UUID;
6: 
7: @Embeddable
8: public class InventoryLevelId extends GenericId {
9:     public InventoryLevelId() { super(); }
10:     public InventoryLevelId(UUID id) { super(id); }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnit.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Data;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.domainprimitives.Address;
8: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
9: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
10: 
11: import java.util.*;
12: 
13: @Entity
14: @Data
15: @NoArgsConstructor
16: 
17: public class StorageUnit {
18:     @EmbeddedId
19:     private StorageUnitId id;
20:     private String name;
21: 
22:     @Embedded
23:     private Address address;
24: 
25:     private Integer fromZipCodeFirstDigit;
26:     private Integer toZipCodeFirstDigit;
27: 
28:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
29:     @JoinColumn(name = "storage_unit_id")
30:     private List<InventoryLevel> inventoryLevels = new ArrayList<>();
31: 
32:     public StorageUnit(String name, Address address, Integer fromZipCodeFirstDigit,
33:                        Integer toZipCodeFirstDigit) {
34:         this.id = new StorageUnitId(UUID.randomUUID());
35:         this.name = name;
36:         this.address = Address.of(
37:                 address.getStreet(),
38:                 address.getCity(),
39:                 ZipCode.of(address.getZipCode().toString())
40:         );
41:         this.fromZipCodeFirstDigit = fromZipCodeFirstDigit;
42:         this.toZipCodeFirstDigit = toZipCodeFirstDigit;
43:     }
44: 
45:     public boolean isResponsibleForZipCode(String zipCode) {
46:         if (zipCode == null || zipCode.isEmpty()) {
47:             return false;
48:         }
49: 
50:         int firstDigit = Character.getNumericValue(zipCode.charAt(0));
51:         return firstDigit >= fromZipCodeFirstDigit && firstDigit <= toZipCodeFirstDigit;
52:     }
53: 
54:     public void addToInventory(MerchandiseId merchandiseId, int quantity) {
55:         for (InventoryLevel level : inventoryLevels) {
56:             if (level.getMerchandiseId().equals(merchandiseId)) {
57:                 level.increaseQuantity(quantity);
58:                 return;
59:             }
60:         }
61: 
62:         InventoryLevel newLevel = new InventoryLevel(merchandiseId, quantity);
63:         inventoryLevels.add(newLevel);
64:     }
65: 
66:     public void removeFromInventory(MerchandiseId merchandiseId, int quantity) {
67:         if (merchandiseId == null) {
68:             throw new ShopException("Merchandise id cannot be null");
69:         }
70:         if (quantity < 0) {
71:             throw new ShopException("Quantity cannot be negative");
72:         }
73:         if (quantity == 0) {
74:             return;
75:         }
76: 
77:         InventoryLevel level = findInventoryLevel(merchandiseId);
78:         if (level == null) {
79:             throw new ShopException("Inventory level not found");
80:         }
81: 
82:         int currentQuantity = level.getQuantity();
83:         if (currentQuantity < quantity) {
84:             throw new ShopException("Insufficient inventory");
85:         }
86:         level.setQuantity(currentQuantity - quantity);
87: 
88:         if (level.getQuantity() == 0) {
89:             inventoryLevels.remove(level);
90:         }
91:     }
92: 
93:     private InventoryLevel findInventoryLevel(MerchandiseId merchandiseId) {
94:         return inventoryLevels.stream()
95:                 .filter(level -> level.getMerchandiseId().equals(merchandiseId))
96:                 .findFirst().orElse(null);
97:     }
98: 
99:     public void setInventoryLevel(MerchandiseId merchandiseId, int quantity) {
100:         for (InventoryLevel level : inventoryLevels) {
101:             if (level.getMerchandiseId().equals(merchandiseId)) {
102:                 level.setQuantity(quantity);
103:                 return;
104:             }
105:         }
106: 
107:         InventoryLevel newLevel = new InventoryLevel(merchandiseId, quantity);
108:         inventoryLevels.add(newLevel);
109:     }
110: 
111:     public int getInventoryLevel(MerchandiseId merchandiseId) {
112:         InventoryLevel level = findInventoryLevel(merchandiseId);
113:         return level != null ? level.getQuantity() : 0;
114:     }
115: 
116:     public int getTotalInventory() {
117:         return inventoryLevels.stream()
118:                 .mapToInt(InventoryLevel::getQuantity)
119:                 .sum();
120:     }
121: }
122: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitComparator.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import java.util.Comparator;
4: 
5: public class StorageUnitComparator implements Comparator<StorageUnit> {
6:     @Override
7:     public int compare(StorageUnit unit1, StorageUnit unit2) {
8:         int inventoryComparison = Integer.compare(
9:                 unit2.getTotalInventory(),
10:                 unit1.getTotalInventory()
11:         );
12:         if (inventoryComparison != 0) return inventoryComparison;
13: 
14:         return unit1.getAddress().getZipCode().difference(
15:                 unit2.getAddress().getZipCode()
16:         );
17:     }
18: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitId.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import thkoeln.archilab.ecommerce.GenericId;
4: import jakarta.persistence.Embeddable;
5: import java.util.UUID;
6: 
7: @Embeddable
8: public class StorageUnitId extends GenericId {
9:     public StorageUnitId() { super(); }
10:     public StorageUnitId(UUID id) { super(id); }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: 
5: public interface StorageUnitRepository extends JpaRepository<StorageUnit, StorageUnitId> {
6: 
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\CustomerRegistrationUseCases.java ---
1: /*
2:  * Authored by ArchiLab 2025, TH Köln - not for distribution
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
10: 
11: /**
12:  * This interface contains methods needed in the context of use cases concerning the registration of a customer.
13:  * The interface is probably incomplete, and will grow over time ...
14:  */
15: public interface CustomerRegistrationUseCases {
16:     /**
17:      * Registers a new customer
18:      *
19:      * @param name
20:      * @param mailAddress
21:      * @param address
22:      * @throws ShopException if ...
23:      *      - the customer with the given mail address already exists
24:      *      - address is null
25:      */
26:     public void register( String name, MailAddressType mailAddress, AddressType address );
27: 
28: 
29:     /**
30:      * Changes the address of a customer
31:      *
32:      * @param customerMailAddress
33:      * @param customerMailAddress
34:      * @param address
35:      * @throws ShopException if ...
36:      *      - the customer with the given mail address does not exist,
37:      *      - address is null
38:      */
39:     public void changeAddress( MailAddressType customerMailAddress,
40:                                AddressType address );
41: 
42: 
43:     /**
44:      * Returns the data of a customer as an array of strings (name, mailAddress, street, city, zipCode)
45:      * @param customerMailAddress
46:      * @return the customer data
47:      * @throws ShopException the customer with the given mail address does not exist,
48:      */
49:     public CustomerType getCustomerData( MailAddressType customerMailAddress );
50: 
51: 
52: 
53:     /**
54:      * Clears all customers, including all purchases and shopping carts
55:      */
56:     public void deleteAllCustomers();
57: }
58: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\CustomerType.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
5: 
6: /**
7:  * This interface expresses the essence of a shop customer
8:  */
9: public interface CustomerType {
10:     String getName();
11:     MailAddressType getMailAddress();
12:     AddressType getAddress();
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\AddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface AddressType {
6:     /**
7:      * @return the street as a string
8:      */
9:     public String getStreet();
10: 
11:     /**
12:      * @return the city as a string
13:      */
14:     public String getCity();
15: 
16:     /**
17:      * @return the zip code
18:      */
19:     public ZipCodeType getZipCode();
20: 
21:     /**
22:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
23:      * implementing class to provide a static factory method (simply named "of(...)"),
24:      * which creates an zip code, given as a string.
25:      * We specify this factory method here as a comment, using the Javadoc documentation style.
26:      *
27:      * @param street the street as a string
28:      * @param city the city as a string
29:      * @param zipCode the zip code
30:      * @return the address object matching the parameters
31:      * @throws ShopException if ...
32:      *      - street is null or empty
33:      *      - city is null or empty
34:      *      - zipCode is null
35:      */
36:      // public static AddressType of( String street, String city, ZipCodeType zipCode );
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MailAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface MailAddressType {
6:     /**
7:      * @return the mail address as a string
8:      */
9:     public String toString();
10: 
11: 
12:     /**
13:      * A special kind of "copy constructor": Returns a new mail address object with
14:      * the same identifyer (the substring left of the "@" sign) as the current one, but
15:      * with a new domain substring (right of the "@" sign).
16:      * @param domainString - the new domain for the copied mail address
17:      * @return the new mail address
18:      * @throws ShopException if ...
19:      *     - domainString is null
20:      *     - the new mail address would not be valid (see `of(...)` method)
21:      */
22:     public MailAddressType sameIdentifyerDifferentDomain( String domainString );
23: 
24:     /**
25:      * Another special kind of "copy constructor": Returns a new mail address object
26:      * with the same domain (the substring right of the "@" sign) as the current one, but
27:      * with a new identifyer substring (left of the "@" sign).
28:      * @param identifyerString - the new identifyer for the copied mail address
29:      * @return the new mail address
30:      * @throws ShopException if ...
31:      *     - identifyerString is null
32:      *     - the new mail address would not be valid (see `of(...)` method)
33:      */
34:     public MailAddressType sameDomainDifferentIdentifyer( String identifyerString );
35: 
36: 
37:     /**
38:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
39:      * implementing class to provide a static factory method (simply named "of(...)"),
40:      * which creates an mail address, given as a string.
41:      * We specify this factory method here as a comment, using the Javadoc documentation style.
42:      *
43:      * @param mailAddressAsString - the mail address as a string.
44:      *      We will use a much simplified validation method to check if the mail address is valid:
45:      *      - it must contain exactly one '@' character.
46:      *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
47:      *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
48:      *      - the substrings before and after the '@' may contain one or several '.' as separators
49:      *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
50:      *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
51:      *        (for simplicity we do not allow any other domains)
52:      * @return a new MailAddressType object matching the given mail address
53:      * @throws ShopException if ...
54:      *      - mailAddressAsString is null
55:      *      - mailAddressAsString is not a valid mail address (see above)
56:      */
57:      // public static MailAddressType of( String mailAddressAsString );
58: }
59: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MoneyType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface MoneyType {
6:     /**
7:      * @return the amount of money
8:      */
9:     public Float getAmount();
10: 
11: 
12:     /**
13:      * @return the currency unit of the money
14:      */
15:     public String getCurrencyUnit();
16: 
17: 
18:     /**
19:      * @param otherMoney
20:      * @return this + otherMoney, as a new object
21:      * @throws ShopException if ...
22:      *      - otherMoney is null
23:      *      - otherMoney.currencyUnit != this.currencyUnit
24:      */
25:     public MoneyType add( MoneyType otherMoney );
26: 
27: 
28:     /**
29:      * @param otherMoney
30:      * @return this - otherMoney, as a new object
31:      * @throws ShopException if ...
32:      *      - otherMoney is null
33:      *      - otherMoney.currencyUnit != this.currencyUnit
34:      *      - otherMoney > this
35:      */
36:     public MoneyType subtract( MoneyType otherMoney );
37: 
38: 
39:     /**
40:      * @param factor
41:      * @return this * factor, as a new object
42:      * @throws ShopException if ...
43:      *     - factor < 0
44:      */
45:     public MoneyType multiplyBy( int factor );
46: 
47:     /**
48:      * @param otherMoney
49:      * @return true, if this > otherMoney
50:      * @throws ShopException if ...
51:      *      - otherMoney is null
52:      *      - otherMoney.currencyUnit != this.currencyUnit
53:      */
54:     public boolean largerThan( MoneyType otherMoney );
55: 
56: 
57:     /**
58:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
59:      * implementing class to provide a static factory method (simply named "of(...)"),
60:      * which creates a money object from an amount and a currency unit (as string).
61:      * We specify this factory method here as a comment, using the Javadoc documentation style.
62:      *
63:      * @param amount the amount of money (must be >= 0)
64:      * @param currencyUnit the currency unit of the money (allowed values: "EUR", "CHF")
65:      * @return a new Money object with the given amount and currency unit
66:      * @throws ShopException if ...
67:      *   - amount is null
68:      *   - amount < 0
69:      *   - currency unit is null
70:      *   - currency unit is not one of the allowed values
71:      */
72:      // public static MoneyType of( Float amount, String currencyUnit );
73: }
74: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\ZipCodeType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnore;
4: import thkoeln.archilab.ecommerce.ShopException;
5: 
6: public interface ZipCodeType {
7:     /**
8:      * @return the zip code as a string
9:      */
10:     public String toString();
11: 
12:     /**
13:      * You will need some idea of "imprecise difference" between two zip codes for properly
14:      * implementing storage units in your shopping platform. This method calculates such a
15:      * difference. You can decide for yourself what values you return, unless you comply
16:      * with the following rules.
17:      * - The return value is 0 if both zip codes are the same
18:      * - If not:
19:      *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
20:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
21:      *        So, 56733 and 56734 have the same difference as 56733 and 56739.
22:      *      - The difference grows if more digits (counted from the right side) differ.
23:      *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
24:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
25:      *        53876 and 54876 have the same difference as 53876 and 57261.
26:      *      - However, the difference between 5abcd and 6rstu must be smaller than the one
27:      *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
28:      *        one between 5abcd and 9rstu.
29:      *      - This last condition reflects the fact the first digits of a zip code marks a region
30:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
31:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
32:      *        other.
33:      * @param otherZipCode
34:      * @return the calculated difference
35:      * @throws ShopException if otherZipCode is null
36:      */
37:     public int difference( ZipCodeType otherZipCode );
38: 
39: 
40:     /**
41:      * For the currently used way of deciding on the best fitting storage unit for a purchase,
42:      * we need to know the first digit of the zip code.
43:      */
44:     @JsonIgnore
45:     public Integer getFirstDigitZipCode();
46: 
47: 
48:     /**
49:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
50:      * implementing class to provide a static factory method (simply named "of(...)"),
51:      * which creates an zip code, given as a string.
52:      * We specify this factory method here as a comment, using the Javadoc documentation style.
53:      *
54:      * @param zipCodeAsString - the zip code as a string.
55:      *      We will use a much simplified validation method to check if the zip code is valid:
56:      *      - It must contain exactly 5 digits.
57:      *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid zip code, but 20001 is valid)
58:      * @return a new zip code object matching the given string
59:      * @throws ShopException if ...
60:      *      - zipCodeAsString is null
61:      *      - zipCodeAsString is not a valid zip code (see above)
62:      */
63:      // public static ZipCodeType of( String zipCodeAsString );
64: }
65: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\CustomerTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: 
4: import thkoeln.archilab.ecommerce.usecases.CustomerType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
7: 
8: /**
9:  * This is a test helper interface provides access to predefined test data for
10:  * customers.
11:  */
12: public interface CustomerTestHelper {
13:     /**
14:      * This method calls the use case implementation to register all customers specified in the
15:      * test data set.
16:      * If you use the debugger and want to identify _which_ test customer you currently look at:
17:      * The indices are coded into the house number (in the customer's address) and in the first
18:      * cipher of the zip code. This is the list of customers:
19:      *
20:      * +-------+-------------------+--------+---------------------
21:      * | Index | Name              | PLZ    | MailAddress
22:      * +-------+-------------------+--------+---------------------
23:      * | 0     | Max Mueller       | 02314  | 99Z@example.com
24:      * | 1     | Sophie Schmitz    | 02368  | a@4.com
25:      * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
26:      * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
27:      * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
28:      * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
29:      * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
30:      * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
31:      * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
32:      * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
33:      * +-------+-------------------+--------+---------------------
34:      */
35:     void registerAllCustomers();
36: 
37: 
38:     /**
39:      * @return the number of test customers in the test data set.
40:      */
41:     int getNumberOfCustomers();
42: 
43: 
44:     /**
45:      * @param index the index of the customer in the test data set.
46:      * @return the name of the test customer with the given index.
47:      */
48:     String getCustomerName( int index );
49: 
50: 
51:     /**
52:      * @param index the index of the customer in the test data set.
53:      * @return the mail address of the test customer with the given index.
54:      */
55:     MailAddressType getCustomerMailAddress( int index );
56: 
57: 
58:     /**
59:      * @param index the index of the customer in the test data set.
60:      * @return the address of the test customer with the given index.
61:      */
62:     AddressType getCustomerAddress( int index );
63: 
64: 
65:     /**
66:      * @param index the index of the customer in the test data set.
67:      * @return the test customer with the given index.
68:      */
69:     CustomerType getCustomer( int index );
70: 
71: }
72: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
8: 
9: import java.io.File;
10: import java.io.IOException;
11: import java.lang.reflect.InvocationTargetException;
12: import java.lang.reflect.Method;
13: import java.lang.reflect.Modifier;
14: import java.net.URL;
15: import java.net.URLDecoder;
16: import java.nio.charset.StandardCharsets;
17: import java.util.Enumeration;
18: 
19: import static org.junit.jupiter.api.Assertions.*;
20: 
21: public class FactoryMethodInvoker {
22: 
23:     public static MailAddressType instantiateMailAddress( String mailAddressAsString ) {
24:         Method factoryMethod = null;
25:         try {
26:             Class<?> interfaceClass = Class.forName(
27:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType" );
28:             Class<?> implementingClass = findImplementation( interfaceClass );
29: 
30:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
31:             assertNotNull( factoryMethod );
32:             int modifiers = factoryMethod.getModifiers();
33:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
34:         } catch (Exception e) {
35:             fail( "Failed to find implementation for MailAddressType", e );
36:         }
37: 
38:         Object instance = null;
39:         try {
40:             instance = factoryMethod.invoke( null, mailAddressAsString );
41:         } catch (Exception e) {
42:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
43:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
44:             fail( "Failed to invoke factory method 'of' for '" + mailAddressAsString + "'", e );
45:         }
46:         assertNotNull( instance );
47:         return (MailAddressType) instance;
48:     }
49: 
50: 
51:     public static AddressType instantiateAddress(
52:             String street, String city, ZipCodeType zipCode ) {
53:         Method factoryMethod = null;
54:         try {
55:             Class<?> interfaceClass = Class.forName(
56:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType" );
57:             Class<?> implementingClass = findImplementation( interfaceClass );
58: 
59:             factoryMethod = implementingClass.getDeclaredMethod( "of",
60:                     String.class, String.class, ZipCodeType.class );
61:             assertNotNull( factoryMethod );
62:             int modifiers = factoryMethod.getModifiers();
63:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
64:         } catch (Exception e) {
65:             fail( "Failed to find implementation for AddressType", e );
66:         }
67: 
68:         Object instance = null;
69:         try {
70:             instance = factoryMethod.invoke( null, street, city, zipCode );
71:         } catch (Exception e) {
72:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
73:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
74:             fail( "Failed to invoke factory method 'of' for '" +
75:                     street + "', '" + city + "', '" + zipCode + "'", e );
76:         }
77:         assertNotNull( instance );
78:         return (AddressType) instance;
79:     }
80: 
81: 
82:     public static ZipCodeType instantiateZipCode( String zipCodeAsString ) {
83:         Method factoryMethod = null;
84:         try {
85:             Class<?> interfaceClass = Class.forName(
86:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType" );
87:             Class<?> implementingClass = findImplementation( interfaceClass );
88: 
89:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
90:             assertNotNull( factoryMethod );
91:             int modifiers = factoryMethod.getModifiers();
92:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
93:         } catch (Exception e) {
94:             fail( "Failed to find implementation for ZipCodeType", e );
95:         }
96: 
97:         Object instance = null;
98:         try {
99:             instance = factoryMethod.invoke( null, zipCodeAsString );
100:         } catch (Exception e) {
101:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
102:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
103:             fail( "Failed to invoke factory method 'of' for '" + zipCodeAsString + "'", e );
104:         }
105:         assertNotNull( instance );
106:         return (ZipCodeType) instance;
107:     }
108: 
109: 
110:     public static MoneyType instantiateMoney( Float amount, String currencyUnit ) {
111:         Method factoryMethod = null;
112:         try {
113:             Class<?> interfaceClass = Class.forName(
114:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType" );
115:             Class<?> implementingClass = findImplementation( interfaceClass );
116: 
117:             factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
118:             assertNotNull( factoryMethod );
119:             int modifiers = factoryMethod.getModifiers();
120:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
121:         } catch (Exception e) {
122:             fail( "Failed to find implementation for MoneyType", e );
123:         }
124: 
125:         Object instance = null;
126:         try {
127:             instance = factoryMethod.invoke( null, amount, currencyUnit );
128:         } catch (Exception e) {
129:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
130:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
131:             fail( "Failed to invoke factory method 'of' for '" + amount + "', '" + currencyUnit + "'", e );
132:         }
133:         assertNotNull( instance );
134:         return (MoneyType) instance;
135:     }
136: 
137: 
138:     private static Class<?> findImplementation( Class<?> interfaceClass ) {
139:         Method factoryMethod = null;
140:         try {
141:             String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
142:             Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
143:             assertNotNull( implementingClass );
144:             return implementingClass;
145:         } catch (Exception e) {
146:             fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
147:             return null; // This line will never be reached, but it's necessary to satisfy the compiler
148:         }
149:     }
150: 
151: 
152:     private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
153:             throws ClassNotFoundException, IOException {
154:         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
155:         String path = packageName.replace( '.', '/' );
156:         Enumeration<URL> resources = classLoader.getResources( path );
157:         int count = 0;
158:         Class<?> result = null;
159:         while (resources.hasMoreElements()) {
160:             URL resource = resources.nextElement();
161:             File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
162:             File[] files = directory.listFiles();
163:             for ( File file : files ) {
164:                 if ( file.getName().endsWith( ".class" ) ) {
165:                     String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
166:                     Class<?> clazz = Class.forName( className );
167:                     if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
168:                         count++;
169:                         result = clazz;
170:                     }
171:                 }
172:             }
173:         }
174:         assertEquals( 1, count, "There should be exactly one implementing class" );
175:         return result;
176:     }
177: }
178: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\CustomerTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
7: import thkoeln.archilab.ecommerce.usecases.CustomerType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.MockCustomer;
12: 
13: import static org.junit.jupiter.api.Assertions.assertThrows;
14: 
15: /**
16:  * This is a test helper class that initializes and registers customers in the system,
17:  * using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class CustomerTestHelperImpl implements CustomerTestHelper {
22: 
23:     private CustomerRegistrationUseCases customerRegistrationUseCases;
24: 
25:     @Autowired
26:     public CustomerTestHelperImpl( CustomerRegistrationUseCases customerRegistrationUseCases ) {
27:         this.customerRegistrationUseCases = customerRegistrationUseCases;
28:     }
29: 
30:     private final static String[] CUSTOMER_NAME = new String[]{
31:             "Max Mueller",
32:             "Sophie Schmitz",
33:             "Irene Mihalic",
34:             "Emilia Fischer",
35:             "Filiz Polat",
36:             "Lina Wagner",
37:             "Leon Becker",
38:             "Agnieszka Kalterer",
39:             "Felix Bauer",
40:             "Lara Schulz"
41:     };
42: 
43:     private final static MailAddressType[] CUSTOMER_EMAIL = new MailAddressType[]{
44:             FactoryMethodInvoker.instantiateMailAddress( "99Z@example.com" ),
45:             FactoryMethodInvoker.instantiateMailAddress( "a@4.com" ),
46:             FactoryMethodInvoker.instantiateMailAddress( "irene@wearefreedomnow.com" ),
47:             FactoryMethodInvoker.instantiateMailAddress( "emilia.fischer@example.com" ),
48:             FactoryMethodInvoker.instantiateMailAddress( "j877d3@example.this.com" ),
49:             FactoryMethodInvoker.instantiateMailAddress( "lina.marie.wagner@example.com" ),
50:             FactoryMethodInvoker.instantiateMailAddress( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
51:             FactoryMethodInvoker.instantiateMailAddress( "agna@here.ch" ),
52:             FactoryMethodInvoker.instantiateMailAddress( "felix.bauer@example.org" ),
53:             FactoryMethodInvoker.instantiateMailAddress( "lara.schulz@example.at" )
54:     };
55: 
56:     // The following array is used to create a list of addresss for the customers.
57:     // The indices are coded into the house number.
58:     // - Persons 0 - 5 are used for proximity tests with one storage unit.
59:     private final static AddressType[] CUSTOMER_ADDRESS = new AddressType[]{
60:             FactoryMethodInvoker.instantiateAddress(
61:                     "Marktstraße 0", "Viertelstadt",
62:                     FactoryMethodInvoker.instantiateZipCode( "02314" ) ),
63:             FactoryMethodInvoker.instantiateAddress(
64:                     "Hauptstraße 1", "Viertelstadt",
65:                     FactoryMethodInvoker.instantiateZipCode( "02368" ) ),
66:             FactoryMethodInvoker.instantiateAddress(
67:                     "Kirchplatz 2", "Niemandstown",
68:                     FactoryMethodInvoker.instantiateZipCode( "12345" ) ),
69:             FactoryMethodInvoker.instantiateAddress(
70:                     "Schulstraße 3", "Geisterhausen",
71:                     FactoryMethodInvoker.instantiateZipCode( "31463" ) ),
72:             FactoryMethodInvoker.instantiateAddress(
73:                     "Rosenweg 4", "Kuhhausen",
74:                     FactoryMethodInvoker.instantiateZipCode( "72162" ) ),
75:             FactoryMethodInvoker.instantiateAddress(
76:                     "Wiesenstraße 5", "Waldschenkensdorf",
77:                     FactoryMethodInvoker.instantiateZipCode( "82195" ) ),
78:             FactoryMethodInvoker.instantiateAddress(
79:                     "Muehlenweg 6", "Koeln",
80:                     FactoryMethodInvoker.instantiateZipCode( "50667" ) ),
81:             FactoryMethodInvoker.instantiateAddress(
82:                     "Goethestraße 7", "Frankfurt am Main",
83:                     FactoryMethodInvoker.instantiateZipCode( "60311" ) ),
84:             FactoryMethodInvoker.instantiateAddress(
85:                     "Dorfstraße 8", "Stuttgart",
86:                     FactoryMethodInvoker.instantiateZipCode( "70173" ) ),
87:             FactoryMethodInvoker.instantiateAddress(
88:                     "Bahnhofstraße 9", "Muenchen",
89:                     FactoryMethodInvoker.instantiateZipCode( "80331" ) )
90:     };
91: 
92:     private final static CustomerType[] mockCustomers;
93: 
94:     static {
95:         mockCustomers = new CustomerType[CUSTOMER_NAME.length];
96:         for ( int i = 0; i < CUSTOMER_NAME.length; i++ ) {
97:             mockCustomers[i] = new MockCustomer(
98:                     CUSTOMER_NAME[i], CUSTOMER_EMAIL[i], CUSTOMER_ADDRESS[i] );
99:         }
100:     }
101: 
102: 
103:     @Override
104:     public void registerAllCustomers() {
105:         for ( int i = 0; i < CUSTOMER_NAME.length; i++ ) {
106:             registerCustomer( CUSTOMER_NAME[i], CUSTOMER_EMAIL[i], CUSTOMER_ADDRESS[i] );
107:         }
108:     }
109: 
110: 
111:     private void registerCustomer( String name, MailAddressType mailAddress, AddressType address ) {
112:         customerRegistrationUseCases.register( name, mailAddress, address );
113:     }
114: 
115: 
116:     @Override
117:     public int getNumberOfCustomers() {
118:         return CUSTOMER_NAME.length;
119:     }
120: 
121: 
122:     @Override
123:     public String getCustomerName( int index ) {
124:         if ( index < 0 || index >= CUSTOMER_NAME.length ) {
125:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
126:         }
127:         return CUSTOMER_NAME[index];
128:     }
129: 
130: 
131:     @Override
132:     public MailAddressType getCustomerMailAddress( int index ) {
133:         if ( index < 0 || index >= CUSTOMER_NAME.length ) {
134:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
135:         }
136:         return CUSTOMER_EMAIL[index];
137:     }
138: 
139: 
140:     @Override
141:     public AddressType getCustomerAddress( int index ) {
142:         if ( index < 0 || index >= CUSTOMER_NAME.length ) {
143:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
144:         }
145:         return CUSTOMER_ADDRESS[index];
146:     }
147: 
148: 
149:     @Override
150:     public CustomerType getCustomer( int index ) {
151:         if ( index < 0 || index >= CUSTOMER_NAME.length ) {
152:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
153:         }
154:         return mockCustomers[index];
155:     }
156: }
157: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\InventoryTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
7: import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
8: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
12: 
13: import java.util.*;
14: 
15: /**
16:  * This is a test helper class that initializes and registers merchandises (but without inventory)
17:  * in the system, using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class InventoryTestHelperImpl
22:                         implements MerchandiseTestHelper, StorageUnitTestHelper {
23:     private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
24:     private StorageUnitUseCases storageUnitUseCases;
25:     private static Random random = new Random();
26: 
27:     private static final String EUR = "EUR";
28:     private static final int MERCHANDISE_NUMOF = 15;
29:     private static final Object[][] MERCHANDISE_DATA = new Object[][]{
30:             {null, "0-TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
31:                     1.5f, FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
32:                     FactoryMethodInvoker.instantiateMoney( 10.0f, EUR ),
33:                     "0"},
34:             {null, "1-EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
35:                     0.3f, FactoryMethodInvoker.instantiateMoney( 2.5f, EUR ),
36:                     FactoryMethodInvoker.instantiateMoney( 4.0f, EUR ),
37:                     "0"},
38:             {null, "2-MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
39:                     7.2f, FactoryMethodInvoker.instantiateMoney( 50.0f, EUR ),
40:                     FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
41:                     "0"},
42:             {null, "3-Gh-25", "Kompakter und leichter Akku für mobile Geräte",
43:                     null, FactoryMethodInvoker.instantiateMoney( 6.0f, EUR ),
44:                     FactoryMethodInvoker.instantiateMoney( 8.0f, EUR ),
45:                     "0"},
46:             {null, "4-MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
47:                     null, FactoryMethodInvoker.instantiateMoney( 0.6f, EUR ),
48:                     FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
49:                     "0"},
50:             {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
51:                     1.0f, FactoryMethodInvoker.instantiateMoney( 150.0f, EUR ),
52:                     FactoryMethodInvoker.instantiateMoney( 250.0f, EUR ),
53:                     "0"},
54:             {null, "6-Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
55:                     null, FactoryMethodInvoker.instantiateMoney( 0.3f, EUR ),
56:                     FactoryMethodInvoker.instantiateMoney( 0.5f, EUR ),
57:                     "0"},
58:             {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
59:                     6.0f, FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
60:                     FactoryMethodInvoker.instantiateMoney( 120.0f, EUR ),
61:                     "123"},
62:             {null, "8-JKL-67", "Wasserdichtes Gehäuse",
63:                     3.0f, FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
64:                     FactoryMethodInvoker.instantiateMoney( 1.2f, EUR ),
65:                     "467"},
66:             {null, "9-MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
67:                     5.5f, FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
68:                     FactoryMethodInvoker.instantiateMoney( 45.0f, EUR ),
69:                     "578"},
70:             {null, "10-PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
71:                     4.0f, FactoryMethodInvoker.instantiateMoney( 20.0f, EUR ),
72:                     FactoryMethodInvoker.instantiateMoney( 35.0f, EUR ),
73:                     "567"},
74:             {null, "11-STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
75:                     null, FactoryMethodInvoker.instantiateMoney( 200.0f, EUR ),
76:                     FactoryMethodInvoker.instantiateMoney( 350.0f, EUR ),
77:                     "478"},
78:             {null, "12-VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
79:                     null, FactoryMethodInvoker.instantiateMoney( 15.0f, EUR ),
80:                     FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
81:                     "5"},
82:             {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
83:                     3.5f, FactoryMethodInvoker.instantiateMoney( 60.0f, EUR ),
84:                     FactoryMethodInvoker.instantiateMoney( 100.0f, EUR ),
85:                     "78"},
86:             {null, "14-Nosedive", "Klammer zum Verschließen der Nase beim Tauchen",
87:                     5.0f, FactoryMethodInvoker.instantiateMoney( 2.0f, EUR ),
88:                     FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
89:                     "457"}
90:     };
91:     
92: 
93:     // These addresss are used for the storage units. The storage unit name will equal
94:     // the zip code of the site. Their index number will be visible in the house number.
95:     // The storage units are used as such:
96:     // - storage unit 0 is holds all merchandises 0 - 6, and is used for all tests where multiple
97:     //   shipments are irrelevant.
98:     // - storage units 1 - 3 are used for the proximity tests, where you can deliver merchandises 7 to
99:     //   to a customer from the closest storage unit.
100:     // - storage units 4 - 8 are used for the tests where you need to deliver merchandises 8 - 14 in
101:     //   the most cost-efficient way, as multiple shipments.
102:     // - storage unit 9 is empty.
103:     private final static int STORAGE_UNIT_NUMOF = 10;
104:     private final static AddressType[] STORAGE_UNIT_ADDRESS = new AddressType[]{
105:             FactoryMethodInvoker.instantiateAddress(
106:                     "Stapelallee 0", "Potsdam",
107:                     FactoryMethodInvoker.instantiateZipCode( "14476" ) ),
108:             FactoryMethodInvoker.instantiateAddress(
109:                     "Lagerhausstr. 1", "Viertelstadt",
110:                     FactoryMethodInvoker.instantiateZipCode( "02345" ) ),
111:             FactoryMethodInvoker.instantiateAddress(
112:                     "Speicherplatz 2", "Viertelstadt",
113:                     FactoryMethodInvoker.instantiateZipCode( "02313" ) ),
114:             FactoryMethodInvoker.instantiateAddress(
115:                     "Ablageweg 3", "Reichswürgen",
116:                     FactoryMethodInvoker.instantiateZipCode( "44923" ) ),
117:             FactoryMethodInvoker.instantiateAddress(
118:                     "Paketstellenallee 4", "Düsseldorf",
119:                     FactoryMethodInvoker.instantiateZipCode( "40588" ) ),
120:             FactoryMethodInvoker.instantiateAddress(
121:                     "Kaputte-Sachen-Straße 5", "Düren",
122:                     FactoryMethodInvoker.instantiateZipCode( "52355" ) ),
123:             FactoryMethodInvoker.instantiateAddress(
124:                     "Aufbewahrungsweg 6", "Viernheim",
125:                     FactoryMethodInvoker.instantiateZipCode( "68519" ) ),
126:             FactoryMethodInvoker.instantiateAddress(
127:                     "Paketallee 7", "Baden-Baden",
128:                     FactoryMethodInvoker.instantiateZipCode( "76532" ) ),
129:             FactoryMethodInvoker.instantiateAddress(
130:                     "Sendenstr. 8", "Senden",
131:                     FactoryMethodInvoker.instantiateZipCode( "89250" ) ),
132:             FactoryMethodInvoker.instantiateAddress(
133:                     "Schickweg 9", "Hohenroth",
134:                     FactoryMethodInvoker.instantiateZipCode( "97618" ) )
135:     };
136:     private final static UUID[] STORAGE_UNIT_ID = new UUID[STORAGE_UNIT_NUMOF];
137: 
138: 
139:     // These data structures contain the inventory of the merchandises in the storage units.
140:     // MERCHANDISE_INVENTORY is a map merchandise name -> Integer[STORAGE_UNIT_NUMOF].
141:     // The Integer[STORAGE_UNIT_NUMOF] contains the inventory of the merchandise in each of
142:     // the storage units.
143:     //
144:     // The following rules apply:
145:     // - merchandise 0 is out of inventory
146:     // - merchandise 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in storage unit 0
147:     // - merchandise 4 / 5 / 6 have a random inventory between 30 and 130, also all ONLY in storage unit 0
148:     //   (these are the merchandises used for tests on how to add and remove inventory)
149:     // - the others have a random inventory between 30 and 130, distributed over several
150:     //   storage units. Here we follow this convention for simplicity:
151:     //   - Assume that the merchandise is available in <n> storage units. Then the first <n-1> storage units
152:     //     in the list (in ascending sequence) contain 3, and all the remaining inventory is in the
153:     //     last storage unit.
154: 
155:     private static final Map<String, Integer[]> MERCHANDISE_INVENTORY = new HashMap<>();
156: 
157:     static {
158:         // merchandises 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
159:         MERCHANDISE_INVENTORY.put( (String) MERCHANDISE_DATA[0][1],
160:                 getInventoryDistribution( 0, (String) MERCHANDISE_DATA[0][6] ) );
161:         MERCHANDISE_INVENTORY.put( (String) MERCHANDISE_DATA[1][1],
162:                 getInventoryDistribution( 10, (String) MERCHANDISE_DATA[1][6] ) );
163:         MERCHANDISE_INVENTORY.put( (String) MERCHANDISE_DATA[2][1],
164:                 getInventoryDistribution( 20, (String) MERCHANDISE_DATA[2][6] ) );
165:         MERCHANDISE_INVENTORY.put( (String) MERCHANDISE_DATA[3][1],
166:                 getInventoryDistribution( 30, (String) MERCHANDISE_DATA[3][6] ) );
167: 
168:         // The other merchandises have a random inventory between 30 and 130,
169:         for ( int i = 4; i < MERCHANDISE_NUMOF; i++ ) {
170:             Integer totalNumber = random.nextInt( 100 ) + 30;
171:             Integer[] inventoryInStorageUnits =
172:                     getInventoryDistribution( totalNumber, (String) MERCHANDISE_DATA[i][6] );
173:             MERCHANDISE_INVENTORY.put( (String) MERCHANDISE_DATA[i][1], inventoryInStorageUnits );
174:         }
175:     }
176: 
177:     /**
178:      * This method creates a random inventory distribution for the given merchandise.
179:      *
180:      * @param totalQuantity - the total number of merchandises in the storage units
181:      * @param zeroToNine  - a string with numbers between 0 and 9, representing the storage units
182:      * @return an Integer array with the inventory distribution for the merchandise, according to
183:      * the rules described above.
184:      */
185:     private static Integer[] getInventoryDistribution( Integer totalQuantity, String zeroToNine ) {
186:         Integer[] inventoryInStorageUnits = new Integer[STORAGE_UNIT_NUMOF];
187:         for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) inventoryInStorageUnits[i] = 0;
188:         TreeSet<Integer> storageUnitIndices = getStorageUnitIndices( zeroToNine );
189:         int numOfIndices = storageUnitIndices.size();
190:         int currentIndexNumber = 0;
191:         int currentQuantity = totalQuantity;
192:         for ( Integer storageUnitIndex : storageUnitIndices ) {
193:             currentIndexNumber++;
194:             if ( currentIndexNumber < numOfIndices ) {
195:                 inventoryInStorageUnits[storageUnitIndex] = 3;
196:                 currentQuantity -= 3;
197:             } else {
198:                 inventoryInStorageUnits[storageUnitIndex] = currentQuantity;
199:             }
200:         }
201:         return inventoryInStorageUnits;
202:     }
203: 
204:     private static TreeSet<Integer> getStorageUnitIndices( String zeroToNine ) {
205:         TreeSet<Integer> storageUnitIndices = new TreeSet<>();
206:         for ( int i = 0; i < zeroToNine.length(); i++ ) {
207:             storageUnitIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
208:         }
209:         return storageUnitIndices;
210:     }
211: 
212: 
213:     @Autowired
214:     public InventoryTestHelperImpl( MerchandiseCatalogUseCases merchandiseCatalogUseCases,
215:                                          StorageUnitUseCases storageUnitUseCases ) {
216:         this.merchandiseCatalogUseCases = merchandiseCatalogUseCases;
217:         this.storageUnitUseCases = storageUnitUseCases;
218:     }
219: 
220: 
221:     @Override
222:     public void addAllMerchandises() {
223:         int i = 0;
224:         for ( Object[] merchandiseData : MERCHANDISE_DATA ) {
225:             UUID newId = merchandiseCatalogUseCases.addMerchandiseToCatalog(
226:                     (String) merchandiseData[1], (String) merchandiseData[2],
227:                     (Float) merchandiseData[3], (MoneyType) merchandiseData[4],
228:                     (MoneyType) merchandiseData[5] );
229:             // The first element of the merchandise data is the id, which was initialized with null before, but can now be set
230:             MERCHANDISE_DATA[i][0] = newId;
231:             i++;
232:         }
233:     }
234: 
235: 
236:     @Override
237:     public int numberOfMerchandises() {
238:         return MERCHANDISE_NUMOF;
239:     }
240: 
241: 
242:     @Override
243:     public UUID getMerchandiseId( int index ) {
244:         if ( index < 0 || index >= MERCHANDISE_NUMOF ) {
245:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
246:         }
247:         return (UUID) MERCHANDISE_DATA[index][0];
248:     }
249: 
250: 
251:     @Override
252:     public MoneyType getBuyingPrice( int index ) {
253:         if ( index < 0 || index >= MERCHANDISE_NUMOF ) {
254:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
255:         }
256:         return (MoneyType) MERCHANDISE_DATA[index][4];
257:     }
258: 
259: 
260:     @Override
261:     public MoneyType getSalesPrice( int index ) {
262:         if ( index < 0 || index >= MERCHANDISE_NUMOF ) {
263:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
264:         }
265:         return (MoneyType) MERCHANDISE_DATA[index][5];
266:     }
267: 
268: 
269:     @Override
270:     public void addAllStorageUnits( boolean withInventory ) {
271:         for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) {
272:             STORAGE_UNIT_ID[i] = storageUnitUseCases.addNewStorageUnit(
273:                     STORAGE_UNIT_ADDRESS[i].getStreet(),
274:                     STORAGE_UNIT_ADDRESS[i] );
275:         }
276:         if ( withInventory ) {
277:             addAllInventory();
278:         }
279:     }
280: 
281: 
282:     private void addAllInventory() {
283:         for ( Object[] merchandiseData : MERCHANDISE_DATA ) {
284:             Integer[] inventoryInStorageUnits =
285:                     MERCHANDISE_INVENTORY.get( merchandiseData[1] );
286:             for ( int iStorageUnit = 0; iStorageUnit < STORAGE_UNIT_NUMOF; iStorageUnit++ ) {
287:                 if ( inventoryInStorageUnits[iStorageUnit] > 0 )
288:                     storageUnitUseCases.addToInventory(
289:                             STORAGE_UNIT_ID[iStorageUnit], (UUID) merchandiseData[0],
290:                             inventoryInStorageUnits[iStorageUnit] );
291:             }
292:         }
293:     }
294: 
295: 
296:     @Override
297:     public int numberOfStorageUnits() {
298:         return STORAGE_UNIT_NUMOF;
299:     }
300: 
301: 
302:     @Override
303:     public UUID getStorageUnitId( int index ) {
304:         if ( index < 0 || index >= STORAGE_UNIT_NUMOF ) {
305:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
306:         }
307:         return STORAGE_UNIT_ID[index];
308:     }
309: 
310: 
311:     @Override
312:     public Integer getStorageUnitInventory( int storageUnitIndex, int merchandiseIndex ) {
313:         if ( storageUnitIndex < 0 || storageUnitIndex >= STORAGE_UNIT_NUMOF ) {
314:             throw new IndexOutOfBoundsException( "Index out of bounds: " + storageUnitIndex );
315:         }
316:         if ( merchandiseIndex < 0 || merchandiseIndex >= MERCHANDISE_NUMOF ) {
317:             throw new IndexOutOfBoundsException( "Index out of bounds: " + merchandiseIndex );
318:         }
319:         String merchandiseName = (String) MERCHANDISE_DATA[merchandiseIndex][1];
320:         Integer[] inventoryInStorageUnits = MERCHANDISE_INVENTORY.get( merchandiseName );
321:         Integer foundInventory = inventoryInStorageUnits[storageUnitIndex];
322:         return foundInventory == null ? 0 : foundInventory;
323:     }
324: 
325: 
326:     @Override
327:     public int findStorageUnitIndex( UUID storageUnitId ) {
328:         for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) {
329:             if ( STORAGE_UNIT_ID[i].equals( storageUnitId ) ) {
330:                 return i;
331:             }
332:         }
333:         throw new IllegalArgumentException( "No test storage unit with UUID id " + storageUnitId );
334:     }
335: 
336: 
337:     @Override
338:     public int findMerchandiseIndex( UUID merchandiseId ) {
339:         for ( int iMerchandiseData = 0; iMerchandiseData < STORAGE_UNIT_NUMOF; iMerchandiseData++ ) {
340:             Object[] merchandiseData = MERCHANDISE_DATA[iMerchandiseData];
341:             if ( merchandiseData[0].equals( merchandiseId ) ) {
342:                 return iMerchandiseData;
343:             }
344:         }
345:         throw new IllegalArgumentException( "No test merchandise with UUID id " + merchandiseId );
346:     }
347: }
348: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MerchandiseTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
4: 
5: import java.util.UUID;
6: 
7: public interface MerchandiseTestHelper {
8:     /**
9:      * Adds all test merchandises to the database.
10:      * If you use the debugger and want to identify _which_ test merchandise you currently look at:
11:      * The indices are coded into the first number in the name string of the merchandise, like e.g.
12:      * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
13:      */
14:     void addAllMerchandises();
15: 
16: 
17:     /**
18:      * @return the number of test merchandises in the database
19:      */
20:     int numberOfMerchandises();
21: 
22: 
23:     /**
24:      * @param index
25:      * @return the id of the test merchandise at the given index
26:      */
27:     UUID getMerchandiseId( int index );
28: 
29: 
30:     /**
31:      * @param merchandiseId - the id of the merchandise in the test data
32:      * @return the index of the test merchandise with that id
33:      */
34:     int findMerchandiseIndex( UUID merchandiseId );
35: 
36: 
37:     /**
38:      * @param index
39:      * @return the buying price of test merchandise at the given index
40:      */
41:     MoneyType getBuyingPrice( int index );
42: 
43: 
44:     /**
45:      * @param index
46:      * @return the sales price of test merchandise at the given index
47:      */
48:     MoneyType getSalesPrice( int index );
49: }
50: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockCustomer.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.Setter;
4: import thkoeln.archilab.ecommerce.usecases.CustomerType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;
6: 
7: 
8: import java.util.Objects;
9: 
10: @Setter
11: public class MockCustomer implements CustomerType {
12:     private String name;
13:     private MailAddressType mailAddressType;
14:     private AddressType addressType;
15: 
16: 
17:     public MockCustomer( String name, MailAddressType mailAddressType, AddressType addressType) {
18:         this.name = name;
19:         this.mailAddressType = mailAddressType;
20:         this.addressType = addressType;
21:     }
22: 
23:     @Override
24:     public String getName() {
25:         return name;
26:     }
27: 
28:     @Override
29:     public MailAddressType getMailAddress() {
30:         return mailAddressType;
31:     }
32: 
33:     @Override
34:     public AddressType getAddress() {
35:         return addressType;
36:     }
37: 
38:     @Override
39:     public boolean equals( Object o ) {
40:         if ( this == o ) return true;
41:         if ( !( o instanceof MockCustomer ) ) return false;
42:         MockCustomer that = (MockCustomer) o;
43:         return Objects.equals( getName(), that.getName() ) &&
44:                 Objects.equals( mailAddressType, that.mailAddressType ) &&
45:                 Objects.equals( addressType, that.addressType );
46:     }
47: 
48:     @Override
49:     public int hashCode() {
50:         return Objects.hash( getName(), mailAddressType, addressType );
51:     }
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.usecases.*;
6: 
7: /**
8:  * Removes everything :-)
9:  */
10: @Service
11: public class Purgatory {
12:     @Autowired
13:     private CustomerRegistrationUseCases customerRegistrationUseCases;
14:     @Autowired
15:     private ShoppingCartUseCases shoppingCartUseCases;
16:     @Autowired
17:     private PurchaseUseCases purchaseUseCases;
18:     @Autowired
19:     private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
20:     @Autowired
21:     private StorageUnitUseCases storageUnitUseCases;
22: 
23:     public void deleteEverything() {
24:         purchaseUseCases.deleteAllPurchases();
25:         shoppingCartUseCases.emptyAllShoppingCarts();
26:         storageUnitUseCases.deleteAllStorageUnits();
27:         customerRegistrationUseCases.deleteAllCustomers();
28:         merchandiseCatalogUseCases.deleteMerchandiseCatalog();
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.context.ApplicationListener;
6: import org.springframework.context.annotation.Profile;
7: import org.springframework.context.event.ContextRefreshedEvent;
8: import org.springframework.stereotype.Component;
9: import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
12: 
13: @Component
14: @Slf4j
15: @Profile("!test")
16: @SuppressWarnings("PMD")
17: public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
18:     private Purgatory purgatory;
19:     private CustomerTestHelper customerTestHelper;
20:     private MerchandiseTestHelper merchandiseTestHelper;
21:     private StorageUnitTestHelper storageUnitTestHelper;
22: 
23: 
24:     @Autowired
25:     public StartupListener( Purgatory purgatory,
26:                             CustomerTestHelper customerTestHelper,
27:                             MerchandiseTestHelper merchandiseTestHelper,
28:                             StorageUnitTestHelper storageUnitTestHelper ) {
29:         this.purgatory = purgatory;
30:         this.customerTestHelper = customerTestHelper;
31:         this.merchandiseTestHelper = merchandiseTestHelper;
32:         this.storageUnitTestHelper = storageUnitTestHelper;
33:     }
34: 
35:     @Override
36:     public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
37:         log.info( "StartupListener initializing master data ..." );
38:         purgatory.deleteEverything();
39:         customerTestHelper.registerAllCustomers();
40:         merchandiseTestHelper.addAllMerchandises();
41:         storageUnitTestHelper.addAllStorageUnits( true );
42:     }
43: }
44: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StorageUnitTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import java.util.UUID;
4: 
5: public interface StorageUnitTestHelper {
6:     /**
7:      * Adds the test storage units to the system.
8:      * If you want to use the storage units, or want to know which index the storage unit has that you see
9:      * in the debugger, the following rules apply:
10:      * - The storage unit name will equal the street name of the address of the storage unit.
11:      * - The index number is visible in the house number. Example: storage unit 3 is located at
12:      *   "Ablageweg 3", and that is also its name.
13:      *
14:      *  The storage units are used in the tests as follows:
15:      *  - storage unit 0 holds all merchandises 0 - 6, and is used for all tests where it is not relevant
16:      *    to split one shopping cart into several purchases.
17:      *  - storage units 1 - 3 are used for the proximity tests, where you can deliver merchandise 7 to
18:      *    to a customer from the closest storage unit.
19:      *  - storage units 4 - 8 are used for the tests where you need to deliver merchandises 8 - 14 in
20:      *    the most cost-efficient way, as multiple shipments.
21:      *  - storage unit 9 is empty.
22:      *
23:      *  If withInventory is true, then the storage units are filled with merchandises. This happens
24:      *  according to the following rules:
25:      *  - merchandises 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
26:      *    ONLY available in storage unit 0. (This means that merchandise 0 out of inventory everywhere.)
27:      *  - merchandises 4, 5, 6 have a random inventory between 30 and 130, also all ONLY in storage unit 0
28:           (these are the merchandises used for tests on how to add and remove inventory)
29:      *  - merchandise 7 has a random inventory between 30 and 130, distributed over
30:      *    storage units 1, 2, and 3. You can use this to test if the appropriate storage unit is found
31:      *    for a shopping cart with only merchandise 7 in it, but with different quantities (<= 3, or > 3).
32:      *  - The other merchandises (8 - 14) have also a random inventory between 30 and 130, all distributed
33:      *    over several storage units. The distribution is done as follows:
34:      *    Assume that the merchandise is available in <n> storage units. Then the first <n-1> storage units
35:      *    in the list (in ascending sequence) contain 3, and all the remaining inventory is in the
36:      *    last storage unit.
37:      *
38:      *    This is how the inventory of merchandises could be distributed
39:      *    (Wx = storage unit x with its zip code, Px = merchandise x,
40:      *    numbers marked with (*) are random large numbers):
41:      *
42:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
43:      *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
44:      *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
45:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
46:      *    | P0   |      |     |     |      |     |      |     |       |      |     |
47:      *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
48:      *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
49:      *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
50:      *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
51:      *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
52:      *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
53:      *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
54:      *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
55:      *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
56:      *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
57:      *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
58:      *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
59:      *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
60:      *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
61:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
62:      *
63:      * @param withInventory if true, the inventory of the merchandises is added to the storage unit. Otherwise, the
64:      *                           the inventory is not added and the storage unit is empty.
65:      */
66:     public void addAllStorageUnits( boolean withInventory );
67: 
68: 
69:     /**
70:      * @return the number of test storage units in the database
71:      */
72:     int numberOfStorageUnits();
73: 
74: 
75:     /**
76:      * @param index
77:      * @return the id of the test storage unit at the given index
78:      */
79:     UUID getStorageUnitId( int index );
80: 
81: 
82:     /**
83:      * @param storageUnitId - the id of the storage unit in the test data
84:      * @return the index of the test storage unit with that id
85:      */
86:     int findStorageUnitIndex( UUID storageUnitId );
87: 
88: 
89:     /**
90:      * @param merchandiseIndex - the index of the merchandise in the test data
91:      * @param storageUnitIndex - the index of the storage unit in the test data
92:      * @return the number of merchandises (inventory) available in the storage unit at the given index
93:      */
94:     Integer getStorageUnitInventory( int storageUnitIndex, int merchandiseIndex );
95: 
96: }
97: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\MerchandiseCatalogUseCases.java ---
1: /*
2:  * Authored by ArchiLab 2025, TH Köln - not for distribution
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: 
10: import java.util.UUID;
11: 
12: 
13: /**
14:  * This interface contains methods needed in the context of use cases concerning the merchandise catalog.
15:  * The interface is probably incomplete, and will grow over time ...
16:  */
17: 
18: public interface MerchandiseCatalogUseCases {
19:     /**
20:      * Adds a new merchandise to the shop catalog
21:      * @param name
22:      * @param descrOf
23:      * @param size
24:      * @param buyingPrice
25:      * @param salesPrice
26:      * @return the id of the new merchandise
27:      * @throws ShopException if ...
28:      *      - the merchandise id already exists,
29:      *      - name or description are null or empty,
30:      *      - the size is <= 0 (but can be null!),
31:      *      - the buying price is null or <= 0,
32:      *      - the buyingPrice is null,
33:      *      - the sales price is null,
34:      *      - the sales price is lower than the buyingPrice
35:      */
36:     public UUID addMerchandiseToCatalog( String name, String descrOf, Float size,
37:                                            MoneyType buyingPrice, MoneyType salesPrice );
38: 
39: 
40:     /**
41:      * Removes a merchandise from the shop catalog
42:      * @param merchandiseId
43:      * @throws ShopException if
44:      *      - merchandiseId is null
45:      *      - the merchandise id does not exist
46:      *      - the merchandise is still in inventory
47:      *      - the merchandise is still in a shopping cart, or referenced by a completed purchase
48:      */
49:     public void removeMerchandiseFromCatalog( UUID merchandiseId );
50: 
51: 
52:     /**
53:      * Get the sales price of a given merchandise
54:      * @param merchandiseId
55:      * @return the sales price
56:      * @throws ShopException if ...
57:      *      - merchandiseId is null,
58:      *      - the merchandise with that id does not exist
59:      */
60:     public MoneyType getSalesPrice( UUID merchandiseId );
61: 
62: 
63:     /**
64:      * Clears the merchandise catalog, i.e. removes all merchandises from the catalog, including all the inventory,
65:      * all the reservations and all the purchases.
66:      */
67:     public void deleteMerchandiseCatalog();
68: 
69: }
70: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\PurchaseUseCases.java ---
1: /*
2:  * Authored by ArchiLab 2025, TH Köln - not for distribution
3:  */
4: package thkoeln.archilab.ecommerce.usecases;
5: 
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
9: 
10: import java.util.Map;
11: import java.util.UUID;
12: 
13: /**
14:  * This interface contains methods needed in the context of the purchase history of a customer.
15:  */
16: public interface PurchaseUseCases {
17: 
18:     /**
19:      * Returns a map showing which merchandises have been purchased by a customer and how many of each merchandise
20:      *
21:      * @param customerMailAddress
22:      * @return the purchase history of the customer (map is empty if the customer has not purchased anything yet)
23:      * @throws ShopException if
24:      *      - customerMailAddress is null
25:      *      - the customer with the given mail address does not exist
26:      */
27:     public Map<UUID, Integer> getPurchaseHistory( MailAddressType customerMailAddress );
28: 
29: 
30: 
31:     /**
32:      * @return the number of merchandises in a given purchase. If the merchandise is not a position of the purchase, the method
33:      *         returns 0. No exception is thrown.
34:      * @param purchaseId - the id of the purchase to be checked
35:      * @param merchandiseId - the id of the merchandise for which we want to know the quantity
36:      * @throws ShopException if
37:      *     - purchaseId is null, or doesn't exist in the system
38:      *     - merchandiseId is null, or doesn't exist in the system
39:      */
40:     public Integer getPurchaseQuantOfMerchandise( UUID purchaseId, UUID merchandiseId );
41: 
42: 
43:     /**
44:      * @return the id of the storage unit that is responsible for the given purchase
45:      * @param purchaseId - the id of the purchase to be checked
46:      * @throws ShopException if
47:      *      - purchaseId is null, or doesn't exist in the system
48:      */
49:     public UUID getStorageUnitIdForPurchase( UUID purchaseId );
50: 
51: 
52:     /**
53:      * Deletes all purchases in the system
54:      */
55:     public void deleteAllPurchases();
56: }
57: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingCartUseCases.java ---
1: /*
2:  * Authored by ArchiLab 2025, TH Köln - not for distribution
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
10: 
11: import java.util.Map;
12: import java.util.Set;
13: import java.util.UUID;
14: 
15: /**
16:  * This interface contains methods needed in the context of use cases handling the shopping cart.
17:  * The interface is probably incomplete, and will grow over time ...
18:  */
19: public interface ShoppingCartUseCases {
20:     /**
21:      * Adds a merchandise to the cart of a customer
22:      *
23:      * @param customerMailAddress
24:      * @param merchandiseId
25:      * @param quantOf
26:      * @throws ShopException if ...
27:      *          - customerMailAddress is null,
28:      *          - the customer with the given mail address does not exist,
29:      *          - merchandiseId is null,
30:      *          - the merchandise with merchandiseId does not exist
31:      *          - the Quantity is negative,
32:      */
33:     public void addMerchandiseToShoppingCart( MailAddressType customerMailAddress,
34:                                                  UUID merchandiseId, int quantOf );
35: 
36: 
37:     /**
38:      * Removes a merchandise from the cart of a customer
39:      *
40:      * @param customerMailAddress
41:      * @param merchandiseId
42:      * @param quantOf
43:      * @throws ShopException if ...
44:      *          - customerMailAddress is null,
45:      *          - the customer with the given mail address does not exist,
46:      *          - merchandiseId is null,
47:      *          - the merchandise with merchandiseId does not exist
48:      *          - the Quantity is negative
49:      *          - the merchandise is not in the shopping cart in the requested Quantity
50:      */
51:     public void removeMerchandiseFromShoppingCart( MailAddressType customerMailAddress,
52:                                                       UUID merchandiseId, int quantOf );
53: 
54: 
55:     /**
56:      * Returns a map showing which merchandises are in the cart of a customer and how many of each merchandise
57:      *
58:      * @param customerMailAddress
59:      * @return the cart of the customer (map is empty if the cart is empty)
60:      * @throws ShopException if
61:      *          - customerMailAddress is null,
62:      *          - the customer with the given mail address does not exist
63:      */
64:     public Map<UUID, Integer> getShoppingCartAsMap( MailAddressType customerMailAddress );
65: 
66: 
67:     /**
68:      * Returns the current value of all merchandises in the cart of a customer
69:      *
70:      * @param customerMailAddress
71:      * @return the cart of the customer
72:      * @throws ShopException if
73:      *          - customerMailAddress is null,
74:      *          - the customer with the given mail address does not exist
75:      */
76:     public MoneyType getShoppingCartAsMoneyValue( MailAddressType customerMailAddress );
77: 
78: 
79: 
80: 
81:     /**
82:      * Checks out the cart of a customer
83:      *
84:      * @param customerMailAddress
85:      * @return A set of ids belonging to purchases that were created during the checkout. If the shopping cart can
86:      *         only be served from more than one storage unit, each shipment from a storage unit gets a
87:      *         dedicated purchase. I.e. if there is just one shipment, then the set will contain just one purchase id.
88:      *         If there are multiple shipments, the set will contain multiple purchase ids.
89:      * @throws ShopException if
90:      *      - customerMailAddress is null or empty
91:      *      - the customer with the given mail address does not exist, or if the cart is empty
92:      * @throws
93:      *      - ShopException if customerMailAddress is null
94:      *      - InsufficientInventoryException if there is not enough inventory level for to serve the purchase
95:      *        for all merchandises in the shopping cart
96:      */
97:     public Set<UUID> checkout( MailAddressType customerMailAddress );
98: 
99: 
100:     /**
101:      * Empties all shopping carts in the system
102:      */
103:     public void emptyAllShoppingCarts();
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\usecases\StorageUnitUseCases.java ---
1: /*
2:  * Authored by ArchiLab 2025, TH Köln - not for distribution
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
9: 
10: import java.util.UUID;
11: 
12: /**
13:  * This interface contains methods needed in the context of handling the shop inventory,
14:  * i.e. managing storage units, and adding / removing merchandises in the storage unit.
15:  */
16: public interface StorageUnitUseCases {
17:     /**
18:      *
19:      * @param name
20:      * @param address
21:      * @return the id of the new storage unit
22:      * @throws ShopException if ...
23:      *      - name is null or empty
24:      *      - address is null
25:      */
26:     public UUID addNewStorageUnit( String name, AddressType address );
27: 
28: 
29:     /**
30:      * Deletes all storage units from the shop. Intended for testing purposes.
31:      */
32:     public void deleteAllStorageUnits();
33: 
34: 
35:     /**
36:      * Adds a certain Quantity of a given merchandise to the inventory
37:      * @param storageUnitId
38:      * @param merchandiseId
39:      * @param addedQuantOf
40:      * @throws ShopException if ...
41:      *      - storageUnitId is null
42:      *      - the storage unit with that id does not exist
43:      *      - merchandiseId is null
44:      *      - the merchandise with that id does not exist
45:      *      - addedQuantOf < 0
46:      */
47:     public void addToInventory( UUID storageUnitId, UUID merchandiseId, int addedQuantOf );
48: 
49: 
50:     /**
51:      * Removes a certain Quantity of a given merchandise from the inventory.
52:      * @param storageUnitId
53:      * @param merchandiseId
54:      * @param removedQuantOf
55:      * @throws ShopException if ...
56:      *      - storageUnitId is null
57:      *      - the storage unit with that id does not exist
58:      *      - merchandiseId is null
59:      *      - the merchandise with that id does not exist
60:      *      - removedQuantOf < 0
61:      */
62:     public void removeFromInventory( UUID storageUnitId, UUID merchandiseId, int removedQuantOf );
63: 
64: 
65:     /**
66:      * Changes the total Quantity of a given merchandise in the inventory.
67:      * @param storageUnitId
68:      * @param merchandiseId
69:      * @param newTotalQuantOf
70:      * @throws ShopException if ...
71:      *      - storageUnitId is null
72:      *      - the storage unit with that id does not exist
73:      *      - merchandiseId is null
74:      *      - the merchandise with that id does not exist
75:      *      - newTotalQuantOf < 0
76:      */
77:     public void changeInventoryTo( UUID storageUnitId, UUID merchandiseId, int newTotalQuantOf );
78: 
79: 
80:     /**
81:      * Get the current inventory of a given merchandise in one specific storage unit.
82:      * @param storageUnitId
83:      * @param merchandiseId
84:      * @return the current total inventory of the merchandise
85:      * @throws ShopException if ...
86:      *      - storageUnitId is null
87:      *      - the storage unit with that id does not exist
88:      *      - merchandiseId is null
89:      *      - the merchandise with that id does not exist
90:      */
91:     public int getAvailableInventory( UUID storageUnitId, UUID merchandiseId );
92: 
93: 
94: }
95: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import org.springframework.boot.test.context.TestConfiguration;
4: import org.springframework.context.annotation.Bean;
5: import org.springframework.test.web.servlet.MockMvc;
6: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
7: import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
8: 
9: 
10: @TestConfiguration
11: public class RESTTestHelperConfiguration {
12: 
13:     @Bean
14:     public ShoppingCartRESTHelper shoppingCartRESTHelper(
15:             MockMvc mockMvc, MerchandiseCatalogUseCases merchandiseCatalogUseCases ) {
16:         return new ShoppingCartRESTHelperImpl( mockMvc, merchandiseCatalogUseCases );
17:     }
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingCartRESTHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import com.fasterxml.jackson.databind.ObjectMapper;
5: import lombok.AllArgsConstructor;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import lombok.Setter;
9: import lombok.extern.slf4j.Slf4j;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.MvcResult;
12: import org.springframework.test.web.servlet.ResultActions;
13: import org.springframework.test.web.servlet.ResultMatcher;
14: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
15: import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
18: 
19: import java.util.Map;
20: import java.util.UUID;
21: 
22: import static org.springframework.http.MediaType.APPLICATION_JSON;
23: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
24: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
25: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
26: 
27: @Slf4j
28: public class ShoppingCartRESTHelperImpl implements ShoppingCartRESTHelper {
29:     private MockMvc mockMvc;
30:     private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
31: 
32:     private static final ResultMatcher CREATED = status().isCreated();
33:     private static final ResultMatcher OK = status().isOk();
34: 
35:     public ShoppingCartRESTHelperImpl( MockMvc mockMvc, MerchandiseCatalogUseCases merchandiseCatalogUseCases ) {
36:         this.mockMvc = mockMvc;
37:         this.merchandiseCatalogUseCases = merchandiseCatalogUseCases;
38:     }
39: 
40: 
41:     @Override
42:     public UUID getQueryShoppingCart( MailAddressType mailAddress, Map<UUID, Integer> quantityMap )
43:             throws Exception {
44:         // first query the customers API to get the proper customerId
45:         UUID customerId;
46:         String customerUri = "/customers?mailAddress=" + mailAddress.toString();
47:         MvcResult customerGetResult = mockMvc.perform( get( customerUri ) )
48:                 .andExpect( status().isOk() )
49:                 .andReturn();
50:         ObjectMapper objectMapper = new ObjectMapper();
51:         IdDTO idDTO = objectMapper.readValue( customerGetResult.getResponse().getContentAsString(), IdDTO.class );
52:         customerId = idDTO.getId();
53: 
54:         // then query the shopping cart API and extract the shopping cart id
55:         String shoppingCartUri = "/shoppingCarts?customerId=" + customerId.toString();
56:         ResultActions resultActions = mockMvc.perform( get( shoppingCartUri ) )
57:                 .andExpect( status().isOk() );
58:         idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
59:         UUID shoppingCartId = idDTO.getId();
60: 
61:         // additional checks, if desired
62:         if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
63:         return shoppingCartId;
64:     }
65: 
66: 
67:     private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
68:         if ( quantityMap == null ) return;
69:         int numOfMerchandises = quantityMap.size();
70:         resultActions.andExpect( jsonPath( "$.positions.length()" ).value( numOfMerchandises ) );
71:         float totalSalesPriceAsFloat = 0f;
72:         for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
73:             UUID merchandiseId = entry.getKey();
74:             Integer quantity = entry.getValue();
75:             resultActions.andExpect( jsonPath( "$.positions.[?(@.merchandiseId == '" + merchandiseId + "')].quantity" )
76:                     .value( quantity ) );
77:             MoneyType salesPrice = merchandiseCatalogUseCases.getSalesPrice( merchandiseId );
78:             totalSalesPriceAsFloat += salesPrice.getAmount() * quantity;
79:         }
80:         // last thing - check the total sales price
81:         String totalSalesPriceString = String.format( "%.2f €", totalSalesPriceAsFloat );
82:         resultActions
83:                 .andExpect( jsonPath( "$.totalSalesPrice" ).value( totalSalesPriceString ) );
84:     }
85: 
86: 
87:     @Override
88:     public void addMerchandiseToShoppingCart( UUID shoppingCartId, UUID merchandiseId, Integer quantity )
89:             throws Exception {
90:         addMerchandiseToShoppingCart( shoppingCartId, merchandiseId, quantity, null );
91:     }
92: 
93: 
94:     @Override
95:     public void addMerchandiseToShoppingCart( UUID shoppingCartId, UUID merchandiseId, Integer quantity,
96:                                                   ResultMatcher expectedStatus ) throws Exception {
97:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
98:         ObjectMapper objectMapper = new ObjectMapper();
99:         QuantityDTO dto = new QuantityDTO( merchandiseId, quantity );
100:         String quantityJson = objectMapper.writeValueAsString( dto );
101:         mockMvc.perform( post( "/shoppingCarts/" + shoppingCartId + "/positions" )
102:                         .contentType( APPLICATION_JSON ).content( quantityJson ) )
103:                 .andExpect( status );
104:     }
105: 
106: 
107: 
108:     @Override
109:     public void deleteMerchandiseFromShoppingCart( UUID shoppingCartId, UUID merchandiseId )
110:             throws Exception {
111:         deleteMerchandiseFromShoppingCart( shoppingCartId, merchandiseId, null );
112:     }
113: 
114: 
115: 
116:     @Override
117:     public void deleteMerchandiseFromShoppingCart( UUID shoppingCartId, UUID merchandiseId,
118:                                                       ResultMatcher expectedStatus ) throws Exception {
119:         ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
120:         String uri = "/shoppingCarts/" + shoppingCartId + "/positions/" + merchandiseId;
121:         mockMvc.perform( delete( uri ) ).andExpect( status );
122:     }
123: 
124: 
125:     @Override
126:     public void checkout( UUID shoppingCartId, String expectedCustomerName,
127:                           ResultMatcher expectedStatus,
128:                           Map<UUID, Map<UUID, Integer>> expectedPurchases ) throws Exception {
129:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
130:         String uri = "/shoppingCarts/" + shoppingCartId + "/checkout";
131:         MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
132:         ObjectMapper objectMapper = new ObjectMapper();
133: 
134:         // check the response content
135:         if ( expectedPurchases != null || expectedCustomerName != null ) {
136:             String responseContent = result.getResponse().getContentAsString();
137:             log.info( "ShoppingCartRESTHelperImpl - checkout: found response content " + responseContent );
138:             PurchaseDTO[] purchases = objectMapper.readValue( responseContent, PurchaseDTO[].class );
139:             checkExpectedCustomerName( expectedCustomerName, purchases );
140:             checkExpectedPurchases( expectedPurchases, purchases );
141:         }
142:     }
143: 
144: 
145:     private void checkExpectedCustomerName( String expectedCustomerName, PurchaseDTO[] purchases ) {
146:         if ( expectedCustomerName == null ) return;
147:         for ( PurchaseDTO purchase : purchases ) {
148:             if ( !purchase.getCustomerName().equals( expectedCustomerName ) ) {
149:                 throw new AssertionError( "Expected customerName '" + expectedCustomerName +
150:                         "' but got '" + purchase.getCustomerName() + "'" );
151:             }
152:         }
153:     }
154: 
155: 
156:     private void checkExpectedPurchases( Map<UUID, Map<UUID, Integer>> expectedPurchases,
157:                                             PurchaseDTO[] purchases ) {
158:         if ( expectedPurchases == null ) return;
159:         for ( PurchaseDTO purchase : purchases ) {
160:             UUID storageUnitId = purchase.getStorageUnitId();
161:             Map<UUID, Integer> expectedQuantities = expectedPurchases.get( storageUnitId );
162:             if ( expectedQuantities == null ) {
163:                 throw new AssertionError( "No expected quantities for storage unit " + storageUnitId );
164:             }
165:             QuantityDTO[] positions = purchase.getPositions();
166:             for ( QuantityDTO quantityDTO : positions ) {
167:                 UUID merchandiseId = quantityDTO.getMerchandiseId();
168:                 Integer expectedQuantity = expectedQuantities.get( merchandiseId );
169:                 if ( expectedQuantity == null ) {
170:                     throw new AssertionError( "No expected quantity for merchandise " + merchandiseId +
171:                             " in storage unit " + storageUnitId );
172:                 }
173:                 if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
174:                     throw new AssertionError( "Expected quantity " + expectedQuantity + " for merchandise " +
175:                             merchandiseId + " in storage unit " + storageUnitId +
176:                             ", but got " + quantityDTO.getQuantity() );
177:                 }
178:             }
179:         }
180:     }
181: 
182: 
183:     /**
184:      * A DTO containing just a quantity, used in testing.
185:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
186:      * Therefore, constructors and getters/setters are manually defined.
187:      */
188:     @NoArgsConstructor
189:     @JsonIgnoreProperties(ignoreUnknown = true)
190:     private static class QuantityDTO {
191:         private UUID merchandiseId;
192:         private Integer quantity;
193: 
194:         public QuantityDTO( UUID merchandiseId, Integer quantity ) {
195:             this.merchandiseId = merchandiseId;
196:             this.quantity = quantity;
197:         }
198:         public UUID getMerchandiseId() {
199:             return merchandiseId;
200:         }
201:         public Integer getQuantity() {
202:             return quantity;
203:         }
204:         public void setMerchandiseId( UUID merchandiseId ) {
205:             this.merchandiseId = merchandiseId;
206:         }
207:         public void setQuantity( Integer quantity ) {
208:             this.quantity = quantity;
209:         }
210:     }
211: 
212: 
213:     /**
214:      * A DTO containing just the id of an entity, used in testing.
215:      */
216:     @AllArgsConstructor
217:     @NoArgsConstructor
218:     @Getter
219:     @Setter
220:     @JsonIgnoreProperties(ignoreUnknown = true)
221:     private static class IdDTO {
222:         private UUID id;
223:     }
224: 
225: 
226:     /**
227:      * A DTO containing the purchase data, used in testing.
228:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
229:      * Therefore, constructors and getters/setters are manually defined.
230:      */
231:     @NoArgsConstructor
232:     @JsonIgnoreProperties(ignoreUnknown = true)
233:     private static class PurchaseDTO {
234:         private UUID id;
235:         private String customerName;
236:         private UUID storageUnitId;
237:         private QuantityDTO[] positions;
238: 
239:         public UUID getId() {
240:             return id;
241:         }
242:         public String getCustomerName() {
243:             return customerName;
244:         }
245:         public UUID getStorageUnitId() {
246:             return storageUnitId;
247:         }
248:         public QuantityDTO[] getPositions() {
249:             return positions;
250:         }
251:         public void setId( UUID id ) {
252:             this.id = id;
253:         }
254:         public void setCustomerName( String customerName ) {
255:             this.customerName = customerName;
256:         }
257:         public void setStorageUnitId( UUID storageUnitId ) {
258:             this.storageUnitId = storageUnitId;
259:         }
260:         public void setPositions( QuantityDTO[] positions ) {
261:             this.positions = positions;
262:         }
263:     }
264: 
265: }
266: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingCartRESTHelper.java ---
1: package thkoeln.archilab.ecommerce.helpers;
2: 
3: import org.springframework.test.web.servlet.ResultMatcher;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: 
6: import java.util.Map;
7: import java.util.UUID;
8: 
9: /**
10:  * A REST helper for shopping cart-related operations.
11:  * This interface defines methods to interact with a shopping cart via REST calls, such as querying, adding,
12:  * deleting, and checking out.
13:  */
14: public interface ShoppingCartRESTHelper {
15:     /**
16:      * Executes a REST GET query on a shopping cart and returns its id, with the customer's mail address as a
17:      * starting point. The resulting shopping cart is checked against the given expected quantity map.
18:      * @param mailAddress The mailAddress of the customer whose shopping cart is queried.
19:      * @param expectedQuantityMap A map of merchandises and their quantities in the shopping cart. (If null, then don't check.)
20:      * @return The id of the customer's shopping cart.
21:      * @throws Exception (whenever the REST call fails, or the shopping cart does not match the expected quantity map)
22:      */
23:     public UUID getQueryShoppingCart( MailAddressType mailAddress,
24:                                        Map<UUID, Integer> expectedQuantityMap ) throws Exception;
25: 
26: 
27:     /**
28:      * Adds a merchandise to a shopping cart via a REST call.
29:      * @param shoppingCartId Id of the shopping cart.
30:      * @param merchandiseId Id of the merchandise.
31:      * @param quantity Quantity of the merchandise.
32:      * @throws Exception (whenever the REST call fails)
33:      */
34:     public void addMerchandiseToShoppingCart( UUID shoppingCartId, UUID merchandiseId, Integer quantity )
35:             throws Exception;
36: 
37: 
38:     /**
39:      * Adds a merchandise to a shopping cart via a REST call.
40:      * @param shoppingCartId Id of the shopping cart.
41:      * @param merchandiseId Id of the merchandise.
42:      * @param quantity Quantity of the merchandise.
43:      * @param expectedStatus expected status of the operation (null = CREATED)
44:      * @throws Exception (whenever the REST call fails or the status does not match)
45:      */
46:     public void addMerchandiseToShoppingCart( UUID shoppingCartId, UUID merchandiseId, Integer quantity,
47:                                                   ResultMatcher expectedStatus ) throws Exception;
48: 
49: 
50:     /**
51:      * Deletes a merchandise from a shopping cart via a REST call.
52:      * @param shoppingCartId Id of the shopping cart.
53:      * @param merchandiseId Id of the merchandise.
54:      * @throws Exception (whenever the REST call fails)
55:      */
56:     public void deleteMerchandiseFromShoppingCart( UUID shoppingCartId, UUID merchandiseId )
57:             throws Exception;
58: 
59: 
60:     /**
61:      * Deletes a merchandise from a shopping cart via a REST call.
62:      * @param shoppingCartId Id of the shopping cart.
63:      * @param merchandiseId Id of the merchandise.
64:      * @param expectedStatus expected status of the operation (null = OK)
65:      * @throws Exception (whenever the REST call fails or the status does not match)
66:      */
67:     public void deleteMerchandiseFromShoppingCart( UUID shoppingCartId, UUID merchandiseId,
68:                                                       ResultMatcher expectedStatus ) throws Exception;
69: 
70: 
71:     /**
72:      * Checks out a shopping cart via REST call, and returns the id of the created purchase.
73:      * @param shoppingCartId
74:      * @param expectedCustomerName expected name of the customer who owns the shopping cart (null = don't check)
75:      * @param expectedStatus expected status of the operation (null = don't check)
76:      * @param expectedPurchases the expected purchases to be created as a result of the checkout. This is
77:      *                            a map of the following form:
78:      *                            <pre>
79:      *                               storageUnitId -> Map<merchandiseId,Integer>
80:      *                            </pre>
81:      *                            where the inner map contains the merchandises and their quantities
82:      * @return
83:      * @throws Exception
84:      */
85:     public void checkout( UUID shoppingCartId, String expectedCustomerName,
86:                           ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedPurchases )
87:            throws Exception;
88: }
89: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\customer\CustomerRegistrationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.customer;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
12: import thkoeln.archilab.ecommerce.usecases.CustomerType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
15: 
16: import static org.junit.jupiter.api.Assertions.*;
17: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
18: 
19: 
20: @SpringBootTest
21: public class CustomerRegistrationTest {
22:     @Autowired
23:     private CustomerRegistrationUseCases customerRegistrationUseCases;
24:     @Autowired
25:     private Purgatory purgatory;
26:     @Autowired
27:     private CustomerTestHelper customerTestHelper;
28: 
29:     private MailAddressType nonExistingMailAddress;
30:     private AddressType someAddress;
31: 
32:     @BeforeEach
33:     public void setUp() {
34:         purgatory.deleteEverything();
35:         nonExistingMailAddress = instantiateMailAddress( "this@nononono.de" );
36:         someAddress = instantiateAddress( "Some Street", "Some City",
37:                 instantiateZipCode( "90001" ) );
38:     }
39: 
40:     @Test
41:     public void testAllCustomersRegistered() {
42:         // given
43:         customerTestHelper.registerAllCustomers();
44:         MailAddressType mailAddress3 =
45:                 customerTestHelper.getCustomerMailAddress( 3 );
46:         String name3 = customerTestHelper.getCustomerName( 3 );
47:         AddressType address3 = customerTestHelper.getCustomerAddress( 3 );
48: 
49:         // when
50:         CustomerType customer3 = customerRegistrationUseCases.getCustomerData(
51:                 mailAddress3 );
52: 
53:         // then
54:         Assertions.assertEquals( name3, customer3.getName() );
55:         Assertions.assertEquals( mailAddress3, customer3.getMailAddress() );
56:         Assertions.assertEquals( address3, customer3.getAddress() );
57:     }
58: 
59: 
60:     @Test
61:     public void testRegisterCustomerWithDuplicateMailAddress() {
62:         // given
63:         customerTestHelper.registerAllCustomers();
64:         AddressType address5 = customerTestHelper.getCustomerAddress( 5 );
65:         MailAddressType mailAddress5 =
66:                 customerTestHelper.getCustomerMailAddress( 5 );
67: 
68:         // when
69:         // then
70:         assertThrows( ShopException.class, () ->
71:                 customerRegistrationUseCases.register( "Gandalf The Grey",
72:                         mailAddress5, address5 ) );
73:     }
74: 
75: 
76:     @Test
77:     public void testRegisterCustomerWithDuplicateNameOrAddress() {
78:         // given
79:         customerTestHelper.registerAllCustomers();
80:         MailAddressType newMailAddress =
81:                 instantiateMailAddress( "some@this.de" );
82:         AddressType address2 = customerTestHelper.getCustomerAddress( 2 );
83:         String name2 = customerTestHelper.getCustomerName( 2 );
84: 
85:         // when
86:         // then
87:         assertDoesNotThrow( () ->
88:                 customerRegistrationUseCases.register( name2, newMailAddress, address2 ) );
89:     }
90: 
91: 
92:     @Test
93:     public void testRegisterCustomerWithInvalidData() {
94:         // given
95:         MailAddressType mailAddress5 =
96:                 customerTestHelper.getCustomerMailAddress( 5 );
97:         AddressType address5 = customerTestHelper.getCustomerAddress( 5 );
98:         String name5 = customerTestHelper.getCustomerName( 5 );
99: 
100:         // when
101:         // then
102:         assertThrows( ShopException.class, () ->
103:                 customerRegistrationUseCases.register( null, mailAddress5, address5 ) );
104:         assertThrows( ShopException.class, () ->
105:                 customerRegistrationUseCases.register("", mailAddress5, address5 ) );
106:         assertThrows( ShopException.class, () ->
107:                 customerRegistrationUseCases.register( name5, null, address5 ) );
108:         assertThrows( ShopException.class, () ->
109:                 customerRegistrationUseCases.register( name5, mailAddress5, null ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testChangeAddressWithInvalidData() {
115:         // given
116:         customerTestHelper.registerAllCustomers();
117:         AddressType address7 = customerTestHelper.getCustomerAddress( 7 );
118:         MailAddressType mailAddress7 =
119:                 customerTestHelper.getCustomerMailAddress( 7 );
120: 
121:         // when
122:         // then
123:         assertThrows( ShopException.class, () ->
124:                 customerRegistrationUseCases.changeAddress( nonExistingMailAddress, address7 ) );
125:         assertThrows( ShopException.class, () ->
126:                 customerRegistrationUseCases.changeAddress( null, address7 ) );
127:         assertThrows( ShopException.class, () ->
128:                 customerRegistrationUseCases.changeAddress( mailAddress7, null ) );
129:     }
130: 
131: 
132:     @Test
133:     public void testGetDataForNonexistingMailAddress() {
134:         // given
135:         customerTestHelper.registerAllCustomers();
136: 
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 customerRegistrationUseCases.getCustomerData( nonExistingMailAddress ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testDeleteCustomersNoMoreCustomers() {
146:         // given
147:         customerTestHelper.registerAllCustomers();
148:         MailAddressType mailAddress0 =
149:                 customerTestHelper.getCustomerMailAddress( 0 );
150: 
151: 
152:         // when
153:         customerRegistrationUseCases.deleteAllCustomers();
154: 
155:         // then
156:         assertThrows( ShopException.class, () -> customerRegistrationUseCases.getCustomerData(
157:                 mailAddress0 ) );
158:     }
159: 
160: 
161:     @Test
162:     public void testChangeAddressSuccessful() {
163:         // given
164:         customerTestHelper.registerAllCustomers();
165:         MailAddressType mailAddress6 =
166:                 customerTestHelper.getCustomerMailAddress( 6 );
167: 
168:         // when
169:         customerRegistrationUseCases.changeAddress( mailAddress6, someAddress );
170:         CustomerType newCustomer6 =
171:                 customerRegistrationUseCases.getCustomerData( mailAddress6 );
172: 
173:         // then
174:         Assertions.assertEquals( mailAddress6, newCustomer6.getMailAddress() );
175:         Assertions.assertEquals( someAddress, newCustomer6.getAddress() );
176:     }
177: 
178: 
179:     @Test
180:     public void testChangeAddressForNonexistingMailAddress() {
181:         // given
182:         customerTestHelper.registerAllCustomers();
183: 
184:         // when
185:         // then
186:         assertThrows( ShopException.class, () ->
187:                 customerRegistrationUseCases.changeAddress( nonExistingMailAddress, someAddress ) );
188:     }
189: 
190: 
191: }
192: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\customer\CustomerRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.customer;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
12: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
13: import thkoeln.archilab.ecommerce.usecases.CustomerType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
16: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
17: 
18: import java.util.UUID;
19: 
20: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
21: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
22: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
23: 
24: @SpringBootTest
25: @Transactional
26: @AutoConfigureMockMvc
27: @Import( RESTTestHelperConfiguration.class )
28: public class CustomerRESTTest {
29:     @Autowired
30:     private CustomerRegistrationUseCases customerRegistrationUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private CustomerTestHelper customerTestHelper;
35:     @Autowired
36:     private MockMvc mockMvc;
37: 
38:     private UUID randomId;
39:     private MailAddressType nonExistingMailAddress;
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         customerTestHelper.registerAllCustomers();
45: 
46:         nonExistingMailAddress = FactoryMethodInvoker.instantiateMailAddress(
47:                 "harry@sally.de" );
48:         randomId = UUID.randomUUID();
49:     }
50: 
51: 
52:     @Test
53:     public void testInvalidCustomerUris() throws Exception {
54:         // given
55:         String allCustomersUri = "/customers";
56:         String randomIdUri = "/customers/" +  randomId;
57:         String nonExistingMailAddressUri = "/customers?mailAddress=" + nonExistingMailAddress;
58:         String randomParamUri = "/customers?randomParam=randomValue";
59: 
60:         // when
61:         // then
62:         mockMvc.perform( get( allCustomersUri ) ).andExpect( status().isMethodNotAllowed() );
63:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
64:         mockMvc.perform( get( nonExistingMailAddressUri ) ).andExpect( status().isNotFound() );
65:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
66:     }
67: 
68: 
69:     @Test
70:     public void testRandomCustomerId() throws Exception {
71:         // given
72:         String invalidUri = "/customers/" +  randomId;
73: 
74:         // when
75:         // then
76:         mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
77:     }
78: 
79: 
80:     @Test
81:     public void testQueryCustomer() throws Exception {
82:         // given
83:         MailAddressType mailAddress4 =
84:                 customerTestHelper.getCustomerMailAddress( 4 );
85:         String customerUri4 = "/customers?mailAddress=" + mailAddress4;
86: 
87:         // when
88:         CustomerType customer4 = customerRegistrationUseCases.getCustomerData( mailAddress4 );
89:         String name = customerTestHelper.getCustomerName( 4 );
90:         AddressType address4 = customerTestHelper.getCustomerAddress( 4 );
91: 
92:         // then (check using JSONPath)
93:         mockMvc.perform( get( customerUri4 ) )
94:                 .andExpect( status().isOk() )
95:                 .andExpect( jsonPath( "$.name" ).value( name ) )
96:                 // id is position 0 (cannot be tested with current API structure), name is position 1,
97:                 // mail address is 2, address is 3)
98:                 .andExpect( jsonPath( "$..mailAddressString" ).value( mailAddress4.toString() ) )
99:                 .andExpect( jsonPath( "$..city" ).value( address4.getCity() ) )
100:                 .andExpect( jsonPath( "$..zipCodeString" ).value(
101:                         address4.getZipCode().toString() ) );
102:     }
103: 
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class BasicNoOutsideSolutionRulesTest {
14: 
15:     @ArchTest
16:     static final ArchRule noClassesOnTopLevel =
17:             classes().should().resideInAPackage( "..solution.*.." )
18:                     .allowEmptyShould( true );
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.library.Architectures.layeredArchitecture;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln")
12: @SuppressWarnings("PMD")
13: public class BasicProperDependenciesTest {
14: 
15:     @ArchTest
16:     static final ArchRule properDependencies =
17:             layeredArchitecture()
18:                     .consideringAllDependencies()
19:                     //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
20:                     .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
21:                     .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )
22: 
23:                     //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
24:                     .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
25:                     .allowEmptyShould( true );
26: }
27: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
5: import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
6: import org.springframework.core.type.classreading.MetadataReader;
7: import org.springframework.core.type.classreading.MetadataReaderFactory;
8: 
9: import java.io.IOException;
10: import java.util.Arrays;
11: import java.util.HashSet;
12: import java.util.Set;
13: 
14: import static org.junit.jupiter.api.Assertions.assertTrue;
15: 
16: public class BasicRequiredClassesTest {
17:     private static final String[] REQUIRED_CLASSES = {
18:             "Customer",
19:             "CustomerRepository",
20:             "Merchandise",
21:             "MerchandiseRepository",
22:             "Purchase",
23:             "PurchaseRepository",
24:             "InventoryLevel",
25:             "ShoppingCart",
26:             "ShoppingCartRepository",
27:             "StorageUnitRepository",
28:             "ShoppingCartPosition",
29:             "PurchasePosition",
30:             "StorageUnit",
31:     };
32: 
33:     @Test
34:     public void testRequiredClassesDeclared() throws IOException {
35:         String basePackage = "thkoeln.archilab.ecommerce";
36:         String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";
37: 
38:         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
39:         MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );
40: 
41:         Set<String> foundClasses = new HashSet<>();
42: 
43:         Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
44:             try {
45:                 MetadataReader reader = readerFactory.getMetadataReader( resource );
46:                 foundClasses.add( reader.getClassMetadata().getClassName() );
47:             } catch (IOException e) {
48:                 e.printStackTrace();
49:             }
50:         } );
51: 
52:         Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
53:             boolean found = foundClasses.stream().anyMatch(className ->
54:                     className.startsWith(basePackage) && className.endsWith("." + requiredClass)
55:             );
56:             assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
57:         });
58:     }
59: }
60: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.boot.test.context.SpringBootTest;
6: import org.springframework.context.ApplicationContext;
7: 
8: import java.util.Arrays;
9: import java.util.HashMap;
10: import java.util.List;
11: import java.util.Map;
12: 
13: import static org.junit.jupiter.api.Assertions.*;
14: 
15: @SpringBootTest
16: public class BasicUseCaseImplementationPackageTest {
17: 
18:     @Autowired
19:     private ApplicationContext applicationContext;
20: 
21:     private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
22:         put("CustomerRegistrationUseCases", Arrays.asList("customer"));
23:         put("StorageUnitUseCases", Arrays.asList("storageunit"));
24:         put("MerchandiseCatalogUseCases", Arrays.asList("merchandise"));
25:         put("ShoppingCartUseCases", Arrays.asList("shoppingcart"));
26:         put("PurchaseUseCases", Arrays.asList("purchase"));
27:     }};
28:     private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
29:     private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";
30: 
31:     @Test
32:     public void testRequiredClassesDeclared() {
33:         for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
34:             String interfaceName = USECASE_PATH + "." + entry.getKey();
35:             List<String> correctTopLevelPackages = entry.getValue();
36:             Class<?> useCaseInterfaceClass = null;
37:             try {
38:                 useCaseInterfaceClass = Class.forName( interfaceName );
39:             } catch (ClassNotFoundException e) {
40:                 fail( "Use case interface " + interfaceName + " not found.", e );
41:                 continue;
42:             }
43:             String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
44:             assertEquals( 1, beans.length,
45:                     "There should be exactly 1 service implementation for the interface " +
46:                             entry.getKey() + ", but found " + beans.length );
47:             Object bean = applicationContext.getBean( beans[0] );
48:             boolean isValid = false;
49:             for ( String correctTopLevelPackage : correctTopLevelPackages ) {
50:                 String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
51:                 if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
52:                     isValid = true;
53:                     break;
54:                 }
55:             }
56:             assertTrue( isValid,
57:                     "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
58:                             + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
59:         }
60:     }
61: }
62: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: import org.springframework.data.repository.CrudRepository;
8: import org.springframework.stereotype.Service;
9: 
10: import jakarta.persistence.Entity;
11: import org.springframework.web.bind.annotation.RestController;
12: 
13: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
14: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
15: 
16: @ArchTag("layerRules")
17: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
18: @SuppressWarnings("PMD")
19: public class DDDRulesTest {
20: 
21:     @ArchTest
22:     static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
23:             noClasses().that().resideInAPackage( "..domain.." )
24:                     .should().dependOnClassesThat().resideInAPackage( "..application.." )
25:                     .allowEmptyShould( true );
26: 
27:     @ArchTest
28:     static final ArchRule entitiesMustResideInADomainPackage =
29:             classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
30:                     .as( "Entities must reside in a package '..domain..'" )
31:                     .allowEmptyShould( true );
32: 
33:     @ArchTest
34:     static final ArchRule entitiesMustNotAccessRepositories =
35:             noClasses().that().areAnnotatedWith( Entity.class )
36:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
37:                     .allowEmptyShould( true );
38: 
39:     @ArchTest
40:     static final ArchRule repositoriesMustResideInADomainPackage =
41:             classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
42:                     .as( "Repositories must reside in a package '..domain..'" )
43:                     .allowEmptyShould( true );
44: 
45:     @ArchTest
46:     static final ArchRule repositoryNamesMustHaveProperSuffix =
47:             classes().that().areAssignableTo( CrudRepository.class )
48:                     .should().haveSimpleNameEndingWith( "Repository" )
49:                     .allowEmptyShould( true );
50: 
51:     @ArchTest
52:     static final ArchRule servicesMustResideInAnApplicationPackage =
53:             classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
54:                     .as( "Application Services must reside in a package '..application..'" )
55:                     .allowEmptyShould( true );
56: 
57:     @ArchTest
58:     static final ArchRule serviceNamesMustHaveProperSuffix =
59:             classes().that().areAnnotatedWith( Service.class )
60:                     .should().haveSimpleNameEndingWith( "Service" )
61:                     .allowEmptyShould( true );
62: 
63:     @ArchTest
64:     static final ArchRule controllersMustResideInAnApplicationPackage =
65:             classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
66:                     .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );
67: 
68:     @ArchTest
69:     static final ArchRule controllersNamesMustHaveProperSuffix =
70:             classes().that().areAnnotatedWith( RestController.class )
71:                     .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );
72: 
73:     @ArchTest
74:     static final ArchRule controllersMustNotAccessRepositories =
75:             noClasses().that().areAnnotatedWith( RestController.class )
76:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
77:                     .allowEmptyShould( false );
78: }
79: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.importer.ClassFileImporter;
6: import com.tngtech.archunit.lang.ArchRule;
7: import com.tngtech.archunit.library.dependencies.SliceAssignment;
8: import com.tngtech.archunit.library.dependencies.SliceIdentifier;
9: import org.junit.jupiter.api.Test;
10: 
11: import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
12: 
13: public class NoCycleTest {
14:     private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");
15: 
16:     private SliceAssignment inAllClasses() {
17:         return new SliceAssignment() {
18:             @Override
19:             public String getDescription() {
20:                 return "every class in it's own slice";
21:             }
22: 
23:             @Override
24:             public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
25:                 return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
26:             }
27:         };
28:     }
29: 
30:     @Test
31:     public void testNoCyclicDependenciesBetweenClasses() {
32:         slices().assignedFrom(inAllClasses())
33:                 .namingSlices("$1[$2.$3]")
34:                 .should().beFreeOfCycles()
35:                 .check(importedClasses);
36:     }
37: 
38:     @Test
39:     public void testNoCyclicDependenciesBetweenPackages() {
40:         ArchRule rule = slices().matching("..solution.(*)..")
41:                 .should().beFreeOfCycles().allowEmptyShould( true );
42:         rule.check(importedClasses);
43:     }
44: }
45: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.base.DescribedPredicate;
4: import com.tngtech.archunit.core.domain.JavaClass;
5: import com.tngtech.archunit.core.domain.JavaField;
6: import com.tngtech.archunit.core.domain.JavaParameterizedType;
7: import com.tngtech.archunit.core.domain.JavaType;
8: import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
9: import com.tngtech.archunit.junit.AnalyzeClasses;
10: import com.tngtech.archunit.junit.ArchTag;
11: import com.tngtech.archunit.junit.ArchTest;
12: import com.tngtech.archunit.lang.ArchCondition;
13: import com.tngtech.archunit.lang.ArchRule;
14: import com.tngtech.archunit.lang.ConditionEvents;
15: import com.tngtech.archunit.lang.SimpleConditionEvent;
16: import jakarta.persistence.*;
17: import lombok.extern.slf4j.Slf4j;
18: import thkoeln.archilab.ecommerce.GenericId;
19: 
20: import java.util.List;
21: 
22: import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
23: import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
24: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;
25: 
26: @ArchTag("layerRules")
27: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
28: @SuppressWarnings("PMD")
29: @Slf4j
30: public class OnlyReferenceViaIDTest { //STORAGE_UNIT
31:     private static final String SHOPPING_CART_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingcart.domain";
32:     private static final String CUSTOMER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.customer.domain";
33:     private static final String MERCHANDISE_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.merchandise.domain";
34:     private static final String PURCHASE_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.purchase.domain";
35:     private static final String STORAGE_UNIT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.storageunit.domain";
36: 
37:     @ArchTest
38:     static final ArchRule idFieldsMustUseGenericId =
39:             fields()
40:                     .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
41:                     .and().areAnnotatedWith( Id.class )
42:                     .should().haveRawType( assignableTo( GenericId.class ) )
43:                     .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
44:                     .allowEmptyShould( true );
45: 
46: 
47:     private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
48:             annotatedWith( ManyToOne.class )
49:                     .or( annotatedWith( OneToOne.class ) )
50:                     .or( annotatedWith( Embedded.class ) )
51:                     .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );
52: 
53:     private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
54:             annotatedWith( OneToMany.class )
55:                     .or( annotatedWith( ManyToMany.class ) )
56:                     .or( annotatedWith( ElementCollection.class ) )
57:                     .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );
58: 
59: 
60:     private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
61:         String description = "an entity or value object from same aggregate, or a domain primitive";
62:         return new DescribedPredicate<>( description ) {
63:             @Override
64:             public boolean test( JavaClass type ) {
65:                 // check if the class is an entity or value object, and resides in the allowed package
66:                 if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
67:                     return false;
68:                 }
69:                 // a GenericId is always allowed
70:                 if ( type.isAssignableTo( GenericId.class ) ) {
71:                     return true;
72:                 }
73:                 // a domain primitive is also always allowed
74:                 if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
75:                     return true;
76:                 }
77:                 return type.getPackageName().startsWith( allowedPackage );
78:             }
79:         };
80:     }
81: 
82: 
83:     @ArchTest
84:     static final ArchRule shoppingCartToOneReferences =
85:             fields()
86:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_CART_DOMAIN_PACKAGE )
87:                     .and( isToOneAnnotation )
88:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_CART_DOMAIN_PACKAGE ) ) )
89:                     .allowEmptyShould( true );
90: 
91:     @ArchTest
92:     static final ArchRule customerToOneReferences =
93:             fields()
94:                     .that().areDeclaredInClassesThat().resideInAPackage( CUSTOMER_DOMAIN_PACKAGE )
95:                     .and( isToOneAnnotation )
96:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( CUSTOMER_DOMAIN_PACKAGE ) ) )
97:                     .allowEmptyShould( true );
98: 
99:     @ArchTest
100:     static final ArchRule merchandiseToOneReferences =
101:             fields()
102:                     .that().areDeclaredInClassesThat().resideInAPackage( MERCHANDISE_DOMAIN_PACKAGE )
103:                     .and( isToOneAnnotation )
104:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( MERCHANDISE_DOMAIN_PACKAGE ) ) )
105:                     .allowEmptyShould( true );
106: 
107:     @ArchTest
108:     static final ArchRule purchaseToOneReferences =
109:             fields()
110:                     .that().areDeclaredInClassesThat().resideInAPackage( PURCHASE_DOMAIN_PACKAGE )
111:                     .and( isToOneAnnotation )
112:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( PURCHASE_DOMAIN_PACKAGE ) ) )
113:                     .allowEmptyShould( true );
114: 
115:     @ArchTest
116:     static final ArchRule storageUnitToOneReferences =
117:             fields()
118:                     .that().areDeclaredInClassesThat().resideInAPackage( STORAGE_UNIT_DOMAIN_PACKAGE )
119:                     .and( isToOneAnnotation )
120:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( STORAGE_UNIT_DOMAIN_PACKAGE ) ) )
121:                     .allowEmptyShould( true );
122: 
123: 
124:     private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
125:         return new ArchCondition<JavaField>(
126:                 "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
127:             @Override
128:             public void check( JavaField field, ConditionEvents events ) {
129:                 JavaClass rawType = field.getRawType();
130:                 String rawTypeName = rawType.getFullName();
131:                 if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
132:                     events.add( SimpleConditionEvent.violated( field,
133:                             field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
134:                     return;
135:                 }
136:                 JavaType fieldType = field.getType();
137:                 if ( !( fieldType instanceof JavaParameterizedType ) ) {
138:                     events.add( SimpleConditionEvent.violated( field,
139:                             field.getFullName() + " is a raw List/Set without a type argument" ) );
140:                     return;
141:                 }
142:                 List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
143:                 if ( typeArguments.isEmpty() ) {
144:                     events.add( SimpleConditionEvent.violated( field,
145:                             field.getFullName() + " has no type arguments" ) );
146:                     return;
147:                 }
148:                 JavaType elementType = typeArguments.get( 0 );
149:                 if ( !( elementType instanceof JavaClass ) ) {
150:                     events.add( SimpleConditionEvent.violated( field,
151:                             field.getFullName() + " has an unknown element type" ) );
152:                     return;
153:                 }
154:                 JavaClass elementClass = (JavaClass) elementType;
155:                 boolean hasAnnotation =
156:                         elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
157:                 boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
158:                 boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
159:                 boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
160:                 boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
161:                 if ( !ok ) {
162:                     events.add( SimpleConditionEvent.violated( field,
163:                             field.getFullName() + " refers to " + elementClass.getFullName()
164:                                     + " which is not a DP, or an entity/value object in " + allowedPackage ) );
165:                 }
166:             }
167:         };
168:     }
169: 
170: 
171:     @ArchTest
172:     static final ArchRule shoppingCartToManyReferences =
173:             fields()
174:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_CART_DOMAIN_PACKAGE )
175:                     .and( isToManyAnnotation )
176:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_CART_DOMAIN_PACKAGE ) )
177:                     .allowEmptyShould( true );
178: 
179:     @ArchTest
180:     static final ArchRule customerToManyReferences =
181:             fields()
182:                     .that().areDeclaredInClassesThat().resideInAPackage( CUSTOMER_DOMAIN_PACKAGE )
183:                     .and( isToManyAnnotation )
184:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( CUSTOMER_DOMAIN_PACKAGE ) )
185:                     .allowEmptyShould( true );
186: 
187:     @ArchTest
188:     static final ArchRule merchandiseToManyReferences =
189:             fields()
190:                     .that().areDeclaredInClassesThat().resideInAPackage( MERCHANDISE_DOMAIN_PACKAGE )
191:                     .and( isToManyAnnotation )
192:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( MERCHANDISE_DOMAIN_PACKAGE ) )
193:                     .allowEmptyShould( true );
194: 
195:     @ArchTest
196:     static final ArchRule purchaseToManyReferences =
197:             fields()
198:                     .that().areDeclaredInClassesThat().resideInAPackage( PURCHASE_DOMAIN_PACKAGE )
199:                     .and( isToManyAnnotation )
200:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( PURCHASE_DOMAIN_PACKAGE ) )
201:                     .allowEmptyShould( true );
202: 
203:     @ArchTest
204:     static final ArchRule storageUnitToManyReferences =
205:             fields()
206:                     .that().areDeclaredInClassesThat().resideInAPackage( STORAGE_UNIT_DOMAIN_PACKAGE )
207:                     .and( isToManyAnnotation )
208:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( STORAGE_UNIT_DOMAIN_PACKAGE ) )
209:                     .allowEmptyShould( true );
210: 
211: }
212: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: /**
4:  * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
5:  */
6: 
7: public class OwnTestsTest {
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClasses;
4: import com.tngtech.archunit.core.importer.ClassFileImporter;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: 
8: import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
9: 
10: public class PackageStructureTest {
11: 
12:     private static final String[] REQUIRED_PACKAGES = {"customer", "shoppingcart", "merchandise", "purchase", "storageunit"};
13:     private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
14:     private JavaClasses importedClasses;
15: 
16: 
17:     @BeforeEach
18:     public void setUp() {
19:         importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
20:     }
21: 
22:     @Test
23:     void testRequiredPackagesAreThere() {
24:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
25:             String packageName = BASE_PACKAGE + "." + requiredPackage;
26:             assertThat( importedClasses.containPackage( packageName ) )
27:                     .as( "Expected package %s not found!", packageName )
28:                     .isTrue();
29:         }
30:     }
31: 
32:     @Test
33:     void testRequiredDomainPackagesAreThere() {
34:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
35:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
36:             assertThat( importedClasses.containPackage( packageName ) )
37:                     .as( "Expected domain sub-package %s not found!", packageName )
38:                     .isTrue();
39:         }
40:     }
41: 
42:     @Test
43:     void testRequiredApplicationPackagesAreThere() {
44:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
45:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
46:             assertThat( importedClasses.containPackage( packageName ) )
47:                     .as( "Expected application sub-package %s not found!", packageName )
48:                     .isTrue();
49:         }
50:     }
51: 
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\AddressTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateAddress;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
11: 
12: class AddressTest {
13: 
14:     @Test
15:     public void testGetterAddress() {
16:         // given
17:         String street = "Irgendeinestraße 42";
18:         String city = "Irgendeinestadt";
19:         ZipCodeType plz = instantiateZipCode( "12345" );
20: 
21:         // when
22:         AddressType instance = instantiateAddress( street, city, plz );
23: 
24:         // then
25:         assertEquals( street, instance.getStreet() );
26:         assertEquals( city, instance.getCity() );
27:         assertEquals( plz, instance.getZipCode() );
28:     }
29: 
30:     @Test
31:     public void testFactoryValidAddress() {
32:         // given
33:         String street = "Irgendeinestraße 42";
34:         String city = "Irgendeinestadt";
35:         ZipCodeType plz = instantiateZipCode( "12345" );
36: 
37:         // when
38:         // then
39:         assertDoesNotThrow( () -> instantiateAddress( street, city, plz ) );
40:     }
41: 
42:     @Test
43:     public void testFactoryInvalidAddress() {
44:         // given
45:         String street = "Irgendeinestraße 42";
46:         String city = "Irgendeinestadt";
47:         ZipCodeType plz = instantiateZipCode( "12345" );
48: 
49:         // when
50:         // then
51:         assertThrows( ShopException.class, () -> instantiateAddress( null, city, plz ) );
52:         assertThrows( ShopException.class, () -> instantiateAddress( "", city, plz ) );
53:         assertThrows( ShopException.class, () -> instantiateAddress( street, null, plz ) );
54:         assertThrows( ShopException.class, () -> instantiateAddress( street, "", plz ) );
55:         assertThrows( ShopException.class, () -> instantiateAddress( street, city, null ) );
56:     }
57: 
58:     @Test
59:     public void testEqualityAddress() {
60:         // given
61:         String street = "Irgendeinestraße 42";
62:         String city = "Irgendeinestadt";
63:         ZipCodeType plz = instantiateZipCode( "12345" );
64: 
65:         // when
66:         AddressType instance1 = instantiateAddress( street, city, plz );
67:         AddressType instance2 = instantiateAddress( street, city, plz );
68:         AddressType instance3 = instantiateAddress( "Anderestr. 12", city, plz );
69:         AddressType instance4 = instantiateAddress( street, "AndereStadt", plz );
70:         AddressType instance5 = instantiateAddress( street, city, instantiateZipCode( "54321" ) );
71: 
72:         // then
73:         assertEquals( instance1, instance2 );
74:         assertNotEquals( instance1, instance3 );
75:         assertNotEquals( instance1, instance4 );
76:         assertNotEquals( instance1, instance5 );
77:     }
78: 
79:     @Test
80:     public void testImmutabilityAddress() {
81:         // given
82:         String street = "Irgendeinestraße 42";
83:         String city = "Irgendeinestadt";
84:         ZipCodeType plz = instantiateZipCode( "12345" );
85: 
86:         // when
87:         AddressType instance = instantiateAddress( street, city, plz );
88: 
89:         // then
90:         try {
91:             instance.getClass().getMethod( "setStreet", String.class );
92:             fail( "setStreet method should not exist" );
93:         } catch (NoSuchMethodException e) {
94:             // Success: the object is immutable
95:         }
96:         try {
97:             instance.getClass().getMethod( "setCity", String.class );
98:             fail( "setCity method should not exist" );
99: 
100:         } catch (NoSuchMethodException e) {
101:             // Success: the object is immutable
102:         }
103:         try {
104:             instance.getClass().getMethod( "setZipCode", ZipCodeType.class );
105:             fail( "setZipCode method should not exist" );
106:         } catch (NoSuchMethodException e) {
107:             // Success: the object is immutable
108:         }
109:     }
110: }
111: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("domainPrimitivesUsageRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class DomainPrimitivesUsageRulesTest {
14:     private static final String MAIL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.MailAddress";
15:     private static final String MONEY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Money";
16:     private static final String ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Address";
17: 
18:     @ArchTest
19:     static final ArchRule customerShouldReferenceMailAddress =
20:             classes()
21:                     .that().haveSimpleName( "Customer" )
22:                     .should().dependOnClassesThat().haveFullyQualifiedName( MAIL_ADDRESS_CLASS )
23:                     .because( "Customer should use MailAddress instead of String" );
24: 
25:     @ArchTest
26:     static final ArchRule customerShouldReferenceAddress =
27:             classes()
28:                     .that().haveSimpleName( "Customer" )
29:                     .should().dependOnClassesThat().haveFullyQualifiedName( ADDRESS_CLASS )
30:                     .because( "Customer should use Address instead of whatever else" );
31: 
32:     @ArchTest
33:     static final ArchRule storageUnitShouldReferenceAddress =
34:             classes()
35:                     .that().haveSimpleName( "StorageUnit" )
36:                     .should().dependOnClassesThat().haveFullyQualifiedName( ADDRESS_CLASS )
37:                     .because( "Customer should use Address instead of whatever else" );
38: 
39:     @ArchTest
40:     static final ArchRule merchandiseShouldReferenceMoney =
41:             classes()
42:                     .that().haveSimpleName( "Merchandise" )
43:                     .should().dependOnClassesThat().haveFullyQualifiedName( MONEY_CLASS )
44:                     .because( "Merchandise should use Money instead of float or whatever else" );
45: }
46: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\MailAddressTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMailAddress;
10: 
11: class MailAddressTest {
12: 
13:     @Test
14:     public void testToStringMailAddress() {
15:         // given
16:         String input = "test@example.com";
17: 
18:         // when
19:         MailAddressType instance = instantiateMailAddress( input );
20: 
21:         // then
22:         assertEquals( input, instance.toString() );
23:     }
24: 
25:     @Test
26:     public void testEqualityMailAddress() {
27:         // given
28:         // when
29:         MailAddressType instance1 = instantiateMailAddress( "test@example.com" );
30:         MailAddressType instance2 = instantiateMailAddress( "test@example.com" );
31:         MailAddressType instance3 = instantiateMailAddress( "different@example.com" );
32: 
33:         // then
34:         assertEquals( instance1, instance2 );
35:         assertNotEquals( instance1, instance3 );
36:     }
37: 
38:     @Test
39:     public void testImmutabilityMailAddress() {
40:         // given
41:         // when
42:         MailAddressType instance = instantiateMailAddress( "test@example.com" );
43: 
44:         // then
45:         try {
46:             instance.getClass().getMethod( "setMailAddress", String.class );
47:             fail( "setMailAddress method should not exist" );
48:         } catch (NoSuchMethodException e) {
49:             // Success: the object is immutable
50:         }
51:     }
52: 
53: 
54: 
55:     @Test
56:     public void smokeTestForCopyConstructors() {
57:         // given
58:         MailAddressType mailAddress =
59:                 instantiateMailAddress( "peter.schmidt@web.de" );
60: 
61:         // when
62:         MailAddressType mailAddressOtherIdentifyer =
63:                 mailAddress.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
64:         assertThrows( ShopException.class, () ->
65:                 mailAddress.sameDomainDifferentIdentifyer( "p...eter" ) );
66:         MailAddressType mailAddressOtherDomain =
67:                 mailAddress.sameIdentifyerDifferentDomain( "web.ch" );
68:         assertThrows( ShopException.class, () ->
69:                 mailAddress.sameIdentifyerDifferentDomain( "web.edu" ) );
70: 
71:         // then
72:         assertEquals( "p.e.t.e.r@web.de", mailAddressOtherIdentifyer.toString() );
73:         assertEquals( "peter.schmidt@web.ch", mailAddressOtherDomain.toString() );
74:     }
75: 
76: 
77:     @Test
78:     public void testFactoryValidMailAddress() {
79:         // given
80:         // when
81:         // then
82:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.com" ) );
83:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "99Z@example.com" ) );
84:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "GGGhh@s77.com" ) );
85:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "a@4.com" ) );
86:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "Max.Hammer@example.com" ) );
87:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "Max.Gideon.Hammer@example.com" ) );
88:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.this.com" ) );
89:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.de" ) );
90:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.at" ) );
91:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.ch" ) );
92:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.org" ) );
93:     }
94: 
95: 
96:     @Test
97:     public void testFactoryInvalidMailAddress() {
98:         // given
99:         // when
100:         // then
101:         assertThrows( ShopException.class, () -> instantiateMailAddress( null ) );
102:         assertThrows( ShopException.class, () -> instantiateMailAddress( "testexample.com" ) );
103:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@" ) );
104:         assertThrows( ShopException.class, () -> instantiateMailAddress( "@example.com" ) );
105:         assertThrows( ShopException.class, () -> instantiateMailAddress( "Max..Gideon.Hammer@example.com" ) );
106:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@examplecom" ) );
107:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example..com" ) );
108:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example@that.com" ) );
109:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test example@that.com" ) );
110:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test#example@that.com" ) );
111:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.biz" ) );
112:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.biz" ) );
113:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.42" ) );
114:     }
115: }
116: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\MoneyTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMoney;
9: 
10: class MoneyTest {
11: 
12:     @Test
13:     public void testGetAmountMoney() {
14:         // given
15:         Float inputAmount = 10.0f;
16: 
17:         // when
18:         MoneyType instance = instantiateMoney( inputAmount, "EUR" );
19: 
20:         // then
21:         assertEquals( inputAmount, instance.getAmount() );
22:     }
23: 
24:     @Test
25:     public void testGetCurrencyUnitMoney() {
26:         // given
27:         String inputCurrencyUnit = "EUR";
28: 
29:         // when
30:         MoneyType instance = instantiateMoney( 10.0f, inputCurrencyUnit );
31: 
32:         // then
33:         assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
34:     }
35: 
36:     @Test
37:     public void testAddToMoney() {
38:         // given
39:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
40:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
41:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
42: 
43:         // when
44:         MoneyType result12 = instance1.add( instance2 );
45:         MoneyType result13 = instance1.add( instance3 );
46: 
47:         // then
48:         assertEquals( 30.0f, result12.getAmount() );
49:         assertEquals( "EUR", result12.getCurrencyUnit() );
50:         assertEquals( 10.0f, result13.getAmount() );
51:         assertEquals( "EUR", result12.getCurrencyUnit() );
52:     }
53: 
54:     @Test
55:     public void testInvalidAddToMoney() {
56:         // given
57:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
58:         MoneyType instance2 = instantiateMoney( 20.0f, "CHF" );
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
63:     }
64: 
65:     @Test
66:     public void testSubtractFromMoney() {
67:         // given
68:         MoneyType instance1 = instantiateMoney( 30.0f, "EUR" );
69:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
70:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
71:         MoneyType instance4 = instantiateMoney( 30.0f, "EUR" );
72: 
73:         // when
74:         MoneyType result12 = instance1.subtract( instance2 );
75:         MoneyType result13 = instance1.subtract( instance3 );
76:         MoneyType result14 = instance1.subtract( instance4 );
77: 
78:         // then
79:         assertEquals( 10.0f, result12.getAmount() );
80:         assertEquals( "EUR", result12.getCurrencyUnit() );
81:         assertEquals( 30.0f, result13.getAmount() );
82:         assertEquals( "EUR", result13.getCurrencyUnit() );
83:         assertEquals( 0.0f, result14.getAmount() );
84:         assertEquals( "EUR", result14.getCurrencyUnit() );
85:     }
86: 
87:     @Test
88:     public void testInvalidSubtractFromMoney() {
89:         // given
90:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
91:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
92:         MoneyType instance3 = instantiateMoney( 5.0f, "CHF" );
93: 
94:         // when
95:         // then
96:         assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
97:         assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
98:     }
99: 
100:     @Test
101:     public void testMultiplyByMoney() {
102:         // given
103:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
104: 
105:         // when
106:         MoneyType result = instance.multiplyBy( 3 );
107: 
108:         // then
109:         assertEquals( 30.0f, result.getAmount() );
110:         assertEquals( "EUR", result.getCurrencyUnit() );
111:     }
112: 
113:     @Test
114:     public void testFactoryValidCurrencyUnitMoney() {
115:         // given
116:         // when
117:         // then
118:         assertDoesNotThrow( () -> instantiateMoney( 10.0f, "EUR" ) );
119:     }
120: 
121:     @Test
122:     public void testFactoryInvalidCurrencyUnitMoney() {
123:         // given
124:         // when
125:         // then
126:         assertThrows( ShopException.class, () -> instantiateMoney( -10.0f, "EUR" ) );
127:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, "USD" ) );
128:         assertThrows( ShopException.class, () -> instantiateMoney( null, "EUR" ) );
129:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, null ) );
130:     }
131: 
132:     @Test
133:     public void testLargerThanCurrencyUnitMoney() {
134:         // given
135:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
136:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
137:         MoneyType instance3 = instantiateMoney( 10.0f, "EUR" );
138:         MoneyType instance4 = instantiateMoney( 10.0f, "CHF" );
139: 
140:         // when
141:         // then
142:         assertTrue( instance2.largerThan( instance1 ) );
143:         assertFalse( instance1.largerThan( instance2 ) );
144:         assertFalse( instance1.largerThan( instance3 ) );
145:         assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
146:     }
147: 
148: 
149:     @Test
150:     public void testEqualityCurrencyUnitMoney() {
151:         // given
152:         // when
153:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
154:         MoneyType instance2 = instantiateMoney( 10.0f, "EUR" );
155:         MoneyType instance3 = instantiateMoney( 20.0f, "EUR" );
156: 
157:         // then
158:         assertEquals( instance1, instance2 );
159:         assertNotEquals( instance1, instance3 );
160:     }
161: 
162:     @Test
163:     public void testImmutabilityCurrencyUnitMoney() {
164:         // given
165:         // when
166:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
167: 
168:         // then
169:         try {
170:             instance.getClass().getMethod( "setAmount", Float.class );
171:             fail( "setAmount method should not exist" );
172:         } catch (NoSuchMethodException e) {
173:             // Success: the object is immutable
174:         }
175: 
176:         try {
177:             instance.getClass().getMethod( "setCurrencyUnit", String.class );
178:             fail( "setCurrencyUnit method should not exist" );
179:         } catch (NoSuchMethodException e) {
180:             // Success: the object is immutable
181:         }
182:     }
183: }
184: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\ZipCodeTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
8: 
9: import static org.junit.jupiter.api.Assertions.*;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
11: 
12: class ZipCodeTest {
13: 
14:     private String input1, input4;
15:     private ZipCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
16:             _04233, _02544, _99123, _56323, _79332;
17: 
18: 
19:     @BeforeEach
20:     public void setUp() {
21:         input1 = "12345";
22:         input4 = "49188";
23:         _12345 = FactoryMethodInvoker.instantiateZipCode( "12345" );
24:         _12345b = FactoryMethodInvoker.instantiateZipCode( "12345" );
25:         _23455 = FactoryMethodInvoker.instantiateZipCode( "23455" );
26:         _01234 = FactoryMethodInvoker.instantiateZipCode( "01234" );
27:         _01235 = FactoryMethodInvoker.instantiateZipCode( "01235" );
28:         _01238 = FactoryMethodInvoker.instantiateZipCode( "01238" );
29:         _01263 = FactoryMethodInvoker.instantiateZipCode( "01263" );
30:         _01213 = FactoryMethodInvoker.instantiateZipCode( "01213" );
31:         _01823 = FactoryMethodInvoker.instantiateZipCode( "01823" );
32:         _01312 = FactoryMethodInvoker.instantiateZipCode( "01312" );
33:         _04233 = FactoryMethodInvoker.instantiateZipCode( "04233" );
34:         _02544 = FactoryMethodInvoker.instantiateZipCode( "02544" );
35:         _99123 = FactoryMethodInvoker.instantiateZipCode( "99123" );
36:         _56323 = FactoryMethodInvoker.instantiateZipCode( "56323" );
37:         _79332 = FactoryMethodInvoker.instantiateZipCode( "79332" );
38: 
39:     }
40: 
41: 
42:     @Test
43:     public void testToStringZipCode() {
44:         // given
45:         // when
46:         ZipCodeType instance = instantiateZipCode( input1 );
47: 
48:         // then
49:         assertEquals( input1, instance.toString() );
50:     }
51: 
52:     @Test
53:     public void testFactoryValidZipCode() {
54:         // given
55:         // when
56:         // then
57:         assertDoesNotThrow( () -> instantiateZipCode( input1 ) );
58:     }
59: 
60:     @Test
61:     public void testFactoryInvalidZipCode() {
62:         // given
63:         // when
64:         // then
65:         assertThrows( ShopException.class, () -> instantiateZipCode( "123456" ) );
66:         assertThrows( ShopException.class, () -> instantiateZipCode( "1234" ) );
67:         assertThrows( ShopException.class, () -> instantiateZipCode( "20000" ) );
68:         assertThrows( ShopException.class, () -> instantiateZipCode( null ) );
69:     }
70: 
71:     @Test
72:     public void testEqualityZipCode() {
73:         // given
74:         // when
75:         ZipCodeType instance1a = instantiateZipCode( input1 );
76:         ZipCodeType instance1b = instantiateZipCode( input1 );
77:         ZipCodeType instance4 = instantiateZipCode( input4 );
78: 
79:         // then
80:         assertEquals( instance1a, instance1b );
81:         assertNotEquals( instance1a, instance4 );
82:     }
83: 
84:     @Test
85:     public void testImmutabilityZipCode() {
86:         // given
87:         // when
88:         ZipCodeType instance = instantiateZipCode( input1 );
89: 
90:         // then
91:         try {
92:             instance.getClass().getMethod( "setzipCode", String.class );
93:             fail( "setzipCode method should not exist" );
94:         } catch (NoSuchMethodException e) {
95:             // Success: the object is immutable
96:         }
97:     }
98: 
99: 
100:     @Test
101:     public void smokeTestForDifference() {
102:         // given
103:         ZipCodeType instance1a = instantiateZipCode( input1 );
104:         ZipCodeType instance1b = instantiateZipCode( input1 );
105:         ZipCodeType instance12479 = instantiateZipCode( "12479" );
106:         ZipCodeType instance21456 = instantiateZipCode( "21456" );
107: 
108:         // when
109:         int differenceAB = instance1a.difference( instance1b );
110:         int difference12 = instance1a.difference( instance12479 );
111:         int difference23 = instance12479.difference( instance21456 );
112: 
113:         // then
114:         assertEquals( 0, differenceAB );
115:         assertTrue( difference12 > 0 );
116:         assertTrue( difference23 > difference12 );
117:     }
118: 
119: 
120:     @Test
121:     public void testZipCodeFirstDigit() {
122:         // given
123:         ZipCodeType instance1 = instantiateZipCode( input1 );
124:         ZipCodeType instance4 = instantiateZipCode( input4 );
125: 
126:         // when
127:         // then
128:         assertEquals( 1, instance1.getFirstDigitZipCode() );
129:         assertEquals( 4, instance4.getFirstDigitZipCode() );
130:     }
131: 
132: 
133: 
134:     @Test
135:     public void testInvalidParameters() {
136:         // given
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 _12345.difference( null ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testSameZipCode() {
146:         // given
147:         // when
148:         int diff = _12345.difference( _12345b );
149: 
150:         // then
151:         assertEquals( 0, diff );
152:     }
153: 
154: 
155:     /**
156:      *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
157:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
158:      *        So, 56733 and 56734 have the same difference as 56733 and 56739.
159:      *      - The difference grows if more digits (counted from the right side) differ.
160:      *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
161:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
162:      *        53876 and 54876 have the same difference as 53876 and 57261.
163:      */
164:     @Test
165:     public void testZipCodeDifferenceInAllButFirstDigit() {
166:         // given
167:         // when
168:         int diff5a = _01234.difference( _01235 );
169:         int diff5b = _01234.difference( _01238 );
170:         int diff4a = _01234.difference( _01263 );
171:         int diff4b = _01234.difference( _01213 );
172:         int diff3a = _01234.difference( _01823 );
173:         int diff3b = _01234.difference( _01312 );
174:         int diff2a = _01234.difference( _04233 );
175:         int diff2b = _01234.difference( _02544 );
176: 
177:         // then
178:         assertEquals( diff5a, diff5b, "difference 01234-01235 must be the same as difference 01234-01238" );
179:         assertEquals( diff4a, diff4b, "difference 01234-01263 must be the same as difference 01234-01213" );
180:         assertEquals( diff3a, diff3b, "difference 01234-01823 must be the same as difference 01234-01312" );
181:         assertEquals( diff2a, diff2b, "difference 01234-04233 must be the same as difference 01234-02544" );
182: 
183:         assertTrue( diff5a < diff4a,
184:                 "difference 01234-01235 must be smaller than difference 01234-01263" );
185:         assertTrue( diff4a < diff3a,
186:                 "difference 01234-01263 must be smaller than difference 01234-01823" );
187:         assertTrue( diff3a < diff2a,
188:                 "difference 01234-01823 must be smaller than difference 01234-04233" );
189:     }
190: 
191: 
192:     /**
193:      *      - However, the difference between 5abcd and 6rstu must be smaller than the one
194:      *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
195:      *        one between 5abcd and 9rstu.
196:      *      - This last condition reflects the fact the first digits of a zip code marks a region
197:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
198:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
199:      *        other.
200:      */
201:     @Test
202:     public void testZipCodedifferenceInFirstDigit() {
203:         // given
204:         // when
205:         int diff1_1 = _01234.difference( _99123 );
206:         int diff1_2 = _01234.difference( _23455 );
207:         int diff1_5 = _01234.difference( _56323 );
208:         int diff1_3 = _01234.difference( _79332 );
209: 
210:         // then
211:         assertTrue( diff1_1 < diff1_2,
212:                 "difference 01234-99123 must be smaller than difference 01234-23455"  );
213:         assertTrue( diff1_2 < diff1_3,
214:                 "difference 01234-23455 must be smaller than difference 01234-79332" );
215:         assertTrue( diff1_3 < diff1_5,
216:                 "difference 01234-79332 must be smaller than difference 01234-56323"  );
217:     }
218: 
219: 
220: 
221: }
222: 
223: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
1: package thkoeln.archilab.ecommerce.tests.e1restcalls;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;
5: 
6: 
7: public class E1RestCallTableTest {
8: 
9:     private GenericTableSpecificationTests genericTableSpecificationTests = null;
10: 
11: 
12:     public E1RestCallTableTest() {
13:         this.genericTableSpecificationTests = new GenericTableSpecificationTests();
14:     }
15: 
16:     @Test
17:     public void restTest() throws Exception {
18:         genericTableSpecificationTests.testTableSpecification("E1" );
19:     }
20: }
21: 
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\merchandise\MerchandiseCatalogTest.java ---
1: package thkoeln.archilab.ecommerce.tests.merchandise;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
9: import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
15: 
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.*;
19: 
20: 
21: @SpringBootTest
22: public class MerchandiseCatalogTest {
23:     @Autowired
24:     private CustomerRegistrationUseCases customerRegistrationUseCases;
25:     @Autowired
26:     private ShoppingCartUseCases shoppingCartUseCases;
27:     @Autowired
28:     private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
29:     @Autowired
30:     private StorageUnitUseCases storageUnitUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private CustomerTestHelper customerTestHelper;
35:     @Autowired
36:     private MerchandiseTestHelper merchandiseTestHelper;
37:     @Autowired
38:     private StorageUnitTestHelper storageUnitTestHelper;
39: 
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         customerTestHelper.registerAllCustomers();
45:         merchandiseTestHelper.addAllMerchandises();
46:     }
47: 
48: 
49:     @Test
50:     public void testAddMerchandiseToCatalog() {
51:         // given
52:         UUID merchandiseId4 = merchandiseTestHelper.getMerchandiseId( 4 );
53:         MoneyType salesPrice4 = merchandiseTestHelper.getSalesPrice( 4 );
54: 
55:         // when
56:         MoneyType foundSalesPrice = merchandiseCatalogUseCases.getSalesPrice( merchandiseId4 );
57: 
58:         // then
59:         assertEquals( salesPrice4, foundSalesPrice );
60:     }
61: 
62: 
63:     @Test
64:     public void testAddMerchandiseWithInvalidData() {
65:         // given
66:         String name = "SomeStuff";
67:         String description = "Some more explanation on the stuff";
68:         Float size = 5.0f;
69:         MoneyType buyingPrice =
70:                 FactoryMethodInvoker.instantiateMoney( 5.0f, "EUR" );
71:         MoneyType salesPrice =
72:                 FactoryMethodInvoker.instantiateMoney( 10.0f, "EUR" );
73:         MoneyType tooLowSalesPrice =
74:                 FactoryMethodInvoker.instantiateMoney( 4.0f, "EUR" );
75: 
76:         // when / then
77:         assertThrows( ShopException.class, () ->
78:                 merchandiseCatalogUseCases.addMerchandiseToCatalog(
79:                         null, description, size, buyingPrice, salesPrice ) );
80:         assertThrows( ShopException.class, () ->
81:                 merchandiseCatalogUseCases.addMerchandiseToCatalog(
82:                         "", description, size, buyingPrice, salesPrice ) );
83:         assertThrows( ShopException.class, () ->
84:                 merchandiseCatalogUseCases.addMerchandiseToCatalog(
85:                         name, null, size, buyingPrice, salesPrice ) );
86:         assertThrows( ShopException.class, () ->
87:                 merchandiseCatalogUseCases.addMerchandiseToCatalog(
88:                         name, "", size, buyingPrice, salesPrice ) );
89:         assertThrows( ShopException.class, () ->
90:                 merchandiseCatalogUseCases.addMerchandiseToCatalog(
91:                         name, description, size, null, salesPrice ) );
92:         assertThrows( ShopException.class, () ->
93:                 merchandiseCatalogUseCases.addMerchandiseToCatalog(
94:                         name, description, size, buyingPrice, null ) );
95:         assertThrows( ShopException.class, () ->
96:                 merchandiseCatalogUseCases.addMerchandiseToCatalog(
97:                         name, description, size, buyingPrice, tooLowSalesPrice ) );
98:     }
99: 
100: 
101:     @Test
102:     public void testRemoveNonExistentMerchandise() {
103:         // given merchandise 2 is not in inventory anywhere - should be removable
104:         UUID nonExistentMerchandiseId = UUID.randomUUID();
105: 
106:         // when
107:         // then
108:         assertThrows( ShopException.class,
109:                 () -> merchandiseCatalogUseCases.removeMerchandiseFromCatalog( nonExistentMerchandiseId ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testRemoveMerchandiseWithNoInventory() {
115:         // given merchandise 0 is not in inventory anywhere - should be removable
116:         UUID merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 );
117:         storageUnitTestHelper.addAllStorageUnits( true );
118: 
119:         // when
120:         assertDoesNotThrow( () -> merchandiseCatalogUseCases.getSalesPrice( merchandiseId0 ) );
121:         merchandiseCatalogUseCases.removeMerchandiseFromCatalog( merchandiseId0 );
122: 
123:         // then
124:         assertThrows( ShopException.class, () ->
125:                 merchandiseCatalogUseCases.getSalesPrice( merchandiseId0 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testRemoveMerchandiseThatIsInInventory() {
131:         // given
132:         storageUnitTestHelper.addAllStorageUnits( false );
133:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
134:         UUID merchandiseId3 = merchandiseTestHelper.getMerchandiseId( 3 );
135:         UUID merchandiseId4 = merchandiseTestHelper.getMerchandiseId( 4 );
136:         storageUnitUseCases.addToInventory( storageUnitId0, merchandiseId3, 3 );
137: 
138:         // then merchandise 3 must not be removable, but merchandise 4 must be removable
139:         assertThrows( ShopException.class,
140:                 () -> merchandiseCatalogUseCases.removeMerchandiseFromCatalog( merchandiseId3 ) );
141:         assertDoesNotThrow( () -> merchandiseCatalogUseCases.removeMerchandiseFromCatalog( merchandiseId4 ) );
142:     }
143: 
144: 
145:     @Test
146:     public void testRemoveMerchandiseThatIsInPurchase() {
147:         // given
148:         storageUnitTestHelper.addAllStorageUnits( false );
149:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
150:         UUID merchandiseId4 = merchandiseTestHelper.getMerchandiseId( 4 );
151:         MailAddressType customerMailAddress4 =
152:                 customerTestHelper.getCustomerMailAddress( 4 );
153:         storageUnitUseCases.addToInventory( storageUnitId0, merchandiseId4, 4 );
154: 
155:         // when customer 4 adds 4x merchandise 4 to his shopping cart and checks out ...
156:         shoppingCartUseCases.addMerchandiseToShoppingCart(
157:                 customerMailAddress4, merchandiseId4, 4 );
158:         shoppingCartUseCases.checkout( customerMailAddress4 );
159: 
160:         // then merchandise 4 must not be removable
161:         assertThrows( ShopException.class,
162:                 () -> merchandiseCatalogUseCases.removeMerchandiseFromCatalog( merchandiseId4 ) );
163:     }
164: 
165: 
166:     @Test
167:     public void testClearMerchandiseCatalog() {
168:         // given
169:         UUID merchandiseId4 = merchandiseTestHelper.getMerchandiseId( 4 );
170: 
171:         // when
172:         merchandiseCatalogUseCases.deleteMerchandiseCatalog();
173: 
174:         // then
175:         assertThrows( ShopException.class, () -> merchandiseCatalogUseCases.getSalesPrice( merchandiseId4 ) );
176:     }
177: 
178: }
179: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import com.fasterxml.jackson.databind.ObjectMapper;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import thkoeln.archilab.ecommerce.domainprimitives.Address;
7: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
8: import thkoeln.archilab.ecommerce.domainprimitives.Money;
9: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
10: 
11: import static org.junit.jupiter.api.Assertions.assertEquals;
12: 
13: public class DomainPrimitiveJSONSerializationTest {
14:     private ObjectMapper objectMapper;
15: 
16:     @BeforeEach
17:     public void setUp() {
18:         objectMapper = new ObjectMapper();
19:     }
20: 
21: 
22:     /**
23:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
24:      * MailAddress.
25:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
26:      * on how to implement this test, and how to change property names.
27:      * @throws Exception
28:      */
29:     @Test
30:     public void test_MailAddress_Serialization() throws Exception {
31:         // given
32:         MailAddress mailAddress = MailAddress.of("test@example.com");
33: 
34:         // when
35:         String json = objectMapper.writeValueAsString(mailAddress);
36:         MailAddress deserialized = objectMapper.readValue(json, MailAddress.class);
37: 
38:         // then
39:         assertEquals(mailAddress, deserialized);
40:     }
41: 
42: 
43:     /**
44:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
45:      * ZipCode.
46:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
47:      * on how to implement this test, and how to change property names.
48:      * @throws Exception
49:      */
50:     @Test
51:     public void test_ZipCode_Serialization() throws Exception {
52:         // given
53:         ZipCode zipCode = ZipCode.of("12345");
54: 
55:         // when
56:         String json = objectMapper.writeValueAsString(zipCode);
57:         ZipCode deserialized = objectMapper.readValue(json, ZipCode.class);
58: 
59:         // then
60:         assertEquals(zipCode, deserialized);
61:     }
62: 
63: 
64:     /**
65:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
66:      * Address.
67:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
68:      * on how to implement this test, and how to change property names.
69:      * @throws Exception
70:      */
71:     @Test
72:     public void test_Address_Serialization() throws Exception {
73:         // given
74:         Address address = Address.of(
75:                 "Main Street",
76:                 "New York",
77:                 ZipCode.of("12345")
78:         );
79: 
80:         // when
81:         String json = objectMapper.writeValueAsString(address);
82:         Address deserialized = objectMapper.readValue(json, Address.class);
83: 
84:         // then
85:         assertEquals(address, deserialized);
86:     }
87: 
88: 
89:     /**
90:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
91:      * Money.
92:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
93:      * on how to implement this test, and how to change property names.
94:      * @throws Exception
95:      */
96:     @Test
97:     public void test_Money_Serialization() throws Exception {
98:         // given
99:         Money money = Money.of(19.99f, "EUR");
100: 
101:         // when
102:         String json = objectMapper.writeValueAsString(money);
103:         Money deserialized = objectMapper.readValue(json, Money.class);
104: 
105:         // then
106:         assertEquals(money, deserialized);
107:     }
108: 
109: }
110: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingCartRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import com.fasterxml.jackson.databind.ObjectMapper;
4: import jakarta.transaction.Transactional;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: import org.springframework.beans.factory.annotation.Autowired;
8: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
9: import org.springframework.boot.test.context.SpringBootTest;
10: import org.springframework.context.annotation.Import;
11: import org.springframework.http.MediaType;
12: import org.springframework.test.web.servlet.MockMvc;
13: import org.springframework.test.web.servlet.MvcResult;
14: import org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder;
15: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
16: import thkoeln.archilab.ecommerce.solution.shoppingcart.application.ShoppingCartController;
17: import thkoeln.archilab.ecommerce.solution.shoppingcart.application.ShoppingCartService;
18: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
19: import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
20: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
21: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
22: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
23: 
24: import java.util.HashMap;
25: import java.util.List;
26: import java.util.Map;
27: import java.util.UUID;
28: 
29: import static org.junit.jupiter.api.Assertions.*;
30: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
31: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
32: 
33: @SpringBootTest
34: @Transactional
35: @AutoConfigureMockMvc
36: @Import(RESTTestHelperConfiguration.class)
37: public class OwnShoppingCartRESTTest {
38:     @Autowired
39:     private MockMvc mockMvc;
40:     @Autowired
41:     private ObjectMapper objectMapper;
42:     @Autowired
43:     private Purgatory purgatory;
44:     @Autowired
45:     private CustomerTestHelper customerTestHelper;
46:     @Autowired
47:     private MerchandiseTestHelper merchandiseTestHelper;
48:     @Autowired
49:     private StorageUnitTestHelper storageUnitTestHelper;
50:     @Autowired
51:     private ShoppingCartService shoppingCartService;
52:     @Autowired
53:     private ShoppingCartController shoppingCartController;
54: 
55:     private MailAddressType mailAddress;
56: 
57:     @BeforeEach
58:     public void setUp() {
59:         purgatory.deleteEverything();
60:         customerTestHelper.registerAllCustomers();
61:         merchandiseTestHelper.addAllMerchandises();
62:         storageUnitTestHelper.addAllStorageUnits(true);
63:     }
64: 
65:     @Test
66:     public void test_getQuery_ShoppingCart() throws Exception {
67:         // given
68:         UUID merchandiseId1 = merchandiseTestHelper.getMerchandiseId(0);
69:         UUID merchandiseId2 = merchandiseTestHelper.getMerchandiseId(1);
70: 
71:         shoppingCartService.addMerchandiseToShoppingCart(
72:                 customerTestHelper.getCustomerMailAddress(0),
73:                 merchandiseId1,
74:                 2
75:         );
76:         shoppingCartService.addMerchandiseToShoppingCart(
77:                 customerTestHelper.getCustomerMailAddress(0),
78:                 merchandiseId2,
79:                 1
80:         );
81: 
82:         UUID customerId = shoppingCartService.getCustomerIdByMail(customerTestHelper
83:                 .getCustomerMailAddress(0));
84: 
85:         // when
86:         MvcResult result = mockMvc.perform(get("/shoppingCarts")
87:                         .param("customerId", customerId.toString()))
88:                 .andExpect(status().isOk())
89:                 .andReturn();
90: 
91:         // then
92:         String content = result.getResponse().getContentAsString();
93:         Map<String, Object> response = objectMapper.readValue(content, Map.class);
94: 
95:         assertNotNull(response.get("id"));
96:         assertNotNull(response.get("totalSalesPrice"));
97: 
98:         String totalPrice = response.get("totalSalesPrice").toString();
99:         assertTrue(totalPrice.matches("^\\d+[.,]\\d{2}\\s*(EUR|CHF|€|â¬|\\$)$"),
100:                 "Total price format should be 'XX.XX EUR', 'XX,XX CHF' or similar. Actual: " + totalPrice);
101: 
102:         assertNotNull(response.get("positions"));
103:         assertEquals(2, ((List<?>) response.get("positions")).size());
104:     }
105: 
106:     @Test
107:     public void test_post_ShoppingCartPositions() throws Exception {
108:         // given
109:         MailAddressType customerMailAddress = customerTestHelper.getCustomerMailAddress(0);
110:         UUID merchandiseId = merchandiseTestHelper.getMerchandiseId(0);
111: 
112:         // when
113:         shoppingCartService.addMerchandiseToShoppingCart(customerMailAddress, merchandiseId, 3);
114: 
115:         // then
116:         Map<UUID, Integer> cart = shoppingCartService.getShoppingCartAsMap(customerMailAddress);
117: 
118:         assertEquals(1, cart.size());
119:         assertEquals(3, cart.get(merchandiseId).intValue());
120:     }
121: 
122:     @Test
123:     public void test_delete_ShoppingCartPositions() throws Exception {
124:         // given
125:         MailAddressType customerMailAddress = customerTestHelper.getCustomerMailAddress(0);
126:         UUID merchandiseId = merchandiseTestHelper.getMerchandiseId(0);
127: 
128:         shoppingCartService.addMerchandiseToShoppingCart(
129:                 customerMailAddress,
130:                 merchandiseId,
131:                 5
132:         );
133: 
134:         UUID customerId = shoppingCartService.getCustomerIdByMail(customerTestHelper
135:                 .getCustomerMailAddress(0));
136: 
137:         // when
138:         mockMvc.perform(delete("/shoppingCarts/{customerId}/positions/{merchandiseId}?quantity=2",
139:                         customerId, merchandiseId))
140:                 .andExpect(status().isNotFound());
141: 
142:         // then
143:         Map<UUID, Integer> cart = shoppingCartService.getShoppingCartAsMap(customerMailAddress);
144: 
145:         assertEquals(1, cart.size());
146:         assertEquals(5, cart.get(merchandiseId).intValue());
147:     }
148: 
149:     @Test
150:     public void test_checkout_1_storageUnit() throws Exception {
151:         // given
152:         UUID merchandiseId = merchandiseTestHelper.getMerchandiseId(1);
153: 
154:         shoppingCartService.addMerchandiseToShoppingCart(
155:                 customerTestHelper.getCustomerMailAddress(0),
156:                 merchandiseId,
157:                 2
158:         );
159: 
160:         UUID customerId = shoppingCartService.getCustomerIdByMail(customerTestHelper
161:                 .getCustomerMailAddress(0));
162: 
163:         mockMvc.perform(post("/shoppingCarts/{customerId}/checkout", customerId))
164:                 .andExpect(status().isConflict());
165:     }
166: 
167:     @Test
168:     public void test_checkout_2_storageUnits() throws Exception {
169:         // given
170:         UUID merchandiseId1 = merchandiseTestHelper.getMerchandiseId(6);
171:         UUID merchandiseId2 = merchandiseTestHelper.getMerchandiseId(7);
172: 
173:         shoppingCartService.addMerchandiseToShoppingCart(
174:                 customerTestHelper.getCustomerMailAddress(0),
175:                 merchandiseId1,
176:                 5
177:         );
178:         shoppingCartService.addMerchandiseToShoppingCart(
179:                 customerTestHelper.getCustomerMailAddress(0),
180:                 merchandiseId2,
181:                 5
182:         );
183: 
184:         UUID customerId = shoppingCartService.getCustomerIdByMail(customerTestHelper
185:                 .getCustomerMailAddress(0));
186: 
187:         mockMvc.perform(post("/shoppingCarts/{customerId}/checkout", customerId))
188:                 .andExpect(status().isConflict());
189:     }
190: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\purchase\PurchaseTest.java ---
1: package thkoeln.archilab.ecommerce.tests.purchase;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: 
15: import java.util.Map;
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.assertEquals;
19: import static org.junit.jupiter.api.Assertions.assertThrows;
20: 
21: 
22: @SpringBootTest
23: public class PurchaseTest {
24:     @Autowired
25:     private CustomerRegistrationUseCases customerRegistrationUseCases;
26:     @Autowired
27:     private ShoppingCartUseCases shoppingCartUseCases;
28:     @Autowired
29:     private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
30:     @Autowired
31:     private StorageUnitUseCases storageUnitUseCases;
32:     @Autowired
33:     private PurchaseUseCases purchaseUseCases;
34:     @Autowired
35:     private Purgatory purgatory;
36:     @Autowired
37:     private CustomerTestHelper customerTestHelper;
38:     @Autowired
39:     private MerchandiseTestHelper merchandiseTestHelper;
40:     @Autowired
41:     private StorageUnitTestHelper storageUnitTestHelper;
42: 
43:     private UUID nonExistingId1;
44:     private UUID nonExistingId2;
45: 
46:     @BeforeEach
47:     public void setUp() {
48:         purgatory.deleteEverything();
49:         customerTestHelper.registerAllCustomers();
50:         merchandiseTestHelper.addAllMerchandises();
51:         storageUnitTestHelper.addAllStorageUnits( true );
52:         nonExistingId1 = UUID.randomUUID();
53:         nonExistingId2 = UUID.randomUUID();
54:     }
55: 
56: 
57:     @Test
58:     public void testPurchaseHistory() {
59:         // given
60:         UUID merchandiseId1 = merchandiseTestHelper.getMerchandiseId( 1 );
61:         UUID merchandiseId2 = merchandiseTestHelper.getMerchandiseId( 2 );
62:         MailAddressType customerMailAddress7 =
63:                 customerTestHelper.getCustomerMailAddress( 7 );
64:         Map<UUID, Integer> purchaseHistoryBefore = purchaseUseCases.getPurchaseHistory( customerMailAddress7 );
65: 
66:         // when
67:         shoppingCartUseCases.addMerchandiseToShoppingCart(
68:                 customerMailAddress7, merchandiseId1, 3 );
69:         shoppingCartUseCases.addMerchandiseToShoppingCart(
70:                 customerMailAddress7, merchandiseId2, 2 );
71:         shoppingCartUseCases.checkout( customerMailAddress7 );
72:         Map<UUID, Integer> purchaseHistory1 =
73:                 purchaseUseCases.getPurchaseHistory( customerMailAddress7 );
74:         shoppingCartUseCases.addMerchandiseToShoppingCart(
75:                 customerMailAddress7, merchandiseId1, 6 );
76:         shoppingCartUseCases.addMerchandiseToShoppingCart(
77:                 customerMailAddress7, merchandiseId2, 2 );
78:         shoppingCartUseCases.checkout( customerMailAddress7 );
79:         Map<UUID, Integer> purchaseHistory2 =
80:                 purchaseUseCases.getPurchaseHistory( customerMailAddress7 );
81:         shoppingCartUseCases.addMerchandiseToShoppingCart(
82:                 customerMailAddress7, merchandiseId1, 1 );
83:         shoppingCartUseCases.addMerchandiseToShoppingCart(
84:                 customerMailAddress7, merchandiseId2, 6 );
85:         shoppingCartUseCases.checkout( customerMailAddress7 );
86:         Map<UUID, Integer> purchaseHistory3 =
87:                 purchaseUseCases.getPurchaseHistory( customerMailAddress7 );
88: 
89:         // then
90:         assertEquals( 0, purchaseHistoryBefore.size() );
91:         assertEquals( 2, purchaseHistory1.size() );
92:         assertEquals( 2, purchaseHistory2.size() );
93:         assertEquals( 2, purchaseHistory3.size() );
94:         assertEquals( 3, purchaseHistory1.get( merchandiseId1 ) );
95:         assertEquals( 2, purchaseHistory1.get( merchandiseId2 ) );
96:         assertEquals( 9, purchaseHistory2.get( merchandiseId1 ) );
97:         assertEquals( 4, purchaseHistory2.get( merchandiseId2 ) );
98:         assertEquals( 10, purchaseHistory3.get( merchandiseId1 ) );
99:         assertEquals( 10, purchaseHistory3.get( merchandiseId2 ) );
100:     }
101: 
102: 
103:     @Test
104:     public void testForEmptyPurchaseHistory() {
105:         // given
106:         MailAddressType customerMailAddress4 =
107:                 customerTestHelper.getCustomerMailAddress( 4 );
108:         // when
109:         Map<UUID, Integer> purchaseHistory =
110:                 purchaseUseCases.getPurchaseHistory( customerMailAddress4 );
111:         // then
112:         assertEquals( 0, purchaseHistory.size() );
113:     }
114: 
115: 
116:     @Test
117:     public void testInvalidParamsForGetPurchaseQuantOfMerchandise() {
118:         // given
119:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
120: 
121:         // when / then
122:         assertThrows ( ShopException.class,
123:                 () -> purchaseUseCases.getPurchaseQuantOfMerchandise( null, null ) );
124:         assertThrows ( ShopException.class,
125:                 () -> purchaseUseCases.getPurchaseQuantOfMerchandise( nonExistingId1, null ) );
126:         assertThrows ( ShopException.class,
127:                 () -> purchaseUseCases.getPurchaseQuantOfMerchandise( null, nonExistingId2 ) );
128:         assertThrows ( ShopException.class,
129:                 () -> purchaseUseCases.getPurchaseQuantOfMerchandise( nonExistingId1, nonExistingId2 ) );
130:         assertThrows ( ShopException.class,
131:                 () -> purchaseUseCases.getPurchaseQuantOfMerchandise( storageUnitId0, null ) );
132:         assertThrows ( ShopException.class,
133:                 () -> purchaseUseCases.getPurchaseQuantOfMerchandise( storageUnitId0, nonExistingId2 ) );
134:     }
135: 
136: 
137:     @Test
138:     public void testInvalidParamsForGetStorageUnitIdForPurchase() {
139:         // given / when / then
140:         assertThrows ( ShopException.class,
141:                 () -> purchaseUseCases.getStorageUnitIdForPurchase( null ) );
142:         assertThrows ( ShopException.class,
143:                 () -> purchaseUseCases.getStorageUnitIdForPurchase( nonExistingId1 ) );
144:     }
145: }
146: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\CheckoutAcceptanceTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingcart;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: 
15: import java.util.*;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: 
19: /**
20:  * This test checks the management of inventory across storage units. It focuses on the
21:  * cases where more than one storage unit are needed to serve the shopping cart of a customer.
22:  */
23: @Slf4j
24: @SpringBootTest
25: public class CheckoutAcceptanceTest {
26:     @Autowired
27:     private CustomerRegistrationUseCases customerRegistrationUseCases;
28:     @Autowired
29:     private ShoppingCartUseCases shoppingCartUseCases;
30:     @Autowired
31:     private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
32:     @Autowired
33:     private PurchaseUseCases purchaseUseCases;
34:     @Autowired
35:     private StorageUnitUseCases storageUnitUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private CustomerTestHelper customerTestHelper;
40:     @Autowired
41:     private MerchandiseTestHelper merchandiseTestHelper;
42:     @Autowired
43:     private StorageUnitTestHelper storageUnitTestHelper;
44: 
45:     private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
46:                                 map8_11_14_quantity_3_3_4,
47:                                 map10_12_quantity_1_1, 
48:                                 map11_quantity_1, 
49:                                 map12_quantity_10,
50:                                 map8_9_10_11_quantity_2_1_4_2;
51:     private MailAddressType customerMailAddress3, customerMailAddress6,
52:             customerMailAddress2;
53:     private UUID merchandiseId8, merchandiseId9, merchandiseId10, merchandiseId11, merchandiseId12,
54:             merchandiseId14;
55: 
56: 
57:     @BeforeEach
58:     public void setUp() {
59:         purgatory.deleteEverything();
60:         customerTestHelper.registerAllCustomers();
61:         merchandiseTestHelper.addAllMerchandises();
62:         storageUnitTestHelper.addAllStorageUnits( true );
63: 
64:         customerMailAddress3 = customerTestHelper.getCustomerMailAddress( 3 );
65:         customerMailAddress6 = customerTestHelper.getCustomerMailAddress( 6 );
66:         customerMailAddress2 = customerTestHelper.getCustomerMailAddress( 2 );
67: 
68:         merchandiseId8 = merchandiseTestHelper.getMerchandiseId( 8 );
69:         merchandiseId9 = merchandiseTestHelper.getMerchandiseId( 9 );
70:         merchandiseId10 = merchandiseTestHelper.getMerchandiseId( 10 );
71:         merchandiseId11 = merchandiseTestHelper.getMerchandiseId( 11 );
72:         merchandiseId12 = merchandiseTestHelper.getMerchandiseId( 12 );
73:         merchandiseId14 = merchandiseTestHelper.getMerchandiseId( 14 );
74: 
75:         map8_11_14_quantity_2_2_2 = new HashMap<>() {{
76:             put( merchandiseId8, 2 );
77:             put( merchandiseId11, 2 );
78:             put( merchandiseId14, 2 );
79:         }};
80:         map8_11_14_quantity_3_3_4 = new HashMap<>() {{
81:             put( merchandiseId8, 3 );
82:             put( merchandiseId11, 3 );
83:             put( merchandiseId14, 4 );
84:         }};
85:         map10_12_quantity_1_1 = new HashMap<>() {{
86:             put( merchandiseId10, 1 );
87:             put( merchandiseId12, 1 );
88:         }};
89:         map11_quantity_1 = new HashMap<>() {{
90:             put( merchandiseId11, 1 );
91:         }};
92:         map12_quantity_10 = new HashMap<>() {{
93:             put( merchandiseId12, 10 );
94:         }};
95:         map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
96:             put( merchandiseId8, 2 );
97:             put( merchandiseId9, 1 );
98:             put( merchandiseId10, 4 );
99:             put( merchandiseId11, 2 );
100:         }};
101: 
102:     }
103: 
104: 
105:     /**
106:      * Hint: to better understand the expected results of this test, see the distribution of inventory
107:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
108:      */
109:     @Test
110:     public void testClosestSingleStorageUnitWins() {
111:         log.info( "testClosestSingleStorageUnitWins" );
112: 
113:         // given
114:         shoppingCartUseCases.addMerchandiseToShoppingCart(
115:                 customerMailAddress3, merchandiseId8, 2 );
116:         shoppingCartUseCases.addMerchandiseToShoppingCart(
117:                 customerMailAddress3, merchandiseId11, 2 );
118:         shoppingCartUseCases.addMerchandiseToShoppingCart(
119:                 customerMailAddress3, merchandiseId14, 2 );
120:         // that basket could have been served from storage unit 4 or 7, but 4 is closer to the customer
121:         UUID storageUnitId4 = storageUnitTestHelper.getStorageUnitId( 4 );
122: 
123:         // when
124:         Set<UUID> purchaseIds = shoppingCartUseCases.checkout( customerMailAddress3 );
125: 
126:         // then
127:         checkStorageUnitIds( purchaseIds, storageUnitId4 );
128:         checkMerchandiseNumbers( purchaseIds, storageUnitId4, map8_11_14_quantity_2_2_2 );
129:     }
130: 
131: 
132:     /**
133:      * Hint: to better understand the expected results of this test, see the distribution of inventory
134:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
135:      */
136:     @Test
137:     public void testStorageUnitWithEnoughCapacityWins() {
138:         log.info( "testStorageUnitWithEnoughCapacityWins" );
139: 
140:         // given
141:         shoppingCartUseCases.addMerchandiseToShoppingCart(
142:                 customerMailAddress3, merchandiseId8, 3 );
143:         shoppingCartUseCases.addMerchandiseToShoppingCart(
144:                 customerMailAddress3, merchandiseId11, 3 );
145:         shoppingCartUseCases.addMerchandiseToShoppingCart(
146:                 customerMailAddress3, merchandiseId14, 4 );
147:         // that basket could have been served from storage unit 4 or 7, 4 is closer to the customer,
148:         // but only 7 has enough capacity
149:         UUID storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );
150: 
151:         // when
152:         Set<UUID> purchaseIds = shoppingCartUseCases.checkout( customerMailAddress3 );
153: 
154:         // then
155:         checkStorageUnitIds( purchaseIds, storageUnitId7 );
156:         checkMerchandiseNumbers( purchaseIds, storageUnitId7, map8_11_14_quantity_3_3_4 );
157:     }
158: 
159: 
160:     /**
161:      * Hint: to better understand the expected results of this test, see the distribution of inventory
162:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
163:      */
164:     @Test
165:     public void testTwoStorageUnits() {
166:         log.info( "testTwoStorageUnits" );
167: 
168:         // given
169:         shoppingCartUseCases.addMerchandiseToShoppingCart(
170:                 customerMailAddress6, merchandiseId10, 1 );
171:         shoppingCartUseCases.addMerchandiseToShoppingCart(
172:                 customerMailAddress6, merchandiseId11, 1 );
173:         shoppingCartUseCases.addMerchandiseToShoppingCart(
174:                 customerMailAddress6, merchandiseId12, 1 );
175:         // that basket needs two shipments (2 + 1 merchandises) anyway, and there
176:         // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
177:         // closer. The smaller can then be served from 4 (closest), 7, or 8.
178:         UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
179:                 // should cover map10_12_quantity_1_1
180:         UUID storageUnitId4 = storageUnitTestHelper.getStorageUnitId( 4 );
181:                 // should cover map11_quantity_1
182: 
183:         // when
184:         Set<UUID> purchaseIds = shoppingCartUseCases.checkout( customerMailAddress6 );
185: 
186:         // then
187:         checkStorageUnitIds( purchaseIds, storageUnitId5, storageUnitId4 );
188:         checkMerchandiseNumbers( purchaseIds, storageUnitId5, map10_12_quantity_1_1 );
189:         checkMerchandiseNumbers( purchaseIds, storageUnitId4, map11_quantity_1 );
190:     }
191: 
192: 
193:     /**
194:      * Hint: to better understand the expected results of this test, see the distribution of inventory
195:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
196:      */
197:     @Test
198:     public void testTwoBigShipments() {
199:         log.info( "testTwoBigShipments" );
200: 
201:         // given
202:         shoppingCartUseCases.addMerchandiseToShoppingCart(
203:                 customerMailAddress2, merchandiseId8, 2 );
204:         shoppingCartUseCases.addMerchandiseToShoppingCart(
205:                 customerMailAddress2, merchandiseId9, 1 );
206:         shoppingCartUseCases.addMerchandiseToShoppingCart(
207:                 customerMailAddress2, merchandiseId10, 4 );
208:         shoppingCartUseCases.addMerchandiseToShoppingCart(
209:                 customerMailAddress2, merchandiseId11, 2 );
210:         shoppingCartUseCases.addMerchandiseToShoppingCart(
211:                 customerMailAddress2, merchandiseId12, 10 );
212:         // when
213:         Set<UUID> purchaseIds = shoppingCartUseCases.checkout( customerMailAddress2 );
214:         UUID storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );
215:                 // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 merchandises
216:         UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
217:                 // should cover map12_quantity_10 - the only storage unit with enough capacity for 10 merchandises
218: 
219:         // then
220:         checkStorageUnitIds( purchaseIds, storageUnitId7, storageUnitId5 );
221:         checkMerchandiseNumbers( purchaseIds, storageUnitId7, map8_9_10_11_quantity_2_1_4_2 );
222:         checkMerchandiseNumbers( purchaseIds, storageUnitId5, map12_quantity_10 );
223:     }
224: 
225: 
226:     /**
227:      * Hint: to better understand the expected results of this test, see the distribution of inventory
228:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
229:      */
230:     @Test
231:     public void testOnlyOneSolution() {
232:         log.info( "testOnlyOneSolution" );
233: 
234:         // given
235:         shoppingCartUseCases.addMerchandiseToShoppingCart(
236:                 customerMailAddress6, merchandiseId12, 10 );
237:         // when
238:         Set<UUID> purchaseIds = shoppingCartUseCases.checkout( customerMailAddress6 );
239:         UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
240:         // should cover map12_quantity_10 - the only storage unit with enough capacity for 10 merchandises
241: 
242:         // then
243:         checkStorageUnitIds( purchaseIds, storageUnitId5 );
244:         checkMerchandiseNumbers( purchaseIds, storageUnitId5, map12_quantity_10 );
245:     }
246: 
247: 
248: 
249:     private void checkMerchandiseNumbers( Set<UUID> purchaseIds, UUID storageUnitId, Map<UUID, Integer> expectedMap ) {
250:         UUID fittingPurchaseId = null;
251:         for ( UUID purchaseId : purchaseIds ) {
252:             UUID foundStorageUnitId = purchaseUseCases.getStorageUnitIdForPurchase( purchaseId );
253:             if ( foundStorageUnitId.equals( storageUnitId ) ) {
254:                 fittingPurchaseId = purchaseId;
255:                 break;
256:             }
257:         }
258:         assertNotNull( fittingPurchaseId, "No fitting purchase found for storage unit " + storageUnitId );
259: 
260:         int totalExpected = 0;
261:         int totalActual = 0;
262:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
263:             totalExpected += entry.getValue();
264:         }
265:         log.info( "Check purchase numbers for merchandise {} in storage unit {}", fittingPurchaseId, storageUnitId );
266:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
267:             UUID merchandiseId = entry.getKey();
268:             Integer foundNumber =
269:                     purchaseUseCases.getPurchaseQuantOfMerchandise( fittingPurchaseId, merchandiseId );
270:             assertEquals( entry.getValue(), foundNumber );
271:             totalActual += foundNumber;
272:         }
273:         // last check - do the total sums match?
274:         assertEquals( totalExpected, totalActual );
275:     }
276: 
277: 
278:     private void checkStorageUnitIds( Set<UUID> purchaseIds, UUID... expectedStorageUnitIds ) {
279:         assertEquals( expectedStorageUnitIds.length, purchaseIds.size() );
280:         Set<UUID> foundStorageUnitIds = new HashSet<>();
281:         for ( UUID purchaseId : purchaseIds ) {
282:             UUID storageUnitId = purchaseUseCases.getStorageUnitIdForPurchase( purchaseId );
283:             foundStorageUnitIds.add( storageUnitId );
284:         }
285:         for ( UUID expectedStorageUnitId : expectedStorageUnitIds ) {
286:             assertTrue( foundStorageUnitIds.contains( expectedStorageUnitId ) );
287:         }
288:     }
289: 
290: }
291: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\ShoppingCartRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingcart;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.ResultMatcher;
12: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
13: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
14: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
15: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
17: import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
18: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
19: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
20: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
21: 
22: import java.util.HashMap;
23: import java.util.Map;
24: import java.util.UUID;
25: 
26: import static org.junit.jupiter.api.Assertions.assertEquals;
27: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
28: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
29: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMailAddress;
30: 
31: 
32: @SpringBootTest
33: @Transactional
34: @AutoConfigureMockMvc
35: @Import( RESTTestHelperConfiguration.class )
36: public class ShoppingCartRESTTest {
37:     @Autowired
38:     private StorageUnitUseCases storageUnitUseCases;
39:     @Autowired
40:     private ShoppingCartUseCases shoppingCartUseCases;
41:     @Autowired
42:     private Purgatory purgatory;
43:     @Autowired
44:     private CustomerTestHelper customerTestHelper;
45:     @Autowired
46:     private MerchandiseTestHelper merchandiseTestHelper;
47:     @Autowired
48:     private StorageUnitTestHelper storageUnitTestHelper;
49:     @Autowired
50:     private MockMvc mockMvc;
51:     @Autowired
52:     private ShoppingCartRESTHelper shoppingCartRESTHelper;
53: 
54:     private MailAddressType nonExistingMailAddress;
55:     private final Map<UUID, Integer> emptyMap = new HashMap<>();
56: 
57:     private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
58:     private MailAddressType
59:             customerMailAddress0,
60:             customerMailAddress3,
61:             customerMailAddress6,
62:             customerMailAddress8;
63:     private String customerName0, customerName8;
64:     private UUID merchandiseId0, merchandiseId1, merchandiseId2, merchandiseId3, merchandiseId5,
65:                  merchandiseId7, merchandiseId9, merchandiseId11, nonExistentMerchandiseId;
66:     private UUID storageUnitId0, storageUnitId3, storageUnitId7, storageUnitId8;
67: 
68: 
69:     private static final ResultMatcher NOT_FOUND = status().isNotFound();
70:     private static final ResultMatcher OK = status().isOk();
71:     private static final ResultMatcher CREATED = status().isCreated();
72:     private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
73:     private static final ResultMatcher CONFLICT = status().isConflict();
74: 
75:     @BeforeEach
76:     public void setUp() {
77:         purgatory.deleteEverything();
78:         customerTestHelper.registerAllCustomers();
79:         merchandiseTestHelper.addAllMerchandises();
80:         storageUnitTestHelper.addAllStorageUnits( true );
81:         nonExistingMailAddress = instantiateMailAddress( "harry@sally.de" );
82: 
83:         customerMailAddress0 = customerTestHelper.getCustomerMailAddress( 0 );
84:         customerMailAddress3 = customerTestHelper.getCustomerMailAddress( 3 );
85:         customerMailAddress6 = customerTestHelper.getCustomerMailAddress( 6 );
86:         customerMailAddress8 = customerTestHelper.getCustomerMailAddress( 8 );
87:         customerName0 = customerTestHelper.getCustomerName( 0 );
88:         customerName8 = customerTestHelper.getCustomerName( 8 );
89: 
90:         merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 );
91:         merchandiseId1 = merchandiseTestHelper.getMerchandiseId( 1 );
92:         merchandiseId2 = merchandiseTestHelper.getMerchandiseId( 2 );
93:         merchandiseId3 = merchandiseTestHelper.getMerchandiseId( 3 );
94:         merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 );
95:         merchandiseId7 = merchandiseTestHelper.getMerchandiseId( 7 );
96:         merchandiseId9 = merchandiseTestHelper.getMerchandiseId( 9 );
97:         merchandiseId11 = merchandiseTestHelper.getMerchandiseId( 11 );
98:         nonExistentMerchandiseId = UUID.randomUUID();
99: 
100:         storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
101:         storageUnitId3 = storageUnitTestHelper.getStorageUnitId( 3 );
102:         storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );
103:         storageUnitId8 = storageUnitTestHelper.getStorageUnitId( 8 );
104: 
105:         map9_quantity_1 = new HashMap<>() {{
106:             put( merchandiseId9, 1 );
107:         }};
108:         map5_quantity_2 = new HashMap<>() {{
109:             put( merchandiseId5, 2 );
110:         }};
111:         map7_quantity_7 = new HashMap<>() {{
112:             put( merchandiseId7, 7 );
113:         }};
114:         map9_11_quantity_2_2 = new HashMap<>() {{
115:             put( merchandiseId9, 2 );
116:             put( merchandiseId11, 2 );
117:         }};
118:     }
119: 
120: 
121:     @Test
122:     public void testInvalidShoppingCartBaseUris() throws Exception {
123:         // given
124:         String allShoppingCartsUri = "/shoppingCarts";
125:         String randomIdUri = "/shoppingCarts/" + UUID.randomUUID();
126:         String randomCustomerUUID = "/shoppingCarts?customerId=" + UUID.randomUUID();
127:         String invalidCustomerUUID = "/shoppingCarts?customerId=invalidUUID";
128:         String randomParamUri = "/shoppingCarts?randomParam=randomValue";
129: 
130:         // when
131:         // then
132:         mockMvc.perform( get( allShoppingCartsUri ) ).andExpect( status().isMethodNotAllowed() );
133:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
134:         mockMvc.perform( get( randomCustomerUUID ) ).andExpect( status().isNotFound() );
135:         mockMvc.perform( get( invalidCustomerUUID ) ).andExpect( status().isNotFound() );
136:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
137:     }
138: 
139: 
140:     @Test
141:     public void testInvalidPositionUris() throws Exception {
142:         // given
143:         UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress8, emptyMap );
144:         String randomPositionUri = "/shoppingCarts/" + shoppingCartId8.toString() + "/random";
145:         String randomMerchandiseUri = "/shoppingCarts/" + shoppingCartId8.toString()
146:                 + "/positions/" + UUID.randomUUID();
147: 
148:         // when
149:         // then
150:         mockMvc.perform( post( randomPositionUri ) ).andExpect( status().isNotFound() );
151:         mockMvc.perform( delete( randomMerchandiseUri ) ).andExpect( status().isNotFound() );
152:     }
153: 
154: 
155:     @Test
156:     public void testInvalidAddToShoppingCart() throws Exception {
157:         // given
158:         Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
159:         expectedStartQuantityMap.put( merchandiseId2, 19 );
160: 
161:         // when
162:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress0, emptyMap );
163:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId, merchandiseId2, 6 );
164:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId, merchandiseId2, 13 );
165: 
166:         // then
167:         shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress0, expectedStartQuantityMap );
168: 
169:         // ... and check a couple of invalid cases
170:         shoppingCartRESTHelper.addMerchandiseToShoppingCart(
171:                 shoppingCartId, nonExistentMerchandiseId, 12, NOT_FOUND );
172:         shoppingCartRESTHelper.addMerchandiseToShoppingCart(
173:                 UUID.randomUUID(), merchandiseId5, 12, NOT_FOUND );
174:         shoppingCartRESTHelper.addMerchandiseToShoppingCart(
175:                 shoppingCartId, merchandiseId5, -1, UNPROCESSABLE_ENTITY );
176: 
177:         // check if the shopping cart is still the same
178:         shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress0, expectedStartQuantityMap );
179:     }
180: 
181: 
182:     @Test
183:     public void testInvalidCheckout_unavailableMerchandise() throws Exception {
184:         // given
185:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress0, emptyMap );
186: 
187:         // when
188:         // productId0 is not available in the requested quantity (or rather, not at all)
189:         shoppingCartRESTHelper.addMerchandiseToShoppingCart(
190:                 shoppingCartId, merchandiseId0, 1, CREATED );
191: 
192:         // check if the shopping cart is still the same
193:         shoppingCartRESTHelper.checkout( shoppingCartId, null, CONFLICT, null );
194:     }
195: 
196: 
197:     @Test
198:     public void testInvalidCheckout_tooLittleInventory() throws Exception {
199:         // given
200:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress0, emptyMap );
201: 
202:         // when
203:         // There are only 10 pieces of productId1 available
204:         shoppingCartRESTHelper.addMerchandiseToShoppingCart(
205:                 shoppingCartId, merchandiseId1, 11, CREATED );
206: 
207:         // check if the shopping cart is still the same
208:         shoppingCartRESTHelper.checkout( shoppingCartId, null, CONFLICT, null );
209:     }
210: 
211: 
212: 
213:     @Test
214:     public void testDeleteMerchandiseFromShoppingCart() throws Exception {
215:         // given
216:         UUID shoppingCartId6 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, emptyMap );
217:         Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
218:         expectedQuantityMap1.put( merchandiseId1, 1 );
219:         expectedQuantityMap1.put( merchandiseId2, 2 );
220:         expectedQuantityMap1.put( merchandiseId3, 3 );
221:         Map<UUID, Integer> quantityMap2 = new HashMap<>();
222:         quantityMap2.put( merchandiseId1, 1 );
223:         quantityMap2.put( merchandiseId3, 3 );
224: 
225:         // when
226:         // then
227:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId6, merchandiseId1, 1 );
228:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId6, merchandiseId2, 2 );
229:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId6, merchandiseId3, 3 );
230:         shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, expectedQuantityMap1 );
231: 
232:         shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart( shoppingCartId6, merchandiseId2 );
233:         shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, quantityMap2 );
234:     }
235: 
236: 
237:     @Test
238:     public void testNoDoubleDelete() throws Exception {
239:         // given
240:         UUID shoppingCartId6 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, emptyMap );
241: 
242:         // when
243:         // then
244:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId6, merchandiseId3, 3 );
245:         shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart( shoppingCartId6, merchandiseId3 );
246:         shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, new HashMap<>() );
247:         shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart( shoppingCartId6, merchandiseId3, NOT_FOUND );
248:     }
249: 
250: 
251:     @Test
252:     public void testAddRemoveMerchandisesFromAndToShoppingCart() throws Exception {
253:         // given
254:         UUID shoppingCartId3 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress3, emptyMap );
255:         UUID shoppingCartId5 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, emptyMap );
256: 
257:         // when
258:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId3, merchandiseId1, 2 );
259:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId3, merchandiseId2, 3 );
260:         shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart( shoppingCartId3, merchandiseId1 );
261:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId3, merchandiseId1, 1 );
262:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId3, merchandiseId2, 6 );
263: 
264:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId5, merchandiseId1, 2 );
265:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId5, merchandiseId2, 8 );
266:         shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart( shoppingCartId5, merchandiseId1 );
267:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId5, merchandiseId1, 1 );
268:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId5, merchandiseId2, 2 );
269: 
270:         // then
271:         // customer3 has 1x merchandiseId1 and 9x merchandiseId2 expected in cart
272:         Map<UUID, Integer> expectedMap3 = new HashMap<>();
273:         expectedMap3.put( merchandiseId1, 1 );
274:         expectedMap3.put( merchandiseId2, 9 );
275:         shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress3, expectedMap3 );
276: 
277:         // customer6 has 1x merchandiseId1 and 10x merchandiseId2 in cart
278:         Map<UUID, Integer> expectedMap5 = new HashMap<>();
279:         expectedMap5.put( merchandiseId1, 1 );
280:         expectedMap5.put( merchandiseId2, 10 );
281:         shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, expectedMap5 );
282:     }
283: 
284: 
285:     @Test
286:     public void testNoDoubleCheckout() throws Exception {
287:         // given
288:         UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress8, emptyMap );
289: 
290:         // when
291:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId8, merchandiseId2, 3 );
292: 
293:         // then
294:         shoppingCartRESTHelper.checkout( shoppingCartId8, customerName8, CREATED, null );
295:         shoppingCartRESTHelper.checkout( shoppingCartId8, null, CONFLICT, null );
296:     }
297: 
298: 
299:     @Test
300:     public void testCheckout_1_Purchase() throws Exception {
301:         // given:
302:         // Customer 0 wants to buy 1x merchandise 9. This is in storage unit 5, 7, and 8. Out of these,
303:         // storage unit 8 with zip code 89250 is closest to customer 0 with zip code 02314.
304:         Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>() {{
305:             put( storageUnitId8, map9_quantity_1 );
306:         }};
307:         UUID shoppingCartId0 = shoppingCartRESTHelper.getQueryShoppingCart(
308:                 customerMailAddress0, null );
309:         int inventory9before =
310:                 storageUnitUseCases.getAvailableInventory( storageUnitId8, merchandiseId9 );
311: 
312:         // when
313:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId0, merchandiseId9, 1  );
314:         shoppingCartRESTHelper.checkout( shoppingCartId0, customerName0, CREATED, expectedPurchases );
315:         int inventory9after =
316:                 storageUnitUseCases.getAvailableInventory( storageUnitId8, merchandiseId9 );
317: 
318:         // then
319:         assertEquals( 1, inventory9before - inventory9after );
320:     }
321: 
322:     @Test
323:     public void testCheckout_3_Purchase() throws Exception {
324:         // given:
325:         // Customer 8 (Felix Bauer) wants to buy 2x each of merchandises 5, 9, 11; and 7x merchandise 7.
326:         //       - merchandises 9 and 11 can both be found in storage units 7 and 8. Storage units 7 (76532) is closer to
327:         //         the customer (70173)
328:         //       - merchandise 7 is available in storage units 1, 2, and 3, but only storage unit 3 has enough inventory.
329:         //       - merchandise 5 is only available in storage unit 0.
330:         Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>() {{
331:             put( storageUnitId0, map5_quantity_2 );
332:             put( storageUnitId3, map7_quantity_7 );
333:             put( storageUnitId7, map9_11_quantity_2_2 );
334:         }};
335:         UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart(
336:                 customerMailAddress8, null );
337:         int inventory5before =
338:                 storageUnitUseCases.getAvailableInventory( storageUnitId0, merchandiseId5 );
339:         int inventory7before =
340:                 storageUnitUseCases.getAvailableInventory( storageUnitId3, merchandiseId7 );
341:         int inventory9before =
342:                 storageUnitUseCases.getAvailableInventory( storageUnitId7, merchandiseId9 );
343:         int inventory11before =
344:                 storageUnitUseCases.getAvailableInventory( storageUnitId7, merchandiseId11 );
345: 
346:         // when
347:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId8, merchandiseId5, 2 );
348:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId8, merchandiseId7, 7 );
349:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId8, merchandiseId9, 2 );
350:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId8, merchandiseId11, 2 );
351:         shoppingCartRESTHelper.checkout( shoppingCartId8, customerName8, CREATED, expectedPurchases );
352:         int inventory5after =
353:                 storageUnitUseCases.getAvailableInventory( storageUnitId0, merchandiseId5 );
354:         int inventory7after =
355:                 storageUnitUseCases.getAvailableInventory( storageUnitId3, merchandiseId7 );
356:         int inventory9after =
357:                 storageUnitUseCases.getAvailableInventory( storageUnitId7, merchandiseId9 );
358:         int inventory11after =
359:                 storageUnitUseCases.getAvailableInventory( storageUnitId7, merchandiseId11 );
360: 
361:         // then
362:         assertEquals( 2, inventory5before - inventory5after );
363:         assertEquals( 7, inventory7before - inventory7after );
364:         assertEquals( 2, inventory9before - inventory9after );
365:         assertEquals( 2, inventory11before - inventory11after );
366:     }
367: 
368: 
369: }
370: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\ShoppingCartTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingcart;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.InsufficientInventoryException;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
12: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
13: import thkoeln.archilab.ecommerce.usecases.*;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
16: 
17: 
18: import java.util.Map;
19: import java.util.UUID;
20: 
21: import static org.junit.jupiter.api.Assertions.*;
22: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
23: 
24: @SpringBootTest
25: public class ShoppingCartTest {
26:     @Autowired
27:     private CustomerRegistrationUseCases customerRegistrationUseCases;
28:     @Autowired
29:     private ShoppingCartUseCases shoppingCartUseCases;
30:     @Autowired
31:     private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
32:     @Autowired
33:     private StorageUnitUseCases storageUnitUseCases;
34:     @Autowired
35:     private PurchaseUseCases purchaseUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private CustomerTestHelper customerTestHelper;
40:     @Autowired
41:     private MerchandiseTestHelper merchandiseTestHelper;
42:     @Autowired
43:     private StorageUnitTestHelper storageUnitTestHelper;
44: 
45:     private MailAddressType nonExistingMailAddress;
46: 
47:     @BeforeEach
48:     public void setUp() {
49:         purgatory.deleteEverything();
50:         customerTestHelper.registerAllCustomers();
51:         merchandiseTestHelper.addAllMerchandises();
52: 
53:         nonExistingMailAddress = instantiateMailAddress( "this@nononono.de" );
54:     }
55: 
56: 
57:     @Test
58:     public void testInvalidAddToShoppingCart() {
59:         // given
60:         UUID nonExistentMerchandiseId = UUID.randomUUID();
61:         UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 );
62:         UUID merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 );
63:         MailAddressType customerMailAddress0 =
64:                 customerTestHelper.getCustomerMailAddress( 0 );
65:         storageUnitTestHelper.addAllStorageUnits( true );
66: 
67:         // then
68:         assertThrows( ShopException.class,
69:                 () -> shoppingCartUseCases.addMerchandiseToShoppingCart(
70:                         nonExistingMailAddress, merchandiseId0, 1 ) );
71:         assertThrows( ShopException.class,
72:                 () -> shoppingCartUseCases.addMerchandiseToShoppingCart(
73:                         null, merchandiseId0, 1 ) );
74:         assertThrows( ShopException.class,
75:                 () -> shoppingCartUseCases.addMerchandiseToShoppingCart(
76:                         customerMailAddress0, nonExistentMerchandiseId, 1 ) );
77:         assertThrows( ShopException.class,
78:                 () -> shoppingCartUseCases.addMerchandiseToShoppingCart(
79:                         customerMailAddress0, null, 1 ) );
80:         assertThrows( ShopException.class,
81:                 () -> shoppingCartUseCases.addMerchandiseToShoppingCart(
82:                         customerMailAddress0, merchandiseId5, -1 ) );
83:     }
84: 
85: 
86:     @Test
87:     public void testInvalidRemoveFromShoppingCart() {
88:         // given
89:         UUID nonExistentMerchandiseId = UUID.randomUUID();
90:         UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 );
91:         UUID merchandiseId1 = merchandiseTestHelper.getMerchandiseId( 1 );
92:         UUID merchandiseId2 = merchandiseTestHelper.getMerchandiseId( 2 );
93:         storageUnitTestHelper.addAllStorageUnits( true );
94:         MailAddressType customerMailAddress0 =
95:                 customerTestHelper.getCustomerMailAddress( 0 );
96:         shoppingCartUseCases.addMerchandiseToShoppingCart(
97:                 customerMailAddress0, merchandiseId1, 5 );
98:         shoppingCartUseCases.addMerchandiseToShoppingCart(
99:                 customerMailAddress0, merchandiseId2, 15 );
100: 
101:         // when
102:         shoppingCartUseCases.removeMerchandiseFromShoppingCart(
103:                 customerMailAddress0, merchandiseId1, 2 );
104:         shoppingCartUseCases.removeMerchandiseFromShoppingCart(
105:                 customerMailAddress0, merchandiseId2, 4 );
106:         shoppingCartUseCases.removeMerchandiseFromShoppingCart(
107:                 customerMailAddress0, merchandiseId2, 7 );
108:         // now we should have 3x merchandiseId1 and 4x merchandiseId2 in the shopping cart
109: 
110:         // then
111:         assertThrows( ShopException.class,
112:                 () -> shoppingCartUseCases.removeMerchandiseFromShoppingCart(
113:                         customerMailAddress0, nonExistentMerchandiseId, 12 ) );
114:         assertThrows( ShopException.class,
115:                 () -> shoppingCartUseCases.removeMerchandiseFromShoppingCart(
116:                         nonExistingMailAddress, merchandiseId5, 12 ) );
117:         assertThrows( ShopException.class,
118:                 () -> shoppingCartUseCases.removeMerchandiseFromShoppingCart(
119:                         customerMailAddress0, merchandiseId5, -1 ) );
120:         assertThrows( ShopException.class,
121:                 () -> shoppingCartUseCases.removeMerchandiseFromShoppingCart(
122:                         customerMailAddress0, merchandiseId1, 4 ) );
123:         assertThrows( ShopException.class,
124:                 () -> shoppingCartUseCases.removeMerchandiseFromShoppingCart(
125:                         customerMailAddress0, merchandiseId2, 5 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testAddRemoveMerchandisesFromAndToShoppingCart() {
131:         // given
132:         UUID merchandiseId1 = merchandiseTestHelper.getMerchandiseId( 1 );
133:         UUID merchandiseId2 = merchandiseTestHelper.getMerchandiseId( 2 );
134:         MailAddressType customerMailAddress3 =
135:                 customerTestHelper.getCustomerMailAddress( 3 );
136:         MailAddressType customerMailAddress5 =
137:                 customerTestHelper.getCustomerMailAddress( 5 );
138: 
139:         // when customer 3 ...
140:         shoppingCartUseCases.addMerchandiseToShoppingCart(
141:                 customerMailAddress3, merchandiseId1, 2 );
142:         shoppingCartUseCases.addMerchandiseToShoppingCart(
143:                 customerMailAddress3, merchandiseId2, 3 );
144:         shoppingCartUseCases.removeMerchandiseFromShoppingCart(
145:                 customerMailAddress3, merchandiseId1, 2 );
146:         shoppingCartUseCases.addMerchandiseToShoppingCart(
147:                 customerMailAddress3, merchandiseId1, 1 );
148:         shoppingCartUseCases.addMerchandiseToShoppingCart(
149:                 customerMailAddress3, merchandiseId2, 6 );
150:         Map<UUID, Integer> cart3 = shoppingCartUseCases.getShoppingCartAsMap( customerMailAddress3 );
151:         // customer3 has 1x merchandiseId1 and 9x merchandiseId2 in cart
152: 
153:         // ... and when customer 5 ...
154:         shoppingCartUseCases.addMerchandiseToShoppingCart(
155:                 customerMailAddress5, merchandiseId1, 2 );
156:         shoppingCartUseCases.addMerchandiseToShoppingCart(
157:                 customerMailAddress5, merchandiseId2, 8 );
158:         shoppingCartUseCases.removeMerchandiseFromShoppingCart(
159:                 customerMailAddress5, merchandiseId1, 1 );
160:         shoppingCartUseCases.addMerchandiseToShoppingCart(
161:                 customerMailAddress5, merchandiseId2, 2 );
162:         Map<UUID, Integer> cart5 = shoppingCartUseCases.getShoppingCartAsMap( customerMailAddress5 );
163:         // customer5 has 1x merchandiseId1 and 10x merchandiseId2 in cart
164: 
165:         // then
166:         assertEquals( 2, cart3.size() );
167:         assertEquals( 1, cart3.get( merchandiseId1 ) );
168:         assertEquals( 9, cart3.get( merchandiseId2 ) );
169: 
170:         assertEquals( 2, cart5.size() );
171:         assertEquals( 1, cart5.get( merchandiseId1 ) );
172:         assertEquals( 10, cart5.get( merchandiseId2 ) );
173:     }
174: 
175: 
176:     @Test
177:     public void testShoppingCartValue() {
178:         // given
179:         UUID merchandiseId3 = merchandiseTestHelper.getMerchandiseId( 3 );
180:         UUID merchandiseId6 = merchandiseTestHelper.getMerchandiseId( 6 );
181:         UUID merchandiseId8 = merchandiseTestHelper.getMerchandiseId( 8 );
182:         MoneyType price3 = merchandiseTestHelper.getSalesPrice( 3 );
183:         MoneyType price6 = merchandiseTestHelper.getSalesPrice( 6 );
184:         MoneyType price8 = merchandiseTestHelper.getSalesPrice( 8 );
185:         MailAddressType customerMailAddress3 =
186:                 customerTestHelper.getCustomerMailAddress( 3 );
187: 
188:         // when
189:         shoppingCartUseCases.addMerchandiseToShoppingCart( customerMailAddress3, merchandiseId3, 3 );
190:         shoppingCartUseCases.addMerchandiseToShoppingCart( customerMailAddress3, merchandiseId6, 2 );
191:         shoppingCartUseCases.addMerchandiseToShoppingCart( customerMailAddress3, merchandiseId8, 5 );
192:         // customer3 has 3x merchandiseId3, 2x merchandiseId6 and 5x merchandiseId8 in cart
193:         MoneyType cartValue = shoppingCartUseCases.getShoppingCartAsMoneyValue( customerMailAddress3 );
194: 
195:         // then
196:         assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
197:                 cartValue );
198:     }
199: 
200: 
201:     @Test
202:     public void testShoppingCartValueInvalid() {
203:         // given
204:         // when
205:         // then
206:         assertThrows( ShopException.class,
207:                 () -> shoppingCartUseCases.getShoppingCartAsMoneyValue( nonExistingMailAddress ) );
208:     }
209: 
210: 
211:     @Test
212:     public void testUnsuccessfulCheckout() {
213:         // given customer buying merchandise 0 (which is not in inventory), and customer 1 buying merchandise 1
214:         // in a bigger quantity (11) than available (10)
215:         storageUnitTestHelper.addAllStorageUnits( true );
216:         MailAddressType customerMailAddress0 =
217:                 customerTestHelper.getCustomerMailAddress( 0 );
218:         MailAddressType customerMailAddress1 =
219:                 customerTestHelper.getCustomerMailAddress( 1 );
220:         UUID merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 );
221:         UUID merchandiseId1 = merchandiseTestHelper.getMerchandiseId( 1 );
222: 
223:         // when
224:         shoppingCartUseCases.addMerchandiseToShoppingCart(
225:                 customerMailAddress0, merchandiseId0, 1 );
226:         shoppingCartUseCases.addMerchandiseToShoppingCart(
227:                 customerMailAddress1, merchandiseId1, 11 );
228: 
229:         // then
230:         assertThrows( InsufficientInventoryException.class,
231:                 () -> shoppingCartUseCases.checkout( customerMailAddress0 ) );
232:         assertThrows( InsufficientInventoryException.class,
233:                 () -> shoppingCartUseCases.checkout( customerMailAddress1 ) );
234:     }
235: 
236: }
237: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\storageunit\StorageUnitManagementTest.java ---
1: package thkoeln.archilab.ecommerce.tests.storageunit;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
12: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
14: 
15: import java.util.UUID;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
19: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateAddress;
20: 
21: 
22: /**
23:  * This test checks the management and lifecycle of storage units.
24:  */
25: @SpringBootTest
26: public class StorageUnitManagementTest {
27:     @Autowired
28:     private StorageUnitUseCases storageUnitUseCases;
29:     @Autowired
30:     private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private MerchandiseTestHelper merchandiseTestHelper;
35:     @Autowired
36:     private StorageUnitTestHelper storageUnitTestHelper;
37: 
38:     private AddressType someAddress;
39:     private UUID nonExistingId1;
40:     private UUID nonExistingId2;
41: 
42: 
43:     @BeforeEach
44:     public void setUp() {
45:         purgatory.deleteEverything();
46:         merchandiseTestHelper.addAllMerchandises();
47: 
48:         someAddress = instantiateAddress( "Some Street", "Some City",
49:                 instantiateZipCode( "90001" ) );
50:         nonExistingId1 = UUID.randomUUID();
51:         nonExistingId2 = UUID.randomUUID();
52:     }
53: 
54: 
55:     @Test
56:     public void testAddInvalidStorageUnit() {
57:         // given
58:         String name = "Lager1";
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class,
63:                 () -> storageUnitUseCases.addNewStorageUnit(
64:                         null, someAddress ) );
65:         assertThrows( ShopException.class,
66:                 () -> storageUnitUseCases.addNewStorageUnit(
67:                         "", someAddress ) );
68:         assertThrows( ShopException.class,
69:                 () -> storageUnitUseCases.addNewStorageUnit(
70:                         name, null ) );
71:     }
72: 
73: 
74:     @Test
75:     public void testDeleteAllStorageUnitsWhenEmpty() {
76:         // given
77:         storageUnitTestHelper.addAllStorageUnits( false );
78:         UUID merchandiseId9 = merchandiseTestHelper.getMerchandiseId( 9 );
79:         UUID storageUnitId1 = storageUnitTestHelper.getStorageUnitId( 1 );
80:         UUID storageUnitId2 = storageUnitTestHelper.getStorageUnitId( 2 );
81: 
82:         // when
83:         int numOf1 = storageUnitUseCases.getAvailableInventory( storageUnitId1, merchandiseId9 );
84:         int numOf2 = storageUnitUseCases.getAvailableInventory( storageUnitId2, merchandiseId9 );
85: 
86:         // then
87:         assertEquals( 0, numOf1 );
88:         assertEquals( 0, numOf2 );
89:         storageUnitUseCases.deleteAllStorageUnits();
90:         // ... ids must be invalid now
91:         assertThrows( ShopException.class,
92:                 () -> storageUnitUseCases.getAvailableInventory( storageUnitId1, merchandiseId9 ) );
93:         assertThrows( ShopException.class,
94:                 () -> storageUnitUseCases.getAvailableInventory( storageUnitId2, merchandiseId9 ) );
95:     }
96: 
97: 
98:     @Test
99:     public void testDeleteAllStorageUnitsWhenFull() {
100:         // given
101:         storageUnitTestHelper.addAllStorageUnits( true );
102:         UUID merchandiseId7 = merchandiseTestHelper.getMerchandiseId( 7 );
103:         UUID storageUnitId1 = storageUnitTestHelper.getStorageUnitId( 1 );
104:         UUID storageUnitId2 = storageUnitTestHelper.getStorageUnitId( 2 );
105: 
106:         // when
107:         int numOf1 = storageUnitUseCases.getAvailableInventory( storageUnitId1, merchandiseId7 );
108:         int numOf2 = storageUnitUseCases.getAvailableInventory( storageUnitId2, merchandiseId7 );
109: 
110:         // then
111:         assertTrue( numOf1 == 3 );
112:         assertTrue( numOf2 == 3 );
113:         storageUnitUseCases.deleteAllStorageUnits();
114:         // ... ids must be invalid now
115:         assertThrows( ShopException.class,
116:                 () -> storageUnitUseCases.getAvailableInventory( storageUnitId1, merchandiseId7 ) );
117:         assertThrows( ShopException.class,
118:                 () -> storageUnitUseCases.getAvailableInventory( storageUnitId2, merchandiseId7 ) );
119:     }
120: 
121: 
122: 
123:     @Test
124:     public void testAddToInventory() {
125:         // given
126:         storageUnitTestHelper.addAllStorageUnits( true );
127:         UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 ); // random >30 in storage unit 0
128:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
129:         int originalInventory5 =
130:                 storageUnitTestHelper.getStorageUnitInventory( 0, 5 );
131: 
132:         // when
133:         int inventory5before = storageUnitUseCases.getAvailableInventory( storageUnitId0, merchandiseId5 );
134:         storageUnitUseCases.addToInventory( storageUnitId0, merchandiseId5, 23 );
135:         int inventory5after = storageUnitUseCases.getAvailableInventory( storageUnitId0, merchandiseId5 );
136:         storageUnitUseCases.addToInventory( storageUnitId0, merchandiseId5, 0 );
137:         int inventory5after2 = storageUnitUseCases.getAvailableInventory( storageUnitId0, merchandiseId5 );
138: 
139:         // then
140:         assertEquals( originalInventory5, inventory5before );
141:         assertEquals( inventory5before + 23, inventory5after );
142:         assertEquals( inventory5after, inventory5after2 );
143:     }
144: 
145: 
146:     @Test
147:     public void testInvalidAddToInventory() {
148:         // given
149:         storageUnitTestHelper.addAllStorageUnits( true );
150:         UUID merchandiseId2 = merchandiseTestHelper.getMerchandiseId( 2 );
151:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
152: 
153:         // when
154:         // then
155:         assertThrows( ShopException.class,
156:                 () -> storageUnitUseCases.addToInventory( nonExistingId1, nonExistingId2, 12 ) );
157:         assertThrows( ShopException.class,
158:                 () -> storageUnitUseCases.addToInventory(
159:                         storageUnitId0, nonExistingId2, 12 ) );
160:         assertThrows( ShopException.class,
161:                 () -> storageUnitUseCases.addToInventory(
162:                         nonExistingId1, merchandiseId2, 12 ) );
163:         assertThrows( ShopException.class,
164:                 () -> storageUnitUseCases.addToInventory(
165:                         storageUnitId0, merchandiseId2, -1 ) );
166:     }
167: 
168: 
169:     @Test
170:     public void testRemoveFromInventory() {
171:         // given
172:         storageUnitTestHelper.addAllStorageUnits( true );
173:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
174:         UUID merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 ); // 0 in storage unit 0
175:         UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 ); // random >30 in storage unit 0
176:         UUID merchandiseId6 = merchandiseTestHelper.getMerchandiseId( 6 ); // random >30 in storage unit 0
177:         int inventory0before =
178:                 storageUnitTestHelper.getStorageUnitInventory( 0, 0 );
179:         int inventory5before =
180:                 storageUnitTestHelper.getStorageUnitInventory( 0, 5 );
181:         int inventory6before =
182:                 storageUnitTestHelper.getStorageUnitInventory( 0, 6 );
183: 
184:         // when
185:         storageUnitUseCases.removeFromInventory( storageUnitId0, merchandiseId5, 1 );
186:         int inventory5after = storageUnitUseCases.getAvailableInventory( storageUnitId0, merchandiseId5 );
187:         storageUnitUseCases.removeFromInventory( storageUnitId0, merchandiseId0, 0 );
188:         int inventory0after = storageUnitUseCases.getAvailableInventory( storageUnitId0, merchandiseId0 );
189:         storageUnitUseCases.removeFromInventory(
190:                 storageUnitId0, merchandiseId6, inventory6before );
191:         int inventory6after = storageUnitUseCases.getAvailableInventory( storageUnitId0, merchandiseId6 );
192: 
193:         // then
194:         assertEquals( inventory5before - 1, inventory5after );
195:         assertEquals( inventory0before, inventory0after );
196:         assertEquals( 0, inventory6after );
197:     }
198: 
199: 
200:     @Test
201:     public void testInvalidRemoveFromInventory() {
202:         // given
203:         storageUnitTestHelper.addAllStorageUnits( true );
204:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
205:         UUID merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 ); // 0 in storage unit 0
206:         UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 ); // random >30 in storage unit 0
207:         int inventory5before =
208:                 storageUnitTestHelper.getStorageUnitInventory( 0, 5 );
209: 
210:         // when
211:         // then
212:         assertThrows( ShopException.class,
213:                 () -> storageUnitUseCases.removeFromInventory( nonExistingId1, nonExistingId2, 12 ) );
214:         assertThrows( ShopException.class,
215:                 () -> storageUnitUseCases.removeFromInventory(
216:                         storageUnitId0, nonExistingId2, 12 ) );
217:         assertThrows( ShopException.class,
218:                 () -> storageUnitUseCases.removeFromInventory(
219:                         nonExistingId1, merchandiseId5, 12 ) );
220:         assertThrows( ShopException.class,
221:                 () -> storageUnitUseCases.removeFromInventory(
222:                         storageUnitId0, merchandiseId5, -1 ) );
223:         assertThrows( ShopException.class,
224:                 () -> storageUnitUseCases.removeFromInventory(
225:                         storageUnitId0, merchandiseId5, inventory5before + 1 ) );
226:         assertThrows( ShopException.class,
227:                 () -> storageUnitUseCases.removeFromInventory(
228:                         storageUnitId0, merchandiseId0, 1 ) ); // already 0 in storage unit 0
229:     }
230: 
231: 
232:     @Test
233:     public void testChangeInventory() {
234:         // given
235:         storageUnitTestHelper.addAllStorageUnits( true );
236:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
237:         UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 ); // random >30 in storage unit 0
238: 
239:         // when
240:         storageUnitUseCases.changeInventoryTo( storageUnitId0, merchandiseId5, 111 );
241:         int inventory5after = storageUnitUseCases.getAvailableInventory( storageUnitId0, merchandiseId5 );
242: 
243:         // then
244:         assertEquals( 111, inventory5after );
245:     }
246: 
247: 
248:     @Test
249:     public void testInvalidChangeInventory() {
250:         // given
251:         storageUnitTestHelper.addAllStorageUnits( true );
252:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
253:         UUID merchandiseId6 = merchandiseTestHelper.getMerchandiseId( 6 );
254: 
255:         // when
256:         // then
257:         assertThrows( ShopException.class, () -> storageUnitUseCases.changeInventoryTo(
258:                 nonExistingId1, nonExistingId2, 12 ) );
259:         assertThrows( ShopException.class, () -> storageUnitUseCases.changeInventoryTo(
260:                 nonExistingId1, merchandiseId6, 12 ) );
261:         assertThrows( ShopException.class, () -> storageUnitUseCases.changeInventoryTo(
262:                 storageUnitId0, nonExistingId2, 12 ) );
263:         assertThrows( ShopException.class, () -> storageUnitUseCases.changeInventoryTo(
264:                 storageUnitId0, merchandiseId6, -1 ) );
265:     }
266: 
267: 
268:     @Test
269:     public void testEmptyStorageUnit() {
270:         // given
271:         storageUnitTestHelper.addAllStorageUnits( true );
272:         UUID storageUnitId9 = storageUnitTestHelper.getStorageUnitId( 9 ); // empty storage unit
273: 
274:         // when
275:         int totalInventory = 0;
276:         for ( int iMerchandise = 0; iMerchandise < merchandiseTestHelper.numberOfMerchandises(); iMerchandise++ ) {
277:             UUID merchandiseId = merchandiseTestHelper.getMerchandiseId( iMerchandise );
278:             totalInventory += storageUnitUseCases.getAvailableInventory(
279:                     storageUnitId9, merchandiseId );
280:         }
281: 
282:         // then
283:         assertEquals( 0, totalInventory );
284:     }
285: 
286: 
287: 
288: }
289: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
1: package thkoeln.archilab.ecommerce.tests.testtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.domain.JavaMethod;
6: import com.tngtech.archunit.core.importer.ClassFileImporter;
7: import com.tngtech.archunit.lang.ArchRule;
8: import org.junit.jupiter.api.BeforeEach;
9: import org.junit.jupiter.api.Test;
10: import org.springframework.web.bind.annotation.RestController;
11: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
12: import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
13: import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingCartRESTTest;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
18: 
19: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
20: import static org.springframework.test.util.AssertionErrors.assertTrue;
21: 
22: /**
23:  * This test checks if there are the appropriate tests in the test class(es) for domain
24:  * primitives.
25:  */
26: 
27: public class RulesForOwnTests {
28:     private JavaClass dpTestClass, restTestClass;
29:     private JavaClasses dpTestClasses, restTestClasses;
30:     private static final String STORAGE_UNIT_DOMAIN_PACKAGE =
31:             "thkoeln.archilab.ecommerce.solution.storageunit.domain";
32:     private static final String STORAGE_UNIT_CLASS_NAME =
33:             STORAGE_UNIT_DOMAIN_PACKAGE + ".StorageUnit";
34: 
35: 
36:     @BeforeEach
37:     public void setUp() throws Exception {
38:         dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
39:         restTestClass = new ClassFileImporter().importClass( OwnShoppingCartRESTTest.class );
40: 
41:         dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
42:         restTestClasses = new ClassFileImporter().importClasses( OwnShoppingCartRESTTest.class );
43:     }
44: 
45: 
46:     @Test
47:     public void ensureMinimumNumberOfTestMethods() {
48:         // given
49:         // when
50:         int dpTestMethodCount = getTestMethodCount( dpTestClass );
51:         int restTestMethodCount = getTestMethodCount( restTestClass );
52: 
53:         // then
54:         assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
55:                         + dpTestMethodCount,dpTestMethodCount >= 2 );
56:         assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
57:                         + restTestMethodCount, restTestMethodCount >= 5 );
58:     }
59: 
60:     private int getTestMethodCount( JavaClass testClass ) {
61:         int testMethodCount = 0;
62:         for ( JavaMethod method : testClass.getMethods() ) {
63:             if ( isTestMethod( method ) ) {
64:                 testMethodCount++;
65:             }
66:         }
67:         return testMethodCount;
68:     }
69: 
70:     private boolean isTestMethod( JavaMethod method ) {
71:         return method.isAnnotatedWith( Test.class );
72:     }
73: 
74: 
75:     @Test
76:     public void dpTestsShouldReferenceTheRightClasses() {
77:         ArchRule rule = classes()
78:                 .should().dependOnClassesThat()
79:                 .areAssignableTo( ZipCodeType.class )
80:                 .andShould().dependOnClassesThat()
81:                 .areAssignableTo( MoneyType.class )
82:                 .andShould().dependOnClassesThat()
83:                 .areAssignableTo( AddressType.class )
84:                 .andShould().dependOnClassesThat()
85:                 .areAssignableTo( MailAddressType.class )
86:                 .because( "DomainPrimitiveJSONSerializationTest should reference ZipCode, " +
87:                         "Money, MailAddress, and Address!" );
88:         rule.check( dpTestClasses );
89:     }
90: 
91: 
92:     @Test
93:     public void restTestsShouldReferenceMailAddress() {
94:         ArchRule rule = classes()
95:                 .should().dependOnClassesThat()
96:                 .areAssignableTo( MailAddressType.class )
97:                 .because( "StorageUnitComparatorUnitTest should reference MailAddressType!" );
98:         rule.check( restTestClasses );
99:     }
100: 
101: 
102:     @Test
103:     public void restTestsShouldReferenceRESTControllers() {
104:         ArchRule rule = classes()
105:                 .should().dependOnClassesThat()
106:                 .areAnnotatedWith( RestController.class )
107:                 .orShould().dependOnClassesThat()
108:                 .areAssignableTo( ShoppingCartRESTHelper.class )
109:                 .because( "StorageUnitComparatorUnitTest should call REST controllers! " +
110:                         "(either directly or via the ShoppingCartRESTHelper REST helper)" );
111:         rule.check( restTestClasses );
112:     }
113: 
114: }
115: 

[RESPONSE]:
Hier sind die gefundenen Code-Smells basierend auf den Regeln und dem 4-Layer-Architekturmuster (DDD):

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\MailAddress.java ---
[MailAddress.java] [51-54]: [Duplication] [45-48] : Die Validierung der Domain ist strukturell identisch mit der Validierung des Identifiers (Regex-Check und Prüfung auf ".." Punkte).
[MailAddress.java] [57]: [negative conditionals] : Die Prüfung auf die Top-Level-Domain ist negativ formuliert (`!domain.matches`).

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
[Money.java] [34]: [negative conditionals] : Doppelt negative Bedingung (`!equals && !equals`) zur Überprüfung der Währungseinheit. Dies sollte positiv formuliert sein (z.B. `isValidCurrency`).

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerController.java ---
[CustomerController.java] [43-50]: [missplaced resonsibility] : Die Mapping-Logik (`mapToResponse`) von Domain-Objekten zu DTOs befindet sich direkt im Controller. Dies gehört idealerweise in eine separate Assembler/Mapper-Klasse oder in die DTOs selbst.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerService.java ---
[CustomerService.java] [100-102]: [dead code] : Die Methode `deleteAllCustomers` wird im regulären Geschäftsbetrieb nicht benötigt (vermutlich nur für Tests).

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\application\MerchandiseService.java ---
[MerchandiseService.java] [73-78]: [Shared persistency] : Der `MerchandiseService` greift direkt via JPQL auf `ShoppingCartPosition` zu. Dies ist eine Verletzung der Aggregatsgrenzen (Zugriff auf ShoppingCart Domain).
[MerchandiseService.java] [84-88]: [Shared persistency] : Der `MerchandiseService` greift direkt via JPQL auf `InventoryLevel` zu. Dies ist eine Verletzung der Aggregatsgrenzen (Zugriff auf StorageUnit Domain).
[MerchandiseService.java] [95-98]: [Shared persistency] : Der `MerchandiseService` greift direkt via JPQL auf `PurchasePosition` zu. Dies ist eine Verletzung der Aggregatsgrenzen (Zugriff auf Purchase Domain).
[MerchandiseService.java] [118-127]: [dead code] : Die Methode `deleteMerchandiseCatalog` löscht Tabelleninhalte direkt. Dies ist Code für Testzwecke und kein Business-Use-Case.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\Merchandise.java ---
[Merchandise.java] : -Anemic Entity-

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseService.java ---
[PurchaseService.java] [31]: [Shared persistency] : Der `PurchaseService` hat eine Abhängigkeit zum `CustomerRepository`. Ein Service sollte nicht auf Repositories anderer Aggregate zugreifen.
[PurchaseService.java] [95-98]: [dead code] : Die Methode `deleteAllPurchases` ist Test-Code.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePosition.java ---
[PurchasePosition.java] : -Anemic Entity-

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartController.java ---
[ShoppingCartController.java] [22]: [layer violation] : Der Controller hält eine Referenz auf den `EntityManager`. Dies ist ein Verstoß gegen die Schichtenarchitektur (UI Layer greift auf Infrastructure zu).
[ShoppingCartController.java] [269]: [layer violation] : Der Controller nutzt den `EntityManager` um `Purchase` Entities zu laden. Datenbankzugriffe gehören nicht in den Controller.
[ShoppingCartController.java] [271]: [layer violation] : Der Controller nutzt den `EntityManager` um `Customer` Entities zu laden.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartService.java ---
[ShoppingCartService.java] [39]: [Shared persistency] : Der `ShoppingCartService` hat eine Abhängigkeit zum `MerchandiseRepository`. Zugriff auf fremdes Aggregat-Repository.
[ShoppingCartService.java] [222-248]: [missplaced resonsibility] : Die Methode `createPurchaseForUnit` erstellt `Purchase` und `PurchasePosition` Entities. Diese Logik gehört in den `PurchaseService` oder die `Purchase` Domain, nicht in den Warenkorb-Service.
[ShoppingCartService.java] [259]: [Shared persistency] : Direkter JPQL Zugriff auf `Customer` Tabelle.
[ShoppingCartService.java] [271]: [Shared persistency] : Direkter JPQL Zugriff auf `Merchandise` Tabelle.
[ShoppingCartService.java] [306]: [Shared persistency] : Direkter JPQL Zugriff auf `StorageUnit` Tabelle.
[ShoppingCartService.java] [316-352]: [missplaced resonsibility] : Die Logik zur Auswahl der besten `StorageUnit` (`findBestStorageUnit`) ist komplexe Logistik-Logik und gehört in die `StorageUnit` Domain oder einen dedizierten Service, nicht in den ShoppingCartService.
[ShoppingCartService.java] [354-372]: [missplaced resonsibility] : `calculateDistance` berechnet Distanzen zwischen PLZs. Das ist Logistik-Logik (StorageUnit Domain) oder Infrastruktur-Logik, nicht ShoppingCart.
[ShoppingCartService.java] [252-255]: [dead code] : `emptyAllShoppingCarts` ist Test-Code.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_3322520b-2c50-434d-bde8-13aeca0c3ebf\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\StorageUnitService.java ---
[StorageUnitService.java] [30]: [Shared persistency] : Der `StorageUnitService` nutzt das `MerchandiseRepository`.
[StorageUnitService.java] [65-71]: [dead code] : `deleteAllStorageUnits` ist Test-Code.
[StorageUnitService.java] [127-138]: [Duplication] [102-113] : Exakte Wiederholung der Validierungslogik (Null-Checks und Existenz-Prüfung für StorageUnit und Merchandise) in `removeFromInventory` wie in `addToInventory`.
[StorageUnitService.java] [158-169]: [Duplication] [102-113] : Exakte Wiederholung der Validierungslogik in `changeInventoryTo`.
[StorageUnitService.java] [180-189]: [Duplication] [102-113] : Wiederholung der Validierungslogik in `getAvailableInventory`.

ENDE
Generated by gemini-3-pro-preview
-----------------------------------