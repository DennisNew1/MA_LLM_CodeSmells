--- DATE: 13.1.2026, 14:56:30 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
        Architektur: 4-Layer (Eric Evans).
        Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
        Regeln:
        1. Begründe kurz jeden Fund.
        4. Gruppiere nach Datei (mit Pfad). 
        2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
        3. Keine Code-Wiederholung, nur Referenzen.
        5. Wenn fertig, schreibe "ENDE". 
        6. Nutze die Zeilenangaben die mitgeschickt worden sind.



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\MailAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import org.springframework.util.StringUtils;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
9: 
10: import javax.persistence.Embeddable;
11: import java.util.regex.Pattern;
12: @Getter
13: @Embeddable
14: @NoArgsConstructor
15: public class MailAddress implements MailAddressType {
16:     public String mailAddressString;
17: 
18:     private MailAddress(String value) {
19:         this.mailAddressString = value;
20:     }
21: 
22:     /**
23:      * @return the mail address as a string
24:      */
25:     public String toString() {
26:         return mailAddressString;
27:     }
28: 
29:     /**
30:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
31:      * implementing class to provide a static factory method (simply named "of(...)"),
32:      * which creates an mail address, given as a string.
33:      * We specify this factory method here as a comment, using the Javadoc documentation style.
34:      *
35:      * @param mailAddressAsString - the mail address as a string.
36:      *      We will use a much simplified validation method to check if the mail address is valid:
37:      *      - it must contain exactly one '@' character.
38:      *      - the part before the '@' and the part after the '@' must not be empty, contain of
39:      *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
40:      *      - the parts before and after the '@' may contain one or several '.' as separators
41:      *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
42:      *      - the part after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
43:      *        (for simplicity we do not allow any other domains)
44:      * @return a new MailAddressType object matching the given mail address
45:      * @throws ShopException if ...
46:      *      - mailAddressAsString is null
47:      *      - mailAddressAsString is not a valid mail address (see above)
48:      */
49:     public static MailAddress of(String mailAddressAsString) {
50:         if(mailAddressAsString == null || mailAddressAsString == "") throw new ShopException("Invalid!");
51:         if(!mailAddressAsString.contains("@") || StringUtils.countOccurrencesOf(mailAddressAsString, "@") > 1) throw new ShopException("Invalid!");
52:         String[] mailAddressSplitByDelimiter = StringUtils.split(mailAddressAsString, "@");
53:         if(mailAddressSplitByDelimiter.length != 2) throw new ShopException("Invalid!");
54:         if(mailAddressSplitByDelimiter[0] == null || mailAddressSplitByDelimiter[0] == "") throw new ShopException("Invalid!");
55:         if(mailAddressSplitByDelimiter[1] == null || mailAddressSplitByDelimiter[1] == "") throw new ShopException("Invalid!");
56: 
57:         // RegEx Validation
58:         if(!Pattern.compile("^[A-Za-z0-9\\.]+$").matcher(mailAddressSplitByDelimiter[0]).find()) throw new ShopException("Invalid!");
59:         if(!Pattern.compile("^[A-Za-z0-9\\.]+$").matcher(mailAddressSplitByDelimiter[1]).find()) throw new ShopException("Invalid!");
60:         if(Pattern.compile("\\s").matcher(mailAddressSplitByDelimiter[0]).find()) throw new ShopException("Invalid!");
61:         if(Pattern.compile("\\s").matcher(mailAddressSplitByDelimiter[1]).find()) throw new ShopException("Invalid!");
62:         if(Pattern.compile("(\\.\\.)+").matcher(mailAddressSplitByDelimiter[0]).find()) throw new ShopException("Invalid!");
63:         if(Pattern.compile("(\\.\\.)+").matcher(mailAddressSplitByDelimiter[1]).find()) throw new ShopException("Invalid!");
64:         if(!Pattern.compile("(.)+(\\.de|\\.com|\\.at|\\.ch|\\.org)$").matcher(mailAddressSplitByDelimiter[1]).find()) throw new ShopException("Invalid!");
65: 
66:         MailAddress mailAddress = new MailAddress(mailAddressAsString);
67:         return mailAddress;
68:     }
69: 
70: 
71:     @Override
72:     public boolean equals(final Object obj) {
73:         MailAddress otherObj = (MailAddress) obj;
74:         if(!mailAddressString.equals(otherObj.mailAddressString)) return false;
75:         return true;
76:     }
77: }
78: 
79: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: import com.fasterxml.jackson.annotation.JsonProperty;
3: import lombok.NoArgsConstructor;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import javax.persistence.Embeddable;
8: 
9: @Embeddable
10: @NoArgsConstructor
11: public class Money implements MoneyType {
12:     private String currency;
13:     private Float amount;
14: 
15:     private Money(Float amount, String currency) {
16:         this.amount = amount;
17:         this.currency = currency;
18:     }
19: 
20:     @Override
21:     public boolean equals(final Object obj) {
22:         Money otherObj = (Money) obj;
23:         if(currency.equals(otherObj.getCurrency()) && amount.equals(otherObj.getAmount())) return true;
24:         return false;
25:     }
26: 
27:     /**
28:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
29:      * implementing class to provide a static factory method (simply named "of(...)"),
30:      * which creates a money object from an amount and a currency (as string).
31:      * We specify this factory method here as a comment, using the Javadoc documentation style.
32:      *
33:      * @param amount the amount of money (must be >= 0)
34:      * @param currency the currency of the money (allowed values: "EUR", "CHF")
35:      * @return a new Money object with the given amount and currency
36:      * @throws ShopException if ...
37:      *   - amount is null
38:      *   - amount < 0
39:      *   - currency is null
40:      *   - currency is not one of the allowed values
41:      */
42:     public static MoneyType of(Float amount, String currency) {
43:         if(amount == null || amount < 0) throw new ShopException("Invalid!");
44:         if(currency == null) throw new ShopException("Invalid!");
45:         if(currency != "EUR" && currency != "CHF") throw new ShopException("Invalid!");
46: 
47:         Money money = new Money(amount, currency);
48:         return money;
49:     }
50: 
51:     @Override
52:     public Float getAmount() {
53:         return amount;
54:     }
55: 
56:     @Override
57:     public String getCurrency() {
58:         return currency;
59:     }
60: 
61:     /**
62:      * @param otherMoney
63:      * @return this + otherMoney, as a new object
64:      * @throws ShopException if ...
65:      *      - otherMoney is null
66:      *      - otherMoney.currency != this.currency
67:      */
68:     @Override
69:     public MoneyType add(MoneyType otherMoney) {
70:         if(otherMoney == null) throw new ShopException("Invalid!");
71:         if(otherMoney.getCurrency() != this.currency) throw new ShopException("Invalid!");
72: 
73:         MoneyType newObject = Money.of(getAmount() + otherMoney.getAmount(), getCurrency());
74:         return newObject;
75:     }
76: 
77:     /**
78:      * @param otherMoney
79:      * @return this - otherMoney, as a new object
80:      * @throws ShopException if ...
81:      *      - otherMoney is null
82:      *      - otherMoney.currency != this.currency
83:      *      - otherMoney > this
84:      */
85:     @Override
86:     public MoneyType subtract(MoneyType otherMoney) {
87:         if(otherMoney == null) throw new ShopException("Invalid!");
88:         if(otherMoney.getCurrency() != this.currency) throw new ShopException("Invalid!");
89:         if(otherMoney.getAmount() > getAmount()) throw new ShopException("Invalid!");
90: 
91:         MoneyType newObject = Money.of(getAmount() - otherMoney.getAmount(), getCurrency());
92:         return newObject;
93:     }
94: 
95:     /**
96:      * @param factor
97:      * @return this * factor, as a new object
98:      * @throws ShopException if ...
99:      *     - factor < 0
100:      */
101:     @Override
102:     public MoneyType multiplyBy(int factor) {
103:         if(factor < 0) throw new ShopException("Invalid!");
104: 
105:         MoneyType newObject = Money.of(getAmount() * factor, getCurrency());
106:         return newObject;
107:     }
108: 
109:     /**
110:      * @param otherMoney
111:      * @return true, if this > otherMoney
112:      * @throws ShopException if ...
113:      *      - otherMoney is null
114:      *      - otherMoney.currency != this.currency
115:      */
116:     @Override
117:     public boolean largerThan(MoneyType otherMoney) {
118:         if(otherMoney == null || otherMoney.getCurrency() != this.getCurrency()) throw new ShopException("Invalid!");
119:         boolean result = this.getAmount() > otherMoney.getAmount();
120:         return result;
121:     }
122: }
123: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PersonalAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
6: 
7: public class PersonalAddress implements PersonalAddressType {
8:     private String street;
9:     private String city;
10:     private PostalCodeType postalCode;
11: 
12:     private PersonalAddress(String street, String city, PostalCodeType postalCode) {
13:         this.street = street;
14:         this.city = city;
15:         this.postalCode = postalCode;
16:     }
17: 
18:     @Override
19:     public String getStreet() {
20:         return this.street;
21:     }
22: 
23:     @Override
24:     public String getCity() {
25:         return this.city;
26:     }
27: 
28:     @Override
29:     public PostalCodeType getPostalCode() {
30:         return this.postalCode;
31:     }
32: 
33:     /**
34:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
35:      * implementing class to provide a static factory method (simply named "of(...)"),
36:      * which creates an postal code, given as a string.
37:      * We specify this factory method here as a comment, using the Javadoc documentation style.
38:      *
39:      * @param street the street as a string
40:      * @param city the city as a string
41:      * @param postalCode the postal code
42:      * @return the personalAddress object matching the parameters
43:      * @throws ShopException if ...
44:      *      - street is null or empty
45:      *      - city is null or empty
46:      *      - postalCode is null
47:      */
48:     public static PersonalAddress of(String street, String city, PostalCodeType postalCode) {
49:         if(street == null || street == "") throw new ShopException("Invalid!");
50:         if(city == null || city == "") throw new ShopException("Invalid!");
51:         if(postalCode == null) throw new ShopException("Invalid!");
52: 
53:         PersonalAddress personalAddress = new PersonalAddress(street, city, postalCode);
54:         return personalAddress;
55:     }
56: 
57:     @Override
58:     public boolean equals(final Object obj) {
59:         PersonalAddress otherObj = (PersonalAddress) obj;
60:         if(!street.equals(otherObj.street)) return false;
61:         if(!city.equals(otherObj.city)) return false;
62:         if(!postalCode.equals(otherObj.postalCode)) return false;
63:         return true;
64:     }
65: }
66: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PostalCode.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
5: 
6: import java.util.regex.Pattern;
7: 
8: public class PostalCode implements PostalCodeType {
9:     private String value;
10: 
11:     private PostalCode(String value)
12:     {
13:         this.value = value;
14:     }
15: 
16:     /**
17:      * @return the postal code as a string
18:      */
19:     public String toString() {
20:         return this.value;
21:     }
22: 
23:     /**
24:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
25:      * implementing class to provide a static factory method (simply named "of(...)"),
26:      * which creates an postal code, given as a string.
27:      * We specify this factory method here as a comment, using the Javadoc documentation style.
28:      *
29:      * @param postalCodeAsString - the postal code as a string.
30:      *      We will use a much simplified validation method to check if the postal code is valid:
31:      *      - It must contain exactly 5 digits.
32:      *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid postal code, but 20001 is valid)
33:      * @return a new postal code object matching the given string
34:      * @throws ShopException if ...
35:      *      - postalCodeAsString is null
36:      *      - postalCodeAsString is not a valid postal code (see above)
37:      */
38:     public static PostalCodeType of(String postalCodeAsString) {
39:         if(postalCodeAsString == null) throw new ShopException("Invalid!");
40:         if(!Pattern.compile("^\\d{5}$").matcher(postalCodeAsString).find()) throw new ShopException("Invalid!");
41:         if(postalCodeAsString.endsWith("0000")) throw new ShopException("Invalid!");
42:         PostalCode postalCode = new PostalCode(postalCodeAsString);
43:         return postalCode;
44:     }
45: 
46:     @Override
47:     public boolean equals(final Object obj) {
48:         PostalCode otherObj = (PostalCode) obj;
49:         if(!value.equals(otherObj.value)) return false;
50:         return true;
51:     }
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\UserTypeImplementation.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: import thkoeln.archilab.ecommerce.usecases.UserType;
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
5: 
6: public class UserTypeImplementation implements UserType {
7:     private String name;
8:     private MailAddressType mail;
9:     private PersonalAddressType address;
10: 
11:     private UserTypeImplementation(String name, MailAddressType mail, PersonalAddressType address) {
12:         this.name = name;
13:         this.mail = mail;
14:         this.address = address;
15:     }
16: 
17:     public static UserType of(String name, MailAddressType mail, PersonalAddressType address) {
18:         return new UserTypeImplementation(name, mail, address);
19:     }
20: 
21:     @Override
22:     public String getName() {
23:         return this.name;
24:     }
25: 
26:     @Override
27:     public MailAddressType getMailAddress() {
28:         return this.mail;
29:     }
30: 
31:     @Override
32:     public PersonalAddressType getPersonalAddress() {
33:         return this.address;
34:     }
35: }
36: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\masterdata\FactoryMethodInvoker.java ---
1: package thkoeln.archilab.ecommerce.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
8: 
9: import java.io.File;
10: import java.io.IOException;
11: import java.lang.reflect.InvocationTargetException;
12: import java.lang.reflect.Method;
13: import java.lang.reflect.Modifier;
14: import java.net.URL;
15: import java.net.URLDecoder;
16: import java.nio.charset.StandardCharsets;
17: import java.util.Enumeration;
18: 
19: import static org.junit.jupiter.api.Assertions.*;
20: 
21: public class FactoryMethodInvoker {
22: 
23:     public static MailAddressType instantiateMailAddress( String mailAddressAsString ) {
24:         Method factoryMethod = null;
25:         try {
26:             Class<?> interfaceClass = Class.forName(
27:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType" );
28:             Class<?> implementingClass = findImplementation( interfaceClass );
29: 
30:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
31:             assertNotNull( factoryMethod );
32:             int modifiers = factoryMethod.getModifiers();
33:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
34:         } catch (Exception e) {
35:             fail( "Failed to find implementation for MailAddressType", e );
36:         }
37: 
38:         Object instance = null;
39:         try {
40:             instance = factoryMethod.invoke( null, mailAddressAsString );
41:         } catch (Exception e) {
42:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
43:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
44:             fail( "Failed to invoke factory method 'of' for '" + mailAddressAsString + "'", e );
45:         }
46:         assertNotNull( instance );
47:         return (MailAddressType) instance;
48:     }
49: 
50: 
51:     public static PersonalAddressType instantiatePersonalAddress(
52:             String street, String city, PostalCodeType postalCode ) {
53:         Method factoryMethod = null;
54:         try {
55:             Class<?> interfaceClass = Class.forName(
56:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType" );
57:             Class<?> implementingClass = findImplementation( interfaceClass );
58: 
59:             factoryMethod = implementingClass.getDeclaredMethod( "of",
60:                     String.class, String.class, PostalCodeType.class );
61:             assertNotNull( factoryMethod );
62:             int modifiers = factoryMethod.getModifiers();
63:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
64:         } catch (Exception e) {
65:             fail( "Failed to find implementation for PersonalAddressType", e );
66:         }
67: 
68:         Object instance = null;
69:         try {
70:             instance = factoryMethod.invoke( null, street, city, postalCode );
71:         } catch (Exception e) {
72:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
73:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
74:             fail( "Failed to invoke factory method 'of' for '" +
75:                     street + "', '" + city + "', '" + postalCode + "'", e );
76:         }
77:         assertNotNull( instance );
78:         return (PersonalAddressType) instance;
79:     }
80: 
81: 
82:     public static PostalCodeType instantiatePostalCode( String postalCodeAsString ) {
83:         Method factoryMethod = null;
84:         try {
85:             Class<?> interfaceClass = Class.forName(
86:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType" );
87:             Class<?> implementingClass = findImplementation( interfaceClass );
88: 
89:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
90:             assertNotNull( factoryMethod );
91:             int modifiers = factoryMethod.getModifiers();
92:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
93:         } catch (Exception e) {
94:             fail( "Failed to find implementation for PostalCodeType", e );
95:         }
96: 
97:         Object instance = null;
98:         try {
99:             instance = factoryMethod.invoke( null, postalCodeAsString );
100:         } catch (Exception e) {
101:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
102:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
103:             fail( "Failed to invoke factory method 'of' for '" + postalCodeAsString + "'", e );
104:         }
105:         assertNotNull( instance );
106:         return (PostalCodeType) instance;
107:     }
108: 
109: 
110:     public static MoneyType instantiateMoney( Float amount, String currency ) {
111:         Method factoryMethod = null;
112:         try {
113:             Class<?> interfaceClass = Class.forName(
114:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType" );
115:             Class<?> implementingClass = findImplementation( interfaceClass );
116: 
117:             factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
118:             assertNotNull( factoryMethod );
119:             int modifiers = factoryMethod.getModifiers();
120:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
121:         } catch (Exception e) {
122:             fail( "Failed to find implementation for MoneyType", e );
123:         }
124: 
125:         Object instance = null;
126:         try {
127:             instance = factoryMethod.invoke( null, amount, currency );
128:         } catch (Exception e) {
129:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
130:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
131:             fail( "Failed to invoke factory method 'of' for '" + amount + "', '" + currency + "'", e );
132:         }
133:         assertNotNull( instance );
134:         return (MoneyType) instance;
135:     }
136: 
137: 
138:     private static Class<?> findImplementation( Class<?> interfaceClass ) {
139:         Method factoryMethod = null;
140:         try {
141:             String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
142:             Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
143:             assertNotNull( implementingClass );
144:             return implementingClass;
145:         } catch (Exception e) {
146:             fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
147:             return null; // This line will never be reached, but it's necessary to satisfy the compiler
148:         }
149:     }
150: 
151: 
152:     private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
153:             throws ClassNotFoundException, IOException {
154:         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
155:         String path = packageName.replace( '.', '/' );
156:         Enumeration<URL> resources = classLoader.getResources( path );
157:         int count = 0;
158:         Class<?> result = null;
159:         while (resources.hasMoreElements()) {
160:             URL resource = resources.nextElement();
161:             File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
162:             File[] files = directory.listFiles();
163:             for ( File file : files ) {
164:                 if ( file.getName().endsWith( ".class" ) ) {
165:                     String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
166:                     Class<?> clazz = Class.forName( className );
167:                     if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
168:                         count++;
169:                         result = clazz;
170:                     }
171:                 }
172:             }
173:         }
174:         assertEquals( 1, count, "There should be exactly one implementing class" );
175:         return result;
176:     }
177: }
178: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\masterdata\InitialMasterDataCreator.java ---
1: package thkoeln.archilab.ecommerce.masterdata;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.context.ApplicationListener;
5: import org.springframework.context.annotation.Profile;
6: import org.springframework.context.event.ContextRefreshedEvent;
7: import org.springframework.stereotype.Component;
8: import thkoeln.archilab.ecommerce.usecases.*;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
12: 
13: import java.util.HashMap;
14: import java.util.Map;
15: import java.util.Random;
16: import java.util.UUID;
17: 
18: 
19: /**
20:  * This class is used to create the initial master data for the application. This includes
21:  * users and products. It is executed on application startup, and is used for testing purposes.
22:  */
23: @Component
24: @SuppressWarnings("PMD")
25: public class InitialMasterDataCreator {
26: 
27:     public final static String[] USER_NAME = new String[]{
28:             "Max Müller",
29:             "Sophie Schmitz",
30:             "Irene Mihalic",
31:             "Emilia Fischer",
32:             "Filiz Polat",
33:             "Lina Wagner",
34:             "Leon Becker",
35:             "Agnieszka Kalterer",
36:             "Felix Bauer",
37:             "Lara Schulz"
38:     };
39:     public final static MailAddressType[] USER_EMAIL = new MailAddressType[] {
40:             FactoryMethodInvoker.instantiateMailAddress( "max.mueller@example.com" ),
41:             FactoryMethodInvoker.instantiateMailAddress( "sophie.schmitz@example.com" ),
42:             FactoryMethodInvoker.instantiateMailAddress( "irene@wearefreedomnow.com" ),
43:             FactoryMethodInvoker.instantiateMailAddress( "emilia.fischer@example.com" ),
44:             FactoryMethodInvoker.instantiateMailAddress( "j877d3@gmail.com" ),
45:             FactoryMethodInvoker.instantiateMailAddress( "lina.wagner@example.com" ),
46:             FactoryMethodInvoker.instantiateMailAddress( "leon.becker@example.com" ),
47:             FactoryMethodInvoker.instantiateMailAddress( "agna@here.com" ),
48:             FactoryMethodInvoker.instantiateMailAddress( "felix.bauer@example.com" ),
49:             FactoryMethodInvoker.instantiateMailAddress( "lara.schulz@example.com" )
50:     };
51: 
52:     public final static PersonalAddressType[] USER_ADDRESS = new PersonalAddressType[] {
53:             FactoryMethodInvoker.instantiatePersonalAddress(
54:                     "Hauptstraße 1", "Berlin",
55:                     FactoryMethodInvoker.instantiatePostalCode( "10115" ) ),
56:             FactoryMethodInvoker.instantiatePersonalAddress(
57:                     "Bahnhofstraße 12", "München",
58:                     FactoryMethodInvoker.instantiatePostalCode( "80331" ) ),
59:             FactoryMethodInvoker.instantiatePersonalAddress(
60:                     "Kirchplatz 3", "Hamburg",
61:                     FactoryMethodInvoker.instantiatePostalCode( "20095" ) ),
62:             FactoryMethodInvoker.instantiatePersonalAddress(
63:                     "Goethestraße 7", "Frankfurt am Main",
64:                     FactoryMethodInvoker.instantiatePostalCode( "60311" ) ),
65:             FactoryMethodInvoker.instantiatePersonalAddress(
66:                     "Mühlenweg 15", "Köln",
67:                     FactoryMethodInvoker.instantiatePostalCode( "50667" ) ),
68:             FactoryMethodInvoker.instantiatePersonalAddress(
69:                     "Schulstraße 9", "Düsseldorf",
70:                     FactoryMethodInvoker.instantiatePostalCode( "40213" ) ),
71:             FactoryMethodInvoker.instantiatePersonalAddress(
72:                     "Dorfstraße 21", "Stuttgart",
73:                     FactoryMethodInvoker.instantiatePostalCode( "70173" ) ),
74:             FactoryMethodInvoker.instantiatePersonalAddress(
75:                     "Marktstraße 5", "Leipzig",
76:                     FactoryMethodInvoker.instantiatePostalCode( "04109" ) ),
77:             FactoryMethodInvoker.instantiatePersonalAddress(
78:                     "Rosenweg 14", "Dortmund",
79:                     FactoryMethodInvoker.instantiatePostalCode( "44135" ) ),
80:             FactoryMethodInvoker.instantiatePersonalAddress(
81:                     "Wiesenstraße 6", "Essen",
82:                     FactoryMethodInvoker.instantiatePostalCode( "45127" ) )
83:     };
84: 
85:     public final static UserType[] mockUsers;
86: 
87:     public static final String EUR = "EUR";
88: 
89:     public static final Object[][] PRODUCT_DATA = new Object[][]{
90:             {UUID.randomUUID(), "TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
91:                     1.5f, FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
92:                     FactoryMethodInvoker.instantiateMoney( 10.0f, EUR )},
93:             {UUID.randomUUID(), "EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
94:                     0.3f, FactoryMethodInvoker.instantiateMoney( 2.5f, EUR ),
95:                     FactoryMethodInvoker.instantiateMoney( 4.0f, EUR )},
96:             {UUID.randomUUID(), "MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
97:                     7.2f, FactoryMethodInvoker.instantiateMoney( 50.0f, EUR ),
98:                     FactoryMethodInvoker.instantiateMoney( 80.0f, EUR )},
99:             {UUID.randomUUID(), "Gh-25", "Kompakter und leichter Akku für mobile Geräte",
100:                     null, FactoryMethodInvoker.instantiateMoney( 6.0f, EUR ),
101:                     FactoryMethodInvoker.instantiateMoney( 8.0f, EUR )},
102:             {UUID.randomUUID(), "MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
103:                     null, FactoryMethodInvoker.instantiateMoney( 0.6f, EUR ),
104:                     FactoryMethodInvoker.instantiateMoney( 1.0f, EUR )},
105:             {UUID.randomUUID(), "ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
106:                     1.0f, FactoryMethodInvoker.instantiateMoney( 150.0f, EUR ),
107:                     FactoryMethodInvoker.instantiateMoney( 250.0f, EUR )},
108:             {UUID.randomUUID(), "Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
109:                     null, FactoryMethodInvoker.instantiateMoney( 0.3f, EUR ),
110:                     FactoryMethodInvoker.instantiateMoney( 0.5f, EUR )},
111:             {UUID.randomUUID(), "Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
112:                     6.0f, FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
113:                     FactoryMethodInvoker.instantiateMoney( 120.0f, EUR )},
114:             {UUID.randomUUID(), "JKL-67", "Wasserdichtes Gehäuse",
115:                     3.0f, FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
116:                     FactoryMethodInvoker.instantiateMoney( 1.2f, EUR )},
117:             {UUID.randomUUID(), "MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
118:                     5.5f, FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
119:                     FactoryMethodInvoker.instantiateMoney( 45.0f, EUR )},
120:             {UUID.randomUUID(), "PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
121:                     4.0f, FactoryMethodInvoker.instantiateMoney( 20.0f, EUR ),
122:                     FactoryMethodInvoker.instantiateMoney( 35.0f, EUR )},
123:             {UUID.randomUUID(), "STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
124:                     null, FactoryMethodInvoker.instantiateMoney( 200.0f, EUR ),
125:                     FactoryMethodInvoker.instantiateMoney( 350.0f, EUR )},
126:             {UUID.randomUUID(), "VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
127:                     null, FactoryMethodInvoker.instantiateMoney( 15.0f, EUR ),
128:                     FactoryMethodInvoker.instantiateMoney( 25.0f, EUR )},
129:             {UUID.randomUUID(), "YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
130:                     3.5f, FactoryMethodInvoker.instantiateMoney( 60.0f, EUR ),
131:                     FactoryMethodInvoker.instantiateMoney( 100.0f, EUR )}
132:     };
133: 
134:     private UserRegistrationUseCases userRegistrationUseCases;
135:     private ProductCatalogUseCases productCatalogUseCases;
136:     private InventoryManagementUseCases inventoryManagementUseCases;
137:     private ShoppingBasketUseCases shoppingBasketUseCases;
138: 
139: 
140:     // product 0 is out of inventory, product 1 and 2 have fixed quantities of 10 and 20, respectively, and the
141:     // others have a random inventory between 5 and 100
142:     public static final Map<UUID, Integer> PRODUCT_INVENTORY = new HashMap<>();
143: 
144:     static {
145:         mockUsers = new UserType[USER_NAME.length];
146:         for ( int i = 0; i < USER_NAME.length; i++ ) {
147:             mockUsers[i] = new MockUser(
148:                     USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i]);
149:         }
150:         Random random = new Random();
151:         for ( Object[] productData : PRODUCT_DATA ) {
152:             PRODUCT_INVENTORY.put( (UUID) productData[0], random.nextInt( 100 ) + 20 );
153:         }
154:         PRODUCT_INVENTORY.put( (UUID) PRODUCT_DATA[0][0], 0 );
155:         PRODUCT_INVENTORY.put( (UUID) PRODUCT_DATA[1][0], 10 );
156:         PRODUCT_INVENTORY.put( (UUID) PRODUCT_DATA[2][0], 20 );
157:         PRODUCT_INVENTORY.put( (UUID) PRODUCT_DATA[3][0], 30 );
158: 
159:     }
160: 
161: 
162:     public enum InvalidReason {
163:         NULL, EMPTY;
164: 
165:         public Object getInvalidValue( Object originalValue ) {
166:             switch (this) {
167:                 case NULL:
168:                     return null;
169:                 case EMPTY:
170:                     return "";
171:                 default:
172:                     return null;
173:             }
174:         }
175:     }
176: 
177: 
178:     @Autowired
179:     public InitialMasterDataCreator(
180:             UserRegistrationUseCases userRegistrationUseCases,
181:             ProductCatalogUseCases productCatalogUseCases,
182:             InventoryManagementUseCases inventoryManagementUseCases,
183:             ShoppingBasketUseCases shoppingBasketUseCases ) {
184:         this.userRegistrationUseCases = userRegistrationUseCases;
185:         this.productCatalogUseCases = productCatalogUseCases;
186:         this.inventoryManagementUseCases = inventoryManagementUseCases;
187:         this.shoppingBasketUseCases = shoppingBasketUseCases;
188:     }
189: 
190: 
191:     public void deleteAll() {
192:         shoppingBasketUseCases.deleteAllOrders();
193:         productCatalogUseCases.deleteProductCatalog();
194:         userRegistrationUseCases.deleteAllUsers();
195:     }
196: 
197: 
198:     public void registerAllUsers() {
199:         for ( int i = 0; i < InitialMasterDataCreator.USER_NAME.length; i++ ) {
200:             registerUser( InitialMasterDataCreator.USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
201:         }
202:     }
203: 
204: 
205:     public void registerUser( String name, MailAddressType mailAddress, PersonalAddressType personalAddress ) {
206:         userRegistrationUseCases.register( name, mailAddress, personalAddress );
207:     }
208: 
209:     public void addAllProducts() {
210:         for ( Object[] productData : PRODUCT_DATA ) {
211:             addProductDataToCatalog( productData );
212:         }
213:     }
214: 
215:     public void addProductDataToCatalog( Object[] productData ) {
216:         productCatalogUseCases.addProductToCatalog( (UUID) productData[0], (String) productData[1], (String) productData[2],
217:                 (Float) productData[3], (MoneyType) productData[4], (MoneyType) productData[5] );
218:     }
219: 
220: 
221:     public Object[] getProductDataInvalidAtIndex( int index, InvalidReason reason ) {
222:         Object[] productData = PRODUCT_DATA[1];
223:         Object[] productDataInvalid = new Object[productData.length];
224:         System.arraycopy( productData, 0, productDataInvalid, 0, productData.length );
225:         productDataInvalid[index] = productData[index].getClass().cast(
226:                 reason.getInvalidValue( productData[index] ) );
227:         return productDataInvalid;
228:     }
229: 
230: 
231:     public void inventoryUpAllProducts() {
232:         for ( Object[] productData : PRODUCT_DATA ) {
233:             if ( PRODUCT_INVENTORY.get( productData[0] ) > 0 )
234:                 inventoryManagementUseCases.addToInventory( (UUID) productData[0], PRODUCT_INVENTORY.get( productData[0] ) );
235:         }
236:     }
237: }
238: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\masterdata\MockUser.java ---
1: package thkoeln.archilab.ecommerce.masterdata;
2: 
3: import lombok.Setter;
4: import thkoeln.archilab.ecommerce.usecases.UserType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
7: 
8: import java.util.Objects;
9: 
10: @Setter
11: public class MockUser implements UserType {
12:     private String name;
13:     private MailAddressType mailAddress;
14:     private PersonalAddressType personalAddress;
15: 
16: 
17:     public MockUser( String name, MailAddressType mailAddress, PersonalAddressType personalAddress) {
18:         this.name = name;
19:         this.mailAddress = mailAddress;
20:         this.personalAddress = personalAddress;
21:     }
22: 
23:     @Override
24:     public String getName() {
25:         return name;
26:     }
27: 
28:     @Override
29:     public MailAddressType getMailAddress() {
30:         return mailAddress;
31:     }
32: 
33:     @Override
34:     public PersonalAddressType getPersonalAddress() {
35:         return personalAddress;
36:     }
37: 
38:     @Override
39:     public boolean equals( Object o ) {
40:         if ( this == o ) return true;
41:         if ( !( o instanceof MockUser ) ) return false;
42:         MockUser that = (MockUser) o;
43:         return Objects.equals( getName(), that.getName() ) && Objects.equals( mailAddress, that.mailAddress ) && Objects.equals( personalAddress, that.personalAddress );
44:     }
45: 
46:     @Override
47:     public int hashCode() {
48:         return Objects.hash( getName(), mailAddress, personalAddress );
49:     }
50: }
51: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\masterdata\StartupListener.java ---
1: package thkoeln.archilab.ecommerce.masterdata;
2: 
3: import org.slf4j.Logger;
4: import org.slf4j.LoggerFactory;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.context.ApplicationListener;
7: import org.springframework.context.annotation.Profile;
8: import org.springframework.context.event.ContextRefreshedEvent;
9: import org.springframework.stereotype.Component;
10: 
11: @Component
12: @Profile("!test")
13: public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
14:     private Logger logger = LoggerFactory.getLogger( StartupListener.class );
15: 
16:     private InitialMasterDataCreator initialMasterDataCreator;
17: 
18:     @Autowired
19:     public StartupListener( InitialMasterDataCreator initialMasterDataCreator ) {
20:         this.initialMasterDataCreator = initialMasterDataCreator;
21:     }
22: 
23:     @Override
24:     public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
25:         logger.info( "Initializing master data..." );
26:         initialMasterDataCreator.registerAllUsers();
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
1: package thkoeln.archilab.ecommerce;
2: 
3: import org.springframework.boot.SpringApplication;
4: import org.springframework.boot.autoconfigure.SpringBootApplication;
5: 
6: 
7: @SpringBootApplication
8: public class ProjectApplication {
9: 
10: 	/**
11: 	 * Entry method
12: 	 * @param args
13: 	 */
14: 	public static void main(String[] args) {
15: 		SpringApplication.run(ProjectApplication.class, args);
16: 	}
17: }
18: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
1: package thkoeln.archilab.ecommerce;
2: 
3: public class ShopException extends RuntimeException {
4:     public ShopException( String message ) {
5:         super( message );
6:     }
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\address\domain\Address.java ---
1: package thkoeln.archilab.ecommerce.solution.address.domain;
2: 
3: import lombok.Getter;
4: import lombok.NoArgsConstructor;
5: import lombok.Setter;
6: 
7: import javax.persistence.Entity;
8: import javax.persistence.Id;
9: import java.util.UUID;
10: 
11: @Getter
12: @Setter
13: @Entity
14: @NoArgsConstructor
15: public class Address {
16:     @Id
17:     private final UUID id = UUID.randomUUID();
18:     private String street;
19:     private String city;
20:     private String postalCode;
21: 
22:     public Address(String street, String city, String postalCode) {
23:         this.street = street;
24:         this.city = city;
25:         this.postalCode = postalCode;
26:     }
27: }
28: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\application\DeliveryService.java ---
1: package thkoeln.archilab.ecommerce.solution.delivery.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.delivery.domain.Delivery;
6: import thkoeln.archilab.ecommerce.solution.delivery.domain.DeliveryPosition;
7: import thkoeln.archilab.ecommerce.solution.delivery.domain.DeliveryRepository;
8: import thkoeln.archilab.ecommerce.solution.product.application.ProductUserService;
9: import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
10: import thkoeln.archilab.ecommerce.usecases.DeliveryUseCases;
11: import thkoeln.archilab.ecommerce.ShopException;
12: import thkoeln.archilab.ecommerce.usecases.UserType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: 
15: import java.util.ArrayList;
16: import java.util.HashMap;
17: import java.util.Map;
18: import java.util.UUID;
19: 
20: @Service
21: public class DeliveryService implements DeliveryUseCases {
22: 
23:     @Autowired
24:     public DeliveryRepository deliveries;
25:     @Autowired
26:     public ProductRepository products;
27:     @Autowired
28:     public ProductUserService users;
29: 
30:     /**
31:      * Delivers a product to a user. The product is identified by its id, and the user by
32:      * his/her name, street, city and postal code.
33:      * @param deliveryRecipient
34:      * @param deliveryContent - a map of product ids and quantities
35:      * @return the id of the delivery, if successfully triggered
36:      * @throws ShopException if ...
37:      *      - deliveryRecipient is null
38:      *      - any of the properties in deliveryRecipient (the getXxx(...) methods) return null or empty strings
39:      *      - deliveryContent is null or empty
40:      *      - the total number of products in the delivery is > 20
41:      */
42:     @Override
43:     public UUID triggerDelivery(UserType deliveryRecipient, Map<UUID, Integer> deliveryContent) {
44:         if(deliveryRecipient == null) throw new ShopException("Delivery Recipient is null");
45:         if(deliveryRecipient.getPersonalAddress().getCity() == null || deliveryRecipient.getPersonalAddress().getCity()== "") throw new ShopException("City is null or empty!");
46:         if(deliveryRecipient.getMailAddress() == null || deliveryRecipient.getMailAddress().toString() == "") throw new ShopException("Mail Address is null or empty!");
47:         if(deliveryRecipient.getName() == null || deliveryRecipient.getName() == "") throw new ShopException("Name is null or empty!");
48:         if(deliveryRecipient.getPersonalAddress().getStreet() == null || deliveryRecipient.getPersonalAddress().getStreet() == "") throw new ShopException("Street is null or empty!");
49:         if(deliveryRecipient.getPersonalAddress().getPostalCode() == null || deliveryRecipient.getPersonalAddress().getPostalCode().toString() == "") throw new ShopException("Postal Code is null or empty!");
50:         if(deliveryContent == null || deliveryContent.isEmpty()) throw new ShopException("Delivery Content is null or empty!");
51: 
52:         int deliverySum = 0;
53:         for (int d: deliveryContent.values()) {
54:             deliverySum += d;
55:         }
56: 
57:         if(deliverySum > 20) throw new ShopException("Delivery Content is > 20!");
58: 
59:         ArrayList<DeliveryPosition> deliveryPositions = new ArrayList<DeliveryPosition>();
60:         for (UUID productId: deliveryContent.keySet()) {
61:             deliveryPositions.add(new DeliveryPosition(products.findById(productId).get(), deliveryContent.get(productId)));
62:         }
63: 
64:         Delivery delivery = new Delivery(deliveryRecipient.getMailAddress(), deliveryRecipient.getPersonalAddress().getStreet(),
65:                 deliveryRecipient.getPersonalAddress().getCity(), deliveryRecipient.getPersonalAddress().getPostalCode().toString(), deliveryRecipient.getName(), deliveryPositions);
66: 
67:         deliveries.save(delivery);
68:         return delivery.getId();
69:     }
70: 
71:     /**
72:      * Returns a map showing which products have been delivered to a user, and how many of each product
73:      *
74:      * @param userMailAddress
75:      * @return the delivery history of the user (map is empty if the user has not had any deliveries yet)
76:      * @throws ShopException if
77:      *      - the mail address is null or empty
78:      *      - the user with the given mail address does not exist
79:      */
80:     @Override
81:     public Map<UUID, Integer> getDeliveryHistory(MailAddressType userMailAddress) {
82:         if(userMailAddress == null || userMailAddress.toString() == "") throw new ShopException("Mail is null or empty!");
83:         if(!users.existsByMailAddress(userMailAddress)) throw new ShopException("User does not exist!");
84: 
85:         HashMap<UUID, Integer> result = new HashMap();
86:         for (Delivery delivery: deliveries.findAll()) {
87:             if(delivery.getMailAddress().toString() == userMailAddress.toString()) {
88:                 for (DeliveryPosition position: delivery.getData()) {
89:                     if(!result.containsKey(position.getUuid())) result.put(position.getUuid(), 0);
90:                     result.put(position.getUuid(), result.get(position.getUuid()) + position.getQuantity());
91:                 }
92:             }
93:         }
94:         return result;
95:     }
96: 
97:     /**
98:      *  Deletes all delivery history.
99:      */
100:     @Override
101:     public void deleteDeliveryHistory() {
102:         deliveries.deleteAll();
103:         products.deleteAll();
104:     }
105: }
106: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\Delivery.java ---
1: package thkoeln.archilab.ecommerce.solution.delivery.domain;
2: 
3: import lombok.Getter;
4: import lombok.Setter;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
7: 
8: import javax.persistence.Embedded;
9: import javax.persistence.Entity;
10: import javax.persistence.Id;
11: import java.util.*;
12: 
13: @Getter @Setter
14: @Entity
15: public class Delivery {
16:     @Id
17:     private final UUID id = UUID.randomUUID();
18:     @Embedded
19:     private final MailAddress mailAddress;
20:     private String street;
21:     private String city;
22:     private String postalCode;
23:     private String name;
24: 
25:     private ArrayList<DeliveryPosition> data = new ArrayList();
26: 
27:     private Delivery() { this.mailAddress = null; }
28: 
29:     public Delivery(MailAddressType mailAddress, String street, String city, String postalCode, String name, ArrayList<DeliveryPosition> data) {
30:         this.mailAddress = MailAddress.of(mailAddress.toString());
31:         this.street = street;
32:         this.city = city;
33:         this.postalCode = postalCode;
34:         this.name = name;
35:         this.data = data;
36:     }
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\DeliveryPosition.java ---
1: package thkoeln.archilab.ecommerce.solution.delivery.domain;
2: 
3: import lombok.Getter;
4: import lombok.NoArgsConstructor;
5: import lombok.Setter;
6: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
7: 
8: import javax.persistence.Entity;
9: import javax.persistence.Id;
10: import javax.persistence.ManyToOne;
11: import java.util.UUID;
12: 
13: @Getter @Setter
14: @NoArgsConstructor
15: @Entity
16: public class DeliveryPosition {
17:     @Id
18:     private final UUID uuid = UUID.randomUUID();
19:     @ManyToOne
20:     private Product product;
21:     private int quantity;
22: 
23:     public DeliveryPosition(Product product, int quantity) {
24:         this.product = product;
25:         this.quantity = quantity;
26:     }
27: }
28: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\DeliveryRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.delivery.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: 
6: import java.util.ArrayList;
7: import java.util.HashMap;
8: import java.util.Optional;
9: import java.util.UUID;
10: 
11: @Repository
12: public class DeliveryRepository implements CrudRepository<Delivery, UUID> {
13: 
14:     public HashMap<UUID, Delivery> deliveries = new HashMap();
15: 
16:     @Override
17:     public <S extends Delivery> S save(S s) {
18:         deliveries.put(s.getId(), s);
19:         return s;
20:     }
21: 
22:     @Override
23:     public <S extends Delivery> Iterable<S> saveAll(Iterable<S> iterable) {
24:         for (S delivery: iterable) {
25:             deliveries.put(delivery.getId(), delivery);
26:         }
27:         return iterable;
28:     }
29: 
30:     @Override
31:     public Optional<Delivery> findById(UUID s) {
32:         return Optional.ofNullable(deliveries.get(s));
33:     }
34: 
35:     @Override
36:     public boolean existsById(UUID s) {
37:         return deliveries.containsKey(s);
38:     }
39: 
40:     @Override
41:     public Iterable<Delivery> findAll() {
42:         return deliveries.values();
43:     }
44: 
45:     @Override
46:     public Iterable<Delivery> findAllById(Iterable<UUID> iterable) {
47:         ArrayList<Delivery> data = new ArrayList<Delivery>();
48:         for (UUID mail: iterable) {
49:             if(existsById(mail)) data.add(deliveries.get(mail));
50:         }
51:         return data;
52:     }
53: 
54:     @Override
55:     public long count() {
56:         return deliveries.size();
57:     }
58: 
59:     @Override
60:     public void deleteById(UUID s) {
61:         if(existsById(s)) deliveries.remove(s);
62:     }
63: 
64:     @Override
65:     public void delete(Delivery delivery) {
66:         deleteById(delivery.getId());
67:     }
68: 
69:     @Override
70:     public void deleteAll(Iterable<? extends Delivery> iterable) {
71:         for (Delivery delivery: iterable) {
72:             deleteById(delivery.getId());
73:         }
74:     }
75: 
76:     @Override
77:     public void deleteAll() {
78:         deliveries.clear();
79:     }
80: }
81: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\dtos\OrderDto.java ---
1: package thkoeln.archilab.ecommerce.solution.dtos;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import lombok.Getter;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.domainprimitives.Money;
7: 
8: import java.time.LocalDateTime;
9: import java.util.ArrayList;
10: import java.util.UUID;
11: 
12: @Getter
13: public class OrderDto {
14:     @JsonProperty
15:     private UUID id;
16:     @JsonProperty
17:     private MailAddress mailAddress;
18:     @JsonProperty
19:     private Money price;
20:     @JsonProperty
21:     private OrderPositionDto[] orderPositions;
22:     @JsonProperty
23:     private LocalDateTime submissionDate;
24: 
25:     public OrderDto(UUID id, MailAddress mailAddress, Money price, ArrayList<OrderPositionDto> positions, LocalDateTime submissionDate) {
26:         this.id  = id;
27:         this.mailAddress = mailAddress;
28:         this.price = price;
29: 
30:         this.orderPositions = new OrderPositionDto[positions.size()];
31:         this.orderPositions = positions.toArray(this.orderPositions);
32:         this.submissionDate = submissionDate;
33:     }
34: }
35: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\dtos\OrderPositionDto.java ---
1: package thkoeln.archilab.ecommerce.solution.dtos;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import lombok.Getter;
5: 
6: import java.util.Locale;
7: import java.util.UUID;
8: 
9: @Getter
10: public class OrderPositionDto {
11:     @JsonProperty
12:     private String productId;
13:     @JsonProperty
14:     private int quantity;
15:     @JsonProperty
16:     private String comment;
17: 
18:     public OrderPositionDto(UUID productId, int quantity, String comment) {
19:         this.productId = productId.toString().toLowerCase(Locale.ROOT);
20:         this.quantity = quantity;
21:         this.comment = comment;
22:     }
23: }
24: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\dtos\ShoppingBasketDto.java ---
1: package thkoeln.archilab.ecommerce.solution.dtos;
2: 
3: import lombok.Getter;
4: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
5: 
6: import java.util.UUID;
7: 
8: @Getter
9: public class ShoppingBasketDto {
10:     private UUID id;
11:     private MailAddress mailAddress;
12:     private int totalQuantity;
13: 
14:     public ShoppingBasketDto(UUID id, MailAddress mailAddress, int totalQuantity) {
15:         this.id  = id;
16:         this.mailAddress = mailAddress;
17:         this.totalQuantity = totalQuantity;
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\dtos\ShoppingBasketPositionDto.java ---
1: package thkoeln.archilab.ecommerce.solution.dtos;
2: 
3: import lombok.Getter;
4: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
5: 
6: import java.util.UUID;
7: 
8: @Getter
9: public class ShoppingBasketPositionDto {
10:     private UUID productId;
11:     private int quantity;
12:     private String comment;
13: 
14:     public ShoppingBasketPositionDto(UUID productId, int quantity, String comment) {
15:         this.productId  = productId;
16:         this.quantity = quantity;
17:         this.comment = comment;
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderController.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import org.springframework.web.bind.annotation.GetMapping;
4: import org.springframework.web.bind.annotation.RequestParam;
5: import org.springframework.web.bind.annotation.RestController;
6: import thkoeln.archilab.ecommerce.solution.dtos.OrderDto;
7: import thkoeln.archilab.ecommerce.solution.dtos.OrderPositionDto;
8: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
9: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPositionRepository;
10: import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
11: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
12: 
13: import java.util.ArrayList;
14: import java.util.Comparator;
15: import java.util.List;
16: import java.util.stream.StreamSupport;
17: 
18: @RestController
19: public class OrderController {
20: 
21:     private final OrderRepository orders;
22:     private final OrderPositionRepository orderPositions;
23:     private final UserRepository users;
24: 
25:     public OrderController(OrderRepository orders, OrderPositionRepository orderPositions, UserRepository users) {
26:         this.orders = orders;
27:         this.orderPositions = orderPositions;
28:         this.users = users;
29:     }
30: 
31: 
32:     //Find all orders for user with mailAddressId, ordered by time
33:     @GetMapping("/orders")
34:     OrderDto[] findOrdersByMailAddress(@RequestParam(required = false) String mailAddress,
35:                                            @RequestParam(required = false) String filter) {
36: 
37:         ArrayList<OrderDto> result = new ArrayList();
38:         if(!users.existsById(mailAddress)) return (OrderDto[]) new OrderDto[0];
39: 
40:         StreamSupport.stream(orders.findAll().spliterator(), false)
41:         .filter(e -> e.getMailAddress().toString().equals(mailAddress))
42:         .forEach(order -> {
43:                 ArrayList<OrderPositionDto> positions = new ArrayList();
44:                 StreamSupport.stream(orderPositions.findAll().spliterator(), false)
45:                     .filter(e -> e.getOrder().getId().equals(order.getId()))
46:                     .sorted(Comparator.comparing(OrderPosition::getCreatedDate))
47:                     .forEach(pos -> {
48:                         positions.add(new OrderPositionDto(pos.getProduct().getId(), pos.getQuantity(), pos.getComment()));
49:                     });
50:             result.add(new OrderDto(order.getId(), order.getMailAddress(), order.getPrice(), positions, order.getSubmissionDate()));
51:         });
52: 
53:         Comparator<OrderDto> c = Comparator.comparing(OrderDto::getSubmissionDate);
54:         result.sort(c);
55: 
56:         if(filter != null && filter.equals("latest")) {
57:             result.sort(Comparator.comparing(OrderDto::getSubmissionDate, Comparator.reverseOrder()));
58:             var latestOrder = result.stream().findFirst().get();
59:             result.clear();
60:             result.add(latestOrder);
61:         }
62: 
63:         OrderDto[] arr = new OrderDto[result.size()];
64:         arr = result.toArray(arr);
65:         return arr;
66:     }
67: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import lombok.Getter;
4: import lombok.Setter;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.domainprimitives.Money;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: 
10: import javax.persistence.Embedded;
11: import javax.persistence.Entity;
12: import javax.persistence.Id;
13: import java.time.LocalDateTime;
14: import java.util.UUID;
15: 
16: @Getter @Setter
17: @Entity
18: public class Order {
19:     @Id
20:     private final UUID id = UUID.randomUUID();
21:     @Embedded
22:     private final MailAddress mailAddress;
23:     @Embedded
24:     private Money price;
25:     private LocalDateTime submissionDate;
26: 
27:     private Order() { this.mailAddress = null; }
28: 
29:     public Order(MailAddressType mailAddress, MoneyType price) {
30:         this.mailAddress = MailAddress.of(mailAddress.toString());
31:         this.submissionDate = LocalDateTime.now();
32:         this.price = (Money)Money.of(price.getAmount(), price.getCurrency());
33:     }
34: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPosition.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import lombok.Getter;
4: import lombok.NoArgsConstructor;
5: import lombok.Setter;
6: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
7: 
8: import javax.persistence.Entity;
9: import javax.persistence.Id;
10: import javax.persistence.ManyToOne;
11: import java.time.LocalDateTime;
12: import java.util.UUID;
13: 
14: @Getter @Setter
15: @NoArgsConstructor
16: @Entity
17: public class OrderPosition {
18:     @Id
19:     private final UUID uuid = UUID.randomUUID();
20:     @ManyToOne
21:     private Product product;
22:     @ManyToOne
23:     private Order order;
24:     private String comment;
25:     private int quantity;
26:     private final LocalDateTime createdDate = LocalDateTime.now();
27: 
28:     public OrderPosition(Order order, Product product, int quantity, String comment) {
29:         this.order = order;
30:         this.product = product;
31:         this.quantity = quantity;
32:         this.comment = comment;
33:     }
34: }
35: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: 
6: import java.util.ArrayList;
7: import java.util.HashMap;
8: import java.util.Optional;
9: import java.util.UUID;
10: 
11: @Repository
12: public class OrderPositionRepository implements CrudRepository<OrderPosition, UUID> {
13: 
14:     public HashMap<UUID, OrderPosition> orderPositions = new HashMap();
15: 
16:     @Override
17:     public <S extends OrderPosition> S save(S s) {
18:         orderPositions.put(s.getUuid(), s);
19:         return s;
20:     }
21: 
22:     @Override
23:     public <S extends OrderPosition> Iterable<S> saveAll(Iterable<S> iterable) {
24:         for (S orderPosition: iterable) {
25:             orderPositions.put(orderPosition.getUuid(), orderPosition);
26:         }
27:         return iterable;
28:     }
29: 
30:     @Override
31:     public Optional<OrderPosition> findById(UUID s) {
32:         return Optional.ofNullable(orderPositions.get(s));
33:     }
34: 
35:     @Override
36:     public boolean existsById(UUID s) {
37:         return orderPositions.containsKey(s);
38:     }
39: 
40:     @Override
41:     public Iterable<OrderPosition> findAll() {
42:         return orderPositions.values();
43:     }
44: 
45:     @Override
46:     public Iterable<OrderPosition> findAllById(Iterable<UUID> iterable) {
47:         ArrayList<OrderPosition> data = new ArrayList<OrderPosition>();
48:         for (UUID mail: iterable) {
49:             if(existsById(mail)) data.add(orderPositions.get(mail));
50:         }
51:         return data;
52:     }
53: 
54:     @Override
55:     public long count() {
56:         return orderPositions.size();
57:     }
58: 
59:     @Override
60:     public void deleteById(UUID s) {
61:         if(existsById(s)) orderPositions.remove(s);
62:     }
63: 
64:     @Override
65:     public void delete(OrderPosition orderPosition) {
66:         deleteById(orderPosition.getUuid());
67:     }
68: 
69:     @Override
70:     public void deleteAll(Iterable<? extends OrderPosition> iterable) {
71:         for (OrderPosition orderPosition: iterable) {
72:             deleteById(orderPosition.getUuid());
73:         }
74:     }
75: 
76:     @Override
77:     public void deleteAll() {
78:         orderPositions.clear();
79:     }
80: }
81: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: 
6: import java.util.ArrayList;
7: import java.util.HashMap;
8: import java.util.Optional;
9: import java.util.UUID;
10: 
11: @Repository
12: public class OrderRepository implements CrudRepository<Order, UUID> {
13: 
14:     public HashMap<UUID, Order> orders = new HashMap();
15: 
16:     @Override
17:     public <S extends Order> S save(S s) {
18:         orders.put(s.getId(), s);
19:         return s;
20:     }
21: 
22:     @Override
23:     public <S extends Order> Iterable<S> saveAll(Iterable<S> iterable) {
24:         for (S order: iterable) {
25:             orders.put(order.getId(), order);
26:         }
27:         return iterable;
28:     }
29: 
30:     @Override
31:     public Optional<Order> findById(UUID s) {
32:         return Optional.ofNullable(orders.get(s));
33:     }
34: 
35:     @Override
36:     public boolean existsById(UUID s) {
37:         return orders.containsKey(s);
38:     }
39: 
40:     @Override
41:     public Iterable<Order> findAll() {
42:         return orders.values();
43:     }
44: 
45:     @Override
46:     public Iterable<Order> findAllById(Iterable<UUID> iterable) {
47:         ArrayList<Order> data = new ArrayList<Order>();
48:         for (UUID mail: iterable) {
49:             if(existsById(mail)) data.add(orders.get(mail));
50:         }
51:         return data;
52:     }
53: 
54:     @Override
55:     public long count() {
56:         return orders.size();
57:     }
58: 
59:     @Override
60:     public void deleteById(UUID s) {
61:         if(existsById(s)) orders.remove(s);
62:     }
63: 
64:     @Override
65:     public void delete(Order order) {
66:         deleteById(order.getId());
67:     }
68: 
69:     @Override
70:     public void deleteAll(Iterable<? extends Order> iterable) {
71:         for (Order order: iterable) {
72:             deleteById(order.getId());
73:         }
74:     }
75: 
76:     @Override
77:     public void deleteAll() {
78:         orders.clear();
79:     }
80: }
81: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\payment\application\PaymentService.java ---
1: package thkoeln.archilab.ecommerce.solution.payment.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.Money;
6: import thkoeln.archilab.ecommerce.solution.product.application.ProductUserService;
7: import thkoeln.archilab.ecommerce.solution.payment.domain.Payment;
8: import thkoeln.archilab.ecommerce.solution.payment.domain.PaymentRepository;
9: import thkoeln.archilab.ecommerce.usecases.PaymentUseCases;
10: import thkoeln.archilab.ecommerce.ShopException;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
13: 
14: import java.util.UUID;
15: 
16: @Service
17: public class PaymentService implements PaymentUseCases {
18: 
19:     @Autowired
20:     private ProductUserService users;
21:     @Autowired
22:     private PaymentRepository payments;
23: 
24:     /**
25:      * Authorizes a payment for a user (identified by his/her mail address) for a given amount
26:      * @param userMailAddress
27:      * @param amount
28:      * @return the id of the payment, if successfully authorized
29:      * @throws ShopException if ...
30:      *      - userMailAddress is null or empty
31:      *      - the user with the given mail address does not exist
32:      *      - the amount is <= 0.00 EUR
33:      *      - the payment cannot be processed, because it is over the limit of 500.00 EUR
34:      */
35:     @Override
36:     public UUID authorizePayment( MailAddressType userMailAddress, MoneyType amount ) {
37:         if(userMailAddress == null || userMailAddress.toString() == "") throw new ShopException("User Mail Address is null or empty!");
38:         if(!users.existsByMailAddress(userMailAddress)) throw new ShopException("User does not exist!");
39:         if(amount == null || amount.getAmount() <= 0) throw new ShopException("Amount cannot be <= 0!");
40:         if(amount.getAmount() > 500) throw new ShopException("Amount cannot be > 500!");
41: 
42:         // Save payment in repo
43:         Payment payment = new Payment(userMailAddress.toString(), amount.getAmount());
44:         payments.save(payment);
45:         return payment.getId();
46:     }
47: 
48:     /**
49:      * Returns the total amount of payments (over the complete history) for a user
50:      * (identified by his/her mail address)
51:      * @param userMailAddress
52:      * @return the total amount of payments for the user with the given mailAddress,
53:      *         or 0.00 EUR if the user has not made any payments yet.
54:      * @throws ShopException if ...
55:      *      - userMailAddress is null or empty
56:      *      - the user with the given mailAddress does not exist
57:      */
58:     @Override
59:     public MoneyType getPaymentTotal(MailAddressType userMailAddress) {
60:         if(userMailAddress == null || userMailAddress.toString() == "") throw new ShopException("User Mail Address is null or empty!");
61:         if(!users.existsByMailAddress(userMailAddress)) throw new ShopException("User does not exist!");
62: 
63:         Float sum = 0f;
64:         for (Payment payment: payments.findAll()) {
65:             if(payment.getMailAddress() == userMailAddress.toString()) sum += payment.getAmount();
66:         }
67:         return Money.of(sum, "EUR");
68:     }
69: 
70:     /**
71:      * Deletes all payment history, for all users.
72:      */
73:     @Override
74:     public void deletePaymentHistory() {
75:         payments.deleteAll();
76:     }
77: }
78: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\payment\domain\Payment.java ---
1: package thkoeln.archilab.ecommerce.solution.payment.domain;
2: 
3: import lombok.Getter;
4: import lombok.Setter;
5: 
6: import javax.persistence.Id;
7: import java.util.UUID;
8: 
9: @Getter @Setter
10: public class Payment {
11:     @Id
12:     private final UUID id = UUID.randomUUID();
13:     private String mailAddress;
14:     private Float amount;
15: 
16:     public Payment(String mailAddress, Float amount) {
17:         this.mailAddress = mailAddress;
18:         this.amount = amount;
19:     }
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\payment\domain\PaymentRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.payment.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: 
6: import java.util.ArrayList;
7: import java.util.HashMap;
8: import java.util.Optional;
9: import java.util.UUID;
10: 
11: @Repository
12: public class PaymentRepository implements CrudRepository<Payment, UUID> {
13: 
14:     public HashMap<UUID, Payment> payments = new HashMap();
15: 
16:     @Override
17:     public <S extends Payment> S save(S s) {
18:         payments.put(s.getId(), s);
19:         return s;
20:     }
21: 
22:     @Override
23:     public <S extends Payment> Iterable<S> saveAll(Iterable<S> iterable) {
24:         for (S payment: iterable) {
25:             payments.put(payment.getId(), payment);
26:         }
27:         return iterable;
28:     }
29: 
30:     @Override
31:     public Optional<Payment> findById(UUID s) {
32:         return Optional.ofNullable(payments.get(s));
33:     }
34: 
35:     @Override
36:     public boolean existsById(UUID s) {
37:         return payments.containsKey(s);
38:     }
39: 
40:     @Override
41:     public Iterable<Payment> findAll() {
42:         return payments.values();
43:     }
44: 
45:     @Override
46:     public Iterable<Payment> findAllById(Iterable<UUID> iterable) {
47:         ArrayList<Payment> data = new ArrayList<Payment>();
48:         for (UUID mail: iterable) {
49:             if(existsById(mail)) data.add(payments.get(mail));
50:         }
51:         return data;
52:     }
53: 
54:     @Override
55:     public long count() {
56:         return payments.size();
57:     }
58: 
59:     @Override
60:     public void deleteById(UUID s) {
61:         if(existsById(s)) payments.remove(s);
62:     }
63: 
64:     @Override
65:     public void delete(Payment payment) {
66:         deleteById(payment.getId());
67:     }
68: 
69:     @Override
70:     public void deleteAll(Iterable<? extends Payment> iterable) {
71:         for (Payment payment: iterable) {
72:             deleteById(payment.getId());
73:         }
74:     }
75: 
76:     @Override
77:     public void deleteAll() {
78:         payments.clear();
79:     }
80: }
81: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\InventoryService.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
6: import thkoeln.archilab.ecommerce.usecases.InventoryManagementUseCases;
7: import thkoeln.archilab.ecommerce.ShopException;
8: 
9: import java.util.Hashtable;
10: import java.util.UUID;
11: 
12: @Service
13: public class InventoryService implements InventoryManagementUseCases {
14: 
15:     public Hashtable<UUID, Integer> inventory = new Hashtable();
16: 
17:     @Autowired
18:     private ProductRepository products;
19:     @Autowired
20:     private ProductConsumerService consumer;
21: 
22:     @Override
23:     public void addToInventory(UUID productId, int addedQuantity) {
24:         if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
25:         if(addedQuantity <= 0) throw new ShopException("Quantity can't be null or negative!");
26: 
27:         if(inventory.get(productId) == null) {
28:             inventory.put(productId, addedQuantity);
29:         }
30:         else {
31:             inventory.put(productId, inventory.get(productId) + addedQuantity);
32:         }
33:     }
34: 
35:     @Override
36:     public void removeFromInventory(UUID productId, int removedQuantity) {
37:         if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
38:         if(removedQuantity <= 0)  throw new ShopException("The removed quantity is null or negative!");
39: 
40:         int reservedInventory = consumer.getReservedProductAmount(productId);
41:         int inventoryQuantity = (inventory.get(productId) == null ? 0 : inventory.get(productId));
42:         int reservedQuantity = reservedInventory;
43: 
44:         if(removedQuantity > (inventoryQuantity + reservedQuantity))  throw new ShopException("The removed quantity is too big!");
45: 
46:         int newQuantity = inventoryQuantity - removedQuantity;
47: 
48:         int diffQuantity = reservedInventory - newQuantity;
49:         if(newQuantity < reservedInventory) {
50:             // Correct the reserved quantities
51:             while(diffQuantity > 0) {
52:                 for (UUID id: consumer.getAllIds()) {
53:                     if(diffQuantity == 0) return;
54:                     if(consumer.existsById(id)) {
55:                         if(consumer.getProductQuantity(id, productId) > 0) {
56:                             consumer.addProduct(id, productId, -1);
57:                             diffQuantity--;
58:                         }
59:                     }
60:                 }
61:             }
62:         }
63:         inventory.put(productId, newQuantity);
64:     }
65:  /**
66:      * Changes the total quantity of a given product in the inventory.
67:      * If the new total quantity is lower than the currently reserved products, some of currently reserved products
68:      * (in the users' shopping baskets) are removed. This means that some of the reserved products are lost for
69:      * the user. (This is necessary because there probably was a mistake in the inventory management, a mis-counting,
70:      * or some of the products were stolen from the warehouse, are broken, etc.)
71:      * @param productId
72:      * @param newTotalQuantity
73:      * @throws ShopException if ...
74:      *      - the product id does not exist
75:      *      - if the new total quantity is negative
76:      */
77:     @Override
78:     public void changeInventoryTo(UUID productId, int newTotalQuantity) {
79:         if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
80:         if(newTotalQuantity < 0)  throw new ShopException("The new total quantity is negative!");
81: 
82:         // If the new total quantity is lower than the currently reserved products, some of currently reserved products
83:         //     * (in the users' shopping baskets) are removed
84:         if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
85:         int reservedInventory = consumer.getReservedProductAmount(productId);
86:         int diffQuantity = reservedInventory - newTotalQuantity;
87:         if(newTotalQuantity < reservedInventory) {
88:             // Correct the reserved quantities
89:             while(diffQuantity > 0) {
90:                 for (UUID id: consumer.getAllIds()) {
91:                     if(diffQuantity == 0) return;
92:                     if(consumer.existsById(id)) {
93:                         if(consumer.getProductQuantity(id, productId) > 0) {
94:                             consumer.addProduct(id, productId, -1);
95:                             diffQuantity--;
96:                         }
97:                     }
98:                 }
99:             }
100:         }
101:         // Changes the total quantity of a given product in the inventory.
102:         inventory.put(productId, newTotalQuantity);
103:     }
104: 
105:     @Override
106:     public int getAvailableInventory(UUID productId) {
107:         if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
108:         if(inventory.get(productId) == null) return 0;
109:         int reservedInventory = consumer.getReservedProductAmount(productId);
110:         return inventory.get(productId) - reservedInventory;
111:     }
112: }
113: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductCatalogService.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
7: import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
8: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
10: 
11: import java.util.Hashtable;
12: import java.util.UUID;
13: 
14: @Service
15: public class ProductCatalogService implements ProductCatalogUseCases {
16: 
17:     @Autowired
18:     private ProductRepository products;
19:     @Autowired
20:     private InventoryService inventory;
21:     @Autowired
22:     private ProductConsumerService consumer;
23: 
24:     @Override
25:     public void addProductToCatalog(UUID productId, String name, String description, Float size, MoneyType purchasePrice, MoneyType sellPrice) {
26:         // Validierungen
27:         if(productId == null) throw new ShopException("ProductId is null!");
28:         if(products.existsById(productId)) throw new ShopException("This product already exists!");
29:         if(name == null || name == "") throw new ShopException("Name is null or empty!");
30:         if(description == null || description == "") throw new ShopException("Description is null or empty!");
31:         if(size != null && size <= 0) throw new ShopException("Size can't be negative!");
32:         if(purchasePrice == null || purchasePrice.getAmount() <= 0) throw new ShopException("Purchase Price can't be negative or null!");
33:         if(sellPrice == null || sellPrice.getAmount() <= 0) throw new ShopException("Sell Price can't be negative or null!");
34:         if(sellPrice.getAmount() < purchasePrice.getAmount()) throw new ShopException("Sell Price can't be lower than Purchase Price!");
35: 
36:         // Add product
37:         Product newProduct = new Product(productId, name, description, size, purchasePrice, sellPrice);
38:         products.save(newProduct);
39:     }
40: 
41:     @Override
42:     public void removeProductFromCatalog(UUID productId) {
43:         if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
44:         if((inventory.inventory.get(productId) == null ? 0 : inventory.inventory.get(productId)) > 0) throw new ShopException("This product is still in inventory!");
45:         if(consumer.getReservedProductAmount(productId) > 0) throw new ShopException("This product is still reserved in a shopping basket!");
46:         products.deleteById(productId);
47:     }
48: 
49:     @Override
50:     public MoneyType getSellPrice(UUID productId) {
51:         if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
52:         return products.findById(productId).get().getSellPrice();
53:     }
54: 
55:     @Override
56:     public void deleteProductCatalog() {
57:         consumer.deleteAll();
58:         inventory.inventory = new Hashtable();
59:         products.deleteAll();
60:     }
61: }
62: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductConsumerService.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: import org.springframework.stereotype.Service;
3: 
4: import java.util.Set;
5: import java.util.UUID;
6: 
7: @Service
8: public abstract class ProductConsumerService {
9:     public abstract int getProductQuantity(UUID consumerId, UUID productId);
10:     public abstract void addProduct(UUID consumerId, UUID productId, int amount);
11:     public abstract boolean existsById(UUID s);
12:     public abstract long count();
13:     public abstract void deleteById(UUID s);
14:     public abstract Set<UUID> getAllIds();
15:     public abstract void deleteAll();
16:     public abstract int getReservedProductAmount(UUID productId);
17: }
18: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductUserService.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: 
6: @Service
7: public abstract class ProductUserService {
8:     public abstract boolean existsByMailAddress(MailAddressType mailAddress);
9: }
10: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\Product.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import lombok.Getter;
4: import lombok.Setter;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import javax.persistence.*;
8: import java.util.UUID;
9: 
10: @Getter
11: @Setter
12: @Entity
13: public class Product {
14:     @Id
15:     private final UUID id;
16:     private String name;
17:     private String description;
18:     private Float size;
19:     @Embedded
20:     private MoneyType purchasePrice;
21:     @Embedded
22:     private MoneyType sellPrice;
23: 
24:     private Product() {
25:         this.id = UUID.randomUUID();
26:     }
27: 
28:     public Product(UUID productId, String name, String description, Float size,
29:                    MoneyType purchasePrice, MoneyType sellPrice) {
30:         this.id = productId;
31:         this.name = name;
32:         this.description = description;
33:         this.size = size;
34:         this.purchasePrice = purchasePrice;
35:         this.sellPrice = sellPrice;
36:     }
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: 
6: import java.util.ArrayList;
7: import java.util.HashMap;
8: import java.util.Optional;
9: import java.util.UUID;
10: 
11: @Repository
12: public class ProductRepository implements CrudRepository<Product, UUID> {
13: 
14:     public HashMap<UUID, Product> products = new HashMap();
15: 
16:     @Override
17:     public <S extends Product> S save(S s) {
18:         products.put(s.getId(), s);
19:         return s;
20:     }
21: 
22:     @Override
23:     public <S extends Product> Iterable<S> saveAll(Iterable<S> iterable) {
24:         for (S product: iterable) {
25:             products.put(product.getId(), product);
26:         }
27:         return iterable;
28:     }
29: 
30:     @Override
31:     public Optional<Product> findById(UUID s) {
32:         return Optional.ofNullable(products.get(s));
33:     }
34: 
35:     @Override
36:     public boolean existsById(UUID s) {
37:         return products.containsKey(s);
38:     }
39: 
40:     @Override
41:     public Iterable<Product> findAll() {
42:         return products.values();
43:     }
44: 
45:     @Override
46:     public Iterable<Product> findAllById(Iterable<UUID> iterable) {
47:         ArrayList<Product> data = new ArrayList<Product>();
48:         for (UUID mail: iterable) {
49:             if(existsById(mail)) data.add(products.get(mail));
50:         }
51:         return data;
52:     }
53: 
54:     @Override
55:     public long count() {
56:         return products.size();
57:     }
58: 
59:     @Override
60:     public void deleteById(UUID s) {
61:         if(existsById(s)) products.remove(s);
62:     }
63: 
64:     @Override
65:     public void delete(Product product) {
66:         deleteById(product.getId());
67:     }
68: 
69:     @Override
70:     public void deleteAll(Iterable<? extends Product> iterable) {
71:         for (Product product: iterable) {
72:             deleteById(product.getId());
73:         }
74:     }
75: 
76:     @Override
77:     public void deleteAll() {
78:         products.clear();
79:     }
80: }
81: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketConsumerService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.product.application.ProductConsumerService;
6: import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
7: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
8: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
9: 
10: import java.util.HashSet;
11: import java.util.Set;
12: import java.util.UUID;
13: 
14: @Service
15: public class ShoppingBasketConsumerService extends ProductConsumerService {
16: 
17:     @Autowired
18:     private ShoppingBasketRepository shoppingBaskets;
19:     @Autowired
20:     private ProductRepository products;
21: 
22:     @Override
23:     public int getProductQuantity(UUID consumerId, UUID productId) {
24:         if(!shoppingBaskets.existsById(consumerId)) {
25:             return 0;
26:         }
27:         else {
28:             return shoppingBaskets.findById(consumerId).get().getProductQuantity(productId);
29:         }
30:     }
31: 
32:     @Override
33:     public void addProduct(UUID consumerId, UUID productId, int amount) {
34:         if(shoppingBaskets.existsById(consumerId)) {
35:             ShoppingBasket basket = shoppingBaskets.findById((consumerId)).get();
36:             if(basket.getProductQuantity(productId) > 0) {
37:                 basket.addProduct(products.findById(productId).get(), amount);
38:                 shoppingBaskets.save(basket);
39:             }
40:         }
41:     }
42: 
43:     @Override
44:     public boolean existsById(UUID s) {
45:         return shoppingBaskets.existsById(s);
46:     }
47: 
48:     @Override
49:     public long count() {
50:         return shoppingBaskets.count();
51:     }
52: 
53:     @Override
54:     public void deleteById(UUID s) {
55:         shoppingBaskets.deleteById(s);
56:     }
57: 
58:     @Override
59:     public Set<UUID> getAllIds() {
60:         HashSet<UUID> keys = new HashSet();
61:         for (ShoppingBasket shoppingBasket : shoppingBaskets.findAll()) {
62:             keys.add(shoppingBasket.getShoppingBasketId());
63:         }
64:         return keys;
65:     }
66: 
67:     @Override
68:     public void deleteAll() {
69:         shoppingBaskets.deleteAll();
70:     }
71: 
72:     @Override
73:     public int getReservedProductAmount(UUID productId) {
74:         return shoppingBaskets.getReservedProductAmount(productId);
75:     }
76: }
77: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.http.HttpStatus;
5: import org.springframework.http.ResponseEntity;
6: import org.springframework.web.bind.annotation.*;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.solution.dtos.ShoppingBasketDto;
9: import thkoeln.archilab.ecommerce.solution.dtos.ShoppingBasketPositionDto;
10: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPositionRepository;
11: import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
12: import thkoeln.archilab.ecommerce.solution.product.application.InventoryService;
13: import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
14: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
15: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
16: 
17: import java.util.UUID;
18: import java.util.stream.StreamSupport;
19: 
20: @RestController
21: public class ShoppingBasketController {
22: 
23:     @Autowired
24:     public ShoppingBasketRepository shoppingBaskets;
25:     @Autowired
26:     public ProductRepository products;
27:     @Autowired
28:     public InventoryService inventory;
29:     @Autowired
30:     public ShoppingBasketService shoppingBasketService;
31:     @Autowired
32:     public OrderRepository orders;
33: 
34: 
35:     //Return the shopping basket for a specific user with mailAddress
36:     @GetMapping("/shoppingBaskets")
37:     ResponseEntity<ShoppingBasketDto> findShoppingBasketByMailAddress(@RequestParam(required = false) String mailAddress) {
38:         if(!StreamSupport.stream(shoppingBaskets.findAll().spliterator(), false)
39:                 .anyMatch(e -> e.getMailAddress().toString().equals(mailAddress))) {
40:             return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
41:         }
42: 
43:         var shoppingBasket = StreamSupport.stream(shoppingBaskets.findAll().spliterator(), false)
44:                 .filter(e -> e.getMailAddress().toString().equals(mailAddress)).findFirst().get();
45: 
46:         if(shoppingBasket == null) return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
47: 
48:         int totalQuantity = shoppingBasket.getPositions().stream().mapToInt(ShoppingBasketPosition::getQuantity).sum();
49:         ShoppingBasketDto result = new ShoppingBasketDto(shoppingBasket.getShoppingBasketId(), shoppingBasket.getMailAddress(), totalQuantity);
50:         return new ResponseEntity<>(result, HttpStatus.OK);
51:     }
52: 
53:     //For a specific shopping basket, add/remove a certain quantity of products
54:     @PostMapping("/shoppingBaskets/{shoppingBasket-id}/shoppingBasketPositions")
55:     ResponseEntity<ShoppingBasketDto> modifyShoppingBasket(@PathVariable("shoppingBasket-id") UUID shoppingBasketId,
56:                                                            @RequestBody ShoppingBasketPositionDto newPos) {
57:         if(!shoppingBaskets.existsById(shoppingBasketId)) return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
58:         if(!products.existsById(newPos.getProductId())) return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
59: 
60:         var shoppingBasket = shoppingBaskets.findById(shoppingBasketId).get();
61:         if(newPos.getQuantity() > 0) {
62:             if(inventory.getAvailableInventory(newPos.getProductId()) < newPos.getQuantity())
63:                 return new ResponseEntity<>(null, HttpStatus.CONFLICT);
64: 
65:             var positions = shoppingBasket.getPositions();
66:             // Produkt liegt noch nicht im Warenkorb
67:             if(!positions.stream().anyMatch(e -> e.getProduct().getId().equals(newPos.getProductId()))) {
68:                 shoppingBasket.addProduct(products.findById(newPos.getProductId()).get(), newPos.getQuantity(), newPos.getComment());
69:                 shoppingBaskets.save(shoppingBasket);
70:                 return new ResponseEntity<>(null, HttpStatus.CREATED);
71:             }
72:             // Produkt liegt bereits im Warenkorb
73:             else {
74:                 var pos = positions.stream().filter(e -> e.getProduct().getId().equals(newPos.getProductId())).findFirst().get();
75:                 pos.setQuantity(pos.getQuantity() + newPos.getQuantity());
76:                 pos.setComment(newPos.getComment());
77:                 positions.removeIf(e -> e.getProduct().getId().equals(pos.getProduct().getId()));
78:                 positions.add(pos);
79:                 shoppingBasket.setPositions(positions);
80:             }
81:         }
82:         else {
83:             // Produkt existiert nicht im Warenkorb, kann nicht entfernt werden => Conflict
84:             if(!shoppingBasket.getPositions().stream().anyMatch(e -> e.getProduct().getId().equals(newPos.getProductId()))) {
85:                 return new ResponseEntity<>(null, HttpStatus.CONFLICT);
86:             }
87:             // Produktmenge wird reduziert
88:             else {
89:                 var pos = shoppingBasket.getPositions().stream().filter(e -> e.getProduct().getId().equals(newPos.getProductId())).findFirst().get();
90:                 pos.setQuantity(pos.getQuantity() + newPos.getQuantity());
91:                 pos.setComment(newPos.getComment());
92: 
93:                 if(pos.getQuantity() < 0) return new ResponseEntity<>(null, HttpStatus.CONFLICT);
94:                 if(pos.getQuantity() == 0) shoppingBasket.getPositions().removeIf(e -> e.getProduct().getId().equals(newPos.getProductId()));
95:             }
96:         }
97:         shoppingBaskets.save(shoppingBasket);
98:         return new ResponseEntity<>(null, HttpStatus.CREATED);
99:     }
100: 
101:     //For a specific shopping basket, delete the shopping basket position for this product
102:     @DeleteMapping("/shoppingBaskets/{shoppingBasket-id}/shoppingBasketPositions/{product-id}")
103:     ResponseEntity<ShoppingBasketDto> deletePosition(@PathVariable("shoppingBasket-id") UUID shoppingBasketId,
104:                                                      @PathVariable("product-id") UUID productId) {
105:         if(shoppingBasketId == null || productId == null) return new ResponseEntity<>(null, HttpStatus.UNPROCESSABLE_ENTITY);
106:         if(!shoppingBaskets.existsById(shoppingBasketId)) return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
107:         if(!products.existsById(productId)) return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
108: 
109:         var shoppingBasket = shoppingBaskets.findById(shoppingBasketId).get();
110:         if(!shoppingBasket.getPositions().stream().anyMatch(e -> e.getProduct().getId().equals(productId)))
111:             return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
112: 
113:         shoppingBasket.getPositions().removeIf(e -> e.getProduct().getId().equals(productId));
114:         shoppingBaskets.save(shoppingBasket);
115:         return new ResponseEntity<>(null, HttpStatus.OK);
116:     }
117: 
118:     //For a specific shopping basket and product, get quantity and comment
119:     @GetMapping("/shoppingBaskets/{shoppingBasket-id}/shoppingBasketPositions/{product-id}")
120:     ResponseEntity<ShoppingBasketPositionDto> getPosition(@PathVariable("shoppingBasket-id") UUID shoppingBasketId,
121:                                                      @PathVariable("product-id") UUID productId) {
122:         if(shoppingBasketId == null || productId == null) return new ResponseEntity<>(null, HttpStatus.UNPROCESSABLE_ENTITY);
123:         if(!shoppingBaskets.existsById(shoppingBasketId)) return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
124:         if(!products.existsById(productId)) return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
125: 
126:         var shoppingBasket = shoppingBaskets.findById(shoppingBasketId).get();
127:         if(!shoppingBasket.getPositions().stream().anyMatch(e -> e.getProduct().getId().equals(productId)))
128:             return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
129: 
130:         var pos = shoppingBasket.getPositions().stream().filter(e -> e.getProduct().getId().equals(productId)).findFirst().get();
131:         return new ResponseEntity<>(new ShoppingBasketPositionDto(pos.getProduct().getId(), pos.getQuantity(), pos.getComment()), HttpStatus.OK);
132:     }
133: 
134:     //For a specific shopping basket and product, get quantity and comment
135:     @PutMapping("/shoppingBaskets/{shoppingBasket-id}/checkout")
136:     ResponseEntity checkout(@PathVariable("shoppingBasket-id") UUID shoppingBasketId)
137:     {
138:         if(shoppingBasketId == null) return new ResponseEntity<>(null, HttpStatus.UNPROCESSABLE_ENTITY);
139:         if(!shoppingBaskets.existsById(shoppingBasketId)) return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
140: 
141:         var shoppingBasket = shoppingBaskets.findById(shoppingBasketId).get();
142:         if(shoppingBasket.getPositions().stream().mapToInt(e -> e.getQuantity()).sum() > 20)
143:             return new ResponseEntity<>(null, HttpStatus.CONFLICT);
144:         if(shoppingBasket.getPositions().stream().mapToDouble(e -> e.getProduct().getSellPrice().getAmount() * e.getQuantity()).sum() > 500)
145:             return new ResponseEntity<>(null, HttpStatus.CONFLICT);
146:         if(shoppingBasket.getPositions().stream().count() == 0)
147:             return new ResponseEntity<>(null, HttpStatus.CONFLICT);
148: 
149:         try {
150:             shoppingBasketService.checkout(shoppingBasket.getMailAddress());
151:         }
152:         catch (ShopException ex) {
153:             return new ResponseEntity<>(null, HttpStatus.UNPROCESSABLE_ENTITY);
154:         }
155:         return new ResponseEntity<>(null , HttpStatus.OK);
156:     }
157: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.Money;
6: import thkoeln.archilab.ecommerce.solution.delivery.application.DeliveryService;
7: import thkoeln.archilab.ecommerce.solution.payment.application.PaymentService;
8: import thkoeln.archilab.ecommerce.solution.order.domain.*;
9: import thkoeln.archilab.ecommerce.solution.product.application.InventoryService;
10: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
11: import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
12: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
13: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
14: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketState;
15: import thkoeln.archilab.ecommerce.solution.user.domain.User;
16: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
17: import thkoeln.archilab.ecommerce.ShopException;
18: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
19: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
20: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
21: 
22: import java.util.HashMap;
23: import java.util.Map;
24: import java.util.UUID;
25: 
26: @Service
27: public class ShoppingBasketService implements ShoppingBasketUseCases {
28: 
29:     // Repositories
30:     @Autowired
31:     private ProductRepository products;
32:     @Autowired
33:     private UserRepository users;
34:     @Autowired
35:     private OrderRepository orders;
36:     @Autowired
37:     private OrderPositionRepository orderPositions;
38:     @Autowired
39:     private ShoppingBasketRepository shoppingBaskets;
40: 
41:     // Services
42:     @Autowired
43:     private InventoryService inventory;
44:     @Autowired
45:     private DeliveryService deliveryService;
46:     @Autowired
47:     private PaymentService paymentService;
48: 
49:     @Override
50:     public void addProductToShoppingBasket(MailAddressType userMailAddress, UUID productId, int quantity) {
51:         if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
52:         if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
53:         if(quantity < 0) throw new ShopException("Quantity can't be negative!");
54:         if(inventory.getAvailableInventory(productId) < quantity) throw new ShopException("product is not available in the requested quantity");
55: 
56:         if(!shoppingBaskets.existsByMailAddress(userMailAddress)) {
57:             ShoppingBasket basket = new ShoppingBasket(userMailAddress);
58:             shoppingBaskets.save(basket);
59:         }
60:         ShoppingBasket basket = shoppingBaskets.findByMailAddress(userMailAddress).get();
61:         basket.addProduct(products.findById(productId).get(), quantity);
62:         shoppingBaskets.save(basket);
63:     }
64: 
65:     @Override
66:     public void removeProductFromShoppingBasket(MailAddressType userMailAddress, UUID productId, int quantity) {
67:         if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
68:         if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
69:         if(quantity < 0) throw new ShopException("Quantity can't be negative!");
70: 
71:         if(!shoppingBaskets.existsByMailAddress(userMailAddress)) {
72:             ShoppingBasket basket = new ShoppingBasket(userMailAddress);
73:             shoppingBaskets.save(basket);
74:         }
75:         ShoppingBasket basket = shoppingBaskets.findByMailAddress(userMailAddress).get();
76:         if(basket.getProductQuantity(productId) < quantity) throw new ShopException("Product is not in the cart in the requested quantity");
77:         basket.addProduct(products.findById(productId).get(), -quantity);
78:         shoppingBaskets.save(basket);
79:     }
80: 
81:     @Override
82:     public Map<UUID, Integer> getShoppingBasketAsMap(MailAddressType userMailAddress) {
83:         if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
84:         if(!shoppingBaskets.existsByMailAddress(userMailAddress)) {
85:             ShoppingBasket basket = new ShoppingBasket(userMailAddress);
86:             shoppingBaskets.save(basket);
87:         }
88:         ShoppingBasket basket = shoppingBaskets.findByMailAddress(userMailAddress).get();
89: 
90:         HashMap<UUID, Integer> result = new HashMap();
91:         for (var pos: basket.getPositions()) {
92:             result.put(pos.getProduct().getId(), pos.getQuantity());
93:         }
94:         return result;
95:     }
96: 
97:     @Override
98:     public MoneyType getShoppingBasketAsMoneyValue(MailAddressType userMailAddress) {
99:         if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
100:         Map<UUID, Integer> productsInCart = getShoppingBasketAsMap(userMailAddress);
101:         MoneyType cartValue = null;
102:         for (UUID productId: productsInCart.keySet()) {
103:             Product product = products.findById(productId).get();
104:             MoneyType price = Money.of(product.getSellPrice().getAmount() * productsInCart.get(productId), product.getSellPrice().getCurrency());
105:             if(cartValue == null)
106:             {
107:                 cartValue = Money.of(price.getAmount(), price.getCurrency());
108:             }
109:             else {
110:                 cartValue = cartValue.add(price);
111:             }
112:         }
113:         return cartValue;
114:     }
115: 
116:     @Override
117:     public int getReservedInventoryInShoppingBaskets(UUID productId) {
118:         if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
119:         return shoppingBaskets.getReservedProductAmount(productId);
120:     }
121: 
122:     /**
123:      * Checks if the shopping basket of a user is empty
124:      *
125:      * @param userMailAddress
126:      * @return true if the shopping basket is empty, false otherwise
127:      * @throws ShopException if ...
128:      *    - the mail address is null or empty
129:      *    - the user with the given mail address does not exist
130:      */
131:     @Override
132:     public boolean isEmpty(MailAddressType userMailAddress) {
133:         if(userMailAddress == null || userMailAddress.toString() == "") throw new ShopException("User Mail Address is null or empty!");
134:         if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
135: 
136:         if(!shoppingBaskets.existsByMailAddress(userMailAddress)) return true;
137:         if(shoppingBaskets.findByMailAddress(userMailAddress).get().isEmpty()) return true;
138:         return false;
139:     }
140: 
141:     /**
142:      * Checks if the payment for a specific shopping basket of a user has been authorized to be paid,
143:      * i.e. the shopping basket is not empty, the user has given his/her payment details, and the payment
144:      * has been authorized (under the limits of the user's credit card). However, the order
145:      * has not yet been placed yet, and the logistics details (delivery address) have not yet been given.
146:      *
147:      * @param userMailAddress
148:      * @return true if the payment has been authorized, false otherwise
149:      * @throws ShopException if ...
150:      *   - the mail address is null or empty
151:      *   - the user with the given mail address does not exist
152:      */
153:     @Override
154:     public boolean isPaymentAuthorized(MailAddressType userMailAddress) {
155:         if(userMailAddress == null || userMailAddress.toString() == "") throw new ShopException("User Mail Address is null or empty!");
156:         if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
157: 
158:             if (!shoppingBaskets.existsByMailAddress(userMailAddress)) return false;
159:             ShoppingBasket shoppingBasket = shoppingBaskets.findByMailAddress(userMailAddress).get();
160: 
161:             if(shoppingBasket.getState() == ShoppingBasketState.AUTHORIZED) return true;
162: 
163:             return false;
164:     }
165:     private User validateCheckoutUser(MailAddressType userMailAddress) {
166:         if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
167:         User user = users.findById(userMailAddress.toString()).get();
168:         return user;
169:     }
170:     private ShoppingBasket validateCheckoutBasket(MailAddressType mail) {
171:         if(!shoppingBaskets.existsByMailAddress(mail)) {
172:             ShoppingBasket basket = new ShoppingBasket(mail);
173:             shoppingBaskets.save(basket);
174:         }
175:         ShoppingBasket basket = shoppingBaskets.findByMailAddress(mail).get();
176:         if(basket.isEmpty()) throw new ShopException("This Basket is Empty");
177:         return basket;
178:     }
179: 
180:     @Override
181:     public void checkout(MailAddressType userMailAddress) {
182:         validateCheckoutUser(userMailAddress);
183:         ShoppingBasket basket = validateCheckoutBasket(userMailAddress);
184: 
185:         MoneyType totalPrice = null;
186:         for (var position: basket.getPositions()) {
187:             MoneyType price = Money.of(position.getProduct().getSellPrice().getAmount() * position.getQuantity(), position.getProduct().getSellPrice().getCurrency());
188:             if(totalPrice == null) totalPrice = Money.of(price.getAmount(), price.getCurrency());
189:             else  totalPrice = totalPrice.add(price);
190:         }
191: 
192:         if(!isPaymentAuthorized(userMailAddress)) {
193:             basket.setState(ShoppingBasketState.AUTHORIZED);
194:             shoppingBaskets.save(basket);
195:         }
196:         basket.setState(ShoppingBasketState.DELIVERED);
197:         shoppingBaskets.save(basket);
198: 
199:         Order newOrder = new Order(userMailAddress, totalPrice); // Create new Order
200:         orders.save(newOrder);
201:         for (var position: basket.getPositions()) { // Create Order positions
202:             if(position.getQuantity() > 0) {
203:                 OrderPosition newPos = new OrderPosition(newOrder, position.getProduct(), position.getQuantity(), position.getComment()); // Add position to order
204:                 orderPositions.save(newPos);
205:                 inventory.removeFromInventory(newPos.getProduct().getId(), newPos.getQuantity()); // Remove from inventory
206:             }
207:         }
208:         shoppingBaskets.deleteByMailAddress(userMailAddress);
209:         shoppingBaskets.save(new ShoppingBasket(userMailAddress));
210:     }
211: 
212:     @Override
213:     /**
214:      * Returns a map showing which products have been ordered by a user and how many of each product
215:      *
216:      * @param userMailAddress
217:      * @return the order history of the user (map is empty if the user has not ordered anything yet)
218:      * @throws ShopException if the user with the given mailAddress does not exist
219:      */
220:     public Map<UUID, Integer> getOrderHistory(MailAddressType userMailAddress) {
221:         if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
222:         HashMap<UUID, Integer> result = new HashMap();
223: 
224:         // Get all orders
225:         for (Order order: orders.findAll()) {
226:             // check if order is from this user
227:             if(order.getMailAddress() == userMailAddress) {
228:                 // check all positions
229:                 for (OrderPosition pos : orderPositions.findAll()) {
230:                     // Check if position matches order
231:                     if(pos.getOrder().getId() != order.getId()) continue;
232:                     // if product is in result, then summarize
233:                     if(result.containsKey(pos.getProduct().getId())) {
234:                         result.put(pos.getProduct().getId(), result.get(pos.getProduct().getId()) + pos.getQuantity());
235:                     }
236:                     // else if product is not in result, then add
237:                     else {
238:                         result.put(pos.getProduct().getId(), pos.getQuantity());
239:                     }
240:                 }
241:             }
242:         }
243: 
244:         return result;
245:     }
246: 
247:     @Override
248:     /**
249:      * Deletes all orders and shopping baskets in the system
250:      */
251:     public void deleteAllOrders() {
252:         orders.deleteAll();
253:         shoppingBaskets.deleteAll();
254: 
255:     }
256: 
257: 
258:     @Override
259:     /**
260:      * Sets a comment in the shopping basket position containing a product
261:      *
262:      * @param userMailAddress
263:      * @param productId
264:      * @param comment (can be null)
265:      * @throws ShopException if ...
266:      *      - userMailAddress is null,
267:      *      - the user with the given mailAddress does not exist,
268:      *      - the product does not exist
269:      *      - the product is not in the shopping basket
270:      */
271:     public void setCommentForShoppingBasketPosition( MailAddressType userMailAddress, UUID productId, String comment ) {
272:         if(userMailAddress == null || userMailAddress.toString() == "") throw new ShopException("Mail Address is null or empty!");
273:         if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
274:         if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
275: 
276:         var shoppingBasket = shoppingBaskets.findByMailAddress(userMailAddress).get();
277: 
278:         var position = shoppingBasket.getPositions().stream().filter(e -> e.getProduct().getId() == productId).findFirst().get();
279:         if(position == null || position.getQuantity() == 0)
280:             throw new ShopException("Product is not in the shopping basket!");
281: 
282:         var posIndex = shoppingBasket.getPositions().indexOf(position);
283:         shoppingBasket.getPositions().get(posIndex).setComment(comment);
284:         shoppingBaskets.save(shoppingBasket);
285:     }
286: 
287:     @Override
288:     /**
289:      * Returns the comment in the shopping basket position containing a product
290:      *
291:      * @param userMailAddress
292:      * @param productId
293:      * @return the comment (can be null)
294:      * @throws ShopException if ...
295:      *      - userMailAddress is null,
296:      *      - the user with the given mailAddress does not exist,
297:      *      - the product does not exist
298:      *      - the product is not in the shopping basket
299:      */
300:     public String getCommentForShoppingBasketPosition( MailAddressType userMailAddress, UUID productId ) {
301:         if(userMailAddress == null || userMailAddress.toString() == "") throw new ShopException("Mail Address is null or empty!");
302:         if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
303:         if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
304: 
305:         var shoppingBasket = shoppingBaskets.findByMailAddress(userMailAddress).get();
306: 
307:         var position = shoppingBasket.getPositions().stream().filter(e -> e.getProduct().getId() == productId).findFirst().get();
308:         if(position == null || position.getQuantity() == 0)
309:             throw new ShopException("Product is not in the shopping basket!");
310: 
311:         return position.getComment();
312:     }
313: }
314: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\UserShoppingBasketService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
7: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
8: import thkoeln.archilab.ecommerce.solution.user.application.UserShoppingBasketBase;
9: 
10: @Service
11: public class UserShoppingBasketService extends UserShoppingBasketBase {
12: 
13:     @Autowired
14:     private ShoppingBasketRepository shoppingBaskets;
15: 
16:     @Override
17:     public void createBasketByMail(MailAddress mailAddress) {
18:         shoppingBaskets.save(new ShoppingBasket(mailAddress));
19:     }
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import lombok.Getter;
4: import lombok.Setter;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
8: 
9: import javax.persistence.Embedded;
10: import javax.persistence.Entity;
11: import javax.persistence.Id;
12: import java.util.ArrayList;
13: import java.util.UUID;
14: 
15: @Getter
16: @Setter
17: @Entity
18: public class ShoppingBasket {
19:     @Id
20:     private final UUID shoppingBasketId = UUID.randomUUID();
21:     private ArrayList<ShoppingBasketPosition> positions = new ArrayList();
22:     private ShoppingBasketState state = ShoppingBasketState.EMPTY;
23:     @Embedded
24:     private final MailAddress mailAddress;
25: 
26:     private ShoppingBasket() {
27:         mailAddress = null;
28:     }
29: 
30:     public ShoppingBasket(MailAddressType mailAddress) {
31:         this.mailAddress = MailAddress.of(mailAddress.toString());
32:     }
33: 
34:     public void addProduct(Product product, int quantity) {
35:         addProduct(product, quantity, null);
36:     }
37:     public void addProduct(Product product, int quantity, String comment) {
38:         if(!positions.stream().anyMatch(e -> e.getProduct().getId() == product.getId())) {
39:             positions.add(new ShoppingBasketPosition(product, quantity, comment));
40:         }
41:         else {
42:             var position = positions.stream().filter(e -> e.getProduct().getId() == product.getId()).findFirst().get();
43:             var posIndex = positions.indexOf(position);
44:             positions.get(posIndex).setQuantity(positions.get(posIndex).getQuantity() + quantity);
45:         }
46: 
47:         if(isEmpty()) state = ShoppingBasketState.EMPTY;
48:         else state = ShoppingBasketState.FILLED;
49:     }
50: 
51:     public boolean isEmpty() {
52:         for (ShoppingBasketPosition pos : getPositions()) {
53:             if(pos.getQuantity() > 0) return false;
54:         }
55:         return true;
56:     }
57: 
58:     public Integer getProductQuantity(UUID productId) {
59:         if(!positions.stream().anyMatch(e -> e.getProduct().getId().equals(productId))) return 0;
60:         var position = positions.stream().filter(e -> e.getProduct().getId().equals(productId)).findFirst().get();
61:         return position == null ? 0 : position.getQuantity();
62:     }
63: }
64: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import lombok.Getter;
4: import lombok.NoArgsConstructor;
5: import lombok.Setter;
6: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
7: 
8: import javax.persistence.Entity;
9: import javax.persistence.Id;
10: import javax.persistence.ManyToOne;
11: import java.time.LocalDateTime;
12: import java.util.UUID;
13: 
14: @Getter @Setter
15: @NoArgsConstructor
16: @Entity
17: public class ShoppingBasketPosition {
18:     @Id
19:     private final UUID uuid = UUID.randomUUID();
20:     @ManyToOne
21:     private Product product;
22:     private int quantity;
23:     private String comment;
24: 
25:     public ShoppingBasketPosition(Product product, int quantity, String comment) {
26:         this.product = product;
27:         this.quantity = quantity;
28:         this.comment = comment;
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
6: 
7: import java.util.*;
8: 
9: @Repository
10: public class ShoppingBasketRepository implements CrudRepository<ShoppingBasket, UUID> {
11: 
12:     public HashMap<UUID, ShoppingBasket> shoppingBaskets = new HashMap();
13: 
14:     @Override
15:     public <S extends ShoppingBasket> S save(S s) {
16:         shoppingBaskets.put(s.getShoppingBasketId(), s);
17:         return s;
18:     }
19: 
20:     @Override
21:     public <S extends ShoppingBasket> Iterable<S> saveAll(Iterable<S> iterable) {
22:         for (S shoppingBasket: iterable) {
23:             shoppingBaskets.put(shoppingBasket.getShoppingBasketId(), shoppingBasket);
24:         }
25:         return iterable;
26:     }
27: 
28:     @Override
29:     public Optional<ShoppingBasket> findById(UUID s) {
30:         return Optional.ofNullable(shoppingBaskets.get(s));
31:     }
32: 
33:     @Override
34:     public boolean existsById(UUID s) {
35:         return shoppingBaskets.containsKey(s);
36:     }
37: 
38:     public boolean existsByMailAddress(MailAddressType mail) {
39:         return shoppingBaskets.values().stream().anyMatch(sb -> Objects.equals(sb.getMailAddress().toString(), mail.toString()));
40:     }
41: 
42:     public Optional<ShoppingBasket> findByMailAddress(MailAddressType mail) {
43:         return shoppingBaskets.values().stream().filter(sb -> Objects.equals(sb.getMailAddress().toString(), mail.toString())).findFirst();
44:     }
45: 
46:     @Override
47:     public Iterable<ShoppingBasket> findAll() {
48:         return shoppingBaskets.values();
49:     }
50: 
51:     @Override
52:     public Iterable<ShoppingBasket> findAllById(Iterable<UUID> iterable) {
53:         ArrayList<ShoppingBasket> data = new ArrayList<ShoppingBasket>();
54:         for (UUID mail: iterable) {
55:             if(existsById(mail)) data.add(shoppingBaskets.get(mail));
56:         }
57:         return data;
58:     }
59: 
60:     @Override
61:     public long count() {
62:         return shoppingBaskets.size();
63:     }
64: 
65:     @Override
66:     public void deleteById(UUID s) {
67:         if(existsById(s)) shoppingBaskets.remove(s);
68:     }
69: 
70:     public void deleteByMailAddress(MailAddressType mail) {
71:         if(existsByMailAddress(mail)) shoppingBaskets.remove(findByMailAddress(mail).get().getShoppingBasketId());
72:     }
73: 
74:     @Override
75:     public void delete(ShoppingBasket shoppingBasket) {
76:         deleteById(shoppingBasket.getShoppingBasketId());
77:     }
78: 
79:     @Override
80:     public void deleteAll(Iterable<? extends ShoppingBasket> iterable) {
81:         for (ShoppingBasket shoppingBasket: iterable) {
82:             deleteById(shoppingBasket.getShoppingBasketId());
83:         }
84:     }
85: 
86:     @Override
87:     public void deleteAll() {
88:         shoppingBaskets.clear();
89:     }
90: 
91:     public int getReservedProductAmount(UUID productId) {
92:         int reservedInventory = 0;
93:         for (ShoppingBasket basket: findAll()) {
94:             if(!basket.getPositions().stream().anyMatch(e -> e != null
95:                     && e.getProduct() != null
96:                     && e.getProduct().getId() != null
97:                     && e.getProduct().getId().equals(productId))) continue;
98:             var position = basket.getPositions().stream().filter(e -> e != null
99:                     && e.getProduct() != null
100:                     && e.getProduct().getId() != null
101:                     && e.getProduct().getId().equals(productId)).findFirst().get();
102:             if(position != null) {
103:                 reservedInventory += position.getQuantity();
104:             }
105:         }
106:         return reservedInventory;
107:     }
108: }
109: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketState.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: public enum ShoppingBasketState {
4:     EMPTY,
5:     FILLED,
6:     AUTHORIZED,
7:     DELIVERED
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserProductService.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.product.application.ProductUserService;
6: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
8: 
9: @Service
10: public class UserProductService extends ProductUserService {
11: 
12:     @Autowired
13:     private UserRepository users;
14: 
15:     @Override
16:     public boolean existsByMailAddress(MailAddressType mailAddress) {
17:        return users.existsById(mailAddress.toString());
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserService.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: import org.springframework.beans.factory.annotation.Autowired;
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.domainprimitives.PersonalAddress;
5: import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;
6: import thkoeln.archilab.ecommerce.domainprimitives.UserTypeImplementation;
7: import thkoeln.archilab.ecommerce.solution.address.domain.Address;
8: import thkoeln.archilab.ecommerce.solution.user.domain.User;
9: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
10: import thkoeln.archilab.ecommerce.ShopException;
11: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
12: import thkoeln.archilab.ecommerce.usecases.UserType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
15: 
16: @Service
17: public class UserService implements UserRegistrationUseCases {
18: 
19:     @Autowired
20:     private UserRepository users;
21:     @Autowired
22:     private UserShoppingBasketBase shoppingBasketService;
23: 
24:     @Override
25:     public void register(String name, MailAddressType mailAddress, PersonalAddressType address) {
26:         // check if user exists
27:         if(mailAddress == null) throw new ShopException("Mail Address is null.");
28:         if(address == null) throw new ShopException("Address is null.");
29:         if(users.existsById(mailAddress.toString())) throw new ShopException("This user is already registered.");
30: 
31:         // register new user
32:         if(name == "" || name == null
33:                 || mailAddress.toString() == "" || mailAddress == null
34:                 || address.getStreet() == "" || address.getStreet() == null
35:                 || address.getCity() == "" || address.getCity() == null
36:                 || address.getPostalCode().toString() == "" || address.getPostalCode() == null)
37:         {
38:             throw new ShopException("Invalid values.");
39:         }
40: 
41:         User newUser = new User(name, mailAddress, address.getStreet(), address.getCity(), address.getPostalCode().toString());
42:         users.save(newUser);
43:         shoppingBasketService.createBasketByMail(newUser.getMailAddress());
44:     }
45: 
46:     @Override
47:     public void changeAddress(MailAddressType userMailAddress, PersonalAddressType personalAddress) {
48:         if(users == null) throw new ShopException("Users is null.");
49:         if(userMailAddress == null) throw new ShopException("Mail Address is null.");
50:         if(personalAddress == null) throw new ShopException("Address is null.");
51: 
52:         // Check if user exists.
53:         if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist.");
54: 
55:         // Check if data is valid.
56:         if(personalAddress.getStreet() == "" || personalAddress.getStreet() == null
57:                 || personalAddress.getCity() == "" || personalAddress.getCity() == null
58:                 || personalAddress.getPostalCode().toString() == "" || personalAddress.getPostalCode().toString() == null)
59:         {
60:             throw new ShopException("Invalid values.");
61:         }
62: 
63:         // Change address.
64:         User user = users.findById(userMailAddress.toString()).get();
65:         user.setAddress(new Address(personalAddress.getStreet(), personalAddress.getCity(), personalAddress.getPostalCode().toString()));
66:         users.save(user);
67:     }
68: 
69:     @Override
70:     public UserType getUserData(MailAddressType userMailAddress) {
71:         // Check if user exists.
72:         if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist.");
73: 
74:         // Get User
75:         User user = users.findById(userMailAddress.toString()).get();
76: 
77:         // Read data
78:         return UserTypeImplementation.of(user.getName(),
79:                 user.getMailAddress(),
80:                 PersonalAddress.of(user.getAddress().getStreet(), user.getAddress().getCity(), PostalCode.of(user.getAddress().getPostalCode())));
81:     }
82: 
83:     @Override
84:     public void deleteAllUsers() {
85:         users.deleteAll();
86:     }
87: }
88: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserShoppingBasketBase.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
4: 
5: public abstract class UserShoppingBasketBase {
6:     public abstract void createBasketByMail(MailAddress mailAddress);
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\User.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import lombok.Getter;
4: import lombok.Setter;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.solution.address.domain.Address;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
8: 
9: import javax.persistence.*;
10: import java.util.UUID;
11: 
12: @Getter
13: @Setter
14: @Entity
15: public class User {
16:     @Id
17:     private final UUID id = UUID.randomUUID();
18:     private String name;
19:     @Embedded
20:     private final MailAddress mailAddress;
21:     @OneToOne
22:     private Address address;
23: 
24:     private User() {
25:         this.mailAddress = null;
26:     }
27: 
28:     public User(String name, MailAddressType mailAddress, String street, String city, String postalCode) {
29:         this.name = name;
30:         this.mailAddress = MailAddress.of(mailAddress.toString());
31:         this.address = new Address(street, city, postalCode);
32:     }
33: }
34: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: 
6: import java.util.ArrayList;
7: import java.util.HashMap;
8: import java.util.Optional;
9: 
10: @Repository
11: public class UserRepository implements CrudRepository<User, String> {
12: 
13:     public HashMap<String, User> users = new HashMap();
14: 
15:     @Override
16:     public <S extends User> S save(S s) {
17:         users.put(s.getMailAddress().toString(), s);
18:         return s;
19:     }
20: 
21:     @Override
22:     public <S extends User> Iterable<S> saveAll(Iterable<S> iterable) {
23:         for (S user: iterable) {
24:             users.put(user.getMailAddress().toString(), user);
25:         }
26:         return iterable;
27:     }
28: 
29:     @Override
30:     public Optional<User> findById(String s) {
31:         return Optional.ofNullable(users.get(s));
32:     }
33: 
34:     @Override
35:     public boolean existsById(String s) {
36:         return users.containsKey(s);
37:     }
38: 
39:     @Override
40:     public Iterable<User> findAll() {
41:         return users.values();
42:     }
43: 
44:     @Override
45:     public Iterable<User> findAllById(Iterable<String> iterable) {
46:         ArrayList<User> data = new ArrayList<User>();
47:         for (String mail: iterable) {
48:             if(existsById(mail)) data.add(users.get(mail));
49:         }
50:         return data;
51:     }
52: 
53:     @Override
54:     public long count() {
55:         return users.size();
56:     }
57: 
58:     @Override
59:     public void deleteById(String s) {
60:         if(existsById(s)) users.remove(s);
61:     }
62: 
63:     @Override
64:     public void delete(User user) {
65:         deleteById(user.getMailAddress().toString());
66:     }
67: 
68:     @Override
69:     public void deleteAll(Iterable<? extends User> iterable) {
70:         for (User user: iterable) {
71:             deleteById(user.getMailAddress().toString());
72:         }
73:     }
74: 
75:     @Override
76:     public void deleteAll() {
77:         users.clear();
78:     }
79: }
80: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\DeliveryUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: 
6: import java.util.Map;
7: import java.util.UUID;
8: 
9: /**
10:  * This interface contains methods needed in the context of use cases dealing with logistics,
11:  * i.e. the delivery of products to a user. It is probably incomplete, and will grow over time.
12:  */
13: public interface DeliveryUseCases {
14:     /**
15:      * Delivers a product to a user. The product is identified by its id, and the user by
16:      * his/her name, street, city and postal code.
17:      * @param deliveryRecipient
18:      * @param deliveryContent - a map of product ids and quantities
19:      * @return the id of the delivery, if successfully triggered
20:      * @throws ShopException if ...
21:      *      - deliveryRecipient is null
22:      *      - any of the properties in deliveryRecipient (the getXxx(...) methods) return null or empty strings
23:      *      - deliveryContent is null or empty
24:      *      - the total number of products in the delivery is > 20
25:      */
26:     public UUID triggerDelivery( UserType deliveryRecipient, Map<UUID, Integer> deliveryContent );
27: 
28: 
29:     /**
30:      * Returns a map showing which products have been delivered to a user, and how many of each product
31:      *
32:      * @param userMailAddress
33:      * @return the delivery history of the user (map is empty if the user has not had any deliveries yet)
34:      * @throws ShopException if
35:      *      - mailAddress is null
36:      *      - the user with the given mail address does not exist
37:      */
38:     public Map<UUID, Integer> getDeliveryHistory( MailAddressType userMailAddress );
39: 
40: 
41: 
42:     /**
43:      *  Deletes all delivery history.
44:      */
45:     public void deleteDeliveryHistory();
46: }
47: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MailAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface MailAddressType {
6:     /**
7:      * @return the mail address as a string
8:      */
9:     public String toString();
10: 
11:     /**
12:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
13:      * implementing class to provide a static factory method (simply named "of(...)"),
14:      * which creates an mail address, given as a string.
15:      * We specify this factory method here as a comment, using the Javadoc documentation style.
16:      *
17:      * @param mailAddressAsString - the mail address as a string.
18:      *      We will use a much simplified validation method to check if the mail address is valid:
19:      *      - it must contain exactly one '@' character.
20:      *      - the part before the '@' and the part after the '@' must not be empty, contain of
21:      *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
22:      *      - the parts before and after the '@' may contain one or several '.' as separators
23:      *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
24:      *      - the part after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
25:      *        (for simplicity we do not allow any other domains)
26:      * @return a new MailAddressType object matching the given mail address
27:      * @throws ShopException if ...
28:      *      - mailAddressAsString is null
29:      *      - mailAddressAsString is not a valid mail address (see above)
30:      */
31:      // public static MailAddressType of( String mailAddressAsString );
32: }
33: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MoneyType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface MoneyType {
6:     /**
7:      * @return the amount of money
8:      */
9:     public Float getAmount();
10: 
11: 
12:     /**
13:      * @return the currency of the money
14:      */
15:     public String getCurrency();
16: 
17: 
18:     /**
19:      * @param otherMoney
20:      * @return this + otherMoney, as a new object
21:      * @throws ShopException if ...
22:      *      - otherMoney is null
23:      *      - otherMoney.currency != this.currency
24:      */
25:     public MoneyType add( MoneyType otherMoney );
26: 
27: 
28:     /**
29:      * @param otherMoney
30:      * @return this - otherMoney, as a new object
31:      * @throws ShopException if ...
32:      *      - otherMoney is null
33:      *      - otherMoney.currency != this.currency
34:      *      - otherMoney > this
35:      */
36:     public MoneyType subtract( MoneyType otherMoney );
37: 
38: 
39:     /**
40:      * @param factor
41:      * @return this * factor, as a new object
42:      * @throws ShopException if ...
43:      *     - factor < 0
44:      */
45:     public MoneyType multiplyBy( int factor );
46: 
47:     /**
48:      * @param otherMoney
49:      * @return true, if this > otherMoney
50:      * @throws ShopException if ...
51:      *      - otherMoney is null
52:      *      - otherMoney.currency != this.currency
53:      */
54:     public boolean largerThan( MoneyType otherMoney );
55: 
56: 
57:     /**
58:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
59:      * implementing class to provide a static factory method (simply named "of(...)"),
60:      * which creates a money object from an amount and a currency (as string).
61:      * We specify this factory method here as a comment, using the Javadoc documentation style.
62:      *
63:      * @param amount the amount of money (must be >= 0)
64:      * @param currency the currency of the money (allowed values: "EUR", "CHF")
65:      * @return a new Money object with the given amount and currency
66:      * @throws ShopException if ...
67:      *   - amount is null
68:      *   - amount < 0
69:      *   - currency is null
70:      *   - currency is not one of the allowed values
71:      */
72:      // public static MoneyType of( Float amount, String currency );
73: }
74: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PersonalAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface PersonalAddressType {
6:     /**
7:      * @return the street as a string
8:      */
9:     public String getStreet();
10: 
11:     /**
12:      * @return the city as a string
13:      */
14:     public String getCity();
15: 
16:     /**
17:      * @return the postal code
18:      */
19:     public PostalCodeType getPostalCode();
20: 
21:     /**
22:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
23:      * implementing class to provide a static factory method (simply named "of(...)"),
24:      * which creates an postal code, given as a string.
25:      * We specify this factory method here as a comment, using the Javadoc documentation style.
26:      *
27:      * @param street the street as a string
28:      * @param city the city as a string
29:      * @param postalCode the postal code
30:      * @return the personalAddress object matching the parameters
31:      * @throws ShopException if ...
32:      *      - street is null or empty
33:      *      - city is null or empty
34:      *      - postalCode is null
35:      */
36:      // public static PersonalAddressType of( String street, String city, PostalCodeType postalCode );
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PostalCodeType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface PostalCodeType {
6:     /**
7:      * @return the postal code as a string
8:      */
9:     public String toString();
10: 
11:     /**
12:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
13:      * implementing class to provide a static factory method (simply named "of(...)"),
14:      * which creates an postal code, given as a string.
15:      * We specify this factory method here as a comment, using the Javadoc documentation style.
16:      *
17:      * @param postalCodeAsString - the postal code as a string.
18:      *      We will use a much simplified validation method to check if the postal code is valid:
19:      *      - It must contain exactly 5 digits.
20:      *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid postal code, but 20001 is valid)
21:      * @return a new postal code object matching the given string
22:      * @throws ShopException if ...
23:      *      - postalCodeAsString is null
24:      *      - postalCodeAsString is not a valid postal code (see above)
25:      */
26:      // public static PostalCodeType of( String postalCodeAsString );
27: }
28: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\InventoryManagementUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: import java.util.UUID;
6: 
7: 
8: /**
9:  * This interface contains methods needed in the context of use cases dealing with managing the shop inventory,
10:  * i.e. adding and removing products in the warehouse. The interface is probably incomplete, and
11:  * will grow over time.
12:  */
13: public interface InventoryManagementUseCases {
14:     /**
15:      * Adds a certain quantity of a given product to the inventory
16:      * @param productId
17:      * @param addedQuantity
18:      * @throws ShopException if ...
19:      *      - productId is null
20:      *      - the product with that id does not exist
21:      *      - addedQuantity <= 0
22:      */
23:     public void addToInventory( UUID productId, int addedQuantity );
24: 
25: 
26:     /**
27:      * Removes a certain quantity of a given product from the inventory.
28:      * If the new total quantity is lower than the currently reserved products, some of currently reserved products
29:      * (in the users' shopping baskets) are removed. This means that some of the reserved products are lost for
30:      * the user. (This is necessary because there probably was a mistake in the inventory management, a mis-counting,
31:      * or some of the products were stolen from the warehouse, are broken, etc.)
32:      * @param productId
33:      * @param removedQuantity
34:      * @throws ShopException if ...
35:      *      - productId is null
36:      *      - the product with that id does not exist
37:      *      - removedQuantity <= 0
38:      *      - the removed quantity is greater than the current inventory and the currently reserved products together
39:      */
40:     public void removeFromInventory( UUID productId, int removedQuantity );
41: 
42: 
43:     /**
44:      * Changes the total quantity of a given product in the inventory.
45:      * If the new total quantity is lower than the currently reserved products, some of currently reserved products
46:      * (in the users' shopping baskets) are removed. This means that some of the reserved products are lost for
47:      * the user. (This is necessary because there probably was a mistake in the inventory management, a mis-counting,
48:      * or some of the products were stolen from the warehouse, are broken, etc.)
49:      * @param productId
50:      * @param newTotalQuantity
51:      * @throws ShopException if ...
52:      *      - productId is null
53:      *      - the product with that id does not exist
54:      *      - newTotalQuantity < 0
55:      */
56:     public void changeInventoryTo( UUID productId, int newTotalQuantity );
57: 
58: 
59:     /**
60:      * Get the current total inventory of a given product, including the currently reserved products
61:      * @param productId
62:      * @return the current total inventory of the product
63:      * @throws ShopException if ...
64:      *      - productId is null
65:      *      - the product with that id does not exist
66:      */
67:     public int getAvailableInventory( UUID productId );
68: }
69: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\PaymentUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import java.util.UUID;
8: 
9: /**
10:  * This interface contains methods needed in the context of use cases dealing with payments.
11:  */
12: public interface PaymentUseCases {
13: 
14:     /**
15:      * Authorizes a payment from a bank card for a given amount
16:      *
17:      * @param userMailAddress
18:      * @param moneyAmount
19:      * @return the id of the payment, if successfully authorized
20:      * @throws ShopException if ...
21:      *      - userMailAddress is null
22:      *      - the amount is null
23:      *      - the amount is 0.00 EUR
24:      *      - the payment cannot be processed, because it is over the limit of 500.00 EUR
25:      */
26:     public UUID authorizePayment( MailAddressType userMailAddress, MoneyType moneyAmount );
27: 
28: 
29:     /**
30:      * Returns the total amount of payments (over the complete history) for a user
31:      * (identified by his/her mail address)
32:      *
33:      * @param userMailAddress
34:      * @return the total amount of payments made using this bank card, or 0.00 EUR if there
35:      *         weren't any payments yet.
36:      * @throws ShopException if ...
37:      *      - userMailAddress is null
38:      */
39:     public MoneyType getPaymentTotal( MailAddressType userMailAddress );
40: 
41: 
42:     /**
43:      * Deletes all payment history, for all users.
44:      */
45:     public void deletePaymentHistory();
46: }
47: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\ProductCatalogUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
5: 
6: import java.util.UUID;
7: 
8: 
9: /**
10:  * This interface contains methods needed in the context of use cases dealing with managing the product catalog.
11:  * The interface is probably incomplete, and will grow over time.
12:  */
13: 
14: public interface ProductCatalogUseCases {
15:     /**
16:      * Adds a new product to the shop catalog
17:      * @param productId
18:      * @param name
19:      * @param description
20:      * @param size
21:      * @param purchasePrice
22:      * @param sellPrice
23:      * @throws ShopException if ...
24:      *      - productId is null,
25:      *      - the product with that id already exists,
26:      *      - name or description are null or empty,
27:      *      - the size is <= 0 (but can be null!),
28:      *      - the purchase price is null,
29:      *      - the sell price is null,
30:      *      - the sell price is lower than the purchase price
31:      */
32:     public void addProductToCatalog( UUID productId, String name, String description, Float size,
33:                                            MoneyType purchasePrice, MoneyType sellPrice );
34: 
35: 
36:     /**
37:      * Removes a product from the shop catalog
38:      * @param productId
39:      * @throws ShopException if
40:      *      - productId is null,
41:      *      - the product with that id does not exist
42:      *      - the product is still in inventory
43:      *      - the product is still reserved in a shopping basket, or part of a completed order
44:      */
45:     public void removeProductFromCatalog( UUID productId );
46: 
47: 
48:     /**
49:      * Get the sell price of a given product
50:      * @param productId
51:      * @return the sell price
52:      * @throws ShopException if ...
53:      *      - productId is null,
54:      *      - the product with that id does not exist
55:      */
56:     public MoneyType getSellPrice( UUID productId );
57: 
58: 
59:     /**
60:      * Clears the product catalog, i.e. removes all products from the catalog, including all the inventory,
61:      * all the reservations and all the orders.
62:      */
63:     public void deleteProductCatalog();
64: 
65: }
66: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingBasketUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import java.util.Map;
8: import java.util.UUID;
9: 
10: /**
11:  * This interface contains methods needed in the context of use cases dealing with the shopping basket.
12:  * The interface is probably incomplete, and will grow over time.
13:  */
14: public interface ShoppingBasketUseCases {
15:     /**
16:      * Adds a product to the shopping basket of a user
17:      *
18:      * @param userMailAddress
19:      * @param productId
20:      * @param quantity
21:      * @throws ShopException if ...
22:      *      - the user with the given mailAddress does not exist,
23:      *      - the product does not exist,
24:      *      - the quantity <= 0,
25:      *      - the product is not available in the requested quantity
26:      */
27:     public void addProductToShoppingBasket( MailAddressType userMailAddress, UUID productId, int quantity );
28: 
29: 
30:     /**
31:      * Removes a product from the shopping basket of a user
32:      *
33:      * @param userMailAddress
34:      * @param productId
35:      * @param quantity
36:      * @throws ShopException if ...
37:      *      - userMailAddress is null,
38:      *      - the user with the given mailAddress does not exist,
39:      *      - the product does not exist
40:      *      - the quantity <= 0,
41:      *      - the product is not in the shopping basket in the requested quantity
42:      */
43:     public void removeProductFromShoppingBasket( MailAddressType userMailAddress, UUID productId, int quantity );
44: 
45: 
46:     /**
47:      * Sets a comment in the shopping basket position containing a product
48:      *
49:      * @param userMailAddress
50:      * @param productId
51:      * @param comment (can be null)
52:      * @throws ShopException if ...
53:      *      - userMailAddress is null,
54:      *      - the user with the given mailAddress does not exist,
55:      *      - the product does not exist
56:      *      - the product is not in the shopping basket
57:      */
58:     public void setCommentForShoppingBasketPosition( MailAddressType userMailAddress, UUID productId, String comment );
59: 
60: 
61:     /**
62:      * Returns the comment in the shopping basket position containing a product
63:      *
64:      * @param userMailAddress
65:      * @param productId
66:      * @return the comment (can be null)
67:      * @throws ShopException if ...
68:      *      - userMailAddress is null,
69:      *      - the user with the given mailAddress does not exist,
70:      *      - the product does not exist
71:      *      - the product is not in the shopping basket
72:      */
73:     public String getCommentForShoppingBasketPosition( MailAddressType userMailAddress, UUID productId );
74: 
75: 
76:     /**
77:      * Returns a map showing which products are in the shopping basket of a user and how many of each product
78:      *
79:      * @param userMailAddress
80:      * @return the shopping basket of the user (map is empty if the shopping basket is empty)
81:      * @throws ShopException if ...
82:      *      - userMailAddress is null,
83:      *      - the user with the given mailAddress does not exist
84:      */
85:     public Map<UUID, Integer> getShoppingBasketAsMap( MailAddressType userMailAddress );
86: 
87: 
88:     /**
89:      * Returns the current value of all products in the shopping basket of a user
90:      *
91:      * @param userMailAddress
92:      * @return the value of shopping basket of the user
93:      * @throws ShopException if ...
94:      *      - userMailAddress is null,
95:      *      - the user with the given mailAddress does not exist
96:      */
97:     public MoneyType getShoppingBasketAsMoneyValue( MailAddressType userMailAddress );
98: 
99: 
100: 
101:     /**
102:      * Get the number units of a specific product that are currently reserved in the shopping baskets of all users
103:      * @param productId
104:      * @return the number of reserved products of that type in all shopping baskets
105:      * @throws ShopException
106:      *      - productId is null
107:      *      - if the product id does not exist
108:      */
109:     public int getReservedInventoryInShoppingBaskets( UUID productId );
110: 
111: 
112:     /**
113:      * Checks if the shopping basket of a user is empty
114:      *
115:      * @param userMailAddress
116:      * @return true if the shopping basket is empty, false otherwise
117:      * @throws ShopException if ...
118:      *    - userMailAddress is null
119:      *    - the user with the given mail address does not exist
120:      */
121:     public boolean isEmpty( MailAddressType userMailAddress );
122: 
123: 
124:     /**
125:      * Checks if the payment for a specific shopping basket of a user has been authorized to be paid,
126:      * i.e. the shopping basket is not empty, the user has given his/her payment details, and the payment
127:      * has been authorized (under the limits of the user's credit card). However, the order
128:      * has not yet been placed yet, and the logistics details have not yet been given.
129:      *
130:      * @param userMailAddress
131:      * @return true if the payment has been authorized, false otherwise
132:      * @throws ShopException if ...
133:      *      - userMailAddress is null
134:      *      - the user with the given mail address does not exist
135:      */
136:     public boolean isPaymentAuthorized( MailAddressType userMailAddress );
137: 
138: 
139:     /**
140:      * Checks out the shopping basket of a user
141:      *
142:      * @param userMailAddress
143:      * @throws ShopException if ... 
144:      * @throws ShopException if ...
145:      *      - userMailAddress is null
146:      *      - the user with the given mail address does not exist
147:      *      - the shopping basket is empty
148:      */
149:     public void checkout( MailAddressType userMailAddress );
150: 
151: 
152: 
153: 
154:     /**
155:      * Returns a map showing which products have been ordered by a user, and how many of each product
156:      *
157:      * @param userMailAddress
158:      * @return the order history of the user (map is empty if the user has not ordered anything yet)
159:      * @Deprecated Might be split into a dedicated OrderUseCases interface later (but still valid in this milestone)
160:      * @throws ShopException if
161:      *      - the mail address is null
162:      *      - the user with the given mail address does not exist
163:      */
164:     public Map<UUID, Integer> getOrderHistory( MailAddressType userMailAddress );
165: 
166: 
167: 
168:     /**
169:      * Deletes all orders and shopping baskets in the system
170:      * @Deprecated Might be split into two methods later (delete orders and delete shopping baskets), with
171:      *             the order deletion moved to a dedicated OrderUseCases interface later
172:      *             (but still valid in this milestone)
173:      */
174:     public void deleteAllOrders();
175: }
176: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\UserRegistrationUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
6: 
7: /**
8:  * This interface contains methods needed in the context of use cases dealing with registering a user.
9:  * The interface is probably incomplete, and will grow over time.
10:  */
11: public interface UserRegistrationUseCases {
12:     /**
13:      * Registers a new user
14:      *
15:      * @param name
16:      * @param mailAddress
17:      * @param personalAddress
18:      * @throws ShopException if ...
19:      *      - name is null or empty
20:      *      - mailAddress is null
21:      *      - user with the given mail address already exists
22:      *      - personalAddress is null
23:      */
24:     public void register( String name, MailAddressType mailAddress, PersonalAddressType personalAddress );
25: 
26: 
27:     /**
28:      * Changes the personalAddress of a user
29:      *
30:      * @param userMailAddress
31:      * @param personalAddress
32:      * @throws ShopException if ...
33:      *      - mailAddress is null
34:      *      - user with the given mail address already exists
35:      *      - personalAddress is null
36:      */
37:     public void changeAddress( MailAddressType userMailAddress, PersonalAddressType personalAddress );
38: 
39: 
40:     /**
41:      * Returns the data of a user
42:      * @param userMailAddress
43:      * @return the user data
44:      * @throws ShopException if ...
45:      *      - mailAddress is null
46:      *      - the user with the given mail address does not exist
47:      */
48:     public UserType getUserData( MailAddressType userMailAddress );
49: 
50: 
51: 
52:     /**
53:      * Deletes all users, including all orders and shopping baskets
54:      */
55:     public void deleteAllUsers();
56: }
57: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\UserType.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
5: 
6: /**
7:  * This interface expresses the essence of a shop user
8:  */
9: public interface UserType {
10:     public String getName();
11:     public MailAddressType getMailAddress();
12:     public PersonalAddressType getPersonalAddress();
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\codereview\E3DDDOutsideSolutionRulesTest.java ---
1: package thkoeln.archilab.ecommerce.codereview;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.library.Architectures.layeredArchitecture;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln")
12: @SuppressWarnings("PMD")
13: public class E3DDDOutsideSolutionRulesTest {
14: 
15:     @ArchTest
16:     static final ArchRule noClassesOutsideSolutionAndDomainprimitives =
17:             layeredArchitecture()
18:                     .consideringAllDependencies()
19:                     .layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
20:                     .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
21:                     .layer( "Test1" ).definedBy( "thkoeln.archilab.ecommerce.codereview.." )
22:                     .layer( "Test2" ).definedBy( "thkoeln.archilab.ecommerce.e1e2resttests.." )
23:                     .layer( "Test3" ).definedBy( "thkoeln.archilab.ecommerce.regression.." )
24: 
25:                     .whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers( "SolutionClasses", "Test1", "Test2", "Test3" )
26:                     .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Test1", "Test2", "Test3" );
27: }
28: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\codereview\E3DDDRulesTest.java ---
1: package thkoeln.archilab.ecommerce.codereview;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: import org.springframework.data.repository.CrudRepository;
8: import org.springframework.stereotype.Service;
9: 
10: import javax.persistence.Entity;
11: import javax.persistence.Id;
12: 
13: import java.util.UUID;
14: 
15: import static com.tngtech.archunit.core.domain.JavaMember.Predicates.declaredIn;
16: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.*;
17: 
18: @ArchTag("layerRules")
19: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
20: @SuppressWarnings("PMD")
21: public class E3DDDRulesTest {
22: 
23:     @ArchTest
24:     static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
25:             noClasses().that().resideInAPackage("..domain..")
26:                     .should().dependOnClassesThat().resideInAPackage("..application..");
27: 
28:     @ArchTest
29:     static final ArchRule entitiesMustResideInADomainPackage =
30:             classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage("..domain..")
31:                     .as("Entities must reside in a package '..domain..'");
32: 
33:     @ArchTest
34:     static final ArchRule entitiesMustNotAccessRepositories =
35:             noClasses().that().areAnnotatedWith( Entity.class )
36:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class );
37: 
38:     @ArchTest
39:     static final ArchRule repositoriesMustResideInADomainPackage =
40:             classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage("..domain..")
41:                     .as("Repositories must reside in a package '..domain..'");
42: 
43:     @ArchTest
44:     static final ArchRule repositoryNamesMustHaveProperSuffix =
45:             classes().that().areAssignableTo( CrudRepository.class )
46:                     .should().haveSimpleNameEndingWith("Repository");
47: 
48:     @ArchTest
49:     static final ArchRule servicesMustResideInAnApplicationPackage =
50:             classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage("..application..")
51:                     .as("Application Services must reside in a package '..application..'");
52: 
53:     @ArchTest
54:     static final ArchRule serviceNamesMustHaveProperSuffix =
55:             classes().that().areAnnotatedWith( Service.class )
56:                     .should().haveSimpleNameEndingWith("Service");
57: 
58:     @ArchTest
59:     static final ArchRule noClassesOnTopLevel =
60:             classes().should().resideInAPackage( "..solution.*.." );
61: 
62:     @ArchTest
63:     static final ArchRule noNonIdFieldsOfTypeIUUID =
64:             fields()
65:                     .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
66:                     .and().areNotAnnotatedWith( Id.class )
67:                     .and().areDeclaredInClassesThat().doNotHaveSimpleName( "Product" )
68:                     .should().notHaveRawType( UUID.class );
69: }
70: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\codereview\E3NoCycleTest.java ---
1: package thkoeln.archilab.ecommerce.codereview;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.importer.ClassFileImporter;
6: import com.tngtech.archunit.lang.ArchRule;
7: import com.tngtech.archunit.library.dependencies.SliceAssignment;
8: import com.tngtech.archunit.library.dependencies.SliceIdentifier;
9: import org.junit.jupiter.api.Test;
10: 
11: import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
12: 
13: public class E3NoCycleTest {
14:     private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");
15: 
16:     private SliceAssignment inAllClasses() {
17:         return new SliceAssignment() {
18:             @Override
19:             public String getDescription() {
20:                 return "every class in it's own slice";
21:             }
22: 
23:             @Override
24:             public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
25:                 return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
26:             }
27:         };
28:     }
29: 
30:     @Test
31:     public void testNoCyclicDependenciesBetweenClasses() {
32:         slices().assignedFrom(inAllClasses())
33:                 .namingSlices("$1[$2.$3]")
34:                 .should().beFreeOfCycles()
35:                 .check(importedClasses);
36:     }
37: 
38:     @Test
39:     public void testNoCyclicDependenciesBetweenPackages() {
40:         ArchRule rule = slices().matching("..solution.(*)..").should().beFreeOfCycles();
41:         rule.check(importedClasses);
42:     }
43: }
44: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\codereview\E3PackageStructureTest.java ---
1: package thkoeln.archilab.ecommerce.codereview;
2: 
3: import com.tngtech.archunit.core.domain.JavaClasses;
4: import com.tngtech.archunit.core.importer.ClassFileImporter;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: 
8: import static org.assertj.core.api.Assertions.assertThat;
9: import static org.junit.jupiter.api.Assertions.assertTrue;
10: 
11: public class E3PackageStructureTest {
12: 
13:     private static final String[] REQUIRED_PACKAGES = {"user", "shoppingbasket", "product", "order"};
14:     private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
15:     private JavaClasses importedClasses;
16: 
17: 
18:     @BeforeEach
19:     public void setUp() {
20:         importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
21:     }
22: 
23:     @Test
24:     void testRequiredPackagesAreThere() {
25:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
26:             String packageName = BASE_PACKAGE + "." + requiredPackage;
27:             assertThat( importedClasses.containPackage( packageName ) )
28:                     .as( "Expected package %s not found!", packageName )
29:                     .isTrue();
30:         }
31:     }
32: 
33:     @Test
34:     void testRequiredDomainPackagesAreThere() {
35:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
36:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
37:             assertThat( importedClasses.containPackage( packageName ) )
38:                     .as( "Expected domain sub-package %s not found!", packageName )
39:                     .isTrue();
40:         }
41:     }
42: 
43:     @Test
44:     void testRequiredApplicationPackagesAreThere() {
45:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
46:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
47:             assertThat( importedClasses.containPackage( packageName ) )
48:                     .as( "Expected application sub-package %s not found!", packageName )
49:                     .isTrue();
50:         }
51:     }
52: 
53: }
54: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\codereview\E3RequiredClassesTest.java ---
1: package thkoeln.archilab.ecommerce.codereview;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
5: import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
6: import org.springframework.core.type.classreading.MetadataReader;
7: import org.springframework.core.type.classreading.MetadataReaderFactory;
8: 
9: import java.io.IOException;
10: import java.util.Arrays;
11: import java.util.HashSet;
12: import java.util.Set;
13: 
14: import static org.junit.jupiter.api.Assertions.assertTrue;
15: 
16: public class E3RequiredClassesTest {
17: 
18: 
19:     private static final String[] REQUIRED_CLASSES = {
20:             "User",
21:             "UserRepository",
22:             "Order",
23:             "OrderRepository",
24:             "ShoppingBasket",
25:             "ShoppingBasketRepository",
26:             "Product",
27:             "ProductRepository"
28:     };
29: 
30:     @Test
31:     public void testRequiredClassesDeclared() throws IOException {
32:         String basePackage = "thkoeln.archilab.ecommerce";
33:         String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";
34: 
35:         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
36:         MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );
37: 
38:         Set<String> foundClasses = new HashSet<>();
39: 
40:         Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
41:             try {
42:                 MetadataReader reader = readerFactory.getMetadataReader( resource );
43:                 foundClasses.add( reader.getClassMetadata().getClassName() );
44:             } catch (IOException e) {
45:                 e.printStackTrace();
46:             }
47:         } );
48: 
49:         Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
50:             boolean found = foundClasses.stream().anyMatch(className ->
51:                     className.startsWith(basePackage) && className.endsWith("." + requiredClass)
52:             );
53:             assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
54:         });
55:     }
56: }
57: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\E1OrdertRESTTest.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import org.springframework.test.context.ActiveProfiles;
9: import org.springframework.test.web.servlet.MockMvc;
10: import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
13: 
14: import javax.transaction.Transactional;
15: import java.util.UUID;
16: 
17: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
18: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
19: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
20: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
21: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.instantiateMailAddress;
22: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.PRODUCT_DATA;
23: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.USER_EMAIL;
24: 
25: @SpringBootTest
26: @Transactional
27: @AutoConfigureMockMvc
28: @ActiveProfiles("test")
29: public class E1OrdertRESTTest {
30: 
31:     @Autowired
32:     private InitialMasterDataCreator initialMasterDataCreator;
33:     @Autowired
34:     private MockMvc mockMvc;
35: 
36:     private RESTHelper restHelper;
37:     private MailAddressType nonExistingMailAddress;
38: 
39: 
40:     @BeforeEach
41:     public void setUp() {
42:         initialMasterDataCreator.deleteAll();
43: 
44:         initialMasterDataCreator.addAllProducts();
45:         initialMasterDataCreator.inventoryUpAllProducts();
46:         initialMasterDataCreator.registerAllUsers();
47: 
48:         restHelper = new RESTHelper( mockMvc );
49:         nonExistingMailAddress = instantiateMailAddress( "harry@sally.de" );
50:     }
51: 
52: 
53:     @Test
54:     public void testGetNoOrders() throws Exception {
55:         // given
56:         // when
57:         // then
58:         mockMvc.perform( get( "/orders" ) )
59:                 .andExpect( status().isOk() )
60:                 .andExpect( jsonPath( "$.length()" ).value( 0 ) );
61:         mockMvc.perform( get( "/orders?mailAddress=" + nonExistingMailAddress ) )
62:                 .andExpect( status().isOk() )
63:                 .andExpect( jsonPath( "$.length()" ).value( 0 ) );
64:         mockMvc.perform( get( "/orders?mailAddress=invalidEmailString" ) )
65:                 .andExpect( status().isOk() )
66:                 .andExpect( jsonPath( "$.length()" ).value( 0 ) );
67:         mockMvc.perform( get( "/orders?mailAddress=" + USER_EMAIL[3].toString() ) )
68:                 .andExpect( status().isOk() )
69:                 .andExpect( jsonPath( "$.length()" ).value( 0 ) );
70:     }
71: 
72: 
73:     @Test void testMakeThreeOrders() throws Exception {
74:         // given
75:         String mailAddressString = USER_EMAIL[6].toString();
76: 
77:         UUID productId2 = (UUID) PRODUCT_DATA[2][0];
78:         UUID productId4 = (UUID) PRODUCT_DATA[4][0];
79:         UUID productId6 = (UUID) PRODUCT_DATA[6][0];
80:         Float productMoneyAmount2 = ((MoneyType) PRODUCT_DATA[2][5]).getAmount() * 2;
81:         Float productMoneyAmount4 = ((MoneyType) PRODUCT_DATA[4][5]).getAmount() * 4;
82:         Float productMoneyAmount6 = ((MoneyType) PRODUCT_DATA[6][5]).getAmount() * 6;
83: 
84:         String uriAllOrders = "/orders?mailAddress=" + mailAddressString;
85:         String uriLatestOrder = uriAllOrders + "&filter=latest";
86: 
87:         // when
88:         restHelper.makeOrderForUser( mailAddressString, productId2, 2 );
89:         restHelper.makeOrderForUser( mailAddressString, productId4, 4 );
90:         restHelper.makeOrderForUser( mailAddressString, productId6, 6 );
91: 
92:         // then get all orders ...
93:         mockMvc.perform( get( uriAllOrders ) )
94:                 .andExpect( status().isOk() )
95:                 .andExpect( jsonPath( "$.length()" ).value( 3 ) )
96: 
97:                 .andExpect( jsonPath( "$[0].mailAddress.mailAddressString" ).value( mailAddressString ) )
98:                 .andExpect( jsonPath( "$[0].price.amount" ).value( productMoneyAmount2 ) )
99: 
100:                 .andExpect( jsonPath( "$[1].mailAddress.mailAddressString" ).value( mailAddressString ) )
101:                 .andExpect( jsonPath( "$[1].price.amount" ).value( productMoneyAmount4 ) )
102: 
103:                 .andExpect( jsonPath( "$[2].mailAddress.mailAddressString" ).value( mailAddressString ) )
104:                 .andExpect( jsonPath( "$[2].price.amount" ).value( productMoneyAmount6 ) );
105: 
106:         // ... and the latest order
107:         mockMvc.perform( get( uriLatestOrder ) )
108:                 .andExpect( status().isOk() )
109:                 .andExpect( jsonPath( "$.length()" ).value( 1 ) )
110:                 .andExpect( jsonPath( "$[0].price.amount" ).value( productMoneyAmount6 ) );
111:     }
112: 
113: 
114:     @Test
115:     public void testIfMoneySumInOrderIsCorrect() throws Exception {
116:         // given
117:         String mailAddressString = USER_EMAIL[3].toString();
118:         UUID productId3 = (UUID) PRODUCT_DATA[3][0];
119:         UUID productId4 = (UUID) PRODUCT_DATA[4][0];
120:         Integer quantity3 = 14;
121:         Integer quantity4 = 5;
122:         Float productMoneyAmount =
123:                 ((MoneyType) PRODUCT_DATA[3][5]).getAmount() * quantity3 +
124:                 ((MoneyType) PRODUCT_DATA[4][5]).getAmount() * quantity4;
125: 
126:         // when
127:         UUID shoppingBasketId = restHelper.getShoppingBasketId( mailAddressString );
128:         restHelper.addProductToShoppingBasket( shoppingBasketId, productId3, quantity3 );
129:         restHelper.addProductToShoppingBasket( shoppingBasketId, productId4, quantity4 );
130:         mockMvc.perform( put( "/shoppingBaskets/" + shoppingBasketId.toString() + "/checkout" ) )
131:                 .andExpect( status().isOk() );
132: 
133:         // then
134:         mockMvc.perform( get(
135:                 "/orders?mailAddress=" + mailAddressString + "&filter=latest") )
136:                 .andExpect( status().isOk() )
137:                 .andExpect( jsonPath( "$.length()" ).value( 1 ) )
138:                 .andExpect( jsonPath( "$[0].price.amount" ).value( productMoneyAmount ) );
139:     }
140: 
141: 
142: 
143: }
144: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\E2ShoppingBasketRESTTest.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import org.springframework.test.context.ActiveProfiles;
9: import org.springframework.test.web.servlet.MockMvc;
10: import org.springframework.test.web.servlet.ResultMatcher;
11: import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
13: 
14: import javax.transaction.Transactional;
15: import java.util.UUID;
16: 
17: import static org.springframework.http.MediaType.APPLICATION_JSON;
18: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
19: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
20: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
21: import static thkoeln.archilab.ecommerce.e1e2resttests.RESTHelper.CONFLICT;
22: import static thkoeln.archilab.ecommerce.e1e2resttests.RESTHelper.CREATED;
23: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.instantiateMailAddress;
24: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.PRODUCT_DATA;
25: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.USER_EMAIL;
26: 
27: @SpringBootTest
28: @Transactional
29: @AutoConfigureMockMvc
30: @ActiveProfiles("test")
31: public class E2ShoppingBasketRESTTest {
32: 
33:     @Autowired
34:     private InitialMasterDataCreator initialMasterDataCreator;
35:     @Autowired
36:     private MockMvc mockMvc;
37: 
38:     private RESTHelper restHelper;
39:     private MailAddressType nonExistingMailAddress;
40: 
41: 
42:     @BeforeEach
43:     public void setUp() {
44:         initialMasterDataCreator.deleteAll();
45: 
46:         initialMasterDataCreator.addAllProducts();
47:         initialMasterDataCreator.inventoryUpAllProducts();
48:         initialMasterDataCreator.registerAllUsers();
49: 
50:         restHelper = new RESTHelper( mockMvc );
51:         nonExistingMailAddress = instantiateMailAddress( "harry@sally.de" );
52:     }
53: 
54: 
55:     @Test
56:     public void testEmptyShoppingBasket() throws Exception {
57:         // given
58:         String validUri = "/shoppingBaskets?mailAddress=" + USER_EMAIL[4].toString();
59:         String invalidUri1 = "/shoppingBaskets?mailAddress=" + nonExistingMailAddress.toString();
60:         String invalidUri2 = "/shoppingBaskets?mailAddress=justaninvalidemailaddress";
61: 
62:         // when
63:         // then
64:         mockMvc.perform( get( validUri ) )
65:                 .andExpect( status().isOk() )
66:                 .andExpect( jsonPath( "$.totalQuantity" ).value( 0 ) );
67:         mockMvc.perform( get( invalidUri1 ) )
68:                 .andExpect( status().isNotFound() );
69:         mockMvc.perform( get( invalidUri2 ) )
70:                 .andExpect( status().isNotFound() );
71:     }
72: 
73: 
74:     @Test
75:     public void testInvalidUris() throws Exception {
76:         // given
77:         UUID productId = (UUID) PRODUCT_DATA[3][0];
78:         String userEmailString = USER_EMAIL[4].toString();
79:         UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
80: 
81:         String invalidPostUri = "/shoppingBaskets/" + UUID.randomUUID() + "/shoppingBasketPositions";
82:         String invalidPatchGetDeleteUri1 =
83:                 "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions/" + UUID.randomUUID();
84:         String invalidPatchGetDeleteUri2 =
85:                 "/shoppingBaskets/" + UUID.randomUUID().toString() + "/shoppingBasketPositions/" + productId;
86:         String invalidCheckoutUri1 = "/shoppingBaskets/" + shoppingBasketId + "/chekkout";
87:         String invalidCheckoutUri2 = "/shoppingBaskets/" + UUID.randomUUID() + "/checkout";
88: 
89:         // when
90:         // then
91:         mockMvc.perform( post( invalidPostUri )
92:                 .contentType( APPLICATION_JSON ).content( "[]" ) ).andExpect( status().is4xxClientError() );
93: 
94:         mockMvc.perform( delete( invalidPatchGetDeleteUri1 ) ).andExpect( status().isNotFound() );
95:         mockMvc.perform( get( invalidPatchGetDeleteUri1 ) ).andExpect( status().isNotFound() );
96: 
97:         mockMvc.perform( delete( invalidPatchGetDeleteUri2 ) ).andExpect( status().isNotFound() );
98:         mockMvc.perform( get( invalidPatchGetDeleteUri2 ) ).andExpect( status().isNotFound() );
99: 
100:         mockMvc.perform( put( invalidCheckoutUri1 ) ).andExpect( status().isNotFound() );
101:         mockMvc.perform( put( invalidCheckoutUri2 ) ).andExpect( status().isNotFound() );
102:     }
103: 
104: 
105:     @Test
106:     public void testQueryNonExistingProduct() throws Exception {
107:         // given
108:         UUID productId = (UUID) PRODUCT_DATA[3][0];
109:         String userEmailString = USER_EMAIL[7].toString();
110:         UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
111:         String invalidUri = "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions/" + productId;
112: 
113:         // when
114:         // then
115:         mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
116:     }
117: 
118: 
119:     @Test
120:     public void testDeleteFromShoppingBasket() throws Exception {
121:         // given
122:         UUID productId1 = (UUID) PRODUCT_DATA[1][0];
123:         String userEmailString9 = USER_EMAIL[9].toString();
124:         String userEmailString7 = USER_EMAIL[7].toString();
125: 
126:         UUID shoppingBasketId9 = restHelper.getShoppingBasketId( userEmailString9 );
127:         UUID shoppingBasketId7 = restHelper.getShoppingBasketId( userEmailString7 );
128: 
129:         String baseUri9 = "/shoppingBaskets/" + shoppingBasketId9 + "/shoppingBasketPositions/";
130:         String checkoutUri9 = "/shoppingBaskets/" + shoppingBasketId9 + "/checkout";
131:         String checkoutUri7 = "/shoppingBaskets/" + shoppingBasketId7 + "/checkout";
132: 
133:         // when
134:         restHelper.addMultipleProductsToShoppingBasket( userEmailString9,
135:                 new Integer[]{1, 4, 6}, new Integer[]{1, 4, 6}, new String[]{"c1", "c4", "c6"} );
136:         restHelper.checkMultipleShoppingBasketPositions(
137:                 userEmailString9, new Integer[]{1, 4, 6}, new Integer[]{1, 4, 6},
138:                 new String[]{"c1", "c4", "c6"} );
139:         mockMvc.perform( delete( baseUri9 + productId1 ) )
140:                 .andExpect( status().isOk() );
141:         restHelper.checkMultipleShoppingBasketPositions(
142:                 userEmailString9, new Integer[]{1, 4, 6}, new Integer[]{null, 4, 6},
143:                 new String[]{null, "c4", "c6"}, new Boolean[]{false, true, true} );
144:         // ... and another customer can still buy 10 of the "Nr. 1" product
145:         restHelper.addProductToShoppingBasket( shoppingBasketId7, productId1, 10,
146:                 "still10", null );
147: 
148:         // then
149:         mockMvc.perform( put( checkoutUri9 ) ).andExpect( status().isOk() );
150:         restHelper.checkMultipleOrderPositionsInLatestOrder( userEmailString9,
151:                 new Integer[]{4, 6}, new Integer[]{4, 6}, new String[]{"c4", "c6"} );
152:         mockMvc.perform( put( checkoutUri7 ) ).andExpect( status().isOk() );
153:         restHelper.checkMultipleOrderPositionsInLatestOrder( userEmailString7,
154:                 new Integer[]{1}, new Integer[]{10}, new String[]{"still10"} );
155:     }
156: 
157: 
158:     @Test
159:     public void testAddToAndRemoveFromShoppingBasket() throws Exception {
160:         // given
161:         String userEmailString = USER_EMAIL[2].toString();
162:         UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
163:         String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
164: 
165:         // when
166:         restHelper.addMultipleProductsToShoppingBasket( userEmailString,
167:                 new Integer[]{2, 4, 2, 4, 6, 2}, new Integer[]{2, 3, 4, -1, 3, -6},
168:                 new String[]{null, "c4a", "c2a", "c4b", "c6", null} );
169:         restHelper.checkMultipleShoppingBasketPositions(
170:                 userEmailString, new Integer[]{2, 4, 6}, new Integer[]{null, 2, 3},
171:                 new String[]{null, "c4b", "c6"}, new Boolean[]{false, true, true} );
172: 
173:         // then
174:         mockMvc.perform( put( checkoutUri ) ).andExpect( status().isOk() );
175:         restHelper.checkMultipleOrderPositionsInLatestOrder( userEmailString,
176:                 new Integer[]{4, 6}, new Integer[]{2, 3}, new String[]{"c4b", "c6"} );
177:     }
178: 
179: 
180:     @Test
181:     public void testRemoveMoreThanThereIsInShoppingBasket() throws Exception {
182:         // given
183:         String userEmailString = USER_EMAIL[2].toString();
184: 
185:         // when
186:         // then
187:         restHelper.addMultipleProductsToShoppingBasket( userEmailString,
188:                 new Integer[]{2, 4, 2}, new Integer[]{2, 3, -3}, new String[]{null, null, null},
189:                 new ResultMatcher[]{CREATED, CREATED, CONFLICT} );
190:     }
191: 
192: 
193:     @Test
194:     public void testAddMoreThanIsInInventory() throws Exception {
195:         // given
196:         String userEmailString = USER_EMAIL[7].toString();
197: 
198:         // when
199:         // then
200:         restHelper.addMultipleProductsToShoppingBasket( userEmailString,
201:                 new Integer[]{1, 1, 1, 1}, new Integer[]{2, 3, 4, 2}, new String[]{null, null, null, null},
202:                 new ResultMatcher[]{CREATED, CREATED, CREATED, CONFLICT} );
203:     }
204: 
205: 
206:     @Test
207:     public void testSuccessfulCheckoutJustWithinPaymentLimit() throws Exception {
208:         // given
209:         String userEmailString = USER_EMAIL[5].toString();
210:         UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
211:         String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
212: 
213:         // when
214:         restHelper.addMultipleProductsToShoppingBasket( userEmailString,
215:                 new Integer[]{11, 13, 10, 6}, new Integer[]{1, 1, 1, 17}, new String[]{"350€", "100€", "35€", "8.50€"} );
216: 
217:         // then
218:         mockMvc.perform( put( checkoutUri ) ).andExpect( status().isOk() );
219:         restHelper.checkMultipleOrderPositionsInLatestOrder( userEmailString,
220:                 new Integer[]{11, 13, 10, 6}, new Integer[]{1, 1, 1, 17}, new String[]{"350€", "100€", "35€", "8.50€"} );
221:     }
222: 
223: 
224: 
225:     @Test
226:     public void testUnsuccessfulCheckoutAbovePaymentLimit() throws Exception {
227:         // given
228:         String userEmailString = USER_EMAIL[1].toString();
229:         UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
230:         String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
231: 
232:         // when
233:         restHelper.addMultipleProductsToShoppingBasket( userEmailString,
234:                 new Integer[]{13, 10}, new Integer[]{4, 3}, new String[]{"400€", "105€"} );
235: 
236:         // then
237:         mockMvc.perform( put( checkoutUri ) ).andExpect( status().isConflict() );
238:     }
239: 
240: 
241:     @Test
242:     public void testUnsuccessfulCheckoutAboveDeliveryLimit() throws Exception {
243:         // given
244:         String userEmailString = USER_EMAIL[8].toString();
245:         UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
246:         String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
247: 
248:         // when
249:         restHelper.addMultipleProductsToShoppingBasket( userEmailString,
250:                 new Integer[]{13, 6}, new Integer[]{3, 18}, new String[]{"300€", "9€"} );
251: 
252:         // then
253:         mockMvc.perform( put( checkoutUri ) ).andExpect( status().isConflict() );
254:     }
255: 
256: 
257:     @Test
258:     public void testNoCheckoutForEmptyShoppingBasket() throws Exception {
259:         // given
260:         String userEmailString = USER_EMAIL[9].toString();
261:         UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
262:         String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
263: 
264:         // when
265:         // then
266:         mockMvc.perform( put( checkoutUri ) ).andExpect( status().isConflict() );
267:     }
268: }
269: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\RESTHelper.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests;
2: 
3: import com.fasterxml.jackson.databind.ObjectMapper;
4: import org.springframework.test.web.servlet.MockMvc;
5: import org.springframework.test.web.servlet.MvcResult;
6: import org.springframework.test.web.servlet.ResultActions;
7: import org.springframework.test.web.servlet.ResultMatcher;
8: import thkoeln.archilab.ecommerce.e1e2resttests.testdtos.IdDTO;
9: import thkoeln.archilab.ecommerce.e1e2resttests.testdtos.QuantityAndCommentDTO;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
11: 
12: import java.util.HashMap;
13: import java.util.Map;
14: import java.util.UUID;
15: 
16: import static org.springframework.http.MediaType.APPLICATION_JSON;
17: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
18: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
19: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
20: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.PRODUCT_DATA;
21: 
22: public class RESTHelper {
23:     private MockMvc mockMvc;
24: 
25:     public static final ResultMatcher NOT_FOUND = status().isNotFound();
26:     public static final ResultMatcher OK = status().isOk();
27:     public static final ResultMatcher CREATED = status().isCreated();
28:     public static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
29:     public static final ResultMatcher CONFLICT = status().isConflict();
30: 
31:     public RESTHelper( MockMvc mockMvc ) {
32:         this.mockMvc = mockMvc;
33:     }
34: 
35:     public void makeOrderForUser( String mailAddressString, UUID productId, Integer quantity ) throws Exception {
36:         UUID shoppingBasketId = getShoppingBasketId( mailAddressString );
37:         addProductToShoppingBasket( shoppingBasketId, productId, quantity );
38:         mockMvc.perform( put( "/shoppingBaskets/" + shoppingBasketId.toString() + "/checkout" ) )
39:                 .andExpect( OK );
40:     }
41: 
42:     public UUID getShoppingBasketId( String mailAddressString ) throws Exception {
43:         // get the shopping basket and extract its id ...
44:         MvcResult shoppingBasket = mockMvc.perform( get( "/shoppingBaskets?mailAddress=" + mailAddressString ) )
45:                 .andExpect( OK )
46:                 .andExpect( jsonPath( "$.id" ).isNotEmpty() )
47:                 .andReturn();
48:         ObjectMapper objectMapper = new ObjectMapper();
49:         IdDTO idDTO = objectMapper.readValue( shoppingBasket.getResponse().getContentAsString(), IdDTO.class );
50:         return idDTO.getId();
51:     }
52: 
53:     public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity,
54:                                                  String comment, ResultMatcher expectedStatus )
55:                                                 throws Exception {
56:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
57:         ObjectMapper objectMapper = new ObjectMapper();
58:         QuantityAndCommentDTO dto = new QuantityAndCommentDTO( productId, quantity, comment );
59:         String quantityJson = objectMapper.writeValueAsString( dto );
60:         mockMvc.perform( post( "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions" )
61:                 .contentType( APPLICATION_JSON ).content( quantityJson ) )
62:                 .andExpect( status );
63:     }
64: 
65: 
66:     public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity )
67:             throws Exception {
68:         addProductToShoppingBasket( shoppingBasketId, productId, quantity, null, null );
69:     }
70: 
71: 
72: 
73:     public void addMultipleProductsToShoppingBasket(
74:             String userEmailString, Integer[] productIndices, Integer[] quantities, String[] comments,
75:             ResultMatcher[] expectedAddStatuses ) throws Exception {
76:         UUID shoppingBasketId = getShoppingBasketId( userEmailString );
77:         String shoppingBasketUri = "shoppingBaskets?mailAddress=" + userEmailString;
78:         String baseUri = "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions/";
79: 
80:         // add all the products to the shopping basket ...
81:         Map<Integer, Integer> quantityMap = new HashMap<>();
82:         Map<Integer, String> commentMap = new HashMap<>();
83:         for ( int i = 0; i < productIndices.length; i++ ) {
84:             UUID productId = (UUID) PRODUCT_DATA[productIndices[i]][0];
85:             addProductToShoppingBasket( shoppingBasketId, productId, quantities[i], comments[i], expectedAddStatuses[i] );
86:             if ( expectedAddStatuses[i] != null || expectedAddStatuses[i] == CREATED || expectedAddStatuses[i] == OK ) {
87:                 quantityMap.put( productIndices[i],
88:                         quantities[i] + quantityMap.getOrDefault( productIndices[i], 0 ) );
89:                 commentMap.put( productIndices[i], comments[i] );
90:             }
91:         }
92:     }
93: 
94: 
95:     public void addMultipleProductsToShoppingBasket(
96:             String userEmailString, Integer[] productIndices, Integer[] quantities,
97:             String[] comments ) throws Exception {
98:         ResultMatcher[] expectedAddStatuses = new ResultMatcher[productIndices.length];
99:         for ( int i = 0; i < productIndices.length; i++ ) {
100:             expectedAddStatuses[i] = CREATED;
101:         }
102:         addMultipleProductsToShoppingBasket( userEmailString, productIndices, quantities,
103:                 comments, expectedAddStatuses );
104:     }
105: 
106: 
107:     public void checkMultipleShoppingBasketPositions( String userEmailString,
108:                                                          Integer[] productIndices, Integer[] expectedQuantities,
109:                                                          String[] expectedComments, Boolean[] expectedToBeFound ) throws Exception {
110:         UUID shoppingBasketId = getShoppingBasketId( userEmailString );
111:         String shoppingBasketUri = "/shoppingBaskets?mailAddress=" + userEmailString;
112:         String baseUri = "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions/";
113: 
114:         // check that the shopping basket contains all the products ...
115:         int totalQuantity = 0;
116:         for ( int i = 0; i < productIndices.length; i++ ) {
117:             if ( expectedQuantities[i] != null ) {
118:                 totalQuantity += expectedQuantities[i];
119:             }
120:         }
121:         mockMvc.perform( get( shoppingBasketUri ) )
122:                 .andExpect( OK )
123:                 .andExpect( jsonPath( "$.totalQuantity" ).value( totalQuantity ) );
124: 
125:         // check that each product has the correct quantity and comment ...
126:         for ( int i = 0; i < productIndices.length; i++ ) {
127:             UUID productId = (UUID) PRODUCT_DATA[productIndices[i]][0];
128:             if ( expectedToBeFound[i] ) {
129:                 mockMvc.perform( get( baseUri + productId ) )
130:                         .andExpect( OK )
131:                         .andExpect( jsonPath( "$.quantity" ).value( expectedQuantities[i] ) )
132:                         .andExpect( jsonPath( "$.comment" ).value( expectedComments[i] ) );
133:             } else {
134:                 mockMvc.perform( get( baseUri + productId ) )
135:                         .andExpect( NOT_FOUND );
136:             }
137:         }
138:     }
139: 
140: 
141:     public void checkMultipleShoppingBasketPositions( String userEmailString,
142:                                                          Integer[] productIndices, Integer[] expectedQuantities,
143:                                                          String[] expectedComments ) throws Exception {
144:         Boolean[] expectedToBeFound = new Boolean[productIndices.length];
145:         for ( int i = 0; i < productIndices.length; i++ ) {
146:             expectedToBeFound[i] = true;
147:         }
148:         checkMultipleShoppingBasketPositions( userEmailString, productIndices, expectedQuantities,
149:                 expectedComments, expectedToBeFound );
150:     }
151: 
152: 
153: 
154:     public void checkMultipleOrderPositionsInLatestOrder(
155:             String userEmailString, Integer[] productIndices, Integer[] expectedQuantities,
156:             String[] expectedComments ) throws Exception {
157:         String latestOrderUri = "/orders?mailAddress=" + userEmailString + "&filter=latest";
158: 
159:         // Calculate the total price of the order ...
160:         float totalPrice = 0f;
161:         for ( int i = 0; i < productIndices.length; i++ ) {
162:             totalPrice += expectedQuantities[i] * ((MoneyType) PRODUCT_DATA[productIndices[i]][5]).getAmount();
163:         }
164: 
165:         // ... and check that the order has the correct total price (and other data)
166:         ResultActions resultActions = mockMvc.perform( get( latestOrderUri ) ).andExpect( OK )
167:                 .andExpect( jsonPath( "$.length()" ).value( 1 ) )
168:                 .andExpect( jsonPath( "$[0].price.amount" ).value( totalPrice ) )
169:                 .andExpect( jsonPath( "$[0].mailAddress.mailAddressString" ).value( userEmailString ) );
170: 
171:         // Now check that all the expected parts are there
172:         for ( int i = 0; i < productIndices.length; i++ ) {
173:             UUID productId = (UUID) PRODUCT_DATA[productIndices[i]][0];
174:             resultActions.andExpect(
175:                     jsonPath( "$[0].orderPositions.length()" ).value( productIndices.length ) );
176:             resultActions.andExpect(
177:                     jsonPath( "$[0].orderPositions[?(@.productId == '" + productId + "')].quantity" )
178:                             .value( expectedQuantities[i] ) );
179:             if ( expectedComments[i] != null ) {
180:                 resultActions.andExpect(
181:                         jsonPath( "$[0].orderPositions[?(@.productId == '" + productId + "')].comment" )
182:                                 .value( expectedComments[i] ) );
183:             }
184:         }
185:     }
186: 
187: }
188: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\testdtos\CommentDTO.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests.testdtos;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import lombok.*;
5: 
6: import java.util.UUID;
7: 
8: /**
9:  * A DTO containing just a comment, used in testing.
10:  */
11: 
12: @AllArgsConstructor
13: @NoArgsConstructor
14: @Setter
15: @Getter
16: @ToString
17: @JsonIgnoreProperties(ignoreUnknown = true)
18: public class CommentDTO {
19:     private UUID productId;
20:     private String comment;
21: }
22: 
23: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\testdtos\IdDTO.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests.testdtos;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import lombok.*;
5: 
6: import java.util.UUID;
7: 
8: /**
9:  * A DTO containing just the id of an entity, used in testing.
10:  */
11: 
12: @AllArgsConstructor
13: @NoArgsConstructor
14: @Setter
15: @Getter
16: @ToString
17: @JsonIgnoreProperties(ignoreUnknown = true)
18: public class IdDTO {
19:     private UUID id;
20: }
21: 
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\testdtos\QuantityAndCommentDTO.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests.testdtos;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import lombok.*;
5: 
6: import java.util.UUID;
7: 
8: /**
9:  * A DTO containing just a quantity, used in testing.
10:  */
11: 
12: 
13: @NoArgsConstructor
14: @Setter
15: @Getter
16: @ToString
17: @JsonIgnoreProperties(ignoreUnknown = true)
18: public class QuantityAndCommentDTO {
19:     private UUID productId;
20:     private Integer quantity;
21:     private String comment;
22: 
23:     public QuantityAndCommentDTO( UUID productId, Integer quantity, String comment ) {
24:         this.productId = productId;
25:         this.quantity = quantity;
26:         this.comment = comment;
27:     }
28: }
29: 
30: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionMailAddressTest.java ---
1: package thkoeln.archilab.ecommerce.regression.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;
9: 
10: class RegressionMailAddressTest {
11: 
12:     @Test
13:     public void testToString() {
14:         // given
15:         String input = "test@example.com";
16: 
17:         // when
18:         MailAddressType instance = instantiateMailAddress( input );
19: 
20:         // then
21:         assertEquals( input, instance.toString() );
22:     }
23: 
24:     @Test
25:     public void testFactoryMethodValid() {
26:         // given
27:         // when
28:         // then
29:         assertDoesNotThrow( () -> instantiateMailAddress( "test@example.com" ) );
30:         assertDoesNotThrow( () -> instantiateMailAddress( "99Z@example.com" ) );
31:         assertDoesNotThrow( () -> instantiateMailAddress( "GGGhh@s77.com" ) );
32:         assertDoesNotThrow( () -> instantiateMailAddress( "a@4.com" ) );
33:         assertDoesNotThrow( () -> instantiateMailAddress( "Max.Hammer@example.com" ) );
34:         assertDoesNotThrow( () -> instantiateMailAddress( "Max.Gideon.Hammer@example.com" ) );
35:         assertDoesNotThrow( () -> instantiateMailAddress( "test@example.this.com" ) );
36:         assertDoesNotThrow( () -> instantiateMailAddress( "test@example.de" ) );
37:         assertDoesNotThrow( () -> instantiateMailAddress( "test@example.at" ) );
38:         assertDoesNotThrow( () -> instantiateMailAddress( "test@example.ch" ) );
39:         assertDoesNotThrow( () -> instantiateMailAddress( "test@example.org" ) );
40:     }
41: 
42:     @Test
43:     public void testFactoryMethodInvalid() {
44:         // given
45:         // when
46:         // then
47:         assertThrows( ShopException.class, () -> instantiateMailAddress( null ) );
48:         assertThrows( ShopException.class, () -> instantiateMailAddress( "testexample.com" ) );
49:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@" ) );
50:         assertThrows( ShopException.class, () -> instantiateMailAddress( "@example.com" ) );
51:         assertThrows( ShopException.class, () -> instantiateMailAddress( "Max..Gideon.Hammer@example.com" ) );
52:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@examplecom" ) );
53:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example..com" ) );
54:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example@that.com" ) );
55:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test example@that.com" ) );
56:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test#example@that.com" ) );
57:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.biz" ) );
58:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.biz" ) );
59:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.42" ) );
60:     }
61: 
62:     @Test
63:     public void testValueObjectEquality() {
64:         // given
65:         // when
66:         MailAddressType instance1 = instantiateMailAddress( "test@example.com" );
67:         MailAddressType instance2 = instantiateMailAddress( "test@example.com" );
68:         MailAddressType instance3 = instantiateMailAddress( "different@example.com" );
69: 
70:         // then
71:         assertEquals( instance1, instance2 );
72:         assertNotEquals( instance1, instance3 );
73:     }
74: 
75:     @Test
76:     public void testImmutability() {
77:         // given
78:         // when
79:         MailAddressType instance = instantiateMailAddress( "test@example.com" );
80: 
81:         // then
82:         try {
83:             instance.getClass().getMethod( "setMailAddress", String.class );
84:             fail( "setMailAddress method should not exist" );
85:         } catch (NoSuchMethodException e) {
86:             // Success: the object is immutable
87:         }
88:     }
89: }
90: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionMoneyTest.java ---
1: package thkoeln.archilab.ecommerce.regression.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;
9: 
10: class RegressionMoneyTest {
11: 
12:     @Test
13:     public void testGetAmount() {
14:         // given
15:         Float inputAmount = 10.0f;
16: 
17:         // when
18:         MoneyType instance = instantiateMoney( inputAmount, "EUR" );
19: 
20:         // then
21:         assertEquals( inputAmount, instance.getAmount() );
22:     }
23: 
24:     @Test
25:     public void testGetCurrency() {
26:         // given
27:         String inputCurrency = "EUR";
28: 
29:         // when
30:         MoneyType instance = instantiateMoney( 10.0f, inputCurrency );
31: 
32:         // then
33:         assertEquals( inputCurrency, instance.getCurrency() );
34:     }
35: 
36:     @Test
37:     public void testAddTo() {
38:         // given
39:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
40:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
41:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
42: 
43:         // when
44:         MoneyType result12 = instance1.add( instance2 );
45:         MoneyType result13 = instance1.add( instance3 );
46: 
47:         // then
48:         assertEquals( 30.0f, result12.getAmount() );
49:         assertEquals( "EUR", result12.getCurrency() );
50:         assertEquals( 10.0f, result13.getAmount() );
51:         assertEquals( "EUR", result12.getCurrency() );
52:     }
53: 
54:     @Test
55:     public void testInvalidAddTo() {
56:         // given
57:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
58:         MoneyType instance2 = instantiateMoney( 20.0f, "CHF" );
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
63:     }
64: 
65:     @Test
66:     public void testSubtractFrom() {
67:         // given
68:         MoneyType instance1 = instantiateMoney( 30.0f, "EUR" );
69:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
70:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
71:         MoneyType instance4 = instantiateMoney( 30.0f, "EUR" );
72: 
73:         // when
74:         MoneyType result12 = instance1.subtract( instance2 );
75:         MoneyType result13 = instance1.subtract( instance3 );
76:         MoneyType result14 = instance1.subtract( instance4 );
77: 
78:         // then
79:         assertEquals( 10.0f, result12.getAmount() );
80:         assertEquals( "EUR", result12.getCurrency() );
81:         assertEquals( 30.0f, result13.getAmount() );
82:         assertEquals( "EUR", result13.getCurrency() );
83:         assertEquals( 0.0f, result14.getAmount() );
84:         assertEquals( "EUR", result14.getCurrency() );
85:     }
86: 
87:     @Test
88:     public void testInvalidSubtractFrom() {
89:         // given
90:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
91:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
92:         MoneyType instance3 = instantiateMoney( 5.0f, "CHF" );
93: 
94:         // when
95:         // then
96:         assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
97:         assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
98:     }
99: 
100:     @Test
101:     public void testMultiplyBy() {
102:         // given
103:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
104: 
105:         // when
106:         MoneyType result = instance.multiplyBy( 3 );
107: 
108:         // then
109:         assertEquals( 30.0f, result.getAmount() );
110:         assertEquals( "EUR", result.getCurrency() );
111:     }
112: 
113:     @Test
114:     public void testFactoryMethodValid() {
115:         // given
116:         // when
117:         // then
118:         assertDoesNotThrow( () -> instantiateMoney( 10.0f, "EUR" ) );
119:     }
120: 
121:     @Test
122:     public void testFactoryMethodInvalid() {
123:         // given
124:         // when
125:         // then
126:         assertThrows( ShopException.class, () -> instantiateMoney( -10.0f, "EUR" ) );
127:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, "USD" ) );
128:         assertThrows( ShopException.class, () -> instantiateMoney( null, "EUR" ) );
129:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, null ) );
130:     }
131: 
132:     @Test
133:     public void testLargerThan() {
134:         // given
135:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
136:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
137:         MoneyType instance3 = instantiateMoney( 10.0f, "EUR" );
138:         MoneyType instance4 = instantiateMoney( 10.0f, "CHF" );
139: 
140:         // when
141:         // then
142:         assertTrue( instance2.largerThan( instance1 ) );
143:         assertFalse( instance1.largerThan( instance2 ) );
144:         assertFalse( instance1.largerThan( instance3 ) );
145:         assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
146:     }
147: 
148: 
149:     @Test
150:     public void testValueObjectEquality() {
151:         // given
152:         // when
153:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
154:         MoneyType instance2 = instantiateMoney( 10.0f, "EUR" );
155:         MoneyType instance3 = instantiateMoney( 20.0f, "EUR" );
156: 
157:         // then
158:         assertEquals( instance1, instance2 );
159:         assertNotEquals( instance1, instance3 );
160:     }
161: 
162:     @Test
163:     public void testImmutability() {
164:         // given
165:         // when
166:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
167: 
168:         // then
169:         try {
170:             instance.getClass().getMethod( "setAmount", Float.class );
171:             fail( "setAmount method should not exist" );
172:         } catch (NoSuchMethodException e) {
173:             // Success: the object is immutable
174:         }
175: 
176:         try {
177:             instance.getClass().getMethod( "setCurrency", String.class );
178:             fail( "setCurrency method should not exist" );
179:         } catch (NoSuchMethodException e) {
180:             // Success: the object is immutable
181:         }
182:     }
183: }
184: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionPersonalAddressTest.java ---
1: package thkoeln.archilab.ecommerce.regression.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;
10: 
11: class RegressionPersonalAddressTest {
12: 
13:     @Test
14:     public void testGetterMethods() {
15:         // given
16:         String street = "Irgendeinestraße 42";
17:         String city = "Irgendeinestadt";
18:         PostalCodeType plz = instantiatePostalCode( "12345" );
19: 
20:         // when
21:         PersonalAddressType instance = instantiatePersonalAddress( street, city, plz );
22: 
23:         // then
24:         assertEquals( street, instance.getStreet() );
25:         assertEquals( city, instance.getCity() );
26:         assertEquals( plz, instance.getPostalCode() );
27:     }
28: 
29:     @Test
30:     public void testFactoryMethodValid() {
31:         // given
32:         String street = "Irgendeinestraße 42";
33:         String city = "Irgendeinestadt";
34:         PostalCodeType plz = instantiatePostalCode( "12345" );
35: 
36:         // when
37:         // then
38:         assertDoesNotThrow( () -> instantiatePersonalAddress( street, city, plz ) );
39:     }
40: 
41:     @Test
42:     public void testFactoryMethodInvalid() {
43:         // given
44:         String street = "Irgendeinestraße 42";
45:         String city = "Irgendeinestadt";
46:         PostalCodeType plz = instantiatePostalCode( "12345" );
47: 
48:         // when
49:         // then
50:         assertThrows( ShopException.class, () -> instantiatePersonalAddress( null, city, plz ) );
51:         assertThrows( ShopException.class, () -> instantiatePersonalAddress( "", city, plz ) );
52:         assertThrows( ShopException.class, () -> instantiatePersonalAddress( street, null, plz ) );
53:         assertThrows( ShopException.class, () -> instantiatePersonalAddress( street, "", plz ) );
54:         assertThrows( ShopException.class, () -> instantiatePersonalAddress( street, city, null ) );
55:     }
56: 
57:     @Test
58:     public void testValueObjectEquality() {
59:         // given
60:         String street = "Irgendeinestraße 42";
61:         String city = "Irgendeinestadt";
62:         PostalCodeType plz = instantiatePostalCode( "12345" );
63: 
64:         // when
65:         PersonalAddressType instance1 = instantiatePersonalAddress( street, city, plz );
66:         PersonalAddressType instance2 = instantiatePersonalAddress( street, city, plz );
67:         PersonalAddressType instance3 = instantiatePersonalAddress( "Anderestr. 12", city, plz );
68:         PersonalAddressType instance4 = instantiatePersonalAddress( street, "AndereStadt", plz );
69:         PersonalAddressType instance5 = instantiatePersonalAddress( street, city, instantiatePostalCode( "54321" ) );
70: 
71:         // then
72:         assertEquals( instance1, instance2 );
73:         assertNotEquals( instance1, instance3 );
74:         assertNotEquals( instance1, instance4 );
75:         assertNotEquals( instance1, instance5 );
76:     }
77: 
78:     @Test
79:     public void testImmutability() {
80:         // given
81:         String street = "Irgendeinestraße 42";
82:         String city = "Irgendeinestadt";
83:         PostalCodeType plz = instantiatePostalCode( "12345" );
84: 
85:         // when
86:         PersonalAddressType instance = instantiatePersonalAddress( street, city, plz );
87: 
88:         // then
89:         try {
90:             instance.getClass().getMethod( "setStreet", String.class );
91:             fail( "setStreet method should not exist" );
92:         } catch (NoSuchMethodException e) {
93:             // Success: the object is immutable
94:         }
95:         try {
96:             instance.getClass().getMethod( "setCity", String.class );
97:             fail( "setCity method should not exist" );
98: 
99:         } catch (NoSuchMethodException e) {
100:             // Success: the object is immutable
101:         }
102:         try {
103:             instance.getClass().getMethod( "setPostalCode", PostalCodeType.class );
104:             fail( "setPostalCode method should not exist" );
105:         } catch (NoSuchMethodException e) {
106:             // Success: the object is immutable
107:         }
108:     }
109: }
110: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionPostalCodeTest.java ---
1: package thkoeln.archilab.ecommerce.regression.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;
9: 
10: class RegressionPostalCodeTest {
11: 
12:     @Test
13:     public void testToString() {
14:         // given
15:         String input = "12345";
16: 
17:         // when
18:         PostalCodeType instance = instantiatePostalCode( input );
19: 
20:         // then
21:         assertEquals( input, instance.toString() );
22:     }
23: 
24:     @Test
25:     public void testFactoryMethodValid() {
26:         // given
27:         // when
28:         // then
29:         assertDoesNotThrow( () -> instantiatePostalCode( "12345" ) );
30:     }
31: 
32:     @Test
33:     public void testFactoryMethodInvalid() {
34:         // given
35:         // when
36:         // then
37:         assertThrows( ShopException.class, () -> instantiatePostalCode( "123456" ) );
38:         assertThrows( ShopException.class, () -> instantiatePostalCode( "1234" ) );
39:         assertThrows( ShopException.class, () -> instantiatePostalCode( "20000" ) );
40:         assertThrows( ShopException.class, () -> instantiatePostalCode( null ) );
41:     }
42: 
43:     @Test
44:     public void testValueObjectEquality() {
45:         // given
46:         // when
47:         PostalCodeType instance1 = instantiatePostalCode( "12345" );
48:         PostalCodeType instance2 = instantiatePostalCode( "12345" );
49:         PostalCodeType instance3 = instantiatePostalCode( "54321" );
50: 
51:         // then
52:         assertEquals( instance1, instance2 );
53:         assertNotEquals( instance1, instance3 );
54:     }
55: 
56:     @Test
57:     public void testImmutability() {
58:         // given
59:         // when
60:         PostalCodeType instance = instantiatePostalCode( "12345" );
61: 
62:         // then
63:         try {
64:             instance.getClass().getMethod( "setpostalCode", String.class );
65:             fail( "setpostalCode method should not exist" );
66:         } catch (NoSuchMethodException e) {
67:             // Success: the object is immutable
68:         }
69:     }
70: }
71: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\regression\RegressionInventoryManagementTest.java ---
1: package thkoeln.archilab.ecommerce.regression;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
8: import thkoeln.archilab.ecommerce.usecases.InventoryManagementUseCases;
9: 
10: import javax.transaction.Transactional;
11: import java.util.UUID;
12: 
13: import static org.junit.jupiter.api.Assertions.assertEquals;
14: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.PRODUCT_INVENTORY;
15: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.PRODUCT_DATA;
16: 
17: @SpringBootTest
18: @Transactional
19: public class RegressionInventoryManagementTest {
20: 
21:     @Autowired
22:     private InventoryManagementUseCases inventoryManagementUseCases;
23:     @Autowired
24:     private InitialMasterDataCreator initialMasterDataCreator;
25: 
26: 
27:     @BeforeEach
28:     public void setUp() {
29:         initialMasterDataCreator.deleteAll();
30:         initialMasterDataCreator.addAllProducts();
31:     }
32: 
33: 
34: 
35:     @Test
36:     public void testAddToInventory() {
37:         // given
38:         initialMasterDataCreator.inventoryUpAllProducts();
39:         UUID productId8 = (UUID) PRODUCT_DATA[8][0];
40: 
41:         // when
42:         int inventory8before = inventoryManagementUseCases.getAvailableInventory( productId8 );
43:         assertEquals( PRODUCT_INVENTORY.get( productId8 ), inventory8before );
44:         inventoryManagementUseCases.addToInventory( productId8, 22 );
45:         int inventory8after = inventoryManagementUseCases.getAvailableInventory( productId8 );
46:         inventoryManagementUseCases.addToInventory( productId8, 1 );
47:         int inventory8after2 = inventoryManagementUseCases.getAvailableInventory( productId8 );
48: 
49:         // then
50:         assertEquals( inventory8before + 22, inventory8after );
51:         assertEquals( inventory8after + 1, inventory8after2 );
52:     }
53: 
54: 
55:     @Test
56:     public void testRemoveFromInventory() {
57:         // given
58:         initialMasterDataCreator.inventoryUpAllProducts();
59:         UUID productId6 = (UUID) PRODUCT_DATA[6][0];
60:         int inventory6before = PRODUCT_INVENTORY.get( productId6 );
61:         UUID productId9 = (UUID) PRODUCT_DATA[9][0];
62:         int inventory9before = PRODUCT_INVENTORY.get( productId9 );
63:         UUID productId1 = (UUID) PRODUCT_DATA[1][0];
64:         int inventory1before = PRODUCT_INVENTORY.get( productId1 );
65: 
66:         // when
67:         inventoryManagementUseCases.removeFromInventory( productId6, 1 );
68:         int inventory6after = inventoryManagementUseCases.getAvailableInventory( productId6 );
69:         inventoryManagementUseCases.removeFromInventory( productId1, 3 );
70:         int inventory1after = inventoryManagementUseCases.getAvailableInventory( productId1 );
71:         inventoryManagementUseCases.removeFromInventory( productId9, inventory9before );
72:         int inventory9after = inventoryManagementUseCases.getAvailableInventory( productId9 );
73: 
74:         // then
75:         assertEquals( inventory6before - 1, inventory6after );
76:         assertEquals( inventory1before - 3, inventory1after );
77:         assertEquals( 0, inventory9after );
78:     }
79: 
80: }
81: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\regression\RegressionProductCatalogTest.java ---
1: package thkoeln.archilab.ecommerce.regression;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
9: import thkoeln.archilab.ecommerce.usecases.InventoryManagementUseCases;
10: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
12: 
13: import javax.transaction.Transactional;
14: import java.util.UUID;
15: 
16: import static org.junit.jupiter.api.Assertions.*;
17: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.PRODUCT_DATA;
18: 
19: @SpringBootTest
20: @Transactional
21: public class RegressionProductCatalogTest {
22: 
23:     @Autowired
24:     private ProductCatalogUseCases productCatalogUseCases;
25:     @Autowired
26:     private InventoryManagementUseCases inventoryManagementUseCases;
27:     @Autowired
28:     private InitialMasterDataCreator initialMasterDataCreator;
29: 
30:     @BeforeEach
31:     public void setUp() {
32:         initialMasterDataCreator.deleteAll();
33:     }
34: 
35: 
36: 
37:     @Test
38:     public void testAddProductToCatalog() {
39:         // given
40:         initialMasterDataCreator.addAllProducts();
41: 
42:         // when
43:         MoneyType sellPrice = productCatalogUseCases.getSellPrice( (UUID) PRODUCT_DATA[4][0] );
44: 
45:         // then
46:         assertEquals( PRODUCT_DATA[4][5], sellPrice );
47:     }
48: 
49:     @Test
50:     public void testRemoveProductFromCatalog() {
51:         // given
52:         initialMasterDataCreator.addAllProducts();
53:         UUID productId = (UUID) PRODUCT_DATA[4][0];
54: 
55:         // when
56:         assertDoesNotThrow( () -> productCatalogUseCases.getSellPrice( productId ) );
57:         productCatalogUseCases.removeProductFromCatalog( productId );
58: 
59:         // then
60:         assertThrows( ShopException.class, () -> productCatalogUseCases.getSellPrice( productId ) );
61:     }
62: 
63: 
64: 
65: 
66:     @Test
67:     public void testRemoveProductThatIsInInventory() {
68:         // given
69:         initialMasterDataCreator.addAllProducts();
70:         UUID productId = (UUID) PRODUCT_DATA[4][0];
71:         inventoryManagementUseCases.addToInventory( productId, 3 );
72: 
73:         // when
74:         // then
75:         assertThrows( ShopException.class, () -> productCatalogUseCases.removeProductFromCatalog( productId ) );
76:     }
77: 
78: 
79:     @Test
80:     public void testClearProductCatalog() {
81:         // given
82:         initialMasterDataCreator.addAllProducts();
83: 
84:         // when
85:         productCatalogUseCases.deleteProductCatalog();
86: 
87:         // then
88:         assertThrows( ShopException.class, () -> productCatalogUseCases.getSellPrice( (UUID) PRODUCT_DATA[4][0] ) );
89:     }
90: 
91: }
92: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\regression\RegressionUserRegistrationTest.java ---
1: package thkoeln.archilab.ecommerce.regression;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
10: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.UserType;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
13: 
14: import javax.transaction.Transactional;
15: 
16: import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
17: import static org.junit.jupiter.api.Assertions.assertThrows;
18: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.instantiateMailAddress;
19: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.USER_ADDRESS;
20: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.USER_EMAIL;
21: 
22: @SpringBootTest
23: @Transactional
24: public class RegressionUserRegistrationTest {
25: 
26:     @Autowired
27:     private UserRegistrationUseCases userRegistrationUseCases;
28:     @Autowired
29:     private InitialMasterDataCreator initialMasterDataCreator;
30: 
31:     private MailAddressType nonExistingMailAddress;
32: 
33:     @BeforeEach
34:     public void setUp() {
35:         initialMasterDataCreator.deleteAll();
36:         nonExistingMailAddress = instantiateMailAddress( "this@nononono.de" );
37:     }
38: 
39: 
40:     @Test
41:     public void testAllUsersRegistered() {
42:         // given
43:         initialMasterDataCreator.registerAllUsers();
44: 
45:         // when
46:         UserType user3 = userRegistrationUseCases.getUserData( USER_EMAIL[3] );
47: 
48:         // then
49:         Assertions.assertEquals( initialMasterDataCreator.USER_NAME[3], user3.getName() );
50:         Assertions.assertEquals( USER_EMAIL[3], user3.getMailAddress() );
51:         Assertions.assertEquals( USER_ADDRESS[3], user3.getPersonalAddress() );
52:     }
53: 
54: 
55:     @Test
56:     public void testRegisterUserWithDuplicateMailAddress() {
57:         // given
58:         initialMasterDataCreator.registerAllUsers();
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class, () ->
63:                 userRegistrationUseCases.register( "Gandalf The Grey", USER_EMAIL[5],
64:                         USER_ADDRESS[5] ) );
65:     }
66: 
67:     @Test
68:     public void testRegisterUserWithDuplicateNameOrPersonalAddress() {
69:         // given
70:         initialMasterDataCreator.registerAllUsers();
71:         MailAddressType newMailAddress = instantiateMailAddress( "some@this.de" );
72: 
73:         // when
74:         // then
75:         assertDoesNotThrow(() ->
76:                 userRegistrationUseCases.register( initialMasterDataCreator.USER_NAME[2], newMailAddress,
77:                         USER_ADDRESS[2] ) );
78:     }
79: 
80: 
81:     @Test
82:     public void testDeleteUsersNoMoreUsers() {
83:         // given
84:         initialMasterDataCreator.registerAllUsers();
85: 
86:         // when
87:         userRegistrationUseCases.deleteAllUsers();
88: 
89:         // then
90:         assertThrows( ShopException.class, () -> userRegistrationUseCases.getUserData( USER_EMAIL[0] ) );
91:     }
92: 
93: }
94: 

[RESPONSE]:
# Code Review - 4-Layer Architektur (Eric Evans)

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\MailAddress.java
**MailAddress.java Zeile 49-64**: Duplication (mehrfach dieselbe Exception) : Immer wieder `throw new ShopException("Invalid!")` statt spezifischer Fehlermeldungen.

**MailAddress.java Zeile 58-59**: Duplication (Original Zeile 58) : Gleiche Regex-Prüfung für beide Teile der Mailadresse.

**MailAddress.java Zeile 60-61**: Duplication (Original Zeile 60) : Gleiche Leerzeichenprüfung für beide Teile.

**MailAddress.java Zeile 62-63**: Duplication (Original Zeile 62) : Gleiche doppelte Punkt-Prüfung für beide Teile.

**MailAddress.java Zeile 51**: Negative conditionals : `!mailAddressAsString.contains("@") || StringUtils.countOccurrencesOf(mailAddressAsString, "@") > 1` - doppelte Negation mit "nicht enthält ODER mehr als 1".

**MailAddress.java Zeile 58-64**: Negative conditionals : Mehrere negierte Pattern-Abfragen (`!Pattern.compile(...).matcher(...).find()`).

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java
**Money.java Zeile 43-45**: Duplication (Original Zeile 43) : Mehrere `throw new ShopException("Invalid!")` ohne spezifische Meldung.

**Money.java Zeile 45**: Negative conditionals : `currency != "EUR" && currency != "CHF"` - String-Vergleich mit `!=` ist falsch, sollte `!currency.equals("EUR")` sein.

**Money.java Zeile 71**: Negative conditionals : `otherMoney.getCurrency() != this.currency` - String-Vergleich mit `!=`.

**Money.java Zeile 88**: Negative conditionals : `otherMoney.getCurrency() != this.currency` - String-Vergleich mit `!=`.

**Money.java Zeile 118**: Negative conditionals : `otherMoney == null || otherMoney.getCurrency() != this.getCurrency()` - kombinierte Bedingung.

**Money.java**: -Anemic Entity- : Klasse hat nur Getter/Setter und einfache Rechenoperationen, aber keine Domänenlogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PersonalAddress.java
**PersonalAddress.java Zeile 49-51**: Duplication (Original Zeile 49) : Immer wieder `throw new ShopException("Invalid!")`.

**PersonalAddress.java**: -Anemic Entity- : Nur Getter/Setter, keine Domänenlogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PostalCode.java
**PostalCode.java Zeile 39-41**: Duplication (Original Zeile 39) : Mehrere `throw new ShopException("Invalid!")`.

**PostalCode.java**: -Anemic Entity- : Nur Getter/Setter, keine Domänenlogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\UserTypeImplementation.java
**UserTypeImplementation.java**: -Anemic Entity- : Nur Getter/Setter, keine Domänenlogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\masterdata\FactoryMethodInvoker.java
**FactoryMethodInvoker.java Zeile 23-48, 51-79, 82-107, 110-135**: Duplication (Original Zeile 23-48) : Vier fast identische Methoden (instantiateMailAddress, instantiatePersonalAddress, instantiatePostalCode, instantiateMoney) mit gleichem Strukturmuster.

**FactoryMethodInvoker.java Zeile 42-44, 72-74, 101-103, 129-131**: Duplication (Original Zeile 42-44) : Immer gleiche Exception-Behandlung für InvocationTargetException.

**FactoryMethodInvoker.java**: missplaced responsibility : Diese Utility-Klasse gehört nicht in masterdata-Package, sondern in einen Infrastruktur-Layer oder Helper-Package.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\address\domain\Address.java
**Address.java**: -Anemic Entity- : Nur Getter/Setter, keine Domänenlogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\application\DeliveryService.java
**DeliveryService.java Zeile 45-49**: Duplication (Original Zeile 45) : Immer wieder ähnliche Null/Empty-Prüfungen mit `== ""`.

**DeliveryService.java Zeile 45-49**: Negative conditionals : Mehrere `== null || ... == ""` Bedingungen.

**DeliveryService.java Zeile 87**: Negative conditionals : `delivery.getMailAddress().toString() == userMailAddress.toString()` - String-Vergleich mit `==`.

**DeliveryService.java Zeile 103**: missplaced responsibility : `products.deleteAll()` gehört nicht in DeliveryService, der nur Lieferungen verwalten sollte.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\Delivery.java
**Delivery.java**: -Anemic Entity- : Nur Getter/Setter, keine Domänenlogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\DeliveryPosition.java
**DeliveryPosition.java**: -Anemic Entity- : Nur Getter/Setter, keine Domänenlogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java
**Order.java**: -Anemic Entity- : Nur Getter/Setter, keine Domänenlogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPosition.java
**OrderPosition.java**: -Anemic Entity- : Nur Getter/Setter, keine Domänenlogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\payment\application\PaymentService.java
**PaymentService.java Zeile 37-40**: Duplication (Original Zeile 37) : Mehrere ähnliche Validierungen.

**PaymentService.java Zeile 37**: Negative conditionals : `userMailAddress == null || userMailAddress.toString() == ""` - String-Vergleich mit `==`.

**PaymentService.java Zeile 65**: Negative conditionals : `payment.getMailAddress() == userMailAddress.toString()` - String-Vergleich mit `==`.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\payment\domain\Payment.java
**Payment.java**: -Anemic Entity- : Nur Getter/Setter, keine Domänenlogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\InventoryService.java
**InventoryService.java Zeile 40-62, 85-100**: Duplication (Original Zeile 40-62) : Fast identischer Code zum Reduzieren reservierter Mengen in zwei Methoden.

**InventoryService.java Zeile 84**: Duplication (Original Zeile 24) : `throw new ShopException("This product does not exist!")` schon in Zeile 79.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductCatalogService.java
**ProductCatalogService.java Zeile 27-34**: Duplication (Original Zeile 27) : Mehrere ähnliche Validierungen.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\Product.java
**Product.java**: -Anemic Entity- : Nur Getter/Setter, keine Domänenlogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java
**ShoppingBasketService.java Zeile 51-54, 66-69, 133-134, 155-156, 272-274, 301-303**: Duplication (Original Zeile 51-54) : Immer wieder ähnliche Validierungen.

**ShoppingBasketService.java Zeile 227**: Negative conditionals : `order.getMailAddress() == userMailAddress` - Vergleich von MailAddressType mit `==`.

**ShoppingBasketService.java Zeile 165-178**: missplaced responsibility : Validierungsmethoden `validateCheckoutUser` und `validateCheckoutBasket` sollten in einer separaten Validierungsklasse sein.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java
**ShoppingBasket.java**: -Anemic Entity- : Zwar hat es Methoden wie `addProduct`, aber diese sind simple Setter-Operationen ohne komplexe Domänenlogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java
**ShoppingBasketPosition.java**: -Anemic Entity- : Nur Getter/Setter, keine Domänenlogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserService.java
**UserService.java Zeile 27-29, 32-38, 48-51, 56-61**: Duplication (Original Zeile 27-29) : Mehrere ähnliche Validierungsblöcke.

**UserService.java Zeile 33**: Negative conditionals : `mailAddress.toString() == ""` - String-Vergleich mit `==`.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\User.java
**User.java**: -Anemic Entity- : Nur Getter/Setter, keine Domänenlogik.

---

## ZUSAMMENFASSUNG DER HÄUFIGSTEN SMELLS:
1. **Anemic Entities**: Fast alle Domain-Entities haben nur Getter/Setter ohne Domänenlogik.
2. **Duplication**: Vielfache Wiederholung von Validierungslogik und Exception-Handling.
3. **Negative Conditionals**: Häufige String-Vergleiche mit `==` statt `equals()` und komplexe negierte Bedingungen.
4. **Missplaced Responsibility**: Utility-Klassen in falschen Packages, Validierungslogik in Services.

## EMPFEHLUNGEN:
1. Domänenlogik in Entities verschieben (z.B. Validierungen)
2. Hilfsklassen für wiederkehrende Validierungen erstellen
3. String-Vergleiche mit `equals()` korrigieren
4. FactoryMethodInvoker in Infrastruktur-Layer verschieben

ENDE
Generated by deepseek-reasoner
-----------------------------------