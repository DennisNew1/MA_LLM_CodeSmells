--- DATE: 15.1.2026, 16:20:12 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
        Architektur: 4-Layer (Eric Evans).
        Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
        Regeln:
        1. Begründe kurz jeden Fund.
        4. Gruppiere nach Datei (mit Pfad). 
        2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
        3. Keine Code-Wiederholung, nur Referenzen.
        5. Wenn fertig, schreibe "ENDE". 
        6. Nutze die Zeilenangaben die mitgeschickt worden sind.



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Address.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Embeddable;
4: import jakarta.persistence.Embedded;
5: import lombok.AllArgsConstructor;
6: import lombok.EqualsAndHashCode;
7: import lombok.Getter;
8: import lombok.NoArgsConstructor;
9: import thkoeln.archilab.ecommerce.ShopException;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
11: 
12: @Embeddable
13: @AllArgsConstructor
14: @NoArgsConstructor
15: @EqualsAndHashCode
16: @Getter
17: public class Address implements thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType {
18:     private String street;
19:     private String city;
20:     @Embedded
21:     private ZipCode zipCode;
22: 
23:     @Override
24:     public String getStreet() {
25:         return street;
26:     }
27: 
28:     @Override
29:     public String getCity() {
30:         return city;
31:     }
32: 
33:     @Override
34:     public ZipCodeType getZipCode() {
35:         return zipCode;
36:     }
37: 
38: 
39:     public static Address of(String street, String city, ZipCodeType zipCode) {
40:         if (street == null || street.isEmpty()) throw new ShopException("street is null or empty");
41: 
42:         if (city == null || city.isEmpty()) throw new ShopException("city is null or empty");
43: 
44:         if (zipCode == null) throw new ShopException("zipCode is null");
45: 
46:         return new Address(street, city, (ZipCode) zipCode);
47:     }
48: }
49: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Currency.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.AllArgsConstructor;
5: import lombok.EqualsAndHashCode;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
10: 
11: import java.text.NumberFormat;
12: import java.util.Locale;
13: 
14: @Embeddable
15: @AllArgsConstructor
16: @NoArgsConstructor
17: @EqualsAndHashCode
18: @Getter
19: public class Currency implements CurrencyType {
20: 
21:     private Float quantity;
22:     private CurrencyEnum currencyUnit;
23: 
24:     @Override
25:     public Float getQuantity() {
26:         return quantity;
27:     }
28: 
29:     @Override
30:     public String getCurrencyUnit() {
31:         return currencyUnit.name();
32:     }
33: 
34: 
35:     @Override
36:     public String toString() {
37:         String currencySymbol = "€";
38:         if (currencyUnit.name().equals("CHF")) {
39:             currencySymbol = "CHF";
40:         }
41: 
42:         NumberFormat format = NumberFormat.getNumberInstance(Locale.getDefault());
43:         format.setMinimumFractionDigits(2);
44:         format.setMaximumFractionDigits(2);
45:         format.setGroupingUsed(false);
46: 
47:         String formatted = format.format(getQuantity());
48:         return formatted + " " + currencySymbol;
49:     }
50: 
51:     @Override
52:     public CurrencyType add(CurrencyType otherCurrency) {
53:         if (otherCurrency == null) throw new ShopException("otherCurrency is null");
54:         if(this.currencyUnit.name().equals(otherCurrency.getCurrencyUnit()) == false) {
55:             throw new ShopException("Currency units do not match");
56:         }
57:         return Currency.of(otherCurrency.getQuantity() + this.getQuantity(), this.getCurrencyUnit());
58:     }
59: 
60:     /**
61:      * @param otherCurrency
62:      * @return this - otherCurrency, as a new object
63:      * @throws ShopException if ...
64:      *                       - otherCurrency is null
65:      *                       - otherCurrency.currencyUnit != this.currencyUnit
66:      *                       - otherCurrency > this
67:      */
68:     @Override
69:     public CurrencyType subtract(CurrencyType otherCurrency) {
70:         if (otherCurrency == null) throw new ShopException("otherCurrency is null");
71:         if(this.currencyUnit.name().equals(otherCurrency.getCurrencyUnit()) == false) {
72:             throw new ShopException("Currency units do not match");
73:         }
74:         if(otherCurrency.getQuantity() > this.getQuantity()) {
75:             throw new ShopException("Currency quantity is less than 0");
76:         }
77:         float newQuantity = this.getQuantity() - otherCurrency.getQuantity();
78: 
79:         return Currency.of(newQuantity, this.getCurrencyUnit());
80: 
81:     }
82: 
83:     /**
84:      * @param factor
85:      * @return this * factor, as a new object
86:      * @throws ShopException if ...
87:      *                       - factor < 0
88:      */
89:     @Override
90:     public CurrencyType multiplyBy(int factor) {
91:         if(factor < 0) throw new ShopException("factor is negative");
92:         return Currency.of(this.getQuantity() * factor, this.getCurrencyUnit());
93:     }
94: 
95:     /**
96:      * @param otherCurrency
97:      * @return true, if this > otherCurrency
98:      * @throws ShopException if ...
99:      *                       - otherCurrency is null
100:      *                       - otherCurrency.currencyUnit != this.currencyUnit
101:      */
102:     @Override
103:     public boolean largerThan(CurrencyType otherCurrency) {
104:         if(otherCurrency == null) throw new ShopException("otherCurrency is null");
105:         if(this.currencyUnit.name().equals(otherCurrency.getCurrencyUnit()) == false) {
106:             throw new ShopException("Currency units do not match");
107:         }
108:         return this.getQuantity() > otherCurrency.getQuantity();
109:     }
110: 
111:     /**
112:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
113:      * implementing class to provide a static factory method (simply named "of(...)"),
114:      * which creates a currency object from an quantity and a currency unit (as string).
115:      * We specify this factory method here as a comment, using the Javadoc documentation style.
116:      *
117:      * @param quantity     the quantity of currency (must be >= 0)
118:      * @param currencyUnit the currency unit of the currency (allowed values: "EUR", "CHF")
119:      * @return a new Currency object with the given quantity and currency unit
120:      * @throws ShopException if ...
121:      *                       - quantity is null
122:      *                       - quantity < 0
123:      *                       - currency unit is null
124:      *                       - currency unit is not one of the allowed values
125:      */
126:     public static CurrencyType of(Float quantity, String currencyUnit) {
127:         if(quantity == null) {
128:             throw new ShopException("quantity is null");
129:         }
130:         if(quantity < 0) {
131:             throw new ShopException("quantity is less than 0");
132:         }
133:         if(currencyUnit == null) {
134:             throw new ShopException("currencyUnit is null");
135:         }
136:         if(isValidCurrency(currencyUnit) == false) {
137:             throw new ShopException("currencyUnit is not valid");
138:         }
139: 
140:         return new Currency(quantity, CurrencyEnum.valueOf(currencyUnit));
141:     }
142: 
143:     private static boolean isValidCurrency(String currencyUnit) {
144:         try {
145:             CurrencyEnum.valueOf(currencyUnit);
146:             return true;
147:         } catch (Exception e) {
148:             return false;
149:         }
150:     }
151: 
152: }
153: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\CurrencyEnum.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: public enum CurrencyEnum {
4:     EUR, CHF
5: }
6: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Email.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: import com.fasterxml.jackson.annotation.JsonProperty;
3: import jakarta.persistence.Embeddable;
4: import lombok.AllArgsConstructor;
5: import lombok.EqualsAndHashCode;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
10: 
11: @Embeddable
12: @AllArgsConstructor
13: @NoArgsConstructor
14: @EqualsAndHashCode
15: @Getter
16: public class Email implements EmailType {
17: 
18:     @JsonProperty("emailString")
19:     private String email;
20: 
21:     public String toString() {
22:         return email;
23:     }
24:     /**
25:      * A special kind of "copy constructor": Returns a new email object with
26:      * the same identifyer (the substring left of the "@" sign) as the current one, but
27:      * with a new domain substring (right of the "@" sign).
28:      *
29:      * @param domainString - the new domain for the copied email
30:      * @return the new email
31:      * @throws ShopException if ...
32:      *                       - domainString is null
33:      *                       - the new email would not be valid (see `of(...)` method)
34:      */
35:     @Override
36:     public EmailType sameIdentifyerDifferentDomain(String domainString) {
37:         if(domainString == null) throw new ShopException("domainString is null");
38: 
39:         String newMail = email.substring(0, email.indexOf("@")) + "@" + domainString;
40:         try{
41:             return Email.of(newMail);
42:         } catch (Exception e) {
43:             throw new ShopException("new email is not valid");
44:         }
45:     }
46: 
47:     /**
48:      * Another special kind of "copy constructor": Returns a new email object
49:      * with the same domain (the substring right of the "@" sign) as the current one, but
50:      * with a new identifyer substring (left of the "@" sign).
51:      *
52:      * @param identifyerString - the new identifyer for the copied email
53:      * @return the new email
54:      * @throws ShopException if ...
55:      *                       - identifyerString is null
56:      *                       - the new email would not be valid (see `of(...)` method)
57:      */
58:     @Override
59:     public EmailType sameDomainDifferentIdentifyer(String identifyerString) {
60:         String newMail = identifyerString + email.substring(email.indexOf("@"));
61:         try {
62:             return Email.of(newMail);
63:         } catch (ShopException e) {
64:             throw new ShopException("new email is not valid");
65:         }
66:     }
67: 
68: 
69:     /**
70:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
71:      * implementing class to provide a static factory method (simply named "of(...)"),
72:      * which creates an email, given as a string.
73:      * We specify this factory method here as a comment, using the Javadoc documentation style.
74:      *
75:      * @param emailAsString - the email as a string.
76:      *      We will use a much simplified validation method to check if the email is valid:
77:      *      - it must contain exactly one '@' character.
78:      *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
79:      *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
80:      *      - the substrings before and after the '@' may contain one or several '.' as separators
81:      *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
82:      *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
83:      *        (for simplicity we do not allow any other domains)
84:      * @return a new EmailType object matching the given email
85:      * @throws ShopException if ...
86:      *      - emailAsString is null
87:      *      - emailAsString is not a valid email (see above)
88:      */
89:     public static EmailType of( String emailAsString ) {
90:         if (emailAsString == null) {
91:             throw new ShopException("Email cannot be null");
92:         }
93: 
94:         // Check for exactly one '@'
95:         int atIndex = emailAsString.indexOf('@');
96:         if (atIndex == -1 || atIndex != emailAsString.lastIndexOf('@')) {
97:             throw new ShopException("Email must contain exactly one '@'");
98:         }
99: 
100:         String localPart = emailAsString.substring(0, atIndex);
101:         String domainPart = emailAsString.substring(atIndex + 1);
102: 
103:         // Basic non-empty checks
104:         if (localPart.isEmpty() || domainPart.isEmpty()) {
105:             throw new ShopException("Local or domain part is empty");
106:         }
107: 
108:         // Check for allowed characters (A-Z, a-z, 0-9, .) and no whitespace
109:         String validCharsRegex = "^[A-Za-z0-9]+(\\.?[A-Za-z0-9]+)*$";
110:         if (!localPart.matches(validCharsRegex) || !domainPart.matches(validCharsRegex)) {
111:             throw new ShopException("Email parts must contain only A-Z, a-z, 0-9 and dots, and no whitespace");
112:         }
113: 
114:         // No consecutive dots
115:         if (emailAsString.contains("..")) {
116:             throw new ShopException("Email must not contain consecutive dots");
117:         }
118: 
119:         // Domain must end with allowed TLDs
120:         if (!domainPart.matches(".*\\.(de|at|ch|com|org)$")) {
121:             throw new ShopException("Invalid top-level domain");
122:         }
123:         if (emailAsString.matches("^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$") && !emailAsString.matches(".*\\.\\.{2,}.*")) {
124:             return new Email( emailAsString );
125:         } else {
126:             throw new ShopException( "emailAsString is not a valid email" );
127:         }
128: 
129: 
130:     }
131: 
132: 
133: 
134: }
135: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\ConflictException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: @ResponseStatus(code = HttpStatus.CONFLICT)
7: public class ConflictException extends ShopException {
8:     public ConflictException(String message) {
9:         super(message);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\InsufficientInventoryException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: import org.springframework.http.HttpStatus;
3: import org.springframework.web.bind.annotation.ResponseStatus;
4: @ResponseStatus(code = HttpStatus.CONFLICT)
5: public class InsufficientInventoryException extends thkoeln.archilab.ecommerce.InsufficientInventoryException {
6:     public InsufficientInventoryException(String message) {
7:         super(message);
8:     }
9: }
10: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\MethodNotAllowedException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(HttpStatus.METHOD_NOT_ALLOWED)
8: public class MethodNotAllowedException extends ShopException {
9:     public MethodNotAllowedException(String message) {
10:         super(message);
11:     }
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\NotFoundException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Entity not found")
8: public class NotFoundException extends ShopException {
9:     public NotFoundException(String message){
10:         super(message);
11:     }
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\UnprocessableEntityException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY, reason="Entity or data is invalid")
8: public class UnprocessableEntityException extends ShopException {
9:     public UnprocessableEntityException(String message){
10:         super(message);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import jakarta.persistence.Embeddable;
5: import lombok.AllArgsConstructor;
6: import lombok.EqualsAndHashCode;
7: import lombok.Getter;
8: import lombok.NoArgsConstructor;
9: import thkoeln.archilab.ecommerce.ShopException;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
11: 
12: import static java.lang.Math.abs;
13: 
14: @Embeddable
15: @AllArgsConstructor
16: @NoArgsConstructor
17: @EqualsAndHashCode
18: @Getter
19: public class ZipCode implements ZipCodeType {
20:     @JsonProperty("zipCodeString")
21:     private String zipCode;
22: 
23:     public String toString() {
24:         return zipCode;
25:     }
26: 
27: 
28: 
29:     /***
30:     * - The return value is 0 if both zip codes are the same
31:      * - If not:
32:      *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
33:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
34:      *        So, 56733 and 56734 have the same difference as 56733 and 56739.
35:      *      - The difference grows if more digits (counted from the right side) differ.
36:      *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
37:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
38:      *        53876 and 54876 have the same difference as 53876 and 57261.
39:      *      - However, the difference between 5abcd and 6rstu must be smaller than the one
40:      *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
41:      *        one between 5abcd and 9rstu.
42:      *      - This last condition reflects the fact the first digits of a zip code marks a region
43:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
44:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
45:      *        other.
46:      */
47:     public int difference(ZipCodeType otherZipCode) {
48:         if (otherZipCode == null) throw new ShopException("otherZipCode is null");
49: 
50:         if(this.zipCode.equals(otherZipCode.toString())) return 0;
51: 
52:         int firstDigitOfThisZipCode = Character.getNumericValue(this.zipCode.charAt(0));
53:         int firstDigitOfOtherZipCode = Character.getNumericValue(otherZipCode.toString().charAt(0));
54:         int diff = Math.abs(firstDigitOfThisZipCode - firstDigitOfOtherZipCode);
55:         int zirkularDifference = Math.min(diff, 10 - diff );
56:         String difference = String.valueOf(zirkularDifference);
57: 
58:         for (int i = 1; i < this.zipCode.length(); i++) {
59:             if (this.zipCode.charAt(i) != otherZipCode.toString().charAt(i)) {
60:                 difference += "1";
61:                 for(int j = i + 1; j < this.zipCode.length(); j++) {
62:                     difference += "0";}
63:                 break;
64:             } else difference += "0";
65:         }
66:         return Integer.parseInt(difference);
67:     }
68: 
69: 
70:     public Integer getFirstDigitZipCode() {
71:         return Character.getNumericValue(this.zipCode.charAt(0));
72:     }
73: 
74: 
75:     public static ZipCodeType of(String zipCodeAsString) {
76:         if (zipCodeAsString == null) {
77:             throw new ShopException("zipCodeAsString is null");
78:         }
79:         if (isZipCodeValid(zipCodeAsString) == false) {
80:             throw new ShopException("zipCodeAsString is not a valid zip code");
81:         }
82:         return new ZipCode(zipCodeAsString);
83:     }
84: 
85:     public static Boolean isZipCodeValid(String zipCode) {
86:         if (zipCode.matches("^[0-9]{5}$") == false) {
87:             return false;
88:         }
89:         if (zipCode.substring(1).equals("0000")) {
90:             return false;
91:         }
92:         return true;
93:     }
94: }
95: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.Column;
7: import jakarta.persistence.MappedSuperclass;
8: import lombok.EqualsAndHashCode;
9: import lombok.Getter;
10: import lombok.ToString;
11: 
12: import java.io.Serializable;
13: import java.util.UUID;
14: 
15: @MappedSuperclass
16: @Getter
17: @EqualsAndHashCode(of = "id")
18: @ToString(of = "id")
19: public abstract class GenericId implements Serializable {
20:     @Column(nullable = false, updatable = false)
21:     private final UUID id;
22: 
23:     protected GenericId() {
24:         this( UUID.randomUUID() );
25:     }
26: 
27:     protected GenericId( UUID id ) {
28:         this.id = id;
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.AttributeConverter;
7: 
8: import java.util.UUID;
9: import java.util.function.Function;
10: 
11: 
12: public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
13:     private final Function<UUID, T> factory;
14: 
15:     protected GenericIdConverter( Function<UUID, T> factory ) {
16:         this.factory = factory;
17:     }
18: 
19:     @Override
20:     public UUID convertToDatabaseColumn( T attribute ) {
21:         return attribute == null ? null : attribute.getId();
22:     }
23: 
24:     @Override
25:     public T convertToEntityAttribute( UUID dbData ) {
26:         return dbData == null ? null : factory.apply( dbData );
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\InsufficientInventoryException.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: /**
7:  * Exception is thrown if the item's inventory level is not sufficient to serve the order.
8:  */
9: public class InsufficientInventoryException extends ShopException {
10:     public InsufficientInventoryException( String message ) {
11:         super( message );
12:     }
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import org.springframework.boot.SpringApplication;
7: import org.springframework.boot.autoconfigure.SpringBootApplication;
8: 
9: 
10: @SpringBootApplication
11: public class ProjectApplication {
12: 
13: 	/**
14: 	 * Entry method
15: 	 * @param args
16: 	 */
17: 	public static void main(String[] args) {
18: 		SpringApplication.run(ProjectApplication.class, args);
19: 	}
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: public class ShopException extends RuntimeException {
7:     public ShopException( String message ) {
8:         super( message );
9:     }
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\InventoryLevelDeletionInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.item.application;
2: 
3: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
4: 
5: public interface InventoryLevelDeletionInterface {
6:      Boolean existsInAnyInventoryLevel(ItemId itemId);
7:      void deleteAllInventoryLevels();
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ItemAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.item.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
6: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
7: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
9: 
10: import java.util.UUID;
11: 
12: @Service
13: public class ItemAdapterService implements ItemCatalogUseCases {
14:     private final ItemService itemService;
15: 
16:     @Autowired
17:     public ItemAdapterService(ItemService itemService) {
18:         this.itemService = itemService;
19:     }
20: 
21:     @Override
22:     public UUID addItemToCatalog(String name, String descriptOf, Float size, CurrencyType buyingPrice, CurrencyType sellingPrice) {
23:         return itemService.addItemToCatalog(name, descriptOf, size, (Currency) buyingPrice, (Currency) sellingPrice).getId();
24:     }
25: 
26:     @Override
27:     public void removeItemFromCatalog(UUID itemId) {
28:         itemService.removeItemFromCatalog(new ItemId(itemId));
29:     }
30: 
31:     @Override
32:     public CurrencyType getSellingPrice(UUID itemId) {
33:         return itemService.getSellingPrice(new ItemId(itemId));
34:     }
35: 
36:     @Override
37:     public void deleteItemCatalog() {
38:         itemService.deleteItemCatalog();
39:     }
40: }
41: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ItemService.java ---
1: package thkoeln.archilab.ecommerce.solution.item.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
7: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.ConflictException;
8: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.NotFoundException;
9: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
10: import thkoeln.archilab.ecommerce.solution.item.domain.Item;
11: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
12: import thkoeln.archilab.ecommerce.solution.item.domain.ItemRepository;
13: 
14: 
15: @Service
16: public class ItemService {
17: 
18:     private final ItemRepository itemRepository;
19:     private final InventoryLevelDeletionInterface inventoryLevelDeletionInterface;
20:     private final ShoppingCartDeletionInterface shoppingCartDeletionInterface;
21:     private final OrderDeletionInterface orderDeletionInterface;
22: 
23:     @Autowired
24:     public ItemService(ItemRepository itemRepository,
25:                        ShoppingCartDeletionInterface shoppingCartDeletionInterface,
26:                        OrderDeletionInterface orderDeletionInterface,
27:                        InventoryLevelDeletionInterface inventoryLevelDeletionService) {
28:         this.itemRepository = itemRepository;
29:         this.inventoryLevelDeletionInterface = inventoryLevelDeletionService;
30:         this.shoppingCartDeletionInterface = shoppingCartDeletionInterface;
31:         this.orderDeletionInterface = orderDeletionInterface;
32:     }
33:     /**
34:      * Adds a new item to the shop catalog
35:      * @param name
36:      * @param descriptOf
37:      * @param size
38:      * @param buyingPrice
39:      * @param sellingPrice
40:      * @return the id of the new item
41:      * @throws ShopException if ...
42:      *         - name or description are null or empty,
43:      *         - the size is <= 0 (but can be null!),
44:      *         - the buying price is null or <= 0,
45:      *         - the selling price is null or <= 0,
46:      *         - the selling price is lower than the buying price
47:      */
48: 
49:     public ItemId addItemToCatalog(String name, String descriptOf, Float size, Currency buyingPrice, Currency sellingPrice) {
50: 
51:         if(name == null || descriptOf == null || buyingPrice == null || sellingPrice == null) {
52:             throw new UnprocessableEntityException("Argument cannot be null");
53:         }
54:         if(name.isEmpty() || descriptOf.isEmpty()) {
55:             throw new UnprocessableEntityException("Name or description cannot be empty");
56:         }
57:         if(size != null && size <= 0) {
58:             throw new UnprocessableEntityException("Size must be greater than 0");
59:         }
60:         if(buyingPrice.getQuantity() <= 0) {
61:             throw new UnprocessableEntityException("Price must be greater than 0");
62:         }
63:         if(sellingPrice.getQuantity() <= 0) {
64:             throw new UnprocessableEntityException("Price must be greater than 0");
65:         }
66:         if(sellingPrice.getQuantity() < buyingPrice.getQuantity()) {
67:             throw new UnprocessableEntityException("Selling price must be greater than buying price");
68:         }
69: 
70:         Item item = new Item(name, descriptOf, size, buyingPrice, sellingPrice);
71:         itemRepository.save(item);
72: 
73:         return item.getId();
74:     }
75: 
76:     /**
77:      * Removes a item from the shop catalog
78:      * @param itemId
79:      * @throws ShopException if
80:      *      - the item id does not exist
81:      *      - the item is still in inventory
82:      *      - the item is still in a shopping cart, or referenced by a completed order
83:      */
84: 
85: 
86:     public void removeItemFromCatalog(ItemId itemId) {
87: 
88:         if(!itemRepository.existsById(itemId)) {
89:             throw new NotFoundException("Item not found");
90:         }
91:         if(inventoryLevelDeletionInterface.existsInAnyInventoryLevel(itemId)) {
92:             throw new ConflictException("Item is still in inventory");
93:         }
94:         if(shoppingCartDeletionInterface.existsInAnyShoppingCart(itemId)){
95:             throw new ConflictException("Item is still in a shopping cart");
96:         }
97:         if(orderDeletionInterface.existsInAnyOrder(itemId)){
98:             throw new ConflictException("Item is still in an order");
99:         }
100:         itemRepository.deleteById(itemId);
101:     }
102:     /**
103:      * Get the selling price of a given item
104:      * @param itemId
105:      * @return the selling price
106:      * @throws ShopException if the item id does not exist
107:      */
108: 
109:     public Currency getSellingPrice(ItemId itemId) {
110: 
111:         if(itemRepository.findById(itemId).isPresent()) {
112:             return itemRepository.findById(itemId).get().getSellingPrice();
113:         } else {
114:             throw new NotFoundException("Item not found");
115:         }
116:     }
117: 
118: 
119:     /**
120:      * Clears the item catalog, i.e. removes all items from the catalog, including all the inventory,
121:      * all the reservations and all the orders.
122:      */
123:     public void deleteItemCatalog() {
124:         inventoryLevelDeletionInterface.deleteAllInventoryLevels();
125:         shoppingCartDeletionInterface.deleteAll();
126:         orderDeletionInterface.deleteAll();
127:         itemRepository.deleteAll();
128:     }
129: 
130:     public Item getItemById(ItemId itemId) {
131:         if (itemIdNotExisting(itemId))
132:             return null;
133:         else
134:             return itemRepository.findById(itemId).get();
135:     }
136: 
137:     public Boolean itemIdNotExisting(ItemId itemId) {
138:         return !(itemId != null && itemRepository.existsById(itemId));
139:     }
140: }
141: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\OrderDeletionInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.item.application;
2: 
3: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
4: 
5: public interface OrderDeletionInterface {
6:     Boolean existsInAnyOrder(ItemId itemId);
7:     void deleteAll();
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ShoppingCartDeletionInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.item.application;
2: 
3: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
4: 
5: public interface ShoppingCartDeletionInterface {
6:     Boolean existsInAnyShoppingCart(ItemId itemId);
7:     void deleteAll();
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\Item.java ---
1: package thkoeln.archilab.ecommerce.solution.item.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.AccessLevel;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import lombok.Setter;
8: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
9: 
10: @Entity
11: @Setter
12: @Getter
13: @NoArgsConstructor
14: public class Item {
15: 
16:     @Setter(AccessLevel.PRIVATE)    // only for JPA
17:     @EmbeddedId
18:     private ItemId id;
19: 
20:     private String name;
21:     private String description;
22:     private Float size ;
23: 
24:     @Embedded
25:     @AttributeOverrides({
26:             @AttributeOverride(name = "quantity", column = @Column(name = "buying_price_quantity")),
27:             @AttributeOverride(name = "currencyUnit", column = @Column(name = "buying_price_currency"))
28:     })
29:     private Currency buyingPrice;
30: 
31:     @Embedded
32:     @AttributeOverrides({
33:             @AttributeOverride(name = "quantity", column = @Column(name = "selling_price_quantity")),
34:             @AttributeOverride(name = "currencyUnit", column = @Column(name = "selling_price_currency"))
35:     })
36:     private Currency sellingPrice;
37: 
38: 
39:     public Item(String name, String description, Float size, Currency buyingPrice, Currency sellingPrice) {
40:         this.id = new ItemId();
41:         this.name = name;
42:         this.description = description;
43:         this.size = size;
44:         this.buyingPrice = buyingPrice;
45:         this.sellingPrice = sellingPrice;
46:     }
47: 
48: 
49: 
50: }
51: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemId.java ---
1: package thkoeln.archilab.ecommerce.solution.item.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "item_id"))
15: public class ItemId extends GenericId {
16:     public ItemId(UUID id ) {
17:         super( id );
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.item.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ItemIdConverter extends GenericIdConverter<ItemId> {
8:     public ItemIdConverter() {
9:         super(ItemId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.item.domain;
2: 
3: 
4: import org.springframework.data.repository.CrudRepository;
5: import org.springframework.stereotype.Repository;
6: 
7: 
8: @Repository
9: public interface ItemRepository extends CrudRepository<Item, ItemId> {
10: 
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\dto\OrderDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application.dto;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.List;
9: import java.util.UUID;
10: 
11: 
12: @Setter
13: @Getter
14: @NoArgsConstructor
15: @AllArgsConstructor
16: public class OrderDTO {
17:     private UUID orderId;
18:     private String userName;
19:     private UUID storageUnitId;
20:     private List<OrderPositionDTO> positions;
21: }
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\dto\OrderDTOHelper.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application.dto;
2: 
3: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
4: 
5: import java.util.List;
6: 
7: public class OrderDTOHelper {
8:     public static OrderDTO entityToOrderDto(Order order, List<OrderPositionDTO> orderPositionDTOList, String userName){
9:         OrderDTO orderDTO = new OrderDTO();
10:         orderDTO.setOrderId(order.getId().getId());
11:         orderDTO.setPositions(orderPositionDTOList);
12:         orderDTO.setUserName(userName);
13:         orderDTO.setStorageUnitId(order.getStorageUnitId().getId());
14: 
15:         return orderDTO;
16:     }
17: }
18: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\dto\OrderPositionDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application.dto;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.UUID;
9: 
10: @Setter
11: @Getter
12: @NoArgsConstructor
13: @AllArgsConstructor
14: public class OrderPositionDTO {
15:     private UUID itemId;
16:     private Integer quantity;
17: }
18: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\dto\OrderPositionDTOHelper.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application.dto;
2: 
3: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
4: 
5: import java.util.ArrayList;
6: import java.util.List;
7: 
8: public class OrderPositionDTOHelper {
9: 
10:     public static OrderPositionDTO fromOrderPosition(OrderPosition orderPosition){
11:             return new OrderPositionDTO(orderPosition.getItemId().getId(), orderPosition.getQuantity());
12:     }
13: 
14:     public static List<OrderPositionDTO> fromListOfOrderPositions(List<OrderPosition> orderPositions){
15:         List<OrderPositionDTO> orderPositionDTOList = new ArrayList<>();
16:         for(OrderPosition each : orderPositions){
17:             orderPositionDTOList.add(fromOrderPosition(each));
18:         }
19:         return orderPositionDTOList;
20:     }
21: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.Email;
6: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
7: import thkoeln.archilab.ecommerce.usecases.OrderUseCases;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
9: 
10: import java.util.Map;
11: import java.util.UUID;
12: import java.util.stream.Collectors;
13: 
14: @Service
15: public class OrderAdapterService implements OrderUseCases {
16: 
17:     private final OrderService orderService;
18:     @Autowired
19:     public OrderAdapterService(OrderService orderService) {
20:         this.orderService = orderService;
21:     }
22: 
23: 
24:     @Override
25:     public Map<UUID, Integer> getOrderHistory(EmailType userEmail) {
26:         Map<ItemId, Integer> orderHistory = orderService.getOrderHistory((Email) userEmail);
27:         return orderHistory.entrySet().stream()
28:                 .collect(Collectors.toMap(entry -> entry.getKey().getId(), Map.Entry::getValue));
29: 
30:     }
31: 
32: 
33:     @Override
34:     public Integer getOrderQuantityOfItem(UUID orderId, UUID itemId) {
35:         return orderService.getOrderQuantityOfItem(orderId,itemId);
36:     }
37: 
38: 
39:     @Override
40:     public UUID getStorageUnitIdForOrder(UUID orderId) {
41:         return orderService.getStorageUnitIdForOrder(orderId);
42:     }
43: 
44:     @Override
45:     public void deleteAllOrders() {
46:         orderService.deleteAllOrders();
47:     }
48: }
49: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderDeletionService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.item.application.OrderDeletionInterface;
6: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
7: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPositionRepository;
8: import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
9: 
10: @Service
11: public class OrderDeletionService implements OrderDeletionInterface {
12: 
13:     private final OrderPositionRepository orderPositionRepository;
14:     private final OrderRepository orderRepository;
15: 
16:     @Autowired
17:     public OrderDeletionService(OrderPositionRepository orderPositionRepository, OrderRepository orderRepository) {
18:         this.orderPositionRepository = orderPositionRepository;
19:         this.orderRepository = orderRepository;
20:     }
21: 
22:     public Boolean existsInAnyOrder(ItemId itemId) {
23:         return orderPositionRepository.existsByItemId(itemId);
24:     }
25: 
26:     @Override
27:     public void deleteAll() {
28:         orderRepository.deleteAll();
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Email;
7: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.NotFoundException;
8: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
9: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
10: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
11: import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
12: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
13: import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
14: import thkoeln.archilab.ecommerce.solution.storageunit.application.StorageUnitService;
15: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
16: import thkoeln.archilab.ecommerce.solution.user.application.UserService;
17: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
18: 
19: import java.util.Map;
20: import java.util.Optional;
21: import java.util.UUID;
22: import java.util.stream.Collectors;
23: 
24: @Service
25: public class OrderService  {
26: 
27:     private final OrderRepository orderRepository;
28:     private final UserService userService;
29:     private final OrderDeletionService orderDeletionService;
30:     private final StorageUnitService storageUnitService;
31: 
32: 
33:     @Autowired
34:     public OrderService(
35:             OrderRepository orderRepository,
36:             UserService userService,
37:             OrderDeletionService orderDeletionService,
38:             StorageUnitService storageUnitService
39:     ) {
40:         this.orderRepository = orderRepository;
41:         this.userService = userService;
42:         this.orderDeletionService = orderDeletionService;
43:         this.storageUnitService = storageUnitService;
44:     }
45:     /**
46:      * Returns a map showing which items have been ordered by a user and how many of each item
47:      *
48:      * @param userEmail
49:      * @return the order history of the user (map is empty if the user has not ordered anything yet)
50:      * @throws ShopException if
51:      *                       - userEmail is null or empty
52:      *                       - the user with the given email does not exist
53:      */
54: 
55:     public Map<ItemId, Integer> getOrderHistory(Email userEmail) {
56: 
57:         if (userEmail == null || userEmail.toString().isEmpty()) throw new UnprocessableEntityException("User email cannot be null or empty");
58:         UserId userId = userService.getUserIdOrNullByEmail(userEmail);
59:         if(userId == null) throw new NotFoundException("User with email does not exist");
60: 
61:         return getOrderHistory(userId);
62:     }
63: 
64:     public Map<ItemId, Integer> getOrderHistory(UserId userId){
65:         return orderRepository.findAllByUserId(userId).get().stream()
66:                 .flatMap(order -> order.getOrderPositions().stream())
67:                 .collect(Collectors.toMap(
68:                         OrderPosition::getItemId,
69:                         OrderPosition::getQuantity,
70:                         Integer::sum // falls mehrfach das gleiche itemId vorkommt
71:                 ));
72:     }
73: 
74: 
75: 
76:     public Integer getOrderQuantityOfItem(UUID orderId, UUID itemId) {
77:         if (orderId == null || itemId == null) throw new UnprocessableEntityException("OrderID or ItemId should not be null");
78: 
79:         Optional<Order> order = orderRepository.findById(new OrderId(orderId));
80:         if (order.isEmpty()) throw new NotFoundException("Order is not found");
81: 
82:         Integer quantity = null;
83:         for (OrderPosition orderPosition : order.get().getOrderPositions()) {
84:             if (orderPosition.getItemId().equals(new ItemId(itemId))) {
85:                 quantity = orderPosition.getQuantity();
86:             }
87:         }
88:         return quantity;
89:     }
90: 
91:     public Order getOrderOrNull(OrderId orderId){
92:         Optional<Order> order = orderRepository.findById(orderId);
93:         return order.orElse(null);
94:     }
95: 
96:     public UUID getStorageUnitIdForOrder(UUID orderId) {
97:         Optional<Order> order = orderRepository.findById(new OrderId(orderId));
98:         if(order.isEmpty()) throw new NotFoundException("Order is not found");
99:         return order.get().getStorageUnitId().getId();
100:     }
101: 
102:     public void deleteAllOrders() { orderDeletionService.deleteAll();}
103: 
104:     public OrderId createOrder(Map<ItemId, Integer> map, StorageUnitId storageUnitId, UserId userId){
105: 
106:         Order order = new Order(userId, storageUnitId);
107: 
108:         for(Map.Entry<ItemId, Integer> each : map.entrySet()){
109:             order.addToOrderPosition(new OrderPosition(each.getValue(), each.getKey()));
110:             storageUnitService.removeFromInventory(storageUnitId, each.getKey(), each.getValue());
111:         }
112:         orderRepository.save(order);
113:         return order.getId();
114:     }
115: 
116: }
117: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: 
4: import jakarta.persistence.*;
5: import lombok.AccessLevel;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import lombok.Setter;
9: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
10: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
11: 
12: import java.util.ArrayList;
13: import java.util.List;
14: 
15: @Entity
16: @Table(name = "orders")
17: @Getter
18: @NoArgsConstructor
19: public class Order {
20:     @Setter(AccessLevel.PRIVATE)    // only for JPA
21:     @EmbeddedId
22:     private OrderId id;
23: 
24:     @OneToMany (cascade= CascadeType.ALL, fetch= FetchType.EAGER, orphanRemoval = true)
25:     private List<OrderPosition> orderPositions;
26: 
27:     @Embedded
28:     private UserId userId;
29: 
30:     @Embedded
31:     private StorageUnitId storageUnitId;
32: 
33:     public Order(UserId userId, StorageUnitId storageUnitId) {
34:         this.id = new OrderId();
35:         this.userId = userId;
36:         this.orderPositions = new ArrayList<>();
37:         this.storageUnitId = storageUnitId;
38:     }
39: 
40:     public void addToOrderPosition(OrderPosition orderPosition) {
41:         this.orderPositions.add(orderPosition);
42:     }
43: 
44: }
45: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderId.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "order_id"))
15: public class OrderId extends GenericId {
16:     public OrderId(UUID id ) {
17:         super( id );
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class OrderIdConverter extends GenericIdConverter<OrderId> {
8:     public OrderIdConverter() {
9:         super(OrderId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPosition.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.Embedded;
4: import jakarta.persistence.EmbeddedId;
5: import jakarta.persistence.Entity;
6: import lombok.AccessLevel;
7: import lombok.Getter;
8: import lombok.NoArgsConstructor;
9: import lombok.Setter;
10: import thkoeln.archilab.ecommerce.ShopException;
11: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
12: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
13: 
14: 
15: @Entity
16: @Getter
17: @NoArgsConstructor
18: public class OrderPosition {
19:     @Setter(AccessLevel.PRIVATE)    // only for JPA
20:     @EmbeddedId
21:     private OrderPositionId id;
22:     private Integer quantity;
23: 
24:     @Embedded
25:     private ItemId itemId;
26: 
27:     public OrderPosition(Integer quantity, ItemId itemId) {
28:         this.id = new OrderPositionId();
29:         setQuantity(quantity);
30:         this.itemId = itemId;
31:     }
32: 
33:     public void setQuantity(Integer quantity) {
34:         if (quantity <= 0) {
35:             throw new UnprocessableEntityException("Quantity cannot be negative");
36:         }
37:         this.quantity = quantity;
38:     }
39: }
40: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionId.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "orderPosition_id"))
15: public class OrderPositionId extends GenericId {
16:     public OrderPositionId(UUID id ) {
17:         super( id );
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class OrderPositionIdConverter extends GenericIdConverter<OrderPositionId> {
8:     public OrderPositionIdConverter() {
9:         super(OrderPositionId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
6: 
7: @Repository
8: public interface OrderPositionRepository extends CrudRepository<OrderPosition, OrderPositionId> {
9:     Boolean existsByItemId(ItemId itemId);
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
6: 
7: import java.util.List;
8: import java.util.Optional;
9: 
10: @Repository
11: public interface OrderRepository extends CrudRepository<Order, OrderRepository> {
12:     Optional<List<Order>> findAllByUserId(UserId userId);
13:     Optional<Order> findById(OrderId id);
14: }
15: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\dto\ShoppingCartDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application.dto;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.List;
9: import java.util.UUID;
10: 
11: @Getter
12: @Setter
13: @NoArgsConstructor
14: @AllArgsConstructor
15: public class ShoppingCartDTO {
16: 
17:     private UUID id;
18: 
19:     private String totalSellingPrice;
20: 
21:     private List<ShoppingCartPositionDTO> positions;
22: 
23: 
24: }
25: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\dto\ShoppingCartDTOHelper.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application.dto;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
4: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartId;
5: 
6: import java.util.List;
7: 
8: 
9: public class ShoppingCartDTOHelper {
10: 
11: 
12:     public static ShoppingCartDTO fromEntityToDTO(ShoppingCartId shoppingCartId, Currency totalValue, List<ShoppingCartPositionDTO> shoppingCartPositions) {
13:         ShoppingCartDTO shoppingCartDTO = new ShoppingCartDTO();
14:         shoppingCartDTO.setId(shoppingCartId.getId());
15:         shoppingCartDTO.setTotalSellingPrice(totalValue.toString().strip());
16:         shoppingCartDTO.setPositions(shoppingCartPositions);
17:         return shoppingCartDTO;
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\dto\ShoppingCartPositionDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application.dto;
2: 
3: 
4: import lombok.AllArgsConstructor;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import lombok.Setter;
8: import java.util.UUID;
9: 
10: @Getter
11: @Setter
12: @NoArgsConstructor
13: @AllArgsConstructor
14: public class ShoppingCartPositionDTO {
15:     private UUID itemId;
16:     private Integer quantity;
17: }
18: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\dto\ShoppingCartPositionDTOHelper.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application.dto;
2: 
3: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartPosition;
4: 
5: import java.util.ArrayList;
6: import java.util.List;
7: 
8: public class ShoppingCartPositionDTOHelper {
9: 
10:     public static ShoppingCartPositionDTO fromShoppingCartPosition(ShoppingCartPosition shoppingCartPosition){
11:         return new ShoppingCartPositionDTO(shoppingCartPosition.getItemId().getId(), shoppingCartPosition.getQuantity());
12:     }
13: 
14:     public static List<ShoppingCartPositionDTO> fromListOfShoppingCartPositions(List<ShoppingCartPosition> shoppingCartPositions){
15:         List<ShoppingCartPositionDTO> shoppingCartPositionDTOList = new ArrayList<>();
16:         for(ShoppingCartPosition each : shoppingCartPositions){
17:             shoppingCartPositionDTOList.add(fromShoppingCartPosition(each));
18:         }
19:         return shoppingCartPositionDTOList;
20:     }
21: }
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.Email;
6: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
7: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
8: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
11: 
12: import java.util.Map;
13: import java.util.Set;
14: import java.util.UUID;
15: import java.util.stream.Collectors;
16: 
17: @Service
18: public class ShoppingCartAdapterService implements ShoppingCartUseCases {
19: 
20:     private final ShoppingCartService shoppingCartService;
21:     @Autowired
22:     public ShoppingCartAdapterService(ShoppingCartService shoppingCartService) {
23:         this.shoppingCartService = shoppingCartService;
24:     }
25: 
26:     @Override
27:     public void addItemToShoppingCart(EmailType userEmail, UUID itemId, int quantityOf) {
28:         shoppingCartService.addItemToShoppingCart((Email) userEmail, new ItemId(itemId), quantityOf);
29:     }
30: 
31:     @Override
32:     public void removeItemFromShoppingCart(EmailType userEmail, UUID itemId, int quantityOf) {
33:         shoppingCartService.removeItemFromShoppingCart((Email) userEmail, new ItemId(itemId), quantityOf);
34:     }
35: 
36:     @Override
37:     public Map<UUID, Integer> getShoppingCartAsMap(EmailType userEmail) {
38:         Map<ItemId, Integer> shoppingCartAsMap = shoppingCartService.getShoppingCartAsMap((Email) userEmail);
39:         return shoppingCartAsMap.entrySet().stream()
40:                 .collect(Collectors.toMap(entry -> entry.getKey().getId(), Map.Entry::getValue));
41: 
42:     }
43: 
44:     @Override
45:     public CurrencyType getShoppingCartAsCurrencyValue(EmailType userEmail) {
46:         return shoppingCartService.getShoppingCartAsCurrencyValue((Email) userEmail);
47:     }
48: 
49:     @Override
50:     public Set<UUID> checkout(EmailType userEmail) {
51:         return shoppingCartService.checkout((Email) userEmail);
52:     }
53: 
54:     @Override
55:     public void emptyAllShoppingCarts() {
56:         shoppingCartService.emptyAllShoppingCarts();
57:     }
58: 
59:     public ShoppingCart getShoppingCart(EmailType email){
60:         return shoppingCartService.getShoppingCart((Email) email);
61:     }
62: }
63: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartController.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.http.HttpStatus;
5: import org.springframework.http.ResponseEntity;
6: import org.springframework.web.bind.annotation.*;
7: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
8: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.MethodNotAllowedException;
9: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.NotFoundException;
10: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
11: import thkoeln.archilab.ecommerce.solution.order.application.OrderService;
12: import thkoeln.archilab.ecommerce.solution.order.application.dto.OrderDTO;
13: import thkoeln.archilab.ecommerce.solution.order.application.dto.OrderDTOHelper;
14: import thkoeln.archilab.ecommerce.solution.order.application.dto.OrderPositionDTOHelper;
15: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
16: import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
17: import thkoeln.archilab.ecommerce.solution.shoppingcart.application.dto.ShoppingCartDTO;
18: import thkoeln.archilab.ecommerce.solution.shoppingcart.application.dto.ShoppingCartDTOHelper;
19: import thkoeln.archilab.ecommerce.solution.shoppingcart.application.dto.ShoppingCartPositionDTO;
20: import thkoeln.archilab.ecommerce.solution.shoppingcart.application.dto.ShoppingCartPositionDTOHelper;
21: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
22: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartId;
23: import thkoeln.archilab.ecommerce.solution.user.application.UserService;
24: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
25: 
26: import java.util.ArrayList;
27: import java.util.List;
28: import java.util.Set;
29: import java.util.UUID;
30: 
31: @RestController
32: public class ShoppingCartController {
33: 
34:     private final ShoppingCartService shoppingCartService;
35:     private final UserService userService;
36:     private final OrderService orderService;
37: 
38:     @Autowired
39:     public ShoppingCartController(ShoppingCartService shoppingCartService,
40:                                   UserService userService,
41:                                   OrderService orderService){
42:         this.shoppingCartService = shoppingCartService;
43:         this.userService = userService;
44:         this.orderService = orderService;
45:     }
46: 
47:     @GetMapping("/shoppingCarts")
48:     public ResponseEntity<ShoppingCartDTO> getShoppingCart(
49:             @RequestParam(value="userId", required = false) String userId){
50:         if(userId==null) throw new MethodNotAllowedException("method not allowed");
51: 
52:         UserId newUserId;
53:         try {
54:             newUserId = new UserId(UUID.fromString(userId));
55:         } catch (IllegalArgumentException e) {
56:             throw new NotFoundException("Invalid UUID format for userId");
57:         }
58: 
59:         ShoppingCart shoppingCart = shoppingCartService.getOrCreateShoppingCart(newUserId);
60: 
61:         Currency totalValue = shoppingCartService.getShoppingCartAsCurrencyValue(shoppingCart);
62: 
63:         List<ShoppingCartPositionDTO> shoppingCartPositionDTOs = ShoppingCartPositionDTOHelper.
64:                 fromListOfShoppingCartPositions(shoppingCart.getShoppingCartPositions());
65: 
66:         ShoppingCartDTO shoppingCartDTO = ShoppingCartDTOHelper.
67:                 fromEntityToDTO(shoppingCart.getId(), totalValue, shoppingCartPositionDTOs);
68: 
69:         return ResponseEntity.ok(shoppingCartDTO);
70:     }
71: 
72: 
73:     @PostMapping("/shoppingCarts/{shoppingCartId}/positions")
74:     public ResponseEntity addShoppingCartPosition(@PathVariable UUID shoppingCartId,
75:                                                   @RequestBody ShoppingCartPositionDTO shoppingCartPositionDTO){
76:         shoppingCartService.addItemToShoppingCart(new ShoppingCartId(shoppingCartId),
77:                 new ItemId(shoppingCartPositionDTO.getItemId()),
78:                 shoppingCartPositionDTO.getQuantity());
79: 
80:         return new ResponseEntity<>(HttpStatus.CREATED);
81:     }
82: 
83:     @DeleteMapping("/shoppingCarts/{shoppingCartId}/positions/{itemId}")
84:     public ResponseEntity deleteShoppingCartPosition(@PathVariable UUID shoppingCartId,
85:                                                      @PathVariable UUID itemId){
86:         shoppingCartService.removeAllQuantityOfItemFromShoppingCart(new ShoppingCartId(shoppingCartId), new ItemId(itemId));
87:         return new ResponseEntity<>(HttpStatus.OK);
88:     }
89: 
90: 
91:     @PostMapping("shoppingCarts/{shoppingCartId}/checkout")
92:     public ResponseEntity checkoutShoppingCart(@PathVariable UUID shoppingCartId){
93:         ShoppingCartId newShoppingCartId = new ShoppingCartId(shoppingCartId);
94:         if(!shoppingCartService.checkExistence(newShoppingCartId)) throw new NotFoundException("ShoppingCart is not found");
95: 
96:         ShoppingCart shoppingCart = shoppingCartService.getShoppingCart(newShoppingCartId);
97:         UserId userId = shoppingCart.getUserId();
98:         String userName = userService.getUserName(userId);
99: 
100:         Set<UUID> orders = shoppingCartService.checkout(newShoppingCartId);
101: 
102:         List<OrderDTO> orderDTOS = new ArrayList<>();
103: 
104:         Order order = null;
105: 
106:         for(UUID each : orders){
107:             order = orderService.getOrderOrNull(new OrderId(each));
108:             if(order != null) {
109:                 orderDTOS.add(
110:                         OrderDTOHelper.entityToOrderDto(
111:                                 order,
112:                                 OrderPositionDTOHelper.fromListOfOrderPositions(order.getOrderPositions()),
113:                                 userName));
114:             }
115:         }
116:         return ResponseEntity
117:                 .status(HttpStatus.CREATED)
118:                 .body(orderDTOS);
119:     }
120: 
121: 
122: }
123: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartDeletionService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.item.application.ShoppingCartDeletionInterface;
6: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
7: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartPositionRepository;
8: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartRepository;
9: 
10: @Service
11: public class ShoppingCartDeletionService implements ShoppingCartDeletionInterface {
12: 
13:     private final ShoppingCartPositionRepository shoppingCartPositionRepository;
14:     private final ShoppingCartRepository shoppingCartRepository;
15: 
16:     @Autowired
17:     public ShoppingCartDeletionService(ShoppingCartPositionRepository shoppingCartPositionRepository, ShoppingCartRepository shoppingCartRepository) {
18:         this.shoppingCartPositionRepository = shoppingCartPositionRepository;
19:         this.shoppingCartRepository = shoppingCartRepository;
20:     }
21: 
22:     public Boolean existsInAnyShoppingCart(ItemId itemId) {
23:         return shoppingCartPositionRepository.existsByItemId(itemId);
24:     }
25: 
26:     @Override
27:     public void deleteAll() {
28:         shoppingCartRepository.deleteAll();
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: 
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.stereotype.Service;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
8: import thkoeln.archilab.ecommerce.domainprimitives.Email;
9: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
10: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.ConflictException;
11: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.InsufficientInventoryException;
12: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.NotFoundException;
13: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
14: import thkoeln.archilab.ecommerce.solution.item.application.ItemService;
15: import thkoeln.archilab.ecommerce.solution.item.domain.Item;
16: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
17: import thkoeln.archilab.ecommerce.solution.order.application.OrderService;
18: import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
19: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
20: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartId;
21: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartPosition;
22: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartRepository;
23: import thkoeln.archilab.ecommerce.solution.storageunit.application.StorageUnitService;
24: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnit;
25: import thkoeln.archilab.ecommerce.solution.user.application.UserService;
26: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
27: 
28: import java.util.*;
29: import java.util.stream.Collectors;
30: 
31: @Service
32: public class ShoppingCartService {
33: 
34:     private final ShoppingCartRepository shoppingCartRepository;
35:     private final UserService userService;
36:     private final ItemService itemService;
37:     private final StorageUnitService storageUnitService;
38:     private final OrderService orderService;
39: 
40: 
41:     @Autowired
42:     public ShoppingCartService(ShoppingCartRepository shoppingCartRepository,
43:                                ItemService itemService, UserService userService,
44:                                StorageUnitService storageUnitService,
45:                                OrderService orderService) {
46:         this.shoppingCartRepository = shoppingCartRepository;
47:         this.userService = userService;
48:         this.itemService = itemService;
49:         this.storageUnitService = storageUnitService;
50:         this.orderService = orderService;
51:     }
52: 
53: 
54:     /**
55:      * Adds an item to the cart of a user
56:      * param userEmail
57:      * param itemId
58:      * param quantityOf
59:      * throws ShopException if ...
60:      *                       - userEmail is null or empty,
61:      *                       - the user with the given email does not exist,
62:      *                       - itemId is null,
63:      *                       - the item with itemId does not exist
64:      *                       - the Quantity is negative,
65:      */
66: 
67:     public void addItemToShoppingCart(Email userEmail, ItemId itemId, int quantityOf) {
68:         addItemToShoppingCart(getOrCreateShoppingCart(getUserId(userEmail)).getId(), itemId, quantityOf);
69:     }
70: 
71:     public void addItemToShoppingCart(ShoppingCartId shoppingCartId, ItemId itemId, int quantityOf){
72: 
73:         if (quantityOf <= 0) { throw new UnprocessableEntityException("Quantity is negative");}
74:         if(itemService.itemIdNotExisting(itemId)) {throw new NotFoundException("Item with the given id does not exist");}
75: 
76:         ShoppingCart shoppingCart = getShoppingCart(shoppingCartId);
77: 
78:         shoppingCart.addShoppingCartPosition(new ShoppingCartPosition(quantityOf, itemId));
79:         shoppingCartRepository.save(shoppingCart);
80:     }
81: 
82:     /**
83:      * Removes an item from the cart of a user
84:      * param userEmail
85:      * param itemId
86:      * param quantityOf
87:      * throws ShopException if ...
88:      *                       - userEmail is null or empty,
89:      *                       - the user with the given email does not exist,
90:      *                       - itemId is null,
91:      *                       - the item with itemId does not exist
92:      *                       - the Quantity is negative
93:      *                       - the item is not in the shopping cart in the requested Quantity
94:      */
95: 
96:     public void removeItemFromShoppingCart(Email userEmail, ItemId itemId, int quantityOf) {
97:         removeItemFromShoppingCart(getShoppingCart(getUserId(userEmail)).getId(), itemId, quantityOf);
98:     }
99: 
100:     public void removeItemFromShoppingCart(ShoppingCartId shoppingCartId, ItemId itemId, int quantityOf){
101:         if (quantityOf < 0)  throw new UnprocessableEntityException("Quantity is negative");
102:         if(itemService.itemIdNotExisting(itemId)) {throw new NotFoundException("Item with the given id does not exist");}
103: 
104:         ShoppingCart shoppingCart = getShoppingCart(shoppingCartId);
105:         shoppingCart.removeShoppingCartPosition(new ShoppingCartPosition(quantityOf, itemId));
106: 
107:         if (shoppingCart.getShoppingCartPositions().isEmpty())
108:             shoppingCartRepository.delete(shoppingCart);
109:         else
110:             shoppingCartRepository.save(shoppingCart);
111:     }
112: 
113:     public void removeAllQuantityOfItemFromShoppingCart(ShoppingCartId shoppingCartId, ItemId itemId){
114:         removeItemFromShoppingCart(shoppingCartId, itemId, getQuantityOfItemInShoppingCart(shoppingCartId, itemId));
115:     }
116: 
117:     public Integer getQuantityOfItemInShoppingCart(ShoppingCartId shoppingCartId, ItemId itemId){
118:         ShoppingCart shoppingCart = getShoppingCart(shoppingCartId);
119:         ShoppingCartPosition shoppingCartPosition = shoppingCart.getShoppingCartPositionOrNull(new ShoppingCartPosition(0, itemId));
120: 
121:         int quantity = 0;
122:         if(shoppingCartPosition != null) quantity = shoppingCartPosition.getQuantity();
123:         return quantity;
124:     }
125: 
126:     /**
127:      * Returns a map showing which items are in the cart of a user and how many of each item
128:      * param userEmail
129:      * return the cart of the user (map is empty if the cart is empty)
130:      * throws ShopException if
131:      *                       - the user with the given email does not exist
132:      */
133: 
134:     public Map<ItemId, Integer> getShoppingCartAsMap(Email userEmail) {
135:         return shoppingCartToMap(getOrCreateShoppingCart(getUserId(userEmail)));
136:     }
137: 
138:     protected Map<ItemId, Integer> shoppingCartToMap(ShoppingCart shoppingCart){
139:         return shoppingCart.getShoppingCartPositions().stream()
140:                 .collect(Collectors.toMap(
141:                         ShoppingCartPosition::getItemId,
142:                         ShoppingCartPosition::getQuantity,
143:                         Integer::sum
144:                 ));
145:     }
146: 
147:     /**
148:      * Returns the current value of all items in the cart of a user
149:      * param userEmail
150:      * return the cart of the user
151:      * throws ShopException if the user with the given email does not exist
152:      */
153:     public Currency getShoppingCartAsCurrencyValue(Email userEmail) {
154:         return getShoppingCartAsCurrencyValue(getShoppingCart(getUserId(userEmail)));
155:     }
156: 
157:     protected Currency getShoppingCartAsCurrencyValue(ShoppingCart shoppingCart){
158:         Map<ItemId, Integer> shoppingCartAsMap = shoppingCartToMap(shoppingCart);
159: 
160:         float totalValueFloat = 0F;
161:         for(Map.Entry<ItemId, Integer> entry : shoppingCartAsMap.entrySet()) {
162:             Item item = itemService.getItemById(entry.getKey());
163:             if(item != null) {
164:                 totalValueFloat += item.getSellingPrice().getQuantity() * entry.getValue();
165:             }
166:         }
167:         return (Currency) Currency.of(totalValueFloat, "EUR");
168: 
169:     }
170:     /**
171:      * Checks out the cart of a user
172:      *
173:      * @param userEmail
174:      * @return A set of ids belonging to orders that were created during the checkout. If the shopping cart can
175:      *         only be served from more than one storage unit, each shipment from a storage unit gets a
176:      *         dedicated order. I.e. if there is just one shipment, then the set will contain just one order id.
177:      *         If there are multiple shipments, the set will contain multiple order ids.
178:      * @throws ShopException if
179:      *      - userEmail is null or empty
180:      *      - the user with the given email does not exist, or if the cart is empty
181:      * @throws
182:      *      - ShopException if userEmail is null
183:      *      - InsufficientInventoryException if there is not enough inventory level for to serve the order
184:      *        for all items in the shopping cart
185:      */
186: 
187: 
188:     public Set<UUID> checkout(Email userEmail) {
189:         return checkout(getShoppingCart(userEmail).getId());
190:     }
191: 
192: 
193:     protected Set<UUID> checkout(ShoppingCartId shoppingCartId) {
194:         ShoppingCart shoppingCart = getShoppingCart(shoppingCartId);
195:         if(shoppingCart.getShoppingCartPositions().isEmpty()) {throw new ConflictException("ShoppingCart is empty");}
196:         UserId userId = shoppingCart.getUserId();
197:         ZipCode zipCode = userService.getUserZipCodeOrNull(userId);
198:         Map<ShoppingCart, StorageUnit> virtualShoppingCarts = new HashMap<>();
199: 
200:         do {
201:             Map<ItemId, Integer> map = shoppingCartToMap(shoppingCart);
202: 
203:             StorageUnit bestStorageUnitId = storageUnitService.findBestStorageUnit(map, zipCode);
204:             if (bestStorageUnitId == null) throw new ConflictException("no storage Units found");
205: 
206:             ShoppingCart virtualShopCart = createVirtualShoppingCart(bestStorageUnitId, map, userId);
207:             if (virtualShopCart == null) {throw new InsufficientInventoryException("Not enough inventory in any storageUnit");}
208: 
209:             virtualShoppingCarts.put(virtualShopCart, bestStorageUnitId);
210:             shoppingCart.removeShoppingCartPositions(virtualShopCart.getShoppingCartPositions());
211:         } while (!shoppingCart.getShoppingCartPositions().isEmpty()) ;
212: 
213:         Set<UUID> orderings = new HashSet<>();
214:         for(Map.Entry<ShoppingCart, StorageUnit> each : virtualShoppingCarts.entrySet()){
215:             OrderId orderId = orderService.createOrder(shoppingCartToMap(each.getKey()),
216:                     each.getValue().getId(), userId);
217:             orderings.add(orderId.getId());
218:         }
219: 
220:         shoppingCartRepository.save(shoppingCart);
221:         return orderings;
222:     }
223: 
224:     private ShoppingCart createVirtualShoppingCart(StorageUnit storageUnit, Map<ItemId, Integer> map, UserId userid){
225: 
226:         ShoppingCart shoppingCart1 = new ShoppingCart(userid);
227: 
228:         for (Map.Entry<ItemId, Integer> each : map.entrySet()) {
229:             int available = storageUnitService.getAvailableInventory(storageUnit.getId(), each.getKey());
230:             int required = each.getValue();
231: 
232:             if (available >= required) {
233:                 shoppingCart1.addShoppingCartPosition(new ShoppingCartPosition(required, each.getKey()));
234:             }
235:         }
236: 
237:         if(shoppingCart1.getShoppingCartPositions().isEmpty()) {return null;}
238:         return shoppingCart1;
239:     }
240: 
241:     public void emptyAllShoppingCarts() {
242:         shoppingCartRepository.findAll()
243:                 .forEach(shoppingCart -> {
244:                     shoppingCart.getShoppingCartPositions().clear();
245:                     shoppingCartRepository.save(shoppingCart);
246:                 });
247:     }
248: 
249:     protected ShoppingCart getOrCreateShoppingCart(UserId userId) {
250: 
251:         if(!userService.userExists(userId)) throw new NotFoundException("User does not exist");
252:         Optional <ShoppingCart> shoppingCart = shoppingCartRepository.findByUserId(userId);
253: 
254:         if (shoppingCart.isPresent()) return shoppingCart.get();
255:         else {
256:             ShoppingCart newShoppingCart = new ShoppingCart(userId);
257:             shoppingCartRepository.save(newShoppingCart);
258:             return newShoppingCart;
259:         }
260: 
261:     }
262: 
263:     public ShoppingCart getShoppingCart(UserId userId){
264:         if(userId == null) throw new NotFoundException("UserId is null");
265: 
266:         Optional <ShoppingCart> shoppingCart = shoppingCartRepository.findByUserId(userId);
267:         if (shoppingCart.isEmpty()) throw new NotFoundException("ShoppingCart is not found");
268:         return shoppingCart.get();
269:     }
270: 
271:     public ShoppingCart getShoppingCart(Email email){
272:         return getShoppingCart(getUserId(email));
273:     }
274: 
275:     public ShoppingCart getShoppingCart(ShoppingCartId shoppingCartId){
276:         Optional <ShoppingCart> shoppingCart = shoppingCartRepository.findById(shoppingCartId);
277:         if (shoppingCart.isEmpty()) throw new NotFoundException("ShoppingCart is not found");
278:         return shoppingCart.get();
279:     }
280: 
281:     public UserId getUserId(Email email){
282:         if(email == null || email.toString().isEmpty()) throw new UnprocessableEntityException("User email is null or empty");
283:         UserId userId = userService.getUserIdOrNullByEmail(email);
284:         if( userId == null) throw new NotFoundException("No UserId found for given Email");
285:         return userId;
286:     }
287: 
288:     public Boolean checkExistence(ShoppingCartId shoppingCartId){ return shoppingCartRepository.existsById(shoppingCartId);}
289: 
290: }
291: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCart.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.AccessLevel;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import lombok.Setter;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
10: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.NotFoundException;
11: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
12: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
13: 
14: import java.util.ArrayList;
15: import java.util.List;
16: 
17: @Entity
18: @Getter
19: @NoArgsConstructor
20: public class ShoppingCart {
21:     @Setter(AccessLevel.PRIVATE)    // only for JPA
22:     @EmbeddedId
23:     private ShoppingCartId id;
24: 
25:     @Setter
26:     @OneToMany(cascade= CascadeType.ALL, fetch= FetchType.EAGER, orphanRemoval = true)
27:     private List<ShoppingCartPosition> shoppingCartPositions;
28: 
29:     @Embedded
30:     private UserId userId;
31: 
32:     public ShoppingCart(UserId userId) {
33:         this.id = new ShoppingCartId();
34:         this.shoppingCartPositions = new ArrayList<>();
35:         this.userId = userId;
36:     }
37: 
38:     public void addShoppingCartPosition(ShoppingCartPosition shoppingCartPosition) {
39:         for(ShoppingCartPosition existingPosition : this.shoppingCartPositions) {
40:             if (existingPosition.getItemId().equals(shoppingCartPosition.getItemId())) {
41:                 int newQuantity = existingPosition.getQuantity() + shoppingCartPosition.getQuantity();
42:                 existingPosition.setQuantity(newQuantity);
43:                 return;
44:             }
45:         }
46:         this.shoppingCartPositions.add(shoppingCartPosition);
47:     }
48: 
49:     public void removeShoppingCartPosition(ShoppingCartPosition shoppingCartPosition) {
50:         for(ShoppingCartPosition existingPosition : this.shoppingCartPositions) {
51:             if (existingPosition.getItemId().equals(shoppingCartPosition.getItemId())) {
52:                 int newQuantity = existingPosition.getQuantity() - shoppingCartPosition.getQuantity();
53:                 if (newQuantity > 0) {
54:                     existingPosition.setQuantity(newQuantity);
55:                 } else if (newQuantity == 0) {
56:                     this.shoppingCartPositions.remove(existingPosition);
57:                 }
58:                 else {
59:                     throw new UnprocessableEntityException("quantity cannot be negative");
60:                 }
61:                 return;
62:             }
63:         }
64:         throw new NotFoundException("no shopping cart position found for item " + shoppingCartPosition.getItemId());
65:     }
66: 
67:     public void removeShoppingCartPositions(Iterable<ShoppingCartPosition> list){
68:         for(ShoppingCartPosition shoppingCartPosition : list){
69:             removeShoppingCartPosition(shoppingCartPosition);
70:         }
71:     }
72: 
73:     public ShoppingCartPosition getShoppingCartPositionOrNull(ShoppingCartPosition shoppingCartPosition){
74:         for(ShoppingCartPosition shoppingCartPosition1 : this.shoppingCartPositions){
75:             if( shoppingCartPosition1.getItemId().equals(shoppingCartPosition.getItemId()))
76:                 return shoppingCartPosition1;
77:         }
78:         return null;
79:     }
80: }
81: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "shoppingCart_id"))
15: public class ShoppingCartId extends GenericId {
16:     public ShoppingCartId(UUID id ) {
17:         super( id );
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ShoppingCartIdConverter extends GenericIdConverter<ShoppingCartId> {
8:     public ShoppingCartIdConverter() {
9:         super(ShoppingCartId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPosition.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.Embedded;
4: import jakarta.persistence.EmbeddedId;
5: import jakarta.persistence.Entity;
6: import lombok.AccessLevel;
7: import lombok.Getter;
8: import lombok.NoArgsConstructor;
9: import lombok.Setter;
10: import thkoeln.archilab.ecommerce.ShopException;
11: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
12: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
13: 
14: @Entity
15: @Getter
16: @NoArgsConstructor
17: public class ShoppingCartPosition {
18:     @Setter(AccessLevel.PRIVATE)    // only for JPA
19:     @EmbeddedId
20:     private ShoppingCartPositionId id;
21:     private Integer quantity;
22: 
23: 
24:     @Embedded
25:     private ItemId itemId;
26: 
27:     public ShoppingCartPosition(Integer quantity, ItemId itemId) {
28:         this.id = new ShoppingCartPositionId();
29:         setQuantity(quantity);
30:         this.itemId = itemId;
31:     }
32: 
33:     public void setQuantity(Integer quantity) {
34:         if (quantity < 0) {
35:             throw new UnprocessableEntityException("Quantity cannot be negative");
36:         }
37:         this.quantity = quantity;
38:     }
39: }
40: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPositionId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "shoppingCartPosition_id"))
15: public class ShoppingCartPositionId extends GenericId {
16:     public ShoppingCartPositionId(UUID id ) {
17:         super( id );
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPositionIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ShoppingCartPositionIdConverter extends GenericIdConverter<ShoppingCartPositionId> {
8:     public ShoppingCartPositionIdConverter() {
9:         super(ShoppingCartPositionId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPositionRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
6: 
7: @Repository
8: public interface ShoppingCartPositionRepository extends CrudRepository<ShoppingCartPosition, ShoppingCartPositionId> {
9:     Boolean existsByItemId(ItemId itemId);
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
6: 
7: import java.util.Optional;
8: 
9: @Repository
10: public interface ShoppingCartRepository extends CrudRepository<ShoppingCart, ShoppingCartId> {
11:     Optional<ShoppingCart> findByUserId(UserId userId);
12:   }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\InventoryLevelDeletionService.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.item.application.InventoryLevelDeletionInterface;
6: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
7: import thkoeln.archilab.ecommerce.solution.storageunit.domain.InventoryLevel;
8: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnit;
9: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitRepository;
10: 
11: @Service
12: public class InventoryLevelDeletionService implements InventoryLevelDeletionInterface {
13: 
14:     private final StorageUnitRepository storageUnitRepository;
15: 
16:     @Autowired
17:     public InventoryLevelDeletionService( StorageUnitRepository storageUnitRepository) {
18:         this.storageUnitRepository = storageUnitRepository;
19:     }
20: 
21:     public Boolean existsInAnyInventoryLevel(ItemId itemId) {
22:         for (StorageUnit storageUnit : storageUnitRepository.findAll()) {
23:             for (InventoryLevel inventoryLevel : storageUnit.getInventoryLevels()) {
24:                 if (inventoryLevel.getItemId().equals(itemId)) {
25:                     return true;
26:                 }
27:             }
28:         }
29:         return false;
30:     }
31: 
32:     public void deleteAllInventoryLevels() {
33:         for(StorageUnit storageUnit : storageUnitRepository.findAll()){
34:             storageUnit.setInventoryLevels(null);
35:             storageUnitRepository.save(storageUnit);
36:         }
37:     }
38: 
39: 
40: 
41:     // TODO() FRAGE: Dürfte das oder MUSS ich über StorageUnit gehen? AggretateRoot...
42:     //public Boolean existByItemId(ItemId itemId) {
43:     //    return inventoryLevelRepository.existsByItemId(itemId);
44:     //}
45: }
46: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\StorageUnitAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.application;
2: import org.springframework.beans.factory.annotation.Autowired;
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.domainprimitives.Address;
5: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
6: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
7: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
9: 
10: import java.util.UUID;
11: 
12: @Service
13: public class StorageUnitAdapterService implements StorageUnitUseCases {
14: 
15:     private final StorageUnitService storageUnitService;
16: 
17:     @Autowired
18:     public StorageUnitAdapterService(StorageUnitService storageUnitService) {
19:         this.storageUnitService = storageUnitService;
20:     }
21: 
22: 
23: 
24:     @Override
25:     public UUID addNewStorageUnit(String name, AddressType address) {
26:         return storageUnitService.addNewStorageUnit(name, (Address) address).getId();
27:     }
28: 
29:     @Override
30:     public void deleteAllStorageUnits() {
31:         storageUnitService.deleteAllStorageUnits();
32:     }
33: 
34: 
35:     @Override
36:     public void addToInventory(UUID storageUnitId, UUID itemId, int addedQuantityOf) {
37:         storageUnitService.addToInventory(new StorageUnitId(storageUnitId), new ItemId(itemId), addedQuantityOf);
38:     }
39: 
40:     @Override
41:     public void removeFromInventory(UUID storageUnitId, UUID itemId, int removedQuantityOf) {
42:         storageUnitService.removeFromInventory(new StorageUnitId(storageUnitId), new ItemId(itemId), removedQuantityOf);
43:     }
44: 
45: 
46:     @Override
47:     public void changeInventoryTo(UUID storageUnitId, UUID itemId, int newTotalQuantityOf) {
48:         storageUnitService.changeInventoryTo(new StorageUnitId(storageUnitId), new ItemId(itemId), newTotalQuantityOf);
49:     }
50: 
51:     @Override
52:     public int getAvailableInventory(UUID storageUnitId, UUID itemId) {
53:         return storageUnitService.getAvailableInventory(new StorageUnitId(storageUnitId), new ItemId(itemId));
54:     }
55: }
56: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\StorageUnitService.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Address;
7: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
8: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.NotFoundException;
9: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
10: import thkoeln.archilab.ecommerce.solution.item.application.ItemService;
11: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
12: import thkoeln.archilab.ecommerce.solution.storageunit.domain.*;
13: 
14: import java.util.List;
15: import java.util.Map;
16: 
17: 
18: @Service
19: public class StorageUnitService {
20: 
21:     private final StorageUnitRepository storageUnitRepository;
22:     private final ItemService itemService;
23: 
24:     @Autowired
25:     public StorageUnitService(StorageUnitRepository storageUnitRepository, ItemService itemService) {
26:         this.storageUnitRepository = storageUnitRepository;
27:         this.itemService = itemService;
28:     }
29: 
30: 
31:     public StorageUnitId addNewStorageUnit(String name, Address address) {
32: 
33:         validateShopDetails(name, address);
34:         StorageUnit storageUnit = new StorageUnit(name, address);
35:         storageUnitRepository.save(storageUnit);
36:         return storageUnit.getId();
37:     }
38: 
39: 
40:     public void deleteAllStorageUnits() {storageUnitRepository.deleteAll();}
41: 
42: 
43:     public void addToInventory(StorageUnitId storageUnitId, ItemId itemId, int addedQuantityOf) {
44:         if( addedQuantityOf < 0) throw new UnprocessableEntityException("Quantity cannot be negative");
45: 
46:         if(!storageUnitRepository.existsById(storageUnitId) ) {
47:             throw new NotFoundException("No suitable storage unit found for the given id");
48:         }
49:         StorageUnit storageUnit = storageUnitRepository.findById(storageUnitId).get();
50: 
51:         if(itemService.itemIdNotExisting(itemId)) throw new NotFoundException("ItemId ist not existing");
52: 
53:         storageUnit.addInventoryLevel(new InventoryLevel(itemId, addedQuantityOf));
54:         storageUnitRepository.save(storageUnit);
55:     }
56: 
57: 
58:     public void removeFromInventory(StorageUnitId storageUnitId, ItemId itemId, int removedQuantityOf) {
59:         if(removedQuantityOf < 0) throw new UnprocessableEntityException("Quantity cannot be negative");
60: 
61:         if(!storageUnitRepository.existsById(storageUnitId) ) {
62:             throw new NotFoundException("No storage unit found for the given id");
63:         }
64:         if(itemService.itemIdNotExisting(itemId)) throw new NotFoundException("ItemId is not existing");
65: 
66: 
67:         StorageUnit storageUnit = storageUnitRepository.findById(storageUnitId).get();
68: 
69:         storageUnit.removeInventoryLevel(new InventoryLevel(itemId, removedQuantityOf));
70:         storageUnitRepository.save(storageUnit);
71:     }
72: 
73: 
74:     public void changeInventoryTo(StorageUnitId storageUnitId, ItemId itemId, int newTotalQuantityOf) {
75:         validateStorageUnitExistenceById(storageUnitId);
76:         if(itemService.itemIdNotExisting(itemId)){
77:             throw new NotFoundException("Item with the given id does not exist");
78:         }
79:         if(newTotalQuantityOf < 0) throw new UnprocessableEntityException("Quantity cannot be negative");
80: 
81:         StorageUnit storageUnit = storageUnitRepository.findById(storageUnitId).get();
82:         storageUnit.changeInventoryLevel(new InventoryLevel(itemId, newTotalQuantityOf));
83: 
84:         storageUnitRepository.save(storageUnit);
85:     }
86: 
87: 
88:     public int getAvailableInventory(StorageUnitId storageUnitId, ItemId itemId) {
89:         validateStorageUnitExistenceById(storageUnitId);
90:         if(itemService.itemIdNotExisting(itemId)){
91:             throw new NotFoundException("Item with the given id does not exist");
92:         }
93:         StorageUnit storageUnit = storageUnitRepository.findById(storageUnitId).get();
94:         for(InventoryLevel inventoryLevel : storageUnit.getInventoryLevels()){
95:             if(inventoryLevel.getItemId().equals(itemId)){
96:                 return inventoryLevel.getQuantity();
97:             }
98:         }
99:         return 0;
100:     }
101: 
102:     public StorageUnit findBestStorageUnit(Map<ItemId, Integer> map, ZipCode zipcode){
103:         StorageUnitComparator comparator = new StorageUnitComparator(map, zipcode);
104: 
105:         List<StorageUnit> storageUnits = (List<StorageUnit>) storageUnitRepository.findAll();
106:         storageUnits.sort(comparator);
107:         if(storageUnits.isEmpty()){
108:             return null;
109:         } else return storageUnits.getLast();
110:     }
111: 
112: /**
113:  * Validation methods
114:  *
115:  * @throws ShopException if ...
116:  *      - name, street, city are null or empty
117:  *      - zipCode is null, empty, or not a valid zip code
118:  *      - fromZipCodeFirstDigit is null, or not between 0 und 9
119:  *      - toZipCodeFirstDigit is null, >9, or < fromZipCodeFirstDigit
120:  */
121: 
122: 
123: private void validateShopDetails(String name, Address address) {
124:     if(address == null) {
125:         throw new ShopException("Address cannot be null");
126:     }
127:     validateNotEmpty(name, "Name");
128:     validateNotEmpty(address.getStreet(), "Street");
129:     validateNotEmpty(address.getCity(), "City");
130:     validateZipCodeLength(address.getZipCode().toString());
131: }
132: 
133: private void validateNotEmpty(String value, String fieldName) {
134:     if (value == null || value.isEmpty()) {
135:         throw new UnprocessableEntityException(fieldName + " cannot be null or empty");
136:     }
137: }
138: 
139: private void validateZipCodeLength(String zipCode) {
140:     if (zipCode == null || zipCode.length() != 5) {
141:         throw new UnprocessableEntityException("Invalid zip code");
142:     }
143: }
144: 
145: 
146: private void validateStorageUnitExistenceById(StorageUnitId storageUnitId) {
147:     if (storageUnitId == null) {
148:         throw new UnprocessableEntityException("Storage unit ID cannot be null");
149:     }
150:     if (!storageUnitRepository.existsById(storageUnitId)) {
151:         throw new NotFoundException("Storage unit with ID " + storageUnitId + " does not exist");
152:     }
153: }
154: 
155: 
156: }
157: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\InventoryLevel.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: 
4: import jakarta.persistence.Embedded;
5: import jakarta.persistence.EmbeddedId;
6: import jakarta.persistence.Entity;
7: import lombok.AccessLevel;
8: import lombok.Getter;
9: import lombok.NoArgsConstructor;
10: import lombok.Setter;
11: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
12: 
13: 
14: // nicht immer setter !!
15: 
16: @Getter
17: @Entity
18: @NoArgsConstructor
19: public class InventoryLevel {
20:     @Setter(AccessLevel.PRIVATE)    // only for JPA
21:     @EmbeddedId
22:     private InventoryLevelId id;
23: 
24:     private Integer quantity;
25: 
26:     @Embedded
27:     private ItemId itemId;
28: 
29:     public InventoryLevel(ItemId itemId, Integer quantity) {
30:         this.itemId = itemId;
31:         this.quantity = quantity;
32:         this.id = new InventoryLevelId();
33:     }
34: 
35:     public void setQuantity(Integer quantity) {
36:         if (quantity < 0) {
37:             throw new IllegalArgumentException("Quantity cannot be negative");
38:         }
39:         this.quantity = quantity;
40:     }
41: 
42: }
43: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\InventoryLevelId.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "inventoryLevel_id"))
15: public class InventoryLevelId extends GenericId {
16:     public InventoryLevelId(UUID id ) {
17:         super( id );
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\InventoryLevelIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class InventoryLevelIdConverter extends GenericIdConverter<InventoryLevelId> {
8:     public InventoryLevelIdConverter() {
9:         super(InventoryLevelId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\InventoryLevelRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
6: 
7: @Repository
8: public interface InventoryLevelRepository extends CrudRepository<InventoryLevel, InventoryLevelId> {
9:     Boolean existsByItemId(ItemId itemId);
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnit.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.*;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Address;
7: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.NotFoundException;
8: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
9: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
10: 
11: import java.util.ArrayList;
12: import java.util.List;
13: import java.util.Map;
14: import java.util.Set;
15: 
16: @Getter
17: @Entity
18: @NoArgsConstructor
19: @ToString
20: public class StorageUnit {
21:     @Setter(AccessLevel.PRIVATE)    // only for JPA
22:     @EmbeddedId
23:     private StorageUnitId id;
24:     private String name;
25: 
26:     @Embedded
27:     private Address address;
28: 
29:     @Setter
30:     @OneToMany(cascade= CascadeType.ALL, fetch= FetchType.EAGER, orphanRemoval = true)
31:     private List<InventoryLevel> inventoryLevels;
32: 
33:     public StorageUnit(String name, Address address) {
34:         this.id = new StorageUnitId();
35:         this.name = name;
36:         this.address = address;
37:         this.inventoryLevels = new ArrayList<>();
38:     }
39: 
40:     public void addInventoryLevel(InventoryLevel inventoryLevelToAdd) {
41:         for (InventoryLevel existingLevel : this.inventoryLevels) {
42:             if (existingLevel.getItemId().equals(inventoryLevelToAdd.getItemId())) {
43:                 int newQuantity = existingLevel.getQuantity() + inventoryLevelToAdd.getQuantity();
44:                 existingLevel.setQuantity(newQuantity);
45:                 return;
46:             }
47:         }
48:         this.inventoryLevels.add(inventoryLevelToAdd);
49:     }
50: 
51: 
52:     public void removeInventoryLevel(InventoryLevel inventoryLevelToRemove) {
53:         for (InventoryLevel existingLevel : this.inventoryLevels) {
54:             if (existingLevel.getItemId().equals(inventoryLevelToRemove.getItemId())) {
55:                 int newQuantity = existingLevel.getQuantity() - inventoryLevelToRemove.getQuantity();
56:                 if (newQuantity > 0) {
57:                     existingLevel.setQuantity(newQuantity);
58:                 } else if (newQuantity == 0) {
59:                     this.inventoryLevels.remove(existingLevel);
60:                 } else {
61:                     throw new UnprocessableEntityException("quantity cannot be negative");
62:                 }
63:                 return;
64:             }
65:         }
66:         if(inventoryLevelToRemove.getQuantity() != 0) throw new NotFoundException("Item not found in inventory");
67:     }
68: 
69:     public void changeInventoryLevel(InventoryLevel updatedInventoryLevel) {
70:         for (InventoryLevel inventoryLevel : this.inventoryLevels) {
71:             if (inventoryLevel.getItemId().equals(updatedInventoryLevel.getItemId())) {
72:                 inventoryLevel.setQuantity(updatedInventoryLevel.getQuantity());
73:                 return;
74:             }
75:         }
76:         this.inventoryLevels.add(updatedInventoryLevel);
77:     }
78: 
79:     public Set<ItemId> fulfillableShoppingCartPositions(Map<ItemId, Integer> itemQuantityMap ){
80:         Set<ItemId> fulfillableItems = new java.util.HashSet<>(Set.of());
81: 
82:         for (InventoryLevel inventoryLevel : this.inventoryLevels) {
83:             ItemId itemId = inventoryLevel.getItemId();
84:             if (itemQuantityMap.containsKey(itemId)) {
85:                 if(inventoryLevel.getQuantity() >= itemQuantityMap.get(itemId)) {
86:                     fulfillableItems.add(itemId);
87:                 }
88:             }
89:         }
90:         return fulfillableItems;
91:     }
92: }
93: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitComparator.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
4: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
5: 
6: import java.util.Comparator;
7: import java.util.Map;
8: 
9: public class StorageUnitComparator implements Comparator<StorageUnit>{
10: 
11:     private final Map<ItemId, Integer> itemQuantityMap;
12:     private final ZipCode otherZipCode;
13: 
14:     public StorageUnitComparator(Map<ItemId, Integer> itemQuantityMap, ZipCode otherZipCode) {
15:         this.itemQuantityMap = itemQuantityMap;
16:         this.otherZipCode = otherZipCode;
17:     }
18: 
19:     @Override
20:     public int compare(StorageUnit o1, StorageUnit o2) {
21:         int diff = o1.fulfillableShoppingCartPositions(itemQuantityMap).size() - o2.fulfillableShoppingCartPositions(itemQuantityMap).size();
22:         int fst = Integer.compare(diff, 0);
23:         if( fst != 0){
24:             return fst;
25:         } else {
26:             int zipfst = otherZipCode.difference((ZipCode) o1.getAddress().getZipCode());
27:             int zipsec = otherZipCode.difference((ZipCode) o2.getAddress().getZipCode());
28:             return Integer.compare(zipsec, zipfst);
29:         }
30:     }
31: }
32: 
33: 
34: 
35: 
36: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitId.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "storageUnit_id"))
15: public class StorageUnitId extends GenericId {
16:     public StorageUnitId(UUID id ) {
17:         super( id );
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class StorageUnitIdConverter extends GenericIdConverter<StorageUnitId> {
8:     public StorageUnitIdConverter() {
9:         super(StorageUnitId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: 
6: @Repository
7: public interface StorageUnitRepository extends CrudRepository<StorageUnit, StorageUnitId> {
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.Address;
6: import thkoeln.archilab.ecommerce.domainprimitives.Email;
7: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
8: import thkoeln.archilab.ecommerce.usecases.UserType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
11: 
12: 
13: @Service
14: public class UserAdapterService implements UserRegistrationUseCases {
15: 
16:     private final UserService userService;
17: 
18:     @Autowired
19:     public UserAdapterService(UserService userService) {
20:         this.userService = userService;
21:     }
22: 
23:     @Override
24:     public void register(String name, EmailType email, AddressType address) {
25:         userService.register(name, (Email) email, (Address) address);
26:     }
27: 
28:     @Override
29:     public void changeAddress(EmailType userEmail, AddressType address) {
30:         userService.changeAddress((Email) userEmail, (Address) address);
31:     }
32: 
33:     @Override
34:     public UserType getUserData(EmailType userEmail) {
35:         return userService.getUserData((Email) userEmail);
36:     }
37: 
38:     @Override
39:     public void deleteAllUsers() {
40:         userService.deleteAllUsers();
41:     }
42: }
43: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserController.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import org.modelmapper.ModelMapper;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.http.HttpStatus;
6: import org.springframework.http.ResponseEntity;
7: import org.springframework.web.bind.annotation.GetMapping;
8: import org.springframework.web.bind.annotation.RequestParam;
9: import org.springframework.web.bind.annotation.RestController;
10: import thkoeln.archilab.ecommerce.domainprimitives.Email;
11: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.MethodNotAllowedException;
12: import thkoeln.archilab.ecommerce.solution.user.domain.User;
13: 
14: @RestController
15: public class UserController {
16: 
17:     private final UserService userService;
18: 
19:     @Autowired
20:     public UserController(UserService userService){
21:         this.userService = userService;
22:     };
23: 
24:     /**
25:      *
26:      * Decide how to deal with error handling and HTTP status codes.
27:      * The two options are explained in this infopage.
28:      * If you choose lean controller methods and annotions of exceptions,
29:      * you need to created dedicated exceptions for the main HTTP error codes
30:      * (404 Not Found, 409 Conflict, 422 Unprocessable)
31:      * You can place these new exceptions in the domainprimitive package
32:      * In your code, you need to start replacing the generic ShopException by the dedicated exceptions
33:      */
34: 
35:     @GetMapping("/users")
36:     public ResponseEntity<UserDTO>getUserByEmail(@RequestParam(value = "email", required = false) Email email){
37:         if(email==null) throw new MethodNotAllowedException("method not allowed");
38:         User user = userService.getUserData(email);
39:         ModelMapper modelMapper = new ModelMapper();
40:         return new ResponseEntity<>(modelMapper.map(user, UserDTO.class), HttpStatus.OK);
41:     }
42: 
43: 
44: 
45: }
46: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import lombok.Getter;
4: import lombok.Setter;
5: import thkoeln.archilab.ecommerce.domainprimitives.Address;
6: import thkoeln.archilab.ecommerce.domainprimitives.Email;
7: 
8: import java.util.UUID;
9: 
10: @Getter
11: @Setter
12: public class UserDTO {
13: 
14:     private UUID id;
15:     private String name;
16:     private Email email;
17:     private Address address;
18: 
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserService.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Address;
7: import thkoeln.archilab.ecommerce.domainprimitives.Email;
8: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
9: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.ConflictException;
10: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.NotFoundException;
11: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
12: import thkoeln.archilab.ecommerce.solution.item.application.OrderDeletionInterface;
13: import thkoeln.archilab.ecommerce.solution.item.application.ShoppingCartDeletionInterface;
14: import thkoeln.archilab.ecommerce.solution.user.domain.User;
15: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
16: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
17: 
18: @Service
19: public class UserService {
20: 
21:     private final UserRepository userRepository;
22:     private final OrderDeletionInterface orderDeletionInterface;
23:     private final ShoppingCartDeletionInterface shoppingCartDeletionInterface;
24: 
25:     @Autowired
26:     public UserService(UserRepository userRepository,
27:                        OrderDeletionInterface orderDeletionInterface,
28:                        ShoppingCartDeletionInterface shoppingCartDeletionInterface) {
29:         this.userRepository = userRepository;
30:         this.orderDeletionInterface = orderDeletionInterface;
31:         this.shoppingCartDeletionInterface = shoppingCartDeletionInterface;
32:     }
33:     /**
34:      * Registers a new user
35:      * param name
36:      * param email
37:      * param street
38:      * param city
39:      * param zipCode
40:      * throws ShopException if ...
41:      *                       - user with the given email already exists
42:      *                       - if the data are invalid (name, email, street, city, zipCode empty or null,
43:      *                       zipCode is not a valid zip code)
44:      */
45: 
46:     public void register(String name, Email email, Address address) {
47:         if( address == null ) {
48:             throw new ShopException("Address cannot be null");
49:         }
50:         if(email == null) {
51:             throw new ShopException("Email cannot be null");
52:         }
53:         User.validateNotEmptyOrNull(email.toString(), "email");
54:         User.validateNotEmptyOrNull(name, "name");
55:         User.validateNotEmptyOrNull(address.getStreet(), "street");
56:         User.validateNotEmptyOrNull(address.getCity(), "city");
57:         User.validateNotEmptyOrNull(address.getZipCode().toString(), "zipCode");
58:         if(ZipCode.isZipCodeValid(address.getZipCode().toString()) == false) {
59:             throw new UnprocessableEntityException("Invalid zip code");
60:         }
61:         if(userRepository.existsByEmail(email)) {
62:             throw new ConflictException("User with email already exists");
63:         }
64:         User user = new User(name, email, address);
65:         userRepository.save(user);
66:     }
67: 
68:     /**
69:      * Changes the address of a user
70:      * param userEmail
71:      * param street
72:      * param city
73:      * param zipCode
74:      * throws ShopException if ...
75:      *                       - the user with the given email does not exist,
76:      *                       - the address data are invalid (street, city, zipCode empty, null or not a valid zip code)
77:      */
78: 
79:     public void changeAddress(Email userEmail, Address address) {
80:         if(address == null) {
81:             throw new ShopException("Address is null");
82:         }
83:         User.validateNotEmptyOrNull(address.getStreet(), "street");
84:         User.validateNotEmptyOrNull(address.getCity(), "city");
85:         User.validateNotEmptyOrNull(address.getZipCode().toString(), "zipCode");
86:         if(ZipCode.isZipCodeValid(address.getZipCode().toString()) == false) {
87:             throw new UnprocessableEntityException("Invalid zip code");
88:         }
89: 
90:         User user = userRepository.findByEmail(userEmail);
91:         if(user == null) {
92:             throw new NotFoundException("User with email does not exist");
93:         }
94:         user.setAddress(address);
95:         userRepository.save(user);
96:     }
97: 
98:     /**
99:      * Returns the data of a user as an array of strings (name, email, street, city, zipCode)
100:      * param userEmail
101:      * return the user data
102:      * throws ShopException if the user with the given email does not exist
103:      */
104: 
105:     public User getUserData(Email userEmail) {
106:         User user = userRepository.findByEmail(userEmail);
107:         if(user == null) {
108:             throw new NotFoundException("User with email does not exist");
109:         }
110:         return user;
111:     }
112: 
113:     /**
114:      * Clears all users, including all orders and shopping carts
115:      */
116:     public void deleteAllUsers() {
117:         shoppingCartDeletionInterface.deleteAll();
118:         orderDeletionInterface.deleteAll();
119:         userRepository.deleteAll();
120:     }
121: 
122: 
123: 
124:     public UserId getUserIdOrNullByEmail(Email email) {
125:         if(userRepository.existsByEmail(email)) {
126:             return userRepository.findByEmail(email).getId();
127:         } else {
128:             return null;
129:         }
130:     }
131: 
132: 
133: 
134: 
135:     public ZipCode getUserZipCodeOrNull(UserId userId) {
136:         if(userRepository.existsById(userId)){
137:             return (ZipCode) userRepository.findById(userId).get().getAddress().getZipCode();
138:         }
139:         return null;
140:     }
141: 
142: 
143:     public Boolean userExists(UserId userId) {
144:         return userRepository.existsById(userId);
145:     }
146: 
147: 
148:     public String getUserName(UserId userId){
149:         if(!userExists(userId)) throw new NotFoundException("User is does not exist");
150:         return userRepository.findById(userId).get().getName();
151:     }
152: 
153: }
154: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\User.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: 
4: import jakarta.persistence.Embedded;
5: import jakarta.persistence.EmbeddedId;
6: import jakarta.persistence.Entity;
7: import jakarta.persistence.Table;
8: import lombok.*;
9: import thkoeln.archilab.ecommerce.ShopException;
10: import thkoeln.archilab.ecommerce.domainprimitives.Address;
11: import thkoeln.archilab.ecommerce.domainprimitives.Email;
12: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
13: import thkoeln.archilab.ecommerce.usecases.UserType;
14: 
15: 
16: @Entity
17: @ToString
18: @Getter
19: @Setter
20: @NoArgsConstructor
21: @Table(name = "app_user")
22: public class User implements UserType {
23:     @Setter(AccessLevel.PRIVATE)    // only for JPA
24:     @EmbeddedId
25:     private UserId id;
26: 
27:     @Embedded
28:     private Email email;
29: 
30:     private String name;
31: 
32:     @Embedded
33:     private Address address;
34: 
35:     public User(String name, Email email, Address address) {
36:         this.id = new UserId();
37:         this.name = name;
38:         this.email = email;
39:         this.address = address;
40:     }
41: 
42:     public static void validateNotEmptyOrNull(String value, String fieldName) {
43:         if (value == null || value.trim().isEmpty()) {
44:             throw new UnprocessableEntityException(fieldName + " darf nicht leer oder null sein.");
45:         }
46:     }
47: }
48: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserId.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "user_id"))
15: public class UserId extends GenericId {
16:     public UserId(UUID id ) {
17:         super( id );
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class UserIdConverter extends GenericIdConverter<UserId> {
8:     public UserIdConverter() {
9:         super(UserId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.domainprimitives.Email;
6: 
7: 
8: @Repository
9: public interface UserRepository extends CrudRepository<User, UserId> {
10:     Boolean existsByEmail(Email email);
11:     User findByEmail(Email email);
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\AddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface AddressType {
6:     /**
7:      * @return the street as a string
8:      */
9:     public String getStreet();
10: 
11:     /**
12:      * @return the city as a string
13:      */
14:     public String getCity();
15: 
16:     /**
17:      * @return the zip code
18:      */
19:     public ZipCodeType getZipCode();
20: 
21:     /**
22:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
23:      * implementing class to provide a static factory method (simply named "of(...)"),
24:      * which creates an zip code, given as a string.
25:      * We specify this factory method here as a comment, using the Javadoc documentation style.
26:      *
27:      * @param street the street as a string
28:      * @param city the city as a string
29:      * @param zipCode the zip code
30:      * @return the address object matching the parameters
31:      * @throws ShopException if ...
32:      *      - street is null or empty
33:      *      - city is null or empty
34:      *      - zipCode is null
35:      */
36:      // public static AddressType of( String street, String city, ZipCodeType zipCode );
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\CurrencyType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface CurrencyType {
6:     /**
7:      * @return the quantity of currency
8:      */
9:     public Float getQuantity();
10: 
11: 
12:     /**
13:      * @return the currency unit of the currency
14:      */
15:     public String getCurrencyUnit();
16: 
17: 
18:     /**
19:      * @param otherCurrency
20:      * @return this + otherCurrency, as a new object
21:      * @throws ShopException if ...
22:      *      - otherCurrency is null
23:      *      - otherCurrency.currencyUnit != this.currencyUnit
24:      */
25:     public CurrencyType add( CurrencyType otherCurrency );
26: 
27: 
28:     /**
29:      * @param otherCurrency
30:      * @return this - otherCurrency, as a new object
31:      * @throws ShopException if ...
32:      *      - otherCurrency is null
33:      *      - otherCurrency.currencyUnit != this.currencyUnit
34:      *      - otherCurrency > this
35:      */
36:     public CurrencyType subtract( CurrencyType otherCurrency );
37: 
38: 
39:     /**
40:      * @param factor
41:      * @return this * factor, as a new object
42:      * @throws ShopException if ...
43:      *     - factor < 0
44:      */
45:     public CurrencyType multiplyBy( int factor );
46: 
47:     /**
48:      * @param otherCurrency
49:      * @return true, if this > otherCurrency
50:      * @throws ShopException if ...
51:      *      - otherCurrency is null
52:      *      - otherCurrency.currencyUnit != this.currencyUnit
53:      */
54:     public boolean largerThan( CurrencyType otherCurrency );
55: 
56: 
57:     /**
58:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
59:      * implementing class to provide a static factory method (simply named "of(...)"),
60:      * which creates a currency object from an quantity and a currency unit (as string).
61:      * We specify this factory method here as a comment, using the Javadoc documentation style.
62:      *
63:      * @param quantity the quantity of currency (must be >= 0)
64:      * @param currencyUnit the currency unit of the currency (allowed values: "EUR", "CHF")
65:      * @return a new Currency object with the given quantity and currency unit
66:      * @throws ShopException if ...
67:      *   - quantity is null
68:      *   - quantity < 0
69:      *   - currency unit is null
70:      *   - currency unit is not one of the allowed values
71:      */
72:      // public static CurrencyType of( Float quantity, String currencyUnit );
73: }
74: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\EmailType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface EmailType {
6:     /**
7:      * @return the email as a string
8:      */
9:     public String toString();
10: 
11: 
12:     /**
13:      * A special kind of "copy constructor": Returns a new email object with
14:      * the same identifyer (the substring left of the "@" sign) as the current one, but
15:      * with a new domain substring (right of the "@" sign).
16:      * @param domainString - the new domain for the copied email
17:      * @return the new email
18:      * @throws ShopException if ...
19:      *     - domainString is null
20:      *     - the new email would not be valid (see `of(...)` method)
21:      */
22:     public EmailType sameIdentifyerDifferentDomain( String domainString );
23: 
24:     /**
25:      * Another special kind of "copy constructor": Returns a new email object
26:      * with the same domain (the substring right of the "@" sign) as the current one, but
27:      * with a new identifyer substring (left of the "@" sign).
28:      * @param identifyerString - the new identifyer for the copied email
29:      * @return the new email
30:      * @throws ShopException if ...
31:      *     - identifyerString is null
32:      *     - the new email would not be valid (see `of(...)` method)
33:      */
34:     public EmailType sameDomainDifferentIdentifyer( String identifyerString );
35: 
36: 
37:     /**
38:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
39:      * implementing class to provide a static factory method (simply named "of(...)"),
40:      * which creates an email, given as a string.
41:      * We specify this factory method here as a comment, using the Javadoc documentation style.
42:      *
43:      * @param emailAsString - the email as a string.
44:      *      We will use a much simplified validation method to check if the email is valid:
45:      *      - it must contain exactly one '@' character.
46:      *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
47:      *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
48:      *      - the substrings before and after the '@' may contain one or several '.' as separators
49:      *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
50:      *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
51:      *        (for simplicity we do not allow any other domains)
52:      * @return a new EmailType object matching the given email
53:      * @throws ShopException if ...
54:      *      - emailAsString is null
55:      *      - emailAsString is not a valid email (see above)
56:      */
57:      // public static EmailType of( String emailAsString );
58: }
59: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\ZipCodeType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnore;
4: import thkoeln.archilab.ecommerce.ShopException;
5: 
6: public interface ZipCodeType {
7:     /**
8:      * @return the zip code as a string
9:      */
10:     public String toString();
11: 
12:     /**
13:      * You will need some idea of "imprecise difference" between two zip codes for properly
14:      * implementing storage units in your shopping platform. This method calculates such a
15:      * difference. You can decide for yourself what values you return, unless you comply
16:      * with the following rules.
17:      * - The return value is 0 if both zip codes are the same
18:      * - If not:
19:      *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
20:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
21:      *        So, 56733 and 56734 have the same difference as 56733 and 56739.
22:      *      - The difference grows if more digits (counted from the right side) differ.
23:      *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
24:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
25:      *        53876 and 54876 have the same difference as 53876 and 57261.
26:      *      - However, the difference between 5abcd and 6rstu must be smaller than the one
27:      *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
28:      *        one between 5abcd and 9rstu.
29:      *      - This last condition reflects the fact the first digits of a zip code marks a region
30:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
31:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
32:      *        other.
33:      * @param otherZipCode
34:      * @return the calculated difference
35:      * @throws ShopException if otherZipCode is null
36:      */
37:     public int difference( ZipCodeType otherZipCode );
38: 
39: 
40:     /**
41:      * For the currently used way of deciding on the best fitting storage unit for a order,
42:      * we need to know the first digit of the zip code.
43:      */
44:     @JsonIgnore
45:     public Integer getFirstDigitZipCode();
46: 
47: 
48:     /**
49:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
50:      * implementing class to provide a static factory method (simply named "of(...)"),
51:      * which creates an zip code, given as a string.
52:      * We specify this factory method here as a comment, using the Javadoc documentation style.
53:      *
54:      * @param zipCodeAsString - the zip code as a string.
55:      *      We will use a much simplified validation method to check if the zip code is valid:
56:      *      - It must contain exactly 5 digits.
57:      *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid zip code, but 20001 is valid)
58:      * @return a new zip code object matching the given string
59:      * @throws ShopException if ...
60:      *      - zipCodeAsString is null
61:      *      - zipCodeAsString is not a valid zip code (see above)
62:      */
63:      // public static ZipCodeType of( String zipCodeAsString );
64: }
65: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\ItemCatalogUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
9: 
10: import java.util.UUID;
11: 
12: 
13: /**
14:  * This interface contains methods needed in the context of use cases concerning the item catalog.
15:  * The interface is probably incomplete, and will grow over time ...
16:  */
17: 
18: public interface ItemCatalogUseCases {
19:     /**
20:      * Adds a new item to the shop catalog
21:      * @param name
22:      * @param descriptOf
23:      * @param size
24:      * @param buyingPrice
25:      * @param sellingPrice
26:      * @return the id of the new item
27:      * @throws ShopException if ...
28:      *      - the item id already exists,
29:      *      - name or description are null or empty,
30:      *      - the size is <= 0 (but can be null!),
31:      *      - the buying price is null or <= 0,
32:      *      - the buyingPrice is null,
33:      *      - the selling price is null,
34:      *      - the selling price is lower than the buyingPrice
35:      */
36:     public UUID addItemToCatalog( String name, String descriptOf, Float size,
37:                                            CurrencyType buyingPrice, CurrencyType sellingPrice );
38: 
39: 
40:     /**
41:      * Removes a item from the shop catalog
42:      * @param itemId
43:      * @throws ShopException if
44:      *      - itemId is null
45:      *      - the item id does not exist
46:      *      - the item is still in inventory
47:      *      - the item is still in a shopping cart, or referenced by a completed order
48:      */
49:     public void removeItemFromCatalog( UUID itemId );
50: 
51: 
52:     /**
53:      * Get the selling price of a given item
54:      * @param itemId
55:      * @return the selling price
56:      * @throws ShopException if ...
57:      *      - itemId is null,
58:      *      - the item with that id does not exist
59:      */
60:     public CurrencyType getSellingPrice( UUID itemId );
61: 
62: 
63:     /**
64:      * Clears the item catalog, i.e. removes all items from the catalog, including all the inventory,
65:      * all the reservations and all the orders.
66:      */
67:     public void deleteItemCatalog();
68: 
69: }
70: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
8: 
9: import java.io.File;
10: import java.io.IOException;
11: import java.lang.reflect.InvocationTargetException;
12: import java.lang.reflect.Method;
13: import java.lang.reflect.Modifier;
14: import java.net.URL;
15: import java.net.URLDecoder;
16: import java.nio.charset.StandardCharsets;
17: import java.util.Enumeration;
18: 
19: import static org.junit.jupiter.api.Assertions.*;
20: 
21: public class FactoryMethodInvoker {
22: 
23:     public static EmailType instantiateEmail( String emailAsString ) {
24:         Method factoryMethod = null;
25:         try {
26:             Class<?> interfaceClass = Class.forName(
27:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType" );
28:             Class<?> implementingClass = findImplementation( interfaceClass );
29: 
30:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
31:             assertNotNull( factoryMethod );
32:             int modifiers = factoryMethod.getModifiers();
33:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
34:         } catch (Exception e) {
35:             fail( "Failed to find implementation for EmailType", e );
36:         }
37: 
38:         Object instance = null;
39:         try {
40:             instance = factoryMethod.invoke( null, emailAsString );
41:         } catch (Exception e) {
42:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
43:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
44:             fail( "Failed to invoke factory method 'of' for '" + emailAsString + "'", e );
45:         }
46:         assertNotNull( instance );
47:         return (EmailType) instance;
48:     }
49: 
50: 
51:     public static AddressType instantiateAddress(
52:             String street, String city, ZipCodeType zipCode ) {
53:         Method factoryMethod = null;
54:         try {
55:             Class<?> interfaceClass = Class.forName(
56:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType" );
57:             Class<?> implementingClass = findImplementation( interfaceClass );
58: 
59:             factoryMethod = implementingClass.getDeclaredMethod( "of",
60:                     String.class, String.class, ZipCodeType.class );
61:             assertNotNull( factoryMethod );
62:             int modifiers = factoryMethod.getModifiers();
63:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
64:         } catch (Exception e) {
65:             fail( "Failed to find implementation for AddressType", e );
66:         }
67: 
68:         Object instance = null;
69:         try {
70:             instance = factoryMethod.invoke( null, street, city, zipCode );
71:         } catch (Exception e) {
72:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
73:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
74:             fail( "Failed to invoke factory method 'of' for '" +
75:                     street + "', '" + city + "', '" + zipCode + "'", e );
76:         }
77:         assertNotNull( instance );
78:         return (AddressType) instance;
79:     }
80: 
81: 
82:     public static ZipCodeType instantiateZipCode( String zipCodeAsString ) {
83:         Method factoryMethod = null;
84:         try {
85:             Class<?> interfaceClass = Class.forName(
86:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType" );
87:             Class<?> implementingClass = findImplementation( interfaceClass );
88: 
89:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
90:             assertNotNull( factoryMethod );
91:             int modifiers = factoryMethod.getModifiers();
92:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
93:         } catch (Exception e) {
94:             fail( "Failed to find implementation for ZipCodeType", e );
95:         }
96: 
97:         Object instance = null;
98:         try {
99:             instance = factoryMethod.invoke( null, zipCodeAsString );
100:         } catch (Exception e) {
101:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
102:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
103:             fail( "Failed to invoke factory method 'of' for '" + zipCodeAsString + "'", e );
104:         }
105:         assertNotNull( instance );
106:         return (ZipCodeType) instance;
107:     }
108: 
109: 
110:     public static CurrencyType instantiateCurrency( Float quantity, String currencyUnit ) {
111:         Method factoryMethod = null;
112:         try {
113:             Class<?> interfaceClass = Class.forName(
114:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType" );
115:             Class<?> implementingClass = findImplementation( interfaceClass );
116: 
117:             factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
118:             assertNotNull( factoryMethod );
119:             int modifiers = factoryMethod.getModifiers();
120:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
121:         } catch (Exception e) {
122:             fail( "Failed to find implementation for CurrencyType", e );
123:         }
124: 
125:         Object instance = null;
126:         try {
127:             instance = factoryMethod.invoke( null, quantity, currencyUnit );
128:         } catch (Exception e) {
129:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
130:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
131:             fail( "Failed to invoke factory method 'of' for '" + quantity + "', '" + currencyUnit + "'", e );
132:         }
133:         assertNotNull( instance );
134:         return (CurrencyType) instance;
135:     }
136: 
137: 
138:     private static Class<?> findImplementation( Class<?> interfaceClass ) {
139:         Method factoryMethod = null;
140:         try {
141:             String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
142:             Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
143:             assertNotNull( implementingClass );
144:             return implementingClass;
145:         } catch (Exception e) {
146:             fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
147:             return null; // This line will never be reached, but it's necessary to satisfy the compiler
148:         }
149:     }
150: 
151: 
152:     private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
153:             throws ClassNotFoundException, IOException {
154:         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
155:         String path = packageName.replace( '.', '/' );
156:         Enumeration<URL> resources = classLoader.getResources( path );
157:         int count = 0;
158:         Class<?> result = null;
159:         while (resources.hasMoreElements()) {
160:             URL resource = resources.nextElement();
161:             File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
162:             File[] files = directory.listFiles();
163:             for ( File file : files ) {
164:                 if ( file.getName().endsWith( ".class" ) ) {
165:                     String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
166:                     Class<?> clazz = Class.forName( className );
167:                     if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
168:                         count++;
169:                         result = clazz;
170:                     }
171:                 }
172:             }
173:         }
174:         assertEquals( 1, count, "There should be exactly one implementing class" );
175:         return result;
176:     }
177: }
178: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\InventoryTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
7: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
8: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
12: 
13: import java.util.*;
14: 
15: /**
16:  * This is a test helper class that initializes and registers items (but without inventory)
17:  * in the system, using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class InventoryTestHelperImpl
22:                         implements ItemTestHelper, StorageUnitTestHelper {
23:     private ItemCatalogUseCases itemCatalogUseCases;
24:     private StorageUnitUseCases storageUnitUseCases;
25:     private static Random random = new Random();
26: 
27:     private static final String EUR = "EUR";
28:     private static final int ITEM_NUMOF = 15;
29:     private static final Object[][] ITEM_DATA = new Object[][]{
30:             {null, "0-TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
31:                     1.5f, FactoryMethodInvoker.instantiateCurrency( 5.0f, EUR ),
32:                     FactoryMethodInvoker.instantiateCurrency( 10.0f, EUR ),
33:                     "0"},
34:             {null, "1-EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
35:                     0.3f, FactoryMethodInvoker.instantiateCurrency( 2.5f, EUR ),
36:                     FactoryMethodInvoker.instantiateCurrency( 4.0f, EUR ),
37:                     "0"},
38:             {null, "2-MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
39:                     7.2f, FactoryMethodInvoker.instantiateCurrency( 50.0f, EUR ),
40:                     FactoryMethodInvoker.instantiateCurrency( 80.0f, EUR ),
41:                     "0"},
42:             {null, "3-Gh-25", "Kompakter und leichter Akku für mobile Geräte",
43:                     null, FactoryMethodInvoker.instantiateCurrency( 6.0f, EUR ),
44:                     FactoryMethodInvoker.instantiateCurrency( 8.0f, EUR ),
45:                     "0"},
46:             {null, "4-MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
47:                     null, FactoryMethodInvoker.instantiateCurrency( 0.6f, EUR ),
48:                     FactoryMethodInvoker.instantiateCurrency( 1.0f, EUR ),
49:                     "0"},
50:             {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
51:                     1.0f, FactoryMethodInvoker.instantiateCurrency( 150.0f, EUR ),
52:                     FactoryMethodInvoker.instantiateCurrency( 250.0f, EUR ),
53:                     "0"},
54:             {null, "6-Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
55:                     null, FactoryMethodInvoker.instantiateCurrency( 0.3f, EUR ),
56:                     FactoryMethodInvoker.instantiateCurrency( 0.5f, EUR ),
57:                     "0"},
58:             {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
59:                     6.0f, FactoryMethodInvoker.instantiateCurrency( 80.0f, EUR ),
60:                     FactoryMethodInvoker.instantiateCurrency( 120.0f, EUR ),
61:                     "123"},
62:             {null, "8-JKL-67", "Wasserdichtes Gehäuse",
63:                     3.0f, FactoryMethodInvoker.instantiateCurrency( 1.0f, EUR ),
64:                     FactoryMethodInvoker.instantiateCurrency( 1.2f, EUR ),
65:                     "467"},
66:             {null, "9-MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
67:                     5.5f, FactoryMethodInvoker.instantiateCurrency( 25.0f, EUR ),
68:                     FactoryMethodInvoker.instantiateCurrency( 45.0f, EUR ),
69:                     "578"},
70:             {null, "10-PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
71:                     4.0f, FactoryMethodInvoker.instantiateCurrency( 20.0f, EUR ),
72:                     FactoryMethodInvoker.instantiateCurrency( 35.0f, EUR ),
73:                     "567"},
74:             {null, "11-STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
75:                     null, FactoryMethodInvoker.instantiateCurrency( 200.0f, EUR ),
76:                     FactoryMethodInvoker.instantiateCurrency( 350.0f, EUR ),
77:                     "478"},
78:             {null, "12-VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
79:                     null, FactoryMethodInvoker.instantiateCurrency( 15.0f, EUR ),
80:                     FactoryMethodInvoker.instantiateCurrency( 25.0f, EUR ),
81:                     "5"},
82:             {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
83:                     3.5f, FactoryMethodInvoker.instantiateCurrency( 60.0f, EUR ),
84:                     FactoryMethodInvoker.instantiateCurrency( 100.0f, EUR ),
85:                     "78"},
86:             {null, "14-Nosedive", "Klammer zum Verschließen der Nase beim Tauchen",
87:                     5.0f, FactoryMethodInvoker.instantiateCurrency( 2.0f, EUR ),
88:                     FactoryMethodInvoker.instantiateCurrency( 5.0f, EUR ),
89:                     "457"}
90:     };
91:     
92: 
93:     // These addresss are used for the storage units. The storage unit name will equal
94:     // the zip code of the site. Their index number will be visible in the house number.
95:     // The storage units are used as such:
96:     // - storage unit 0 is holds all items 0 - 6, and is used for all tests where multiple
97:     //   shipments are irrelevant.
98:     // - storage units 1 - 3 are used for the proximity tests, where you can deliver items 7 to
99:     //   to a user from the closest storage unit.
100:     // - storage units 4 - 8 are used for the tests where you need to deliver items 8 - 14 in
101:     //   the most cost-efficient way, as multiple shipments.
102:     // - storage unit 9 is empty.
103:     private final static int STORAGE_UNIT_NUMOF = 10;
104:     private final static AddressType[] STORAGE_UNIT_ADDRESS = new AddressType[]{
105:             FactoryMethodInvoker.instantiateAddress(
106:                     "Stapelallee 0", "Potsdam",
107:                     FactoryMethodInvoker.instantiateZipCode( "14476" ) ),
108:             FactoryMethodInvoker.instantiateAddress(
109:                     "Lagerhausstr. 1", "Viertelstadt",
110:                     FactoryMethodInvoker.instantiateZipCode( "02345" ) ),
111:             FactoryMethodInvoker.instantiateAddress(
112:                     "Speicherplatz 2", "Viertelstadt",
113:                     FactoryMethodInvoker.instantiateZipCode( "02313" ) ),
114:             FactoryMethodInvoker.instantiateAddress(
115:                     "Ablageweg 3", "Reichswürgen",
116:                     FactoryMethodInvoker.instantiateZipCode( "44923" ) ),
117:             FactoryMethodInvoker.instantiateAddress(
118:                     "Paketstellenallee 4", "Düsseldorf",
119:                     FactoryMethodInvoker.instantiateZipCode( "40588" ) ),
120:             FactoryMethodInvoker.instantiateAddress(
121:                     "Kaputte-Sachen-Straße 5", "Düren",
122:                     FactoryMethodInvoker.instantiateZipCode( "52355" ) ),
123:             FactoryMethodInvoker.instantiateAddress(
124:                     "Aufbewahrungsweg 6", "Viernheim",
125:                     FactoryMethodInvoker.instantiateZipCode( "68519" ) ),
126:             FactoryMethodInvoker.instantiateAddress(
127:                     "Paketallee 7", "Baden-Baden",
128:                     FactoryMethodInvoker.instantiateZipCode( "76532" ) ),
129:             FactoryMethodInvoker.instantiateAddress(
130:                     "Sendenstr. 8", "Senden",
131:                     FactoryMethodInvoker.instantiateZipCode( "89250" ) ),
132:             FactoryMethodInvoker.instantiateAddress(
133:                     "Schickweg 9", "Hohenroth",
134:                     FactoryMethodInvoker.instantiateZipCode( "97618" ) )
135:     };
136:     private final static UUID[] STORAGE_UNIT_ID = new UUID[STORAGE_UNIT_NUMOF];
137: 
138: 
139:     // These data structures contain the inventory of the items in the storage units.
140:     // ITEM_INVENTORY is a map item name -> Integer[STORAGE_UNIT_NUMOF].
141:     // The Integer[STORAGE_UNIT_NUMOF] contains the inventory of the item in each of
142:     // the storage units.
143:     //
144:     // The following rules apply:
145:     // - item 0 is out of inventory
146:     // - item 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in storage unit 0
147:     // - item 4 / 5 / 6 have a random inventory between 30 and 130, also all ONLY in storage unit 0
148:     //   (these are the items used for tests on how to add and remove inventory)
149:     // - the others have a random inventory between 30 and 130, distributed over several
150:     //   storage units. Here we follow this convention for simplicity:
151:     //   - Assume that the item is available in <n> storage units. Then the first <n-1> storage units
152:     //     in the list (in ascending sequence) contain 3, and all the remaining inventory is in the
153:     //     last storage unit.
154: 
155:     private static final Map<String, Integer[]> ITEM_INVENTORY = new HashMap<>();
156: 
157:     static {
158:         // items 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
159:         ITEM_INVENTORY.put( (String) ITEM_DATA[0][1],
160:                 getInventoryDistribution( 0, (String) ITEM_DATA[0][6] ) );
161:         ITEM_INVENTORY.put( (String) ITEM_DATA[1][1],
162:                 getInventoryDistribution( 10, (String) ITEM_DATA[1][6] ) );
163:         ITEM_INVENTORY.put( (String) ITEM_DATA[2][1],
164:                 getInventoryDistribution( 20, (String) ITEM_DATA[2][6] ) );
165:         ITEM_INVENTORY.put( (String) ITEM_DATA[3][1],
166:                 getInventoryDistribution( 30, (String) ITEM_DATA[3][6] ) );
167: 
168:         // The other items have a random inventory between 30 and 130,
169:         for ( int i = 4; i < ITEM_NUMOF; i++ ) {
170:             Integer totalNumber = random.nextInt( 100 ) + 30;
171:             Integer[] inventoryInStorageUnits =
172:                     getInventoryDistribution( totalNumber, (String) ITEM_DATA[i][6] );
173:             ITEM_INVENTORY.put( (String) ITEM_DATA[i][1], inventoryInStorageUnits );
174:         }
175:     }
176: 
177:     /**
178:      * This method creates a random inventory distribution for the given item.
179:      *
180:      * @param totalQuantity - the total number of items in the storage units
181:      * @param zeroToNine  - a string with numbers between 0 and 9, representing the storage units
182:      * @return an Integer array with the inventory distribution for the item, according to
183:      * the rules described above.
184:      */
185:     private static Integer[] getInventoryDistribution( Integer totalQuantity, String zeroToNine ) {
186:         Integer[] inventoryInStorageUnits = new Integer[STORAGE_UNIT_NUMOF];
187:         for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) inventoryInStorageUnits[i] = 0;
188:         TreeSet<Integer> storageUnitIndices = getStorageUnitIndices( zeroToNine );
189:         int numOfIndices = storageUnitIndices.size();
190:         int currentIndexNumber = 0;
191:         int currentQuantity = totalQuantity;
192:         for ( Integer storageUnitIndex : storageUnitIndices ) {
193:             currentIndexNumber++;
194:             if ( currentIndexNumber < numOfIndices ) {
195:                 inventoryInStorageUnits[storageUnitIndex] = 3;
196:                 currentQuantity -= 3;
197:             } else {
198:                 inventoryInStorageUnits[storageUnitIndex] = currentQuantity;
199:             }
200:         }
201:         return inventoryInStorageUnits;
202:     }
203: 
204:     private static TreeSet<Integer> getStorageUnitIndices( String zeroToNine ) {
205:         TreeSet<Integer> storageUnitIndices = new TreeSet<>();
206:         for ( int i = 0; i < zeroToNine.length(); i++ ) {
207:             storageUnitIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
208:         }
209:         return storageUnitIndices;
210:     }
211: 
212: 
213:     @Autowired
214:     public InventoryTestHelperImpl( ItemCatalogUseCases itemCatalogUseCases,
215:                                          StorageUnitUseCases storageUnitUseCases ) {
216:         this.itemCatalogUseCases = itemCatalogUseCases;
217:         this.storageUnitUseCases = storageUnitUseCases;
218:     }
219: 
220: 
221:     @Override
222:     public void addAllItems() {
223:         int i = 0;
224:         for ( Object[] itemData : ITEM_DATA ) {
225:             UUID newId = itemCatalogUseCases.addItemToCatalog(
226:                     (String) itemData[1], (String) itemData[2],
227:                     (Float) itemData[3], (CurrencyType) itemData[4],
228:                     (CurrencyType) itemData[5] );
229:             // The first element of the item data is the id, which was initialized with null before, but can now be set
230:             ITEM_DATA[i][0] = newId;
231:             i++;
232:         }
233:     }
234: 
235: 
236:     @Override
237:     public int numberOfItems() {
238:         return ITEM_NUMOF;
239:     }
240: 
241: 
242:     @Override
243:     public UUID getItemId( int index ) {
244:         if ( index < 0 || index >= ITEM_NUMOF ) {
245:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
246:         }
247:         return (UUID) ITEM_DATA[index][0];
248:     }
249: 
250: 
251:     @Override
252:     public CurrencyType getBuyingPrice( int index ) {
253:         if ( index < 0 || index >= ITEM_NUMOF ) {
254:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
255:         }
256:         return (CurrencyType) ITEM_DATA[index][4];
257:     }
258: 
259: 
260:     @Override
261:     public CurrencyType getSellingPrice( int index ) {
262:         if ( index < 0 || index >= ITEM_NUMOF ) {
263:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
264:         }
265:         return (CurrencyType) ITEM_DATA[index][5];
266:     }
267: 
268: 
269:     @Override
270:     public void addAllStorageUnits( boolean withInventory ) {
271:         for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) {
272:             STORAGE_UNIT_ID[i] = storageUnitUseCases.addNewStorageUnit(
273:                     STORAGE_UNIT_ADDRESS[i].getStreet(),
274:                     STORAGE_UNIT_ADDRESS[i] );
275:         }
276:         if ( withInventory ) {
277:             addAllInventory();
278:         }
279:     }
280: 
281: 
282:     private void addAllInventory() {
283:         for ( Object[] itemData : ITEM_DATA ) {
284:             Integer[] inventoryInStorageUnits =
285:                     ITEM_INVENTORY.get( itemData[1] );
286:             for ( int iStorageUnit = 0; iStorageUnit < STORAGE_UNIT_NUMOF; iStorageUnit++ ) {
287:                 if ( inventoryInStorageUnits[iStorageUnit] > 0 )
288:                     storageUnitUseCases.addToInventory(
289:                             STORAGE_UNIT_ID[iStorageUnit], (UUID) itemData[0],
290:                             inventoryInStorageUnits[iStorageUnit] );
291:             }
292:         }
293:     }
294: 
295: 
296:     @Override
297:     public int numberOfStorageUnits() {
298:         return STORAGE_UNIT_NUMOF;
299:     }
300: 
301: 
302:     @Override
303:     public UUID getStorageUnitId( int index ) {
304:         if ( index < 0 || index >= STORAGE_UNIT_NUMOF ) {
305:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
306:         }
307:         return STORAGE_UNIT_ID[index];
308:     }
309: 
310: 
311:     @Override
312:     public Integer getStorageUnitInventory( int storageUnitIndex, int itemIndex ) {
313:         if ( storageUnitIndex < 0 || storageUnitIndex >= STORAGE_UNIT_NUMOF ) {
314:             throw new IndexOutOfBoundsException( "Index out of bounds: " + storageUnitIndex );
315:         }
316:         if ( itemIndex < 0 || itemIndex >= ITEM_NUMOF ) {
317:             throw new IndexOutOfBoundsException( "Index out of bounds: " + itemIndex );
318:         }
319:         String itemName = (String) ITEM_DATA[itemIndex][1];
320:         Integer[] inventoryInStorageUnits = ITEM_INVENTORY.get( itemName );
321:         Integer foundInventory = inventoryInStorageUnits[storageUnitIndex];
322:         return foundInventory == null ? 0 : foundInventory;
323:     }
324: 
325: 
326:     @Override
327:     public int findStorageUnitIndex( UUID storageUnitId ) {
328:         for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) {
329:             if ( STORAGE_UNIT_ID[i].equals( storageUnitId ) ) {
330:                 return i;
331:             }
332:         }
333:         throw new IllegalArgumentException( "No test storage unit with UUID id " + storageUnitId );
334:     }
335: 
336: 
337:     @Override
338:     public int findItemIndex( UUID itemId ) {
339:         for ( int iItemData = 0; iItemData < STORAGE_UNIT_NUMOF; iItemData++ ) {
340:             Object[] itemData = ITEM_DATA[iItemData];
341:             if ( itemData[0].equals( itemId ) ) {
342:                 return iItemData;
343:             }
344:         }
345:         throw new IllegalArgumentException( "No test item with UUID id " + itemId );
346:     }
347: }
348: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\UserTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
7: import thkoeln.archilab.ecommerce.usecases.UserType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.MockUser;
12: 
13: import static org.junit.jupiter.api.Assertions.assertThrows;
14: 
15: /**
16:  * This is a test helper class that initializes and registers users in the system,
17:  * using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class UserTestHelperImpl implements UserTestHelper {
22: 
23:     private UserRegistrationUseCases userRegistrationUseCases;
24: 
25:     @Autowired
26:     public UserTestHelperImpl( UserRegistrationUseCases userRegistrationUseCases ) {
27:         this.userRegistrationUseCases = userRegistrationUseCases;
28:     }
29: 
30:     private final static String[] USER_NAME = new String[]{
31:             "Max Mueller",
32:             "Sophie Schmitz",
33:             "Irene Mihalic",
34:             "Emilia Fischer",
35:             "Filiz Polat",
36:             "Lina Wagner",
37:             "Leon Becker",
38:             "Agnieszka Kalterer",
39:             "Felix Bauer",
40:             "Lara Schulz"
41:     };
42: 
43:     private final static EmailType[] USER_EMAIL = new EmailType[]{
44:             FactoryMethodInvoker.instantiateEmail( "99Z@example.com" ),
45:             FactoryMethodInvoker.instantiateEmail( "a@4.com" ),
46:             FactoryMethodInvoker.instantiateEmail( "irene@wearefreedomnow.com" ),
47:             FactoryMethodInvoker.instantiateEmail( "emilia.fischer@example.com" ),
48:             FactoryMethodInvoker.instantiateEmail( "j877d3@example.this.com" ),
49:             FactoryMethodInvoker.instantiateEmail( "lina.marie.wagner@example.com" ),
50:             FactoryMethodInvoker.instantiateEmail( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
51:             FactoryMethodInvoker.instantiateEmail( "agna@here.ch" ),
52:             FactoryMethodInvoker.instantiateEmail( "felix.bauer@example.org" ),
53:             FactoryMethodInvoker.instantiateEmail( "lara.schulz@example.at" )
54:     };
55: 
56:     // The following array is used to create a list of addresss for the users.
57:     // The indices are coded into the house number.
58:     // - Persons 0 - 5 are used for proximity tests with one storage unit.
59:     private final static AddressType[] USER_ADDRESS = new AddressType[]{
60:             FactoryMethodInvoker.instantiateAddress(
61:                     "Marktstraße 0", "Viertelstadt",
62:                     FactoryMethodInvoker.instantiateZipCode( "02314" ) ),
63:             FactoryMethodInvoker.instantiateAddress(
64:                     "Hauptstraße 1", "Viertelstadt",
65:                     FactoryMethodInvoker.instantiateZipCode( "02368" ) ),
66:             FactoryMethodInvoker.instantiateAddress(
67:                     "Kirchplatz 2", "Niemandstown",
68:                     FactoryMethodInvoker.instantiateZipCode( "12345" ) ),
69:             FactoryMethodInvoker.instantiateAddress(
70:                     "Schulstraße 3", "Geisterhausen",
71:                     FactoryMethodInvoker.instantiateZipCode( "31463" ) ),
72:             FactoryMethodInvoker.instantiateAddress(
73:                     "Rosenweg 4", "Kuhhausen",
74:                     FactoryMethodInvoker.instantiateZipCode( "72162" ) ),
75:             FactoryMethodInvoker.instantiateAddress(
76:                     "Wiesenstraße 5", "Waldschenkensdorf",
77:                     FactoryMethodInvoker.instantiateZipCode( "82195" ) ),
78:             FactoryMethodInvoker.instantiateAddress(
79:                     "Muehlenweg 6", "Koeln",
80:                     FactoryMethodInvoker.instantiateZipCode( "50667" ) ),
81:             FactoryMethodInvoker.instantiateAddress(
82:                     "Goethestraße 7", "Frankfurt am Main",
83:                     FactoryMethodInvoker.instantiateZipCode( "60311" ) ),
84:             FactoryMethodInvoker.instantiateAddress(
85:                     "Dorfstraße 8", "Stuttgart",
86:                     FactoryMethodInvoker.instantiateZipCode( "70173" ) ),
87:             FactoryMethodInvoker.instantiateAddress(
88:                     "Bahnhofstraße 9", "Muenchen",
89:                     FactoryMethodInvoker.instantiateZipCode( "80331" ) )
90:     };
91: 
92:     private final static UserType[] mockUsers;
93: 
94:     static {
95:         mockUsers = new UserType[USER_NAME.length];
96:         for ( int i = 0; i < USER_NAME.length; i++ ) {
97:             mockUsers[i] = new MockUser(
98:                     USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
99:         }
100:     }
101: 
102: 
103:     @Override
104:     public void registerAllUsers() {
105:         for ( int i = 0; i < USER_NAME.length; i++ ) {
106:             registerUser( USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
107:         }
108:     }
109: 
110: 
111:     private void registerUser( String name, EmailType email, AddressType address ) {
112:         userRegistrationUseCases.register( name, email, address );
113:     }
114: 
115: 
116:     @Override
117:     public int getNumberOfUsers() {
118:         return USER_NAME.length;
119:     }
120: 
121: 
122:     @Override
123:     public String getUserName( int index ) {
124:         if ( index < 0 || index >= USER_NAME.length ) {
125:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
126:         }
127:         return USER_NAME[index];
128:     }
129: 
130: 
131:     @Override
132:     public EmailType getUserEmail( int index ) {
133:         if ( index < 0 || index >= USER_NAME.length ) {
134:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
135:         }
136:         return USER_EMAIL[index];
137:     }
138: 
139: 
140:     @Override
141:     public AddressType getUserAddress( int index ) {
142:         if ( index < 0 || index >= USER_NAME.length ) {
143:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
144:         }
145:         return USER_ADDRESS[index];
146:     }
147: 
148: 
149:     @Override
150:     public UserType getUser( int index ) {
151:         if ( index < 0 || index >= USER_NAME.length ) {
152:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
153:         }
154:         return mockUsers[index];
155:     }
156: }
157: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ItemTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
4: 
5: import java.util.UUID;
6: 
7: public interface ItemTestHelper {
8:     /**
9:      * Adds all test items to the database.
10:      * If you use the debugger and want to identify _which_ test item you currently look at:
11:      * The indices are coded into the first number in the name string of the item, like e.g.
12:      * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
13:      */
14:     void addAllItems();
15: 
16: 
17:     /**
18:      * @return the number of test items in the database
19:      */
20:     int numberOfItems();
21: 
22: 
23:     /**
24:      * @param index
25:      * @return the id of the test item at the given index
26:      */
27:     UUID getItemId( int index );
28: 
29: 
30:     /**
31:      * @param itemId - the id of the item in the test data
32:      * @return the index of the test item with that id
33:      */
34:     int findItemIndex( UUID itemId );
35: 
36: 
37:     /**
38:      * @param index
39:      * @return the buying price of test item at the given index
40:      */
41:     CurrencyType getBuyingPrice( int index );
42: 
43: 
44:     /**
45:      * @param index
46:      * @return the selling price of test item at the given index
47:      */
48:     CurrencyType getSellingPrice( int index );
49: }
50: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockUser.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.Setter;
4: import thkoeln.archilab.ecommerce.usecases.UserType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;
6: 
7: 
8: import java.util.Objects;
9: 
10: @Setter
11: public class MockUser implements UserType {
12:     private String name;
13:     private EmailType emailType;
14:     private AddressType addressType;
15: 
16: 
17:     public MockUser( String name, EmailType emailType, AddressType addressType) {
18:         this.name = name;
19:         this.emailType = emailType;
20:         this.addressType = addressType;
21:     }
22: 
23:     @Override
24:     public String getName() {
25:         return name;
26:     }
27: 
28:     @Override
29:     public EmailType getEmail() {
30:         return emailType;
31:     }
32: 
33:     @Override
34:     public AddressType getAddress() {
35:         return addressType;
36:     }
37: 
38:     @Override
39:     public boolean equals( Object o ) {
40:         if ( this == o ) return true;
41:         if ( !( o instanceof MockUser ) ) return false;
42:         MockUser that = (MockUser) o;
43:         return Objects.equals( getName(), that.getName() ) &&
44:                 Objects.equals( emailType, that.emailType ) &&
45:                 Objects.equals( addressType, that.addressType );
46:     }
47: 
48:     @Override
49:     public int hashCode() {
50:         return Objects.hash( getName(), emailType, addressType );
51:     }
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.usecases.*;
6: 
7: /**
8:  * Removes everything :-)
9:  */
10: @Service
11: public class Purgatory {
12:     @Autowired
13:     private UserRegistrationUseCases userRegistrationUseCases;
14:     @Autowired
15:     private ShoppingCartUseCases shoppingCartUseCases;
16:     @Autowired
17:     private OrderUseCases orderUseCases;
18:     @Autowired
19:     private ItemCatalogUseCases itemCatalogUseCases;
20:     @Autowired
21:     private StorageUnitUseCases storageUnitUseCases;
22: 
23:     public void deleteEverything() {
24:         orderUseCases.deleteAllOrders();
25:         shoppingCartUseCases.emptyAllShoppingCarts();
26:         storageUnitUseCases.deleteAllStorageUnits();
27:         userRegistrationUseCases.deleteAllUsers();
28:         itemCatalogUseCases.deleteItemCatalog();
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.context.ApplicationListener;
6: import org.springframework.context.annotation.Profile;
7: import org.springframework.context.event.ContextRefreshedEvent;
8: import org.springframework.stereotype.Component;
9: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
12: 
13: @Component
14: @Slf4j
15: @Profile("!test")
16: @SuppressWarnings("PMD")
17: public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
18:     private Purgatory purgatory;
19:     private UserTestHelper userTestHelper;
20:     private ItemTestHelper itemTestHelper;
21:     private StorageUnitTestHelper storageUnitTestHelper;
22: 
23: 
24:     @Autowired
25:     public StartupListener( Purgatory purgatory,
26:                             UserTestHelper userTestHelper,
27:                             ItemTestHelper itemTestHelper,
28:                             StorageUnitTestHelper storageUnitTestHelper ) {
29:         this.purgatory = purgatory;
30:         this.userTestHelper = userTestHelper;
31:         this.itemTestHelper = itemTestHelper;
32:         this.storageUnitTestHelper = storageUnitTestHelper;
33:     }
34: 
35:     @Override
36:     public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
37:         log.info( "StartupListener initializing master data ..." );
38:         purgatory.deleteEverything();
39:         userTestHelper.registerAllUsers();
40:         itemTestHelper.addAllItems();
41:         storageUnitTestHelper.addAllStorageUnits( true );
42:     }
43: }
44: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StorageUnitTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import java.util.UUID;
4: 
5: public interface StorageUnitTestHelper {
6:     /**
7:      * Adds the test storage units to the system.
8:      * If you want to use the storage units, or want to know which index the storage unit has that you see
9:      * in the debugger, the following rules apply:
10:      * - The storage unit name will equal the street name of the address of the storage unit.
11:      * - The index number is visible in the house number. Example: storage unit 3 is located at
12:      *   "Ablageweg 3", and that is also its name.
13:      *
14:      *  The storage units are used in the tests as follows:
15:      *  - storage unit 0 holds all items 0 - 6, and is used for all tests where it is not relevant
16:      *    to split one shopping cart into several orders.
17:      *  - storage units 1 - 3 are used for the proximity tests, where you can deliver item 7 to
18:      *    to a user from the closest storage unit.
19:      *  - storage units 4 - 8 are used for the tests where you need to deliver items 8 - 14 in
20:      *    the most cost-efficient way, as multiple shipments.
21:      *  - storage unit 9 is empty.
22:      *
23:      *  If withInventory is true, then the storage units are filled with items. This happens
24:      *  according to the following rules:
25:      *  - items 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
26:      *    ONLY available in storage unit 0. (This means that item 0 out of inventory everywhere.)
27:      *  - items 4, 5, 6 have a random inventory between 30 and 130, also all ONLY in storage unit 0
28:           (these are the items used for tests on how to add and remove inventory)
29:      *  - item 7 has a random inventory between 30 and 130, distributed over
30:      *    storage units 1, 2, and 3. You can use this to test if the appropriate storage unit is found
31:      *    for a shopping cart with only item 7 in it, but with different quantities (<= 3, or > 3).
32:      *  - The other items (8 - 14) have also a random inventory between 30 and 130, all distributed
33:      *    over several storage units. The distribution is done as follows:
34:      *    Assume that the item is available in <n> storage units. Then the first <n-1> storage units
35:      *    in the list (in ascending sequence) contain 3, and all the remaining inventory is in the
36:      *    last storage unit.
37:      *
38:      *    This is how the inventory of items could be distributed
39:      *    (Wx = storage unit x with its zip code, Px = item x,
40:      *    numbers marked with (*) are random large numbers):
41:      *
42:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
43:      *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
44:      *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
45:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
46:      *    | P0   |      |     |     |      |     |      |     |       |      |     |
47:      *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
48:      *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
49:      *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
50:      *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
51:      *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
52:      *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
53:      *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
54:      *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
55:      *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
56:      *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
57:      *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
58:      *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
59:      *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
60:      *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
61:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
62:      *
63:      * @param withInventory if true, the inventory of the items is added to the storage unit. Otherwise, the
64:      *                           the inventory is not added and the storage unit is empty.
65:      */
66:     public void addAllStorageUnits( boolean withInventory );
67: 
68: 
69:     /**
70:      * @return the number of test storage units in the database
71:      */
72:     int numberOfStorageUnits();
73: 
74: 
75:     /**
76:      * @param index
77:      * @return the id of the test storage unit at the given index
78:      */
79:     UUID getStorageUnitId( int index );
80: 
81: 
82:     /**
83:      * @param storageUnitId - the id of the storage unit in the test data
84:      * @return the index of the test storage unit with that id
85:      */
86:     int findStorageUnitIndex( UUID storageUnitId );
87: 
88: 
89:     /**
90:      * @param itemIndex - the index of the item in the test data
91:      * @param storageUnitIndex - the index of the storage unit in the test data
92:      * @return the number of items (inventory) available in the storage unit at the given index
93:      */
94:     Integer getStorageUnitInventory( int storageUnitIndex, int itemIndex );
95: 
96: }
97: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\UserTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: 
4: import thkoeln.archilab.ecommerce.usecases.UserType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
7: 
8: /**
9:  * This is a test helper interface provides access to predefined test data for
10:  * users.
11:  */
12: public interface UserTestHelper {
13:     /**
14:      * This method calls the use case implementation to register all users specified in the
15:      * test data set.
16:      * If you use the debugger and want to identify _which_ test user you currently look at:
17:      * The indices are coded into the house number (in the user's address) and in the first
18:      * cipher of the zip code. This is the list of users:
19:      *
20:      * +-------+-------------------+--------+---------------------
21:      * | Index | Name              | PLZ    | Email
22:      * +-------+-------------------+--------+---------------------
23:      * | 0     | Max Mueller       | 02314  | 99Z@example.com
24:      * | 1     | Sophie Schmitz    | 02368  | a@4.com
25:      * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
26:      * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
27:      * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
28:      * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
29:      * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
30:      * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
31:      * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
32:      * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
33:      * +-------+-------------------+--------+---------------------
34:      */
35:     void registerAllUsers();
36: 
37: 
38:     /**
39:      * @return the number of test users in the test data set.
40:      */
41:     int getNumberOfUsers();
42: 
43: 
44:     /**
45:      * @param index the index of the user in the test data set.
46:      * @return the name of the test user with the given index.
47:      */
48:     String getUserName( int index );
49: 
50: 
51:     /**
52:      * @param index the index of the user in the test data set.
53:      * @return the email of the test user with the given index.
54:      */
55:     EmailType getUserEmail( int index );
56: 
57: 
58:     /**
59:      * @param index the index of the user in the test data set.
60:      * @return the address of the test user with the given index.
61:      */
62:     AddressType getUserAddress( int index );
63: 
64: 
65:     /**
66:      * @param index the index of the user in the test data set.
67:      * @return the test user with the given index.
68:      */
69:     UserType getUser( int index );
70: 
71: }
72: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\OrderUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: package thkoeln.archilab.ecommerce.usecases;
5: 
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
9: 
10: import java.util.Map;
11: import java.util.UUID;
12: 
13: /**
14:  * This interface contains methods needed in the context of the order history of a user.
15:  */
16: public interface OrderUseCases {
17: 
18:     /**
19:      * Returns a map showing which items have been ordered by a user and how many of each item
20:      *
21:      * @param userEmail
22:      * @return the order history of the user (map is empty if the user has not ordered anything yet)
23:      * @throws ShopException if
24:      *      - userEmail is null
25:      *      - the user with the given email does not exist
26:      */
27:     public Map<UUID, Integer> getOrderHistory( EmailType userEmail );
28: 
29: 
30: 
31:     /**
32:      * @return the number of items in a given order. If the item is not a position of the order, the method
33:      *         returns 0. No exception is thrown.
34:      * @param orderId - the id of the order to be checked
35:      * @param itemId - the id of the item for which we want to know the quantity
36:      * @throws ShopException if
37:      *     - orderId is null, or doesn't exist in the system
38:      *     - itemId is null, or doesn't exist in the system
39:      */
40:     public Integer getOrderQuantityOfItem( UUID orderId, UUID itemId );
41: 
42: 
43:     /**
44:      * @return the id of the storage unit that is responsible for the given order
45:      * @param orderId - the id of the order to be checked
46:      * @throws ShopException if
47:      *      - orderId is null, or doesn't exist in the system
48:      */
49:     public UUID getStorageUnitIdForOrder( UUID orderId );
50: 
51: 
52:     /**
53:      * Deletes all orders in the system
54:      */
55:     public void deleteAllOrders();
56: }
57: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingCartUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
10: 
11: import java.util.Map;
12: import java.util.Set;
13: import java.util.UUID;
14: 
15: /**
16:  * This interface contains methods needed in the context of use cases handling the shopping cart.
17:  * The interface is probably incomplete, and will grow over time ...
18:  */
19: public interface ShoppingCartUseCases {
20:     /**
21:      * Adds a item to the cart of a user
22:      *
23:      * @param userEmail
24:      * @param itemId
25:      * @param quantityOf
26:      * @throws ShopException if ...
27:      *          - userEmail is null,
28:      *          - the user with the given email does not exist,
29:      *          - itemId is null,
30:      *          - the item with itemId does not exist
31:      *          - the Quantity is negative,
32:      */
33:     public void addItemToShoppingCart( EmailType userEmail,
34:                                                  UUID itemId, int quantityOf );
35: 
36: 
37:     /**
38:      * Removes a item from the cart of a user
39:      *
40:      * @param userEmail
41:      * @param itemId
42:      * @param quantityOf
43:      * @throws ShopException if ...
44:      *          - userEmail is null,
45:      *          - the user with the given email does not exist,
46:      *          - itemId is null,
47:      *          - the item with itemId does not exist
48:      *          - the Quantity is negative
49:      *          - the item is not in the shopping cart in the requested Quantity
50:      */
51:     public void removeItemFromShoppingCart( EmailType userEmail,
52:                                                       UUID itemId, int quantityOf );
53: 
54: 
55:     /**
56:      * Returns a map showing which items are in the cart of a user and how many of each item
57:      *
58:      * @param userEmail
59:      * @return the cart of the user (map is empty if the cart is empty)
60:      * @throws ShopException if
61:      *          - userEmail is null,
62:      *          - the user with the given email does not exist
63:      */
64:     public Map<UUID, Integer> getShoppingCartAsMap( EmailType userEmail );
65: 
66: 
67:     /**
68:      * Returns the current value of all items in the cart of a user
69:      *
70:      * @param userEmail
71:      * @return the cart of the user
72:      * @throws ShopException if
73:      *          - userEmail is null,
74:      *          - the user with the given email does not exist
75:      */
76:     public CurrencyType getShoppingCartAsCurrencyValue( EmailType userEmail );
77: 
78: 
79: 
80: 
81:     /**
82:      * Checks out the cart of a user
83:      *
84:      * @param userEmail
85:      * @return A set of ids belonging to orders that were created during the checkout. If the shopping cart can
86:      *         only be served from more than one storage unit, each shipment from a storage unit gets a
87:      *         dedicated order. I.e. if there is just one shipment, then the set will contain just one order id.
88:      *         If there are multiple shipments, the set will contain multiple order ids.
89:      * @throws ShopException if
90:      *      - userEmail is null or empty
91:      *      - the user with the given email does not exist, or if the cart is empty
92:      * @throws
93:      *      - ShopException if userEmail is null
94:      *      - InsufficientInventoryException if there is not enough inventory level for to serve the order
95:      *        for all items in the shopping cart
96:      */
97:     public Set<UUID> checkout( EmailType userEmail );
98: 
99: 
100:     /**
101:      * Empties all shopping carts in the system
102:      */
103:     public void emptyAllShoppingCarts();
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\StorageUnitUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
9: 
10: import java.util.UUID;
11: 
12: /**
13:  * This interface contains methods needed in the context of handling the shop inventory,
14:  * i.e. managing storage units, and adding / removing items in the storage unit.
15:  */
16: public interface StorageUnitUseCases {
17:     /**
18:      *
19:      * @param name
20:      * @param address
21:      * @return the id of the new storage unit
22:      * @throws ShopException if ...
23:      *      - name is null or empty
24:      *      - address is null
25:      */
26:     public UUID addNewStorageUnit( String name, AddressType address );
27: 
28: 
29:     /**
30:      * Deletes all storage units from the shop. Intended for testing purposes.
31:      */
32:     public void deleteAllStorageUnits();
33: 
34: 
35:     /**
36:      * Adds a certain Quantity of a given item to the inventory
37:      * @param storageUnitId
38:      * @param itemId
39:      * @param addedQuantityOf
40:      * @throws ShopException if ...
41:      *      - storageUnitId is null
42:      *      - the storage unit with that id does not exist
43:      *      - itemId is null
44:      *      - the item with that id does not exist
45:      *      - addedQuantityOf < 0
46:      */
47:     public void addToInventory( UUID storageUnitId, UUID itemId, int addedQuantityOf );
48: 
49: 
50:     /**
51:      * Removes a certain Quantity of a given item from the inventory.
52:      * @param storageUnitId
53:      * @param itemId
54:      * @param removedQuantityOf
55:      * @throws ShopException if ...
56:      *      - storageUnitId is null
57:      *      - the storage unit with that id does not exist
58:      *      - itemId is null
59:      *      - the item with that id does not exist
60:      *      - removedQuantityOf < 0
61:      */
62:     public void removeFromInventory( UUID storageUnitId, UUID itemId, int removedQuantityOf );
63: 
64: 
65:     /**
66:      * Changes the total Quantity of a given item in the inventory.
67:      * @param storageUnitId
68:      * @param itemId
69:      * @param newTotalQuantityOf
70:      * @throws ShopException if ...
71:      *      - storageUnitId is null
72:      *      - the storage unit with that id does not exist
73:      *      - itemId is null
74:      *      - the item with that id does not exist
75:      *      - newTotalQuantityOf < 0
76:      */
77:     public void changeInventoryTo( UUID storageUnitId, UUID itemId, int newTotalQuantityOf );
78: 
79: 
80:     /**
81:      * Get the current inventory of a given item in one specific storage unit.
82:      * @param storageUnitId
83:      * @param itemId
84:      * @return the current total inventory of the item
85:      * @throws ShopException if ...
86:      *      - storageUnitId is null
87:      *      - the storage unit with that id does not exist
88:      *      - itemId is null
89:      *      - the item with that id does not exist
90:      */
91:     public int getAvailableInventory( UUID storageUnitId, UUID itemId );
92: 
93: 
94: }
95: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\UserRegistrationUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
10: 
11: /**
12:  * This interface contains methods needed in the context of use cases concerning the registration of a user.
13:  * The interface is probably incomplete, and will grow over time ...
14:  */
15: public interface UserRegistrationUseCases {
16:     /**
17:      * Registers a new user
18:      *
19:      * @param name
20:      * @param email
21:      * @param address
22:      * @throws ShopException if ...
23:      *      - the user with the given email already exists
24:      *      - address is null
25:      */
26:     public void register( String name, EmailType email, AddressType address );
27: 
28: 
29:     /**
30:      * Changes the address of a user
31:      *
32:      * @param userEmail
33:      * @param userEmail
34:      * @param address
35:      * @throws ShopException if ...
36:      *      - the user with the given email does not exist,
37:      *      - address is null
38:      */
39:     public void changeAddress( EmailType userEmail,
40:                                AddressType address );
41: 
42: 
43:     /**
44:      * Returns the data of a user as an array of strings (name, email, street, city, zipCode)
45:      * @param userEmail
46:      * @return the user data
47:      * @throws ShopException the user with the given email does not exist,
48:      */
49:     public UserType getUserData( EmailType userEmail );
50: 
51: 
52: 
53:     /**
54:      * Clears all users, including all orders and shopping carts
55:      */
56:     public void deleteAllUsers();
57: }
58: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\usecases\UserType.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
5: 
6: /**
7:  * This interface expresses the essence of a shop user
8:  */
9: public interface UserType {
10:     String getName();
11:     EmailType getEmail();
12:     AddressType getAddress();
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import org.springframework.boot.test.context.TestConfiguration;
4: import org.springframework.context.annotation.Bean;
5: import org.springframework.test.web.servlet.MockMvc;
6: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
7: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
8: 
9: 
10: @TestConfiguration
11: public class RESTTestHelperConfiguration {
12: 
13:     @Bean
14:     public ShoppingCartRESTHelper shoppingCartRESTHelper(
15:             MockMvc mockMvc, ItemCatalogUseCases itemCatalogUseCases ) {
16:         return new ShoppingCartRESTHelperImpl( mockMvc, itemCatalogUseCases );
17:     }
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingCartRESTHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import com.fasterxml.jackson.databind.ObjectMapper;
5: import lombok.AllArgsConstructor;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import lombok.Setter;
9: import lombok.extern.slf4j.Slf4j;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.MvcResult;
12: import org.springframework.test.web.servlet.ResultActions;
13: import org.springframework.test.web.servlet.ResultMatcher;
14: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
15: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
18: 
19: import java.util.Map;
20: import java.util.UUID;
21: 
22: import static org.springframework.http.MediaType.APPLICATION_JSON;
23: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
24: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
25: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
26: 
27: @Slf4j
28: public class ShoppingCartRESTHelperImpl implements ShoppingCartRESTHelper {
29:     private MockMvc mockMvc;
30:     private ItemCatalogUseCases itemCatalogUseCases;
31: 
32:     private static final ResultMatcher CREATED = status().isCreated();
33:     private static final ResultMatcher OK = status().isOk();
34: 
35:     public ShoppingCartRESTHelperImpl( MockMvc mockMvc, ItemCatalogUseCases itemCatalogUseCases ) {
36:         this.mockMvc = mockMvc;
37:         this.itemCatalogUseCases = itemCatalogUseCases;
38:     }
39: 
40: 
41:     @Override
42:     public UUID getQueryShoppingCart( EmailType email, Map<UUID, Integer> quantityMap )
43:             throws Exception {
44:         // first query the users API to get the proper userId
45:         UUID userId;
46:         String userUri = "/users?email=" + email.toString();
47:         MvcResult userGetResult = mockMvc.perform( get( userUri ) )
48:                 .andExpect( status().isOk() )
49:                 .andReturn();
50:         ObjectMapper objectMapper = new ObjectMapper();
51:         IdDTO idDTO = objectMapper.readValue( userGetResult.getResponse().getContentAsString(), IdDTO.class );
52:         userId = idDTO.getId();
53: 
54:         // then query the shopping cart API and extract the shopping cart id
55:         String shoppingCartUri = "/shoppingCarts?userId=" + userId.toString();
56:         ResultActions resultActions = mockMvc.perform( get( shoppingCartUri ) )
57:                 .andExpect( status().isOk() );
58:         idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
59:         UUID shoppingCartId = idDTO.getId();
60: 
61:         // additional checks, if desired
62:         if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
63:         return shoppingCartId;
64:     }
65: 
66: 
67:     private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
68:         if ( quantityMap == null ) return;
69:         int numOfItems = quantityMap.size();
70:         resultActions.andExpect( jsonPath( "$.positions.length()" ).value( numOfItems ) );
71:         float totalSellingPriceAsFloat = 0f;
72:         for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
73:             UUID itemId = entry.getKey();
74:             Integer quantity = entry.getValue();
75:             resultActions.andExpect( jsonPath( "$.positions.[?(@.itemId == '" + itemId + "')].quantity" )
76:                     .value( quantity ) );
77:             CurrencyType sellingPrice = itemCatalogUseCases.getSellingPrice( itemId );
78:             totalSellingPriceAsFloat += sellingPrice.getQuantity() * quantity;
79:         }
80:         // last thing - check the total selling price
81:         String totalSellingPriceString = String.format( "%.2f €", totalSellingPriceAsFloat );
82:         resultActions
83:                 .andExpect( jsonPath( "$.totalSellingPrice" ).value( totalSellingPriceString ) );
84:     }
85: 
86: 
87:     @Override
88:     public void addItemToShoppingCart( UUID shoppingCartId, UUID itemId, Integer quantity )
89:             throws Exception {
90:         addItemToShoppingCart( shoppingCartId, itemId, quantity, null );
91:     }
92: 
93: 
94:     @Override
95:     public void addItemToShoppingCart( UUID shoppingCartId, UUID itemId, Integer quantity,
96:                                                   ResultMatcher expectedStatus ) throws Exception {
97:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
98:         ObjectMapper objectMapper = new ObjectMapper();
99:         QuantityDTO dto = new QuantityDTO( itemId, quantity );
100:         String quantityJson = objectMapper.writeValueAsString( dto );
101:         mockMvc.perform( post( "/shoppingCarts/" + shoppingCartId + "/positions" )
102:                         .contentType( APPLICATION_JSON ).content( quantityJson ) )
103:                 .andExpect( status );
104:     }
105: 
106: 
107: 
108:     @Override
109:     public void deleteItemFromShoppingCart( UUID shoppingCartId, UUID itemId )
110:             throws Exception {
111:         deleteItemFromShoppingCart( shoppingCartId, itemId, null );
112:     }
113: 
114: 
115: 
116:     @Override
117:     public void deleteItemFromShoppingCart( UUID shoppingCartId, UUID itemId,
118:                                                       ResultMatcher expectedStatus ) throws Exception {
119:         ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
120:         String uri = "/shoppingCarts/" + shoppingCartId + "/positions/" + itemId;
121:         mockMvc.perform( delete( uri ) ).andExpect( status );
122:     }
123: 
124: 
125:     @Override
126:     public void checkout( UUID shoppingCartId, String expectedUserName,
127:                           ResultMatcher expectedStatus,
128:                           Map<UUID, Map<UUID, Integer>> expectedOrders ) throws Exception {
129:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
130:         String uri = "/shoppingCarts/" + shoppingCartId + "/checkout";
131:         MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
132:         ObjectMapper objectMapper = new ObjectMapper();
133: 
134:         // check the response content
135:         if ( expectedOrders != null || expectedUserName != null ) {
136:             String responseContent = result.getResponse().getContentAsString();
137:             log.info( "ShoppingCartRESTHelperImpl - checkout: found response content " + responseContent );
138:             OrderDTO[] orders = objectMapper.readValue( responseContent, OrderDTO[].class );
139:             checkExpectedUserName( expectedUserName, orders );
140:             checkExpectedOrders( expectedOrders, orders );
141:         }
142:     }
143: 
144: 
145:     private void checkExpectedUserName( String expectedUserName, OrderDTO[] orders ) {
146:         if ( expectedUserName == null ) return;
147:         for ( OrderDTO order : orders ) {
148:             if ( !order.getUserName().equals( expectedUserName ) ) {
149:                 throw new AssertionError( "Expected userName '" + expectedUserName +
150:                         "' but got '" + order.getUserName() + "'" );
151:             }
152:         }
153:     }
154: 
155: 
156:     private void checkExpectedOrders( Map<UUID, Map<UUID, Integer>> expectedOrders,
157:                                             OrderDTO[] orders ) {
158:         if ( expectedOrders == null ) return;
159:         for ( OrderDTO order : orders ) {
160:             UUID storageUnitId = order.getStorageUnitId();
161:             Map<UUID, Integer> expectedQuantities = expectedOrders.get( storageUnitId );
162:             if ( expectedQuantities == null ) {
163:                 throw new AssertionError( "No expected quantities for storage unit " + storageUnitId );
164:             }
165:             QuantityDTO[] positions = order.getPositions();
166:             for ( QuantityDTO quantityDTO : positions ) {
167:                 UUID itemId = quantityDTO.getItemId();
168:                 Integer expectedQuantity = expectedQuantities.get( itemId );
169:                 if ( expectedQuantity == null ) {
170:                     throw new AssertionError( "No expected quantity for item " + itemId +
171:                             " in storage unit " + storageUnitId );
172:                 }
173:                 if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
174:                     throw new AssertionError( "Expected quantity " + expectedQuantity + " for item " +
175:                             itemId + " in storage unit " + storageUnitId +
176:                             ", but got " + quantityDTO.getQuantity() );
177:                 }
178:             }
179:         }
180:     }
181: 
182: 
183:     /**
184:      * A DTO containing just a quantity, used in testing.
185:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
186:      * Therefore, constructors and getters/setters are manually defined.
187:      */
188:     @NoArgsConstructor
189:     @JsonIgnoreProperties(ignoreUnknown = true)
190:     private static class QuantityDTO {
191:         private UUID itemId;
192:         private Integer quantity;
193: 
194:         public QuantityDTO( UUID itemId, Integer quantity ) {
195:             this.itemId = itemId;
196:             this.quantity = quantity;
197:         }
198:         public UUID getItemId() {
199:             return itemId;
200:         }
201:         public Integer getQuantity() {
202:             return quantity;
203:         }
204:         public void setItemId( UUID itemId ) {
205:             this.itemId = itemId;
206:         }
207:         public void setQuantity( Integer quantity ) {
208:             this.quantity = quantity;
209:         }
210:     }
211: 
212: 
213:     /**
214:      * A DTO containing just the id of an entity, used in testing.
215:      */
216:     @AllArgsConstructor
217:     @NoArgsConstructor
218:     @Getter
219:     @Setter
220:     @JsonIgnoreProperties(ignoreUnknown = true)
221:     private static class IdDTO {
222:         private UUID id;
223:     }
224: 
225: 
226:     /**
227:      * A DTO containing the order data, used in testing.
228:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
229:      * Therefore, constructors and getters/setters are manually defined.
230:      */
231:     @NoArgsConstructor
232:     @JsonIgnoreProperties(ignoreUnknown = true)
233:     private static class OrderDTO {
234:         private UUID id;
235:         private String userName;
236:         private UUID storageUnitId;
237:         private QuantityDTO[] positions;
238: 
239:         public UUID getId() {
240:             return id;
241:         }
242:         public String getUserName() {
243:             return userName;
244:         }
245:         public UUID getStorageUnitId() {
246:             return storageUnitId;
247:         }
248:         public QuantityDTO[] getPositions() {
249:             return positions;
250:         }
251:         public void setId( UUID id ) {
252:             this.id = id;
253:         }
254:         public void setUserName( String userName ) {
255:             this.userName = userName;
256:         }
257:         public void setStorageUnitId( UUID storageUnitId ) {
258:             this.storageUnitId = storageUnitId;
259:         }
260:         public void setPositions( QuantityDTO[] positions ) {
261:             this.positions = positions;
262:         }
263:     }
264: 
265: }
266: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingCartRESTHelper.java ---
1: package thkoeln.archilab.ecommerce.helpers;
2: 
3: import org.springframework.test.web.servlet.ResultMatcher;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
5: 
6: import java.util.Map;
7: import java.util.UUID;
8: 
9: /**
10:  * A REST helper for shopping cart-related operations.
11:  * This interface defines methods to interact with a shopping cart via REST calls, such as querying, adding,
12:  * deleting, and checking out.
13:  */
14: public interface ShoppingCartRESTHelper {
15:     /**
16:      * Executes a REST GET query on a shopping cart and returns its id, with the user's email as a
17:      * starting point. The resulting shopping cart is checked against the given expected quantity map.
18:      * @param email The email of the user whose shopping cart is queried.
19:      * @param expectedQuantityMap A map of items and their quantities in the shopping cart. (If null, then don't check.)
20:      * @return The id of the user's shopping cart.
21:      * @throws Exception (whenever the REST call fails, or the shopping cart does not match the expected quantity map)
22:      */
23:     public UUID getQueryShoppingCart( EmailType email,
24:                                        Map<UUID, Integer> expectedQuantityMap ) throws Exception;
25: 
26: 
27:     /**
28:      * Adds a item to a shopping cart via a REST call.
29:      * @param shoppingCartId Id of the shopping cart.
30:      * @param itemId Id of the item.
31:      * @param quantity Quantity of the item.
32:      * @throws Exception (whenever the REST call fails)
33:      */
34:     public void addItemToShoppingCart( UUID shoppingCartId, UUID itemId, Integer quantity )
35:             throws Exception;
36: 
37: 
38:     /**
39:      * Adds a item to a shopping cart via a REST call.
40:      * @param shoppingCartId Id of the shopping cart.
41:      * @param itemId Id of the item.
42:      * @param quantity Quantity of the item.
43:      * @param expectedStatus expected status of the operation (null = CREATED)
44:      * @throws Exception (whenever the REST call fails or the status does not match)
45:      */
46:     public void addItemToShoppingCart( UUID shoppingCartId, UUID itemId, Integer quantity,
47:                                                   ResultMatcher expectedStatus ) throws Exception;
48: 
49: 
50:     /**
51:      * Deletes a item from a shopping cart via a REST call.
52:      * @param shoppingCartId Id of the shopping cart.
53:      * @param itemId Id of the item.
54:      * @throws Exception (whenever the REST call fails)
55:      */
56:     public void deleteItemFromShoppingCart( UUID shoppingCartId, UUID itemId )
57:             throws Exception;
58: 
59: 
60:     /**
61:      * Deletes a item from a shopping cart via a REST call.
62:      * @param shoppingCartId Id of the shopping cart.
63:      * @param itemId Id of the item.
64:      * @param expectedStatus expected status of the operation (null = OK)
65:      * @throws Exception (whenever the REST call fails or the status does not match)
66:      */
67:     public void deleteItemFromShoppingCart( UUID shoppingCartId, UUID itemId,
68:                                                       ResultMatcher expectedStatus ) throws Exception;
69: 
70: 
71:     /**
72:      * Checks out a shopping cart via REST call, and returns the id of the created order.
73:      * @param shoppingCartId
74:      * @param expectedUserName expected name of the user who owns the shopping cart (null = don't check)
75:      * @param expectedStatus expected status of the operation (null = don't check)
76:      * @param expectedOrders the expected orders to be created as a result of the checkout. This is
77:      *                            a map of the following form:
78:      *                            <pre>
79:      *                               storageUnitId -> Map<itemId,Integer>
80:      *                            </pre>
81:      *                            where the inner map contains the items and their quantities
82:      * @return
83:      * @throws Exception
84:      */
85:     public void checkout( UUID shoppingCartId, String expectedUserName,
86:                           ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedOrders )
87:            throws Exception;
88: }
89: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class BasicNoOutsideSolutionRulesTest {
14: 
15:     @ArchTest
16:     static final ArchRule noClassesOnTopLevel =
17:             classes().should().resideInAPackage( "..solution.*.." )
18:                     .allowEmptyShould( true );
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.library.Architectures.layeredArchitecture;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln")
12: @SuppressWarnings("PMD")
13: public class BasicProperDependenciesTest {
14: 
15:     @ArchTest
16:     static final ArchRule properDependencies =
17:             layeredArchitecture()
18:                     .consideringAllDependencies()
19:                     //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
20:                     .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
21:                     .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )
22: 
23:                     //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
24:                     .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
25:                     .allowEmptyShould( true );
26: }
27: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
5: import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
6: import org.springframework.core.type.classreading.MetadataReader;
7: import org.springframework.core.type.classreading.MetadataReaderFactory;
8: 
9: import java.io.IOException;
10: import java.util.Arrays;
11: import java.util.HashSet;
12: import java.util.Set;
13: 
14: import static org.junit.jupiter.api.Assertions.assertTrue;
15: 
16: public class BasicRequiredClassesTest {
17:     private static final String[] REQUIRED_CLASSES = {
18:             "User",
19:             "UserRepository",
20:             "Item",
21:             "ItemRepository",
22:             "Order",
23:             "OrderRepository",
24:             "InventoryLevel",
25:             "ShoppingCart",
26:             "ShoppingCartRepository",
27:             "StorageUnitRepository",
28:             "ShoppingCartPosition",
29:             "OrderPosition",
30:             "StorageUnit",
31:     };
32: 
33:     @Test
34:     public void testRequiredClassesDeclared() throws IOException {
35:         String basePackage = "thkoeln.archilab.ecommerce";
36:         String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";
37: 
38:         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
39:         MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );
40: 
41:         Set<String> foundClasses = new HashSet<>();
42: 
43:         Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
44:             try {
45:                 MetadataReader reader = readerFactory.getMetadataReader( resource );
46:                 foundClasses.add( reader.getClassMetadata().getClassName() );
47:             } catch (IOException e) {
48:                 e.printStackTrace();
49:             }
50:         } );
51: 
52:         Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
53:             boolean found = foundClasses.stream().anyMatch(className ->
54:                     className.startsWith(basePackage) && className.endsWith("." + requiredClass)
55:             );
56:             assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
57:         });
58:     }
59: }
60: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.boot.test.context.SpringBootTest;
6: import org.springframework.context.ApplicationContext;
7: 
8: import java.util.Arrays;
9: import java.util.HashMap;
10: import java.util.List;
11: import java.util.Map;
12: 
13: import static org.junit.jupiter.api.Assertions.*;
14: 
15: @SpringBootTest
16: public class BasicUseCaseImplementationPackageTest {
17: 
18:     @Autowired
19:     private ApplicationContext applicationContext;
20: 
21:     private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
22:         put("UserRegistrationUseCases", Arrays.asList("user"));
23:         put("StorageUnitUseCases", Arrays.asList("storageunit"));
24:         put("ItemCatalogUseCases", Arrays.asList("item"));
25:         put("ShoppingCartUseCases", Arrays.asList("shoppingcart"));
26:         put("OrderUseCases", Arrays.asList("order"));
27:     }};
28:     private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
29:     private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";
30: 
31:     @Test
32:     public void testRequiredClassesDeclared() {
33:         for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
34:             String interfaceName = USECASE_PATH + "." + entry.getKey();
35:             List<String> correctTopLevelPackages = entry.getValue();
36:             Class<?> useCaseInterfaceClass = null;
37:             try {
38:                 useCaseInterfaceClass = Class.forName( interfaceName );
39:             } catch (ClassNotFoundException e) {
40:                 fail( "Use case interface " + interfaceName + " not found.", e );
41:                 continue;
42:             }
43:             String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
44:             assertEquals( 1, beans.length,
45:                     "There should be exactly 1 service implementation for the interface " +
46:                             entry.getKey() + ", but found " + beans.length );
47:             Object bean = applicationContext.getBean( beans[0] );
48:             boolean isValid = false;
49:             for ( String correctTopLevelPackage : correctTopLevelPackages ) {
50:                 String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
51:                 if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
52:                     isValid = true;
53:                     break;
54:                 }
55:             }
56:             assertTrue( isValid,
57:                     "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
58:                             + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
59:         }
60:     }
61: }
62: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: import org.springframework.data.repository.CrudRepository;
8: import org.springframework.stereotype.Service;
9: 
10: import jakarta.persistence.Entity;
11: import org.springframework.web.bind.annotation.RestController;
12: 
13: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
14: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
15: 
16: @ArchTag("layerRules")
17: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
18: @SuppressWarnings("PMD")
19: public class DDDRulesTest {
20: 
21:     @ArchTest
22:     static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
23:             noClasses().that().resideInAPackage( "..domain.." )
24:                     .should().dependOnClassesThat().resideInAPackage( "..application.." )
25:                     .allowEmptyShould( true );
26: 
27:     @ArchTest
28:     static final ArchRule entitiesMustResideInADomainPackage =
29:             classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
30:                     .as( "Entities must reside in a package '..domain..'" )
31:                     .allowEmptyShould( true );
32: 
33:     @ArchTest
34:     static final ArchRule entitiesMustNotAccessRepositories =
35:             noClasses().that().areAnnotatedWith( Entity.class )
36:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
37:                     .allowEmptyShould( true );
38: 
39:     @ArchTest
40:     static final ArchRule repositoriesMustResideInADomainPackage =
41:             classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
42:                     .as( "Repositories must reside in a package '..domain..'" )
43:                     .allowEmptyShould( true );
44: 
45:     @ArchTest
46:     static final ArchRule repositoryNamesMustHaveProperSuffix =
47:             classes().that().areAssignableTo( CrudRepository.class )
48:                     .should().haveSimpleNameEndingWith( "Repository" )
49:                     .allowEmptyShould( true );
50: 
51:     @ArchTest
52:     static final ArchRule servicesMustResideInAnApplicationPackage =
53:             classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
54:                     .as( "Application Services must reside in a package '..application..'" )
55:                     .allowEmptyShould( true );
56: 
57:     @ArchTest
58:     static final ArchRule serviceNamesMustHaveProperSuffix =
59:             classes().that().areAnnotatedWith( Service.class )
60:                     .should().haveSimpleNameEndingWith( "Service" )
61:                     .allowEmptyShould( true );
62: 
63:     @ArchTest
64:     static final ArchRule controllersMustResideInAnApplicationPackage =
65:             classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
66:                     .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );
67: 
68:     @ArchTest
69:     static final ArchRule controllersNamesMustHaveProperSuffix =
70:             classes().that().areAnnotatedWith( RestController.class )
71:                     .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );
72: 
73:     @ArchTest
74:     static final ArchRule controllersMustNotAccessRepositories =
75:             noClasses().that().areAnnotatedWith( RestController.class )
76:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
77:                     .allowEmptyShould( false );
78: }
79: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.importer.ClassFileImporter;
6: import com.tngtech.archunit.lang.ArchRule;
7: import com.tngtech.archunit.library.dependencies.SliceAssignment;
8: import com.tngtech.archunit.library.dependencies.SliceIdentifier;
9: import org.junit.jupiter.api.Test;
10: 
11: import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
12: 
13: public class NoCycleTest {
14:     private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");
15: 
16:     private SliceAssignment inAllClasses() {
17:         return new SliceAssignment() {
18:             @Override
19:             public String getDescription() {
20:                 return "every class in it's own slice";
21:             }
22: 
23:             @Override
24:             public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
25:                 return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
26:             }
27:         };
28:     }
29: 
30:     @Test
31:     public void testNoCyclicDependenciesBetweenClasses() {
32:         slices().assignedFrom(inAllClasses())
33:                 .namingSlices("$1[$2.$3]")
34:                 .should().beFreeOfCycles()
35:                 .check(importedClasses);
36:     }
37: 
38:     @Test
39:     public void testNoCyclicDependenciesBetweenPackages() {
40:         ArchRule rule = slices().matching("..solution.(*)..")
41:                 .should().beFreeOfCycles().allowEmptyShould( true );
42:         rule.check(importedClasses);
43:     }
44: }
45: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.base.DescribedPredicate;
4: import com.tngtech.archunit.core.domain.JavaClass;
5: import com.tngtech.archunit.core.domain.JavaField;
6: import com.tngtech.archunit.core.domain.JavaParameterizedType;
7: import com.tngtech.archunit.core.domain.JavaType;
8: import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
9: import com.tngtech.archunit.junit.AnalyzeClasses;
10: import com.tngtech.archunit.junit.ArchTag;
11: import com.tngtech.archunit.junit.ArchTest;
12: import com.tngtech.archunit.lang.ArchCondition;
13: import com.tngtech.archunit.lang.ArchRule;
14: import com.tngtech.archunit.lang.ConditionEvents;
15: import com.tngtech.archunit.lang.SimpleConditionEvent;
16: import jakarta.persistence.*;
17: import lombok.extern.slf4j.Slf4j;
18: import thkoeln.archilab.ecommerce.GenericId;
19: 
20: import java.util.List;
21: 
22: import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
23: import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
24: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;
25: 
26: @ArchTag("layerRules")
27: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
28: @SuppressWarnings("PMD")
29: @Slf4j
30: public class OnlyReferenceViaIDTest { //STORAGE_UNIT
31:     private static final String SHOPPING_CART_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingcart.domain";
32:     private static final String USER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.user.domain";
33:     private static final String ITEM_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.item.domain";
34:     private static final String ORDER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.order.domain";
35:     private static final String STORAGE_UNIT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.storageunit.domain";
36: 
37:     @ArchTest
38:     static final ArchRule idFieldsMustUseGenericId =
39:             fields()
40:                     .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
41:                     .and().areAnnotatedWith( Id.class )
42:                     .should().haveRawType( assignableTo( GenericId.class ) )
43:                     .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
44:                     .allowEmptyShould( true );
45: 
46: 
47:     private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
48:             annotatedWith( ManyToOne.class )
49:                     .or( annotatedWith( OneToOne.class ) )
50:                     .or( annotatedWith( Embedded.class ) )
51:                     .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );
52: 
53:     private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
54:             annotatedWith( OneToMany.class )
55:                     .or( annotatedWith( ManyToMany.class ) )
56:                     .or( annotatedWith( ElementCollection.class ) )
57:                     .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );
58: 
59: 
60:     private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
61:         String description = "an entity or value object from same aggregate, or a domain primitive";
62:         return new DescribedPredicate<>( description ) {
63:             @Override
64:             public boolean test( JavaClass type ) {
65:                 // check if the class is an entity or value object, and resides in the allowed package
66:                 if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
67:                     return false;
68:                 }
69:                 // a GenericId is always allowed
70:                 if ( type.isAssignableTo( GenericId.class ) ) {
71:                     return true;
72:                 }
73:                 // a domain primitive is also always allowed
74:                 if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
75:                     return true;
76:                 }
77:                 return type.getPackageName().startsWith( allowedPackage );
78:             }
79:         };
80:     }
81: 
82: 
83:     @ArchTest
84:     static final ArchRule shoppingCartToOneReferences =
85:             fields()
86:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_CART_DOMAIN_PACKAGE )
87:                     .and( isToOneAnnotation )
88:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_CART_DOMAIN_PACKAGE ) ) )
89:                     .allowEmptyShould( true );
90: 
91:     @ArchTest
92:     static final ArchRule userToOneReferences =
93:             fields()
94:                     .that().areDeclaredInClassesThat().resideInAPackage( USER_DOMAIN_PACKAGE )
95:                     .and( isToOneAnnotation )
96:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( USER_DOMAIN_PACKAGE ) ) )
97:                     .allowEmptyShould( true );
98: 
99:     @ArchTest
100:     static final ArchRule itemToOneReferences =
101:             fields()
102:                     .that().areDeclaredInClassesThat().resideInAPackage( ITEM_DOMAIN_PACKAGE )
103:                     .and( isToOneAnnotation )
104:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( ITEM_DOMAIN_PACKAGE ) ) )
105:                     .allowEmptyShould( true );
106: 
107:     @ArchTest
108:     static final ArchRule orderToOneReferences =
109:             fields()
110:                     .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
111:                     .and( isToOneAnnotation )
112:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) ) )
113:                     .allowEmptyShould( true );
114: 
115:     @ArchTest
116:     static final ArchRule storageUnitToOneReferences =
117:             fields()
118:                     .that().areDeclaredInClassesThat().resideInAPackage( STORAGE_UNIT_DOMAIN_PACKAGE )
119:                     .and( isToOneAnnotation )
120:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( STORAGE_UNIT_DOMAIN_PACKAGE ) ) )
121:                     .allowEmptyShould( true );
122: 
123: 
124:     private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
125:         return new ArchCondition<JavaField>(
126:                 "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
127:             @Override
128:             public void check( JavaField field, ConditionEvents events ) {
129:                 JavaClass rawType = field.getRawType();
130:                 String rawTypeName = rawType.getFullName();
131:                 if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
132:                     events.add( SimpleConditionEvent.violated( field,
133:                             field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
134:                     return;
135:                 }
136:                 JavaType fieldType = field.getType();
137:                 if ( !( fieldType instanceof JavaParameterizedType ) ) {
138:                     events.add( SimpleConditionEvent.violated( field,
139:                             field.getFullName() + " is a raw List/Set without a type argument" ) );
140:                     return;
141:                 }
142:                 List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
143:                 if ( typeArguments.isEmpty() ) {
144:                     events.add( SimpleConditionEvent.violated( field,
145:                             field.getFullName() + " has no type arguments" ) );
146:                     return;
147:                 }
148:                 JavaType elementType = typeArguments.get( 0 );
149:                 if ( !( elementType instanceof JavaClass ) ) {
150:                     events.add( SimpleConditionEvent.violated( field,
151:                             field.getFullName() + " has an unknown element type" ) );
152:                     return;
153:                 }
154:                 JavaClass elementClass = (JavaClass) elementType;
155:                 boolean hasAnnotation =
156:                         elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
157:                 boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
158:                 boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
159:                 boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
160:                 boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
161:                 if ( !ok ) {
162:                     events.add( SimpleConditionEvent.violated( field,
163:                             field.getFullName() + " refers to " + elementClass.getFullName()
164:                                     + " which is not a DP, or an entity/value object in " + allowedPackage ) );
165:                 }
166:             }
167:         };
168:     }
169: 
170: 
171:     @ArchTest
172:     static final ArchRule shoppingCartToManyReferences =
173:             fields()
174:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_CART_DOMAIN_PACKAGE )
175:                     .and( isToManyAnnotation )
176:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_CART_DOMAIN_PACKAGE ) )
177:                     .allowEmptyShould( true );
178: 
179:     @ArchTest
180:     static final ArchRule userToManyReferences =
181:             fields()
182:                     .that().areDeclaredInClassesThat().resideInAPackage( USER_DOMAIN_PACKAGE )
183:                     .and( isToManyAnnotation )
184:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( USER_DOMAIN_PACKAGE ) )
185:                     .allowEmptyShould( true );
186: 
187:     @ArchTest
188:     static final ArchRule itemToManyReferences =
189:             fields()
190:                     .that().areDeclaredInClassesThat().resideInAPackage( ITEM_DOMAIN_PACKAGE )
191:                     .and( isToManyAnnotation )
192:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( ITEM_DOMAIN_PACKAGE ) )
193:                     .allowEmptyShould( true );
194: 
195:     @ArchTest
196:     static final ArchRule orderToManyReferences =
197:             fields()
198:                     .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
199:                     .and( isToManyAnnotation )
200:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) )
201:                     .allowEmptyShould( true );
202: 
203:     @ArchTest
204:     static final ArchRule storageUnitToManyReferences =
205:             fields()
206:                     .that().areDeclaredInClassesThat().resideInAPackage( STORAGE_UNIT_DOMAIN_PACKAGE )
207:                     .and( isToManyAnnotation )
208:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( STORAGE_UNIT_DOMAIN_PACKAGE ) )
209:                     .allowEmptyShould( true );
210: 
211: }
212: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: /**
4:  * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
5:  */
6: 
7: public class OwnTestsTest {
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClasses;
4: import com.tngtech.archunit.core.importer.ClassFileImporter;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: 
8: import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
9: 
10: public class PackageStructureTest {
11: 
12:     private static final String[] REQUIRED_PACKAGES = {"user", "shoppingcart", "item", "order", "storageunit"};
13:     private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
14:     private JavaClasses importedClasses;
15: 
16: 
17:     @BeforeEach
18:     public void setUp() {
19:         importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
20:     }
21: 
22:     @Test
23:     void testRequiredPackagesAreThere() {
24:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
25:             String packageName = BASE_PACKAGE + "." + requiredPackage;
26:             assertThat( importedClasses.containPackage( packageName ) )
27:                     .as( "Expected package %s not found!", packageName )
28:                     .isTrue();
29:         }
30:     }
31: 
32:     @Test
33:     void testRequiredDomainPackagesAreThere() {
34:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
35:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
36:             assertThat( importedClasses.containPackage( packageName ) )
37:                     .as( "Expected domain sub-package %s not found!", packageName )
38:                     .isTrue();
39:         }
40:     }
41: 
42:     @Test
43:     void testRequiredApplicationPackagesAreThere() {
44:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
45:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
46:             assertThat( importedClasses.containPackage( packageName ) )
47:                     .as( "Expected application sub-package %s not found!", packageName )
48:                     .isTrue();
49:         }
50:     }
51: 
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\AddressTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateAddress;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
11: 
12: class AddressTest {
13: 
14:     @Test
15:     public void testGetterAddress() {
16:         // given
17:         String street = "Irgendeinestraße 42";
18:         String city = "Irgendeinestadt";
19:         ZipCodeType plz = instantiateZipCode( "12345" );
20: 
21:         // when
22:         AddressType instance = instantiateAddress( street, city, plz );
23: 
24:         // then
25:         assertEquals( street, instance.getStreet() );
26:         assertEquals( city, instance.getCity() );
27:         assertEquals( plz, instance.getZipCode() );
28:     }
29: 
30:     @Test
31:     public void testFactoryValidAddress() {
32:         // given
33:         String street = "Irgendeinestraße 42";
34:         String city = "Irgendeinestadt";
35:         ZipCodeType plz = instantiateZipCode( "12345" );
36: 
37:         // when
38:         // then
39:         assertDoesNotThrow( () -> instantiateAddress( street, city, plz ) );
40:     }
41: 
42:     @Test
43:     public void testFactoryInvalidAddress() {
44:         // given
45:         String street = "Irgendeinestraße 42";
46:         String city = "Irgendeinestadt";
47:         ZipCodeType plz = instantiateZipCode( "12345" );
48: 
49:         // when
50:         // then
51:         assertThrows( ShopException.class, () -> instantiateAddress( null, city, plz ) );
52:         assertThrows( ShopException.class, () -> instantiateAddress( "", city, plz ) );
53:         assertThrows( ShopException.class, () -> instantiateAddress( street, null, plz ) );
54:         assertThrows( ShopException.class, () -> instantiateAddress( street, "", plz ) );
55:         assertThrows( ShopException.class, () -> instantiateAddress( street, city, null ) );
56:     }
57: 
58:     @Test
59:     public void testEqualityAddress() {
60:         // given
61:         String street = "Irgendeinestraße 42";
62:         String city = "Irgendeinestadt";
63:         ZipCodeType plz = instantiateZipCode( "12345" );
64: 
65:         // when
66:         AddressType instance1 = instantiateAddress( street, city, plz );
67:         AddressType instance2 = instantiateAddress( street, city, plz );
68:         AddressType instance3 = instantiateAddress( "Anderestr. 12", city, plz );
69:         AddressType instance4 = instantiateAddress( street, "AndereStadt", plz );
70:         AddressType instance5 = instantiateAddress( street, city, instantiateZipCode( "54321" ) );
71: 
72:         // then
73:         assertEquals( instance1, instance2 );
74:         assertNotEquals( instance1, instance3 );
75:         assertNotEquals( instance1, instance4 );
76:         assertNotEquals( instance1, instance5 );
77:     }
78: 
79:     @Test
80:     public void testImmutabilityAddress() {
81:         // given
82:         String street = "Irgendeinestraße 42";
83:         String city = "Irgendeinestadt";
84:         ZipCodeType plz = instantiateZipCode( "12345" );
85: 
86:         // when
87:         AddressType instance = instantiateAddress( street, city, plz );
88: 
89:         // then
90:         try {
91:             instance.getClass().getMethod( "setStreet", String.class );
92:             fail( "setStreet method should not exist" );
93:         } catch (NoSuchMethodException e) {
94:             // Success: the object is immutable
95:         }
96:         try {
97:             instance.getClass().getMethod( "setCity", String.class );
98:             fail( "setCity method should not exist" );
99: 
100:         } catch (NoSuchMethodException e) {
101:             // Success: the object is immutable
102:         }
103:         try {
104:             instance.getClass().getMethod( "setZipCode", ZipCodeType.class );
105:             fail( "setZipCode method should not exist" );
106:         } catch (NoSuchMethodException e) {
107:             // Success: the object is immutable
108:         }
109:     }
110: }
111: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\CurrencyTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateCurrency;
9: 
10: class CurrencyTest {
11: 
12:     @Test
13:     public void testGetQuantityCurrency() {
14:         // given
15:         Float inputQuantity = 10.0f;
16: 
17:         // when
18:         CurrencyType instance = instantiateCurrency( inputQuantity, "EUR" );
19: 
20:         // then
21:         assertEquals( inputQuantity, instance.getQuantity() );
22:     }
23: 
24:     @Test
25:     public void testGetCurrencyUnitCurrency() {
26:         // given
27:         String inputCurrencyUnit = "EUR";
28: 
29:         // when
30:         CurrencyType instance = instantiateCurrency( 10.0f, inputCurrencyUnit );
31: 
32:         // then
33:         assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
34:     }
35: 
36:     @Test
37:     public void testAddToCurrency() {
38:         // given
39:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
40:         CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
41:         CurrencyType instance3 = instantiateCurrency( 0.0f, "EUR" );
42: 
43:         // when
44:         CurrencyType result12 = instance1.add( instance2 );
45:         CurrencyType result13 = instance1.add( instance3 );
46: 
47:         // then
48:         assertEquals( 30.0f, result12.getQuantity() );
49:         assertEquals( "EUR", result12.getCurrencyUnit() );
50:         assertEquals( 10.0f, result13.getQuantity() );
51:         assertEquals( "EUR", result12.getCurrencyUnit() );
52:     }
53: 
54:     @Test
55:     public void testInvalidAddToCurrency() {
56:         // given
57:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
58:         CurrencyType instance2 = instantiateCurrency( 20.0f, "CHF" );
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
63:     }
64: 
65:     @Test
66:     public void testSubtractFromCurrency() {
67:         // given
68:         CurrencyType instance1 = instantiateCurrency( 30.0f, "EUR" );
69:         CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
70:         CurrencyType instance3 = instantiateCurrency( 0.0f, "EUR" );
71:         CurrencyType instance4 = instantiateCurrency( 30.0f, "EUR" );
72: 
73:         // when
74:         CurrencyType result12 = instance1.subtract( instance2 );
75:         CurrencyType result13 = instance1.subtract( instance3 );
76:         CurrencyType result14 = instance1.subtract( instance4 );
77: 
78:         // then
79:         assertEquals( 10.0f, result12.getQuantity() );
80:         assertEquals( "EUR", result12.getCurrencyUnit() );
81:         assertEquals( 30.0f, result13.getQuantity() );
82:         assertEquals( "EUR", result13.getCurrencyUnit() );
83:         assertEquals( 0.0f, result14.getQuantity() );
84:         assertEquals( "EUR", result14.getCurrencyUnit() );
85:     }
86: 
87:     @Test
88:     public void testInvalidSubtractFromCurrency() {
89:         // given
90:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
91:         CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
92:         CurrencyType instance3 = instantiateCurrency( 5.0f, "CHF" );
93: 
94:         // when
95:         // then
96:         assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
97:         assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
98:     }
99: 
100:     @Test
101:     public void testMultiplyByCurrency() {
102:         // given
103:         CurrencyType instance = instantiateCurrency( 10.0f, "EUR" );
104: 
105:         // when
106:         CurrencyType result = instance.multiplyBy( 3 );
107: 
108:         // then
109:         assertEquals( 30.0f, result.getQuantity() );
110:         assertEquals( "EUR", result.getCurrencyUnit() );
111:     }
112: 
113:     @Test
114:     public void testFactoryValidCurrencyUnitCurrency() {
115:         // given
116:         // when
117:         // then
118:         assertDoesNotThrow( () -> instantiateCurrency( 10.0f, "EUR" ) );
119:     }
120: 
121:     @Test
122:     public void testFactoryInvalidCurrencyUnitCurrency() {
123:         // given
124:         // when
125:         // then
126:         assertThrows( ShopException.class, () -> instantiateCurrency( -10.0f, "EUR" ) );
127:         assertThrows( ShopException.class, () -> instantiateCurrency( 10.0f, "USD" ) );
128:         assertThrows( ShopException.class, () -> instantiateCurrency( null, "EUR" ) );
129:         assertThrows( ShopException.class, () -> instantiateCurrency( 10.0f, null ) );
130:     }
131: 
132:     @Test
133:     public void testLargerThanCurrencyUnitCurrency() {
134:         // given
135:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
136:         CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
137:         CurrencyType instance3 = instantiateCurrency( 10.0f, "EUR" );
138:         CurrencyType instance4 = instantiateCurrency( 10.0f, "CHF" );
139: 
140:         // when
141:         // then
142:         assertTrue( instance2.largerThan( instance1 ) );
143:         assertFalse( instance1.largerThan( instance2 ) );
144:         assertFalse( instance1.largerThan( instance3 ) );
145:         assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
146:     }
147: 
148: 
149:     @Test
150:     public void testEqualityCurrencyUnitCurrency() {
151:         // given
152:         // when
153:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
154:         CurrencyType instance2 = instantiateCurrency( 10.0f, "EUR" );
155:         CurrencyType instance3 = instantiateCurrency( 20.0f, "EUR" );
156: 
157:         // then
158:         assertEquals( instance1, instance2 );
159:         assertNotEquals( instance1, instance3 );
160:     }
161: 
162:     @Test
163:     public void testImmutabilityCurrencyUnitCurrency() {
164:         // given
165:         // when
166:         CurrencyType instance = instantiateCurrency( 10.0f, "EUR" );
167: 
168:         // then
169:         try {
170:             instance.getClass().getMethod( "setQuantity", Float.class );
171:             fail( "setQuantity method should not exist" );
172:         } catch (NoSuchMethodException e) {
173:             // Success: the object is immutable
174:         }
175: 
176:         try {
177:             instance.getClass().getMethod( "setCurrencyUnit", String.class );
178:             fail( "setCurrencyUnit method should not exist" );
179:         } catch (NoSuchMethodException e) {
180:             // Success: the object is immutable
181:         }
182:     }
183: }
184: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("domainPrimitivesUsageRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class DomainPrimitivesUsageRulesTest {
14:     private static final String EMAIL_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Email";
15:     private static final String CURRENCY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Currency";
16:     private static final String ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Address";
17: 
18:     @ArchTest
19:     static final ArchRule userShouldReferenceEmail =
20:             classes()
21:                     .that().haveSimpleName( "User" )
22:                     .should().dependOnClassesThat().haveFullyQualifiedName( EMAIL_CLASS )
23:                     .because( "User should use Email instead of String" );
24: 
25:     @ArchTest
26:     static final ArchRule userShouldReferenceAddress =
27:             classes()
28:                     .that().haveSimpleName( "User" )
29:                     .should().dependOnClassesThat().haveFullyQualifiedName( ADDRESS_CLASS )
30:                     .because( "User should use Address instead of whatever else" );
31: 
32:     @ArchTest
33:     static final ArchRule storageUnitShouldReferenceAddress =
34:             classes()
35:                     .that().haveSimpleName( "StorageUnit" )
36:                     .should().dependOnClassesThat().haveFullyQualifiedName( ADDRESS_CLASS )
37:                     .because( "User should use Address instead of whatever else" );
38: 
39:     @ArchTest
40:     static final ArchRule itemShouldReferenceCurrency =
41:             classes()
42:                     .that().haveSimpleName( "Item" )
43:                     .should().dependOnClassesThat().haveFullyQualifiedName( CURRENCY_CLASS )
44:                     .because( "Item should use Currency instead of float or whatever else" );
45: }
46: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\EmailTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmail;
10: 
11: class EmailTest {
12: 
13:     @Test
14:     public void testToStringEmail() {
15:         // given
16:         String input = "test@example.com";
17: 
18:         // when
19:         EmailType instance = instantiateEmail( input );
20: 
21:         // then
22:         assertEquals( input, instance.toString() );
23:     }
24: 
25:     @Test
26:     public void testEqualityEmail() {
27:         // given
28:         // when
29:         EmailType instance1 = instantiateEmail( "test@example.com" );
30:         EmailType instance2 = instantiateEmail( "test@example.com" );
31:         EmailType instance3 = instantiateEmail( "different@example.com" );
32: 
33:         // then
34:         assertEquals( instance1, instance2 );
35:         assertNotEquals( instance1, instance3 );
36:     }
37: 
38:     @Test
39:     public void testImmutabilityEmail() {
40:         // given
41:         // when
42:         EmailType instance = instantiateEmail( "test@example.com" );
43: 
44:         // then
45:         try {
46:             instance.getClass().getMethod( "setEmail", String.class );
47:             fail( "setEmail method should not exist" );
48:         } catch (NoSuchMethodException e) {
49:             // Success: the object is immutable
50:         }
51:     }
52: 
53: 
54: 
55:     @Test
56:     public void smokeTestForCopyConstructors() {
57:         // given
58:         EmailType email =
59:                 instantiateEmail( "peter.schmidt@web.de" );
60: 
61:         // when
62:         EmailType emailOtherIdentifyer =
63:                 email.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
64:         assertThrows( ShopException.class, () ->
65:                 email.sameDomainDifferentIdentifyer( "p...eter" ) );
66:         EmailType emailOtherDomain =
67:                 email.sameIdentifyerDifferentDomain( "web.ch" );
68:         assertThrows( ShopException.class, () ->
69:                 email.sameIdentifyerDifferentDomain( "web.edu" ) );
70: 
71:         // then
72:         assertEquals( "p.e.t.e.r@web.de", emailOtherIdentifyer.toString() );
73:         assertEquals( "peter.schmidt@web.ch", emailOtherDomain.toString() );
74:     }
75: 
76: 
77:     @Test
78:     public void testFactoryValidEmail() {
79:         // given
80:         // when
81:         // then
82:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.com" ) );
83:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "99Z@example.com" ) );
84:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "GGGhh@s77.com" ) );
85:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "a@4.com" ) );
86:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "Max.Hammer@example.com" ) );
87:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "Max.Gideon.Hammer@example.com" ) );
88:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.this.com" ) );
89:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.de" ) );
90:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.at" ) );
91:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.ch" ) );
92:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.org" ) );
93:     }
94: 
95: 
96:     @Test
97:     public void testFactoryInvalidEmail() {
98:         // given
99:         // when
100:         // then
101:         assertThrows( ShopException.class, () -> instantiateEmail( null ) );
102:         assertThrows( ShopException.class, () -> instantiateEmail( "testexample.com" ) );
103:         assertThrows( ShopException.class, () -> instantiateEmail( "test@" ) );
104:         assertThrows( ShopException.class, () -> instantiateEmail( "@example.com" ) );
105:         assertThrows( ShopException.class, () -> instantiateEmail( "Max..Gideon.Hammer@example.com" ) );
106:         assertThrows( ShopException.class, () -> instantiateEmail( "test@examplecom" ) );
107:         assertThrows( ShopException.class, () -> instantiateEmail( "test@example..com" ) );
108:         assertThrows( ShopException.class, () -> instantiateEmail( "test@example@that.com" ) );
109:         assertThrows( ShopException.class, () -> instantiateEmail( "test example@that.com" ) );
110:         assertThrows( ShopException.class, () -> instantiateEmail( "test#example@that.com" ) );
111:         assertThrows( ShopException.class, () -> instantiateEmail( "test@example.biz" ) );
112:         assertThrows( ShopException.class, () -> instantiateEmail( "test@example.biz" ) );
113:         assertThrows( ShopException.class, () -> instantiateEmail( "test@example.42" ) );
114:     }
115: }
116: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\ZipCodeTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
8: 
9: import static org.junit.jupiter.api.Assertions.*;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
11: 
12: class ZipCodeTest {
13: 
14:     private String input1, input4;
15:     private ZipCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
16:             _04233, _02544, _99123, _56323, _79332;
17: 
18: 
19:     @BeforeEach
20:     public void setUp() {
21:         input1 = "12345";
22:         input4 = "49188";
23:         _12345 = FactoryMethodInvoker.instantiateZipCode( "12345" );
24:         _12345b = FactoryMethodInvoker.instantiateZipCode( "12345" );
25:         _23455 = FactoryMethodInvoker.instantiateZipCode( "23455" );
26:         _01234 = FactoryMethodInvoker.instantiateZipCode( "01234" );
27:         _01235 = FactoryMethodInvoker.instantiateZipCode( "01235" );
28:         _01238 = FactoryMethodInvoker.instantiateZipCode( "01238" );
29:         _01263 = FactoryMethodInvoker.instantiateZipCode( "01263" );
30:         _01213 = FactoryMethodInvoker.instantiateZipCode( "01213" );
31:         _01823 = FactoryMethodInvoker.instantiateZipCode( "01823" );
32:         _01312 = FactoryMethodInvoker.instantiateZipCode( "01312" );
33:         _04233 = FactoryMethodInvoker.instantiateZipCode( "04233" );
34:         _02544 = FactoryMethodInvoker.instantiateZipCode( "02544" );
35:         _99123 = FactoryMethodInvoker.instantiateZipCode( "99123" );
36:         _56323 = FactoryMethodInvoker.instantiateZipCode( "56323" );
37:         _79332 = FactoryMethodInvoker.instantiateZipCode( "79332" );
38: 
39:     }
40: 
41: 
42:     @Test
43:     public void testToStringZipCode() {
44:         // given
45:         // when
46:         ZipCodeType instance = instantiateZipCode( input1 );
47: 
48:         // then
49:         assertEquals( input1, instance.toString() );
50:     }
51: 
52:     @Test
53:     public void testFactoryValidZipCode() {
54:         // given
55:         // when
56:         // then
57:         assertDoesNotThrow( () -> instantiateZipCode( input1 ) );
58:     }
59: 
60:     @Test
61:     public void testFactoryInvalidZipCode() {
62:         // given
63:         // when
64:         // then
65:         assertThrows( ShopException.class, () -> instantiateZipCode( "123456" ) );
66:         assertThrows( ShopException.class, () -> instantiateZipCode( "1234" ) );
67:         assertThrows( ShopException.class, () -> instantiateZipCode( "20000" ) );
68:         assertThrows( ShopException.class, () -> instantiateZipCode( null ) );
69:     }
70: 
71:     @Test
72:     public void testEqualityZipCode() {
73:         // given
74:         // when
75:         ZipCodeType instance1a = instantiateZipCode( input1 );
76:         ZipCodeType instance1b = instantiateZipCode( input1 );
77:         ZipCodeType instance4 = instantiateZipCode( input4 );
78: 
79:         // then
80:         assertEquals( instance1a, instance1b );
81:         assertNotEquals( instance1a, instance4 );
82:     }
83: 
84:     @Test
85:     public void testImmutabilityZipCode() {
86:         // given
87:         // when
88:         ZipCodeType instance = instantiateZipCode( input1 );
89: 
90:         // then
91:         try {
92:             instance.getClass().getMethod( "setzipCode", String.class );
93:             fail( "setzipCode method should not exist" );
94:         } catch (NoSuchMethodException e) {
95:             // Success: the object is immutable
96:         }
97:     }
98: 
99: 
100:     @Test
101:     public void smokeTestForDifference() {
102:         // given
103:         ZipCodeType instance1a = instantiateZipCode( input1 );
104:         ZipCodeType instance1b = instantiateZipCode( input1 );
105:         ZipCodeType instance12479 = instantiateZipCode( "12479" );
106:         ZipCodeType instance21456 = instantiateZipCode( "21456" );
107: 
108:         // when
109:         int differenceAB = instance1a.difference( instance1b );
110:         int difference12 = instance1a.difference( instance12479 );
111:         int difference23 = instance12479.difference( instance21456 );
112: 
113:         // then
114:         assertEquals( 0, differenceAB );
115:         assertTrue( difference12 > 0 );
116:         assertTrue( difference23 > difference12 );
117:     }
118: 
119: 
120:     @Test
121:     public void testZipCodeFirstDigit() {
122:         // given
123:         ZipCodeType instance1 = instantiateZipCode( input1 );
124:         ZipCodeType instance4 = instantiateZipCode( input4 );
125: 
126:         // when
127:         // then
128:         assertEquals( 1, instance1.getFirstDigitZipCode() );
129:         assertEquals( 4, instance4.getFirstDigitZipCode() );
130:     }
131: 
132: 
133: 
134:     @Test
135:     public void testInvalidParameters() {
136:         // given
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 _12345.difference( null ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testSameZipCode() {
146:         // given
147:         // when
148:         int diff = _12345.difference( _12345b );
149: 
150:         // then
151:         assertEquals( 0, diff );
152:     }
153: 
154: 
155:     /**
156:      *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
157:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
158:      *        So, 56733 and 56734 have the same difference as 56733 and 56739.
159:      *      - The difference grows if more digits (counted from the right side) differ.
160:      *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
161:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
162:      *        53876 and 54876 have the same difference as 53876 and 57261.
163:      */
164:     @Test
165:     public void testZipCodeDifferenceInAllButFirstDigit() {
166:         // given
167:         // when
168:         int diff5a = _01234.difference( _01235 );
169:         int diff5b = _01234.difference( _01238 );
170:         int diff4a = _01234.difference( _01263 );
171:         int diff4b = _01234.difference( _01213 );
172:         int diff3a = _01234.difference( _01823 );
173:         int diff3b = _01234.difference( _01312 );
174:         int diff2a = _01234.difference( _04233 );
175:         int diff2b = _01234.difference( _02544 );
176: 
177:         // then
178:         assertEquals( diff5a, diff5b, "difference 01234-01235 must be the same as difference 01234-01238" );
179:         assertEquals( diff4a, diff4b, "difference 01234-01263 must be the same as difference 01234-01213" );
180:         assertEquals( diff3a, diff3b, "difference 01234-01823 must be the same as difference 01234-01312" );
181:         assertEquals( diff2a, diff2b, "difference 01234-04233 must be the same as difference 01234-02544" );
182: 
183:         assertTrue( diff5a < diff4a,
184:                 "difference 01234-01235 must be smaller than difference 01234-01263" );
185:         assertTrue( diff4a < diff3a,
186:                 "difference 01234-01263 must be smaller than difference 01234-01823" );
187:         assertTrue( diff3a < diff2a,
188:                 "difference 01234-01823 must be smaller than difference 01234-04233" );
189:     }
190: 
191: 
192:     /**
193:      *      - However, the difference between 5abcd and 6rstu must be smaller than the one
194:      *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
195:      *        one between 5abcd and 9rstu.
196:      *      - This last condition reflects the fact the first digits of a zip code marks a region
197:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
198:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
199:      *        other.
200:      */
201:     @Test
202:     public void testZipCodedifferenceInFirstDigit() {
203:         // given
204:         // when
205:         int diff1_1 = _01234.difference( _99123 );
206:         int diff1_2 = _01234.difference( _23455 );
207:         int diff1_5 = _01234.difference( _56323 );
208:         int diff1_3 = _01234.difference( _79332 );
209: 
210:         // then
211:         assertTrue( diff1_1 < diff1_2,
212:                 "difference 01234-99123 must be smaller than difference 01234-23455"  );
213:         assertTrue( diff1_2 < diff1_3,
214:                 "difference 01234-23455 must be smaller than difference 01234-79332" );
215:         assertTrue( diff1_3 < diff1_5,
216:                 "difference 01234-79332 must be smaller than difference 01234-56323"  );
217:     }
218: 
219: 
220: 
221: }
222: 
223: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
1: package thkoeln.archilab.ecommerce.tests.e1restcalls;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;
5: 
6: 
7: public class E1RestCallTableTest {
8: 
9:     private GenericTableSpecificationTests genericTableSpecificationTests = null;
10: 
11: 
12:     public E1RestCallTableTest() {
13:         this.genericTableSpecificationTests = new GenericTableSpecificationTests();
14:     }
15: 
16:     @Test
17:     public void restTest() throws Exception {
18:         genericTableSpecificationTests.testTableSpecification("E1" );
19:     }
20: }
21: 
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\item\ItemCatalogTest.java ---
1: package thkoeln.archilab.ecommerce.tests.item;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
9: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
14: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
15: 
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.*;
19: 
20: 
21: @SpringBootTest
22: public class ItemCatalogTest {
23:     @Autowired
24:     private UserRegistrationUseCases userRegistrationUseCases;
25:     @Autowired
26:     private ShoppingCartUseCases shoppingCartUseCases;
27:     @Autowired
28:     private ItemCatalogUseCases itemCatalogUseCases;
29:     @Autowired
30:     private StorageUnitUseCases storageUnitUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private UserTestHelper userTestHelper;
35:     @Autowired
36:     private ItemTestHelper itemTestHelper;
37:     @Autowired
38:     private StorageUnitTestHelper storageUnitTestHelper;
39: 
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         userTestHelper.registerAllUsers();
45:         itemTestHelper.addAllItems();
46:     }
47: 
48: 
49:     @Test
50:     public void testAddItemToCatalog() {
51:         // given
52:         UUID itemId4 = itemTestHelper.getItemId( 4 );
53:         CurrencyType sellingPrice4 = itemTestHelper.getSellingPrice( 4 );
54: 
55:         // when
56:         CurrencyType foundSellingPrice = itemCatalogUseCases.getSellingPrice( itemId4 );
57: 
58:         // then
59:         assertEquals( sellingPrice4, foundSellingPrice );
60:     }
61: 
62: 
63:     @Test
64:     public void testAddItemWithInvalidData() {
65:         // given
66:         String name = "SomeStuff";
67:         String description = "Some more explanation on the stuff";
68:         Float size = 5.0f;
69:         CurrencyType buyingPrice =
70:                 FactoryMethodInvoker.instantiateCurrency( 5.0f, "EUR" );
71:         CurrencyType sellingPrice =
72:                 FactoryMethodInvoker.instantiateCurrency( 10.0f, "EUR" );
73:         CurrencyType tooLowSellingPrice =
74:                 FactoryMethodInvoker.instantiateCurrency( 4.0f, "EUR" );
75: 
76:         // when / then
77:         assertThrows( ShopException.class, () ->
78:                 itemCatalogUseCases.addItemToCatalog(
79:                         null, description, size, buyingPrice, sellingPrice ) );
80:         assertThrows( ShopException.class, () ->
81:                 itemCatalogUseCases.addItemToCatalog(
82:                         "", description, size, buyingPrice, sellingPrice ) );
83:         assertThrows( ShopException.class, () ->
84:                 itemCatalogUseCases.addItemToCatalog(
85:                         name, null, size, buyingPrice, sellingPrice ) );
86:         assertThrows( ShopException.class, () ->
87:                 itemCatalogUseCases.addItemToCatalog(
88:                         name, "", size, buyingPrice, sellingPrice ) );
89:         assertThrows( ShopException.class, () ->
90:                 itemCatalogUseCases.addItemToCatalog(
91:                         name, description, size, null, sellingPrice ) );
92:         assertThrows( ShopException.class, () ->
93:                 itemCatalogUseCases.addItemToCatalog(
94:                         name, description, size, buyingPrice, null ) );
95:         assertThrows( ShopException.class, () ->
96:                 itemCatalogUseCases.addItemToCatalog(
97:                         name, description, size, buyingPrice, tooLowSellingPrice ) );
98:     }
99: 
100: 
101:     @Test
102:     public void testRemoveNonExistentItem() {
103:         // given item 2 is not in inventory anywhere - should be removable
104:         UUID nonExistentItemId = UUID.randomUUID();
105: 
106:         // when
107:         // then
108:         assertThrows( ShopException.class,
109:                 () -> itemCatalogUseCases.removeItemFromCatalog( nonExistentItemId ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testRemoveItemWithNoInventory() {
115:         // given item 0 is not in inventory anywhere - should be removable
116:         UUID itemId0 = itemTestHelper.getItemId( 0 );
117:         storageUnitTestHelper.addAllStorageUnits( true );
118: 
119:         // when
120:         assertDoesNotThrow( () -> itemCatalogUseCases.getSellingPrice( itemId0 ) );
121:         itemCatalogUseCases.removeItemFromCatalog( itemId0 );
122: 
123:         // then
124:         assertThrows( ShopException.class, () ->
125:                 itemCatalogUseCases.getSellingPrice( itemId0 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testRemoveItemThatIsInInventory() {
131:         // given
132:         storageUnitTestHelper.addAllStorageUnits( false );
133:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
134:         UUID itemId3 = itemTestHelper.getItemId( 3 );
135:         UUID itemId4 = itemTestHelper.getItemId( 4 );
136:         storageUnitUseCases.addToInventory( storageUnitId0, itemId3, 3 );
137: 
138:         // then item 3 must not be removable, but item 4 must be removable
139:         assertThrows( ShopException.class,
140:                 () -> itemCatalogUseCases.removeItemFromCatalog( itemId3 ) );
141:         assertDoesNotThrow( () -> itemCatalogUseCases.removeItemFromCatalog( itemId4 ) );
142:     }
143: 
144: 
145:     @Test
146:     public void testRemoveItemThatIsInOrder() {
147:         // given
148:         storageUnitTestHelper.addAllStorageUnits( false );
149:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
150:         UUID itemId4 = itemTestHelper.getItemId( 4 );
151:         EmailType userEmail4 =
152:                 userTestHelper.getUserEmail( 4 );
153:         storageUnitUseCases.addToInventory( storageUnitId0, itemId4, 4 );
154: 
155:         // when user 4 adds 4x item 4 to his shopping cart and checks out ...
156:         shoppingCartUseCases.addItemToShoppingCart(
157:                 userEmail4, itemId4, 4 );
158:         shoppingCartUseCases.checkout( userEmail4 );
159: 
160:         // then item 4 must not be removable
161:         assertThrows( ShopException.class,
162:                 () -> itemCatalogUseCases.removeItemFromCatalog( itemId4 ) );
163:     }
164: 
165: 
166:     @Test
167:     public void testClearItemCatalog() {
168:         // given
169:         UUID itemId4 = itemTestHelper.getItemId( 4 );
170: 
171:         // when
172:         itemCatalogUseCases.deleteItemCatalog();
173: 
174:         // then
175:         assertThrows( ShopException.class, () -> itemCatalogUseCases.getSellingPrice( itemId4 ) );
176:     }
177: 
178: }
179: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\order\OrderTest.java ---
1: package thkoeln.archilab.ecommerce.tests.order;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
14: 
15: import java.util.Map;
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.assertEquals;
19: import static org.junit.jupiter.api.Assertions.assertThrows;
20: 
21: 
22: @SpringBootTest
23: public class OrderTest {
24:     @Autowired
25:     private UserRegistrationUseCases userRegistrationUseCases;
26:     @Autowired
27:     private ShoppingCartUseCases shoppingCartUseCases;
28:     @Autowired
29:     private ItemCatalogUseCases itemCatalogUseCases;
30:     @Autowired
31:     private StorageUnitUseCases storageUnitUseCases;
32:     @Autowired
33:     private OrderUseCases orderUseCases;
34:     @Autowired
35:     private Purgatory purgatory;
36:     @Autowired
37:     private UserTestHelper userTestHelper;
38:     @Autowired
39:     private ItemTestHelper itemTestHelper;
40:     @Autowired
41:     private StorageUnitTestHelper storageUnitTestHelper;
42: 
43:     private UUID nonExistingId1;
44:     private UUID nonExistingId2;
45: 
46:     @BeforeEach
47:     public void setUp() {
48:         purgatory.deleteEverything();
49:         userTestHelper.registerAllUsers();
50:         itemTestHelper.addAllItems();
51:         storageUnitTestHelper.addAllStorageUnits( true );
52:         nonExistingId1 = UUID.randomUUID();
53:         nonExistingId2 = UUID.randomUUID();
54:     }
55: 
56: 
57:     @Test
58:     public void testOrderHistory() {
59:         // given
60:         UUID itemId1 = itemTestHelper.getItemId( 1 );
61:         UUID itemId2 = itemTestHelper.getItemId( 2 );
62:         EmailType userEmail7 =
63:                 userTestHelper.getUserEmail( 7 );
64:         Map<UUID, Integer> orderHistoryBefore = orderUseCases.getOrderHistory( userEmail7 );
65: 
66:         // when
67:         shoppingCartUseCases.addItemToShoppingCart(
68:                 userEmail7, itemId1, 3 );
69:         shoppingCartUseCases.addItemToShoppingCart(
70:                 userEmail7, itemId2, 2 );
71:         shoppingCartUseCases.checkout( userEmail7 );
72:         Map<UUID, Integer> orderHistory1 =
73:                 orderUseCases.getOrderHistory( userEmail7 );
74:         shoppingCartUseCases.addItemToShoppingCart(
75:                 userEmail7, itemId1, 6 );
76:         shoppingCartUseCases.addItemToShoppingCart(
77:                 userEmail7, itemId2, 2 );
78:         shoppingCartUseCases.checkout( userEmail7 );
79:         Map<UUID, Integer> orderHistory2 =
80:                 orderUseCases.getOrderHistory( userEmail7 );
81:         shoppingCartUseCases.addItemToShoppingCart(
82:                 userEmail7, itemId1, 1 );
83:         shoppingCartUseCases.addItemToShoppingCart(
84:                 userEmail7, itemId2, 6 );
85:         shoppingCartUseCases.checkout( userEmail7 );
86:         Map<UUID, Integer> orderHistory3 =
87:                 orderUseCases.getOrderHistory( userEmail7 );
88: 
89:         // then
90:         assertEquals( 0, orderHistoryBefore.size() );
91:         assertEquals( 2, orderHistory1.size() );
92:         assertEquals( 2, orderHistory2.size() );
93:         assertEquals( 2, orderHistory3.size() );
94:         assertEquals( 3, orderHistory1.get( itemId1 ) );
95:         assertEquals( 2, orderHistory1.get( itemId2 ) );
96:         assertEquals( 9, orderHistory2.get( itemId1 ) );
97:         assertEquals( 4, orderHistory2.get( itemId2 ) );
98:         assertEquals( 10, orderHistory3.get( itemId1 ) );
99:         assertEquals( 10, orderHistory3.get( itemId2 ) );
100:     }
101: 
102: 
103:     @Test
104:     public void testForEmptyOrderHistory() {
105:         // given
106:         EmailType userEmail4 =
107:                 userTestHelper.getUserEmail( 4 );
108:         // when
109:         Map<UUID, Integer> orderHistory =
110:                 orderUseCases.getOrderHistory( userEmail4 );
111:         // then
112:         assertEquals( 0, orderHistory.size() );
113:     }
114: 
115: 
116:     @Test
117:     public void testInvalidParamsForGetOrderQuantityOfItem() {
118:         // given
119:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
120: 
121:         // when / then
122:         assertThrows ( ShopException.class,
123:                 () -> orderUseCases.getOrderQuantityOfItem( null, null ) );
124:         assertThrows ( ShopException.class,
125:                 () -> orderUseCases.getOrderQuantityOfItem( nonExistingId1, null ) );
126:         assertThrows ( ShopException.class,
127:                 () -> orderUseCases.getOrderQuantityOfItem( null, nonExistingId2 ) );
128:         assertThrows ( ShopException.class,
129:                 () -> orderUseCases.getOrderQuantityOfItem( nonExistingId1, nonExistingId2 ) );
130:         assertThrows ( ShopException.class,
131:                 () -> orderUseCases.getOrderQuantityOfItem( storageUnitId0, null ) );
132:         assertThrows ( ShopException.class,
133:                 () -> orderUseCases.getOrderQuantityOfItem( storageUnitId0, nonExistingId2 ) );
134:     }
135: 
136: 
137:     @Test
138:     public void testInvalidParamsForGetStorageUnitIdForOrder() {
139:         // given / when / then
140:         assertThrows ( ShopException.class,
141:                 () -> orderUseCases.getStorageUnitIdForOrder( null ) );
142:         assertThrows ( ShopException.class,
143:                 () -> orderUseCases.getStorageUnitIdForOrder( nonExistingId1 ) );
144:     }
145: }
146: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import com.fasterxml.jackson.databind.ObjectMapper;
4: import com.jayway.jsonpath.JsonPath;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: import thkoeln.archilab.ecommerce.domainprimitives.Address;
8: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
9: import thkoeln.archilab.ecommerce.domainprimitives.Email;
10: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
11: 
12: import static org.junit.jupiter.api.Assertions.assertEquals;
13: 
14: 
15: public class DomainPrimitiveJSONSerializationTest {
16: 
17: 
18: 
19:     @BeforeEach
20:     public void setUp() {
21:         // ... add own setup code here
22: 
23:     }
24: 
25: 
26:     /**
27:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
28:      * Email.
29:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
30:      * on how to implement this test, and how to change property names.
31:      * @throws Exception
32:      */
33:     @Test
34:     public void test_Email_Serialization() throws Exception {
35:         // given
36:         ObjectMapper objectMapper = new ObjectMapper();
37:         Email email = (Email) Email.of("hallo@example.com");
38:         // when
39:         String json = objectMapper.writeValueAsString(email);
40:         // then
41:         String emailString = JsonPath.read(json, "$.emailString");
42:         assertEquals("hallo@example.com", emailString);
43:     }
44: 
45: 
46:     /**
47:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
48:      * ZipCode.
49:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
50:      * on how to implement this test, and how to change property names.
51:      * @throws Exception
52:      */
53:     @Test
54:     public void test_ZipCode_Serialization() throws Exception {
55: 
56:         // given
57:         ObjectMapper objectMapper = new ObjectMapper();
58:         ZipCode zipCode = (ZipCode) ZipCode.of("51545");
59: 
60:         // when
61:         String json = objectMapper.writeValueAsString(zipCode);
62:         // then
63:         String zipCodeString = JsonPath.read(json, "$.zipCodeString");
64:         assertEquals("51545", zipCodeString, "zipCode test failed");
65:     }
66: 
67: 
68:     /**
69:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
70:      * Address.
71:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
72:      * on how to implement this test, and how to change property names.
73:      * @throws Exception
74:      */
75:     @Test
76:     public void test_Address_Serialization() throws Exception {
77:         ObjectMapper objectMapper = new ObjectMapper();
78:         ZipCode zipCode = (ZipCode) ZipCode.of("51545");
79:         String street = "Buchenweg 11";
80:         String city = "Gummersbach";
81:         Address address = (Address) Address.of(street, city, zipCode );
82: 
83:         // when
84:         String json = objectMapper.writeValueAsString(address);
85:         // then
86:         String zipCodeString = JsonPath.read(json, "$.zipCode.zipCodeString");
87:         String streetString = JsonPath.read(json, "$.street");
88:         String cityString = JsonPath.read(json, "$.city");
89:         assertEquals("51545", zipCodeString, "zipCode test failed");
90:         assertEquals(city, cityString);
91:         assertEquals(street,streetString);
92:     }
93: 
94: 
95:     /**
96:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
97:      * Currency.
98:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
99:      * on how to implement this test, and how to change property names.
100:      * @throws Exception
101:      */
102:     @Test
103:     public void test_Currency_Serialization() throws Exception {
104:         // given
105:         ObjectMapper objectMapper = new ObjectMapper();
106:         Currency currency = (Currency) Currency.of(5f, "EUR");
107: 
108:         // when
109:         String json = objectMapper.writeValueAsString(currency);
110:         // then
111:         Double quantity = JsonPath.read(json, "$.quantity");
112:         String currenyUnitString = JsonPath.read(json, "$.currencyUnit");
113:         assertEquals(5f, quantity);
114:         assertEquals("EUR", currenyUnitString);
115:     }
116: 
117: }
118: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingCartRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import thkoeln.archilab.ecommerce.domainprimitives.Email;
11: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
12: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
13: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
14: import thkoeln.archilab.ecommerce.solution.shoppingcart.application.ShoppingCartService;
15: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
16: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
17: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
18: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
19: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
20: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
21: 
22: import java.util.Map;
23: import java.util.UUID;
24: 
25: import static org.junit.jupiter.api.Assertions.*;
26: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
27: 
28: 
29: @SpringBootTest
30: @Transactional
31: @AutoConfigureMockMvc
32: @Import( RESTTestHelperConfiguration.class )
33: public class OwnShoppingCartRESTTest {
34:     @Autowired
35:     private Purgatory purgatory;
36:     @Autowired
37:     private UserTestHelper userTestHelper;
38:     @Autowired
39:     private ItemTestHelper itemTestHelper;
40:     @Autowired
41:     private StorageUnitTestHelper storageUnitTestHelper;
42:     @Autowired
43:     private ShoppingCartUseCases shoppingCartUseCases;
44: 
45:     @Autowired
46:     private ShoppingCartRESTHelper shoppingCartRESTHelper;
47: 
48:     @Autowired
49:     private ShoppingCartService shoppingCartService;
50: 
51: 
52:     private Email email3;
53:     private String userName3;
54:     private UUID itemId2;
55:     private UUID itemId3;
56:     private ShoppingCart shoppingCart3;
57: 
58:     @BeforeEach
59:     public void setUp() {
60:         purgatory.deleteEverything();
61:         userTestHelper.registerAllUsers();
62:         itemTestHelper.addAllItems();
63:         storageUnitTestHelper.addAllStorageUnits( true );
64: 
65:         // ... add own setup code here
66:         email3 = (Email) userTestHelper.getUser(3).getEmail();
67:         userName3 = userTestHelper.getUser(3).getName();
68:         itemId2 = itemTestHelper.getItemId(2);
69:         itemId3 = itemTestHelper.getItemId(3);
70:     }
71: 
72: 
73:     /**
74:      * Provide a test that implements a simple call to the REST endpoint (3):
75:      * <pre>
76:      *     GET /shoppingCarts?userId=<user id as uuid>
77:      * </pre>
78:      * - Use the {@link UserTestHelper} to obtain the email
79:      *   of some example user.
80:      * - Use your shopping cart service to add entries to the shopping cart of that person.
81:      * - then use the `ShoppingCartRESTHelper` to create the GET call, and check the results.
82:      * - (or do it by directly calling your REST controller, if you prefer)
83:      * @ throws Exception
84:      */
85:     @Test
86:     public void test_getQuery_ShoppingCart() throws Exception {
87:         // given
88:         shoppingCartUseCases.addItemToShoppingCart(email3, itemId2, 2);
89:         Map<UUID, Integer> expectedMap = Map.of(itemId2, 2);
90:         // when
91:         shoppingCartRESTHelper.getQueryShoppingCart(email3, expectedMap);
92:         // then
93:     }
94: 
95: 
96: 
97:     /**
98:      * Provide a test that implements the addition of one item to the shopping cart via
99:      * REST endpoint (6):
100:      * <pre>
101:      *     POST /shoppingCarts/{shoppingCart-Id}/positions
102:      * </pre>
103:      * You can test now "the other way around" as in test_getQuery_ShoppingCart():
104:      * - Use `ShoppingCartRESTHelper` to add items via REST, then use shopping cart service methods
105:      *   to check of the shopping cart contains the right stuff.
106:      * - (or do it by directly calling your REST controller, if you prefer)*
107:      * @ throws Exception
108:      */
109:     @Test
110:     public void test_post_ShoppingCartPositions() throws Exception {
111:         // given
112:         Map<ItemId, Integer> expectedMap = Map.of(new ItemId(itemId2), 2, new ItemId(itemId3), 3);
113:         shoppingCartUseCases.addItemToShoppingCart(email3, itemId3, 3);
114: 
115:         // when
116:         shoppingCart3 = shoppingCartService.getShoppingCart(email3);
117: 
118:         shoppingCartRESTHelper.addItemToShoppingCart(shoppingCart3.getId().getId(), itemId2, 2);
119:         Map<ItemId, Integer> isMap = shoppingCartService.getShoppingCartAsMap(email3);
120:         // then
121:         assertEquals(2, isMap.size());
122:         assertEquals(expectedMap.entrySet(), isMap.entrySet());
123:     }
124: 
125: 
126: 
127:     /**
128:      * Provide a test that implements the deletion of one item in the shopping cart via
129:      * REST endpoint (10):
130:      * <pre>
131:      *     DELETE /shoppingCarts/{shoppingCart-Id}/positions/{item-Id}
132:      * </pre>
133:      * This should be just a slight variation of the test_post_ShoppingCartPositions()
134:      * method, but instead of adding an item to the shopping cart, you delete it.*
135:      * @ throws Exception
136:      */
137:     @Test
138:     public void test_delete_ShoppingCartPositions() throws Exception {
139:         //
140:         Map<ItemId, Integer> expectedMap = Map.of(new ItemId(itemId3), 3);
141:         shoppingCartService.addItemToShoppingCart(email3,new ItemId(itemId3), 3);
142:         shoppingCartService.addItemToShoppingCart(email3, new ItemId(itemId2), 2);
143: 
144:         // when
145:         shoppingCart3 = shoppingCartService.getShoppingCart(email3);
146: 
147:         shoppingCartRESTHelper.deleteItemFromShoppingCart(shoppingCart3.getId().getId(), itemId2);
148:         Map<ItemId, Integer> isMap = shoppingCartService.getShoppingCartAsMap(email3);
149: 
150:         // then
151:         assertEquals(1, isMap.size());
152:         assertEquals(expectedMap.entrySet(), isMap.entrySet());
153:     }
154: 
155: 
156: 
157:     /**
158:      * Provide a test that implements the checkout of a shopping cart that can be served
159:      * by just 1 storage unit, using the REST endpoint (11):
160:      * <pre>
161:      *     POST /shoppingCarts/{shoppingCart-Id}/checkout
162:      * </pre>
163:      * - Use your shopping cart service to add entries to the shopping cart of some example user,
164:      * - then use the `ShoppingCartRESTHelper to post the checkout call, and to check the results.
165:      * - (or do it by directly calling your REST controller, if you prefer)*
166:      * @ throws Exception
167:      */
168:     @Test
169:     public void test_checkout_1_storageUnit() throws Exception {
170:         // given
171:         Map<UUID, Map<UUID, Integer>> expectedMap = Map.of(storageUnitTestHelper.getStorageUnitId(0) ,Map.of(itemId2, 2));
172:         shoppingCartUseCases.addItemToShoppingCart(email3, itemId2, 2);
173:         // when
174:         shoppingCart3 = shoppingCartService.getShoppingCart( email3);
175:         // then
176:         shoppingCartRESTHelper.checkout(shoppingCart3.getId().getId(), userName3, status().isCreated(), expectedMap);
177:     }
178: 
179: 
180: 
181:     /**
182:      * Provide a test that implements the checkout of a shopping cart that can only be served
183:      * by using 2 storage units, using the REST endpoint (11):
184:      * <pre>
185:      *     POST /shoppingCarts/{shoppingCart-Id}/checkout
186:      * </pre>
187:      * This should be just a slight variation of thetest_checkout_1_storageUnit() test.*
188:      * @ throws Exception
189:      */
190:     @Test
191:     public void test_checkout_2_storageUnits() throws Exception {
192:         // given
193:         UUID itemId3 = itemTestHelper.getItemId(7);
194:         UUID storageUnitId = storageUnitTestHelper.getStorageUnitId(0);
195:         UUID storageUnitId1 = storageUnitTestHelper.getStorageUnitId(3);
196: 
197:         Map<UUID, Map<UUID, Integer>> expectedMap = Map.of(storageUnitId,Map.of(itemId2, 2),
198:                 storageUnitId1, Map.of(itemId3, 1));
199: 
200:         shoppingCartUseCases.addItemToShoppingCart(email3, itemId2, 2);
201:         shoppingCartUseCases.addItemToShoppingCart(email3, itemId3, 1);
202: 
203:         // when
204:         shoppingCart3 = shoppingCartService.getShoppingCart( email3);
205:         // then
206:         shoppingCartRESTHelper.checkout(shoppingCart3.getId().getId(), userName3, status().isCreated(), expectedMap);
207:     }
208: 
209: }
210: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\CheckoutAcceptanceTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingcart;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
14: 
15: import java.util.*;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: 
19: /**
20:  * This test checks the management of inventory across storage units. It focuses on the
21:  * cases where more than one storage unit are needed to serve the shopping cart of a user.
22:  */
23: @Slf4j
24: @SpringBootTest
25: public class CheckoutAcceptanceTest {
26:     @Autowired
27:     private UserRegistrationUseCases userRegistrationUseCases;
28:     @Autowired
29:     private ShoppingCartUseCases shoppingCartUseCases;
30:     @Autowired
31:     private ItemCatalogUseCases itemCatalogUseCases;
32:     @Autowired
33:     private OrderUseCases orderUseCases;
34:     @Autowired
35:     private StorageUnitUseCases storageUnitUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private UserTestHelper userTestHelper;
40:     @Autowired
41:     private ItemTestHelper itemTestHelper;
42:     @Autowired
43:     private StorageUnitTestHelper storageUnitTestHelper;
44: 
45:     private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
46:                                 map8_11_14_quantity_3_3_4,
47:                                 map10_12_quantity_1_1, 
48:                                 map11_quantity_1, 
49:                                 map12_quantity_10,
50:                                 map8_9_10_11_quantity_2_1_4_2;
51:     private EmailType userEmail3, userEmail6,
52:             userEmail2;
53:     private UUID itemId8, itemId9, itemId10, itemId11, itemId12,
54:             itemId14;
55: 
56: 
57:     @BeforeEach
58:     public void setUp() {
59:         purgatory.deleteEverything();
60:         userTestHelper.registerAllUsers();
61:         itemTestHelper.addAllItems();
62:         storageUnitTestHelper.addAllStorageUnits( true );
63: 
64:         userEmail3 = userTestHelper.getUserEmail( 3 );
65:         userEmail6 = userTestHelper.getUserEmail( 6 );
66:         userEmail2 = userTestHelper.getUserEmail( 2 );
67: 
68:         itemId8 = itemTestHelper.getItemId( 8 );
69:         itemId9 = itemTestHelper.getItemId( 9 );
70:         itemId10 = itemTestHelper.getItemId( 10 );
71:         itemId11 = itemTestHelper.getItemId( 11 );
72:         itemId12 = itemTestHelper.getItemId( 12 );
73:         itemId14 = itemTestHelper.getItemId( 14 );
74: 
75:         map8_11_14_quantity_2_2_2 = new HashMap<>() {{
76:             put( itemId8, 2 );
77:             put( itemId11, 2 );
78:             put( itemId14, 2 );
79:         }};
80:         map8_11_14_quantity_3_3_4 = new HashMap<>() {{
81:             put( itemId8, 3 );
82:             put( itemId11, 3 );
83:             put( itemId14, 4 );
84:         }};
85:         map10_12_quantity_1_1 = new HashMap<>() {{
86:             put( itemId10, 1 );
87:             put( itemId12, 1 );
88:         }};
89:         map11_quantity_1 = new HashMap<>() {{
90:             put( itemId11, 1 );
91:         }};
92:         map12_quantity_10 = new HashMap<>() {{
93:             put( itemId12, 10 );
94:         }};
95:         map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
96:             put( itemId8, 2 );
97:             put( itemId9, 1 );
98:             put( itemId10, 4 );
99:             put( itemId11, 2 );
100:         }};
101: 
102:     }
103: 
104: 
105:     /**
106:      * Hint: to better understand the expected results of this test, see the distribution of inventory
107:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
108:      */
109:     @Test
110:     public void testClosestSingleStorageUnitWins() {
111:         log.info( "testClosestSingleStorageUnitWins" );
112: 
113:         // given
114:         shoppingCartUseCases.addItemToShoppingCart(
115:                 userEmail3, itemId8, 2 );
116:         shoppingCartUseCases.addItemToShoppingCart(
117:                 userEmail3, itemId11, 2 );
118:         shoppingCartUseCases.addItemToShoppingCart(
119:                 userEmail3, itemId14, 2 );
120:         // that basket could have been served from storage unit 4 or 7, but 4 is closer to the user
121:         UUID storageUnitId4 = storageUnitTestHelper.getStorageUnitId( 4 );
122: 
123:         // when
124:         Set<UUID> orderIds = shoppingCartUseCases.checkout( userEmail3 );
125: 
126:         // then
127:         checkStorageUnitIds( orderIds, storageUnitId4 );
128:         checkItemNumbers( orderIds, storageUnitId4, map8_11_14_quantity_2_2_2 );
129:     }
130: 
131: 
132:     /**
133:      * Hint: to better understand the expected results of this test, see the distribution of inventory
134:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
135:      */
136:     @Test
137:     public void testStorageUnitWithEnoughCapacityWins() {
138:         log.info( "testStorageUnitWithEnoughCapacityWins" );
139: 
140:         // given
141:         shoppingCartUseCases.addItemToShoppingCart(
142:                 userEmail3, itemId8, 3 );
143:         shoppingCartUseCases.addItemToShoppingCart(
144:                 userEmail3, itemId11, 3 );
145:         shoppingCartUseCases.addItemToShoppingCart(
146:                 userEmail3, itemId14, 4 );
147:         // that basket could have been served from storage unit 4 or 7, 4 is closer to the user,
148:         // but only 7 has enough capacity
149:         UUID storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );
150: 
151:         // when
152:         Set<UUID> orderIds = shoppingCartUseCases.checkout( userEmail3 );
153: 
154:         // then
155:         checkStorageUnitIds( orderIds, storageUnitId7 );
156:         checkItemNumbers( orderIds, storageUnitId7, map8_11_14_quantity_3_3_4 );
157:     }
158: 
159: 
160:     /**
161:      * Hint: to better understand the expected results of this test, see the distribution of inventory
162:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
163:      */
164:     @Test
165:     public void testTwoStorageUnits() {
166:         log.info( "testTwoStorageUnits" );
167: 
168:         // given
169:         shoppingCartUseCases.addItemToShoppingCart(
170:                 userEmail6, itemId10, 1 );
171:         shoppingCartUseCases.addItemToShoppingCart(
172:                 userEmail6, itemId11, 1 );
173:         shoppingCartUseCases.addItemToShoppingCart(
174:                 userEmail6, itemId12, 1 );
175:         // that basket needs two shipments (2 + 1 items) anyway, and there
176:         // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
177:         // closer. The smaller can then be served from 4 (closest), 7, or 8.
178:         UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
179:                 // should cover map10_12_quantity_1_1
180:         UUID storageUnitId4 = storageUnitTestHelper.getStorageUnitId( 4 );
181:                 // should cover map11_quantity_1
182: 
183:         // when
184:         Set<UUID> orderIds = shoppingCartUseCases.checkout( userEmail6 );
185: 
186:         // then
187:         checkStorageUnitIds( orderIds, storageUnitId5, storageUnitId4 );
188:         checkItemNumbers( orderIds, storageUnitId5, map10_12_quantity_1_1 );
189:         checkItemNumbers( orderIds, storageUnitId4, map11_quantity_1 );
190:     }
191: 
192: 
193:     /**
194:      * Hint: to better understand the expected results of this test, see the distribution of inventory
195:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
196:      */
197:     @Test
198:     public void testTwoBigShipments() {
199:         log.info( "testTwoBigShipments" );
200: 
201:         // given
202:         shoppingCartUseCases.addItemToShoppingCart(
203:                 userEmail2, itemId8, 2 );
204:         shoppingCartUseCases.addItemToShoppingCart(
205:                 userEmail2, itemId9, 1 );
206:         shoppingCartUseCases.addItemToShoppingCart(
207:                 userEmail2, itemId10, 4 );
208:         shoppingCartUseCases.addItemToShoppingCart(
209:                 userEmail2, itemId11, 2 );
210:         shoppingCartUseCases.addItemToShoppingCart(
211:                 userEmail2, itemId12, 10 );
212:         // when
213:         Set<UUID> orderIds = shoppingCartUseCases.checkout( userEmail2 );
214:         UUID storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );
215:                 // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 items
216:         UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
217:                 // should cover map12_quantity_10 - the only storage unit with enough capacity for 10 items
218: 
219:         // then
220:         checkStorageUnitIds( orderIds, storageUnitId7, storageUnitId5 );
221:         checkItemNumbers( orderIds, storageUnitId7, map8_9_10_11_quantity_2_1_4_2 );
222:         checkItemNumbers( orderIds, storageUnitId5, map12_quantity_10 );
223:     }
224: 
225: 
226:     /**
227:      * Hint: to better understand the expected results of this test, see the distribution of inventory
228:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
229:      */
230:     @Test
231:     public void testOnlyOneSolution() {
232:         log.info( "testOnlyOneSolution" );
233: 
234:         // given
235:         shoppingCartUseCases.addItemToShoppingCart(
236:                 userEmail6, itemId12, 10 );
237:         // when
238:         Set<UUID> orderIds = shoppingCartUseCases.checkout( userEmail6 );
239:         UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
240:         // should cover map12_quantity_10 - the only storage unit with enough capacity for 10 items
241: 
242:         // then
243:         checkStorageUnitIds( orderIds, storageUnitId5 );
244:         checkItemNumbers( orderIds, storageUnitId5, map12_quantity_10 );
245:     }
246: 
247: 
248: 
249:     private void checkItemNumbers( Set<UUID> orderIds, UUID storageUnitId, Map<UUID, Integer> expectedMap ) {
250:         UUID fittingOrderId = null;
251:         for ( UUID orderId : orderIds ) {
252:             UUID foundStorageUnitId = orderUseCases.getStorageUnitIdForOrder( orderId );
253:             if ( foundStorageUnitId.equals( storageUnitId ) ) {
254:                 fittingOrderId = orderId;
255:                 break;
256:             }
257:         }
258:         assertNotNull( fittingOrderId, "No fitting order found for storage unit " + storageUnitId );
259: 
260:         int totalExpected = 0;
261:         int totalActual = 0;
262:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
263:             totalExpected += entry.getValue();
264:         }
265:         log.info( "Check order numbers for item {} in storage unit {}", fittingOrderId, storageUnitId );
266:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
267:             UUID itemId = entry.getKey();
268:             Integer foundNumber =
269:                     orderUseCases.getOrderQuantityOfItem( fittingOrderId, itemId );
270:             assertEquals( entry.getValue(), foundNumber );
271:             totalActual += foundNumber;
272:         }
273:         // last check - do the total sums match?
274:         assertEquals( totalExpected, totalActual );
275:     }
276: 
277: 
278:     private void checkStorageUnitIds( Set<UUID> orderIds, UUID... expectedStorageUnitIds ) {
279:         assertEquals( expectedStorageUnitIds.length, orderIds.size() );
280:         Set<UUID> foundStorageUnitIds = new HashSet<>();
281:         for ( UUID orderId : orderIds ) {
282:             UUID storageUnitId = orderUseCases.getStorageUnitIdForOrder( orderId );
283:             foundStorageUnitIds.add( storageUnitId );
284:         }
285:         for ( UUID expectedStorageUnitId : expectedStorageUnitIds ) {
286:             assertTrue( foundStorageUnitIds.contains( expectedStorageUnitId ) );
287:         }
288:     }
289: 
290: }
291: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\ShoppingCartRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingcart;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.ResultMatcher;
12: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
13: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
14: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
15: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
17: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
18: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
19: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
20: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
21: 
22: import java.util.HashMap;
23: import java.util.Map;
24: import java.util.UUID;
25: 
26: import static org.junit.jupiter.api.Assertions.assertEquals;
27: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
28: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
29: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmail;
30: 
31: 
32: @SpringBootTest
33: @Transactional
34: @AutoConfigureMockMvc
35: @Import( RESTTestHelperConfiguration.class )
36: public class ShoppingCartRESTTest {
37:     @Autowired
38:     private StorageUnitUseCases storageUnitUseCases;
39:     @Autowired
40:     private ShoppingCartUseCases shoppingCartUseCases;
41:     @Autowired
42:     private Purgatory purgatory;
43:     @Autowired
44:     private UserTestHelper userTestHelper;
45:     @Autowired
46:     private ItemTestHelper itemTestHelper;
47:     @Autowired
48:     private StorageUnitTestHelper storageUnitTestHelper;
49:     @Autowired
50:     private MockMvc mockMvc;
51:     @Autowired
52:     private ShoppingCartRESTHelper shoppingCartRESTHelper;
53: 
54:     private EmailType nonExistingEmail;
55:     private final Map<UUID, Integer> emptyMap = new HashMap<>();
56: 
57:     private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
58:     private EmailType
59:             userEmail0,
60:             userEmail3,
61:             userEmail6,
62:             userEmail8;
63:     private String userName0, userName8;
64:     private UUID itemId0, itemId1, itemId2, itemId3, itemId5,
65:                  itemId7, itemId9, itemId11, nonExistentItemId;
66:     private UUID storageUnitId0, storageUnitId3, storageUnitId7, storageUnitId8;
67: 
68: 
69:     private static final ResultMatcher NOT_FOUND = status().isNotFound();
70:     private static final ResultMatcher OK = status().isOk();
71:     private static final ResultMatcher CREATED = status().isCreated();
72:     private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
73:     private static final ResultMatcher CONFLICT = status().isConflict();
74: 
75:     @BeforeEach
76:     public void setUp() {
77:         purgatory.deleteEverything();
78:         userTestHelper.registerAllUsers();
79:         itemTestHelper.addAllItems();
80:         storageUnitTestHelper.addAllStorageUnits( true );
81:         nonExistingEmail = instantiateEmail( "harry@sally.de" );
82: 
83:         userEmail0 = userTestHelper.getUserEmail( 0 );
84:         userEmail3 = userTestHelper.getUserEmail( 3 );
85:         userEmail6 = userTestHelper.getUserEmail( 6 );
86:         userEmail8 = userTestHelper.getUserEmail( 8 );
87:         userName0 = userTestHelper.getUserName( 0 );
88:         userName8 = userTestHelper.getUserName( 8 );
89: 
90:         itemId0 = itemTestHelper.getItemId( 0 );
91:         itemId1 = itemTestHelper.getItemId( 1 );
92:         itemId2 = itemTestHelper.getItemId( 2 );
93:         itemId3 = itemTestHelper.getItemId( 3 );
94:         itemId5 = itemTestHelper.getItemId( 5 );
95:         itemId7 = itemTestHelper.getItemId( 7 );
96:         itemId9 = itemTestHelper.getItemId( 9 );
97:         itemId11 = itemTestHelper.getItemId( 11 );
98:         nonExistentItemId = UUID.randomUUID();
99: 
100:         storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
101:         storageUnitId3 = storageUnitTestHelper.getStorageUnitId( 3 );
102:         storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );
103:         storageUnitId8 = storageUnitTestHelper.getStorageUnitId( 8 );
104: 
105:         map9_quantity_1 = new HashMap<>() {{
106:             put( itemId9, 1 );
107:         }};
108:         map5_quantity_2 = new HashMap<>() {{
109:             put( itemId5, 2 );
110:         }};
111:         map7_quantity_7 = new HashMap<>() {{
112:             put( itemId7, 7 );
113:         }};
114:         map9_11_quantity_2_2 = new HashMap<>() {{
115:             put( itemId9, 2 );
116:             put( itemId11, 2 );
117:         }};
118:     }
119: 
120: 
121:     @Test
122:     public void testInvalidShoppingCartBaseUris() throws Exception {
123:         // given
124:         String allShoppingCartsUri = "/shoppingCarts";
125:         String randomIdUri = "/shoppingCarts/" + UUID.randomUUID();
126:         String randomUserUUID = "/shoppingCarts?userId=" + UUID.randomUUID();
127:         String invalidUserUUID = "/shoppingCarts?userId=invalidUUID";
128:         String randomParamUri = "/shoppingCarts?randomParam=randomValue";
129: 
130:         // when
131:         // then
132:         mockMvc.perform( get( allShoppingCartsUri ) ).andExpect( status().isMethodNotAllowed() );
133:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
134:         mockMvc.perform( get( randomUserUUID ) ).andExpect( status().isNotFound() );
135:         mockMvc.perform( get( invalidUserUUID ) ).andExpect( status().isNotFound() );
136:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
137:     }
138: 
139: 
140:     @Test
141:     public void testInvalidPositionUris() throws Exception {
142:         // given
143:         UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail8, emptyMap );
144:         String randomPositionUri = "/shoppingCarts/" + shoppingCartId8.toString() + "/random";
145:         String randomItemUri = "/shoppingCarts/" + shoppingCartId8.toString()
146:                 + "/positions/" + UUID.randomUUID();
147: 
148:         // when
149:         // then
150:         mockMvc.perform( post( randomPositionUri ) ).andExpect( status().isNotFound() );
151:         mockMvc.perform( delete( randomItemUri ) ).andExpect( status().isNotFound() );
152:     }
153: 
154: 
155:     @Test
156:     public void testInvalidAddToShoppingCart() throws Exception {
157:         // given
158:         Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
159:         expectedStartQuantityMap.put( itemId2, 19 );
160: 
161:         // when
162:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( userEmail0, emptyMap );
163:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId, itemId2, 6 );
164:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId, itemId2, 13 );
165: 
166:         // then
167:         shoppingCartRESTHelper.getQueryShoppingCart( userEmail0, expectedStartQuantityMap );
168: 
169:         // ... and check a couple of invalid cases
170:         shoppingCartRESTHelper.addItemToShoppingCart(
171:                 shoppingCartId, nonExistentItemId, 12, NOT_FOUND );
172:         shoppingCartRESTHelper.addItemToShoppingCart(
173:                 UUID.randomUUID(), itemId5, 12, NOT_FOUND );
174:         shoppingCartRESTHelper.addItemToShoppingCart(
175:                 shoppingCartId, itemId5, -1, UNPROCESSABLE_ENTITY );
176: 
177:         // check if the shopping cart is still the same
178:         shoppingCartRESTHelper.getQueryShoppingCart( userEmail0, expectedStartQuantityMap );
179:     }
180: 
181: 
182:     @Test
183:     public void testInvalidCheckout_unavailableItem() throws Exception {
184:         // given
185:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( userEmail0, emptyMap );
186: 
187:         // when
188:         // productId0 is not available in the requested quantity (or rather, not at all)
189:         shoppingCartRESTHelper.addItemToShoppingCart(
190:                 shoppingCartId, itemId0, 1, CREATED );
191: 
192:         // check if the shopping cart is still the same
193:         shoppingCartRESTHelper.checkout( shoppingCartId, null, CONFLICT, null );
194:     }
195: 
196: 
197:     @Test
198:     public void testInvalidCheckout_tooLittleInventory() throws Exception {
199:         // given
200:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( userEmail0, emptyMap );
201: 
202:         // when
203:         // There are only 10 pieces of productId1 available
204:         shoppingCartRESTHelper.addItemToShoppingCart(
205:                 shoppingCartId, itemId1, 11, CREATED );
206: 
207:         // check if the shopping cart is still the same
208:         shoppingCartRESTHelper.checkout( shoppingCartId, null, CONFLICT, null );
209:     }
210: 
211: 
212: 
213:     @Test
214:     public void testDeleteItemFromShoppingCart() throws Exception {
215:         // given
216:         UUID shoppingCartId6 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, emptyMap );
217:         Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
218:         expectedQuantityMap1.put( itemId1, 1 );
219:         expectedQuantityMap1.put( itemId2, 2 );
220:         expectedQuantityMap1.put( itemId3, 3 );
221:         Map<UUID, Integer> quantityMap2 = new HashMap<>();
222:         quantityMap2.put( itemId1, 1 );
223:         quantityMap2.put( itemId3, 3 );
224: 
225:         // when
226:         // then
227:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId6, itemId1, 1 );
228:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId6, itemId2, 2 );
229:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId6, itemId3, 3 );
230:         shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, expectedQuantityMap1 );
231: 
232:         shoppingCartRESTHelper.deleteItemFromShoppingCart( shoppingCartId6, itemId2 );
233:         shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, quantityMap2 );
234:     }
235: 
236: 
237:     @Test
238:     public void testNoDoubleDelete() throws Exception {
239:         // given
240:         UUID shoppingCartId6 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, emptyMap );
241: 
242:         // when
243:         // then
244:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId6, itemId3, 3 );
245:         shoppingCartRESTHelper.deleteItemFromShoppingCart( shoppingCartId6, itemId3 );
246:         shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, new HashMap<>() );
247:         shoppingCartRESTHelper.deleteItemFromShoppingCart( shoppingCartId6, itemId3, NOT_FOUND );
248:     }
249: 
250: 
251:     @Test
252:     public void testAddRemoveItemsFromAndToShoppingCart() throws Exception {
253:         // given
254:         UUID shoppingCartId3 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail3, emptyMap );
255:         UUID shoppingCartId5 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, emptyMap );
256: 
257:         // when
258:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId3, itemId1, 2 );
259:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId3, itemId2, 3 );
260:         shoppingCartRESTHelper.deleteItemFromShoppingCart( shoppingCartId3, itemId1 );
261:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId3, itemId1, 1 );
262:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId3, itemId2, 6 );
263: 
264:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId5, itemId1, 2 );
265:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId5, itemId2, 8 );
266:         shoppingCartRESTHelper.deleteItemFromShoppingCart( shoppingCartId5, itemId1 );
267:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId5, itemId1, 1 );
268:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId5, itemId2, 2 );
269: 
270:         // then
271:         // user3 has 1x itemId1 and 9x itemId2 expected in cart
272:         Map<UUID, Integer> expectedMap3 = new HashMap<>();
273:         expectedMap3.put( itemId1, 1 );
274:         expectedMap3.put( itemId2, 9 );
275:         shoppingCartRESTHelper.getQueryShoppingCart( userEmail3, expectedMap3 );
276: 
277:         // user6 has 1x itemId1 and 10x itemId2 in cart
278:         Map<UUID, Integer> expectedMap5 = new HashMap<>();
279:         expectedMap5.put( itemId1, 1 );
280:         expectedMap5.put( itemId2, 10 );
281:         shoppingCartRESTHelper.getQueryShoppingCart( userEmail6, expectedMap5 );
282:     }
283: 
284: 
285:     @Test
286:     public void testNoDoubleCheckout() throws Exception {
287:         // given
288:         UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart( userEmail8, emptyMap );
289: 
290:         // when
291:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId8, itemId2, 3 );
292: 
293:         // then
294:         shoppingCartRESTHelper.checkout( shoppingCartId8, userName8, CREATED, null );
295:         shoppingCartRESTHelper.checkout( shoppingCartId8, null, CONFLICT, null );
296:     }
297: 
298: 
299:     @Test
300:     public void testCheckout_1_Order() throws Exception {
301:         // given:
302:         // User 0 wants to buy 1x item 9. This is in storage unit 5, 7, and 8. Out of these,
303:         // storage unit 8 with zip code 89250 is closest to user 0 with zip code 02314.
304:         Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
305:             put( storageUnitId8, map9_quantity_1 );
306:         }};
307:         UUID shoppingCartId0 = shoppingCartRESTHelper.getQueryShoppingCart(
308:                 userEmail0, null );
309:         int inventory9before =
310:                 storageUnitUseCases.getAvailableInventory( storageUnitId8, itemId9 );
311: 
312:         // when
313:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId0, itemId9, 1 );
314:         shoppingCartRESTHelper.checkout( shoppingCartId0, userName0, CREATED, expectedOrders );
315:         int inventory9after =
316:                 storageUnitUseCases.getAvailableInventory( storageUnitId8, itemId9 );
317: 
318:         // then
319:         assertEquals( 1, inventory9before - inventory9after );
320:     }
321: 
322: 
323:     @Test
324:     public void testCheckout_3_Order() throws Exception {
325:         // given:
326:         // User 8 (Felix Bauer) wants to buy 2x each of items 5, 9, 11; and 7x item 7.
327:         //       - items 9 and 11 can both be found in storage units 7 and 8. Storage units 7 (76532) is closer to
328:         //         the user (70173)
329:         //       - item 7 is available in storage units 1, 2, and 3, but only storage unit 3 has enough inventory.
330:         //       - item 5 is only available in storage unit 0.
331:         Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
332:             put( storageUnitId0, map5_quantity_2 );
333:             put( storageUnitId3, map7_quantity_7 );
334:             put( storageUnitId7, map9_11_quantity_2_2 );
335:         }};
336:         UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart(
337:                 userEmail8, null );
338:         int inventory5before =
339:                 storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId5 );
340:         int inventory7before =
341:                 storageUnitUseCases.getAvailableInventory( storageUnitId3, itemId7 );
342:         int inventory9before =
343:                 storageUnitUseCases.getAvailableInventory( storageUnitId7, itemId9 );
344:         int inventory11before =
345:                 storageUnitUseCases.getAvailableInventory( storageUnitId7, itemId11 );
346: 
347:         // when
348:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId8, itemId5, 2 );
349:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId8, itemId7, 7 );
350:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId8, itemId9, 2 );
351:         shoppingCartRESTHelper.addItemToShoppingCart( shoppingCartId8, itemId11, 2 );
352:         shoppingCartRESTHelper.checkout( shoppingCartId8, userName8, CREATED, expectedOrders );
353:         int inventory5after =
354:                 storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId5 );
355:         int inventory7after =
356:                 storageUnitUseCases.getAvailableInventory( storageUnitId3, itemId7 );
357:         int inventory9after =
358:                 storageUnitUseCases.getAvailableInventory( storageUnitId7, itemId9 );
359:         int inventory11after =
360:                 storageUnitUseCases.getAvailableInventory( storageUnitId7, itemId11 );
361: 
362:         // then
363:         assertEquals( 2, inventory5before - inventory5after );
364:         assertEquals( 7, inventory7before - inventory7after );
365:         assertEquals( 2, inventory9before - inventory9after );
366:         assertEquals( 2, inventory11before - inventory11after );
367:     }
368: 
369: 
370: }
371: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\ShoppingCartTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingcart;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.InsufficientInventoryException;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
12: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
13: import thkoeln.archilab.ecommerce.usecases.*;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
16: 
17: 
18: import java.util.Map;
19: import java.util.UUID;
20: 
21: import static org.junit.jupiter.api.Assertions.*;
22: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
23: 
24: @SpringBootTest
25: public class ShoppingCartTest {
26:     @Autowired
27:     private UserRegistrationUseCases userRegistrationUseCases;
28:     @Autowired
29:     private ShoppingCartUseCases shoppingCartUseCases;
30:     @Autowired
31:     private ItemCatalogUseCases itemCatalogUseCases;
32:     @Autowired
33:     private StorageUnitUseCases storageUnitUseCases;
34:     @Autowired
35:     private OrderUseCases orderUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private UserTestHelper userTestHelper;
40:     @Autowired
41:     private ItemTestHelper itemTestHelper;
42:     @Autowired
43:     private StorageUnitTestHelper storageUnitTestHelper;
44: 
45:     private EmailType nonExistingEmail;
46: 
47:     @BeforeEach
48:     public void setUp() {
49:         purgatory.deleteEverything();
50:         userTestHelper.registerAllUsers();
51:         itemTestHelper.addAllItems();
52: 
53:         nonExistingEmail = instantiateEmail( "this@nononono.de" );
54:     }
55: 
56: 
57:     @Test
58:     public void testInvalidAddToShoppingCart() {
59:         // given
60:         UUID nonExistentItemId = UUID.randomUUID();
61:         UUID itemId5 = itemTestHelper.getItemId( 5 );
62:         UUID itemId0 = itemTestHelper.getItemId( 0 );
63:         EmailType userEmail0 =
64:                 userTestHelper.getUserEmail( 0 );
65:         storageUnitTestHelper.addAllStorageUnits( true );
66: 
67:         // then
68:         assertThrows( ShopException.class,
69:                 () -> shoppingCartUseCases.addItemToShoppingCart(
70:                         nonExistingEmail, itemId0, 1 ) );
71:         assertThrows( ShopException.class,
72:                 () -> shoppingCartUseCases.addItemToShoppingCart(
73:                         null, itemId0, 1 ) );
74:         assertThrows( ShopException.class,
75:                 () -> shoppingCartUseCases.addItemToShoppingCart(
76:                         userEmail0, nonExistentItemId, 1 ) );
77:         assertThrows( ShopException.class,
78:                 () -> shoppingCartUseCases.addItemToShoppingCart(
79:                         userEmail0, null, 1 ) );
80:         assertThrows( ShopException.class,
81:                 () -> shoppingCartUseCases.addItemToShoppingCart(
82:                         userEmail0, itemId5, -1 ) );
83:     }
84: 
85: 
86:     @Test
87:     public void testInvalidRemoveFromShoppingCart() {
88:         // given
89:         UUID nonExistentItemId = UUID.randomUUID();
90:         UUID itemId5 = itemTestHelper.getItemId( 5 );
91:         UUID itemId1 = itemTestHelper.getItemId( 1 );
92:         UUID itemId2 = itemTestHelper.getItemId( 2 );
93:         storageUnitTestHelper.addAllStorageUnits( true );
94:         EmailType userEmail0 =
95:                 userTestHelper.getUserEmail( 0 );
96:         shoppingCartUseCases.addItemToShoppingCart(
97:                 userEmail0, itemId1, 5 );
98:         shoppingCartUseCases.addItemToShoppingCart(
99:                 userEmail0, itemId2, 15 );
100: 
101:         // when
102:         shoppingCartUseCases.removeItemFromShoppingCart(
103:                 userEmail0, itemId1, 2 );
104:         shoppingCartUseCases.removeItemFromShoppingCart(
105:                 userEmail0, itemId2, 4 );
106:         shoppingCartUseCases.removeItemFromShoppingCart(
107:                 userEmail0, itemId2, 7 );
108:         // now we should have 3x itemId1 and 4x itemId2 in the shopping cart
109: 
110:         // then
111:         assertThrows( ShopException.class,
112:                 () -> shoppingCartUseCases.removeItemFromShoppingCart(
113:                         userEmail0, nonExistentItemId, 12 ) );
114:         assertThrows( ShopException.class,
115:                 () -> shoppingCartUseCases.removeItemFromShoppingCart(
116:                         nonExistingEmail, itemId5, 12 ) );
117:         assertThrows( ShopException.class,
118:                 () -> shoppingCartUseCases.removeItemFromShoppingCart(
119:                         userEmail0, itemId5, -1 ) );
120:         assertThrows( ShopException.class,
121:                 () -> shoppingCartUseCases.removeItemFromShoppingCart(
122:                         userEmail0, itemId1, 4 ) );
123:         assertThrows( ShopException.class,
124:                 () -> shoppingCartUseCases.removeItemFromShoppingCart(
125:                         userEmail0, itemId2, 5 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testAddRemoveItemsFromAndToShoppingCart() {
131:         // given
132:         UUID itemId1 = itemTestHelper.getItemId( 1 );
133:         UUID itemId2 = itemTestHelper.getItemId( 2 );
134:         EmailType userEmail3 =
135:                 userTestHelper.getUserEmail( 3 );
136:         EmailType userEmail5 =
137:                 userTestHelper.getUserEmail( 5 );
138: 
139:         // when user 3 ...
140:         shoppingCartUseCases.addItemToShoppingCart(
141:                 userEmail3, itemId1, 2 );
142:         shoppingCartUseCases.addItemToShoppingCart(
143:                 userEmail3, itemId2, 3 );
144:         shoppingCartUseCases.removeItemFromShoppingCart(
145:                 userEmail3, itemId1, 2 );
146:         shoppingCartUseCases.addItemToShoppingCart(
147:                 userEmail3, itemId1, 1 );
148:         shoppingCartUseCases.addItemToShoppingCart(
149:                 userEmail3, itemId2, 6 );
150:         Map<UUID, Integer> cart3 = shoppingCartUseCases.getShoppingCartAsMap( userEmail3 );
151:         // user3 has 1x itemId1 and 9x itemId2 in cart
152: 
153:         // ... and when user 5 ...
154:         shoppingCartUseCases.addItemToShoppingCart(
155:                 userEmail5, itemId1, 2 );
156:         shoppingCartUseCases.addItemToShoppingCart(
157:                 userEmail5, itemId2, 8 );
158:         shoppingCartUseCases.removeItemFromShoppingCart(
159:                 userEmail5, itemId1, 1 );
160:         shoppingCartUseCases.addItemToShoppingCart(
161:                 userEmail5, itemId2, 2 );
162:         Map<UUID, Integer> cart5 = shoppingCartUseCases.getShoppingCartAsMap( userEmail5 );
163:         // user5 has 1x itemId1 and 10x itemId2 in cart
164: 
165:         // then
166:         assertEquals( 2, cart3.size() );
167:         assertEquals( 1, cart3.get( itemId1 ) );
168:         assertEquals( 9, cart3.get( itemId2 ) );
169: 
170:         assertEquals( 2, cart5.size() );
171:         assertEquals( 1, cart5.get( itemId1 ) );
172:         assertEquals( 10, cart5.get( itemId2 ) );
173:     }
174: 
175: 
176:     @Test
177:     public void testShoppingCartValue() {
178:         // given
179:         UUID itemId3 = itemTestHelper.getItemId( 3 );
180:         UUID itemId6 = itemTestHelper.getItemId( 6 );
181:         UUID itemId8 = itemTestHelper.getItemId( 8 );
182:         CurrencyType price3 = itemTestHelper.getSellingPrice( 3 );
183:         CurrencyType price6 = itemTestHelper.getSellingPrice( 6 );
184:         CurrencyType price8 = itemTestHelper.getSellingPrice( 8 );
185:         EmailType userEmail3 =
186:                 userTestHelper.getUserEmail( 3 );
187: 
188:         // when
189:         shoppingCartUseCases.addItemToShoppingCart( userEmail3, itemId3, 3 );
190:         shoppingCartUseCases.addItemToShoppingCart( userEmail3, itemId6, 2 );
191:         shoppingCartUseCases.addItemToShoppingCart( userEmail3, itemId8, 5 );
192:         // user3 has 3x itemId3, 2x itemId6 and 5x itemId8 in cart
193:         CurrencyType cartValue = shoppingCartUseCases.getShoppingCartAsCurrencyValue( userEmail3 );
194: 
195:         // then
196:         assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
197:                 cartValue );
198:     }
199: 
200: 
201:     @Test
202:     public void testShoppingCartValueInvalid() {
203:         // given
204:         // when
205:         // then
206:         assertThrows( ShopException.class,
207:                 () -> shoppingCartUseCases.getShoppingCartAsCurrencyValue( nonExistingEmail ) );
208:     }
209: 
210: 
211:     @Test
212:     public void testUnsuccessfulCheckout() {
213:         // given user buying item 0 (which is not in inventory), and user 1 buying item 1
214:         // in a bigger quantity (11) than available (10)
215:         storageUnitTestHelper.addAllStorageUnits( true );
216:         EmailType userEmail0 =
217:                 userTestHelper.getUserEmail( 0 );
218:         EmailType userEmail1 =
219:                 userTestHelper.getUserEmail( 1 );
220:         UUID itemId0 = itemTestHelper.getItemId( 0 );
221:         UUID itemId1 = itemTestHelper.getItemId( 1 );
222: 
223:         // when
224:         shoppingCartUseCases.addItemToShoppingCart(
225:                 userEmail0, itemId0, 1 );
226:         shoppingCartUseCases.addItemToShoppingCart(
227:                 userEmail1, itemId1, 11 );
228: 
229:         // then
230:         assertThrows( InsufficientInventoryException.class,
231:                 () -> shoppingCartUseCases.checkout( userEmail0 ) );
232:         assertThrows( InsufficientInventoryException.class,
233:                 () -> shoppingCartUseCases.checkout( userEmail1 ) );
234:     }
235: 
236: }
237: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\storageunit\StorageUnitManagementTest.java ---
1: package thkoeln.archilab.ecommerce.tests.storageunit;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
12: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
14: 
15: import java.util.UUID;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
19: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateAddress;
20: 
21: 
22: /**
23:  * This test checks the management and lifecycle of storage units.
24:  */
25: @SpringBootTest
26: public class StorageUnitManagementTest {
27:     @Autowired
28:     private StorageUnitUseCases storageUnitUseCases;
29:     @Autowired
30:     private ItemCatalogUseCases itemCatalogUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private ItemTestHelper itemTestHelper;
35:     @Autowired
36:     private StorageUnitTestHelper storageUnitTestHelper;
37: 
38:     private AddressType someAddress;
39:     private UUID nonExistingId1;
40:     private UUID nonExistingId2;
41: 
42: 
43:     @BeforeEach
44:     public void setUp() {
45:         purgatory.deleteEverything();
46:         itemTestHelper.addAllItems();
47: 
48:         someAddress = instantiateAddress( "Some Street", "Some City",
49:                 instantiateZipCode( "90001" ) );
50:         nonExistingId1 = UUID.randomUUID();
51:         nonExistingId2 = UUID.randomUUID();
52:     }
53: 
54: 
55:     @Test
56:     public void testAddInvalidStorageUnit() {
57:         // given
58:         String name = "Lager1";
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class,
63:                 () -> storageUnitUseCases.addNewStorageUnit(
64:                         null, someAddress ) );
65:         assertThrows( ShopException.class,
66:                 () -> storageUnitUseCases.addNewStorageUnit(
67:                         "", someAddress ) );
68:         assertThrows( ShopException.class,
69:                 () -> storageUnitUseCases.addNewStorageUnit(
70:                         name, null ) );
71:     }
72: 
73: 
74:     @Test
75:     public void testDeleteAllStorageUnitsWhenEmpty() {
76:         // given
77:         storageUnitTestHelper.addAllStorageUnits( false );
78:         UUID itemId9 = itemTestHelper.getItemId( 9 );
79:         UUID storageUnitId1 = storageUnitTestHelper.getStorageUnitId( 1 );
80:         UUID storageUnitId2 = storageUnitTestHelper.getStorageUnitId( 2 );
81: 
82:         // when
83:         int numOf1 = storageUnitUseCases.getAvailableInventory( storageUnitId1, itemId9 );
84:         int numOf2 = storageUnitUseCases.getAvailableInventory( storageUnitId2, itemId9 );
85: 
86:         // then
87:         assertEquals( 0, numOf1 );
88:         assertEquals( 0, numOf2 );
89:         storageUnitUseCases.deleteAllStorageUnits();
90:         // ... ids must be invalid now
91:         assertThrows( ShopException.class,
92:                 () -> storageUnitUseCases.getAvailableInventory( storageUnitId1, itemId9 ) );
93:         assertThrows( ShopException.class,
94:                 () -> storageUnitUseCases.getAvailableInventory( storageUnitId2, itemId9 ) );
95:     }
96: 
97: 
98:     @Test
99:     public void testDeleteAllStorageUnitsWhenFull() {
100:         // given
101:         storageUnitTestHelper.addAllStorageUnits( true );
102:         UUID itemId7 = itemTestHelper.getItemId( 7 );
103:         UUID storageUnitId1 = storageUnitTestHelper.getStorageUnitId( 1 );
104:         UUID storageUnitId2 = storageUnitTestHelper.getStorageUnitId( 2 );
105: 
106:         // when
107:         int numOf1 = storageUnitUseCases.getAvailableInventory( storageUnitId1, itemId7 );
108:         int numOf2 = storageUnitUseCases.getAvailableInventory( storageUnitId2, itemId7 );
109: 
110:         // then
111:         assertTrue( numOf1 == 3 );
112:         assertTrue( numOf2 == 3 );
113:         storageUnitUseCases.deleteAllStorageUnits();
114:         // ... ids must be invalid now
115:         assertThrows( ShopException.class,
116:                 () -> storageUnitUseCases.getAvailableInventory( storageUnitId1, itemId7 ) );
117:         assertThrows( ShopException.class,
118:                 () -> storageUnitUseCases.getAvailableInventory( storageUnitId2, itemId7 ) );
119:     }
120: 
121: 
122: 
123:     @Test
124:     public void testAddToInventory() {
125:         // given
126:         storageUnitTestHelper.addAllStorageUnits( true );
127:         UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in storage unit 0
128:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
129:         int originalInventory5 =
130:                 storageUnitTestHelper.getStorageUnitInventory( 0, 5 );
131: 
132:         // when
133:         int inventory5before = storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId5 );
134:         storageUnitUseCases.addToInventory( storageUnitId0, itemId5, 23 );
135:         int inventory5after = storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId5 );
136:         storageUnitUseCases.addToInventory( storageUnitId0, itemId5, 0 );
137:         int inventory5after2 = storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId5 );
138: 
139:         // then
140:         assertEquals( originalInventory5, inventory5before );
141:         assertEquals( inventory5before + 23, inventory5after );
142:         assertEquals( inventory5after, inventory5after2 );
143:     }
144: 
145: 
146:     @Test
147:     public void testInvalidAddToInventory() {
148:         // given
149:         storageUnitTestHelper.addAllStorageUnits( true );
150:         UUID itemId2 = itemTestHelper.getItemId( 2 );
151:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
152: 
153:         // when
154:         // then
155:         assertThrows( ShopException.class,
156:                 () -> storageUnitUseCases.addToInventory( nonExistingId1, nonExistingId2, 12 ) );
157:         assertThrows( ShopException.class,
158:                 () -> storageUnitUseCases.addToInventory(
159:                         storageUnitId0, nonExistingId2, 12 ) );
160:         assertThrows( ShopException.class,
161:                 () -> storageUnitUseCases.addToInventory(
162:                         nonExistingId1, itemId2, 12 ) );
163:         assertThrows( ShopException.class,
164:                 () -> storageUnitUseCases.addToInventory(
165:                         storageUnitId0, itemId2, -1 ) );
166:     }
167: 
168: 
169:     @Test
170:     public void testRemoveFromInventory() {
171:         // given
172:         storageUnitTestHelper.addAllStorageUnits( true );
173:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
174:         UUID itemId0 = itemTestHelper.getItemId( 0 ); // 0 in storage unit 0
175:         UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in storage unit 0
176:         UUID itemId6 = itemTestHelper.getItemId( 6 ); // random >30 in storage unit 0
177:         int inventory0before =
178:                 storageUnitTestHelper.getStorageUnitInventory( 0, 0 );
179:         int inventory5before =
180:                 storageUnitTestHelper.getStorageUnitInventory( 0, 5 );
181:         int inventory6before =
182:                 storageUnitTestHelper.getStorageUnitInventory( 0, 6 );
183: 
184:         // when
185:         storageUnitUseCases.removeFromInventory( storageUnitId0, itemId5, 1 );
186:         int inventory5after = storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId5 );
187:         storageUnitUseCases.removeFromInventory( storageUnitId0, itemId0, 0 );
188:         int inventory0after = storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId0 );
189:         storageUnitUseCases.removeFromInventory(
190:                 storageUnitId0, itemId6, inventory6before );
191:         int inventory6after = storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId6 );
192: 
193:         // then
194:         assertEquals( inventory5before - 1, inventory5after );
195:         assertEquals( inventory0before, inventory0after );
196:         assertEquals( 0, inventory6after );
197:     }
198: 
199: 
200:     @Test
201:     public void testInvalidRemoveFromInventory() {
202:         // given
203:         storageUnitTestHelper.addAllStorageUnits( true );
204:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
205:         UUID itemId0 = itemTestHelper.getItemId( 0 ); // 0 in storage unit 0
206:         UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in storage unit 0
207:         int inventory5before =
208:                 storageUnitTestHelper.getStorageUnitInventory( 0, 5 );
209: 
210:         // when
211:         // then
212:         assertThrows( ShopException.class,
213:                 () -> storageUnitUseCases.removeFromInventory( nonExistingId1, nonExistingId2, 12 ) );
214:         assertThrows( ShopException.class,
215:                 () -> storageUnitUseCases.removeFromInventory(
216:                         storageUnitId0, nonExistingId2, 12 ) );
217:         assertThrows( ShopException.class,
218:                 () -> storageUnitUseCases.removeFromInventory(
219:                         nonExistingId1, itemId5, 12 ) );
220:         assertThrows( ShopException.class,
221:                 () -> storageUnitUseCases.removeFromInventory(
222:                         storageUnitId0, itemId5, -1 ) );
223:         assertThrows( ShopException.class,
224:                 () -> storageUnitUseCases.removeFromInventory(
225:                         storageUnitId0, itemId5, inventory5before + 1 ) );
226:         assertThrows( ShopException.class,
227:                 () -> storageUnitUseCases.removeFromInventory(
228:                         storageUnitId0, itemId0, 1 ) ); // already 0 in storage unit 0
229:     }
230: 
231: 
232:     @Test
233:     public void testChangeInventory() {
234:         // given
235:         storageUnitTestHelper.addAllStorageUnits( true );
236:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
237:         UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in storage unit 0
238: 
239:         // when
240:         storageUnitUseCases.changeInventoryTo( storageUnitId0, itemId5, 111 );
241:         int inventory5after = storageUnitUseCases.getAvailableInventory( storageUnitId0, itemId5 );
242: 
243:         // then
244:         assertEquals( 111, inventory5after );
245:     }
246: 
247: 
248:     @Test
249:     public void testInvalidChangeInventory() {
250:         // given
251:         storageUnitTestHelper.addAllStorageUnits( true );
252:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
253:         UUID itemId6 = itemTestHelper.getItemId( 6 );
254: 
255:         // when
256:         // then
257:         assertThrows( ShopException.class, () -> storageUnitUseCases.changeInventoryTo(
258:                 nonExistingId1, nonExistingId2, 12 ) );
259:         assertThrows( ShopException.class, () -> storageUnitUseCases.changeInventoryTo(
260:                 nonExistingId1, itemId6, 12 ) );
261:         assertThrows( ShopException.class, () -> storageUnitUseCases.changeInventoryTo(
262:                 storageUnitId0, nonExistingId2, 12 ) );
263:         assertThrows( ShopException.class, () -> storageUnitUseCases.changeInventoryTo(
264:                 storageUnitId0, itemId6, -1 ) );
265:     }
266: 
267: 
268:     @Test
269:     public void testEmptyStorageUnit() {
270:         // given
271:         storageUnitTestHelper.addAllStorageUnits( true );
272:         UUID storageUnitId9 = storageUnitTestHelper.getStorageUnitId( 9 ); // empty storage unit
273: 
274:         // when
275:         int totalInventory = 0;
276:         for ( int iItem = 0; iItem < itemTestHelper.numberOfItems(); iItem++ ) {
277:             UUID itemId = itemTestHelper.getItemId( iItem );
278:             totalInventory += storageUnitUseCases.getAvailableInventory(
279:                     storageUnitId9, itemId );
280:         }
281: 
282:         // then
283:         assertEquals( 0, totalInventory );
284:     }
285: 
286: 
287: 
288: }
289: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
1: package thkoeln.archilab.ecommerce.tests.testtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.domain.JavaMethod;
6: import com.tngtech.archunit.core.importer.ClassFileImporter;
7: import com.tngtech.archunit.lang.ArchRule;
8: import org.junit.jupiter.api.BeforeEach;
9: import org.junit.jupiter.api.Test;
10: import org.springframework.web.bind.annotation.RestController;
11: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
12: import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
13: import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingCartRESTTest;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
18: 
19: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
20: import static org.springframework.test.util.AssertionErrors.assertTrue;
21: 
22: /**
23:  * This test checks if there are the appropriate tests in the test class(es) for domain
24:  * primitives.
25:  */
26: 
27: public class RulesForOwnTests {
28:     private JavaClass dpTestClass, restTestClass;
29:     private JavaClasses dpTestClasses, restTestClasses;
30:     private static final String STORAGE_UNIT_DOMAIN_PACKAGE =
31:             "thkoeln.archilab.ecommerce.solution.storageunit.domain";
32:     private static final String STORAGE_UNIT_CLASS_NAME =
33:             STORAGE_UNIT_DOMAIN_PACKAGE + ".StorageUnit";
34: 
35: 
36:     @BeforeEach
37:     public void setUp() throws Exception {
38:         dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
39:         restTestClass = new ClassFileImporter().importClass( OwnShoppingCartRESTTest.class );
40: 
41:         dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
42:         restTestClasses = new ClassFileImporter().importClasses( OwnShoppingCartRESTTest.class );
43:     }
44: 
45: 
46:     @Test
47:     public void ensureMinimumNumberOfTestMethods() {
48:         // given
49:         // when
50:         int dpTestMethodCount = getTestMethodCount( dpTestClass );
51:         int restTestMethodCount = getTestMethodCount( restTestClass );
52: 
53:         // then
54:         assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
55:                         + dpTestMethodCount,dpTestMethodCount >= 2 );
56:         assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
57:                         + restTestMethodCount, restTestMethodCount >= 5 );
58:     }
59: 
60:     private int getTestMethodCount( JavaClass testClass ) {
61:         int testMethodCount = 0;
62:         for ( JavaMethod method : testClass.getMethods() ) {
63:             if ( isTestMethod( method ) ) {
64:                 testMethodCount++;
65:             }
66:         }
67:         return testMethodCount;
68:     }
69: 
70:     private boolean isTestMethod( JavaMethod method ) {
71:         return method.isAnnotatedWith( Test.class );
72:     }
73: 
74: 
75:     @Test
76:     public void dpTestsShouldReferenceTheRightClasses() {
77:         ArchRule rule = classes()
78:                 .should().dependOnClassesThat()
79:                 .areAssignableTo( ZipCodeType.class )
80:                 .andShould().dependOnClassesThat()
81:                 .areAssignableTo( CurrencyType.class )
82:                 .andShould().dependOnClassesThat()
83:                 .areAssignableTo( AddressType.class )
84:                 .andShould().dependOnClassesThat()
85:                 .areAssignableTo( EmailType.class )
86:                 .because( "DomainPrimitiveJSONSerializationTest should reference ZipCode, " +
87:                         "Currency, Email, and Address!" );
88:         rule.check( dpTestClasses );
89:     }
90: 
91: 
92:     @Test
93:     public void restTestsShouldReferenceEmail() {
94:         ArchRule rule = classes()
95:                 .should().dependOnClassesThat()
96:                 .areAssignableTo( EmailType.class )
97:                 .because( "StorageUnitComparatorUnitTest should reference EmailType!" );
98:         rule.check( restTestClasses );
99:     }
100: 
101: 
102:     @Test
103:     public void restTestsShouldReferenceRESTControllers() {
104:         ArchRule rule = classes()
105:                 .should().dependOnClassesThat()
106:                 .areAnnotatedWith( RestController.class )
107:                 .orShould().dependOnClassesThat()
108:                 .areAssignableTo( ShoppingCartRESTHelper.class )
109:                 .because( "StorageUnitComparatorUnitTest should call REST controllers! " +
110:                         "(either directly or via the ShoppingCartRESTHelper REST helper)" );
111:         rule.check( restTestClasses );
112:     }
113: 
114: }
115: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\user\UserRegistrationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.user;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
12: import thkoeln.archilab.ecommerce.usecases.UserType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
15: 
16: import static org.junit.jupiter.api.Assertions.*;
17: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
18: 
19: 
20: @SpringBootTest
21: public class UserRegistrationTest {
22:     @Autowired
23:     private UserRegistrationUseCases userRegistrationUseCases;
24:     @Autowired
25:     private Purgatory purgatory;
26:     @Autowired
27:     private UserTestHelper userTestHelper;
28: 
29:     private EmailType nonExistingEmail;
30:     private AddressType someAddress;
31: 
32:     @BeforeEach
33:     public void setUp() {
34:         purgatory.deleteEverything();
35:         nonExistingEmail = instantiateEmail( "this@nononono.de" );
36:         someAddress = instantiateAddress( "Some Street", "Some City",
37:                 instantiateZipCode( "90001" ) );
38:     }
39: 
40:     @Test
41:     public void testAllUsersRegistered() {
42:         // given
43:         userTestHelper.registerAllUsers();
44:         EmailType email3 =
45:                 userTestHelper.getUserEmail( 3 );
46:         String name3 = userTestHelper.getUserName( 3 );
47:         AddressType address3 = userTestHelper.getUserAddress( 3 );
48: 
49:         // when
50:         UserType user3 = userRegistrationUseCases.getUserData(
51:                 email3 );
52: 
53:         // then
54:         Assertions.assertEquals( name3, user3.getName() );
55:         Assertions.assertEquals( email3, user3.getEmail() );
56:         Assertions.assertEquals( address3, user3.getAddress() );
57:     }
58: 
59: 
60:     @Test
61:     public void testRegisterUserWithDuplicateEmail() {
62:         // given
63:         userTestHelper.registerAllUsers();
64:         AddressType address5 = userTestHelper.getUserAddress( 5 );
65:         EmailType email5 =
66:                 userTestHelper.getUserEmail( 5 );
67: 
68:         // when
69:         // then
70:         assertThrows( ShopException.class, () ->
71:                 userRegistrationUseCases.register( "Gandalf The Grey",
72:                         email5, address5 ) );
73:     }
74: 
75: 
76:     @Test
77:     public void testRegisterUserWithDuplicateNameOrAddress() {
78:         // given
79:         userTestHelper.registerAllUsers();
80:         EmailType newEmail =
81:                 instantiateEmail( "some@this.de" );
82:         AddressType address2 = userTestHelper.getUserAddress( 2 );
83:         String name2 = userTestHelper.getUserName( 2 );
84: 
85:         // when
86:         // then
87:         assertDoesNotThrow( () ->
88:                 userRegistrationUseCases.register( name2, newEmail, address2 ) );
89:     }
90: 
91: 
92:     @Test
93:     public void testRegisterUserWithInvalidData() {
94:         // given
95:         EmailType email5 =
96:                 userTestHelper.getUserEmail( 5 );
97:         AddressType address5 = userTestHelper.getUserAddress( 5 );
98:         String name5 = userTestHelper.getUserName( 5 );
99: 
100:         // when
101:         // then
102:         assertThrows( ShopException.class, () ->
103:                 userRegistrationUseCases.register( null, email5, address5 ) );
104:         assertThrows( ShopException.class, () ->
105:                 userRegistrationUseCases.register("", email5, address5 ) );
106:         assertThrows( ShopException.class, () ->
107:                 userRegistrationUseCases.register( name5, null, address5 ) );
108:         assertThrows( ShopException.class, () ->
109:                 userRegistrationUseCases.register( name5, email5, null ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testChangeAddressWithInvalidData() {
115:         // given
116:         userTestHelper.registerAllUsers();
117:         AddressType address7 = userTestHelper.getUserAddress( 7 );
118:         EmailType email7 =
119:                 userTestHelper.getUserEmail( 7 );
120: 
121:         // when
122:         // then
123:         assertThrows( ShopException.class, () ->
124:                 userRegistrationUseCases.changeAddress( nonExistingEmail, address7 ) );
125:         assertThrows( ShopException.class, () ->
126:                 userRegistrationUseCases.changeAddress( null, address7 ) );
127:         assertThrows( ShopException.class, () ->
128:                 userRegistrationUseCases.changeAddress( email7, null ) );
129:     }
130: 
131: 
132:     @Test
133:     public void testGetDataForNonexistingEmail() {
134:         // given
135:         userTestHelper.registerAllUsers();
136: 
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 userRegistrationUseCases.getUserData( nonExistingEmail ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testDeleteUsersNoMoreUsers() {
146:         // given
147:         userTestHelper.registerAllUsers();
148:         EmailType email0 =
149:                 userTestHelper.getUserEmail( 0 );
150: 
151: 
152:         // when
153:         userRegistrationUseCases.deleteAllUsers();
154: 
155:         // then
156:         assertThrows( ShopException.class, () -> userRegistrationUseCases.getUserData(
157:                 email0 ) );
158:     }
159: 
160: 
161:     @Test
162:     public void testChangeAddressSuccessful() {
163:         // given
164:         userTestHelper.registerAllUsers();
165:         EmailType email6 =
166:                 userTestHelper.getUserEmail( 6 );
167: 
168:         // when
169:         userRegistrationUseCases.changeAddress( email6, someAddress );
170:         UserType newUser6 =
171:                 userRegistrationUseCases.getUserData( email6 );
172: 
173:         // then
174:         Assertions.assertEquals( email6, newUser6.getEmail() );
175:         Assertions.assertEquals( someAddress, newUser6.getAddress() );
176:     }
177: 
178: 
179:     @Test
180:     public void testChangeAddressForNonexistingEmail() {
181:         // given
182:         userTestHelper.registerAllUsers();
183: 
184:         // when
185:         // then
186:         assertThrows( ShopException.class, () ->
187:                 userRegistrationUseCases.changeAddress( nonExistingEmail, someAddress ) );
188:     }
189: 
190: 
191: }
192: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\user\UserRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.user;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
12: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
13: import thkoeln.archilab.ecommerce.usecases.UserType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
16: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
17: 
18: import java.util.UUID;
19: 
20: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
21: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
22: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
23: 
24: @SpringBootTest
25: @Transactional
26: @AutoConfigureMockMvc
27: @Import( RESTTestHelperConfiguration.class )
28: public class UserRESTTest {
29:     @Autowired
30:     private UserRegistrationUseCases userRegistrationUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private UserTestHelper userTestHelper;
35:     @Autowired
36:     private MockMvc mockMvc;
37: 
38:     private UUID randomId;
39:     private EmailType nonExistingEmail;
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         userTestHelper.registerAllUsers();
45: 
46:         nonExistingEmail = FactoryMethodInvoker.instantiateEmail(
47:                 "harry@sally.de" );
48:         randomId = UUID.randomUUID();
49:     }
50: 
51: 
52:     @Test
53:     public void testInvalidUserUris() throws Exception {
54:         // given
55:         String allUsersUri = "/users";
56:         String randomIdUri = "/users/" +  randomId;
57:         String nonExistingEmailUri = "/users?email=" + nonExistingEmail;
58:         String randomParamUri = "/users?randomParam=randomValue";
59: 
60:         // when
61:         // then
62:         mockMvc.perform( get( allUsersUri ) ).andExpect( status().isMethodNotAllowed() );
63:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
64:         mockMvc.perform( get( nonExistingEmailUri ) ).andExpect( status().isNotFound() );
65:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
66:     }
67: 
68: 
69:     @Test
70:     public void testRandomUserId() throws Exception {
71:         // given
72:         String invalidUri = "/users/" +  randomId;
73: 
74:         // when
75:         // then
76:         mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
77:     }
78: 
79: 
80:     @Test
81:     public void testQueryUser() throws Exception {
82:         // given
83:         EmailType email4 =
84:                 userTestHelper.getUserEmail( 4 );
85:         String userUri4 = "/users?email=" + email4;
86: 
87:         // when
88:         UserType user4 = userRegistrationUseCases.getUserData( email4 );
89:         String name = userTestHelper.getUserName( 4 );
90:         AddressType address4 = userTestHelper.getUserAddress( 4 );
91: 
92:         // then (check using JSONPath)
93:         mockMvc.perform( get( userUri4 ) )
94:                 .andExpect( status().isOk() )
95:                 .andExpect( jsonPath( "$.name" ).value( name ) )
96:                 // id is position 0 (cannot be tested with current API structure), name is position 1,
97:                 // email is 2, address is 3)
98:                 .andExpect( jsonPath( "$..emailString" ).value( email4.toString() ) )
99:                 .andExpect( jsonPath( "$..city" ).value( address4.getCity() ) )
100:                 .andExpect( jsonPath( "$..zipCodeString" ).value(
101:                         address4.getZipCode().toString() ) );
102:     }
103: 
104: }
105: 

[RESPONSE]:
Hier ist das Review des Codes basierend auf den angegebenen Regeln und Kriterien.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Currency.java
[Currency.java] [Zeile(n) 54]: [negative conditionals] : [Überprüfung auf `== false` ist eine doppelte Negierung und schwerer lesbar als `!condition`.]
[Currency.java] [Zeile(n) 71]: [Duplication] [54] : [Identische Überprüfung der Währungseinheit inkl. Exception-Wurf.]
[Currency.java] [Zeile(n) 71]: [negative conditionals] : [Überprüfung auf `== false`.]
[Currency.java] [Zeile(n) 105]: [Duplication] [54] : [Identische Überprüfung der Währungseinheit inkl. Exception-Wurf.]
[Currency.java] [Zeile(n) 105]: [negative conditionals] : [Überprüfung auf `== false`.]
[Currency.java] [Zeile(n) 136]: [negative conditionals] : [Überprüfung auf `== false`.]

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Email.java
[Email.java] [Zeile(n) 123]: [negative conditionals] : [Negierung einer Regex-Prüfung innerhalb einer komplexen Bedingung ist schwer verständlich.]

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java
[ZipCode.java] [Zeile(n) 79]: [negative conditionals] : [Überprüfung auf `== false`.]
[ZipCode.java] [Zeile(n) 86]: [negative conditionals] : [Überprüfung auf `== false`.]

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ItemService.java
[ItemService.java] [Zeile(n) 63-65]: [Duplication] [60-62] : [Identische Logik zur Überprüfung, ob ein Preis <= 0 ist und Werfen derselben Exception.]
[ItemService.java] [Zeile(n) 138]: [negative conditionals] : [Doppelte Negierung durch `!(... != ...)`.]

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\Item.java
[Item.java] [-Anemic Entity-] : [Klasse enthält nur Daten (Felder) und Getter/Setter, aber keine Geschäftslogik.]

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java
[Order.java] [-Anemic Entity-] : [Klasse agiert primär als Datencontainer. Die Methode `addToOrderPosition` ist lediglich ein Wrapper für List-Operationen ohne Domänenlogik.]

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPosition.java
[OrderPosition.java] [-Anemic Entity-] : [Reiner Datencontainer mit Gettern/Settern.]

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartService.java
[ShoppingCartService.java] [Zeile(n) 101]: [Duplication] [73] : [Identische Prüfung auf negative Quantität.]
[ShoppingCartService.java] [Zeile(n) 102]: [Duplication] [74] : [Identische Prüfung auf Existenz der ItemId.]
[ShoppingCartService.java] [Zeile(n) 188-222]: [missplaced resonsibility] : [Die Checkout-Logik (Berechnung virtueller Warenkörbe, Aufteilung auf StorageUnits) ist komplexe Geschäftslogik und gehört in einen Domain Service oder das Aggregat, nicht direkt in den Application Service.]
[ShoppingCartService.java] [Zeile(n) 251]: [negative conditionals] : [Negierung einer Existenzprüfung `!userExists`.]

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPosition.java
[ShoppingCartPosition.java] [-Anemic Entity-] : [Reiner Datencontainer mit Gettern/Settern.]

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\StorageUnitService.java
[StorageUnitService.java] [Zeile(n) 58-71]: [Duplication] [43-55] : [Die Methoden `removeFromInventory` und `addToInventory` teilen sich fast die identische Struktur (Validierung, Laden, Modifizieren, Speichern).]

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\InventoryLevel.java
[InventoryLevel.java] [-Anemic Entity-] : [Reiner Datencontainer.]

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserService.java
[UserService.java] [Zeile(n) 58]: [negative conditionals] : [Überprüfung auf `== false`.]
[UserService.java] [Zeile(n) 83-88]: [Duplication] [55-60] : [Wiederholung der Validierungslogik für Adressfelder und ZipCode.]
[UserService.java] [Zeile(n) 86]: [negative conditionals] : [Überprüfung auf `== false`.]
[UserService.java] [Zeile(n) 149]: [negative conditionals] : [Negierung von `userExists`.]

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\User.java
[User.java] [-Anemic Entity-] : [Klasse enthält fast nur Daten. Die Validierungsmethode ist statisch und operiert nicht auf dem Instanz-Status.]

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java
[OwnTestsTest.java] [Zeile(n) 7-8]: [dead code] : [Leere Testklasse, die als OBSOLETE markiert ist.]

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_f3a01ef6-4afc-4868-8c21-be2d7968e05d\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingCartRESTTest.java
[OwnShoppingCartRESTTest.java] [Zeile(n) 137-153]: [Duplication] [110-123] : [Sehr ähnlicher Testaufbau (Hinzufügen von Items, Abrufen des Warenkorbs) in `test_delete_ShoppingCartPositions` verglichen mit `test_post_ShoppingCartPositions`.]

ENDE
Generated by gemini-3-pro-preview
-----------------------------------