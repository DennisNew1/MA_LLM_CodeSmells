--- DATE: 13.1.2026, 15:02:12 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
        Architektur: 4-Layer (Eric Evans).
        Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
        Regeln:
        1. Begründe kurz jeden Fund.
        4. Gruppiere nach Datei (mit Pfad). 
        2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
        3. Keine Code-Wiederholung, nur Referenzen.
        5. Wenn fertig, schreibe "ENDE". 
        6. Nutze die Zeilenangaben die mitgeschickt worden sind.



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Currency.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import jakarta.persistence.Embeddable;
5: import lombok.*;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
8: 
9: import java.util.Locale;
10: 
11: @Getter
12: @Embeddable
13: @EqualsAndHashCode
14: @NoArgsConstructor(access = AccessLevel.PROTECTED) // für JPA
15: @AllArgsConstructor(access = AccessLevel.PRIVATE)
16: public class Currency implements CurrencyType {
17: 
18:     private enum AllowedCurrencyUnit {EUR, CHF}
19: 
20:     @JsonProperty("amount")
21:     private Float amount;
22: 
23:     @JsonProperty("unit")
24:     private String currencyUnit;
25: 
26:     public static Currency of(Float amount, String currencyUnit) {
27:         if (!isValidCurrency(amount, currencyUnit))
28:             throw new ShopException("Amount must not be null or negative.");
29: 
30:         try {
31:             AllowedCurrencyUnit.valueOf(currencyUnit);
32:         } catch (IllegalArgumentException e) {
33:             throw new ShopException("Invalid currency unit: " + currencyUnit);
34:         }
35: 
36:         return new Currency(amount, currencyUnit);
37:     }
38: 
39:     @Override
40:     public Float getQuantity() {
41:         return this.amount;
42:     }
43: 
44:     @Override
45:     public String getCurrencyUnit() {
46:         return this.currencyUnit;
47:     }
48: 
49:     @Override
50:     public CurrencyType add(CurrencyType otherCurrency) {
51:         validateOtherCurrency(otherCurrency);
52:         float result = this.amount + otherCurrency.getQuantity();
53:         return new Currency(result, this.currencyUnit);
54:     }
55: 
56:     @Override
57:     public CurrencyType subtract(CurrencyType otherCurrency) {
58:         validateOtherCurrency(otherCurrency);
59:         if (otherCurrency.getQuantity() > this.amount) {
60:             throw new ShopException("Subtracted amount must not be greater than current amount.");
61:         }
62:         float result = this.amount - otherCurrency.getQuantity();
63:         return new Currency(result, this.currencyUnit);
64:     }
65: 
66:     @Override
67:     public CurrencyType multiplyBy(int factor) {
68:         if (factor < 0) {
69:             throw new ShopException("Factor must not be negative.");
70:         }
71:         float result = this.amount * factor;
72:         return new Currency(result, this.currencyUnit);
73:     }
74: 
75:     @Override
76:     public boolean largerThan(CurrencyType otherCurrency) {
77:         validateOtherCurrency(otherCurrency);
78:         return this.amount > otherCurrency.getQuantity();
79:     }
80: 
81:     private void validateOtherCurrency(CurrencyType otherCurrency) {
82:         if (otherCurrency == null) {
83:             throw new ShopException("Other currency must not be null.");
84:         }
85:         if (!this.currencyUnit.equals(otherCurrency.getCurrencyUnit())) {
86:             throw new ShopException("Currency units must match.");
87:         }
88:     }
89: 
90:     @Override
91:     public String toString() {
92:         java.text.DecimalFormat df = new java.text.DecimalFormat("0.00");
93:         df.setDecimalFormatSymbols(java.text.DecimalFormatSymbols.getInstance(Locale.getDefault()));
94: 
95:         String symbol = currencyUnit.equals("EUR") ? "€" : currencyUnit;
96:         return df.format(this.amount) + " " + symbol;
97:     }
98: 
99:     public static boolean isValidCurrency(Float amount, String currencyUnit){
100:         if (amount == null || amount < 0)
101:             return false;
102:         if (currencyUnit == null)
103:             return false;
104:         return true;
105:     }
106: }
107: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\EmailAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import jakarta.persistence.Embeddable;
5: import lombok.*;
6: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.ConflictException;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
8: 
9: @Getter
10: @Embeddable
11: @EqualsAndHashCode
12: @NoArgsConstructor(access = AccessLevel.PROTECTED) // für JPA
13: @AllArgsConstructor(access = AccessLevel.PRIVATE)
14: public class EmailAddress implements EmailAddressType {
15: 
16:     @JsonProperty("emailAddressString")
17:     private String email;
18: 
19:     public static EmailAddress of(String emailStr) {
20:         if(!isValidEmail(emailStr))
21:             throw new ConflictException("Email address is not a valid email address");
22:         return new EmailAddress(emailStr);
23:     }
24: 
25:     @Override
26:     public EmailAddressType sameIdentifyerDifferentDomain(String newDomain) {
27:         if (newDomain == null) throw new ConflictException("Domain part must not be null.");
28:         String identifier = getIdentifierPart();
29:         return EmailAddress.of(identifier + "@" + newDomain);
30:     }
31: 
32:     @Override
33:     public EmailAddressType sameDomainDifferentIdentifyer(String newIdentifier) {
34:         if (newIdentifier == null) throw new ConflictException("Identifier part must not be null.");
35:         String domain = getDomainPart();
36:         return EmailAddress.of(newIdentifier + "@" + domain);
37:     }
38: 
39:     @Override
40:     public String toString() {
41:         return email;
42:     }
43: 
44:     private static boolean isValidEmail(String emailStr) {
45:         if(emailStr == null)
46:             throw new ConflictException("Email address is not a valid email address");
47: 
48:         String[] parts = emailStr.split("@");
49:         if (parts.length != 2) return false;
50: 
51:         String localPart = parts[0];
52:         String domainPart = parts[1];
53: 
54:         if (localPart.isEmpty() || domainPart.isEmpty()) return false;
55:         if (emailStr.matches(".*\\s.*")) return false;
56:         if (!localPart.matches("[A-Za-z0-9._-]+")) return false;
57:         if (!domainPart.matches("[A-Za-z0-9.-]+")) return false;
58:         if (emailStr.contains("..")) return false;
59:         if (!domainPart.matches(".*\\.(de|at|ch|com|org|fr)$")) return false;
60: 
61:         return true;
62:     }
63: 
64:     private String getIdentifierPart() {
65:         return email.split("@")[0];
66:     }
67: 
68:     private String getDomainPart() {
69:         return email.split("@")[1];
70:     }
71: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\ConflictException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.CONFLICT, reason = "Violating a business rule")
8: public class ConflictException extends ShopException {
9:     public ConflictException( String message ) {
10:         super( message );
11:     }
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\MethodNotAllowedException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(HttpStatus.METHOD_NOT_ALLOWED)
8: public class MethodNotAllowedException extends ShopException {
9:     public MethodNotAllowedException(String message) {
10:         super(message);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\UnprocessableEntityException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY, reason = "Unprocessable Entity")
8: public class UnprocessableEntityException extends ShopException {
9:     public UnprocessableEntityException( String message ) {
10:         super( message );
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PhysicalAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import jakarta.persistence.Embeddable;
5: import jakarta.persistence.Embedded;
6: import lombok.*;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
10: 
11: @Getter
12: @Embeddable
13: @EqualsAndHashCode
14: @NoArgsConstructor(access = AccessLevel.PROTECTED) // für JPA
15: @AllArgsConstructor(access = AccessLevel.PRIVATE)
16: public class PhysicalAddress implements PhysicalAddressType {
17: 
18:     @JsonProperty("street")
19:     private String street;
20: 
21:     @JsonProperty("city")
22:     private String city;
23: 
24:     @Embedded
25:     @JsonProperty("postalCode")
26:     private PostalCode postalCode;
27: 
28:     public static PhysicalAddress of(String street, String city, PostalCodeType postalCode) {
29:         if (street == null || street.trim().isEmpty()) {
30:             throw new ShopException("Street must not be null or empty");
31:         }
32:         if (city == null || city.trim().isEmpty()) {
33:             throw new ShopException("City must not be null or empty");
34:         }
35:         if (!(postalCode instanceof PostalCode)) {
36:             throw new ShopException("Postal code must not be null and must be a PostalCode");
37:         }
38: 
39:         return new PhysicalAddress(street.trim(), city.trim(), (PostalCode) postalCode);
40:     }
41: 
42:     @Override
43:     public PostalCodeType getPostalCode() {
44:         return postalCode;
45:     }
46: }
47: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PostalCode.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import jakarta.persistence.Embeddable;
5: import lombok.*;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
8: 
9: @Getter
10: @Embeddable
11: @EqualsAndHashCode
12: @NoArgsConstructor(access = AccessLevel.PROTECTED) // für JPA
13: @AllArgsConstructor(access = AccessLevel.PRIVATE)
14: public class PostalCode implements PostalCodeType {
15: 
16:     @JsonProperty("postalCodeString")
17:     private String postalCode;
18: 
19:     public static PostalCode of(String postalCodeStr) {
20:         if (postalCodeStr == null)
21:             throw new ShopException("Postal code must not be null.");
22:         if(!isValidPostalCode(postalCodeStr))
23:             throw new ShopException("Postal code not valid.");
24: 
25:         return new PostalCode(postalCodeStr);
26:     }
27: 
28:     public int distance(PostalCodeType otherPostalCode) throws ShopException {
29:         if (otherPostalCode == null)
30:             throw new ShopException("Postleitzahl darf nicht null sein");
31: 
32: 
33:         String plz1 = this.toString();
34:         String plz2 = otherPostalCode.toString();
35: 
36:         if (plz1.equals(plz2)) {
37:             return 0;
38:         }
39: 
40:         // 1. Schritt: Regionale Prüfung über erste Ziffer
41:         int region1 = plz1.charAt(0);
42:         int region2 = plz2.charAt(0);
43: 
44:         int regionDistance = Math.min(
45:                 Math.abs(region1 - region2),
46:                 10 - Math.abs(region1 - region2)
47:         );
48: 
49:         // 2. Schritt: Feiner Vergleich – finde erste unterschiedliche Ziffer ab Position 1 (zweite Stelle)
50:         int distance = 0;
51:         int plz1Length = postalCode.length();
52:         for (int i = 1; i < plz1Length; i++) {
53:             if (plz1.charAt(i) != plz2.charAt(i)) {
54:                 distance = plz1Length - i;  // Je weiter links der Unterschied, desto größer die Zahl (max 4, min 1)
55:                 break;
56:             }
57:         }
58: 
59:         int totalDistance = distance + regionDistance;
60:         return totalDistance;
61:     }
62: 
63:     private static boolean isValidPostalCode(String postalCodeStr) {
64:         if (!postalCodeStr.matches("\\d{5}"))
65:             return false;
66:         if (postalCodeStr.substring(1).equals("0000"))
67:             return false;
68:         return true;
69:     }
70: 
71:     @Override
72:     public Integer getFirstDigitPostalCode() {
73:         return Integer.parseInt(postalCode.substring(0, 1));
74:     }
75: 
76:     @Override
77:     public String toString() {
78:         return postalCode;
79:     }
80: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.Column;
7: import jakarta.persistence.MappedSuperclass;
8: import lombok.EqualsAndHashCode;
9: import lombok.Getter;
10: import lombok.ToString;
11: 
12: import java.io.Serializable;
13: import java.util.UUID;
14: 
15: @MappedSuperclass
16: @Getter
17: @EqualsAndHashCode(of = "id")
18: @ToString(of = "id")
19: public abstract class GenericId implements Serializable {
20:     @Column(nullable = false, updatable = false)
21:     private final UUID id;
22: 
23:     protected GenericId() {
24:         this( UUID.randomUUID() );
25:     }
26: 
27:     protected GenericId( UUID id ) {
28:         this.id = id;
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.AttributeConverter;
7: 
8: import java.util.UUID;
9: import java.util.function.Function;
10: 
11: 
12: public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
13:     private final Function<UUID, T> factory;
14: 
15:     protected GenericIdConverter( Function<UUID, T> factory ) {
16:         this.factory = factory;
17:     }
18: 
19:     @Override
20:     public UUID convertToDatabaseColumn( T attribute ) {
21:         return attribute == null ? null : attribute.getId();
22:     }
23: 
24:     @Override
25:     public T convertToEntityAttribute( UUID dbData ) {
26:         return dbData == null ? null : factory.apply( dbData );
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\InsufficientStockException.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: /**
7:  * Exception is thrown if the product's stock level is not sufficient to serve the purchase.
8:  */
9: public class InsufficientStockException extends ShopException {
10:     public InsufficientStockException( String message ) {
11:         super( message );
12:     }
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import org.springframework.boot.SpringApplication;
7: import org.springframework.boot.autoconfigure.SpringBootApplication;
8: 
9: 
10: @SpringBootApplication
11: public class ProjectApplication {
12: 
13: 	/**
14: 	 * Entry method
15: 	 * @param args
16: 	 */
17: 	public static void main(String[] args) {
18: 		SpringApplication.run(ProjectApplication.class, args);
19: 	}
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: public class ShopException extends RuntimeException {
7:     public ShopException( String message ) {
8:         super( message );
9:     }
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\application\DepotableService.java ---
1: package thkoeln.archilab.ecommerce.solution.depot.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.solution.product.application.DepotableServiceInterface;
5: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
6: 
7: @Service
8: public class DepotableService implements DepotableServiceInterface {
9:     private final DepotService depotService;
10: 
11:     public DepotableService(DepotService depotService) {
12:         this.depotService = depotService;
13:     }
14: 
15:     @Override
16:     public boolean existsProductInDepotByProductId(ProductId productId) {
17:         return depotService.existsProductInDepotByProductId(productId);
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\application\DepotAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.depot.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
6: import thkoeln.archilab.ecommerce.solution.depot.domain.DepotId;
7: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
8: import thkoeln.archilab.ecommerce.usecases.DepotUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: 
11: import java.util.UUID;
12: 
13: @Service
14: public class DepotAdapterService implements DepotUseCases {
15: 
16:     private final DepotService depotService;
17: 
18:     public DepotAdapterService(
19:             DepotService depotService
20:     ) {
21:         this.depotService = depotService;
22:     }
23: 
24:     @Override
25:     public UUID addNewDepot(String name, PhysicalAddressType physicalAddress) {
26:         if (physicalAddress == null) throw new ShopException("Physical address must not be null");
27: 
28:         PhysicalAddress newPhysicalAddress = (PhysicalAddress) physicalAddress;
29:         DepotId depotId = depotService.addNewDepot(name, newPhysicalAddress);
30:         return depotId.getId();
31:     }
32: 
33:     @Override
34:     public void deleteAllDepots() {
35:         depotService.deleteAllDepots();
36:     }
37: 
38:     public UUID findSuitableDepot(String postalCode) {
39:         DepotId depotId = depotService.findSuitableDepot(postalCode);
40:         return depotId.getId();
41:     }
42: 
43:     @Override
44:     public void addToStock(UUID depotId, UUID productId, int addedQuantOf) {
45:         DepotId newDepotId = new DepotId(depotId);
46:         ProductId newProductId = new ProductId(productId);
47:         depotService.addToStock(newDepotId, newProductId, addedQuantOf);
48:     }
49: 
50:     @Override
51:     public void removeFromStock(UUID depotId, UUID productId, int removedQuantOf) {
52:         DepotId newDepotId = new DepotId(depotId);
53:         ProductId newProductId = new ProductId(productId);
54:         depotService.removeFromStock(newDepotId, newProductId, removedQuantOf);
55:     }
56: 
57:     @Override
58:     public void changeStockTo(UUID depotId, UUID productId, int newTotalQuantOf) {
59:         DepotId newDepotId = new DepotId(depotId);
60:         ProductId newProductId = new ProductId(productId);
61:         depotService.changeStockTo(newDepotId, newProductId, newTotalQuantOf);
62:     }
63: 
64:     @Override
65:     public int getAvailableStock(UUID depotId, UUID productId) {
66:         DepotId newDepotId = new DepotId(depotId);
67:         ProductId newProductId = new ProductId(productId);
68:         return depotService.getAvailableStock(newDepotId, newProductId);
69:     }
70: }
71: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\application\DepotService.java ---
1: package thkoeln.archilab.ecommerce.solution.depot.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
6: import thkoeln.archilab.ecommerce.solution.depot.domain.Depot;
7: import thkoeln.archilab.ecommerce.solution.depot.domain.DepotId;
8: import thkoeln.archilab.ecommerce.solution.depot.domain.DepotRepository;
9: import thkoeln.archilab.ecommerce.solution.depot.domain.StockLevel;
10: import thkoeln.archilab.ecommerce.solution.product.application.ProductService;
11: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
12: 
13: import java.util.ArrayList;
14: import java.util.List;
15: 
16: import static thkoeln.archilab.ecommerce.solution.depot.domain.Address.validatePostalCode;
17: 
18: @Service
19: public class DepotService {
20:     private final DepotRepository depotRepository;
21:     private final ProductService productService;
22: 
23:     public DepotService(
24:             DepotRepository depotRepository,
25:             ProductService productService
26:     ) {
27:         this.depotRepository = depotRepository;
28:         this.productService = productService;
29:     }
30: 
31:     public DepotId addNewDepot(String name, PhysicalAddress physicalAddress) {
32:         validateDepotName(name);
33: 
34:         Depot newDepot = new Depot(name, physicalAddress);
35: 
36:         depotRepository.save(newDepot);
37:         return newDepot.getId();
38:     }
39: 
40:     public void deleteAllDepots() {
41:         depotRepository.deleteAll();
42:     }
43: 
44:     public DepotId findSuitableDepot(String postalCode) {
45:         validatePostalCode(postalCode);
46: 
47:         Integer firstDigit = Integer.parseInt(postalCode.substring(0, 1));
48: 
49:         List<Depot> suitableDepots = depotRepository.findSuitableDepots(firstDigit);
50:         if(suitableDepots.isEmpty()) throw new ShopException("No suitable depot found");
51: 
52:         return suitableDepots.getFirst().getId();
53:     }
54: 
55:     public void addToStock(DepotId depotId, ProductId productId, int addedQuantOf) {
56:         if(addedQuantOf == 0) return;
57: 
58:         validateDepotId(depotId);
59:         productService.validateProductId(productId);
60:         validateQuantity(addedQuantOf);
61: 
62:         if(!productService.existsProductByProductId(productId)) throw new ShopException("Product does not exist");
63: 
64:         Depot depot = depotRepository.findDepotById(depotId)
65:                 .orElseThrow(() -> new ShopException("No such depot"));
66: 
67:         StockLevel stockLevel = depot.findStockLevelByProductId(productId)
68:                 .orElseGet(() -> null);
69: 
70:         if(stockLevel == null) {
71:             stockLevel = new StockLevel(productId, addedQuantOf);
72:             depot.getStockLevels().add(stockLevel);
73:         }
74:         else {
75:             int oldQuantOf = stockLevel.getQuantity();
76:             int newQuantOf = oldQuantOf + addedQuantOf;
77:             stockLevel.setQuantity(newQuantOf);
78:         }
79:         depotRepository.save(depot);
80:     }
81: 
82:     public void removeFromStock(DepotId depotId, ProductId productId, int removedQuantOf) {
83:         if(removedQuantOf == 0) return;
84:         validateDepotId(depotId);
85:         productService.validateProductId(productId);
86:         validateQuantity(removedQuantOf);
87: 
88:         if(!productService.existsProductByProductId(productId)) throw new ShopException("Product does not exist");
89: 
90:         Depot depot = depotRepository.findDepotById(depotId)
91:                 .orElseThrow(() -> new ShopException("No such depot"));
92: 
93:         StockLevel stockLevel = depot.findStockLevelByProductId(productId)
94:                 .orElseThrow(() -> new ShopException("No such stock level"));
95: 
96:         int oldQuantOf = stockLevel.getQuantity();
97: 
98:         if(oldQuantOf - removedQuantOf < 0) throw new ShopException("Quantity is too big");
99:         else if (oldQuantOf - removedQuantOf == 0) {
100:             depot.removeStockLevel(stockLevel);
101:         }
102:         else {
103:             stockLevel.setQuantity(oldQuantOf - removedQuantOf);
104:         }
105:         depotRepository.save(depot);
106:     }
107: 
108:     public void changeStockTo(DepotId depotId, ProductId productId, int newTotalQuantOf) {
109:         validateDepotId(depotId);
110:         productService.validateProductId(productId);
111:         if(newTotalQuantOf < 0) throw new ShopException("Quantity is too small");
112: 
113:         if(!productService.existsProductByProductId(productId)) throw new ShopException("Product does not exist");
114: 
115:         Depot depot = depotRepository.findDepotById(depotId)
116:                 .orElseThrow(() -> new ShopException("No such depot"));
117: 
118:         StockLevel stockLevel = depot.findStockLevelByProductId(productId)
119:                 .orElseGet(() -> null);
120: 
121:         if (stockLevel == null) {
122:             if(newTotalQuantOf > 0) {
123:                 StockLevel newStockLevel = new StockLevel(productId, newTotalQuantOf);
124:                 depot.getStockLevels().add(newStockLevel);
125:                 depotRepository.save(depot);
126:                 return;
127:             }
128:         }
129: 
130:         if(newTotalQuantOf == 0) {
131:             depot.removeStockLevel(stockLevel);
132:         }
133:         else {
134:             stockLevel.setQuantity(newTotalQuantOf);
135:         }
136:         depotRepository.save(depot);
137:     }
138: 
139:     public int getAvailableStock(DepotId depotId, ProductId productId) {
140:         validateDepotId(depotId);
141:         productService.validateProductId(productId);
142:         if(!productService.existsProductByProductId(productId)) throw new ShopException("Product does not exist");
143: 
144:         Depot depot = depotRepository.findDepotById(depotId)
145:                 .orElseThrow(() -> new ShopException("No such depot"));
146: 
147:         StockLevel stockLevel = depot.findStockLevelByProductId(productId)
148:                 .orElseGet(() -> null);
149: 
150:         if (stockLevel == null) return 0;
151:         else return stockLevel.getQuantity();
152:     }
153: 
154:     public boolean existsProductInDepotByProductId(ProductId productId) {
155:         for (Depot depot : depotRepository.findAll()) {
156:             if (depot.findStockLevelByProductId(productId).isPresent()) {
157:                 return true;
158:             }
159:         }
160:         return false;
161:     }
162: 
163:     public List<Depot> getAllDepots() {
164:         List<Depot> depots = new ArrayList<>();
165:         for (Depot depot : depotRepository.findAll()) {
166:             depots.add(depot);
167:         }
168:         return depots;
169:     }
170: 
171: 
172:     // VALIDATE
173:     public void validateFromToDigitRange(Integer from, Integer to) {
174:         if(from > to) throw new ShopException("Depot FROM must be greater than or equal to TO");
175:     }
176:     public void validateDepotName(String depotName) {
177:         if(depotName == null || depotName.isEmpty()) {
178:             throw new ShopException("Depot name cannot be empty");
179:         }
180:     }
181:     public void validatePostalCodeDigit(Integer digit) {
182:         if(digit == null || digit > 9 || digit < 0) {
183:             throw new ShopException("Digit must be between 0 and 9");
184:         }
185:     }
186:     public void validateDepotId(DepotId depotId) {
187:         if(depotId == null) {
188:             throw new ShopException("DepotId cannot be null");
189:         }
190:     }
191:     public void validateQuantity(int quantity) {
192:         if(quantity < 0) {
193:             throw new ShopException("Quantity cannot be negative");
194:         }
195:     }
196: }
197: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\Address.java ---
1: package thkoeln.archilab.ecommerce.solution.depot.domain;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.AllArgsConstructor;
5: import lombok.EqualsAndHashCode;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.ShopException;
9: 
10: @Embeddable
11: @Getter
12: @NoArgsConstructor
13: @AllArgsConstructor
14: @EqualsAndHashCode
15: public class Address {
16:     private String street;
17:     private String city;
18:     private String postalCode;
19: 
20:     static public void validateAddress(String street, String city, String postalCode) {
21:         if(street == null || street.isEmpty()) {
22:             throw new ShopException("Street cannot be null or empty.");
23:         }
24:         if(city == null || city.isEmpty()) {
25:             throw new ShopException("City cannot be null or empty.");
26:         }
27:         validatePostalCode(postalCode);
28:     }
29:     static public void validatePostalCode(String postalCode) {
30:         if(postalCode == null || postalCode.isEmpty()) {
31:             throw new ShopException("PostalCode cannot be null or empty.");
32:         }
33:     }
34: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\Depot.java ---
1: package thkoeln.archilab.ecommerce.solution.depot.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.*;
5: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
6: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
7: 
8: import java.util.*;
9: 
10: @Entity
11: @Getter
12: @AllArgsConstructor
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: public class Depot {
15: 
16:     @Setter(AccessLevel.PRIVATE)
17:     @EmbeddedId
18:     private DepotId id;
19: 
20:     @Setter
21:     private String name;
22: 
23:     @Setter
24:     private Integer fromPostalCodeFirstDigit;
25: 
26:     @Setter
27:     private Integer toPostalCodeFirstDigit;
28: 
29:     @Embedded
30:     private PhysicalAddress address;
31: 
32:     @Setter
33:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
34:     List<StockLevel> stockLevels = new ArrayList<>();
35: 
36:     public Depot(String name, PhysicalAddress physicalAddress) {
37:         this.id = new DepotId();
38:         this.name = name;
39:         this.address = physicalAddress;
40:     }
41: 
42:     public Optional<StockLevel> findStockLevelByProductId(ProductId productId) {
43:         for (StockLevel stockLevel : stockLevels) {
44:             if( stockLevel.getProductId().equals(productId)) {
45:                 return Optional.of(stockLevel);
46:             }
47:         }
48:         return Optional.empty();
49:     }
50: 
51:     public void removeStockLevel(StockLevel stockLevel) {
52:         stockLevels.remove(stockLevel);
53:     }
54: 
55:     public Set<ProductId> fulfillableShoppingBasketPositions(Map<ProductId, Integer> productQuantityMap) {
56:         Set<ProductId> fulfillableProducts = new HashSet<>();
57: 
58:         for (Map.Entry<ProductId, Integer> entry : productQuantityMap.entrySet()) {
59:             ProductId productId = entry.getKey();
60:             Integer requiredQuantity = entry.getValue();
61: 
62:             Optional<StockLevel> optionalStockLevel = findStockLevelByProductId(productId);
63: 
64:             if (optionalStockLevel.isPresent() && optionalStockLevel.get().getQuantity() >= requiredQuantity) {
65:                 fulfillableProducts.add(productId);
66:             }
67:         }
68: 
69:         return fulfillableProducts;
70:     }
71: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\DepotComparator.java ---
1: package thkoeln.archilab.ecommerce.solution.depot.domain;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
4: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
5: 
6: import java.util.Comparator;
7: import java.util.Map;
8: import java.util.Set;
9: 
10: public class DepotComparator implements Comparator<Depot> {
11: 
12:     private final Map<ProductId, Integer> shoppingBasket;
13:     private final PhysicalAddress customerAddress;
14: 
15:     public DepotComparator(
16:             Map<ProductId, Integer> shoppingBasket,
17:             PhysicalAddress customerAddress
18:     ) {
19:         this.shoppingBasket = shoppingBasket;
20:         this.customerAddress = customerAddress;
21:     }
22: 
23:     @Override
24:     public int compare(Depot depot1, Depot depot2) {
25:         Set<ProductId> fulfillable1 = depot1.fulfillableShoppingBasketPositions(shoppingBasket);
26:         Set<ProductId> fulfillable2 = depot2.fulfillableShoppingBasketPositions(shoppingBasket);
27: 
28:         int size1 = fulfillable1.size();
29:         int size2 = fulfillable2.size();
30: 
31:         if (size1 != size2) {
32:             return Integer.compare(size2, size1); // mehr erfüllbare Positionen = besser
33:         }
34: 
35:         // Falls gleich viele erfüllbare Positionen, vergleiche Entfernung
36:         double distance1 = depot1.getAddress().getPostalCode().distance(customerAddress.getPostalCode());
37:         double distance2 = depot2.getAddress().getPostalCode().distance(customerAddress.getPostalCode());
38: 
39:         return Double.compare(distance1, distance2); // kürzere Entfernung = besser
40:     }
41: }
42: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\DepotId.java ---
1: package thkoeln.archilab.ecommerce.solution.depot.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "depot_id"))
15: public class DepotId extends GenericId {
16:     public DepotId( UUID id ) {
17:         super( id );
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\DepotIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.depot.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
6: 
7: @Converter(autoApply = true)
8: public class DepotIdConverter extends GenericIdConverter<DepotId> {
9:     public DepotIdConverter() {
10:         super(DepotId::new);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\DepotRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.depot.domain;
2: 
3: import org.springframework.data.jpa.repository.Query;
4: import org.springframework.data.repository.CrudRepository;
5: import org.springframework.data.repository.query.Param;
6: import org.springframework.stereotype.Repository;
7: 
8: import java.util.List;
9: import java.util.Optional;
10: 
11: @Repository
12: public interface DepotRepository extends CrudRepository<Depot, DepotId> {
13:     Optional<Depot> findDepotById(DepotId id);
14: 
15:     @Query("SELECT d FROM Depot d WHERE :postalCodeDigit BETWEEN d.fromPostalCodeFirstDigit AND d.toPostalCodeFirstDigit")
16:     List<Depot> findSuitableDepots(@Param("postalCodeDigit") Integer postalCodeDigit);
17: }
18: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\StockLevel.java ---
1: package thkoeln.archilab.ecommerce.solution.depot.domain;
2: 
3: import jakarta.persistence.EmbeddedId;
4: import jakarta.persistence.Entity;
5: import lombok.*;
6: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
7: 
8: @Getter
9: @Entity
10: @AllArgsConstructor
11: @NoArgsConstructor(access = AccessLevel.PROTECTED)
12: public class StockLevel {
13: 
14:     @Setter(AccessLevel.PRIVATE)
15:     @EmbeddedId
16:     private StockLevelId id;
17: 
18:     @Setter
19:     private Integer quantity;
20: 
21:     @Setter
22:     //@ManyToOne
23:     private ProductId productId;
24: 
25:     public StockLevel(ProductId productId, Integer quantity) {
26:         this.id = new StockLevelId();
27:         this.productId = productId;
28:         this.quantity = quantity;
29:     }
30: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\StockLevelId.java ---
1: package thkoeln.archilab.ecommerce.solution.depot.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "stock_level_id"))
15: public class StockLevelId extends GenericId {
16:     public StockLevelId( UUID id ) {
17:         super( id );
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\StockLevelIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.depot.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class StockLevelIdConverter extends GenericIdConverter<StockLevelId> {
8:     public StockLevelIdConverter() {
9:         super(StockLevelId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\DepotableServiceInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: 
3: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
4: 
5: public interface DepotableServiceInterface {
6:     public boolean existsProductInDepotByProductId(ProductId productId);
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
7: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
8: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
10: 
11: import java.util.UUID;
12: 
13: @Service
14: public class ProductAdapterService implements ProductCatalogUseCases {
15:     private final ProductService productService;
16:     private final RemoveAdapterService removeAdapterService;
17: 
18:     @Autowired
19:     public ProductAdapterService(
20:             ProductService productService,
21:             RemoveAdapterService removeAdapterService) {
22:         this.productService = productService;
23:         this.removeAdapterService = removeAdapterService;
24:     }
25: 
26:     @Override
27:     public UUID addProductToCatalog(String name, String descriptFor, Float size, CurrencyType buyingPrice, CurrencyType salesPrice) {
28:         if(buyingPrice == null) throw new ShopException("buyingPrice is null");
29:         if(salesPrice == null) throw new ShopException("salesPrice is null");
30: 
31:         Currency newBuyingPrice = (Currency) buyingPrice;
32:         Currency newSalesPrice = (Currency) salesPrice;
33: 
34:         ProductId productId = productService.addProductToCatalog(
35:                 name,
36:                 descriptFor,
37:                 size,
38:                 newBuyingPrice,
39:                 newSalesPrice
40:         );
41:         return productId.getId();
42:     }
43: 
44:     @Override
45:     public void removeProductFromCatalog(UUID productId) {
46:         ProductId newProductId = new ProductId(productId);
47:         removeAdapterService.removeProductFromCatalog(newProductId);
48:     }
49: 
50:     @Override
51:     public Currency getSalesPrice(UUID productId) {
52:         ProductId newProductId = new ProductId(productId);
53:         return productService.getSalesPrice(newProductId);
54:     }
55: 
56:     @Override
57:     public void deleteProductCatalog() {
58:         productService.deleteProductCatalog();
59:     }
60: }
61: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductService.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
6: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
7: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
8: import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
9: 
10: import java.util.Optional;
11: 
12: @Service
13: public class ProductService {
14:     private final ProductRepository productRepository;
15: 
16:     public ProductService(
17:             ProductRepository productRepository
18:     )
19:     {
20:         this.productRepository = productRepository;
21:     }
22: 
23:     public ProductId addProductToCatalog(String name, String descriptFor, Float size, Currency buyingPrice, Currency salesPrice) {
24:         validateProductName(name);
25:         validateProductDescription(descriptFor);
26:         validateProductSize(size);
27:         validateProductBuyingAndSalesPrice(buyingPrice, salesPrice);
28: 
29:         Product product = new Product(name, descriptFor, size, buyingPrice, salesPrice);
30: 
31:         productRepository.save(product);
32:         return product.getId();
33:     }
34: 
35:     public void removeProductFromCatalog(ProductId productId) {
36:         validateProductId(productId);
37:         productRepository.deleteById(productId);
38:     }
39: 
40: 
41:     public Currency getSalesPrice(ProductId productId) {
42:         validateProductId(productId);
43: 
44:         Product product = productRepository.findById(productId)
45:                 .orElseThrow(() -> new ShopException("Product with id " + productId + " does not exist"));
46: 
47:         return product.getSalesPrice();
48:     }
49: 
50:     public void deleteProductCatalog() {
51:         productRepository.deleteAll();
52:     }
53: 
54:     // EXISTS
55: 
56:     public boolean existsProductByProductId(ProductId productId) {
57:         return productRepository.existsById(productId);
58:     }
59: 
60:     // FIND
61: 
62:     public Optional<Product> findProductById(ProductId productId) {
63:         return productRepository.findById(productId);
64:     }
65: 
66:     // VALIDATE
67: 
68:     public void validateProductId(ProductId productId) {
69:         if(productId == null) {
70:             throw new ShopException("Product ID cannot be null or empty.");
71:         }
72:     }
73:     public void validateProductName(String productName) {
74:         if(productName == null || productName.isEmpty()) {
75:             throw new ShopException("Product name cannot be null or empty.");
76:         }
77:     }
78:     public void validateProductDescription(String productDescription) {
79:         if(productDescription == null || productDescription.isEmpty()) {
80:             throw new ShopException("Product description cannot be null or empty.");
81:         }
82:     }
83:     public void validateProductSize(Float productSize) {
84:         if (productSize != null && productSize <= 0) {
85:             throw new ShopException("Product size cannot be zero or negative.");
86:         }
87:     }
88:     public void validateProductBuyingAndSalesPrice(Currency buyingPrice, Currency salesPrice) {
89:         if(buyingPrice.largerThan(salesPrice)){
90:             throw new ShopException("Product sales price cannot be greater than salesPrice.");
91:         }
92:     }
93: }
94: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\PurchasableServiceInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: 
3: 
4: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
5: 
6: public interface PurchasableServiceInterface {
7:     public boolean existsProductInPurchaseByProductId(ProductId productId);
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\RemoveAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
7: 
8: @Service
9: public class RemoveAdapterService {
10:     private final ProductService productService;
11:     private final DepotableServiceInterface depotableServiceInterface;
12:     private final PurchasableServiceInterface purchasableServiceInterface;
13: 
14:     @Autowired
15:     public RemoveAdapterService(
16:             ProductService productService,
17:             DepotableServiceInterface depotableServiceInterface,
18:             PurchasableServiceInterface purchasableServiceInterface
19:     ) {
20:         this.productService = productService;
21:         this.depotableServiceInterface = depotableServiceInterface;
22:         this.purchasableServiceInterface = purchasableServiceInterface;
23:     }
24: 
25:     public void removeProductFromCatalog(ProductId productId) {
26:         if(!productService.existsProductByProductId(productId)) throw new ShopException("Product with id " + productId + " does not exist");
27:         if(depotableServiceInterface.existsProductInDepotByProductId(productId)) throw new ShopException("Product with id " + productId + " exists in depot");
28:         if(purchasableServiceInterface.existsProductInPurchaseByProductId(productId)) throw new ShopException("Product with id " + productId + "exists in purchase");
29: 
30:         productService.removeProductFromCatalog(productId);
31:     }
32: }
33: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\exceptions\ProductNotFoundException.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Product not found")
8: public class ProductNotFoundException extends ShopException {
9:     public ProductNotFoundException( String message ) {
10:         super( message );
11:     }
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\Product.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.*;
5: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
6: 
7: @Getter
8: @Entity
9: @AllArgsConstructor
10: @NoArgsConstructor(access = AccessLevel.PROTECTED)
11: public class Product {
12: 
13:     @Setter(AccessLevel.PRIVATE)
14:     @EmbeddedId
15:     private ProductId id;
16: 
17:     @Setter
18:     private String name;
19: 
20:     @Setter
21:     private String description;
22: 
23:     @Setter
24:     private Float size;
25: 
26:     @Setter
27:     @AttributeOverrides({
28:             @AttributeOverride(name = "amount", column = @Column(name = "buying_price_amount")),
29:             @AttributeOverride(name = "currencyUnit", column = @Column(name = "buying_price_currency"))
30:     })
31:     private Currency buyingPrice;
32: 
33:     @Setter
34:     @AttributeOverrides({
35:             @AttributeOverride(name = "amount", column = @Column(name = "sales_price_amount")),
36:             @AttributeOverride(name = "currencyUnit", column = @Column(name = "sales_price_currency"))
37:     })
38:     private Currency salesPrice;
39: 
40:     public Product(String name, String description, Float size, Currency buyingPrice, Currency salesPrice) {
41:         this.id = new ProductId();
42:         this.name = name;
43:         this.description = description;
44:         this.size = size;
45:         this.buyingPrice = buyingPrice;
46:         this.salesPrice = salesPrice;
47:     }
48: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductId.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "product_id"))
15: public class ProductId extends GenericId {
16:     public ProductId( UUID id ) {
17:         super( id );
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ProductIdConverter extends GenericIdConverter<ProductId> {
8:     public ProductIdConverter() {
9:         super(ProductId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: 
6: @Repository
7: public interface ProductRepository extends CrudRepository<Product, ProductId> {
8: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchasableService.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.solution.product.application.PurchasableServiceInterface;
5: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
6: 
7: @Service
8: public class PurchasableService implements PurchasableServiceInterface {
9:     private final PurchaseService purchaseService;
10: 
11:     public PurchasableService(PurchaseService purchaseService) {
12:         this.purchaseService = purchaseService;
13:     }
14: 
15:     @Override
16:     public boolean existsProductInPurchaseByProductId(ProductId productId) {
17:         return purchaseService.existsProductInPurchaseByProductId(productId);
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
6: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
7: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
8: import thkoeln.archilab.ecommerce.usecases.PurchaseUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
10: 
11: import java.util.HashMap;
12: import java.util.Map;
13: import java.util.UUID;
14: 
15: @Service
16: public class PurchaseAdapterService implements PurchaseUseCases {
17: 
18:     private final PurchaseService purchaseService;
19: 
20:     public PurchaseAdapterService(
21:             PurchaseService purchaseService
22:     ) {
23:         this.purchaseService = purchaseService;
24:     }
25: 
26:     @Override
27:     public Map<UUID, Integer> getPurchaseHistory(EmailAddressType userEmailAddress) {
28:         EmailAddress emailAddress = (EmailAddress) userEmailAddress;
29:         Map<ProductId, Integer> purchaseHistoryWithProductId = purchaseService.getPurchaseHistory(emailAddress);
30:         Map<UUID, Integer> purchaseHistoryWithUUID = new HashMap<>();
31: 
32:         for (Map.Entry<ProductId, Integer> entry : purchaseHistoryWithProductId.entrySet()) {
33:             UUID productUUID = entry.getKey().getId(); // Annahme: ProductId hat getId()
34:             Integer quantity = entry.getValue();
35:             purchaseHistoryWithUUID.put(productUUID, quantity);
36:         }
37: 
38:         return purchaseHistoryWithUUID;
39:     }
40: 
41:     @Override
42:     public Integer getPurchaseQuantOfProduct(UUID purchaseId, UUID productId) {
43:         PurchaseId newPurchaseId = new PurchaseId(purchaseId);
44:         ProductId newProductId = new ProductId(productId);
45:         return purchaseService.getPurchaseQuantOfProduct(newPurchaseId, newProductId);
46:     }
47: 
48:     @Override
49:     public UUID getDepotIdForPurchase(UUID purchaseId) {
50:         PurchaseId newPurchaseId = new PurchaseId(purchaseId);
51:         return purchaseService.getDepotIdForPurchase(newPurchaseId);
52:     }
53: 
54:     @Override
55:     public void deleteAllPurchases() {
56:         purchaseService.deleteAllPurchases();
57:     }
58: }
59: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.application;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.List;
9: import java.util.UUID;
10: 
11: @Setter
12: @Getter
13: @AllArgsConstructor
14: @NoArgsConstructor
15: public class PurchaseDTO {
16:     private UUID id;
17:     private String userName;
18:     private UUID depotId;
19:     private List<PurchasePositionDTO> positions;
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchasePositionDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.application;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.UUID;
9: 
10: @Setter
11: @Getter
12: @AllArgsConstructor
13: @NoArgsConstructor
14: public class PurchasePositionDTO {
15:     private UUID productId;
16:     private Integer quantity;
17: }
18: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseService.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
6: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
7: import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
8: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
9: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchasePosition;
10: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;
11: import thkoeln.archilab.ecommerce.solution.user.application.UserService;
12: import thkoeln.archilab.ecommerce.solution.user.domain.User;
13: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
14: 
15: import java.util.HashMap;
16: import java.util.List;
17: import java.util.Map;
18: import java.util.UUID;
19: 
20: @Service
21: public class PurchaseService {
22:     private final PurchaseRepository purchaseRepository;
23:     private final UserService userService;
24: 
25:     public PurchaseService(PurchaseRepository purchaseRepository, UserService userService) {
26:         this.purchaseRepository = purchaseRepository;
27:         this.userService = userService;
28:     }
29: 
30:     public Map<ProductId, Integer> getPurchaseHistory(EmailAddress userEmailAddress) {
31:         if(userEmailAddress == null) throw new ShopException("User not found");
32: 
33:         User user = userService.findUserByEmailAddress(userEmailAddress)
34:                 .orElseThrow(() -> new ShopException("User not found"));
35:         UserId userId = user.getId();
36: 
37:         List<Purchase> purchases = purchaseRepository.findByUserId(userId);
38: 
39:         Map<ProductId, Integer> purchaseHistory = new HashMap<>();
40:         for (Purchase purchase : purchases) {
41:             for (PurchasePosition position : purchase.getPurchasePositions()) {
42:                 ProductId productId = position.getProductId();
43:                 int quantity = position.getQuantity();
44: 
45:                 purchaseHistory.put(
46:                         productId,
47:                         purchaseHistory.getOrDefault(productId, 0) + quantity
48:                 );
49:             }
50:         }
51: 
52:         return purchaseHistory;
53:     }
54: 
55:     public void deleteAllPurchases() {
56:         purchaseRepository.deleteAll();
57:     }
58: 
59:     public boolean existsProductInPurchaseByProductId(ProductId productId) {
60:         for (Purchase purchase : purchaseRepository.findAll()) {
61:             if (purchase.findPurchasePositionByProductId(productId).isPresent()) {
62:                 return true;
63:             }
64:         }
65:         return false;
66:     }
67: 
68:     public Integer getPurchaseQuantOfProduct(PurchaseId purchaseId, ProductId productId) {
69:         Purchase purchase = purchaseRepository.findById(purchaseId).orElseThrow(() -> new ShopException("Purchase not found"));
70:         PurchasePosition purchasePosition = purchase.findPurchasePositionByProductId(productId).orElseThrow(() -> new ShopException("Position not found"));
71:         return purchasePosition.getQuantity();
72:     }
73: 
74:     public UUID getDepotIdForPurchase(PurchaseId purchaseId) {
75:         Purchase purchase = purchaseRepository.findById(purchaseId).orElseThrow(() -> new ShopException("Purchase not found"));
76:         return purchase.getDepotId().getId();
77:     }
78: 
79:     public Purchase getPurchaseById(PurchaseId purchaseId){
80:         return purchaseRepository.findById(purchaseId)
81:                 .orElseThrow(() -> new ShopException("Purchase not found"));
82:     }
83: }
84: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\exceptions\PurchaseNotFoundException.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Product not found")
8: public class PurchaseNotFoundException extends ShopException {
9:     public PurchaseNotFoundException( String message ) {
10:         super( message );
11:     }
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\Purchase.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.*;
5: import thkoeln.archilab.ecommerce.solution.depot.domain.DepotId;
6: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
7: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
8: 
9: import java.util.ArrayList;
10: import java.util.List;
11: import java.util.Optional;
12: 
13: @Getter
14: @Entity
15: @AllArgsConstructor
16: @NoArgsConstructor(access = AccessLevel.PROTECTED)
17: public class Purchase {
18: 
19:     @Setter(AccessLevel.PRIVATE)
20:     @EmbeddedId
21:     private PurchaseId id;
22: 
23:     @Setter
24:     private UserId userId;
25: 
26:     @Setter
27:     private DepotId depotId;
28: 
29:     @Setter
30:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
31:     List<PurchasePosition> purchasePositions = new ArrayList<>();
32: 
33:     public Purchase(UserId userId, DepotId depotId) {
34:         this.id = new PurchaseId();
35:         this.userId = userId;
36:         this.depotId = depotId;
37:     }
38: 
39:     public void addPurchasePosition(PurchasePosition purchasePosition) {
40:         purchasePositions.add(purchasePosition);
41:     }
42: 
43: 
44:     public Optional<PurchasePosition> findPurchasePositionByProductId(ProductId productId) {
45:         for (PurchasePosition purchasePosition : purchasePositions) {
46:             if (purchasePosition.getProductId().equals(productId)) {
47:                 return Optional.of(purchasePosition);
48:             }
49:         }
50:         return Optional.empty();
51:     }
52: 
53: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseId.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "purchase_id"))
15: public class PurchaseId extends GenericId {
16:     public PurchaseId( UUID id ) {
17:         super( id );
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class PurchaseIdConverter extends GenericIdConverter<PurchaseId> {
8:     public PurchaseIdConverter() {
9:         super(PurchaseId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePosition.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.EmbeddedId;
4: import jakarta.persistence.Entity;
5: import lombok.*;
6: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
7: 
8: @Entity
9: @Getter
10: @AllArgsConstructor
11: @NoArgsConstructor(access = AccessLevel.PROTECTED)
12: public class PurchasePosition {
13: 
14:     @Setter(AccessLevel.PRIVATE)
15:     @EmbeddedId
16:     private PurchasePositionId id;
17: 
18:     @Setter
19:     //@ManyToOne
20:     private ProductId productId;
21: 
22:     @Setter
23:     private Integer quantity;
24: 
25:     public PurchasePosition(ProductId productId, Integer quantity) {
26:         this.id = new PurchasePositionId();
27:         this.productId = productId;
28:         this.quantity = quantity;
29:     }
30: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePositionId.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "purchase_position_id"))
15: public class PurchasePositionId extends GenericId {
16:     public PurchasePositionId( UUID id ) {
17:         super( id );
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePositionIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class PurchasePositionIdConverter extends GenericIdConverter<PurchasePositionId> {
8:     public PurchasePositionIdConverter() {
9:         super(PurchasePositionId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
6: 
7: import java.util.List;
8: 
9: @Repository
10: public interface PurchaseRepository extends CrudRepository<Purchase, PurchaseId> {
11:     List<Purchase> findByUserId(UserId userId);
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
6: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
7: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
8: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
11: 
12: import java.util.*;
13: 
14: @Service
15: public class ShoppingAdapterService implements ShoppingBasketUseCases {
16: 
17:     private final ShoppingService shoppingService;
18: 
19:     public ShoppingAdapterService(
20:             ShoppingService shoppingService
21:     ) {
22:         this.shoppingService = shoppingService;
23:     }
24: 
25:     @Override
26:     public void addProductToShoppingBasket(EmailAddressType userEmailAddress, UUID productId, int quantOf) {
27:         if(userEmailAddress == null) throw new ShopException("Email address must not be null");
28: 
29:         ProductId newProductId = new ProductId(productId);
30:         shoppingService.addProductToShoppingBasket(userEmailAddress, newProductId, quantOf);
31:     }
32: 
33:     @Override
34:     public void removeProductFromShoppingBasket(EmailAddressType userEmailAddress, UUID productId, int quantOf) {
35:         if(userEmailAddress == null) throw new ShopException("Email address must not be null");
36: 
37:         ProductId newProductId = new ProductId(productId);
38:         shoppingService.removeProductFromShoppingBasket(userEmailAddress, newProductId, quantOf);
39:     }
40: 
41:     @Override
42:     public Map<UUID, Integer> getShoppingBasketAsMap(EmailAddressType userEmailAddress) {
43:         if(userEmailAddress == null) throw new ShopException("Email address must not be null");
44: 
45:         Map<ProductId, Integer> basketWithProductId = shoppingService.getShoppingBasketAsMap(userEmailAddress);
46:         Map<UUID, Integer> basketWithUUID = new HashMap<>();
47: 
48:         for (Map.Entry<ProductId, Integer> entry : basketWithProductId.entrySet()) {
49:             UUID productUUID = entry.getKey().getId(); // get UUID from ProductId
50:             Integer quantity = entry.getValue();
51:             basketWithUUID.put(productUUID, quantity);
52:         }
53: 
54:         return basketWithUUID;
55:     }
56: 
57: 
58:     @Override
59:     public CurrencyType getShoppingBasketAsCurrencyValue(EmailAddressType userEmailAddress) {
60:         if(userEmailAddress == null) throw new ShopException("Email address must not be null");
61:         EmailAddress newEmailAddress = (EmailAddress) userEmailAddress;
62:         return shoppingService.getShoppingBasketAsCurrencyValue(newEmailAddress);
63:     }
64: 
65:     @Override
66:     public Set<UUID> checkout(EmailAddressType userEmailAddress) {
67:         if (userEmailAddress == null) throw new ShopException("Email address must not be null");
68:         EmailAddress newEmailAddress = (EmailAddress) userEmailAddress;
69:         Set<UUID> newSet = shoppingService.checkout(newEmailAddress);
70:         return newSet;
71:     }
72: 
73: 
74:     @Override
75:     public void emptyAllShoppingBaskets() {
76:         shoppingService.emptyAllShoppingBaskets();
77:     }
78: }
79: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingApplicationService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
6: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.exceptions.ShoppingBasketNotFoundException;
7: import thkoeln.archilab.ecommerce.solution.product.application.ProductService;
8: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
9: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
10: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketId;
11: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
12: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
13: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
14: 
15: import java.util.List;
16: import java.util.Optional;
17: import java.util.UUID;
18: 
19: @Service
20: public class ShoppingApplicationService {
21: 
22:     private final ProductService productService;
23:     private ShoppingBasketRepository shoppingBasketRepository;
24: 
25:     @Autowired
26:     public ShoppingApplicationService(
27:             ShoppingBasketRepository shoppingBasketRepository,
28:             ProductService productService, ShoppingService shoppingService) {
29:         this.shoppingBasketRepository = shoppingBasketRepository;
30:         this.productService = productService;
31:     }
32: 
33:     public Optional<ShoppingBasket> findByUserId(UserId userId){
34:         return shoppingBasketRepository.findShoppingBasketByUserId(userId);
35:     }
36: 
37:     public Currency calculateTotalSalesPrice (List<ShoppingBasketPosition> positions){
38:         Float sumSalesPrice = 0.0f;
39:         String unit = "EUR";
40:         for(ShoppingBasketPosition position : positions){
41:             ProductId productId = position.getProductId();
42:             Currency salesPrice = productService.getSalesPrice(productId);
43:             sumSalesPrice += salesPrice.getAmount() * position.getQuantity();
44:             unit = salesPrice.getCurrencyUnit();
45:         }
46:         return Currency.of(sumSalesPrice, unit);
47:     }
48: 
49:     public void addPositionToBasket(
50:             UUID shoppingBasketId,
51:             ShoppingBasketPositionDTO shoppingBasketPositionDTO
52:     ){
53:         ProductId productId = new ProductId(shoppingBasketPositionDTO.getProductId());
54:         ShoppingBasketId newShoppingBasketId = new ShoppingBasketId(shoppingBasketId);
55: 
56:         ShoppingBasket shoppingBasket = shoppingBasketRepository.getShoppingBasketById(newShoppingBasketId)
57:                 .orElseThrow(()-> new ShoppingBasketNotFoundException("Shopping Basket with id: " + shoppingBasketId+ "not found!"));
58: 
59:         ShoppingBasketPosition shoppingBasketPosition = new ShoppingBasketPosition(
60:                 productId,
61:                 shoppingBasketPositionDTO.getQuantity()
62:         );
63: 
64:         shoppingBasket.addPosition(shoppingBasketPosition);
65:         shoppingBasketRepository.save(shoppingBasket);
66:     }
67: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import jakarta.transaction.Transactional;
4: import org.modelmapper.ModelMapper;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.http.HttpStatus;
7: import org.springframework.http.ResponseEntity;
8: import org.springframework.web.bind.annotation.*;
9: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.*;
10: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
11: import thkoeln.archilab.ecommerce.solution.product.domain.exceptions.ProductNotFoundException;
12: import thkoeln.archilab.ecommerce.solution.purchase.application.PurchaseDTO;
13: import thkoeln.archilab.ecommerce.solution.purchase.application.PurchasePositionDTO;
14: import thkoeln.archilab.ecommerce.solution.purchase.application.PurchaseService;
15: import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
16: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
17: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchasePosition;
18: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
19: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketId;
20: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
21: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.exceptions.ShoppingBasketNotFoundException;
22: import thkoeln.archilab.ecommerce.solution.user.application.UserService;
23: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
24: import thkoeln.archilab.ecommerce.solution.user.domain.exceptions.UserNotFoundException;
25: 
26: import java.util.ArrayList;
27: import java.util.List;
28: import java.util.Set;
29: import java.util.UUID;
30: 
31: @RestController
32: @Transactional
33: @RequestMapping("/shoppingBaskets")
34: public class ShoppingBasketController {
35: 
36:     private final ShoppingApplicationService shoppingBasketApplicationService;
37:     private final ModelMapper modelMapper = new ModelMapper();
38:     private final ShoppingService shoppingService;
39:     private final UserService userService;
40:     private final PurchaseService purchaseService;
41: 
42:     @Autowired
43:     public ShoppingBasketController(
44:             ShoppingApplicationService shoppingBasketApplicationService,
45:             ShoppingService shoppingService, UserService userService, PurchaseService purchaseService) {
46:         this.shoppingBasketApplicationService = shoppingBasketApplicationService;
47:         this.shoppingService = shoppingService;
48:         this.userService = userService;
49:         this.purchaseService = purchaseService;
50:     }
51: 
52:     /**
53:      * GET /shoppingBaskets — Zugriff auf alle ShoppingBaskets ist verboten
54:      */
55:     @GetMapping
56:     public ResponseEntity<Void> getAllShoppingBaskets() {
57:         throw new MethodNotAllowedException("Access to all users is forbidden. Use specific userId.");
58:     }
59: 
60:     @GetMapping("/{id}")
61:     public ResponseEntity<ShoppingBasketDTO> getOneShoppingBasketById(
62:             @PathVariable("id") String shoppingBasketIdStr
63:     ) {
64:         UUID shoppingBasketId;
65:         try {
66:             shoppingBasketId = UUID.fromString(shoppingBasketIdStr);
67:         } catch (IllegalArgumentException ex) {
68:             throw new ShoppingBasketNotFoundException("Invalid UUID format.");
69:         }
70:         ShoppingBasketId shoppingBasketId1 = new ShoppingBasketId(shoppingBasketId);
71:         ShoppingBasket shoppingBasket = shoppingService.findById(shoppingBasketId1)
72:                 .orElseThrow(()->new ShoppingBasketNotFoundException("Shopping Basket with id: " +shoppingBasketId+ "not found!"));
73: 
74:         ShoppingBasketDTO dto = modelMapper.map(shoppingBasket, ShoppingBasketDTO.class);
75: 
76:         return ResponseEntity.ok(dto);
77:     }
78: 
79:     @GetMapping(params = "userId")
80:     public ResponseEntity<ShoppingBasketDTO> getShoppingBasketByUserId(
81:             @RequestParam("userId") String userIdStr
82:     ) {
83:         UUID userId;
84:         try {
85:             userId = UUID.fromString(userIdStr);
86:         } catch (IllegalArgumentException ex) {
87:             throw new ShoppingBasketNotFoundException("Invalid UUID format.");
88:         }
89:         UserId newUserId = new UserId(userId);
90:         if(!userService.existsUserById(newUserId)) throw new UserNotFoundException("User with id:" +userId+ "not found!");
91: 
92:         ShoppingBasket shoppingBasket = shoppingService.getShoppingBasketByUserId(newUserId);
93:         ShoppingBasketId shoppingBasketId = shoppingBasket.getId();
94: 
95:         List<ShoppingBasketPosition> positions = shoppingBasket.getShoppingBasketPositions();
96:         List<ShoppingBasketPositionDTO> positionsDtos = new ArrayList<>();
97:         for(ShoppingBasketPosition position : positions){
98:             positionsDtos.add(modelMapper.map(position, ShoppingBasketPositionDTO.class));
99:         }
100:         String totalSalesPrice = shoppingBasketApplicationService.calculateTotalSalesPrice(positions).toString();
101: 
102:         ShoppingBasketDTO dto = new ShoppingBasketDTO();
103:         dto.setId(shoppingBasketId.getId());
104:         dto.setUserId(newUserId.getId());
105:         dto.setTotalSalesPrice(totalSalesPrice);
106:         dto.setPositions(positionsDtos);
107: 
108:         return ResponseEntity.ok(dto);
109:     }
110: 
111:     @PostMapping("/{shoppingBasketId}/positions")
112:     public ResponseEntity postShoppingBasketPosition(
113:             @PathVariable UUID shoppingBasketId,
114:             @RequestBody ShoppingBasketPositionDTO shoppingBasketPositionDTO
115:     ) {
116:         shoppingService.addProductToShoppingBasket(shoppingBasketId, shoppingBasketPositionDTO);
117:         return new ResponseEntity( HttpStatus.CREATED );
118:     }
119: 
120:     @DeleteMapping("/{shoppingBasketIdStr}/positions/{productIdStr}")
121:     public ResponseEntity deleteOneUser(
122:             @PathVariable String shoppingBasketIdStr,
123:             @PathVariable String productIdStr
124:     ) {
125:         ShoppingBasketId shoppingBasketId;
126:         ProductId productId;
127:         try {
128:             shoppingBasketId = new ShoppingBasketId(UUID.fromString(shoppingBasketIdStr));
129:         } catch (IllegalArgumentException ex) {
130:             throw new ShoppingBasketNotFoundException("Invalid UUID format.");
131:         }
132:         try {
133:             productId = new ProductId(UUID.fromString(productIdStr));
134:         } catch (IllegalArgumentException ex) {
135:             throw new ProductNotFoundException("Invalid UUID format.");
136:         }
137: 
138:         shoppingService.removeProductFromShoppingBasket(shoppingBasketId, productId);
139:         return new ResponseEntity(HttpStatus.OK);
140:     }
141: 
142:     @PostMapping("/{shoppingBasketIdStr}/checkout")
143:     public ResponseEntity<List<PurchaseDTO>> postShoppingBasketPosition(
144:             @PathVariable String shoppingBasketIdStr
145:     ) {
146:         ShoppingBasketId shoppingBasketId;
147:         try {
148:             shoppingBasketId = new ShoppingBasketId(UUID.fromString(shoppingBasketIdStr));
149:         } catch (IllegalArgumentException ex) {
150:             throw new ShoppingBasketNotFoundException("Invalid UUID format.");
151:         }
152: 
153:         Set<UUID> purchases = shoppingService.checkout(shoppingBasketId);
154: 
155:         List<PurchaseDTO> purchaseDtos = new ArrayList<>();
156:         for(UUID purchaseId : purchases){
157:             PurchaseDTO dto = new PurchaseDTO();
158:             Purchase purchase = purchaseService.getPurchaseById(new PurchaseId(purchaseId));
159:             dto.setId(purchaseId);
160:             dto.setDepotId(purchase.getDepotId().getId());
161:             dto.setUserName(userService.getUserNameById(purchase.getUserId()));
162: 
163:             List<PurchasePositionDTO> purchasePositionDTOS = new ArrayList<>();
164:             for(PurchasePosition purchasePosition : purchase.getPurchasePositions()){
165:                 purchasePositionDTOS.add(modelMapper.map(purchasePosition, PurchasePositionDTO.class));
166:             }
167:             dto.setPositions(purchasePositionDTOS);
168:         }
169: 
170:         return ResponseEntity.status(HttpStatus.CREATED).body(purchaseDtos);
171:     }
172: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
8: 
9: import java.util.List;
10: import java.util.UUID;
11: 
12: @Setter
13: @Getter
14: @AllArgsConstructor
15: @NoArgsConstructor
16: public class ShoppingBasketDTO {
17:     private UUID id;
18:     private String totalSalesPrice;
19:     private List<ShoppingBasketPositionDTO> positions;
20:     private UUID userId;
21: }
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketPositionDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.UUID;
9: 
10: @Setter
11: @Getter
12: @AllArgsConstructor
13: @NoArgsConstructor
14: public class ShoppingBasketPositionDTO {
15:     private UUID productId;
16:     private Integer quantity;
17: 
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.InsufficientStockException;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
7: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
8: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
9: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.*;
10: import thkoeln.archilab.ecommerce.solution.depot.application.DepotService;
11: import thkoeln.archilab.ecommerce.solution.depot.domain.Depot;
12: import thkoeln.archilab.ecommerce.solution.depot.domain.DepotComparator;
13: import thkoeln.archilab.ecommerce.solution.product.application.ProductService;
14: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
15: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
16: import thkoeln.archilab.ecommerce.solution.product.domain.exceptions.ProductNotFoundException;
17: import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
18: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchasePosition;
19: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;
20: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
21: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketId;
22: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
23: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
24: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.exceptions.ShoppingBasketNotFoundException;
25: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.exceptions.ShoppingBasketPositionNotFoundException;
26: import thkoeln.archilab.ecommerce.solution.user.application.UserService;
27: import thkoeln.archilab.ecommerce.solution.user.domain.User;
28: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
29: import thkoeln.archilab.ecommerce.solution.user.domain.exceptions.UserNotFoundException;
30: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
31: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
32: 
33: import java.util.*;
34: 
35: @Service
36: public class ShoppingService {
37: 
38:     private final UserService userService;
39:     private final ProductService productService;
40:     private final ShoppingBasketRepository shoppingBasketRepository;
41:     private final DepotService depotService;
42:     private final PurchaseRepository purchaseRepository;
43: 
44:     public ShoppingService(
45:             UserService userService,
46:             ProductService productService,
47:             ShoppingBasketRepository shoppingBasketRepository,
48:             DepotService depotService,
49:             PurchaseRepository purchaseRepository
50:     ) {
51:         this.userService = userService;
52:         this.productService = productService;
53:         this.shoppingBasketRepository = shoppingBasketRepository;
54:         this.depotService = depotService;
55:         this.purchaseRepository = purchaseRepository;
56:     }
57: 
58:     public ShoppingBasket getShoppingBasketByUserId(UserId userId){
59:         if(userId == null) throw new UserNotFoundException("User Not Found");
60: 
61:         ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketByUserId(userId)
62:                 .orElseGet(() -> new ShoppingBasket(userId));
63:         shoppingBasketRepository.save(shoppingBasket);
64: 
65:         return shoppingBasket;
66:     }
67: 
68:     public void addProductToShoppingBasket(EmailAddressType userEmailAddress, ProductId productId, int quantOf) {
69:         if(quantOf == 0) return;
70: 
71:         nullThrow(List.of(userEmailAddress));
72: 
73:         productService.validateProductId(productId);
74:         validateQuantity(quantOf);
75: 
76:         if(!productService.existsProductByProductId(productId)) throw new ShopException("Product does not exist");
77: 
78:         EmailAddress emailAddress = (EmailAddress) userEmailAddress;
79:         User user = userService.findUserByEmailAddress(emailAddress)
80:                 .orElseThrow(() -> new ShopException("User not found"));
81:         UserId userId = user.getId();
82: 
83:         ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketByUserId(userId)
84:                 .orElseGet(() -> new ShoppingBasket(userId));
85: 
86:         ShoppingBasketPosition shoppingBasketPosition = shoppingBasket.findShoppingBasketPositionsByProductId(productId)
87:                 .orElseGet(() -> null);
88: 
89:         if(shoppingBasketPosition == null) {
90:             shoppingBasketPosition = new ShoppingBasketPosition(productId, quantOf);
91:             shoppingBasket.getShoppingBasketPositions().add(shoppingBasketPosition);
92:         }
93:         else {
94:             int oldQuantity = shoppingBasketPosition.getQuantity();
95:             int newQuantity = oldQuantity + quantOf;
96:             shoppingBasketPosition.setQuantity(newQuantity);
97:         }
98:         shoppingBasketRepository.save(shoppingBasket);
99:     }
100: 
101:     public void addProductToShoppingBasket(UUID shoppingBasketId1, ShoppingBasketPositionDTO shoppingBasketPositionDTO) {
102:         int quantOf = shoppingBasketPositionDTO.getQuantity();
103:         ProductId productId = new ProductId(shoppingBasketPositionDTO.getProductId());
104:         ShoppingBasketId shoppingBasketId = new ShoppingBasketId(shoppingBasketId1);
105: 
106:         if(quantOf == 0) return;
107: 
108:         productService.validateProductId(productId);
109:         validateQuantity(quantOf);
110: 
111:         if(!productService.existsProductByProductId(productId)) throw new ProductNotFoundException("Product does not exist");
112: 
113:         ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketById(shoppingBasketId)
114:                 .orElseThrow(() -> new ShoppingBasketNotFoundException("Shopping Basket not found"));
115: 
116:         ShoppingBasketPosition shoppingBasketPosition = shoppingBasket.findShoppingBasketPositionsByProductId(productId)
117:                 .orElseGet(() -> null);
118: 
119:         if(shoppingBasketPosition == null) {
120:             shoppingBasketPosition = new ShoppingBasketPosition(productId, quantOf);
121:             shoppingBasket.getShoppingBasketPositions().add(shoppingBasketPosition);
122:         }
123:         else {
124:             int oldQuantity = shoppingBasketPosition.getQuantity();
125:             int newQuantity = oldQuantity + quantOf;
126:             shoppingBasketPosition.setQuantity(newQuantity);
127:         }
128:         shoppingBasketRepository.save(shoppingBasket);
129:     }
130: 
131:     public void removeProductFromShoppingBasket(EmailAddressType userEmailAddress, ProductId productId, int quantOf) {
132:         productService.validateProductId(productId);
133:         validateQuantity(quantOf);
134: 
135:         if(!productService.existsProductByProductId(productId)) throw new ShopException("Product does not exist");
136: 
137:         EmailAddress emailAddress = (EmailAddress) userEmailAddress;
138:         User user = userService.findUserByEmailAddress(emailAddress)
139:                 .orElseThrow(() -> new ShopException("User not found"));
140:         UserId userId = user.getId();
141: 
142:         ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketByUserId(userId)
143:                 .orElseThrow(() -> new ShopException("Shopping basket not found"));
144: 
145:         ShoppingBasketPosition shoppingBasketPosition = shoppingBasket.findShoppingBasketPositionsByProductId(productId)
146:                 .orElseThrow(() -> new ShopException("Shopping basket does not exist"));
147: 
148:         int oldQuantity = shoppingBasketPosition.getQuantity();
149: 
150:         if(oldQuantity - quantOf < 0) throw new ShopException("Quantity is too big");
151:         else if (oldQuantity - quantOf == 0) {
152:             shoppingBasket.removePosition(shoppingBasketPosition);
153:         }
154:         else {
155:             shoppingBasketPosition.setQuantity(oldQuantity - quantOf);
156:         }
157:         shoppingBasketRepository.save(shoppingBasket);
158:     }
159:     public void removeProductFromShoppingBasket(ShoppingBasketId shoppingBasketId, ProductId productId) {
160:         productService.validateProductId(productId);
161: 
162:         if(!productService.existsProductByProductId(productId)) throw new ProductNotFoundException("Product does not exist");
163: 
164:         ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketById(shoppingBasketId)
165:                 .orElseThrow(() -> new ShoppingBasketNotFoundException("Shopping basket not found"));
166: 
167:         ShoppingBasketPosition shoppingBasketPosition = shoppingBasket.findShoppingBasketPositionsByProductId(productId)
168:                 .orElseThrow(() -> new ShoppingBasketPositionNotFoundException("Shopping basket does not exist"));
169: 
170:         shoppingBasket.removePosition(shoppingBasketPosition);
171:         shoppingBasketRepository.save(shoppingBasket);
172:     }
173: 
174:     public Map<ProductId, Integer> getShoppingBasketAsMap(EmailAddressType userEmailAddress) {
175: 
176:         EmailAddress emailAddress = (EmailAddress) userEmailAddress;
177:         User user = userService.findUserByEmailAddress(emailAddress)
178:                 .orElseThrow(() -> new ShopException("User not found"));
179:         UserId userId = user.getId();
180: 
181:         ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketByUserId(userId)
182:                 .orElseThrow(() -> new ShopException("Shopping basket not found"));
183: 
184:         Map<ProductId, Integer> basketMap = new HashMap<>();
185:         for (ShoppingBasketPosition position : shoppingBasket.getShoppingBasketPositions()) {
186:             ProductId productId = position.getProductId();
187:             int quantity = position.getQuantity();
188:             basketMap.put(productId, basketMap.getOrDefault(productId, 0) + quantity);
189:         }
190: 
191:         return basketMap;
192:     }
193: 
194:     public CurrencyType getShoppingBasketAsCurrencyValue(EmailAddress userEmailAddress) {
195: 
196:         EmailAddress emailAddress = (EmailAddress) userEmailAddress;
197:         User user = userService.findUserByEmailAddress(emailAddress)
198:                 .orElseThrow(() -> new ShopException("User not found"));
199:         UserId userId = user.getId();
200: 
201:         ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketByUserId(userId)
202:                 .orElseGet(() -> null);
203:         if (shoppingBasket == null) return Currency.of(0.0f, "EUR");
204: 
205:         float sum = 0f;
206:         for(ShoppingBasketPosition position : shoppingBasket.getShoppingBasketPositions()) {
207:             int quantity = position.getQuantity();
208: 
209:             Product product = productService.findProductById(position.getProductId())
210:                     .orElseThrow(() -> new ShopException("Product not found"));
211: 
212:             sum += quantity * product.getSalesPrice().getAmount();
213:         }
214: 
215:         return Currency.of(sum, "EUR");
216:     }
217: 
218:     public Set<UUID> checkout(EmailAddress userEmailAddress) {
219:         nullThrow(List.of(userEmailAddress));
220: 
221:         EmailAddress emailAddress = (EmailAddress) userEmailAddress;
222: 
223:         User user = userService.findUserByEmailAddress(emailAddress).orElseThrow(() -> new ShopException("User not found"));
224:         UserId userId = user.getId();
225: 
226:         ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketByUserId(userId).orElseThrow(() -> new ShopException("Shopping basket not found"));
227:         if (shoppingBasket.getShoppingBasketPositions().isEmpty()) throw new ShopException("Shopping basket is empty");
228: 
229:         List<Depot> depots = depotService.getAllDepots();
230:         PhysicalAddress userAddress = user.getPhysicalAddress();
231: 
232:         Map<ProductId, Integer> shoppingBasketMap = new HashMap<>();
233:         for (ShoppingBasketPosition position : shoppingBasket.getShoppingBasketPositions()) {
234:             shoppingBasketMap.put(position.getProductId(), position.getQuantity());
235:         }
236: 
237:         Set<UUID> createdPurchaseIds = new HashSet<>();
238: 
239:         Set<ProductId> allFulfilledProductIds = new HashSet<>();
240: 
241:         while (!shoppingBasketMap.isEmpty()) {
242:             depots.sort(new DepotComparator(shoppingBasketMap, userAddress));
243:             Depot bestDepot = depots.get(0);
244:             Set<ProductId> fulfillableProducts = bestDepot.fulfillableShoppingBasketPositions(shoppingBasketMap);
245: 
246:             if (fulfillableProducts.isEmpty()) throw new InsufficientStockException("No depot can fulfill the remaining shopping basket items");
247: 
248:             Purchase purchase = createAndPersistPurchase(user.getId(), bestDepot, fulfillableProducts, shoppingBasketMap, createdPurchaseIds);
249:             allFulfilledProductIds.addAll(fulfillableProducts);
250:         }
251: 
252:         updateShoppingBasket(shoppingBasket, allFulfilledProductIds);
253: 
254:         return createdPurchaseIds;
255:     }
256:     public Set<UUID> checkout(ShoppingBasketId shoppingBasketId) {
257: 
258:         ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketById(shoppingBasketId)
259:                 .orElseThrow(() -> new ShoppingBasketNotFoundException("Shopping basket not found"));
260:         if (shoppingBasket.getShoppingBasketPositions().isEmpty()) throw new ConflictException("Shopping basket is empty");
261: 
262:         List<Depot> depots = depotService.getAllDepots();
263:         User user = userService.findUserById(shoppingBasket.getUserId())
264:                 .orElseThrow(()-> new UserNotFoundException("User not found!"));
265: 
266:         PhysicalAddress userAddress = user.getPhysicalAddress();
267: 
268:         Map<ProductId, Integer> shoppingBasketMap = new HashMap<>();
269:         for (ShoppingBasketPosition position : shoppingBasket.getShoppingBasketPositions()) {
270:             shoppingBasketMap.put(position.getProductId(), position.getQuantity());
271:         }
272: 
273:         Set<UUID> createdPurchaseIds = new HashSet<>();
274: 
275:         Set<ProductId> allFulfilledProductIds = new HashSet<>();
276: 
277:         while (!shoppingBasketMap.isEmpty()) {
278:             depots.sort(new DepotComparator(shoppingBasketMap, userAddress));
279:             Depot bestDepot = depots.get(0);
280:             Set<ProductId> fulfillableProducts = bestDepot.fulfillableShoppingBasketPositions(shoppingBasketMap);
281: 
282:             if (fulfillableProducts.isEmpty()) throw new ConflictException("No depot can fulfill the remaining shopping basket items");
283: 
284:             Purchase purchase = createAndPersistPurchase(user.getId(), bestDepot, fulfillableProducts, shoppingBasketMap, createdPurchaseIds);
285:             allFulfilledProductIds.addAll(fulfillableProducts);
286:         }
287: 
288:         updateShoppingBasket(shoppingBasket, allFulfilledProductIds);
289: 
290:         return createdPurchaseIds;
291:     }
292: 
293:     private Purchase createAndPersistPurchase(UserId userId, Depot depot, Set<ProductId> products,
294:                                               Map<ProductId, Integer> basketMap, Set<UUID> purchaseIds) {
295:         Purchase purchase = new Purchase(userId, depot.getId());
296: 
297:         for (ProductId productId : products) {
298:             int quantity = basketMap.get(productId);
299:             int availableStock = depotService.getAvailableStock(depot.getId(), productId);
300: 
301:             if (availableStock < quantity) {
302:                 throw new ConflictException("Not enough stock in depot " + depot.getName());
303:             }
304: 
305:             depotService.removeFromStock(depot.getId(), productId, quantity);
306:             purchase.getPurchasePositions().add(new PurchasePosition(productId, quantity));
307:         }
308: 
309:         purchaseRepository.save(purchase);
310:         purchaseIds.add(purchase.getId().getId());
311: 
312:         for (ProductId productId : products) {
313:             basketMap.remove(productId);
314:         }
315: 
316:         return purchase;
317:     }
318: 
319:     private void updateShoppingBasket(ShoppingBasket shoppingBasket, Set<ProductId> fulfilledProductIds) {
320:         shoppingBasket.removePositions(fulfilledProductIds);
321:         shoppingBasketRepository.save(shoppingBasket);
322:     }
323: 
324: 
325:     public void emptyAllShoppingBaskets() {
326:         shoppingBasketRepository.deleteAll();
327:     }
328: 
329:     public Optional<ShoppingBasket> findById(ShoppingBasketId shoppingBasketId){
330:         return shoppingBasketRepository.findById(shoppingBasketId);
331:     }
332: 
333:     // VALIDATE
334:     public void validateQuantity(int quantity) {
335:         if(quantity < 0) {
336:             throw new UnprocessableEntityException("Quantity must be a positive number");
337:         }
338:     }
339: 
340:     // =====================================
341:     // INTERNAL VALIDATION
342:     // =====================================
343:     private void nullThrow(List<Object> values) {
344:         for (Object value : values) {
345:             if (value == null) {
346:                 throw new ShopException("Ein übergebener Wert im UserService ist ungewollt null.");
347:             }
348:         }
349:     }
350: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\exceptions\ShoppingBasketNotFoundException.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Shopping Basket not found")
8: public class ShoppingBasketNotFoundException extends ShopException {
9:     public ShoppingBasketNotFoundException( String message ) {
10:         super( message );
11:     }
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\exceptions\ShoppingBasketPositionNotFoundException.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Shopping Basket not found")
8: public class ShoppingBasketPositionNotFoundException extends ShopException {
9:     public ShoppingBasketPositionNotFoundException( String message ) {
10:         super( message );
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.*;
5: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
6: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
7: 
8: import java.util.ArrayList;
9: import java.util.List;
10: import java.util.Optional;
11: import java.util.Set;
12: 
13: @Getter
14: @Entity
15: @AllArgsConstructor
16: @NoArgsConstructor(access = AccessLevel.PROTECTED)
17: public class ShoppingBasket {
18: 
19:     @Setter(AccessLevel.PRIVATE)
20:     @EmbeddedId
21:     private ShoppingBasketId id;
22: 
23:     @Setter
24:     private UserId userId;
25: 
26:     @Setter
27:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
28:     List<ShoppingBasketPosition> shoppingBasketPositions = new ArrayList<>();
29: 
30:     public ShoppingBasket(UserId userId) {
31:         this.id = new ShoppingBasketId();
32:         this.userId = userId;
33:     }
34: 
35:     public void removePosition(ShoppingBasketPosition position) {
36:         shoppingBasketPositions.remove(position);
37:     }
38: 
39:     public Optional<ShoppingBasketPosition> findShoppingBasketPositionsByProductId(ProductId productId) {
40:         for (ShoppingBasketPosition position : shoppingBasketPositions) {
41:             if (position.getProductId().equals(productId)) {
42:                 return Optional.of(position);
43:             }
44:         }
45:         return Optional.empty();
46:     }
47: 
48:     public void removePositions(Set<ProductId> productIds) {
49:         shoppingBasketPositions.removeIf(position -> productIds.contains(position.getProductId()));
50:     }
51: 
52:     public void addPosition(ShoppingBasketPosition shoppingBasketPosition){
53:         shoppingBasketPositions.add(shoppingBasketPosition);
54:     }
55: }
56: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "shopping_basket_id"))
15: public class ShoppingBasketId extends GenericId {
16:     public ShoppingBasketId( UUID id ) {
17:         super( id );
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ShoppingBasketIdConverter extends GenericIdConverter<ShoppingBasketId> {
8:     public ShoppingBasketIdConverter() {
9:         super(ShoppingBasketId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.EmbeddedId;
4: import jakarta.persistence.Entity;
5: import lombok.*;
6: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
7: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
9: 
10: @Getter
11: @Entity
12: @AllArgsConstructor
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: public class ShoppingBasketPosition {
15: 
16:     @Setter(AccessLevel.PRIVATE)
17:     @EmbeddedId
18:     private ShoppingBasketPositionId id;
19: 
20:     @Setter
21:     private ProductId productId;
22: 
23:     @Setter
24:     private Integer quantity;
25: 
26:     public ShoppingBasketPosition(ProductId productId, Integer quantity) {
27:         this.id = new ShoppingBasketPositionId();
28:         this.productId = productId;
29:         this.quantity = quantity;
30:     }
31: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "shopping_basket_position_id"))
15: public class ShoppingBasketPositionId extends GenericId {
16:     public ShoppingBasketPositionId( UUID id ) {
17:         super( id );
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ShoppingBasketPositionIdConverter extends GenericIdConverter<ShoppingBasketPositionId> {
8:     public ShoppingBasketPositionIdConverter() {
9:         super(ShoppingBasketPositionId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
6: 
7: import java.util.List;
8: import java.util.Optional;
9: 
10: @Repository
11: public interface ShoppingBasketRepository extends CrudRepository<ShoppingBasket, ShoppingBasketId> {
12:     Optional<ShoppingBasket> findShoppingBasketByUserId(UserId userId);
13:     Optional<ShoppingBasket> getShoppingBasketById(ShoppingBasketId id);
14: 
15:     Optional<ShoppingBasket> findShoppingBasketById(ShoppingBasketId shoppingBasketId);
16: }
17: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
5: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
6: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
7: import thkoeln.archilab.ecommerce.usecases.UserType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: 
11: @Service
12: public class UserAdapterService implements UserRegistrationUseCases {
13: 
14:     private final UserService userService;
15: 
16:     public UserAdapterService(UserService userService){
17:         this.userService = userService;
18:     }
19: 
20:     @Override
21:     public void register(String name, EmailAddressType emailAddress, PhysicalAddressType physicalAddress) {
22:         EmailAddress newEmailAddress = (EmailAddress) emailAddress;
23:         PhysicalAddress newPhysicalAddress = (PhysicalAddress) physicalAddress;
24:         userService.registerUser(name, newEmailAddress, newPhysicalAddress);
25:     }
26: 
27:     @Override
28:     public void changeAddress(EmailAddressType emailAddress, PhysicalAddressType physicalAddress ) {
29:         EmailAddress newEmailAddress = (EmailAddress) emailAddress;
30:         PhysicalAddress newPhysicalAddress = (PhysicalAddress) physicalAddress;
31:         userService.updateUserAddressByEmailAddress(newEmailAddress, newPhysicalAddress);
32:     }
33: 
34:     @Override
35:     public UserType getUserData(EmailAddressType userEmailAddress) {
36:         EmailAddress newEmailAddress = (EmailAddress) userEmailAddress;
37:         return userService.getUserByEmailAddress(newEmailAddress);
38:     }
39: 
40:     @Override
41:     public void deleteAllUsers() {
42:         userService.deleteAllUsers();
43:     }
44: }
45: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserController.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import jakarta.transaction.Transactional;
4: import org.modelmapper.ModelMapper;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.http.HttpStatus;
7: import org.springframework.http.ResponseEntity;
8: import org.springframework.web.bind.annotation.*;
9: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
10: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.ConflictException;
11: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.MethodNotAllowedException;
12: import thkoeln.archilab.ecommerce.solution.user.domain.User;
13: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
14: import thkoeln.archilab.ecommerce.solution.user.domain.exceptions.UserNotFoundException;
15: 
16: import java.util.UUID;
17: 
18: @RestController
19: @Transactional
20: @RequestMapping("/users")
21: public class UserController {
22: 
23:     private final ModelMapper modelMapper = new ModelMapper();
24:     private final UserService userService;
25: 
26:     @Autowired
27:     public UserController(UserService userService) {
28:         this.userService = userService;
29:     }
30: 
31:     /**
32:      * GET /users — Zugriff auf alle Benutzer ist verboten
33:      */
34:     @GetMapping
35:     public ResponseEntity<Void> getAllUsers() {
36:         throw new MethodNotAllowedException("Access to all users is forbidden. Use specific emailAddress.");
37:     }
38: 
39:     /**
40:      * GET /users/{id} — Benutzer per ID abrufen
41:      */
42:     @GetMapping("/{idStr}")
43:     public ResponseEntity<UserDTO> getUserById(@PathVariable String idStr) {
44: 
45:         // ─── 1. Konvertiere und validiere Parameter ───────────────────────────────
46:         UserId userId;
47:         try {
48:             userId = new UserId(UUID.fromString(idStr));
49:         } catch (IllegalArgumentException ex) {
50:             throw new UserNotFoundException("Invalid UUID format.");
51:         }
52: 
53:         // ─── 2. Führe die Business-Logik aus ──────────────────────────────────────
54:         User user = userService.getUserById(userId);
55: 
56:         // ─── 3. Wandle in DTO um ──────────────────────────────────────────────────
57:         UserDTO dto = modelMapper.map(user, UserDTO.class);
58: 
59:         // ─── 4. Rückgabe ──────────────────────────────────────────────────────────
60:         return ResponseEntity.ok(dto);
61:     }
62: 
63:     /**
64:      * GET /users?emailAddress=... — Benutzer per E-Mail abrufen
65:      */
66:     @GetMapping(params = "emailAddress")
67:     public ResponseEntity<UserDTO> getUserByEmailAddress(@RequestParam("emailAddress") String emailAddressStr) {
68: 
69:         // ─── 1. Konvertiere und validiere Parameter ───────────────────────────────
70:         EmailAddress emailAddress;
71:         try {
72:             emailAddress = EmailAddress.of(emailAddressStr);
73:         } catch (IllegalArgumentException ex) {
74:             throw new UserNotFoundException("Invalid emailAddress format.");
75:         }
76: 
77:         // ─── 2. Führe die Business-Logik aus ──────────────────────────────────────
78:         User user = userService.getUserByEmailAddress(emailAddress);
79: 
80:         // ─── 3. Wandle in DTO um ──────────────────────────────────────────────────
81:         UserDTO dto = modelMapper.map(user, UserDTO.class);
82: 
83:         // ─── 4. Rückgabe ──────────────────────────────────────────────────────────
84:         return ResponseEntity.ok(dto);
85:     }
86: 
87:     /**
88:      * DELETE /users/{id} — Benutzer löschen
89:      */
90:     @DeleteMapping("/{idStr}")
91:     public ResponseEntity<Void> deleteUser(@PathVariable String idStr) {
92: 
93:         // ─── 1. Konvertiere und validiere Parameter ───────────────────────────────
94:         UserId userId;
95:         try {
96:             userId = new UserId(UUID.fromString(idStr));
97:         } catch (IllegalArgumentException ex) {
98:             throw new UserNotFoundException("Invalid UUID format.");
99:         }
100: 
101:         // ─── 2. Führe die Business-Logik aus ──────────────────────────────────────
102:         userService.deleteUserById(userId);
103: 
104:         // ─── 3. Wandle in DTO um ──────────────────────────────────────────────────
105:         // ─── 4. Rückgabe ──────────────────────────────────────────────────────────
106:         return ResponseEntity.noContent().build();
107:     }
108: 
109:     /**
110:      * POST /users — Neuen Benutzer erstellen
111:      */
112:     @PostMapping
113:     public ResponseEntity<Void> createUser(@RequestBody UserDTO userDTO) {
114: 
115:         // ─── 1. Konvertiere und validiere Parameter ───────────────────────────────
116:         User user = UserDTOMapperHelper.mapUserDTOToUser(userDTO);
117: 
118:         // ─── 2. Führe die Business-Logik aus ──────────────────────────────────────
119:         User registeredUser = userService.registerUser(
120:                 user.getName(),
121:                 user.getEmailAddress(),
122:                 user.getPhysicalAddress()
123:         );
124: 
125:         // ─── 3. Wandle in DTO um ──────────────────────────────────────────────────
126:         UserDTO createdUserDTO = modelMapper.map(registeredUser, UserDTO.class);
127: 
128:         // ─── 4. Rückgabe mit Status 201 Created ───────────────────────────────────
129:         /*return ResponseEntity
130:                 .created(URI.create("/users/" + registeredUser.getId().toString()))
131:                 .body(createdUserDTO);*/
132:         return new ResponseEntity<>(HttpStatus.CREATED);
133:     }
134: 
135:     /**
136:      * PATCH /users — User updaten via id
137:      */
138:     @PatchMapping(path = "/{idStr}")
139:     public ResponseEntity<Void> createUser(
140:             @PathVariable String idStr,
141:             @RequestBody UserDTO userDTO
142:     ) {
143: 
144:         // ─── 1. Konvertiere und validiere Parameter ───────────────────────────────
145:         UserId userId;
146:         try {
147:             userId = new UserId(UUID.fromString(idStr));
148:         } catch (IllegalArgumentException ex) {
149:             throw new UserNotFoundException("Invalid UUID format.");
150:         }
151: 
152:         User user = UserDTOMapperHelper.mapUserDTOToUser(userDTO);
153: 
154:         // ─── 2. Führe die Business-Logik aus ──────────────────────────────────────
155:         userService.updateUserById(userId, user);
156: 
157:         // ─── 3. Wandle in DTO um ──────────────────────────────────────────────────
158:         // ─── 4. Rückgabe mit Status 201 Created ───────────────────────────────────
159:         return new ResponseEntity<>(HttpStatus.OK);
160:     }
161: 
162:     // =====================================
163:     // VALIDATION
164:     // =====================================
165:     private void nullThrow(Object... values) {
166:         for (Object value : values) {
167:             if (value == null) {
168:                 throw new ConflictException("Ein übergebener Wert im UserService ist ungewollt null.");
169:             }
170:         }
171:     }
172: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import lombok.*;
4: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
5: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
6: 
7: import java.util.UUID;
8: 
9: @Setter
10: @Getter
11: @AllArgsConstructor
12: @NoArgsConstructor
13: public class UserDTO {
14:     private UUID id;
15:     private EmailAddress emailAddress;
16:     private String name;
17:     private PhysicalAddress physicalAddress;
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserDTOMapperHelper.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import org.modelmapper.ModelMapper;
4: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
5: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
6: import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;
7: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.ConflictException;
8: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
9: import thkoeln.archilab.ecommerce.solution.user.domain.User;
10: 
11: public class UserDTOMapperHelper {
12:     static ModelMapper modelMapper = new ModelMapper();
13: 
14:     public static User mapUserDTOToUser(UserDTO userDTO){
15:         UserDTO validateUserDTO = UserDTOMapperHelper.validateUserDTO(userDTO);
16: 
17:         try {
18:             return modelMapper.map(validateUserDTO, User.class);
19:         } catch (Exception ex) {
20:             throw new ConflictException("Fehler bei Erstellung eines Users: " + ex.getMessage()); //409
21:         }
22:     }
23: 
24:     public static UserDTO validateUserDTO(UserDTO userDTO) {
25:         try {
26:             UserDTO validUserDTO = new UserDTO();
27: 
28:             // Name setzen, wenn vorhanden
29:             validUserDTO.setName(
30:                     userDTO.getName()
31:             );
32: 
33:             // EmailAddress setzen, wenn vorhanden
34:             if (userDTO.getEmailAddress() != null && userDTO.getEmailAddress().getEmail() != null) {
35:                 String emailAddressStr = userDTO.getEmailAddress().getEmail();
36: 
37:                 validUserDTO.setEmailAddress(
38:                         EmailAddress.of(emailAddressStr)
39:                 );
40:             }
41: 
42:             // PhysicalAddress setzen, wenn vorhanden
43:             if (userDTO.getPhysicalAddress() != null) {
44:                 String street = userDTO.getPhysicalAddress().getStreet();
45:                 String city = userDTO.getPhysicalAddress().getCity();
46: 
47:                 String postalCodeStr = userDTO.getPhysicalAddress().getPostalCode().toString();
48:                 PostalCode postalCode = PostalCode.of(postalCodeStr);
49: 
50:                 validUserDTO.setPhysicalAddress(
51:                         PhysicalAddress.of(street, city, postalCode)
52:                 );
53:             }
54: 
55:             return validUserDTO;
56: 
57:         } catch (Exception ex) {
58:             throw new UnprocessableEntityException("Ungültige Userdaten: " + ex.getMessage()); //422
59:         }
60:     }
61: }
62: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserService.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
5: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
6: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.ConflictException;
7: import thkoeln.archilab.ecommerce.solution.user.domain.exceptions.UserNotFoundException;
8: import thkoeln.archilab.ecommerce.solution.user.domain.User;
9: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
10: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
11: 
12: import java.util.Optional;
13: 
14: @Service
15: public class UserService {
16: 
17:     private final UserRepository userRepository;
18: 
19:     public UserService(UserRepository userRepository) {
20:         this.userRepository = userRepository;
21:     }
22: 
23:     // =====================================
24:     // USER REGISTRATION & CREATION
25:     // =====================================
26: 
27:     public User registerUser(String name, EmailAddress emailAddress, PhysicalAddress physicalAddress) {
28:         nullThrow(name, emailAddress, physicalAddress);
29:         if(name.isBlank())
30:             throw new ConflictException("Der Name: " +name+ " ist nicht valide.");
31:         if (existsUserByEmailAddress(emailAddress))
32:             throw new ConflictException("Diese E-Mail-Adresse: " +emailAddress.getEmail()+ " wird bereits verwendet.");
33: 
34:         User newUser = new User(name, emailAddress, physicalAddress);
35:         userRepository.save(newUser);
36:         return newUser;
37:     }
38: 
39:     // =====================================
40:     // UPDATE
41:     // =====================================
42: 
43:     public void updateUserById(UserId oldUserId, User newUser){
44:         nullThrow(oldUserId, newUser);
45:         User oldUser = this.getUserById(oldUserId);
46:         this.updateUser(oldUser, newUser);
47:     }
48: 
49:     public void updateUser(User oldUser, User newUser) {
50:         nullThrow(oldUser, newUser);
51: 
52:         if (newUser.getName() != null) {
53:             oldUser.setName(newUser.getName());
54:         }
55:         if (newUser.getEmailAddress() != null) {
56:             oldUser.setEmailAddress(newUser.getEmailAddress());
57:         }
58:         if (newUser.getPhysicalAddress() != null) {
59:             oldUser.setPhysicalAddress(newUser.getPhysicalAddress());
60:         }
61:     }
62: 
63:     public void updateUserNameById(UserId userId, String name){
64:         nullThrow(userId, name);
65:         User user = getUserById(userId);
66:         updateUserName(user, name);
67:     }
68: 
69:     public void updateUserAddressByEmailAddress(EmailAddress emailAddress, PhysicalAddress newPhysicalAddress) {
70:         nullThrow(emailAddress, newPhysicalAddress);
71:         User user = getUserByEmailAddress(emailAddress);
72:         updateUserAddress(user, newPhysicalAddress);
73:     }
74: 
75:     public void updateUserAddress(User user, PhysicalAddress newPhysicalAddress){
76:         nullThrow(user, newPhysicalAddress);
77:         user.setPhysicalAddress(newPhysicalAddress);
78:         userRepository.save(user);
79:     }
80: 
81:     public void updateUserName(User user, String name){
82:         nullThrow(user, name);
83:         user.setName(name);
84:         userRepository.save(user);
85:     }
86: 
87:     // =====================================
88:     // DELETE
89:     // =====================================
90: 
91:     public void deleteAllUsers() {
92:         userRepository.deleteAll();
93:     }
94: 
95:     public void deleteUserById(UserId userId){
96:         User user = getUserById(userId);
97:         deleteUser(user);
98:     }
99: 
100:     public void deleteUser(User user){
101:         userRepository.delete(user);
102:     }
103: 
104:     // =====================================
105:     // GET
106:     // =====================================
107: 
108:     public User getUserByEmailAddress(EmailAddress emailAddress) {
109:         nullThrow(emailAddress);
110:         User user = findUserByEmailAddress(emailAddress)
111:                 .orElseThrow(() -> new UserNotFoundException("Benutzer mit der Email Address: " +emailAddress.getEmail()+ " wurde nicht gefunden."));
112:         return user;
113:     }
114: 
115:     public String getUserNameById(UserId userId) {
116:         nullThrow(userId);
117:         User user = getUserById(userId);
118:         return user.getName();
119:     }
120: 
121:     public User getUserById(UserId userId){
122:         nullThrow(userId);
123:         User user = findUserById(userId)
124:                 .orElseThrow(() -> new UserNotFoundException("Benutzer mit der ID: " +userId.getId()+ " wurde nicht gefunden."));
125:         return user;
126:     }
127: 
128:     // =====================================
129:     // FIND
130:     // =====================================
131: 
132:     public Optional<User> findUserByEmailAddress(EmailAddress emailAddress) {
133:         nullThrow(emailAddress);
134:         return userRepository.findByEmailAddress(emailAddress);
135:     }
136: 
137:     public Optional<User> findUserById(UserId userId) {
138:         nullThrow(userId);
139:         return userRepository.findById(userId);
140:     }
141: 
142:     // =====================================
143:     // EXISTS
144:     // =====================================
145: 
146:     public boolean existsUserByEmailAddress(EmailAddress emailAddress){
147:         nullThrow(emailAddress);
148:         return userRepository.existsByEmailAddress(emailAddress);
149:     }
150: 
151:     public boolean existsUserById(UserId userId) {
152:         nullThrow(userId);
153:         return userRepository.existsById(userId);
154:     }
155: 
156:     // =====================================
157:     // VALIDATION
158:     // =====================================
159:     private void nullThrow(Object... values) {
160:         for (Object value : values) {
161:             if (value == null) {
162:                 throw new ConflictException("Ein übergebener Wert im UserService ist ungewollt null.");
163:             }
164:         }
165:     }
166: 
167:     // =====================================
168:     // INTERNAL HELPER
169:     // =====================================
170: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\exceptions\UserNotFoundException.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "User Not Found") //404
8: //@ResponseStatus(code = HttpStatus.METHOD_NOT_ALLOWED, reason = "DemoNotFoundException") //405
9: //@ResponseStatus(code = HttpStatus.CONFLICT, reason = "DemoNotFoundException") //409
10: //@ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY, reason = "DemoNotFoundException") //422
11: public class UserNotFoundException extends ShopException {
12:     public UserNotFoundException( String message ) {
13:         super( message );
14:     }
15: }
16: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\User.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import jakarta.persistence.Embedded;
5: import jakarta.persistence.EmbeddedId;
6: import jakarta.persistence.Entity;
7: import jakarta.persistence.Table;
8: import lombok.*;
9: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
10: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
11: import thkoeln.archilab.ecommerce.usecases.UserType;
12: 
13: @Getter
14: @Entity
15: @AllArgsConstructor
16: @NoArgsConstructor(access = AccessLevel.PROTECTED)
17: @Table(name = "\"user\"")
18: public class User implements UserType {
19: 
20:     @Setter(AccessLevel.PRIVATE)
21:     @EmbeddedId
22:     private UserId id;
23: 
24:     @Setter
25:     @Embedded
26:     @JsonProperty("emailAddress")
27:     private EmailAddress emailAddress;
28: 
29:     @Setter
30:     @JsonProperty("name")
31:     private String name;
32: 
33:     @Setter
34:     @Embedded
35:     @JsonProperty("physicalAddress")
36:     private PhysicalAddress physicalAddress;
37: 
38:     public User(String name, EmailAddress emailAddress, PhysicalAddress physicalAddress) {
39:         this.id = new UserId();
40:         this.emailAddress = emailAddress;
41:         this.name = name;
42:         this.physicalAddress = physicalAddress;
43:     }
44: }
45: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserId.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "customer_id"))
15: public class UserId extends GenericId {
16:     public UserId( UUID id ) {
17:         super( id );
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class UserIdConverter extends GenericIdConverter<UserId> {
8:     public UserIdConverter() {
9:         super(UserId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
6: 
7: import java.util.Optional;
8: 
9: @Repository
10: public interface UserRepository extends CrudRepository<User, UserId> {
11:     boolean existsByEmailAddress(EmailAddress emailAddress);
12:     Optional<User> findByEmailAddress(EmailAddress emailAddress);
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\DepotUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
9: 
10: import java.util.UUID;
11: 
12: /**
13:  * This interface contains methods needed in the context of handling the shop stock,
14:  * i.e. managing depots, and adding / removing products in the depot.
15:  */
16: public interface DepotUseCases {
17:     /**
18:      *
19:      * @param name
20:      * @param physicalAddress
21:      * @return the id of the new depot
22:      * @throws ShopException if ...
23:      *      - name is null or empty
24:      *      - physicalAddress is null
25:      */
26:     public UUID addNewDepot( String name, PhysicalAddressType physicalAddress );
27: 
28: 
29:     /**
30:      * Deletes all depots from the shop. Intended for testing purposes.
31:      */
32:     public void deleteAllDepots();
33: 
34: 
35:     /**
36:      * Adds a certain Quantity of a given product to the stock
37:      * @param depotId
38:      * @param productId
39:      * @param addedQuantOf
40:      * @throws ShopException if ...
41:      *      - depotId is null
42:      *      - the depot with that id does not exist
43:      *      - productId is null
44:      *      - the product with that id does not exist
45:      *      - addedQuantOf < 0
46:      */
47:     public void addToStock( UUID depotId, UUID productId, int addedQuantOf );
48: 
49: 
50:     /**
51:      * Removes a certain Quantity of a given product from the stock.
52:      * @param depotId
53:      * @param productId
54:      * @param removedQuantOf
55:      * @throws ShopException if ...
56:      *      - depotId is null
57:      *      - the depot with that id does not exist
58:      *      - productId is null
59:      *      - the product with that id does not exist
60:      *      - removedQuantOf < 0
61:      */
62:     public void removeFromStock( UUID depotId, UUID productId, int removedQuantOf );
63: 
64: 
65:     /**
66:      * Changes the total Quantity of a given product in the stock.
67:      * @param depotId
68:      * @param productId
69:      * @param newTotalQuantOf
70:      * @throws ShopException if ...
71:      *      - depotId is null
72:      *      - the depot with that id does not exist
73:      *      - productId is null
74:      *      - the product with that id does not exist
75:      *      - newTotalQuantOf < 0
76:      */
77:     public void changeStockTo( UUID depotId, UUID productId, int newTotalQuantOf );
78: 
79: 
80:     /**
81:      * Get the current stock of a given product in one specific depot.
82:      * @param depotId
83:      * @param productId
84:      * @return the current total stock of the product
85:      * @throws ShopException if ...
86:      *      - depotId is null
87:      *      - the depot with that id does not exist
88:      *      - productId is null
89:      *      - the product with that id does not exist
90:      */
91:     public int getAvailableStock( UUID depotId, UUID productId );
92: 
93: 
94: }
95: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\CurrencyType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface CurrencyType {
6:     /**
7:      * @return the quantity of currency
8:      */
9:     public Float getQuantity();
10: 
11: 
12:     /**
13:      * @return the currency unit of the currency
14:      */
15:     public String getCurrencyUnit();
16: 
17: 
18:     /**
19:      * @param otherCurrency
20:      * @return this + otherCurrency, as a new object
21:      * @throws ShopException if ...
22:      *      - otherCurrency is null
23:      *      - otherCurrency.currencyUnit != this.currencyUnit
24:      */
25:     public CurrencyType add( CurrencyType otherCurrency );
26: 
27: 
28:     /**
29:      * @param otherCurrency
30:      * @return this - otherCurrency, as a new object
31:      * @throws ShopException if ...
32:      *      - otherCurrency is null
33:      *      - otherCurrency.currencyUnit != this.currencyUnit
34:      *      - otherCurrency > this
35:      */
36:     public CurrencyType subtract( CurrencyType otherCurrency );
37: 
38: 
39:     /**
40:      * @param factor
41:      * @return this * factor, as a new object
42:      * @throws ShopException if ...
43:      *     - factor < 0
44:      */
45:     public CurrencyType multiplyBy( int factor );
46: 
47:     /**
48:      * @param otherCurrency
49:      * @return true, if this > otherCurrency
50:      * @throws ShopException if ...
51:      *      - otherCurrency is null
52:      *      - otherCurrency.currencyUnit != this.currencyUnit
53:      */
54:     public boolean largerThan( CurrencyType otherCurrency );
55: 
56: 
57:     /**
58:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
59:      * implementing class to provide a static factory method (simply named "of(...)"),
60:      * which creates a currency object from an quantity and a currency unit (as string).
61:      * We specify this factory method here as a comment, using the Javadoc documentation style.
62:      *
63:      * @param quantity the quantity of currency (must be >= 0)
64:      * @param currencyUnit the currency unit of the currency (allowed values: "EUR", "CHF")
65:      * @return a new Currency object with the given quantity and currency unit
66:      * @throws ShopException if ...
67:      *   - quantity is null
68:      *   - quantity < 0
69:      *   - currency unit is null
70:      *   - currency unit is not one of the allowed values
71:      */
72:      // public static CurrencyType of( Float quantity, String currencyUnit );
73: }
74: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\EmailAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface EmailAddressType {
6:     /**
7:      * @return the email address as a string
8:      */
9:     public String toString();
10: 
11: 
12:     /**
13:      * A special kind of "copy constructor": Returns a new email address object with
14:      * the same identifyer (the substring left of the "@" sign) as the current one, but
15:      * with a new domain substring (right of the "@" sign).
16:      * @param domainString - the new domain for the copied email address
17:      * @return the new email address
18:      * @throws ShopException if ...
19:      *     - domainString is null
20:      *     - the new email address would not be valid (see `of(...)` method)
21:      */
22:     public EmailAddressType sameIdentifyerDifferentDomain( String domainString );
23: 
24:     /**
25:      * Another special kind of "copy constructor": Returns a new email address object
26:      * with the same domain (the substring right of the "@" sign) as the current one, but
27:      * with a new identifyer substring (left of the "@" sign).
28:      * @param identifyerString - the new identifyer for the copied email address
29:      * @return the new email address
30:      * @throws ShopException if ...
31:      *     - identifyerString is null
32:      *     - the new email address would not be valid (see `of(...)` method)
33:      */
34:     public EmailAddressType sameDomainDifferentIdentifyer( String identifyerString );
35: 
36: 
37:     /**
38:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
39:      * implementing class to provide a static factory method (simply named "of(...)"),
40:      * which creates an email address, given as a string.
41:      * We specify this factory method here as a comment, using the Javadoc documentation style.
42:      *
43:      * @param emailAddressAsString - the email address as a string.
44:      *      We will use a much simplified validation method to check if the email address is valid:
45:      *      - it must contain exactly one '@' character.
46:      *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
47:      *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
48:      *      - the substrings before and after the '@' may contain one or several '.' as separators
49:      *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
50:      *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
51:      *        (for simplicity we do not allow any other domains)
52:      * @return a new EmailAddressType object matching the given email address
53:      * @throws ShopException if ...
54:      *      - emailAddressAsString is null
55:      *      - emailAddressAsString is not a valid email address (see above)
56:      */
57:      // public static EmailAddressType of( String emailAddressAsString );
58: }
59: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PhysicalAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface PhysicalAddressType {
6:     /**
7:      * @return the street as a string
8:      */
9:     public String getStreet();
10: 
11:     /**
12:      * @return the city as a string
13:      */
14:     public String getCity();
15: 
16:     /**
17:      * @return the postal code
18:      */
19:     public PostalCodeType getPostalCode();
20: 
21:     /**
22:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
23:      * implementing class to provide a static factory method (simply named "of(...)"),
24:      * which creates an postal code, given as a string.
25:      * We specify this factory method here as a comment, using the Javadoc documentation style.
26:      *
27:      * @param street the street as a string
28:      * @param city the city as a string
29:      * @param postalCode the postal code
30:      * @return the physical address object matching the parameters
31:      * @throws ShopException if ...
32:      *      - street is null or empty
33:      *      - city is null or empty
34:      *      - postalCode is null
35:      */
36:      // public static PhysicalAddressType of( String street, String city, PostalCodeType postalCode );
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PostalCodeType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnore;
4: import thkoeln.archilab.ecommerce.ShopException;
5: 
6: public interface PostalCodeType {
7:     /**
8:      * @return the postal code as a string
9:      */
10:     public String toString();
11: 
12:     /**
13:      * You will need some idea of "imprecise distance" between two postal codes for properly
14:      * implementing depots in your shopping platform. This method calculates such a
15:      * distance. You can decide for yourself what values you return, unless you comply
16:      * with the following rules.
17:      * - The return value is 0 if both postal codes are the same
18:      * - If not:
19:      *      - The distance is > 0 if both postal codes differ in the last digit, like 5673x
20:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
21:      *        So, 56733 and 56734 have the same distance as 56733 and 56739.
22:      *      - The distance grows if more digits (counted from the right side) differ.
23:      *        So, 5abcd and 5rstu have a larger distance than 53bcd and 53stu (if abcd
24:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
25:      *        53876 and 54876 have the same distance as 53876 and 57261.
26:      *      - However, the distance between 5abcd and 6rstu must be smaller than the one
27:      *        between 5abcd and 7rstu, and this distance in turn must be smaller than the
28:      *        one between 5abcd and 9rstu.
29:      *      - This last condition reflects the fact the first digits of a postal code marks a region
30:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
31:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
32:      *        other.
33:      * @param otherPostalCode
34:      * @return the calculated distance
35:      * @throws ShopException if otherPostalCode is null
36:      */
37:     public int distance( PostalCodeType otherPostalCode );
38: 
39: 
40:     /**
41:      * For the currently used way of deciding on the best fitting depot for a purchase,
42:      * we need to know the first digit of the postal code.
43:      */
44:     @JsonIgnore
45:     public Integer getFirstDigitPostalCode();
46: 
47: 
48:     /**
49:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
50:      * implementing class to provide a static factory method (simply named "of(...)"),
51:      * which creates an postal code, given as a string.
52:      * We specify this factory method here as a comment, using the Javadoc documentation style.
53:      *
54:      * @param postalCodeAsString - the postal code as a string.
55:      *      We will use a much simplified validation method to check if the postal code is valid:
56:      *      - It must contain exactly 5 digits.
57:      *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid postal code, but 20001 is valid)
58:      * @return a new postal code object matching the given string
59:      * @throws ShopException if ...
60:      *      - postalCodeAsString is null
61:      *      - postalCodeAsString is not a valid postal code (see above)
62:      */
63:      // public static PostalCodeType of( String postalCodeAsString );
64: }
65: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\DepotTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import java.util.UUID;
4: 
5: public interface DepotTestHelper {
6:     /**
7:      * Adds the test depots to the system.
8:      * If you want to use the depots, or want to know which index the depot has that you see
9:      * in the debugger, the following rules apply:
10:      * - The depot name will equal the street name of the physical address of the depot.
11:      * - The index number is visible in the house number. Example: depot 3 is located at
12:      *   "Ablageweg 3", and that is also its name.
13:      *
14:      *  The depots are used in the tests as follows:
15:      *  - depot 0 holds all products 0 - 6, and is used for all tests where it is not relevant
16:      *    to split one shopping basket into several purchases.
17:      *  - depots 1 - 3 are used for the proximity tests, where you can deliver product 7 to
18:      *    to a user from the closest depot.
19:      *  - depots 4 - 8 are used for the tests where you need to deliver products 8 - 14 in
20:      *    the most cost-efficient way, as multiple deliveries.
21:      *  - depot 9 is empty.
22:      *
23:      *  If withStock is true, then the depots are filled with products. This happens
24:      *  according to the following rules:
25:      *  - products 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
26:      *    ONLY available in depot 0. (This means that product 0 out of stock everywhere.)
27:      *  - products 4, 5, 6 have a random stock between 30 and 130, also all ONLY in depot 0
28:           (these are the products used for tests on how to add and remove stock)
29:      *  - product 7 has a random stock between 30 and 130, distributed over
30:      *    depots 1, 2, and 3. You can use this to test if the appropriate depot is found
31:      *    for a shopping basket with only product 7 in it, but with different quantities (<= 3, or > 3).
32:      *  - The other products (8 - 14) have also a random stock between 30 and 130, all distributed
33:      *    over several depots. The distribution is done as follows:
34:      *    Assume that the product is available in <n> depots. Then the first <n-1> depots
35:      *    in the list (in ascending sequence) contain 3, and all the remaining stock is in the
36:      *    last depot.
37:      *
38:      *    This is how the stock of products could be distributed
39:      *    (Wx = depot x with its postal code, Px = product x,
40:      *    numbers marked with (*) are random large numbers):
41:      *
42:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
43:      *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
44:      *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
45:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
46:      *    | P0   |      |     |     |      |     |      |     |       |      |     |
47:      *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
48:      *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
49:      *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
50:      *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
51:      *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
52:      *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
53:      *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
54:      *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
55:      *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
56:      *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
57:      *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
58:      *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
59:      *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
60:      *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
61:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
62:      *
63:      * @param withStock if true, the stock of the products is added to the depot. Otherwise, the
64:      *                           the stock is not added and the depot is empty.
65:      */
66:     public void addAllDepots( boolean withStock );
67: 
68: 
69:     /**
70:      * @return the number of test depots in the database
71:      */
72:     int numberOfDepots();
73: 
74: 
75:     /**
76:      * @param index
77:      * @return the id of the test depot at the given index
78:      */
79:     UUID getDepotId( int index );
80: 
81: 
82:     /**
83:      * @param depotId - the id of the depot in the test data
84:      * @return the index of the test depot with that id
85:      */
86:     int findDepotIndex( UUID depotId );
87: 
88: 
89:     /**
90:      * @param productIndex - the index of the product in the test data
91:      * @param depotIndex - the index of the depot in the test data
92:      * @return the number of products (stock) available in the depot at the given index
93:      */
94:     Integer getDepotStock( int depotIndex, int productIndex );
95: 
96: }
97: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
8: 
9: import java.io.File;
10: import java.io.IOException;
11: import java.lang.reflect.InvocationTargetException;
12: import java.lang.reflect.Method;
13: import java.lang.reflect.Modifier;
14: import java.net.URL;
15: import java.net.URLDecoder;
16: import java.nio.charset.StandardCharsets;
17: import java.util.Enumeration;
18: 
19: import static org.junit.jupiter.api.Assertions.*;
20: 
21: public class FactoryMethodInvoker {
22: 
23:     public static EmailAddressType instantiateEmailAddress( String emailAddressAsString ) {
24:         Method factoryMethod = null;
25:         try {
26:             Class<?> interfaceClass = Class.forName(
27:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType" );
28:             Class<?> implementingClass = findImplementation( interfaceClass );
29: 
30:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
31:             assertNotNull( factoryMethod );
32:             int modifiers = factoryMethod.getModifiers();
33:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
34:         } catch (Exception e) {
35:             fail( "Failed to find implementation for EmailAddressType", e );
36:         }
37: 
38:         Object instance = null;
39:         try {
40:             instance = factoryMethod.invoke( null, emailAddressAsString );
41:         } catch (Exception e) {
42:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
43:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
44:             fail( "Failed to invoke factory method 'of' for '" + emailAddressAsString + "'", e );
45:         }
46:         assertNotNull( instance );
47:         return (EmailAddressType) instance;
48:     }
49: 
50: 
51:     public static PhysicalAddressType instantiatePhysicalAddress(
52:             String street, String city, PostalCodeType postalCode ) {
53:         Method factoryMethod = null;
54:         try {
55:             Class<?> interfaceClass = Class.forName(
56:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType" );
57:             Class<?> implementingClass = findImplementation( interfaceClass );
58: 
59:             factoryMethod = implementingClass.getDeclaredMethod( "of",
60:                     String.class, String.class, PostalCodeType.class );
61:             assertNotNull( factoryMethod );
62:             int modifiers = factoryMethod.getModifiers();
63:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
64:         } catch (Exception e) {
65:             fail( "Failed to find implementation for PhysicalAddressType", e );
66:         }
67: 
68:         Object instance = null;
69:         try {
70:             instance = factoryMethod.invoke( null, street, city, postalCode );
71:         } catch (Exception e) {
72:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
73:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
74:             fail( "Failed to invoke factory method 'of' for '" +
75:                     street + "', '" + city + "', '" + postalCode + "'", e );
76:         }
77:         assertNotNull( instance );
78:         return (PhysicalAddressType) instance;
79:     }
80: 
81: 
82:     public static PostalCodeType instantiatePostalCode( String postalCodeAsString ) {
83:         Method factoryMethod = null;
84:         try {
85:             Class<?> interfaceClass = Class.forName(
86:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType" );
87:             Class<?> implementingClass = findImplementation( interfaceClass );
88: 
89:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
90:             assertNotNull( factoryMethod );
91:             int modifiers = factoryMethod.getModifiers();
92:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
93:         } catch (Exception e) {
94:             fail( "Failed to find implementation for PostalCodeType", e );
95:         }
96: 
97:         Object instance = null;
98:         try {
99:             instance = factoryMethod.invoke( null, postalCodeAsString );
100:         } catch (Exception e) {
101:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
102:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
103:             fail( "Failed to invoke factory method 'of' for '" + postalCodeAsString + "'", e );
104:         }
105:         assertNotNull( instance );
106:         return (PostalCodeType) instance;
107:     }
108: 
109: 
110:     public static CurrencyType instantiateCurrency( Float quantity, String currencyUnit ) {
111:         Method factoryMethod = null;
112:         try {
113:             Class<?> interfaceClass = Class.forName(
114:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType" );
115:             Class<?> implementingClass = findImplementation( interfaceClass );
116: 
117:             factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
118:             assertNotNull( factoryMethod );
119:             int modifiers = factoryMethod.getModifiers();
120:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
121:         } catch (Exception e) {
122:             fail( "Failed to find implementation for CurrencyType", e );
123:         }
124: 
125:         Object instance = null;
126:         try {
127:             instance = factoryMethod.invoke( null, quantity, currencyUnit );
128:         } catch (Exception e) {
129:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
130:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
131:             fail( "Failed to invoke factory method 'of' for '" + quantity + "', '" + currencyUnit + "'", e );
132:         }
133:         assertNotNull( instance );
134:         return (CurrencyType) instance;
135:     }
136: 
137: 
138:     private static Class<?> findImplementation( Class<?> interfaceClass ) {
139:         Method factoryMethod = null;
140:         try {
141:             String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
142:             Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
143:             assertNotNull( implementingClass );
144:             return implementingClass;
145:         } catch (Exception e) {
146:             fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
147:             return null; // This line will never be reached, but it's necessary to satisfy the compiler
148:         }
149:     }
150: 
151: 
152:     private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
153:             throws ClassNotFoundException, IOException {
154:         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
155:         String path = packageName.replace( '.', '/' );
156:         Enumeration<URL> resources = classLoader.getResources( path );
157:         int count = 0;
158:         Class<?> result = null;
159:         while (resources.hasMoreElements()) {
160:             URL resource = resources.nextElement();
161:             File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
162:             File[] files = directory.listFiles();
163:             for ( File file : files ) {
164:                 if ( file.getName().endsWith( ".class" ) ) {
165:                     String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
166:                     Class<?> clazz = Class.forName( className );
167:                     if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
168:                         count++;
169:                         result = clazz;
170:                     }
171:                 }
172:             }
173:         }
174:         assertEquals( 1, count, "There should be exactly one implementing class" );
175:         return result;
176:     }
177: }
178: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\StockTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.DepotTestHelper;
7: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
8: import thkoeln.archilab.ecommerce.usecases.DepotUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
12: 
13: import java.util.*;
14: 
15: /**
16:  * This is a test helper class that initializes and registers products (but without stock)
17:  * in the system, using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class StockTestHelperImpl
22:                         implements ProductTestHelper, DepotTestHelper {
23:     private ProductCatalogUseCases productCatalogUseCases;
24:     private DepotUseCases depotUseCases;
25:     private static Random random = new Random();
26: 
27:     private static final String EUR = "EUR";
28:     private static final int PRODUCT_NUMOF = 15;
29:     private static final Object[][] PRODUCT_DATA = new Object[][]{
30:             {null, "0-TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
31:                     1.5f, FactoryMethodInvoker.instantiateCurrency( 5.0f, EUR ),
32:                     FactoryMethodInvoker.instantiateCurrency( 10.0f, EUR ),
33:                     "0"},
34:             {null, "1-EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
35:                     0.3f, FactoryMethodInvoker.instantiateCurrency( 2.5f, EUR ),
36:                     FactoryMethodInvoker.instantiateCurrency( 4.0f, EUR ),
37:                     "0"},
38:             {null, "2-MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
39:                     7.2f, FactoryMethodInvoker.instantiateCurrency( 50.0f, EUR ),
40:                     FactoryMethodInvoker.instantiateCurrency( 80.0f, EUR ),
41:                     "0"},
42:             {null, "3-Gh-25", "Kompakter und leichter Akku für mobile Geräte",
43:                     null, FactoryMethodInvoker.instantiateCurrency( 6.0f, EUR ),
44:                     FactoryMethodInvoker.instantiateCurrency( 8.0f, EUR ),
45:                     "0"},
46:             {null, "4-MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
47:                     null, FactoryMethodInvoker.instantiateCurrency( 0.6f, EUR ),
48:                     FactoryMethodInvoker.instantiateCurrency( 1.0f, EUR ),
49:                     "0"},
50:             {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
51:                     1.0f, FactoryMethodInvoker.instantiateCurrency( 150.0f, EUR ),
52:                     FactoryMethodInvoker.instantiateCurrency( 250.0f, EUR ),
53:                     "0"},
54:             {null, "6-Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
55:                     null, FactoryMethodInvoker.instantiateCurrency( 0.3f, EUR ),
56:                     FactoryMethodInvoker.instantiateCurrency( 0.5f, EUR ),
57:                     "0"},
58:             {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
59:                     6.0f, FactoryMethodInvoker.instantiateCurrency( 80.0f, EUR ),
60:                     FactoryMethodInvoker.instantiateCurrency( 120.0f, EUR ),
61:                     "123"},
62:             {null, "8-JKL-67", "Wasserdichtes Gehäuse",
63:                     3.0f, FactoryMethodInvoker.instantiateCurrency( 1.0f, EUR ),
64:                     FactoryMethodInvoker.instantiateCurrency( 1.2f, EUR ),
65:                     "467"},
66:             {null, "9-MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
67:                     5.5f, FactoryMethodInvoker.instantiateCurrency( 25.0f, EUR ),
68:                     FactoryMethodInvoker.instantiateCurrency( 45.0f, EUR ),
69:                     "578"},
70:             {null, "10-PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
71:                     4.0f, FactoryMethodInvoker.instantiateCurrency( 20.0f, EUR ),
72:                     FactoryMethodInvoker.instantiateCurrency( 35.0f, EUR ),
73:                     "567"},
74:             {null, "11-STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
75:                     null, FactoryMethodInvoker.instantiateCurrency( 200.0f, EUR ),
76:                     FactoryMethodInvoker.instantiateCurrency( 350.0f, EUR ),
77:                     "478"},
78:             {null, "12-VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
79:                     null, FactoryMethodInvoker.instantiateCurrency( 15.0f, EUR ),
80:                     FactoryMethodInvoker.instantiateCurrency( 25.0f, EUR ),
81:                     "5"},
82:             {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
83:                     3.5f, FactoryMethodInvoker.instantiateCurrency( 60.0f, EUR ),
84:                     FactoryMethodInvoker.instantiateCurrency( 100.0f, EUR ),
85:                     "78"},
86:             {null, "14-Nosedive", "Klammer zum Verschließen der Nase beim Tauchen",
87:                     5.0f, FactoryMethodInvoker.instantiateCurrency( 2.0f, EUR ),
88:                     FactoryMethodInvoker.instantiateCurrency( 5.0f, EUR ),
89:                     "457"}
90:     };
91:     
92: 
93:     // These physical addresss are used for the depots. The depot name will equal
94:     // the postal code of the site. Their index number will be visible in the house number.
95:     // The depots are used as such:
96:     // - depot 0 is holds all products 0 - 6, and is used for all tests where multiple
97:     //   deliveries are irrelevant.
98:     // - depots 1 - 3 are used for the proximity tests, where you can deliver products 7 to
99:     //   to a user from the closest depot.
100:     // - depots 4 - 8 are used for the tests where you need to deliver products 8 - 14 in
101:     //   the most cost-efficient way, as multiple deliveries.
102:     // - depot 9 is empty.
103:     private final static int DEPOT_NUMOF = 10;
104:     private final static PhysicalAddressType[] DEPOT_PHYSICAL_ADDRESS = new PhysicalAddressType[]{
105:             FactoryMethodInvoker.instantiatePhysicalAddress(
106:                     "Stapelallee 0", "Potsdam",
107:                     FactoryMethodInvoker.instantiatePostalCode( "14476" ) ),
108:             FactoryMethodInvoker.instantiatePhysicalAddress(
109:                     "Lagerhausstr. 1", "Viertelstadt",
110:                     FactoryMethodInvoker.instantiatePostalCode( "02345" ) ),
111:             FactoryMethodInvoker.instantiatePhysicalAddress(
112:                     "Speicherplatz 2", "Viertelstadt",
113:                     FactoryMethodInvoker.instantiatePostalCode( "02313" ) ),
114:             FactoryMethodInvoker.instantiatePhysicalAddress(
115:                     "Ablageweg 3", "Reichswürgen",
116:                     FactoryMethodInvoker.instantiatePostalCode( "44923" ) ),
117:             FactoryMethodInvoker.instantiatePhysicalAddress(
118:                     "Paketstellenallee 4", "Düsseldorf",
119:                     FactoryMethodInvoker.instantiatePostalCode( "40588" ) ),
120:             FactoryMethodInvoker.instantiatePhysicalAddress(
121:                     "Kaputte-Sachen-Straße 5", "Düren",
122:                     FactoryMethodInvoker.instantiatePostalCode( "52355" ) ),
123:             FactoryMethodInvoker.instantiatePhysicalAddress(
124:                     "Aufbewahrungsweg 6", "Viernheim",
125:                     FactoryMethodInvoker.instantiatePostalCode( "68519" ) ),
126:             FactoryMethodInvoker.instantiatePhysicalAddress(
127:                     "Paketallee 7", "Baden-Baden",
128:                     FactoryMethodInvoker.instantiatePostalCode( "76532" ) ),
129:             FactoryMethodInvoker.instantiatePhysicalAddress(
130:                     "Sendenstr. 8", "Senden",
131:                     FactoryMethodInvoker.instantiatePostalCode( "89250" ) ),
132:             FactoryMethodInvoker.instantiatePhysicalAddress(
133:                     "Schickweg 9", "Hohenroth",
134:                     FactoryMethodInvoker.instantiatePostalCode( "97618" ) )
135:     };
136:     private final static UUID[] DEPOT_ID = new UUID[DEPOT_NUMOF];
137: 
138: 
139:     // These data structures contain the stock of the products in the depots.
140:     // PRODUCT_STOCK is a map product name -> Integer[DEPOT_NUMOF].
141:     // The Integer[DEPOT_NUMOF] contains the stock of the product in each of
142:     // the depots.
143:     //
144:     // The following rules apply:
145:     // - product 0 is out of stock
146:     // - product 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in depot 0
147:     // - product 4 / 5 / 6 have a random stock between 30 and 130, also all ONLY in depot 0
148:     //   (these are the products used for tests on how to add and remove stock)
149:     // - the others have a random stock between 30 and 130, distributed over several
150:     //   depots. Here we follow this convention for simplicity:
151:     //   - Assume that the product is available in <n> depots. Then the first <n-1> depots
152:     //     in the list (in ascending sequence) contain 3, and all the remaining stock is in the
153:     //     last depot.
154: 
155:     private static final Map<String, Integer[]> PRODUCT_STOCK = new HashMap<>();
156: 
157:     static {
158:         // products 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
159:         PRODUCT_STOCK.put( (String) PRODUCT_DATA[0][1],
160:                 getStockDistribution( 0, (String) PRODUCT_DATA[0][6] ) );
161:         PRODUCT_STOCK.put( (String) PRODUCT_DATA[1][1],
162:                 getStockDistribution( 10, (String) PRODUCT_DATA[1][6] ) );
163:         PRODUCT_STOCK.put( (String) PRODUCT_DATA[2][1],
164:                 getStockDistribution( 20, (String) PRODUCT_DATA[2][6] ) );
165:         PRODUCT_STOCK.put( (String) PRODUCT_DATA[3][1],
166:                 getStockDistribution( 30, (String) PRODUCT_DATA[3][6] ) );
167: 
168:         // The other products have a random stock between 30 and 130,
169:         for ( int i = 4; i < PRODUCT_NUMOF; i++ ) {
170:             Integer totalNumber = random.nextInt( 100 ) + 30;
171:             Integer[] stockInDepots =
172:                     getStockDistribution( totalNumber, (String) PRODUCT_DATA[i][6] );
173:             PRODUCT_STOCK.put( (String) PRODUCT_DATA[i][1], stockInDepots );
174:         }
175:     }
176: 
177:     /**
178:      * This method creates a random stock distribution for the given product.
179:      *
180:      * @param totalQuantity - the total number of products in the depots
181:      * @param zeroToNine  - a string with numbers between 0 and 9, representing the depots
182:      * @return an Integer array with the stock distribution for the product, according to
183:      * the rules described above.
184:      */
185:     private static Integer[] getStockDistribution( Integer totalQuantity, String zeroToNine ) {
186:         Integer[] stockInDepots = new Integer[DEPOT_NUMOF];
187:         for ( int i = 0; i < DEPOT_NUMOF; i++ ) stockInDepots[i] = 0;
188:         TreeSet<Integer> depotIndices = getDepotIndices( zeroToNine );
189:         int numOfIndices = depotIndices.size();
190:         int currentIndexNumber = 0;
191:         int currentQuantity = totalQuantity;
192:         for ( Integer depotIndex : depotIndices ) {
193:             currentIndexNumber++;
194:             if ( currentIndexNumber < numOfIndices ) {
195:                 stockInDepots[depotIndex] = 3;
196:                 currentQuantity -= 3;
197:             } else {
198:                 stockInDepots[depotIndex] = currentQuantity;
199:             }
200:         }
201:         return stockInDepots;
202:     }
203: 
204:     private static TreeSet<Integer> getDepotIndices( String zeroToNine ) {
205:         TreeSet<Integer> depotIndices = new TreeSet<>();
206:         for ( int i = 0; i < zeroToNine.length(); i++ ) {
207:             depotIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
208:         }
209:         return depotIndices;
210:     }
211: 
212: 
213:     @Autowired
214:     public StockTestHelperImpl( ProductCatalogUseCases productCatalogUseCases,
215:                                          DepotUseCases depotUseCases ) {
216:         this.productCatalogUseCases = productCatalogUseCases;
217:         this.depotUseCases = depotUseCases;
218:     }
219: 
220: 
221:     @Override
222:     public void addAllProducts() {
223:         int i = 0;
224:         for ( Object[] productData : PRODUCT_DATA ) {
225:             UUID newId = productCatalogUseCases.addProductToCatalog(
226:                     (String) productData[1], (String) productData[2],
227:                     (Float) productData[3], (CurrencyType) productData[4],
228:                     (CurrencyType) productData[5] );
229:             // The first element of the product data is the id, which was initialized with null before, but can now be set
230:             PRODUCT_DATA[i][0] = newId;
231:             i++;
232:         }
233:     }
234: 
235: 
236:     @Override
237:     public int numberOfProducts() {
238:         return PRODUCT_NUMOF;
239:     }
240: 
241: 
242:     @Override
243:     public UUID getProductId( int index ) {
244:         if ( index < 0 || index >= PRODUCT_NUMOF ) {
245:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
246:         }
247:         return (UUID) PRODUCT_DATA[index][0];
248:     }
249: 
250: 
251:     @Override
252:     public CurrencyType getBuyingPrice( int index ) {
253:         if ( index < 0 || index >= PRODUCT_NUMOF ) {
254:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
255:         }
256:         return (CurrencyType) PRODUCT_DATA[index][4];
257:     }
258: 
259: 
260:     @Override
261:     public CurrencyType getSalesPrice( int index ) {
262:         if ( index < 0 || index >= PRODUCT_NUMOF ) {
263:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
264:         }
265:         return (CurrencyType) PRODUCT_DATA[index][5];
266:     }
267: 
268: 
269:     @Override
270:     public void addAllDepots( boolean withStock ) {
271:         for ( int i = 0; i < DEPOT_NUMOF; i++ ) {
272:             DEPOT_ID[i] = depotUseCases.addNewDepot(
273:                     DEPOT_PHYSICAL_ADDRESS[i].getStreet(),
274:                     DEPOT_PHYSICAL_ADDRESS[i] );
275:         }
276:         if ( withStock ) {
277:             addAllStock();
278:         }
279:     }
280: 
281: 
282:     private void addAllStock() {
283:         for ( Object[] productData : PRODUCT_DATA ) {
284:             Integer[] stockInDepots =
285:                     PRODUCT_STOCK.get( productData[1] );
286:             for ( int iDepot = 0; iDepot < DEPOT_NUMOF; iDepot++ ) {
287:                 if ( stockInDepots[iDepot] > 0 )
288:                     depotUseCases.addToStock(
289:                             DEPOT_ID[iDepot], (UUID) productData[0],
290:                             stockInDepots[iDepot] );
291:             }
292:         }
293:     }
294: 
295: 
296:     @Override
297:     public int numberOfDepots() {
298:         return DEPOT_NUMOF;
299:     }
300: 
301: 
302:     @Override
303:     public UUID getDepotId( int index ) {
304:         if ( index < 0 || index >= DEPOT_NUMOF ) {
305:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
306:         }
307:         return DEPOT_ID[index];
308:     }
309: 
310: 
311:     @Override
312:     public Integer getDepotStock( int depotIndex, int productIndex ) {
313:         if ( depotIndex < 0 || depotIndex >= DEPOT_NUMOF ) {
314:             throw new IndexOutOfBoundsException( "Index out of bounds: " + depotIndex );
315:         }
316:         if ( productIndex < 0 || productIndex >= PRODUCT_NUMOF ) {
317:             throw new IndexOutOfBoundsException( "Index out of bounds: " + productIndex );
318:         }
319:         String productName = (String) PRODUCT_DATA[productIndex][1];
320:         Integer[] stockInDepots = PRODUCT_STOCK.get( productName );
321:         Integer foundStock = stockInDepots[depotIndex];
322:         return foundStock == null ? 0 : foundStock;
323:     }
324: 
325: 
326:     @Override
327:     public int findDepotIndex( UUID depotId ) {
328:         for ( int i = 0; i < DEPOT_NUMOF; i++ ) {
329:             if ( DEPOT_ID[i].equals( depotId ) ) {
330:                 return i;
331:             }
332:         }
333:         throw new IllegalArgumentException( "No test depot with UUID id " + depotId );
334:     }
335: 
336: 
337:     @Override
338:     public int findProductIndex( UUID productId ) {
339:         for ( int iProductData = 0; iProductData < DEPOT_NUMOF; iProductData++ ) {
340:             Object[] productData = PRODUCT_DATA[iProductData];
341:             if ( productData[0].equals( productId ) ) {
342:                 return iProductData;
343:             }
344:         }
345:         throw new IllegalArgumentException( "No test product with UUID id " + productId );
346:     }
347: }
348: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\UserTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
7: import thkoeln.archilab.ecommerce.usecases.UserType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.MockUser;
12: 
13: import static org.junit.jupiter.api.Assertions.assertThrows;
14: 
15: /**
16:  * This is a test helper class that initializes and registers users in the system,
17:  * using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class UserTestHelperImpl implements UserTestHelper {
22: 
23:     private UserRegistrationUseCases userRegistrationUseCases;
24: 
25:     @Autowired
26:     public UserTestHelperImpl( UserRegistrationUseCases userRegistrationUseCases ) {
27:         this.userRegistrationUseCases = userRegistrationUseCases;
28:     }
29: 
30:     private final static String[] USER_NAME = new String[]{
31:             "Max Mueller",
32:             "Sophie Schmitz",
33:             "Irene Mihalic",
34:             "Emilia Fischer",
35:             "Filiz Polat",
36:             "Lina Wagner",
37:             "Leon Becker",
38:             "Agnieszka Kalterer",
39:             "Felix Bauer",
40:             "Lara Schulz"
41:     };
42: 
43:     private final static EmailAddressType[] USER_EMAIL = new EmailAddressType[]{
44:             FactoryMethodInvoker.instantiateEmailAddress( "99Z@example.com" ),
45:             FactoryMethodInvoker.instantiateEmailAddress( "a@4.com" ),
46:             FactoryMethodInvoker.instantiateEmailAddress( "irene@wearefreedomnow.com" ),
47:             FactoryMethodInvoker.instantiateEmailAddress( "emilia.fischer@example.com" ),
48:             FactoryMethodInvoker.instantiateEmailAddress( "j877d3@example.this.com" ),
49:             FactoryMethodInvoker.instantiateEmailAddress( "lina.marie.wagner@example.com" ),
50:             FactoryMethodInvoker.instantiateEmailAddress( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
51:             FactoryMethodInvoker.instantiateEmailAddress( "agna@here.ch" ),
52:             FactoryMethodInvoker.instantiateEmailAddress( "felix.bauer@example.org" ),
53:             FactoryMethodInvoker.instantiateEmailAddress( "lara.schulz@example.at" )
54:     };
55: 
56:     // The following array is used to create a list of physicalAddresss for the users.
57:     // The indices are coded into the house number.
58:     // - Persons 0 - 5 are used for proximity tests with one depot.
59:     private final static PhysicalAddressType[] USER_ADDRESS = new PhysicalAddressType[]{
60:             FactoryMethodInvoker.instantiatePhysicalAddress(
61:                     "Marktstraße 0", "Viertelstadt",
62:                     FactoryMethodInvoker.instantiatePostalCode( "02314" ) ),
63:             FactoryMethodInvoker.instantiatePhysicalAddress(
64:                     "Hauptstraße 1", "Viertelstadt",
65:                     FactoryMethodInvoker.instantiatePostalCode( "02368" ) ),
66:             FactoryMethodInvoker.instantiatePhysicalAddress(
67:                     "Kirchplatz 2", "Niemandstown",
68:                     FactoryMethodInvoker.instantiatePostalCode( "12345" ) ),
69:             FactoryMethodInvoker.instantiatePhysicalAddress(
70:                     "Schulstraße 3", "Geisterhausen",
71:                     FactoryMethodInvoker.instantiatePostalCode( "31463" ) ),
72:             FactoryMethodInvoker.instantiatePhysicalAddress(
73:                     "Rosenweg 4", "Kuhhausen",
74:                     FactoryMethodInvoker.instantiatePostalCode( "72162" ) ),
75:             FactoryMethodInvoker.instantiatePhysicalAddress(
76:                     "Wiesenstraße 5", "Waldschenkensdorf",
77:                     FactoryMethodInvoker.instantiatePostalCode( "82195" ) ),
78:             FactoryMethodInvoker.instantiatePhysicalAddress(
79:                     "Muehlenweg 6", "Koeln",
80:                     FactoryMethodInvoker.instantiatePostalCode( "50667" ) ),
81:             FactoryMethodInvoker.instantiatePhysicalAddress(
82:                     "Goethestraße 7", "Frankfurt am Main",
83:                     FactoryMethodInvoker.instantiatePostalCode( "60311" ) ),
84:             FactoryMethodInvoker.instantiatePhysicalAddress(
85:                     "Dorfstraße 8", "Stuttgart",
86:                     FactoryMethodInvoker.instantiatePostalCode( "70173" ) ),
87:             FactoryMethodInvoker.instantiatePhysicalAddress(
88:                     "Bahnhofstraße 9", "Muenchen",
89:                     FactoryMethodInvoker.instantiatePostalCode( "80331" ) )
90:     };
91: 
92:     private final static UserType[] mockUsers;
93: 
94:     static {
95:         mockUsers = new UserType[USER_NAME.length];
96:         for ( int i = 0; i < USER_NAME.length; i++ ) {
97:             mockUsers[i] = new MockUser(
98:                     USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
99:         }
100:     }
101: 
102: 
103:     @Override
104:     public void registerAllUsers() {
105:         for ( int i = 0; i < USER_NAME.length; i++ ) {
106:             registerUser( USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
107:         }
108:     }
109: 
110: 
111:     private void registerUser( String name, EmailAddressType emailAddress, PhysicalAddressType physicalAddress ) {
112:         userRegistrationUseCases.register( name, emailAddress, physicalAddress );
113:     }
114: 
115: 
116:     @Override
117:     public int getNumberOfUsers() {
118:         return USER_NAME.length;
119:     }
120: 
121: 
122:     @Override
123:     public String getUserName( int index ) {
124:         if ( index < 0 || index >= USER_NAME.length ) {
125:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
126:         }
127:         return USER_NAME[index];
128:     }
129: 
130: 
131:     @Override
132:     public EmailAddressType getUserEmailAddress( int index ) {
133:         if ( index < 0 || index >= USER_NAME.length ) {
134:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
135:         }
136:         return USER_EMAIL[index];
137:     }
138: 
139: 
140:     @Override
141:     public PhysicalAddressType getUserPhysicalAddress( int index ) {
142:         if ( index < 0 || index >= USER_NAME.length ) {
143:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
144:         }
145:         return USER_ADDRESS[index];
146:     }
147: 
148: 
149:     @Override
150:     public UserType getUser( int index ) {
151:         if ( index < 0 || index >= USER_NAME.length ) {
152:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
153:         }
154:         return mockUsers[index];
155:     }
156: }
157: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockUser.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.Setter;
4: import thkoeln.archilab.ecommerce.usecases.UserType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;
6: 
7: 
8: import java.util.Objects;
9: 
10: @Setter
11: public class MockUser implements UserType {
12:     private String name;
13:     private EmailAddressType emailAddressType;
14:     private PhysicalAddressType physicalAddressType;
15: 
16: 
17:     public MockUser( String name, EmailAddressType emailAddressType, PhysicalAddressType physicalAddressType) {
18:         this.name = name;
19:         this.emailAddressType = emailAddressType;
20:         this.physicalAddressType = physicalAddressType;
21:     }
22: 
23:     @Override
24:     public String getName() {
25:         return name;
26:     }
27: 
28:     @Override
29:     public EmailAddressType getEmailAddress() {
30:         return emailAddressType;
31:     }
32: 
33:     @Override
34:     public PhysicalAddressType getPhysicalAddress() {
35:         return physicalAddressType;
36:     }
37: 
38:     @Override
39:     public boolean equals( Object o ) {
40:         if ( this == o ) return true;
41:         if ( !( o instanceof MockUser ) ) return false;
42:         MockUser that = (MockUser) o;
43:         return Objects.equals( getName(), that.getName() ) &&
44:                 Objects.equals( emailAddressType, that.emailAddressType ) &&
45:                 Objects.equals( physicalAddressType, that.physicalAddressType );
46:     }
47: 
48:     @Override
49:     public int hashCode() {
50:         return Objects.hash( getName(), emailAddressType, physicalAddressType );
51:     }
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ProductTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
4: 
5: import java.util.UUID;
6: 
7: public interface ProductTestHelper {
8:     /**
9:      * Adds all test products to the database.
10:      * If you use the debugger and want to identify _which_ test product you currently look at:
11:      * The indices are coded into the first number in the name string of the product, like e.g.
12:      * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
13:      */
14:     void addAllProducts();
15: 
16: 
17:     /**
18:      * @return the number of test products in the database
19:      */
20:     int numberOfProducts();
21: 
22: 
23:     /**
24:      * @param index
25:      * @return the id of the test product at the given index
26:      */
27:     UUID getProductId( int index );
28: 
29: 
30:     /**
31:      * @param productId - the id of the product in the test data
32:      * @return the index of the test product with that id
33:      */
34:     int findProductIndex( UUID productId );
35: 
36: 
37:     /**
38:      * @param index
39:      * @return the buying price of test product at the given index
40:      */
41:     CurrencyType getBuyingPrice( int index );
42: 
43: 
44:     /**
45:      * @param index
46:      * @return the sales price of test product at the given index
47:      */
48:     CurrencyType getSalesPrice( int index );
49: }
50: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.usecases.*;
6: 
7: /**
8:  * Removes everything :-)
9:  */
10: @Service
11: public class Purgatory {
12:     @Autowired
13:     private UserRegistrationUseCases userRegistrationUseCases;
14:     @Autowired
15:     private ShoppingBasketUseCases shoppingBasketUseCases;
16:     @Autowired
17:     private PurchaseUseCases purchaseUseCases;
18:     @Autowired
19:     private ProductCatalogUseCases productCatalogUseCases;
20:     @Autowired
21:     private DepotUseCases depotUseCases;
22: 
23:     public void deleteEverything() {
24:         purchaseUseCases.deleteAllPurchases();
25:         shoppingBasketUseCases.emptyAllShoppingBaskets();
26:         depotUseCases.deleteAllDepots();
27:         userRegistrationUseCases.deleteAllUsers();
28:         productCatalogUseCases.deleteProductCatalog();
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.context.ApplicationListener;
6: import org.springframework.context.annotation.Profile;
7: import org.springframework.context.event.ContextRefreshedEvent;
8: import org.springframework.stereotype.Component;
9: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.DepotUseCases;
12: 
13: @Component
14: @Slf4j
15: @Profile("!test")
16: @SuppressWarnings("PMD")
17: public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
18:     private Purgatory purgatory;
19:     private UserTestHelper userTestHelper;
20:     private ProductTestHelper productTestHelper;
21:     private DepotTestHelper depotTestHelper;
22: 
23: 
24:     @Autowired
25:     public StartupListener( Purgatory purgatory,
26:                             UserTestHelper userTestHelper,
27:                             ProductTestHelper productTestHelper,
28:                             DepotTestHelper depotTestHelper ) {
29:         this.purgatory = purgatory;
30:         this.userTestHelper = userTestHelper;
31:         this.productTestHelper = productTestHelper;
32:         this.depotTestHelper = depotTestHelper;
33:     }
34: 
35:     @Override
36:     public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
37:         log.info( "StartupListener initializing master data ..." );
38:         purgatory.deleteEverything();
39:         userTestHelper.registerAllUsers();
40:         productTestHelper.addAllProducts();
41:         depotTestHelper.addAllDepots( true );
42:     }
43: }
44: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\UserTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: 
4: import thkoeln.archilab.ecommerce.usecases.UserType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
7: 
8: /**
9:  * This is a test helper interface provides access to predefined test data for
10:  * users.
11:  */
12: public interface UserTestHelper {
13:     /**
14:      * This method calls the use case implementation to register all users specified in the
15:      * test data set.
16:      * If you use the debugger and want to identify _which_ test user you currently look at:
17:      * The indices are coded into the house number (in the user's physical address) and in the first
18:      * cipher of the postal code. This is the list of users:
19:      *
20:      * +-------+-------------------+--------+---------------------
21:      * | Index | Name              | PLZ    | EmailAddress
22:      * +-------+-------------------+--------+---------------------
23:      * | 0     | Max Mueller       | 02314  | 99Z@example.com
24:      * | 1     | Sophie Schmitz    | 02368  | a@4.com
25:      * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
26:      * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
27:      * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
28:      * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
29:      * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
30:      * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
31:      * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
32:      * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
33:      * +-------+-------------------+--------+---------------------
34:      */
35:     void registerAllUsers();
36: 
37: 
38:     /**
39:      * @return the number of test users in the test data set.
40:      */
41:     int getNumberOfUsers();
42: 
43: 
44:     /**
45:      * @param index the index of the user in the test data set.
46:      * @return the name of the test user with the given index.
47:      */
48:     String getUserName( int index );
49: 
50: 
51:     /**
52:      * @param index the index of the user in the test data set.
53:      * @return the email address of the test user with the given index.
54:      */
55:     EmailAddressType getUserEmailAddress( int index );
56: 
57: 
58:     /**
59:      * @param index the index of the user in the test data set.
60:      * @return the physical address of the test user with the given index.
61:      */
62:     PhysicalAddressType getUserPhysicalAddress( int index );
63: 
64: 
65:     /**
66:      * @param index the index of the user in the test data set.
67:      * @return the test user with the given index.
68:      */
69:     UserType getUser( int index );
70: 
71: }
72: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\ProductCatalogUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
9: 
10: import java.util.UUID;
11: 
12: 
13: /**
14:  * This interface contains methods needed in the context of use cases concerning the product catalog.
15:  * The interface is probably incomplete, and will grow over time ...
16:  */
17: 
18: public interface ProductCatalogUseCases {
19:     /**
20:      * Adds a new product to the shop catalog
21:      * @param name
22:      * @param descriptFor
23:      * @param size
24:      * @param buyingPrice
25:      * @param salesPrice
26:      * @return the id of the new product
27:      * @throws ShopException if ...
28:      *      - the product id already exists,
29:      *      - name or description are null or empty,
30:      *      - the size is <= 0 (but can be null!),
31:      *      - the buying price is null or <= 0,
32:      *      - the buyingPrice is null,
33:      *      - the sales price is null,
34:      *      - the sales price is lower than the buyingPrice
35:      */
36:     public UUID addProductToCatalog( String name, String descriptFor, Float size,
37:                                            CurrencyType buyingPrice, CurrencyType salesPrice );
38: 
39: 
40:     /**
41:      * Removes a product from the shop catalog
42:      * @param productId
43:      * @throws ShopException if
44:      *      - productId is null
45:      *      - the product id does not exist
46:      *      - the product is still in stock
47:      *      - the product is still in a shopping basket, or referenced by a completed purchase
48:      */
49:     public void removeProductFromCatalog( UUID productId );
50: 
51: 
52:     /**
53:      * Get the sales price of a given product
54:      * @param productId
55:      * @return the sales price
56:      * @throws ShopException if ...
57:      *      - productId is null,
58:      *      - the product with that id does not exist
59:      */
60:     public CurrencyType getSalesPrice( UUID productId );
61: 
62: 
63:     /**
64:      * Clears the product catalog, i.e. removes all products from the catalog, including all the stock,
65:      * all the reservations and all the purchases.
66:      */
67:     public void deleteProductCatalog();
68: 
69: }
70: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\PurchaseUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: package thkoeln.archilab.ecommerce.usecases;
5: 
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
9: 
10: import java.util.Map;
11: import java.util.UUID;
12: 
13: /**
14:  * This interface contains methods needed in the context of the purchase history of a user.
15:  */
16: public interface PurchaseUseCases {
17: 
18:     /**
19:      * Returns a map showing which products have been purchased by a user and how many of each product
20:      *
21:      * @param userEmailAddress
22:      * @return the purchase history of the user (map is empty if the user has not purchased anything yet)
23:      * @throws ShopException if
24:      *      - userEmailAddress is null
25:      *      - the user with the given email address does not exist
26:      */
27:     public Map<UUID, Integer> getPurchaseHistory( EmailAddressType userEmailAddress );
28: 
29: 
30: 
31:     /**
32:      * @return the number of products in a given purchase. If the product is not a position of the purchase, the method
33:      *         returns 0. No exception is thrown.
34:      * @param purchaseId - the id of the purchase to be checked
35:      * @param productId - the id of the product for which we want to know the quantity
36:      * @throws ShopException if
37:      *     - purchaseId is null, or doesn't exist in the system
38:      *     - productId is null, or doesn't exist in the system
39:      */
40:     public Integer getPurchaseQuantOfProduct( UUID purchaseId, UUID productId );
41: 
42: 
43:     /**
44:      * @return the id of the depot that is responsible for the given purchase
45:      * @param purchaseId - the id of the purchase to be checked
46:      * @throws ShopException if
47:      *      - purchaseId is null, or doesn't exist in the system
48:      */
49:     public UUID getDepotIdForPurchase( UUID purchaseId );
50: 
51: 
52:     /**
53:      * Deletes all purchases in the system
54:      */
55:     public void deleteAllPurchases();
56: }
57: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingBasketUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
10: 
11: import java.util.Map;
12: import java.util.Set;
13: import java.util.UUID;
14: 
15: /**
16:  * This interface contains methods needed in the context of use cases handling the shopping basket.
17:  * The interface is probably incomplete, and will grow over time ...
18:  */
19: public interface ShoppingBasketUseCases {
20:     /**
21:      * Adds a product to the cart of a user
22:      *
23:      * @param userEmailAddress
24:      * @param productId
25:      * @param quantOf
26:      * @throws ShopException if ...
27:      *          - userEmailAddress is null,
28:      *          - the user with the given email address does not exist,
29:      *          - productId is null,
30:      *          - the product with productId does not exist
31:      *          - the Quantity is negative,
32:      */
33:     public void addProductToShoppingBasket( EmailAddressType userEmailAddress,
34:                                                  UUID productId, int quantOf );
35: 
36: 
37:     /**
38:      * Removes a product from the cart of a user
39:      *
40:      * @param userEmailAddress
41:      * @param productId
42:      * @param quantOf
43:      * @throws ShopException if ...
44:      *          - userEmailAddress is null,
45:      *          - the user with the given email address does not exist,
46:      *          - productId is null,
47:      *          - the product with productId does not exist
48:      *          - the Quantity is negative
49:      *          - the product is not in the shopping basket in the requested Quantity
50:      */
51:     public void removeProductFromShoppingBasket( EmailAddressType userEmailAddress,
52:                                                       UUID productId, int quantOf );
53: 
54: 
55:     /**
56:      * Returns a map showing which products are in the cart of a user and how many of each product
57:      *
58:      * @param userEmailAddress
59:      * @return the cart of the user (map is empty if the cart is empty)
60:      * @throws ShopException if
61:      *          - userEmailAddress is null,
62:      *          - the user with the given email address does not exist
63:      */
64:     public Map<UUID, Integer> getShoppingBasketAsMap( EmailAddressType userEmailAddress );
65: 
66: 
67:     /**
68:      * Returns the current value of all products in the cart of a user
69:      *
70:      * @param userEmailAddress
71:      * @return the cart of the user
72:      * @throws ShopException if
73:      *          - userEmailAddress is null,
74:      *          - the user with the given email address does not exist
75:      */
76:     public CurrencyType getShoppingBasketAsCurrencyValue( EmailAddressType userEmailAddress );
77: 
78: 
79: 
80: 
81:     /**
82:      * Checks out the cart of a user
83:      *
84:      * @param userEmailAddress
85:      * @return A set of ids belonging to purchases that were created during the checkout. If the shopping basket can
86:      *         only be served from more than one depot, each delivery from a depot gets a
87:      *         dedicated purchase. I.e. if there is just one delivery, then the set will contain just one purchase id.
88:      *         If there are multiple deliveries, the set will contain multiple purchase ids.
89:      * @throws ShopException if
90:      *      - userEmailAddress is null or empty
91:      *      - the user with the given email address does not exist, or if the cart is empty
92:      * @throws
93:      *      - ShopException if userEmailAddress is null
94:      *      - InsufficientStockException if there is not enough stock level for to serve the purchase
95:      *        for all products in the shopping basket
96:      */
97:     public Set<UUID> checkout( EmailAddressType userEmailAddress );
98: 
99: 
100:     /**
101:      * Empties all shopping baskets in the system
102:      */
103:     public void emptyAllShoppingBaskets();
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\UserRegistrationUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: 
11: /**
12:  * This interface contains methods needed in the context of use cases concerning the registration of a user.
13:  * The interface is probably incomplete, and will grow over time ...
14:  */
15: public interface UserRegistrationUseCases {
16:     /**
17:      * Registers a new user
18:      *
19:      * @param name
20:      * @param emailAddress
21:      * @param physicalAddress
22:      * @throws ShopException if ...
23:      *      - the user with the given email address already exists
24:      *      - physicalAddress is null
25:      */
26:     public void register( String name, EmailAddressType emailAddress, PhysicalAddressType physicalAddress );
27: 
28: 
29:     /**
30:      * Changes the address of a user
31:      *
32:      * @param userEmailAddress
33:      * @param userEmailAddress
34:      * @param physicalAddress
35:      * @throws ShopException if ...
36:      *      - the user with the given email address does not exist,
37:      *      - physicalAddress is null
38:      */
39:     public void changeAddress( EmailAddressType userEmailAddress,
40:                                PhysicalAddressType physicalAddress );
41: 
42: 
43:     /**
44:      * Returns the data of a user as an array of strings (name, emailAddress, street, city, postalCode)
45:      * @param userEmailAddress
46:      * @return the user data
47:      * @throws ShopException the user with the given email address does not exist,
48:      */
49:     public UserType getUserData( EmailAddressType userEmailAddress );
50: 
51: 
52: 
53:     /**
54:      * Clears all users, including all purchases and shopping baskets
55:      */
56:     public void deleteAllUsers();
57: }
58: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\UserType.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
5: 
6: /**
7:  * This interface expresses the essence of a shop user
8:  */
9: public interface UserType {
10:     String getName();
11:     EmailAddressType getEmailAddress();
12:     PhysicalAddressType getPhysicalAddress();
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import org.springframework.boot.test.context.TestConfiguration;
4: import org.springframework.context.annotation.Bean;
5: import org.springframework.test.web.servlet.MockMvc;
6: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
7: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
8: 
9: 
10: @TestConfiguration
11: public class RESTTestHelperConfiguration {
12: 
13:     @Bean
14:     public ShoppingBasketRESTHelper shoppingBasketRESTHelper(
15:             MockMvc mockMvc, ProductCatalogUseCases productCatalogUseCases ) {
16:         return new ShoppingBasketRESTHelperImpl( mockMvc, productCatalogUseCases );
17:     }
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingBasketRESTHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import com.fasterxml.jackson.databind.ObjectMapper;
5: import lombok.AllArgsConstructor;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import lombok.Setter;
9: import lombok.extern.slf4j.Slf4j;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.MvcResult;
12: import org.springframework.test.web.servlet.ResultActions;
13: import org.springframework.test.web.servlet.ResultMatcher;
14: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
15: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
18: 
19: import java.util.Map;
20: import java.util.UUID;
21: 
22: import static org.springframework.http.MediaType.APPLICATION_JSON;
23: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
24: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
25: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
26: 
27: @Slf4j
28: public class ShoppingBasketRESTHelperImpl implements ShoppingBasketRESTHelper {
29:     private MockMvc mockMvc;
30:     private ProductCatalogUseCases productCatalogUseCases;
31: 
32:     private static final ResultMatcher CREATED = status().isCreated();
33:     private static final ResultMatcher OK = status().isOk();
34: 
35:     public ShoppingBasketRESTHelperImpl( MockMvc mockMvc, ProductCatalogUseCases productCatalogUseCases ) {
36:         this.mockMvc = mockMvc;
37:         this.productCatalogUseCases = productCatalogUseCases;
38:     }
39: 
40: 
41:     @Override
42:     public UUID getQueryShoppingBasket( EmailAddressType emailAddress, Map<UUID, Integer> quantityMap )
43:             throws Exception {
44:         // first query the users API to get the proper userId
45:         UUID userId;
46:         String userUri = "/users?emailAddress=" + emailAddress.toString();
47:         MvcResult userGetResult = mockMvc.perform( get( userUri ) )
48:                 .andExpect( status().isOk() )
49:                 .andReturn();
50:         ObjectMapper objectMapper = new ObjectMapper();
51:         IdDTO idDTO = objectMapper.readValue( userGetResult.getResponse().getContentAsString(), IdDTO.class );
52:         userId = idDTO.getId();
53: 
54:         // then query the shopping basket API and extract the shopping basket id
55:         String shoppingBasketUri = "/shoppingBaskets?userId=" + userId.toString();
56:         ResultActions resultActions = mockMvc.perform( get( shoppingBasketUri ) )
57:                 .andExpect( status().isOk() );
58:         idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
59:         UUID shoppingBasketId = idDTO.getId();
60: 
61:         // additional checks, if desired
62:         if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
63:         return shoppingBasketId;
64:     }
65: 
66: 
67:     private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
68:         if ( quantityMap == null ) return;
69:         int numOfProducts = quantityMap.size();
70:         resultActions.andExpect( jsonPath( "$.positions.length()" ).value( numOfProducts ) );
71:         float totalSalesPriceAsFloat = 0f;
72:         for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
73:             UUID productId = entry.getKey();
74:             Integer quantity = entry.getValue();
75:             resultActions.andExpect( jsonPath( "$.positions.[?(@.productId == '" + productId + "')].quantity" )
76:                     .value( quantity ) );
77:             CurrencyType salesPrice = productCatalogUseCases.getSalesPrice( productId );
78:             totalSalesPriceAsFloat += salesPrice.getQuantity() * quantity;
79:         }
80:         // last thing - check the total sales price
81:         String totalSalesPriceString = String.format( "%.2f €", totalSalesPriceAsFloat );
82:         resultActions
83:                 .andExpect( jsonPath( "$.totalSalesPrice" ).value( totalSalesPriceString ) );
84:     }
85: 
86: 
87:     @Override
88:     public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity )
89:             throws Exception {
90:         addProductToShoppingBasket( shoppingBasketId, productId, quantity, null );
91:     }
92: 
93: 
94:     @Override
95:     public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity,
96:                                                   ResultMatcher expectedStatus ) throws Exception {
97:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
98:         ObjectMapper objectMapper = new ObjectMapper();
99:         QuantityDTO dto = new QuantityDTO( productId, quantity );
100:         String quantityJson = objectMapper.writeValueAsString( dto );
101:         mockMvc.perform( post( "/shoppingBaskets/" + shoppingBasketId + "/positions" )
102:                         .contentType( APPLICATION_JSON ).content( quantityJson ) )
103:                 .andExpect( status );
104:     }
105: 
106: 
107: 
108:     @Override
109:     public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId )
110:             throws Exception {
111:         deleteProductFromShoppingBasket( shoppingBasketId, productId, null );
112:     }
113: 
114: 
115: 
116:     @Override
117:     public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId,
118:                                                       ResultMatcher expectedStatus ) throws Exception {
119:         ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
120:         String uri = "/shoppingBaskets/" + shoppingBasketId + "/positions/" + productId;
121:         mockMvc.perform( delete( uri ) ).andExpect( status );
122:     }
123: 
124: 
125:     @Override
126:     public void checkout( UUID shoppingBasketId, String expectedUserName,
127:                           ResultMatcher expectedStatus,
128:                           Map<UUID, Map<UUID, Integer>> expectedPurchases ) throws Exception {
129:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
130:         String uri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
131:         MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
132:         ObjectMapper objectMapper = new ObjectMapper();
133: 
134:         // check the response content
135:         if ( expectedPurchases != null || expectedUserName != null ) {
136:             String responseContent = result.getResponse().getContentAsString();
137:             log.info( "ShoppingBasketRESTHelperImpl - checkout: found response content " + responseContent );
138:             PurchaseDTO[] purchases = objectMapper.readValue( responseContent, PurchaseDTO[].class );
139:             checkExpectedUserName( expectedUserName, purchases );
140:             checkExpectedPurchases( expectedPurchases, purchases );
141:         }
142:     }
143: 
144: 
145:     private void checkExpectedUserName( String expectedUserName, PurchaseDTO[] purchases ) {
146:         if ( expectedUserName == null ) return;
147:         for ( PurchaseDTO purchase : purchases ) {
148:             if ( !purchase.getUserName().equals( expectedUserName ) ) {
149:                 throw new AssertionError( "Expected userName '" + expectedUserName +
150:                         "' but got '" + purchase.getUserName() + "'" );
151:             }
152:         }
153:     }
154: 
155: 
156:     private void checkExpectedPurchases( Map<UUID, Map<UUID, Integer>> expectedPurchases,
157:                                             PurchaseDTO[] purchases ) {
158:         if ( expectedPurchases == null ) return;
159:         for ( PurchaseDTO purchase : purchases ) {
160:             UUID depotId = purchase.getDepotId();
161:             Map<UUID, Integer> expectedQuantities = expectedPurchases.get( depotId );
162:             if ( expectedQuantities == null ) {
163:                 throw new AssertionError( "No expected quantities for depot " + depotId );
164:             }
165:             QuantityDTO[] positions = purchase.getPositions();
166:             for ( QuantityDTO quantityDTO : positions ) {
167:                 UUID productId = quantityDTO.getProductId();
168:                 Integer expectedQuantity = expectedQuantities.get( productId );
169:                 if ( expectedQuantity == null ) {
170:                     throw new AssertionError( "No expected quantity for product " + productId +
171:                             " in depot " + depotId );
172:                 }
173:                 if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
174:                     throw new AssertionError( "Expected quantity " + expectedQuantity + " for product " +
175:                             productId + " in depot " + depotId +
176:                             ", but got " + quantityDTO.getQuantity() );
177:                 }
178:             }
179:         }
180:     }
181: 
182: 
183:     /**
184:      * A DTO containing just a quantity, used in testing.
185:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
186:      * Therefore, constructors and getters/setters are manually defined.
187:      */
188:     @NoArgsConstructor
189:     @JsonIgnoreProperties(ignoreUnknown = true)
190:     private static class QuantityDTO {
191:         private UUID productId;
192:         private Integer quantity;
193: 
194:         public QuantityDTO( UUID productId, Integer quantity ) {
195:             this.productId = productId;
196:             this.quantity = quantity;
197:         }
198:         public UUID getProductId() {
199:             return productId;
200:         }
201:         public Integer getQuantity() {
202:             return quantity;
203:         }
204:         public void setProductId( UUID productId ) {
205:             this.productId = productId;
206:         }
207:         public void setQuantity( Integer quantity ) {
208:             this.quantity = quantity;
209:         }
210:     }
211: 
212: 
213:     /**
214:      * A DTO containing just the id of an entity, used in testing.
215:      */
216:     @AllArgsConstructor
217:     @NoArgsConstructor
218:     @Getter
219:     @Setter
220:     @JsonIgnoreProperties(ignoreUnknown = true)
221:     private static class IdDTO {
222:         private UUID id;
223:     }
224: 
225: 
226:     /**
227:      * A DTO containing the purchase data, used in testing.
228:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
229:      * Therefore, constructors and getters/setters are manually defined.
230:      */
231:     @NoArgsConstructor
232:     @JsonIgnoreProperties(ignoreUnknown = true)
233:     private static class PurchaseDTO {
234:         private UUID id;
235:         private String userName;
236:         private UUID depotId;
237:         private QuantityDTO[] positions;
238: 
239:         public UUID getId() {
240:             return id;
241:         }
242:         public String getUserName() {
243:             return userName;
244:         }
245:         public UUID getDepotId() {
246:             return depotId;
247:         }
248:         public QuantityDTO[] getPositions() {
249:             return positions;
250:         }
251:         public void setId( UUID id ) {
252:             this.id = id;
253:         }
254:         public void setUserName( String userName ) {
255:             this.userName = userName;
256:         }
257:         public void setDepotId( UUID depotId ) {
258:             this.depotId = depotId;
259:         }
260:         public void setPositions( QuantityDTO[] positions ) {
261:             this.positions = positions;
262:         }
263:     }
264: 
265: }
266: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingBasketRESTHelper.java ---
1: package thkoeln.archilab.ecommerce.helpers;
2: 
3: import org.springframework.test.web.servlet.ResultMatcher;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
5: 
6: import java.util.Map;
7: import java.util.UUID;
8: 
9: /**
10:  * A REST helper for shopping basket-related operations.
11:  * This interface defines methods to interact with a shopping basket via REST calls, such as querying, adding,
12:  * deleting, and checking out.
13:  */
14: public interface ShoppingBasketRESTHelper {
15:     /**
16:      * Executes a REST GET query on a shopping basket and returns its id, with the user's email address as a
17:      * starting point. The resulting shopping basket is checked against the given expected quantity map.
18:      * @param emailAddress The emailAddress of the user whose shopping basket is queried.
19:      * @param expectedQuantityMap A map of products and their quantities in the shopping basket. (If null, then don't check.)
20:      * @return The id of the user's shopping basket.
21:      * @throws Exception (whenever the REST call fails, or the shopping basket does not match the expected quantity map)
22:      */
23:     public UUID getQueryShoppingBasket( EmailAddressType emailAddress,
24:                                        Map<UUID, Integer> expectedQuantityMap ) throws Exception;
25: 
26: 
27:     /**
28:      * Adds a product to a shopping basket via a REST call.
29:      * @param shoppingBasketId Id of the shopping basket.
30:      * @param productId Id of the product.
31:      * @param quantity Quantity of the product.
32:      * @throws Exception (whenever the REST call fails)
33:      */
34:     public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity )
35:             throws Exception;
36: 
37: 
38:     /**
39:      * Adds a product to a shopping basket via a REST call.
40:      * @param shoppingBasketId Id of the shopping basket.
41:      * @param productId Id of the product.
42:      * @param quantity Quantity of the product.
43:      * @param expectedStatus expected status of the operation (null = CREATED)
44:      * @throws Exception (whenever the REST call fails or the status does not match)
45:      */
46:     public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity,
47:                                                   ResultMatcher expectedStatus ) throws Exception;
48: 
49: 
50:     /**
51:      * Deletes a product from a shopping basket via a REST call.
52:      * @param shoppingBasketId Id of the shopping basket.
53:      * @param productId Id of the product.
54:      * @throws Exception (whenever the REST call fails)
55:      */
56:     public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId )
57:             throws Exception;
58: 
59: 
60:     /**
61:      * Deletes a product from a shopping basket via a REST call.
62:      * @param shoppingBasketId Id of the shopping basket.
63:      * @param productId Id of the product.
64:      * @param expectedStatus expected status of the operation (null = OK)
65:      * @throws Exception (whenever the REST call fails or the status does not match)
66:      */
67:     public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId,
68:                                                       ResultMatcher expectedStatus ) throws Exception;
69: 
70: 
71:     /**
72:      * Checks out a shopping basket via REST call, and returns the id of the created purchase.
73:      * @param shoppingBasketId
74:      * @param expectedUserName expected name of the user who owns the shopping basket (null = don't check)
75:      * @param expectedStatus expected status of the operation (null = don't check)
76:      * @param expectedPurchases the expected purchases to be created as a result of the checkout. This is
77:      *                            a map of the following form:
78:      *                            <pre>
79:      *                               depotId -> Map<productId,Integer>
80:      *                            </pre>
81:      *                            where the inner map contains the products and their quantities
82:      * @return
83:      * @throws Exception
84:      */
85:     public void checkout( UUID shoppingBasketId, String expectedUserName,
86:                           ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedPurchases )
87:            throws Exception;
88: }
89: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class BasicNoOutsideSolutionRulesTest {
14: 
15:     @ArchTest
16:     static final ArchRule noClassesOnTopLevel =
17:             classes().should().resideInAPackage( "..solution.*.." )
18:                     .allowEmptyShould( true );
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.library.Architectures.layeredArchitecture;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln")
12: @SuppressWarnings("PMD")
13: public class BasicProperDependenciesTest {
14: 
15:     @ArchTest
16:     static final ArchRule properDependencies =
17:             layeredArchitecture()
18:                     .consideringAllDependencies()
19:                     //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
20:                     .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
21:                     .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )
22: 
23:                     //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
24:                     .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
25:                     .allowEmptyShould( true );
26: }
27: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
5: import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
6: import org.springframework.core.type.classreading.MetadataReader;
7: import org.springframework.core.type.classreading.MetadataReaderFactory;
8: 
9: import java.io.IOException;
10: import java.util.Arrays;
11: import java.util.HashSet;
12: import java.util.Set;
13: 
14: import static org.junit.jupiter.api.Assertions.assertTrue;
15: 
16: public class BasicRequiredClassesTest {
17:     private static final String[] REQUIRED_CLASSES = {
18:             "User",
19:             "UserRepository",
20:             "Product",
21:             "ProductRepository",
22:             "Purchase",
23:             "PurchaseRepository",
24:             "StockLevel",
25:             "ShoppingBasket",
26:             "ShoppingBasketRepository",
27:             "DepotRepository",
28:             "ShoppingBasketPosition",
29:             "PurchasePosition",
30:             "Depot",
31:     };
32: 
33:     @Test
34:     public void testRequiredClassesDeclared() throws IOException {
35:         String basePackage = "thkoeln.archilab.ecommerce";
36:         String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";
37: 
38:         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
39:         MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );
40: 
41:         Set<String> foundClasses = new HashSet<>();
42: 
43:         Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
44:             try {
45:                 MetadataReader reader = readerFactory.getMetadataReader( resource );
46:                 foundClasses.add( reader.getClassMetadata().getClassName() );
47:             } catch (IOException e) {
48:                 e.printStackTrace();
49:             }
50:         } );
51: 
52:         Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
53:             boolean found = foundClasses.stream().anyMatch(className ->
54:                     className.startsWith(basePackage) && className.endsWith("." + requiredClass)
55:             );
56:             assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
57:         });
58:     }
59: }
60: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.boot.test.context.SpringBootTest;
6: import org.springframework.context.ApplicationContext;
7: 
8: import java.util.Arrays;
9: import java.util.HashMap;
10: import java.util.List;
11: import java.util.Map;
12: 
13: import static org.junit.jupiter.api.Assertions.*;
14: 
15: @SpringBootTest
16: public class BasicUseCaseImplementationPackageTest {
17: 
18:     @Autowired
19:     private ApplicationContext applicationContext;
20: 
21:     private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
22:         put("UserRegistrationUseCases", Arrays.asList("user"));
23:         put("DepotUseCases", Arrays.asList("depot"));
24:         put("ProductCatalogUseCases", Arrays.asList("product"));
25:         put("ShoppingBasketUseCases", Arrays.asList("shoppingbasket"));
26:         put("PurchaseUseCases", Arrays.asList("purchase"));
27:     }};
28:     private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
29:     private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";
30: 
31:     @Test
32:     public void testRequiredClassesDeclared() {
33:         for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
34:             String interfaceName = USECASE_PATH + "." + entry.getKey();
35:             List<String> correctTopLevelPackages = entry.getValue();
36:             Class<?> useCaseInterfaceClass = null;
37:             try {
38:                 useCaseInterfaceClass = Class.forName( interfaceName );
39:             } catch (ClassNotFoundException e) {
40:                 fail( "Use case interface " + interfaceName + " not found.", e );
41:                 continue;
42:             }
43:             String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
44:             assertEquals( 1, beans.length,
45:                     "There should be exactly 1 service implementation for the interface " +
46:                             entry.getKey() + ", but found " + beans.length );
47:             Object bean = applicationContext.getBean( beans[0] );
48:             boolean isValid = false;
49:             for ( String correctTopLevelPackage : correctTopLevelPackages ) {
50:                 String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
51:                 if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
52:                     isValid = true;
53:                     break;
54:                 }
55:             }
56:             assertTrue( isValid,
57:                     "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
58:                             + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
59:         }
60:     }
61: }
62: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: import org.springframework.data.repository.CrudRepository;
8: import org.springframework.stereotype.Service;
9: 
10: import jakarta.persistence.Entity;
11: import org.springframework.web.bind.annotation.RestController;
12: 
13: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
14: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
15: 
16: @ArchTag("layerRules")
17: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
18: @SuppressWarnings("PMD")
19: public class DDDRulesTest {
20: 
21:     @ArchTest
22:     static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
23:             noClasses().that().resideInAPackage( "..domain.." )
24:                     .should().dependOnClassesThat().resideInAPackage( "..application.." )
25:                     .allowEmptyShould( true );
26: 
27:     @ArchTest
28:     static final ArchRule entitiesMustResideInADomainPackage =
29:             classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
30:                     .as( "Entities must reside in a package '..domain..'" )
31:                     .allowEmptyShould( true );
32: 
33:     @ArchTest
34:     static final ArchRule entitiesMustNotAccessRepositories =
35:             noClasses().that().areAnnotatedWith( Entity.class )
36:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
37:                     .allowEmptyShould( true );
38: 
39:     @ArchTest
40:     static final ArchRule repositoriesMustResideInADomainPackage =
41:             classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
42:                     .as( "Repositories must reside in a package '..domain..'" )
43:                     .allowEmptyShould( true );
44: 
45:     @ArchTest
46:     static final ArchRule repositoryNamesMustHaveProperSuffix =
47:             classes().that().areAssignableTo( CrudRepository.class )
48:                     .should().haveSimpleNameEndingWith( "Repository" )
49:                     .allowEmptyShould( true );
50: 
51:     @ArchTest
52:     static final ArchRule servicesMustResideInAnApplicationPackage =
53:             classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
54:                     .as( "Application Services must reside in a package '..application..'" )
55:                     .allowEmptyShould( true );
56: 
57:     @ArchTest
58:     static final ArchRule serviceNamesMustHaveProperSuffix =
59:             classes().that().areAnnotatedWith( Service.class )
60:                     .should().haveSimpleNameEndingWith( "Service" )
61:                     .allowEmptyShould( true );
62: 
63:     @ArchTest
64:     static final ArchRule controllersMustResideInAnApplicationPackage =
65:             classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
66:                     .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );
67: 
68:     @ArchTest
69:     static final ArchRule controllersNamesMustHaveProperSuffix =
70:             classes().that().areAnnotatedWith( RestController.class )
71:                     .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );
72: 
73:     @ArchTest
74:     static final ArchRule controllersMustNotAccessRepositories =
75:             noClasses().that().areAnnotatedWith( RestController.class )
76:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
77:                     .allowEmptyShould( false );
78: }
79: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.importer.ClassFileImporter;
6: import com.tngtech.archunit.lang.ArchRule;
7: import com.tngtech.archunit.library.dependencies.SliceAssignment;
8: import com.tngtech.archunit.library.dependencies.SliceIdentifier;
9: import org.junit.jupiter.api.Test;
10: 
11: import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
12: 
13: public class NoCycleTest {
14:     private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");
15: 
16:     private SliceAssignment inAllClasses() {
17:         return new SliceAssignment() {
18:             @Override
19:             public String getDescription() {
20:                 return "every class in it's own slice";
21:             }
22: 
23:             @Override
24:             public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
25:                 return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
26:             }
27:         };
28:     }
29: 
30:     @Test
31:     public void testNoCyclicDependenciesBetweenClasses() {
32:         slices().assignedFrom(inAllClasses())
33:                 .namingSlices("$1[$2.$3]")
34:                 .should().beFreeOfCycles()
35:                 .check(importedClasses);
36:     }
37: 
38:     @Test
39:     public void testNoCyclicDependenciesBetweenPackages() {
40:         ArchRule rule = slices().matching("..solution.(*)..")
41:                 .should().beFreeOfCycles().allowEmptyShould( true );
42:         rule.check(importedClasses);
43:     }
44: }
45: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.base.DescribedPredicate;
4: import com.tngtech.archunit.core.domain.JavaClass;
5: import com.tngtech.archunit.core.domain.JavaField;
6: import com.tngtech.archunit.core.domain.JavaParameterizedType;
7: import com.tngtech.archunit.core.domain.JavaType;
8: import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
9: import com.tngtech.archunit.junit.AnalyzeClasses;
10: import com.tngtech.archunit.junit.ArchTag;
11: import com.tngtech.archunit.junit.ArchTest;
12: import com.tngtech.archunit.lang.ArchCondition;
13: import com.tngtech.archunit.lang.ArchRule;
14: import com.tngtech.archunit.lang.ConditionEvents;
15: import com.tngtech.archunit.lang.SimpleConditionEvent;
16: import jakarta.persistence.*;
17: import lombok.extern.slf4j.Slf4j;
18: import thkoeln.archilab.ecommerce.GenericId;
19: 
20: import java.util.List;
21: 
22: import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
23: import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
24: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;
25: 
26: @ArchTag("layerRules")
27: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
28: @SuppressWarnings("PMD")
29: @Slf4j
30: public class OnlyReferenceViaIDTest { //DEPOT
31:     private static final String SHOPPING_BASKET_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingbasket.domain";
32:     private static final String USER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.user.domain";
33:     private static final String PRODUCT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.product.domain";
34:     private static final String PURCHASE_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.purchase.domain";
35:     private static final String DEPOT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.depot.domain";
36: 
37:     @ArchTest
38:     static final ArchRule idFieldsMustUseGenericId =
39:             fields()
40:                     .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
41:                     .and().areAnnotatedWith( Id.class )
42:                     .should().haveRawType( assignableTo( GenericId.class ) )
43:                     .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
44:                     .allowEmptyShould( true );
45: 
46: 
47:     private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
48:             annotatedWith( ManyToOne.class )
49:                     .or( annotatedWith( OneToOne.class ) )
50:                     .or( annotatedWith( Embedded.class ) )
51:                     .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );
52: 
53:     private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
54:             annotatedWith( OneToMany.class )
55:                     .or( annotatedWith( ManyToMany.class ) )
56:                     .or( annotatedWith( ElementCollection.class ) )
57:                     .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );
58: 
59: 
60:     private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
61:         String description = "an entity or value object from same aggregate, or a domain primitive";
62:         return new DescribedPredicate<>( description ) {
63:             @Override
64:             public boolean test( JavaClass type ) {
65:                 // check if the class is an entity or value object, and resides in the allowed package
66:                 if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
67:                     return false;
68:                 }
69:                 // a GenericId is always allowed
70:                 if ( type.isAssignableTo( GenericId.class ) ) {
71:                     return true;
72:                 }
73:                 // a domain primitive is also always allowed
74:                 if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
75:                     return true;
76:                 }
77:                 return type.getPackageName().startsWith( allowedPackage );
78:             }
79:         };
80:     }
81: 
82: 
83:     @ArchTest
84:     static final ArchRule shoppingBasketToOneReferences =
85:             fields()
86:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
87:                     .and( isToOneAnnotation )
88:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) ) )
89:                     .allowEmptyShould( true );
90: 
91:     @ArchTest
92:     static final ArchRule userToOneReferences =
93:             fields()
94:                     .that().areDeclaredInClassesThat().resideInAPackage( USER_DOMAIN_PACKAGE )
95:                     .and( isToOneAnnotation )
96:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( USER_DOMAIN_PACKAGE ) ) )
97:                     .allowEmptyShould( true );
98: 
99:     @ArchTest
100:     static final ArchRule productToOneReferences =
101:             fields()
102:                     .that().areDeclaredInClassesThat().resideInAPackage( PRODUCT_DOMAIN_PACKAGE )
103:                     .and( isToOneAnnotation )
104:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( PRODUCT_DOMAIN_PACKAGE ) ) )
105:                     .allowEmptyShould( true );
106: 
107:     @ArchTest
108:     static final ArchRule purchaseToOneReferences =
109:             fields()
110:                     .that().areDeclaredInClassesThat().resideInAPackage( PURCHASE_DOMAIN_PACKAGE )
111:                     .and( isToOneAnnotation )
112:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( PURCHASE_DOMAIN_PACKAGE ) ) )
113:                     .allowEmptyShould( true );
114: 
115:     @ArchTest
116:     static final ArchRule depotToOneReferences =
117:             fields()
118:                     .that().areDeclaredInClassesThat().resideInAPackage( DEPOT_DOMAIN_PACKAGE )
119:                     .and( isToOneAnnotation )
120:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( DEPOT_DOMAIN_PACKAGE ) ) )
121:                     .allowEmptyShould( true );
122: 
123: 
124:     private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
125:         return new ArchCondition<JavaField>(
126:                 "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
127:             @Override
128:             public void check( JavaField field, ConditionEvents events ) {
129:                 JavaClass rawType = field.getRawType();
130:                 String rawTypeName = rawType.getFullName();
131:                 if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
132:                     events.add( SimpleConditionEvent.violated( field,
133:                             field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
134:                     return;
135:                 }
136:                 JavaType fieldType = field.getType();
137:                 if ( !( fieldType instanceof JavaParameterizedType ) ) {
138:                     events.add( SimpleConditionEvent.violated( field,
139:                             field.getFullName() + " is a raw List/Set without a type argument" ) );
140:                     return;
141:                 }
142:                 List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
143:                 if ( typeArguments.isEmpty() ) {
144:                     events.add( SimpleConditionEvent.violated( field,
145:                             field.getFullName() + " has no type arguments" ) );
146:                     return;
147:                 }
148:                 JavaType elementType = typeArguments.get( 0 );
149:                 if ( !( elementType instanceof JavaClass ) ) {
150:                     events.add( SimpleConditionEvent.violated( field,
151:                             field.getFullName() + " has an unknown element type" ) );
152:                     return;
153:                 }
154:                 JavaClass elementClass = (JavaClass) elementType;
155:                 boolean hasAnnotation =
156:                         elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
157:                 boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
158:                 boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
159:                 boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
160:                 boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
161:                 if ( !ok ) {
162:                     events.add( SimpleConditionEvent.violated( field,
163:                             field.getFullName() + " refers to " + elementClass.getFullName()
164:                                     + " which is not a DP, or an entity/value object in " + allowedPackage ) );
165:                 }
166:             }
167:         };
168:     }
169: 
170: 
171:     @ArchTest
172:     static final ArchRule shoppingBasketToManyReferences =
173:             fields()
174:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
175:                     .and( isToManyAnnotation )
176:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) )
177:                     .allowEmptyShould( true );
178: 
179:     @ArchTest
180:     static final ArchRule userToManyReferences =
181:             fields()
182:                     .that().areDeclaredInClassesThat().resideInAPackage( USER_DOMAIN_PACKAGE )
183:                     .and( isToManyAnnotation )
184:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( USER_DOMAIN_PACKAGE ) )
185:                     .allowEmptyShould( true );
186: 
187:     @ArchTest
188:     static final ArchRule productToManyReferences =
189:             fields()
190:                     .that().areDeclaredInClassesThat().resideInAPackage( PRODUCT_DOMAIN_PACKAGE )
191:                     .and( isToManyAnnotation )
192:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( PRODUCT_DOMAIN_PACKAGE ) )
193:                     .allowEmptyShould( true );
194: 
195:     @ArchTest
196:     static final ArchRule purchaseToManyReferences =
197:             fields()
198:                     .that().areDeclaredInClassesThat().resideInAPackage( PURCHASE_DOMAIN_PACKAGE )
199:                     .and( isToManyAnnotation )
200:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( PURCHASE_DOMAIN_PACKAGE ) )
201:                     .allowEmptyShould( true );
202: 
203:     @ArchTest
204:     static final ArchRule depotToManyReferences =
205:             fields()
206:                     .that().areDeclaredInClassesThat().resideInAPackage( DEPOT_DOMAIN_PACKAGE )
207:                     .and( isToManyAnnotation )
208:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( DEPOT_DOMAIN_PACKAGE ) )
209:                     .allowEmptyShould( true );
210: 
211: }
212: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: /**
4:  * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
5:  */
6: 
7: public class OwnTestsTest {
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClasses;
4: import com.tngtech.archunit.core.importer.ClassFileImporter;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: 
8: import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
9: 
10: public class PackageStructureTest {
11: 
12:     private static final String[] REQUIRED_PACKAGES = {"user", "shoppingbasket", "product", "purchase", "depot"};
13:     private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
14:     private JavaClasses importedClasses;
15: 
16: 
17:     @BeforeEach
18:     public void setUp() {
19:         importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
20:     }
21: 
22:     @Test
23:     void testRequiredPackagesAreThere() {
24:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
25:             String packageName = BASE_PACKAGE + "." + requiredPackage;
26:             assertThat( importedClasses.containPackage( packageName ) )
27:                     .as( "Expected package %s not found!", packageName )
28:                     .isTrue();
29:         }
30:     }
31: 
32:     @Test
33:     void testRequiredDomainPackagesAreThere() {
34:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
35:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
36:             assertThat( importedClasses.containPackage( packageName ) )
37:                     .as( "Expected domain sub-package %s not found!", packageName )
38:                     .isTrue();
39:         }
40:     }
41: 
42:     @Test
43:     void testRequiredApplicationPackagesAreThere() {
44:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
45:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
46:             assertThat( importedClasses.containPackage( packageName ) )
47:                     .as( "Expected application sub-package %s not found!", packageName )
48:                     .isTrue();
49:         }
50:     }
51: 
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\depot\DepotManagementTest.java ---
1: package thkoeln.archilab.ecommerce.tests.depot;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.DepotTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
12: import thkoeln.archilab.ecommerce.usecases.DepotUseCases;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
14: 
15: import java.util.UUID;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePostalCode;
19: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
20: 
21: 
22: /**
23:  * This test checks the management and lifecycle of depots.
24:  */
25: @SpringBootTest
26: public class DepotManagementTest {
27:     @Autowired
28:     private DepotUseCases depotUseCases;
29:     @Autowired
30:     private ProductCatalogUseCases productCatalogUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private ProductTestHelper productTestHelper;
35:     @Autowired
36:     private DepotTestHelper depotTestHelper;
37: 
38:     private PhysicalAddressType somePhysicalAddress;
39:     private UUID nonExistingId1;
40:     private UUID nonExistingId2;
41: 
42: 
43:     @BeforeEach
44:     public void setUp() {
45:         purgatory.deleteEverything();
46:         productTestHelper.addAllProducts();
47: 
48:         somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
49:                 instantiatePostalCode( "90001" ) );
50:         nonExistingId1 = UUID.randomUUID();
51:         nonExistingId2 = UUID.randomUUID();
52:     }
53: 
54: 
55:     @Test
56:     public void testAddInvalidDepot() {
57:         // given
58:         String name = "Lager1";
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class,
63:                 () -> depotUseCases.addNewDepot(
64:                         null, somePhysicalAddress ) );
65:         assertThrows( ShopException.class,
66:                 () -> depotUseCases.addNewDepot(
67:                         "", somePhysicalAddress ) );
68:         assertThrows( ShopException.class,
69:                 () -> depotUseCases.addNewDepot(
70:                         name, null ) );
71:     }
72: 
73: 
74:     @Test
75:     public void testDeleteAllDepotsWhenEmpty() {
76:         // given
77:         depotTestHelper.addAllDepots( false );
78:         UUID productId9 = productTestHelper.getProductId( 9 );
79:         UUID depotId1 = depotTestHelper.getDepotId( 1 );
80:         UUID depotId2 = depotTestHelper.getDepotId( 2 );
81: 
82:         // when
83:         int numOf1 = depotUseCases.getAvailableStock( depotId1, productId9 );
84:         int numOf2 = depotUseCases.getAvailableStock( depotId2, productId9 );
85: 
86:         // then
87:         assertEquals( 0, numOf1 );
88:         assertEquals( 0, numOf2 );
89:         depotUseCases.deleteAllDepots();
90:         // ... ids must be invalid now
91:         assertThrows( ShopException.class,
92:                 () -> depotUseCases.getAvailableStock( depotId1, productId9 ) );
93:         assertThrows( ShopException.class,
94:                 () -> depotUseCases.getAvailableStock( depotId2, productId9 ) );
95:     }
96: 
97: 
98:     @Test
99:     public void testDeleteAllDepotsWhenFull() {
100:         // given
101:         depotTestHelper.addAllDepots( true );
102:         UUID productId7 = productTestHelper.getProductId( 7 );
103:         UUID depotId1 = depotTestHelper.getDepotId( 1 );
104:         UUID depotId2 = depotTestHelper.getDepotId( 2 );
105: 
106:         // when
107:         int numOf1 = depotUseCases.getAvailableStock( depotId1, productId7 );
108:         int numOf2 = depotUseCases.getAvailableStock( depotId2, productId7 );
109: 
110:         // then
111:         assertTrue( numOf1 == 3 );
112:         assertTrue( numOf2 == 3 );
113:         depotUseCases.deleteAllDepots();
114:         // ... ids must be invalid now
115:         assertThrows( ShopException.class,
116:                 () -> depotUseCases.getAvailableStock( depotId1, productId7 ) );
117:         assertThrows( ShopException.class,
118:                 () -> depotUseCases.getAvailableStock( depotId2, productId7 ) );
119:     }
120: 
121: 
122: 
123:     @Test
124:     public void testAddToStock() {
125:         // given
126:         depotTestHelper.addAllDepots( true );
127:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in depot 0
128:         UUID depotId0 = depotTestHelper.getDepotId( 0 );
129:         int originalStock5 =
130:                 depotTestHelper.getDepotStock( 0, 5 );
131: 
132:         // when
133:         int stock5before = depotUseCases.getAvailableStock( depotId0, productId5 );
134:         depotUseCases.addToStock( depotId0, productId5, 23 );
135:         int stock5after = depotUseCases.getAvailableStock( depotId0, productId5 );
136:         depotUseCases.addToStock( depotId0, productId5, 0 );
137:         int stock5after2 = depotUseCases.getAvailableStock( depotId0, productId5 );
138: 
139:         // then
140:         assertEquals( originalStock5, stock5before );
141:         assertEquals( stock5before + 23, stock5after );
142:         assertEquals( stock5after, stock5after2 );
143:     }
144: 
145: 
146:     @Test
147:     public void testInvalidAddToStock() {
148:         // given
149:         depotTestHelper.addAllDepots( true );
150:         UUID productId2 = productTestHelper.getProductId( 2 );
151:         UUID depotId0 = depotTestHelper.getDepotId( 0 );
152: 
153:         // when
154:         // then
155:         assertThrows( ShopException.class,
156:                 () -> depotUseCases.addToStock( nonExistingId1, nonExistingId2, 12 ) );
157:         assertThrows( ShopException.class,
158:                 () -> depotUseCases.addToStock(
159:                         depotId0, nonExistingId2, 12 ) );
160:         assertThrows( ShopException.class,
161:                 () -> depotUseCases.addToStock(
162:                         nonExistingId1, productId2, 12 ) );
163:         assertThrows( ShopException.class,
164:                 () -> depotUseCases.addToStock(
165:                         depotId0, productId2, -1 ) );
166:     }
167: 
168: 
169:     @Test
170:     public void testRemoveFromStock() {
171:         // given
172:         depotTestHelper.addAllDepots( true );
173:         UUID depotId0 = depotTestHelper.getDepotId( 0 );
174:         UUID productId0 = productTestHelper.getProductId( 0 ); // 0 in depot 0
175:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in depot 0
176:         UUID productId6 = productTestHelper.getProductId( 6 ); // random >30 in depot 0
177:         int stock0before =
178:                 depotTestHelper.getDepotStock( 0, 0 );
179:         int stock5before =
180:                 depotTestHelper.getDepotStock( 0, 5 );
181:         int stock6before =
182:                 depotTestHelper.getDepotStock( 0, 6 );
183: 
184:         // when
185:         depotUseCases.removeFromStock( depotId0, productId5, 1 );
186:         int stock5after = depotUseCases.getAvailableStock( depotId0, productId5 );
187:         depotUseCases.removeFromStock( depotId0, productId0, 0 );
188:         int stock0after = depotUseCases.getAvailableStock( depotId0, productId0 );
189:         depotUseCases.removeFromStock(
190:                 depotId0, productId6, stock6before );
191:         int stock6after = depotUseCases.getAvailableStock( depotId0, productId6 );
192: 
193:         // then
194:         assertEquals( stock5before - 1, stock5after );
195:         assertEquals( stock0before, stock0after );
196:         assertEquals( 0, stock6after );
197:     }
198: 
199: 
200:     @Test
201:     public void testInvalidRemoveFromStock() {
202:         // given
203:         depotTestHelper.addAllDepots( true );
204:         UUID depotId0 = depotTestHelper.getDepotId( 0 );
205:         UUID productId0 = productTestHelper.getProductId( 0 ); // 0 in depot 0
206:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in depot 0
207:         int stock5before =
208:                 depotTestHelper.getDepotStock( 0, 5 );
209: 
210:         // when
211:         // then
212:         assertThrows( ShopException.class,
213:                 () -> depotUseCases.removeFromStock( nonExistingId1, nonExistingId2, 12 ) );
214:         assertThrows( ShopException.class,
215:                 () -> depotUseCases.removeFromStock(
216:                         depotId0, nonExistingId2, 12 ) );
217:         assertThrows( ShopException.class,
218:                 () -> depotUseCases.removeFromStock(
219:                         nonExistingId1, productId5, 12 ) );
220:         assertThrows( ShopException.class,
221:                 () -> depotUseCases.removeFromStock(
222:                         depotId0, productId5, -1 ) );
223:         assertThrows( ShopException.class,
224:                 () -> depotUseCases.removeFromStock(
225:                         depotId0, productId5, stock5before + 1 ) );
226:         assertThrows( ShopException.class,
227:                 () -> depotUseCases.removeFromStock(
228:                         depotId0, productId0, 1 ) ); // already 0 in depot 0
229:     }
230: 
231: 
232:     @Test
233:     public void testChangeStock() {
234:         // given
235:         depotTestHelper.addAllDepots( true );
236:         UUID depotId0 = depotTestHelper.getDepotId( 0 );
237:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in depot 0
238: 
239:         // when
240:         depotUseCases.changeStockTo( depotId0, productId5, 111 );
241:         int stock5after = depotUseCases.getAvailableStock( depotId0, productId5 );
242: 
243:         // then
244:         assertEquals( 111, stock5after );
245:     }
246: 
247: 
248:     @Test
249:     public void testInvalidChangeStock() {
250:         // given
251:         depotTestHelper.addAllDepots( true );
252:         UUID depotId0 = depotTestHelper.getDepotId( 0 );
253:         UUID productId6 = productTestHelper.getProductId( 6 );
254: 
255:         // when
256:         // then
257:         assertThrows( ShopException.class, () -> depotUseCases.changeStockTo(
258:                 nonExistingId1, nonExistingId2, 12 ) );
259:         assertThrows( ShopException.class, () -> depotUseCases.changeStockTo(
260:                 nonExistingId1, productId6, 12 ) );
261:         assertThrows( ShopException.class, () -> depotUseCases.changeStockTo(
262:                 depotId0, nonExistingId2, 12 ) );
263:         assertThrows( ShopException.class, () -> depotUseCases.changeStockTo(
264:                 depotId0, productId6, -1 ) );
265:     }
266: 
267: 
268:     @Test
269:     public void testEmptyDepot() {
270:         // given
271:         depotTestHelper.addAllDepots( true );
272:         UUID depotId9 = depotTestHelper.getDepotId( 9 ); // empty depot
273: 
274:         // when
275:         int totalStock = 0;
276:         for ( int iProduct = 0; iProduct < productTestHelper.numberOfProducts(); iProduct++ ) {
277:             UUID productId = productTestHelper.getProductId( iProduct );
278:             totalStock += depotUseCases.getAvailableStock(
279:                     depotId9, productId );
280:         }
281: 
282:         // then
283:         assertEquals( 0, totalStock );
284:     }
285: 
286: 
287: 
288: }
289: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\CurrencyTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateCurrency;
9: 
10: class CurrencyTest {
11: 
12:     @Test
13:     public void testGetQuantityCurrency() {
14:         // given
15:         Float inputQuantity = 10.0f;
16: 
17:         // when
18:         CurrencyType instance = instantiateCurrency( inputQuantity, "EUR" );
19: 
20:         // then
21:         assertEquals( inputQuantity, instance.getQuantity() );
22:     }
23: 
24:     @Test
25:     public void testGetCurrencyUnitCurrency() {
26:         // given
27:         String inputCurrencyUnit = "EUR";
28: 
29:         // when
30:         CurrencyType instance = instantiateCurrency( 10.0f, inputCurrencyUnit );
31: 
32:         // then
33:         assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
34:     }
35: 
36:     @Test
37:     public void testAddToCurrency() {
38:         // given
39:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
40:         CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
41:         CurrencyType instance3 = instantiateCurrency( 0.0f, "EUR" );
42: 
43:         // when
44:         CurrencyType result12 = instance1.add( instance2 );
45:         CurrencyType result13 = instance1.add( instance3 );
46: 
47:         // then
48:         assertEquals( 30.0f, result12.getQuantity() );
49:         assertEquals( "EUR", result12.getCurrencyUnit() );
50:         assertEquals( 10.0f, result13.getQuantity() );
51:         assertEquals( "EUR", result12.getCurrencyUnit() );
52:     }
53: 
54:     @Test
55:     public void testInvalidAddToCurrency() {
56:         // given
57:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
58:         CurrencyType instance2 = instantiateCurrency( 20.0f, "CHF" );
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
63:     }
64: 
65:     @Test
66:     public void testSubtractFromCurrency() {
67:         // given
68:         CurrencyType instance1 = instantiateCurrency( 30.0f, "EUR" );
69:         CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
70:         CurrencyType instance3 = instantiateCurrency( 0.0f, "EUR" );
71:         CurrencyType instance4 = instantiateCurrency( 30.0f, "EUR" );
72: 
73:         // when
74:         CurrencyType result12 = instance1.subtract( instance2 );
75:         CurrencyType result13 = instance1.subtract( instance3 );
76:         CurrencyType result14 = instance1.subtract( instance4 );
77: 
78:         // then
79:         assertEquals( 10.0f, result12.getQuantity() );
80:         assertEquals( "EUR", result12.getCurrencyUnit() );
81:         assertEquals( 30.0f, result13.getQuantity() );
82:         assertEquals( "EUR", result13.getCurrencyUnit() );
83:         assertEquals( 0.0f, result14.getQuantity() );
84:         assertEquals( "EUR", result14.getCurrencyUnit() );
85:     }
86: 
87:     @Test
88:     public void testInvalidSubtractFromCurrency() {
89:         // given
90:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
91:         CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
92:         CurrencyType instance3 = instantiateCurrency( 5.0f, "CHF" );
93: 
94:         // when
95:         // then
96:         assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
97:         assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
98:     }
99: 
100:     @Test
101:     public void testMultiplyByCurrency() {
102:         // given
103:         CurrencyType instance = instantiateCurrency( 10.0f, "EUR" );
104: 
105:         // when
106:         CurrencyType result = instance.multiplyBy( 3 );
107: 
108:         // then
109:         assertEquals( 30.0f, result.getQuantity() );
110:         assertEquals( "EUR", result.getCurrencyUnit() );
111:     }
112: 
113:     @Test
114:     public void testFactoryValidCurrencyUnitCurrency() {
115:         // given
116:         // when
117:         // then
118:         assertDoesNotThrow( () -> instantiateCurrency( 10.0f, "EUR" ) );
119:     }
120: 
121:     @Test
122:     public void testFactoryInvalidCurrencyUnitCurrency() {
123:         // given
124:         // when
125:         // then
126:         assertThrows( ShopException.class, () -> instantiateCurrency( -10.0f, "EUR" ) );
127:         assertThrows( ShopException.class, () -> instantiateCurrency( 10.0f, "USD" ) );
128:         assertThrows( ShopException.class, () -> instantiateCurrency( null, "EUR" ) );
129:         assertThrows( ShopException.class, () -> instantiateCurrency( 10.0f, null ) );
130:     }
131: 
132:     @Test
133:     public void testLargerThanCurrencyUnitCurrency() {
134:         // given
135:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
136:         CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
137:         CurrencyType instance3 = instantiateCurrency( 10.0f, "EUR" );
138:         CurrencyType instance4 = instantiateCurrency( 10.0f, "CHF" );
139: 
140:         // when
141:         // then
142:         assertTrue( instance2.largerThan( instance1 ) );
143:         assertFalse( instance1.largerThan( instance2 ) );
144:         assertFalse( instance1.largerThan( instance3 ) );
145:         assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
146:     }
147: 
148: 
149:     @Test
150:     public void testEqualityCurrencyUnitCurrency() {
151:         // given
152:         // when
153:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
154:         CurrencyType instance2 = instantiateCurrency( 10.0f, "EUR" );
155:         CurrencyType instance3 = instantiateCurrency( 20.0f, "EUR" );
156: 
157:         // then
158:         assertEquals( instance1, instance2 );
159:         assertNotEquals( instance1, instance3 );
160:     }
161: 
162:     @Test
163:     public void testImmutabilityCurrencyUnitCurrency() {
164:         // given
165:         // when
166:         CurrencyType instance = instantiateCurrency( 10.0f, "EUR" );
167: 
168:         // then
169:         try {
170:             instance.getClass().getMethod( "setQuantity", Float.class );
171:             fail( "setQuantity method should not exist" );
172:         } catch (NoSuchMethodException e) {
173:             // Success: the object is immutable
174:         }
175: 
176:         try {
177:             instance.getClass().getMethod( "setCurrencyUnit", String.class );
178:             fail( "setCurrencyUnit method should not exist" );
179:         } catch (NoSuchMethodException e) {
180:             // Success: the object is immutable
181:         }
182:     }
183: }
184: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("domainPrimitivesUsageRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class DomainPrimitivesUsageRulesTest {
14:     private static final String EMAIL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.EmailAddress";
15:     private static final String CURRENCY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Currency";
16:     private static final String PHYSICAL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress";
17: 
18:     @ArchTest
19:     static final ArchRule userShouldReferenceEmailAddress =
20:             classes()
21:                     .that().haveSimpleName( "User" )
22:                     .should().dependOnClassesThat().haveFullyQualifiedName( EMAIL_ADDRESS_CLASS )
23:                     .because( "User should use EmailAddress instead of String" );
24: 
25:     @ArchTest
26:     static final ArchRule userShouldReferencePhysicalAddress =
27:             classes()
28:                     .that().haveSimpleName( "User" )
29:                     .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
30:                     .because( "User should use PhysicalAddress instead of whatever else" );
31: 
32:     @ArchTest
33:     static final ArchRule depotShouldReferencePhysicalAddress =
34:             classes()
35:                     .that().haveSimpleName( "Depot" )
36:                     .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
37:                     .because( "User should use PhysicalAddress instead of whatever else" );
38: 
39:     @ArchTest
40:     static final ArchRule productShouldReferenceCurrency =
41:             classes()
42:                     .that().haveSimpleName( "Product" )
43:                     .should().dependOnClassesThat().haveFullyQualifiedName( CURRENCY_CLASS )
44:                     .because( "Product should use Currency instead of float or whatever else" );
45: }
46: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\EmailAddressTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmailAddress;
10: 
11: class EmailAddressTest {
12: 
13:     @Test
14:     public void testToStringEmailAddress() {
15:         // given
16:         String input = "test@example.com";
17: 
18:         // when
19:         EmailAddressType instance = instantiateEmailAddress( input );
20: 
21:         // then
22:         assertEquals( input, instance.toString() );
23:     }
24: 
25:     @Test
26:     public void testEqualityEmailAddress() {
27:         // given
28:         // when
29:         EmailAddressType instance1 = instantiateEmailAddress( "test@example.com" );
30:         EmailAddressType instance2 = instantiateEmailAddress( "test@example.com" );
31:         EmailAddressType instance3 = instantiateEmailAddress( "different@example.com" );
32: 
33:         // then
34:         assertEquals( instance1, instance2 );
35:         assertNotEquals( instance1, instance3 );
36:     }
37: 
38:     @Test
39:     public void testImmutabilityEmailAddress() {
40:         // given
41:         // when
42:         EmailAddressType instance = instantiateEmailAddress( "test@example.com" );
43: 
44:         // then
45:         try {
46:             instance.getClass().getMethod( "setEmailAddress", String.class );
47:             fail( "setEmailAddress method should not exist" );
48:         } catch (NoSuchMethodException e) {
49:             // Success: the object is immutable
50:         }
51:     }
52: 
53: 
54: 
55:     @Test
56:     public void smokeTestForCopyConstructors() {
57:         // given
58:         EmailAddressType emailAddress =
59:                 instantiateEmailAddress( "peter.schmidt@web.de" );
60: 
61:         // when
62:         EmailAddressType emailAddressOtherIdentifyer =
63:                 emailAddress.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
64:         assertThrows( ShopException.class, () ->
65:                 emailAddress.sameDomainDifferentIdentifyer( "p...eter" ) );
66:         EmailAddressType emailAddressOtherDomain =
67:                 emailAddress.sameIdentifyerDifferentDomain( "web.ch" );
68:         assertThrows( ShopException.class, () ->
69:                 emailAddress.sameIdentifyerDifferentDomain( "web.edu" ) );
70: 
71:         // then
72:         assertEquals( "p.e.t.e.r@web.de", emailAddressOtherIdentifyer.toString() );
73:         assertEquals( "peter.schmidt@web.ch", emailAddressOtherDomain.toString() );
74:     }
75: 
76: 
77:     @Test
78:     public void testFactoryValidEmailAddress() {
79:         // given
80:         // when
81:         // then
82:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.com" ) );
83:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "99Z@example.com" ) );
84:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "GGGhh@s77.com" ) );
85:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "a@4.com" ) );
86:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "Max.Hammer@example.com" ) );
87:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "Max.Gideon.Hammer@example.com" ) );
88:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.this.com" ) );
89:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.de" ) );
90:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.at" ) );
91:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.ch" ) );
92:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.org" ) );
93:     }
94: 
95: 
96:     @Test
97:     public void testFactoryInvalidEmailAddress() {
98:         // given
99:         // when
100:         // then
101:         assertThrows( ShopException.class, () -> instantiateEmailAddress( null ) );
102:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "testexample.com" ) );
103:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@" ) );
104:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "@example.com" ) );
105:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "Max..Gideon.Hammer@example.com" ) );
106:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@examplecom" ) );
107:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example..com" ) );
108:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example@that.com" ) );
109:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test example@that.com" ) );
110:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test#example@that.com" ) );
111:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.biz" ) );
112:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.biz" ) );
113:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.42" ) );
114:     }
115: }
116: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\PhysicalAddressTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePostalCode;
11: 
12: class PhysicalAddressTest {
13: 
14:     @Test
15:     public void testGetterPhysicalAddress() {
16:         // given
17:         String street = "Irgendeinestraße 42";
18:         String city = "Irgendeinestadt";
19:         PostalCodeType plz = instantiatePostalCode( "12345" );
20: 
21:         // when
22:         PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );
23: 
24:         // then
25:         assertEquals( street, instance.getStreet() );
26:         assertEquals( city, instance.getCity() );
27:         assertEquals( plz, instance.getPostalCode() );
28:     }
29: 
30:     @Test
31:     public void testFactoryValidPhysicalAddress() {
32:         // given
33:         String street = "Irgendeinestraße 42";
34:         String city = "Irgendeinestadt";
35:         PostalCodeType plz = instantiatePostalCode( "12345" );
36: 
37:         // when
38:         // then
39:         assertDoesNotThrow( () -> instantiatePhysicalAddress( street, city, plz ) );
40:     }
41: 
42:     @Test
43:     public void testFactoryInvalidPhysicalAddress() {
44:         // given
45:         String street = "Irgendeinestraße 42";
46:         String city = "Irgendeinestadt";
47:         PostalCodeType plz = instantiatePostalCode( "12345" );
48: 
49:         // when
50:         // then
51:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( null, city, plz ) );
52:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( "", city, plz ) );
53:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, null, plz ) );
54:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, "", plz ) );
55:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, city, null ) );
56:     }
57: 
58:     @Test
59:     public void testEqualityPhysicalAddress() {
60:         // given
61:         String street = "Irgendeinestraße 42";
62:         String city = "Irgendeinestadt";
63:         PostalCodeType plz = instantiatePostalCode( "12345" );
64: 
65:         // when
66:         PhysicalAddressType instance1 = instantiatePhysicalAddress( street, city, plz );
67:         PhysicalAddressType instance2 = instantiatePhysicalAddress( street, city, plz );
68:         PhysicalAddressType instance3 = instantiatePhysicalAddress( "Anderestr. 12", city, plz );
69:         PhysicalAddressType instance4 = instantiatePhysicalAddress( street, "AndereStadt", plz );
70:         PhysicalAddressType instance5 = instantiatePhysicalAddress( street, city, instantiatePostalCode( "54321" ) );
71: 
72:         // then
73:         assertEquals( instance1, instance2 );
74:         assertNotEquals( instance1, instance3 );
75:         assertNotEquals( instance1, instance4 );
76:         assertNotEquals( instance1, instance5 );
77:     }
78: 
79:     @Test
80:     public void testImmutabilityPhysicalAddress() {
81:         // given
82:         String street = "Irgendeinestraße 42";
83:         String city = "Irgendeinestadt";
84:         PostalCodeType plz = instantiatePostalCode( "12345" );
85: 
86:         // when
87:         PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );
88: 
89:         // then
90:         try {
91:             instance.getClass().getMethod( "setStreet", String.class );
92:             fail( "setStreet method should not exist" );
93:         } catch (NoSuchMethodException e) {
94:             // Success: the object is immutable
95:         }
96:         try {
97:             instance.getClass().getMethod( "setCity", String.class );
98:             fail( "setCity method should not exist" );
99: 
100:         } catch (NoSuchMethodException e) {
101:             // Success: the object is immutable
102:         }
103:         try {
104:             instance.getClass().getMethod( "setPostalCode", PostalCodeType.class );
105:             fail( "setPostalCode method should not exist" );
106:         } catch (NoSuchMethodException e) {
107:             // Success: the object is immutable
108:         }
109:     }
110: }
111: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\PostalCodeTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
8: 
9: import static org.junit.jupiter.api.Assertions.*;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePostalCode;
11: 
12: class PostalCodeTest {
13: 
14:     private String input1, input4;
15:     private PostalCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
16:             _04233, _02544, _99123, _56323, _79332;
17: 
18: 
19:     @BeforeEach
20:     public void setUp() {
21:         input1 = "12345";
22:         input4 = "49188";
23:         _12345 = FactoryMethodInvoker.instantiatePostalCode( "12345" );
24:         _12345b = FactoryMethodInvoker.instantiatePostalCode( "12345" );
25:         _23455 = FactoryMethodInvoker.instantiatePostalCode( "23455" );
26:         _01234 = FactoryMethodInvoker.instantiatePostalCode( "01234" );
27:         _01235 = FactoryMethodInvoker.instantiatePostalCode( "01235" );
28:         _01238 = FactoryMethodInvoker.instantiatePostalCode( "01238" );
29:         _01263 = FactoryMethodInvoker.instantiatePostalCode( "01263" );
30:         _01213 = FactoryMethodInvoker.instantiatePostalCode( "01213" );
31:         _01823 = FactoryMethodInvoker.instantiatePostalCode( "01823" );
32:         _01312 = FactoryMethodInvoker.instantiatePostalCode( "01312" );
33:         _04233 = FactoryMethodInvoker.instantiatePostalCode( "04233" );
34:         _02544 = FactoryMethodInvoker.instantiatePostalCode( "02544" );
35:         _99123 = FactoryMethodInvoker.instantiatePostalCode( "99123" );
36:         _56323 = FactoryMethodInvoker.instantiatePostalCode( "56323" );
37:         _79332 = FactoryMethodInvoker.instantiatePostalCode( "79332" );
38: 
39:     }
40: 
41: 
42:     @Test
43:     public void testToStringPostalCode() {
44:         // given
45:         // when
46:         PostalCodeType instance = instantiatePostalCode( input1 );
47: 
48:         // then
49:         assertEquals( input1, instance.toString() );
50:     }
51: 
52:     @Test
53:     public void testFactoryValidPostalCode() {
54:         // given
55:         // when
56:         // then
57:         assertDoesNotThrow( () -> instantiatePostalCode( input1 ) );
58:     }
59: 
60:     @Test
61:     public void testFactoryInvalidPostalCode() {
62:         // given
63:         // when
64:         // then
65:         assertThrows( ShopException.class, () -> instantiatePostalCode( "123456" ) );
66:         assertThrows( ShopException.class, () -> instantiatePostalCode( "1234" ) );
67:         assertThrows( ShopException.class, () -> instantiatePostalCode( "20000" ) );
68:         assertThrows( ShopException.class, () -> instantiatePostalCode( null ) );
69:     }
70: 
71:     @Test
72:     public void testEqualityPostalCode() {
73:         // given
74:         // when
75:         PostalCodeType instance1a = instantiatePostalCode( input1 );
76:         PostalCodeType instance1b = instantiatePostalCode( input1 );
77:         PostalCodeType instance4 = instantiatePostalCode( input4 );
78: 
79:         // then
80:         assertEquals( instance1a, instance1b );
81:         assertNotEquals( instance1a, instance4 );
82:     }
83: 
84:     @Test
85:     public void testImmutabilityPostalCode() {
86:         // given
87:         // when
88:         PostalCodeType instance = instantiatePostalCode( input1 );
89: 
90:         // then
91:         try {
92:             instance.getClass().getMethod( "setpostalCode", String.class );
93:             fail( "setpostalCode method should not exist" );
94:         } catch (NoSuchMethodException e) {
95:             // Success: the object is immutable
96:         }
97:     }
98: 
99: 
100:     @Test
101:     public void smokeTestForDistance() {
102:         // given
103:         PostalCodeType instance1a = instantiatePostalCode( input1 );
104:         PostalCodeType instance1b = instantiatePostalCode( input1 );
105:         PostalCodeType instance12479 = instantiatePostalCode( "12479" );
106:         PostalCodeType instance21456 = instantiatePostalCode( "21456" );
107: 
108:         // when
109:         int distanceAB = instance1a.distance( instance1b );
110:         int distance12 = instance1a.distance( instance12479 );
111:         int distance23 = instance12479.distance( instance21456 );
112: 
113:         // then
114:         assertEquals( 0, distanceAB );
115:         assertTrue( distance12 > 0 );
116:         assertTrue( distance23 > distance12 );
117:     }
118: 
119: 
120:     @Test
121:     public void testPostalCodeFirstDigit() {
122:         // given
123:         PostalCodeType instance1 = instantiatePostalCode( input1 );
124:         PostalCodeType instance4 = instantiatePostalCode( input4 );
125: 
126:         // when
127:         // then
128:         assertEquals( 1, instance1.getFirstDigitPostalCode() );
129:         assertEquals( 4, instance4.getFirstDigitPostalCode() );
130:     }
131: 
132: 
133: 
134:     @Test
135:     public void testInvalidParameters() {
136:         // given
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 _12345.distance( null ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testSamePostalCode() {
146:         // given
147:         // when
148:         int diff = _12345.distance( _12345b );
149: 
150:         // then
151:         assertEquals( 0, diff );
152:     }
153: 
154: 
155:     /**
156:      *      - The distance is > 0 if both postal codes differ in the last digit, like 5673x
157:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
158:      *        So, 56733 and 56734 have the same distance as 56733 and 56739.
159:      *      - The distance grows if more digits (counted from the right side) differ.
160:      *        So, 5abcd and 5rstu have a larger distance than 53bcd and 53stu (if abcd
161:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
162:      *        53876 and 54876 have the same distance as 53876 and 57261.
163:      */
164:     @Test
165:     public void testPostalCodeDistanceInAllButFirstDigit() {
166:         // given
167:         // when
168:         int diff5a = _01234.distance( _01235 );
169:         int diff5b = _01234.distance( _01238 );
170:         int diff4a = _01234.distance( _01263 );
171:         int diff4b = _01234.distance( _01213 );
172:         int diff3a = _01234.distance( _01823 );
173:         int diff3b = _01234.distance( _01312 );
174:         int diff2a = _01234.distance( _04233 );
175:         int diff2b = _01234.distance( _02544 );
176: 
177:         // then
178:         assertEquals( diff5a, diff5b, "distance 01234-01235 must be the same as distance 01234-01238" );
179:         assertEquals( diff4a, diff4b, "distance 01234-01263 must be the same as distance 01234-01213" );
180:         assertEquals( diff3a, diff3b, "distance 01234-01823 must be the same as distance 01234-01312" );
181:         assertEquals( diff2a, diff2b, "distance 01234-04233 must be the same as distance 01234-02544" );
182: 
183:         assertTrue( diff5a < diff4a,
184:                 "distance 01234-01235 must be smaller than distance 01234-01263" );
185:         assertTrue( diff4a < diff3a,
186:                 "distance 01234-01263 must be smaller than distance 01234-01823" );
187:         assertTrue( diff3a < diff2a,
188:                 "distance 01234-01823 must be smaller than distance 01234-04233" );
189:     }
190: 
191: 
192:     /**
193:      *      - However, the distance between 5abcd and 6rstu must be smaller than the one
194:      *        between 5abcd and 7rstu, and this distance in turn must be smaller than the
195:      *        one between 5abcd and 9rstu.
196:      *      - This last condition reflects the fact the first digits of a postal code marks a region
197:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
198:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
199:      *        other.
200:      */
201:     @Test
202:     public void testPostalCodedistanceInFirstDigit() {
203:         // given
204:         // when
205:         int diff1_1 = _01234.distance( _99123 );
206:         int diff1_2 = _01234.distance( _23455 );
207:         int diff1_5 = _01234.distance( _56323 );
208:         int diff1_3 = _01234.distance( _79332 );
209: 
210:         // then
211:         assertTrue( diff1_1 < diff1_2,
212:                 "distance 01234-99123 must be smaller than distance 01234-23455"  );
213:         assertTrue( diff1_2 < diff1_3,
214:                 "distance 01234-23455 must be smaller than distance 01234-79332" );
215:         assertTrue( diff1_3 < diff1_5,
216:                 "distance 01234-79332 must be smaller than distance 01234-56323"  );
217:     }
218: 
219: 
220: 
221: }
222: 
223: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
1: package thkoeln.archilab.ecommerce.tests.e1restcalls;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;
5: 
6: 
7: public class E1RestCallTableTest {
8: 
9:     private GenericTableSpecificationTests genericTableSpecificationTests = null;
10: 
11: 
12:     public E1RestCallTableTest() {
13:         this.genericTableSpecificationTests = new GenericTableSpecificationTests();
14:     }
15: 
16:     @Test
17:     public void restTest() throws Exception {
18:         genericTableSpecificationTests.testTableSpecification("E1" );
19:     }
20: }
21: 
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import com.fasterxml.jackson.databind.ObjectMapper;
4: import com.jayway.jsonpath.JsonPath;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
8: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
9: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
10: import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;
11: 
12: import static org.junit.jupiter.api.Assertions.assertEquals;
13: 
14: 
15: public class DomainPrimitiveJSONSerializationTest {
16: 
17:     @BeforeEach
18:     public void setUp() {
19:         // ... add own setup code here
20:     }
21: 
22: 
23:     /**
24:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
25:      * EmailAddress.
26:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
27:      * on how to implement this test, and how to change property names.
28:      * @throws Exception
29:      */
30:     @Test
31:     public void test_EmailAddress_Serialization() throws Exception {
32:         // given
33:         EmailAddress emailAddress = EmailAddress.of("max.mustermann@email.com");
34:         ObjectMapper mapper = new ObjectMapper();
35: 
36:         // when
37:         String json = mapper.writeValueAsString(emailAddress);
38: 
39:         // then
40:         String emailAddressString = JsonPath.read( json, "$.emailAddressString" );
41:         assertEquals( "max.mustermann@email.com", emailAddressString);
42:     }
43: 
44: 
45:     /**
46:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
47:      * PostalCode.
48:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
49:      * on how to implement this test, and how to change property names.
50:      * @throws Exception
51:      */
52:     @Test
53:     public void test_PostalCode_Serialization() throws Exception {
54:         // given
55:         PostalCode postalCode = PostalCode.of("40789");
56:         ObjectMapper mapper = new ObjectMapper();
57: 
58:         // when
59:         String json = mapper.writeValueAsString(postalCode);
60: 
61:         // then
62:         String postalCodeString = JsonPath.read( json, "$.postalCodeString" );
63:         assertEquals( "40789", postalCodeString);
64:     }
65: 
66: 
67:     /**
68:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
69:      * PhysicalAddress.
70:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
71:      * on how to implement this test, and how to change property names.
72:      * @throws Exception
73:      */
74:     @Test
75:     public void test_PhysicalAddress_Serialization() throws Exception {
76:         // given
77:         PostalCode newPostalCode = PostalCode.of("40789");
78:         PhysicalAddress physicalAddress = PhysicalAddress.of(
79:             "Musterstraße",
80:                 "Monheim am Rhein",
81:                 newPostalCode
82:         );
83:         ObjectMapper mapper = new ObjectMapper();
84: 
85:         // when
86:         String json = mapper.writeValueAsString(physicalAddress);
87: 
88:         // then
89:         String postalCodeString = JsonPath.read( json, "$.postalCode.postalCodeString" );
90:         String city = JsonPath.read( json, "$.city" );
91:         String street = JsonPath.read( json, "$.street" );
92: 
93:         assertEquals( "40789", postalCodeString);
94:         assertEquals( "Monheim am Rhein", city);
95:         assertEquals( "Musterstraße", street);
96:     }
97: 
98: 
99:     /**
100:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
101:      * Currency.
102:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
103:      * on how to implement this test, and how to change property names.
104:      * @throws Exception
105:      */
106:     @Test
107:     public void test_Currency_Serialization() throws Exception {
108:         // given
109:         Currency currency1 = Currency.of(19.99f, "EUR");
110:         Currency currency2 = Currency.of(0f, "CHF");
111:         ObjectMapper mapper = new ObjectMapper();
112: 
113:         // when
114:         String json1 = mapper.writeValueAsString(currency1);
115:         String json2 = mapper.writeValueAsString(currency2);
116: 
117:         // then
118:         Double amount1 = JsonPath.read( json1, "$.amount" );
119:         String unit1 = JsonPath.read( json1, "$.unit" );
120:         Double amount2 = JsonPath.read( json2, "$.amount" );
121:         String unit2 = JsonPath.read( json2, "$.unit" );
122: 
123:         assertEquals( 19.99f, amount1, 0.001f, "amount mismatch with delta 0.001f" );
124:         assertEquals( "EUR", unit1);
125:         assertEquals( 0f, amount2, 0.001f, "amount mismatch with delta 0.001f" );
126:         assertEquals( "CHF", unit2);
127:     }
128: }
129: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingBasketRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
11: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
12: import thkoeln.archilab.ecommerce.solution.shoppingbasket.application.ShoppingAdapterService;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
15: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
16: import thkoeln.archilab.ecommerce.usecases.masterdata.DepotTestHelper;
17: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
18: 
19: import java.util.HashMap;
20: import java.util.Map;
21: import java.util.UUID;
22: 
23: import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
24: import static org.junit.jupiter.api.Assertions.assertNotNull;
25: 
26: 
27: @SpringBootTest
28: @Transactional
29: @AutoConfigureMockMvc
30: @Import( RESTTestHelperConfiguration.class )
31: public class OwnShoppingBasketRESTTest {
32:     @Autowired
33:     private Purgatory purgatory;
34:     @Autowired
35:     private UserTestHelper userTestHelper;
36:     @Autowired
37:     private ProductTestHelper productTestHelper;
38:     @Autowired
39:     private DepotTestHelper depotTestHelper;
40:     @Autowired
41:     private ShoppingAdapterService shoppingAdapterService;
42:     @Autowired
43:     private ShoppingBasketRESTHelper shoppingBasketRESTHelper;
44: 
45:     @BeforeEach
46:     public void setUp() {
47:         purgatory.deleteEverything();
48:         userTestHelper.registerAllUsers();
49:         productTestHelper.addAllProducts();
50:         depotTestHelper.addAllDepots( true );
51: 
52:         // ... add own setup code here
53:     }
54: 
55: 
56:     /**
57:      * Provide a test that implements a simple call to the REST endpoint (3):
58:      * <pre>
59:      *     GET /shoppingBaskets?userId=<user id as uuid>
60:      * </pre>
61:      * - Use the {@link UserTestHelper} to obtain the email address
62:      *   of some example user.
63:      * - Use your shopping basket service to add entries to the shopping basket of that person.
64:      * - then use the `ShoppingBasketRESTHelper` to create the GET call, and check the results.
65:      * - (or do it by directly calling your REST controller, if you prefer)
66:      * @throws Exception
67:      */
68:     @Test
69:     public void test_getQuery_ShoppingBasket() throws Exception {
70:         // given
71:         EmailAddressType emailAddress9 = userTestHelper.getUserEmailAddress(9);
72: 
73:         // Direkte Nutzung – das ist wichtig für ArchUnit!
74:         String emailAsString = emailAddress9.toString();
75:         assertNotNull(emailAsString);
76: 
77:         UUID productId1 = productTestHelper.getProductId(1);
78:         int quantity1 = 1;
79:         UUID productId2 = productTestHelper.getProductId(2);
80:         int quantity2 = 1;
81:         UUID productId3 = productTestHelper.getProductId(3);
82:         int quantity3 = 1;
83: 
84:         Map<UUID, Integer> expectedQuantityMap = new HashMap<>();
85:         shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId1, quantity1);
86:         expectedQuantityMap.put(productId1, quantity1);
87:         shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId2, quantity2);
88:         expectedQuantityMap.put(productId2, quantity2);
89:         shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId3, quantity3);
90:         expectedQuantityMap.put(productId3, quantity3);
91: 
92:         // when
93:         // then
94:         assertDoesNotThrow(
95:                 () -> shoppingBasketRESTHelper.getQueryShoppingBasket(
96:                         emailAddress9,
97:                         expectedQuantityMap
98:                 )
99:         );
100:     }
101: 
102:     /**
103:      * Provide a test that implements the addition of one product to the shopping basket via
104:      * REST endpoint (6):
105:      * <pre>
106:      *     POST /shoppingBaskets/{shoppingBasket-Id}/positions
107:      * </pre>
108:      * You can test now "the other way around" as in test_getQuery_ShoppingBasket():
109:      * - Use `ShoppingBasketRESTHelper` to add products via REST, then use shopping basket service methods
110:      *   to check of the shopping basket contains the right stuff.
111:      * - (or do it by directly calling your REST controller, if you prefer)
112:      *
113:      * @throws Exception
114:      */
115:     @Test
116:     public void test_post_ShoppingBasketPositions() throws Exception {
117:         // given
118:         EmailAddressType emailAddress9 = userTestHelper.getUserEmailAddress(9);
119: 
120:         UUID productId1 = productTestHelper.getProductId(1);
121:         int quantity1 = 1;
122:         UUID productId2 = productTestHelper.getProductId(2);
123:         int quantity2 = 1;
124:         UUID productId3 = productTestHelper.getProductId(3);
125:         int quantity3 = 1;
126: 
127:         Map<UUID, Integer> expectedQuantityMap = new HashMap<>();
128: 
129:         shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId1, quantity1);
130:         expectedQuantityMap.put(productId1, quantity1);
131: 
132:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket(emailAddress9, null);
133: 
134:         shoppingBasketRESTHelper.addProductToShoppingBasket(shoppingBasketId, productId2, quantity2);
135:         expectedQuantityMap.put(productId2, quantity2);
136:         shoppingBasketRESTHelper.addProductToShoppingBasket(shoppingBasketId, productId3, quantity3);
137:         expectedQuantityMap.put(productId3, quantity3);
138: 
139:         // when
140:         // then
141:         assertDoesNotThrow(
142:                 () -> shoppingBasketRESTHelper.getQueryShoppingBasket(
143:                         emailAddress9,
144:                         expectedQuantityMap
145:                 )
146:         );
147:     }
148: 
149: 
150: 
151:     /**
152:      * Provide a test that implements the deletion of one product in the shopping basket via
153:      * REST endpoint (10):
154:      * <pre>
155:      *     DELETE /shoppingBaskets/{shoppingBasket-Id}/positions/{product-Id}
156:      * </pre>
157:      * This should be just a slight variation of the test_post_ShoppingBasketPositions()
158:      * method, but instead of adding an product to the shopping basket, you delete it.
159:      *
160:      * @throws Exception
161:      */
162:     @Test
163:     public void test_delete_ShoppingBasketPositions() throws Exception {
164:         // given
165:         EmailAddressType emailAddress9 = userTestHelper.getUserEmailAddress(9);
166: 
167:         UUID productId1 = productTestHelper.getProductId(1);
168:         int quantity1 = 1;
169:         UUID productId2 = productTestHelper.getProductId(2);
170:         int quantity2 = 2;
171:         UUID productId3 = productTestHelper.getProductId(3);
172:         int quantity3 = 5;
173: 
174:         Map<UUID, Integer> expectedQuantityMap = new HashMap<>();
175:         shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId1, quantity1);
176:         expectedQuantityMap.put(productId1, quantity1);
177:         shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId2, quantity2);
178:         expectedQuantityMap.put(productId2, quantity2);
179:         shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId3, quantity3);
180:         expectedQuantityMap.put(productId3, quantity3);
181: 
182:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket(emailAddress9, null);
183: 
184:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket(shoppingBasketId, productId3);
185:         expectedQuantityMap.remove(productId3);
186:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket(shoppingBasketId, productId1);
187:         expectedQuantityMap.remove(productId1);
188: 
189:         // when
190:         // then
191:         assertDoesNotThrow(
192:                 () -> shoppingBasketRESTHelper.getQueryShoppingBasket(
193:                         emailAddress9,
194:                         expectedQuantityMap
195:                 )
196:         );
197:     }
198: 
199: 
200: 
201:     /**
202:      * Provide a test that implements the checkout of a shopping basket that can be served
203:      * by just 1 depot, using the REST endpoint (11):
204:      * <pre>
205:      *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
206:      * </pre>
207:      * - Use your shopping basket service to add entries to the shopping basket of some example user,
208:      * - then use the `ShoppingBasketRESTHelper to post the checkout call, and to check the results.
209:      * - (or do it by directly calling your REST controller, if you prefer)
210:      *
211:      * @throws Exception
212:      */
213:     @Test
214:     public void test_checkout_1_depot() throws Exception {
215:         // given
216:         int userIndex = 9;
217:         EmailAddressType emailAddress9 = userTestHelper.getUserEmailAddress(userIndex);
218:         String userName9 = userTestHelper.getUserName(userIndex);
219: 
220:         UUID productId1 = productTestHelper.getProductId(1);
221:         int quantity1 = 10;
222:         int depotIndex = 0;
223:         UUID depotId = depotTestHelper.getDepotId(depotIndex);
224: 
225:         Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>();
226: 
227:         shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId1, quantity1);
228:         Map<UUID, Integer> products = new HashMap<>();
229:         products.put(productId1, quantity1);
230:         expectedPurchases.put(depotId, products);
231: 
232:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket(emailAddress9, null);
233: 
234:         // when
235:         // then
236:         assertDoesNotThrow(
237:                 () -> shoppingBasketRESTHelper.checkout(
238:                         shoppingBasketId,
239:                         userName9,
240:                         null,
241:                         expectedPurchases
242:                 )
243:         );
244:     }
245: 
246: 
247: 
248:     /**
249:      * Provide a test that implements the checkout of a shopping basket that can only be served
250:      * by using 2 depots, using the REST endpoint (11):
251:      * <pre>
252:      *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
253:      * </pre>
254:      * This should be just a slight variation of thetest_checkout_1_depot() test.
255:      *
256:      * @throws Exception
257:      */
258:     @Test
259:     public void test_checkout_2_depots() throws Exception {
260:         // given
261:         int userIndex = 9;
262:         EmailAddressType emailAddress9 = userTestHelper.getUserEmailAddress(userIndex);
263:         String userName9 = userTestHelper.getUserName(userIndex);
264: 
265:         UUID productId1 = productTestHelper.getProductId(1);
266:         int quantity1 = 10;
267:         int depotIndex1 = 0;
268:         UUID depotId1 = depotTestHelper.getDepotId(depotIndex1);
269: 
270:         UUID productId12 = productTestHelper.getProductId(12);
271:         int quantity12 = 10;
272:         int depotIndex12 = 0;
273:         UUID depotId12 = depotTestHelper.getDepotId(depotIndex12);
274: 
275:         Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>();
276: 
277:         shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId1, quantity1);
278:         Map<UUID, Integer> products1 = new HashMap<>();
279:         products1.put(productId1, quantity1);
280:         expectedPurchases.put(depotId1, products1);
281: 
282:         shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId12, quantity12);
283:         Map<UUID, Integer> products12 = new HashMap<>();
284:         products12.put(productId12, quantity12);
285:         expectedPurchases.put(depotId12, products12);
286: 
287:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket(emailAddress9, null);
288: 
289:         // when
290:         // then
291:         assertDoesNotThrow(
292:                 () -> shoppingBasketRESTHelper.checkout(
293:                         shoppingBasketId,
294:                         userName9,
295:                         null,
296:                         expectedPurchases
297:                 )
298:         );
299:     }
300: 
301: }
302: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\product\ProductCatalogTest.java ---
1: package thkoeln.archilab.ecommerce.tests.product;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
9: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.DepotUseCases;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
15: 
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.*;
19: 
20: 
21: @SpringBootTest
22: public class ProductCatalogTest {
23:     @Autowired
24:     private UserRegistrationUseCases userRegistrationUseCases;
25:     @Autowired
26:     private ShoppingBasketUseCases shoppingBasketUseCases;
27:     @Autowired
28:     private ProductCatalogUseCases productCatalogUseCases;
29:     @Autowired
30:     private DepotUseCases depotUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private UserTestHelper userTestHelper;
35:     @Autowired
36:     private ProductTestHelper productTestHelper;
37:     @Autowired
38:     private DepotTestHelper depotTestHelper;
39: 
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         userTestHelper.registerAllUsers();
45:         productTestHelper.addAllProducts();
46:     }
47: 
48: 
49:     @Test
50:     public void testAddProductToCatalog() {
51:         // given
52:         UUID productId4 = productTestHelper.getProductId( 4 );
53:         CurrencyType salesPrice4 = productTestHelper.getSalesPrice( 4 );
54: 
55:         // when
56:         CurrencyType foundSalesPrice = productCatalogUseCases.getSalesPrice( productId4 );
57: 
58:         // then
59:         assertEquals( salesPrice4, foundSalesPrice );
60:     }
61: 
62: 
63:     @Test
64:     public void testAddProductWithInvalidData() {
65:         // given
66:         String name = "SomeStuff";
67:         String description = "Some more explanation on the stuff";
68:         Float size = 5.0f;
69:         CurrencyType buyingPrice =
70:                 FactoryMethodInvoker.instantiateCurrency( 5.0f, "EUR" );
71:         CurrencyType salesPrice =
72:                 FactoryMethodInvoker.instantiateCurrency( 10.0f, "EUR" );
73:         CurrencyType tooLowSalesPrice =
74:                 FactoryMethodInvoker.instantiateCurrency( 4.0f, "EUR" );
75: 
76:         // when / then
77:         assertThrows( ShopException.class, () ->
78:                 productCatalogUseCases.addProductToCatalog(
79:                         null, description, size, buyingPrice, salesPrice ) );
80:         assertThrows( ShopException.class, () ->
81:                 productCatalogUseCases.addProductToCatalog(
82:                         "", description, size, buyingPrice, salesPrice ) );
83:         assertThrows( ShopException.class, () ->
84:                 productCatalogUseCases.addProductToCatalog(
85:                         name, null, size, buyingPrice, salesPrice ) );
86:         assertThrows( ShopException.class, () ->
87:                 productCatalogUseCases.addProductToCatalog(
88:                         name, "", size, buyingPrice, salesPrice ) );
89:         assertThrows( ShopException.class, () ->
90:                 productCatalogUseCases.addProductToCatalog(
91:                         name, description, size, null, salesPrice ) );
92:         assertThrows( ShopException.class, () ->
93:                 productCatalogUseCases.addProductToCatalog(
94:                         name, description, size, buyingPrice, null ) );
95:         assertThrows( ShopException.class, () ->
96:                 productCatalogUseCases.addProductToCatalog(
97:                         name, description, size, buyingPrice, tooLowSalesPrice ) );
98:     }
99: 
100: 
101:     @Test
102:     public void testRemoveNonExistentProduct() {
103:         // given product 2 is not in stock anywhere - should be removable
104:         UUID nonExistentProductId = UUID.randomUUID();
105: 
106:         // when
107:         // then
108:         assertThrows( ShopException.class,
109:                 () -> productCatalogUseCases.removeProductFromCatalog( nonExistentProductId ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testRemoveProductWithNoStock() {
115:         // given product 0 is not in stock anywhere - should be removable
116:         UUID productId0 = productTestHelper.getProductId( 0 );
117:         depotTestHelper.addAllDepots( true );
118: 
119:         // when
120:         assertDoesNotThrow( () -> productCatalogUseCases.getSalesPrice( productId0 ) );
121:         productCatalogUseCases.removeProductFromCatalog( productId0 );
122: 
123:         // then
124:         assertThrows( ShopException.class, () ->
125:                 productCatalogUseCases.getSalesPrice( productId0 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testRemoveProductThatIsInStock() {
131:         // given
132:         depotTestHelper.addAllDepots( false );
133:         UUID depotId0 = depotTestHelper.getDepotId( 0 );
134:         UUID productId3 = productTestHelper.getProductId( 3 );
135:         UUID productId4 = productTestHelper.getProductId( 4 );
136:         depotUseCases.addToStock( depotId0, productId3, 3 );
137: 
138:         // then product 3 must not be removable, but product 4 must be removable
139:         assertThrows( ShopException.class,
140:                 () -> productCatalogUseCases.removeProductFromCatalog( productId3 ) );
141:         assertDoesNotThrow( () -> productCatalogUseCases.removeProductFromCatalog( productId4 ) );
142:     }
143: 
144: 
145:     @Test
146:     public void testRemoveProductThatIsInPurchase() {
147:         // given
148:         depotTestHelper.addAllDepots( false );
149:         UUID depotId0 = depotTestHelper.getDepotId( 0 );
150:         UUID productId4 = productTestHelper.getProductId( 4 );
151:         EmailAddressType userEmailAddress4 =
152:                 userTestHelper.getUserEmailAddress( 4 );
153:         depotUseCases.addToStock( depotId0, productId4, 4 );
154: 
155:         // when user 4 adds 4x product 4 to his shopping basket and checks out ...
156:         shoppingBasketUseCases.addProductToShoppingBasket(
157:                 userEmailAddress4, productId4, 4 );
158:         shoppingBasketUseCases.checkout( userEmailAddress4 );
159: 
160:         // then product 4 must not be removable
161:         assertThrows( ShopException.class,
162:                 () -> productCatalogUseCases.removeProductFromCatalog( productId4 ) );
163:     }
164: 
165: 
166:     @Test
167:     public void testClearProductCatalog() {
168:         // given
169:         UUID productId4 = productTestHelper.getProductId( 4 );
170: 
171:         // when
172:         productCatalogUseCases.deleteProductCatalog();
173: 
174:         // then
175:         assertThrows( ShopException.class, () -> productCatalogUseCases.getSalesPrice( productId4 ) );
176:     }
177: 
178: }
179: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\purchase\PurchaseTest.java ---
1: package thkoeln.archilab.ecommerce.tests.purchase;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.DepotTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: 
15: import java.util.Map;
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.assertEquals;
19: import static org.junit.jupiter.api.Assertions.assertThrows;
20: 
21: 
22: @SpringBootTest
23: public class PurchaseTest {
24:     @Autowired
25:     private UserRegistrationUseCases userRegistrationUseCases;
26:     @Autowired
27:     private ShoppingBasketUseCases shoppingBasketUseCases;
28:     @Autowired
29:     private ProductCatalogUseCases productCatalogUseCases;
30:     @Autowired
31:     private DepotUseCases depotUseCases;
32:     @Autowired
33:     private PurchaseUseCases purchaseUseCases;
34:     @Autowired
35:     private Purgatory purgatory;
36:     @Autowired
37:     private UserTestHelper userTestHelper;
38:     @Autowired
39:     private ProductTestHelper productTestHelper;
40:     @Autowired
41:     private DepotTestHelper depotTestHelper;
42: 
43:     private UUID nonExistingId1;
44:     private UUID nonExistingId2;
45: 
46:     @BeforeEach
47:     public void setUp() {
48:         purgatory.deleteEverything();
49:         userTestHelper.registerAllUsers();
50:         productTestHelper.addAllProducts();
51:         depotTestHelper.addAllDepots( true );
52:         nonExistingId1 = UUID.randomUUID();
53:         nonExistingId2 = UUID.randomUUID();
54:     }
55: 
56: 
57:     @Test
58:     public void testPurchaseHistory() {
59:         // given
60:         UUID productId1 = productTestHelper.getProductId( 1 );
61:         UUID productId2 = productTestHelper.getProductId( 2 );
62:         EmailAddressType userEmailAddress7 =
63:                 userTestHelper.getUserEmailAddress( 7 );
64:         Map<UUID, Integer> purchaseHistoryBefore = purchaseUseCases.getPurchaseHistory( userEmailAddress7 );
65: 
66:         // when
67:         shoppingBasketUseCases.addProductToShoppingBasket(
68:                 userEmailAddress7, productId1, 3 );
69:         shoppingBasketUseCases.addProductToShoppingBasket(
70:                 userEmailAddress7, productId2, 2 );
71:         shoppingBasketUseCases.checkout( userEmailAddress7 );
72:         Map<UUID, Integer> purchaseHistory1 =
73:                 purchaseUseCases.getPurchaseHistory( userEmailAddress7 );
74:         shoppingBasketUseCases.addProductToShoppingBasket(
75:                 userEmailAddress7, productId1, 6 );
76:         shoppingBasketUseCases.addProductToShoppingBasket(
77:                 userEmailAddress7, productId2, 2 );
78:         shoppingBasketUseCases.checkout( userEmailAddress7 );
79:         Map<UUID, Integer> purchaseHistory2 =
80:                 purchaseUseCases.getPurchaseHistory( userEmailAddress7 );
81:         shoppingBasketUseCases.addProductToShoppingBasket(
82:                 userEmailAddress7, productId1, 1 );
83:         shoppingBasketUseCases.addProductToShoppingBasket(
84:                 userEmailAddress7, productId2, 6 );
85:         shoppingBasketUseCases.checkout( userEmailAddress7 );
86:         Map<UUID, Integer> purchaseHistory3 =
87:                 purchaseUseCases.getPurchaseHistory( userEmailAddress7 );
88: 
89:         // then
90:         assertEquals( 0, purchaseHistoryBefore.size() );
91:         assertEquals( 2, purchaseHistory1.size() );
92:         assertEquals( 2, purchaseHistory2.size() );
93:         assertEquals( 2, purchaseHistory3.size() );
94:         assertEquals( 3, purchaseHistory1.get( productId1 ) );
95:         assertEquals( 2, purchaseHistory1.get( productId2 ) );
96:         assertEquals( 9, purchaseHistory2.get( productId1 ) );
97:         assertEquals( 4, purchaseHistory2.get( productId2 ) );
98:         assertEquals( 10, purchaseHistory3.get( productId1 ) );
99:         assertEquals( 10, purchaseHistory3.get( productId2 ) );
100:     }
101: 
102: 
103:     @Test
104:     public void testForEmptyPurchaseHistory() {
105:         // given
106:         EmailAddressType userEmailAddress4 =
107:                 userTestHelper.getUserEmailAddress( 4 );
108:         // when
109:         Map<UUID, Integer> purchaseHistory =
110:                 purchaseUseCases.getPurchaseHistory( userEmailAddress4 );
111:         // then
112:         assertEquals( 0, purchaseHistory.size() );
113:     }
114: 
115: 
116:     @Test
117:     public void testInvalidParamsForGetPurchaseQuantOfProduct() {
118:         // given
119:         UUID depotId0 = depotTestHelper.getDepotId( 0 );
120: 
121:         // when / then
122:         assertThrows ( ShopException.class,
123:                 () -> purchaseUseCases.getPurchaseQuantOfProduct( null, null ) );
124:         assertThrows ( ShopException.class,
125:                 () -> purchaseUseCases.getPurchaseQuantOfProduct( nonExistingId1, null ) );
126:         assertThrows ( ShopException.class,
127:                 () -> purchaseUseCases.getPurchaseQuantOfProduct( null, nonExistingId2 ) );
128:         assertThrows ( ShopException.class,
129:                 () -> purchaseUseCases.getPurchaseQuantOfProduct( nonExistingId1, nonExistingId2 ) );
130:         assertThrows ( ShopException.class,
131:                 () -> purchaseUseCases.getPurchaseQuantOfProduct( depotId0, null ) );
132:         assertThrows ( ShopException.class,
133:                 () -> purchaseUseCases.getPurchaseQuantOfProduct( depotId0, nonExistingId2 ) );
134:     }
135: 
136: 
137:     @Test
138:     public void testInvalidParamsForGetDepotIdForPurchase() {
139:         // given / when / then
140:         assertThrows ( ShopException.class,
141:                 () -> purchaseUseCases.getDepotIdForPurchase( null ) );
142:         assertThrows ( ShopException.class,
143:                 () -> purchaseUseCases.getDepotIdForPurchase( nonExistingId1 ) );
144:     }
145: }
146: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\CheckoutAcceptanceTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingbasket;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.DepotTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: 
15: import java.util.*;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: 
19: /**
20:  * This test checks the management of stock across depots. It focuses on the
21:  * cases where more than one depot are needed to serve the shopping basket of a user.
22:  */
23: @Slf4j
24: @SpringBootTest
25: public class CheckoutAcceptanceTest {
26:     @Autowired
27:     private UserRegistrationUseCases userRegistrationUseCases;
28:     @Autowired
29:     private ShoppingBasketUseCases shoppingBasketUseCases;
30:     @Autowired
31:     private ProductCatalogUseCases productCatalogUseCases;
32:     @Autowired
33:     private PurchaseUseCases purchaseUseCases;
34:     @Autowired
35:     private DepotUseCases depotUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private UserTestHelper userTestHelper;
40:     @Autowired
41:     private ProductTestHelper productTestHelper;
42:     @Autowired
43:     private DepotTestHelper depotTestHelper;
44: 
45:     private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
46:                                 map8_11_14_quantity_3_3_4,
47:                                 map10_12_quantity_1_1, 
48:                                 map11_quantity_1, 
49:                                 map12_quantity_10,
50:                                 map8_9_10_11_quantity_2_1_4_2;
51:     private EmailAddressType userEmailAddress3, userEmailAddress6,
52:             userEmailAddress2;
53:     private UUID productId8, productId9, productId10, productId11, productId12,
54:             productId14;
55: 
56: 
57:     @BeforeEach
58:     public void setUp() {
59:         purgatory.deleteEverything();
60:         userTestHelper.registerAllUsers();
61:         productTestHelper.addAllProducts();
62:         depotTestHelper.addAllDepots( true );
63: 
64:         userEmailAddress3 = userTestHelper.getUserEmailAddress( 3 );
65:         userEmailAddress6 = userTestHelper.getUserEmailAddress( 6 );
66:         userEmailAddress2 = userTestHelper.getUserEmailAddress( 2 );
67: 
68:         productId8 = productTestHelper.getProductId( 8 );
69:         productId9 = productTestHelper.getProductId( 9 );
70:         productId10 = productTestHelper.getProductId( 10 );
71:         productId11 = productTestHelper.getProductId( 11 );
72:         productId12 = productTestHelper.getProductId( 12 );
73:         productId14 = productTestHelper.getProductId( 14 );
74: 
75:         map8_11_14_quantity_2_2_2 = new HashMap<>() {{
76:             put( productId8, 2 );
77:             put( productId11, 2 );
78:             put( productId14, 2 );
79:         }};
80:         map8_11_14_quantity_3_3_4 = new HashMap<>() {{
81:             put( productId8, 3 );
82:             put( productId11, 3 );
83:             put( productId14, 4 );
84:         }};
85:         map10_12_quantity_1_1 = new HashMap<>() {{
86:             put( productId10, 1 );
87:             put( productId12, 1 );
88:         }};
89:         map11_quantity_1 = new HashMap<>() {{
90:             put( productId11, 1 );
91:         }};
92:         map12_quantity_10 = new HashMap<>() {{
93:             put( productId12, 10 );
94:         }};
95:         map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
96:             put( productId8, 2 );
97:             put( productId9, 1 );
98:             put( productId10, 4 );
99:             put( productId11, 2 );
100:         }};
101: 
102:     }
103: 
104: 
105:     /**
106:      * Hint: to better understand the expected results of this test, see the distribution of stock
107:      * across depots, as specified in the DepotTestHelper and in the README file.
108:      */
109:     @Test
110:     public void testClosestSingleDepotWins() {
111:         log.info( "testClosestSingleDepotWins" );
112: 
113:         // given
114:         shoppingBasketUseCases.addProductToShoppingBasket(
115:                 userEmailAddress3, productId8, 2 );
116:         shoppingBasketUseCases.addProductToShoppingBasket(
117:                 userEmailAddress3, productId11, 2 );
118:         shoppingBasketUseCases.addProductToShoppingBasket(
119:                 userEmailAddress3, productId14, 2 );
120:         // that basket could have been served from depot 4 or 7, but 4 is closer to the user
121:         UUID depotId4 = depotTestHelper.getDepotId( 4 );
122: 
123:         // when
124:         Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userEmailAddress3 );
125: 
126:         // then
127:         checkDepotIds( purchaseIds, depotId4 );
128:         checkProductNumbers( purchaseIds, depotId4, map8_11_14_quantity_2_2_2 );
129:     }
130: 
131: 
132:     /**
133:      * Hint: to better understand the expected results of this test, see the distribution of stock
134:      * across depots, as specified in the DepotTestHelper and in the README file.
135:      */
136:     @Test
137:     public void testDepotWithEnoughCapacityWins() {
138:         log.info( "testDepotWithEnoughCapacityWins" );
139: 
140:         // given
141:         shoppingBasketUseCases.addProductToShoppingBasket(
142:                 userEmailAddress3, productId8, 3 );
143:         shoppingBasketUseCases.addProductToShoppingBasket(
144:                 userEmailAddress3, productId11, 3 );
145:         shoppingBasketUseCases.addProductToShoppingBasket(
146:                 userEmailAddress3, productId14, 4 );
147:         // that basket could have been served from depot 4 or 7, 4 is closer to the user,
148:         // but only 7 has enough capacity
149:         UUID depotId7 = depotTestHelper.getDepotId( 7 );
150: 
151:         // when
152:         Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userEmailAddress3 );
153: 
154:         // then
155:         checkDepotIds( purchaseIds, depotId7 );
156:         checkProductNumbers( purchaseIds, depotId7, map8_11_14_quantity_3_3_4 );
157:     }
158: 
159: 
160:     /**
161:      * Hint: to better understand the expected results of this test, see the distribution of stock
162:      * across depots, as specified in the DepotTestHelper and in the README file.
163:      */
164:     @Test
165:     public void testTwoDepots() {
166:         log.info( "testTwoDepots" );
167: 
168:         // given
169:         shoppingBasketUseCases.addProductToShoppingBasket(
170:                 userEmailAddress6, productId10, 1 );
171:         shoppingBasketUseCases.addProductToShoppingBasket(
172:                 userEmailAddress6, productId11, 1 );
173:         shoppingBasketUseCases.addProductToShoppingBasket(
174:                 userEmailAddress6, productId12, 1 );
175:         // that basket needs two deliveries (2 + 1 products) anyway, and there
176:         // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
177:         // closer. The smaller can then be served from 4 (closest), 7, or 8.
178:         UUID depotId5 = depotTestHelper.getDepotId( 5 );
179:                 // should cover map10_12_quantity_1_1
180:         UUID depotId4 = depotTestHelper.getDepotId( 4 );
181:                 // should cover map11_quantity_1
182: 
183:         // when
184:         Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userEmailAddress6 );
185: 
186:         // then
187:         checkDepotIds( purchaseIds, depotId5, depotId4 );
188:         checkProductNumbers( purchaseIds, depotId5, map10_12_quantity_1_1 );
189:         checkProductNumbers( purchaseIds, depotId4, map11_quantity_1 );
190:     }
191: 
192: 
193:     /**
194:      * Hint: to better understand the expected results of this test, see the distribution of stock
195:      * across depots, as specified in the DepotTestHelper and in the README file.
196:      */
197:     @Test
198:     public void testTwoBigDeliverys() {
199:         log.info( "testTwoBigDeliverys" );
200: 
201:         // given
202:         shoppingBasketUseCases.addProductToShoppingBasket(
203:                 userEmailAddress2, productId8, 2 );
204:         shoppingBasketUseCases.addProductToShoppingBasket(
205:                 userEmailAddress2, productId9, 1 );
206:         shoppingBasketUseCases.addProductToShoppingBasket(
207:                 userEmailAddress2, productId10, 4 );
208:         shoppingBasketUseCases.addProductToShoppingBasket(
209:                 userEmailAddress2, productId11, 2 );
210:         shoppingBasketUseCases.addProductToShoppingBasket(
211:                 userEmailAddress2, productId12, 10 );
212:         // when
213:         Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userEmailAddress2 );
214:         UUID depotId7 = depotTestHelper.getDepotId( 7 );
215:                 // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 products
216:         UUID depotId5 = depotTestHelper.getDepotId( 5 );
217:                 // should cover map12_quantity_10 - the only depot with enough capacity for 10 products
218: 
219:         // then
220:         checkDepotIds( purchaseIds, depotId7, depotId5 );
221:         checkProductNumbers( purchaseIds, depotId7, map8_9_10_11_quantity_2_1_4_2 );
222:         checkProductNumbers( purchaseIds, depotId5, map12_quantity_10 );
223:     }
224: 
225: 
226:     /**
227:      * Hint: to better understand the expected results of this test, see the distribution of stock
228:      * across depots, as specified in the DepotTestHelper and in the README file.
229:      */
230:     @Test
231:     public void testOnlyOneSolution() {
232:         log.info( "testOnlyOneSolution" );
233: 
234:         // given
235:         shoppingBasketUseCases.addProductToShoppingBasket(
236:                 userEmailAddress6, productId12, 10 );
237:         // when
238:         Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userEmailAddress6 );
239:         UUID depotId5 = depotTestHelper.getDepotId( 5 );
240:         // should cover map12_quantity_10 - the only depot with enough capacity for 10 products
241: 
242:         // then
243:         checkDepotIds( purchaseIds, depotId5 );
244:         checkProductNumbers( purchaseIds, depotId5, map12_quantity_10 );
245:     }
246: 
247: 
248: 
249:     private void checkProductNumbers( Set<UUID> purchaseIds, UUID depotId, Map<UUID, Integer> expectedMap ) {
250:         UUID fittingPurchaseId = null;
251:         for ( UUID purchaseId : purchaseIds ) {
252:             UUID foundDepotId = purchaseUseCases.getDepotIdForPurchase( purchaseId );
253:             if ( foundDepotId.equals( depotId ) ) {
254:                 fittingPurchaseId = purchaseId;
255:                 break;
256:             }
257:         }
258:         assertNotNull( fittingPurchaseId, "No fitting purchase found for depot " + depotId );
259: 
260:         int totalExpected = 0;
261:         int totalActual = 0;
262:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
263:             totalExpected += entry.getValue();
264:         }
265:         log.info( "Check purchase numbers for product {} in depot {}", fittingPurchaseId, depotId );
266:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
267:             UUID productId = entry.getKey();
268:             Integer foundNumber =
269:                     purchaseUseCases.getPurchaseQuantOfProduct( fittingPurchaseId, productId );
270:             assertEquals( entry.getValue(), foundNumber );
271:             totalActual += foundNumber;
272:         }
273:         // last check - do the total sums match?
274:         assertEquals( totalExpected, totalActual );
275:     }
276: 
277: 
278:     private void checkDepotIds( Set<UUID> purchaseIds, UUID... expectedDepotIds ) {
279:         assertEquals( expectedDepotIds.length, purchaseIds.size() );
280:         Set<UUID> foundDepotIds = new HashSet<>();
281:         for ( UUID purchaseId : purchaseIds ) {
282:             UUID depotId = purchaseUseCases.getDepotIdForPurchase( purchaseId );
283:             foundDepotIds.add( depotId );
284:         }
285:         for ( UUID expectedDepotId : expectedDepotIds ) {
286:             assertTrue( foundDepotIds.contains( expectedDepotId ) );
287:         }
288:     }
289: 
290: }
291: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingbasket;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.ResultMatcher;
12: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
13: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
14: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
15: import thkoeln.archilab.ecommerce.usecases.DepotUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
17: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
18: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
19: import thkoeln.archilab.ecommerce.usecases.masterdata.DepotTestHelper;
20: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
21: 
22: import java.util.HashMap;
23: import java.util.Map;
24: import java.util.UUID;
25: 
26: import static org.junit.jupiter.api.Assertions.assertEquals;
27: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
28: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
29: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmailAddress;
30: 
31: 
32: @SpringBootTest
33: @Transactional
34: @AutoConfigureMockMvc
35: @Import( RESTTestHelperConfiguration.class )
36: public class ShoppingBasketRESTTest {
37:     @Autowired
38:     private DepotUseCases depotUseCases;
39:     @Autowired
40:     private ShoppingBasketUseCases shoppingBasketUseCases;
41:     @Autowired
42:     private Purgatory purgatory;
43:     @Autowired
44:     private UserTestHelper userTestHelper;
45:     @Autowired
46:     private ProductTestHelper productTestHelper;
47:     @Autowired
48:     private DepotTestHelper depotTestHelper;
49:     @Autowired
50:     private MockMvc mockMvc;
51:     @Autowired
52:     private ShoppingBasketRESTHelper shoppingBasketRESTHelper;
53: 
54:     private EmailAddressType nonExistingEmailAddress;
55:     private final Map<UUID, Integer> emptyMap = new HashMap<>();
56: 
57:     private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
58:     private EmailAddressType
59:             userEmailAddress0,
60:             userEmailAddress3,
61:             userEmailAddress6,
62:             userEmailAddress8;
63:     private String userName0, userName8;
64:     private UUID productId0, productId1, productId2, productId3, productId5,
65:                  productId7, productId9, productId11, nonExistentProductId;
66:     private UUID depotId0, depotId3, depotId7, depotId8;
67: 
68: 
69:     private static final ResultMatcher NOT_FOUND = status().isNotFound();
70:     private static final ResultMatcher OK = status().isOk();
71:     private static final ResultMatcher CREATED = status().isCreated();
72:     private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
73:     private static final ResultMatcher CONFLICT = status().isConflict();
74: 
75:     @BeforeEach
76:     public void setUp() {
77:         purgatory.deleteEverything();
78:         userTestHelper.registerAllUsers();
79:         productTestHelper.addAllProducts();
80:         depotTestHelper.addAllDepots( true );
81:         nonExistingEmailAddress = instantiateEmailAddress( "harry@sally.de" );
82: 
83:         userEmailAddress0 = userTestHelper.getUserEmailAddress( 0 );
84:         userEmailAddress3 = userTestHelper.getUserEmailAddress( 3 );
85:         userEmailAddress6 = userTestHelper.getUserEmailAddress( 6 );
86:         userEmailAddress8 = userTestHelper.getUserEmailAddress( 8 );
87:         userName0 = userTestHelper.getUserName( 0 );
88:         userName8 = userTestHelper.getUserName( 8 );
89: 
90:         productId0 = productTestHelper.getProductId( 0 );
91:         productId1 = productTestHelper.getProductId( 1 );
92:         productId2 = productTestHelper.getProductId( 2 );
93:         productId3 = productTestHelper.getProductId( 3 );
94:         productId5 = productTestHelper.getProductId( 5 );
95:         productId7 = productTestHelper.getProductId( 7 );
96:         productId9 = productTestHelper.getProductId( 9 );
97:         productId11 = productTestHelper.getProductId( 11 );
98:         nonExistentProductId = UUID.randomUUID();
99: 
100:         depotId0 = depotTestHelper.getDepotId( 0 );
101:         depotId3 = depotTestHelper.getDepotId( 3 );
102:         depotId7 = depotTestHelper.getDepotId( 7 );
103:         depotId8 = depotTestHelper.getDepotId( 8 );
104: 
105:         map9_quantity_1 = new HashMap<>() {{
106:             put( productId9, 1 );
107:         }};
108:         map5_quantity_2 = new HashMap<>() {{
109:             put( productId5, 2 );
110:         }};
111:         map7_quantity_7 = new HashMap<>() {{
112:             put( productId7, 7 );
113:         }};
114:         map9_11_quantity_2_2 = new HashMap<>() {{
115:             put( productId9, 2 );
116:             put( productId11, 2 );
117:         }};
118:     }
119: 
120: 
121:     @Test
122:     public void testInvalidShoppingBasketBaseUris() throws Exception {
123:         // given
124:         String allShoppingBasketsUri = "/shoppingBaskets";
125:         String randomIdUri = "/shoppingBaskets/" + UUID.randomUUID();
126:         String randomUserUUID = "/shoppingBaskets?userId=" + UUID.randomUUID();
127:         String invalidUserUUID = "/shoppingBaskets?userId=invalidUUID";
128:         String randomParamUri = "/shoppingBaskets?randomParam=randomValue";
129: 
130:         // when
131:         // then
132:         mockMvc.perform( get( allShoppingBasketsUri ) ).andExpect( status().isMethodNotAllowed() );
133:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
134:         mockMvc.perform( get( randomUserUUID ) ).andExpect( status().isNotFound() );
135:         mockMvc.perform( get( invalidUserUUID ) ).andExpect( status().isNotFound() );
136:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
137:     }
138: 
139: 
140:     @Test
141:     public void testInvalidPositionUris() throws Exception {
142:         // given
143:         UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress8, emptyMap );
144:         String randomPositionUri = "/shoppingBaskets/" + shoppingBasketId8.toString() + "/random";
145:         String randomProductUri = "/shoppingBaskets/" + shoppingBasketId8.toString()
146:                 + "/positions/" + UUID.randomUUID();
147: 
148:         // when
149:         // then
150:         mockMvc.perform( post( randomPositionUri ) ).andExpect( status().isNotFound() );
151:         mockMvc.perform( delete( randomProductUri ) ).andExpect( status().isNotFound() );
152:     }
153: 
154: 
155:     @Test
156:     public void testInvalidAddToShoppingBasket() throws Exception {
157:         // given
158:         Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
159:         expectedStartQuantityMap.put( productId2, 19 );
160: 
161:         // when
162:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress0, emptyMap );
163:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId, productId2, 6 );
164:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId, productId2, 13 );
165: 
166:         // then
167:         shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress0, expectedStartQuantityMap );
168: 
169:         // ... and check a couple of invalid cases
170:         shoppingBasketRESTHelper.addProductToShoppingBasket(
171:                 shoppingBasketId, nonExistentProductId, 12, NOT_FOUND );
172:         shoppingBasketRESTHelper.addProductToShoppingBasket(
173:                 UUID.randomUUID(), productId5, 12, NOT_FOUND );
174:         shoppingBasketRESTHelper.addProductToShoppingBasket(
175:                 shoppingBasketId, productId5, -1, UNPROCESSABLE_ENTITY );
176: 
177:         // check if the shopping basket is still the same
178:         shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress0, expectedStartQuantityMap );
179:     }
180: 
181: 
182:     @Test
183:     public void testInvalidCheckout_unavailableProduct() throws Exception {
184:         // given
185:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress0, emptyMap );
186: 
187:         // when
188:         // productId0 is not available in the requested quantity (or rather, not at all)
189:         shoppingBasketRESTHelper.addProductToShoppingBasket(
190:                 shoppingBasketId, productId0, 1, CREATED );
191: 
192:         // check if the shopping basket is still the same
193:         shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
194:     }
195: 
196: 
197:     @Test
198:     public void testInvalidCheckout_tooLittleStock() throws Exception {
199:         // given
200:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress0, emptyMap );
201: 
202:         // when
203:         // There are only 10 pieces of productId1 available
204:         shoppingBasketRESTHelper.addProductToShoppingBasket(
205:                 shoppingBasketId, productId1, 11, CREATED );
206: 
207:         // check if the shopping basket is still the same
208:         shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
209:     }
210: 
211: 
212: 
213:     @Test
214:     public void testDeleteProductFromShoppingBasket() throws Exception {
215:         // given
216:         UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress6, emptyMap );
217:         Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
218:         expectedQuantityMap1.put( productId1, 1 );
219:         expectedQuantityMap1.put( productId2, 2 );
220:         expectedQuantityMap1.put( productId3, 3 );
221:         Map<UUID, Integer> quantityMap2 = new HashMap<>();
222:         quantityMap2.put( productId1, 1 );
223:         quantityMap2.put( productId3, 3 );
224: 
225:         // when
226:         // then
227:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId1, 1 );
228:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId2, 2 );
229:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId3, 3 );
230:         shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress6, expectedQuantityMap1 );
231: 
232:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId2 );
233:         shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress6, quantityMap2 );
234:     }
235: 
236: 
237:     @Test
238:     public void testNoDoubleDelete() throws Exception {
239:         // given
240:         UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress6, emptyMap );
241: 
242:         // when
243:         // then
244:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId3, 3 );
245:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId3 );
246:         shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress6, new HashMap<>() );
247:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId3, NOT_FOUND );
248:     }
249: 
250: 
251:     @Test
252:     public void testAddRemoveProductsFromAndToShoppingBasket() throws Exception {
253:         // given
254:         UUID shoppingBasketId3 = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress3, emptyMap );
255:         UUID shoppingBasketId5 = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress6, emptyMap );
256: 
257:         // when
258:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId1, 2 );
259:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId2, 3 );
260:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId3, productId1 );
261:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId1, 1 );
262:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId2, 6 );
263: 
264:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId1, 2 );
265:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId2, 8 );
266:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId5, productId1 );
267:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId1, 1 );
268:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId2, 2 );
269: 
270:         // then
271:         // user3 has 1x productId1 and 9x productId2 expected in cart
272:         Map<UUID, Integer> expectedMap3 = new HashMap<>();
273:         expectedMap3.put( productId1, 1 );
274:         expectedMap3.put( productId2, 9 );
275:         shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress3, expectedMap3 );
276: 
277:         // user6 has 1x productId1 and 10x productId2 in cart
278:         Map<UUID, Integer> expectedMap5 = new HashMap<>();
279:         expectedMap5.put( productId1, 1 );
280:         expectedMap5.put( productId2, 10 );
281:         shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress6, expectedMap5 );
282:     }
283: 
284: 
285:     @Test
286:     public void testNoDoubleCheckout() throws Exception {
287:         // given
288:         UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress8, emptyMap );
289: 
290:         // when
291:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId2, 3 );
292: 
293:         // then
294:         shoppingBasketRESTHelper.checkout( shoppingBasketId8, userName8, CREATED, null );
295:         shoppingBasketRESTHelper.checkout( shoppingBasketId8, null, CONFLICT, null );
296:     }
297: 
298: 
299:     @Test
300:     public void testCheckout_1_Purchase() throws Exception {
301:         // given:
302:         // User 0 wants to buy 1x product 9. This is in depot 5, 7, and 8. Out of these,
303:         // depot 8 with postal code 89250 is closest to user 0 with postal code 02314.
304:         Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>() {{
305:             put( depotId8, map9_quantity_1 );
306:         }};
307:         UUID shoppingBasketId0 = shoppingBasketRESTHelper.getQueryShoppingBasket(
308:                 userEmailAddress0, null );
309:         int stock9before =
310:                 depotUseCases.getAvailableStock( depotId8, productId9 );
311: 
312:         // when
313:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId0, productId9, 1 );
314:         shoppingBasketRESTHelper.checkout( shoppingBasketId0, userName0, CREATED, expectedPurchases );
315:         int stock9after =
316:                 depotUseCases.getAvailableStock( depotId8, productId9 );
317: 
318:         // then
319:         assertEquals( 1, stock9before - stock9after );
320:     }
321: 
322: 
323:     @Test
324:     public void testCheckout_3_Purchase() throws Exception {
325:         // given:
326:         // User 8 (Felix Bauer) wants to buy 2x each of products 5, 9, 11; and 7x product 7.
327:         //       - products 9 and 11 can both be found in depots 7 and 8. Depots 7 (76532) is closer to
328:         //         the user (70173)
329:         //       - product 7 is available in depots 1, 2, and 3, but only depot 3 has enough stock.
330:         //       - product 5 is only available in depot 0.
331:         Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>() {{
332:             put( depotId0, map5_quantity_2 );
333:             put( depotId3, map7_quantity_7 );
334:             put( depotId7, map9_11_quantity_2_2 );
335:         }};
336:         UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket(
337:                 userEmailAddress8, null );
338:         int stock5before =
339:                 depotUseCases.getAvailableStock( depotId0, productId5 );
340:         int stock7before =
341:                 depotUseCases.getAvailableStock( depotId3, productId7 );
342:         int stock9before =
343:                 depotUseCases.getAvailableStock( depotId7, productId9 );
344:         int stock11before =
345:                 depotUseCases.getAvailableStock( depotId7, productId11 );
346: 
347:         // when
348:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId5, 2 );
349:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId7, 7 );
350:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId9, 2 );
351:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId11, 2 );
352:         shoppingBasketRESTHelper.checkout( shoppingBasketId8, userName8, CREATED, expectedPurchases );
353:         int stock5after =
354:                 depotUseCases.getAvailableStock( depotId0, productId5 );
355:         int stock7after =
356:                 depotUseCases.getAvailableStock( depotId3, productId7 );
357:         int stock9after =
358:                 depotUseCases.getAvailableStock( depotId7, productId9 );
359:         int stock11after =
360:                 depotUseCases.getAvailableStock( depotId7, productId11 );
361: 
362:         // then
363:         assertEquals( 2, stock5before - stock5after );
364:         assertEquals( 7, stock7before - stock7after );
365:         assertEquals( 2, stock9before - stock9after );
366:         assertEquals( 2, stock11before - stock11after );
367:     }
368: 
369: 
370: }
371: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingbasket;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.InsufficientStockException;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.DepotTestHelper;
12: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
13: import thkoeln.archilab.ecommerce.usecases.*;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
16: 
17: 
18: import java.util.Map;
19: import java.util.UUID;
20: 
21: import static org.junit.jupiter.api.Assertions.*;
22: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
23: 
24: @SpringBootTest
25: public class ShoppingBasketTest {
26:     @Autowired
27:     private UserRegistrationUseCases userRegistrationUseCases;
28:     @Autowired
29:     private ShoppingBasketUseCases shoppingBasketUseCases;
30:     @Autowired
31:     private ProductCatalogUseCases productCatalogUseCases;
32:     @Autowired
33:     private DepotUseCases depotUseCases;
34:     @Autowired
35:     private PurchaseUseCases purchaseUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private UserTestHelper userTestHelper;
40:     @Autowired
41:     private ProductTestHelper productTestHelper;
42:     @Autowired
43:     private DepotTestHelper depotTestHelper;
44: 
45:     private EmailAddressType nonExistingEmailAddress;
46: 
47:     @BeforeEach
48:     public void setUp() {
49:         purgatory.deleteEverything();
50:         userTestHelper.registerAllUsers();
51:         productTestHelper.addAllProducts();
52: 
53:         nonExistingEmailAddress = instantiateEmailAddress( "this@nononono.de" );
54:     }
55: 
56: 
57:     @Test
58:     public void testInvalidAddToShoppingBasket() {
59:         // given
60:         UUID nonExistentProductId = UUID.randomUUID();
61:         UUID productId5 = productTestHelper.getProductId( 5 );
62:         UUID productId0 = productTestHelper.getProductId( 0 );
63:         EmailAddressType userEmailAddress0 =
64:                 userTestHelper.getUserEmailAddress( 0 );
65:         depotTestHelper.addAllDepots( true );
66: 
67:         // then
68:         assertThrows( ShopException.class,
69:                 () -> shoppingBasketUseCases.addProductToShoppingBasket(
70:                         nonExistingEmailAddress, productId0, 1 ) );
71:         assertThrows( ShopException.class,
72:                 () -> shoppingBasketUseCases.addProductToShoppingBasket(
73:                         null, productId0, 1 ) );
74:         assertThrows( ShopException.class,
75:                 () -> shoppingBasketUseCases.addProductToShoppingBasket(
76:                         userEmailAddress0, nonExistentProductId, 1 ) );
77:         assertThrows( ShopException.class,
78:                 () -> shoppingBasketUseCases.addProductToShoppingBasket(
79:                         userEmailAddress0, null, 1 ) );
80:         assertThrows( ShopException.class,
81:                 () -> shoppingBasketUseCases.addProductToShoppingBasket(
82:                         userEmailAddress0, productId5, -1 ) );
83:     }
84: 
85: 
86:     @Test
87:     public void testInvalidRemoveFromShoppingBasket() {
88:         // given
89:         UUID nonExistentProductId = UUID.randomUUID();
90:         UUID productId5 = productTestHelper.getProductId( 5 );
91:         UUID productId1 = productTestHelper.getProductId( 1 );
92:         UUID productId2 = productTestHelper.getProductId( 2 );
93:         depotTestHelper.addAllDepots( true );
94:         EmailAddressType userEmailAddress0 =
95:                 userTestHelper.getUserEmailAddress( 0 );
96:         shoppingBasketUseCases.addProductToShoppingBasket(
97:                 userEmailAddress0, productId1, 5 );
98:         shoppingBasketUseCases.addProductToShoppingBasket(
99:                 userEmailAddress0, productId2, 15 );
100: 
101:         // when
102:         shoppingBasketUseCases.removeProductFromShoppingBasket(
103:                 userEmailAddress0, productId1, 2 );
104:         shoppingBasketUseCases.removeProductFromShoppingBasket(
105:                 userEmailAddress0, productId2, 4 );
106:         shoppingBasketUseCases.removeProductFromShoppingBasket(
107:                 userEmailAddress0, productId2, 7 );
108:         // now we should have 3x productId1 and 4x productId2 in the shopping basket
109: 
110:         // then
111:         assertThrows( ShopException.class,
112:                 () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
113:                         userEmailAddress0, nonExistentProductId, 12 ) );
114:         assertThrows( ShopException.class,
115:                 () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
116:                         nonExistingEmailAddress, productId5, 12 ) );
117:         assertThrows( ShopException.class,
118:                 () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
119:                         userEmailAddress0, productId5, -1 ) );
120:         assertThrows( ShopException.class,
121:                 () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
122:                         userEmailAddress0, productId1, 4 ) );
123:         assertThrows( ShopException.class,
124:                 () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
125:                         userEmailAddress0, productId2, 5 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testAddRemoveProductsFromAndToShoppingBasket() {
131:         // given
132:         UUID productId1 = productTestHelper.getProductId( 1 );
133:         UUID productId2 = productTestHelper.getProductId( 2 );
134:         EmailAddressType userEmailAddress3 =
135:                 userTestHelper.getUserEmailAddress( 3 );
136:         EmailAddressType userEmailAddress5 =
137:                 userTestHelper.getUserEmailAddress( 5 );
138: 
139:         // when user 3 ...
140:         shoppingBasketUseCases.addProductToShoppingBasket(
141:                 userEmailAddress3, productId1, 2 );
142:         shoppingBasketUseCases.addProductToShoppingBasket(
143:                 userEmailAddress3, productId2, 3 );
144:         shoppingBasketUseCases.removeProductFromShoppingBasket(
145:                 userEmailAddress3, productId1, 2 );
146:         shoppingBasketUseCases.addProductToShoppingBasket(
147:                 userEmailAddress3, productId1, 1 );
148:         shoppingBasketUseCases.addProductToShoppingBasket(
149:                 userEmailAddress3, productId2, 6 );
150:         Map<UUID, Integer> cart3 = shoppingBasketUseCases.getShoppingBasketAsMap( userEmailAddress3 );
151:         // user3 has 1x productId1 and 9x productId2 in cart
152: 
153:         // ... and when user 5 ...
154:         shoppingBasketUseCases.addProductToShoppingBasket(
155:                 userEmailAddress5, productId1, 2 );
156:         shoppingBasketUseCases.addProductToShoppingBasket(
157:                 userEmailAddress5, productId2, 8 );
158:         shoppingBasketUseCases.removeProductFromShoppingBasket(
159:                 userEmailAddress5, productId1, 1 );
160:         shoppingBasketUseCases.addProductToShoppingBasket(
161:                 userEmailAddress5, productId2, 2 );
162:         Map<UUID, Integer> cart5 = shoppingBasketUseCases.getShoppingBasketAsMap( userEmailAddress5 );
163:         // user5 has 1x productId1 and 10x productId2 in cart
164: 
165:         // then
166:         assertEquals( 2, cart3.size() );
167:         assertEquals( 1, cart3.get( productId1 ) );
168:         assertEquals( 9, cart3.get( productId2 ) );
169: 
170:         assertEquals( 2, cart5.size() );
171:         assertEquals( 1, cart5.get( productId1 ) );
172:         assertEquals( 10, cart5.get( productId2 ) );
173:     }
174: 
175: 
176:     @Test
177:     public void testShoppingBasketValue() {
178:         // given
179:         UUID productId3 = productTestHelper.getProductId( 3 );
180:         UUID productId6 = productTestHelper.getProductId( 6 );
181:         UUID productId8 = productTestHelper.getProductId( 8 );
182:         CurrencyType price3 = productTestHelper.getSalesPrice( 3 );
183:         CurrencyType price6 = productTestHelper.getSalesPrice( 6 );
184:         CurrencyType price8 = productTestHelper.getSalesPrice( 8 );
185:         EmailAddressType userEmailAddress3 =
186:                 userTestHelper.getUserEmailAddress( 3 );
187: 
188:         // when
189:         shoppingBasketUseCases.addProductToShoppingBasket( userEmailAddress3, productId3, 3 );
190:         shoppingBasketUseCases.addProductToShoppingBasket( userEmailAddress3, productId6, 2 );
191:         shoppingBasketUseCases.addProductToShoppingBasket( userEmailAddress3, productId8, 5 );
192:         // user3 has 3x productId3, 2x productId6 and 5x productId8 in cart
193:         CurrencyType cartValue = shoppingBasketUseCases.getShoppingBasketAsCurrencyValue( userEmailAddress3 );
194: 
195:         // then
196:         assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
197:                 cartValue );
198:     }
199: 
200: 
201:     @Test
202:     public void testShoppingBasketValueInvalid() {
203:         // given
204:         // when
205:         // then
206:         assertThrows( ShopException.class,
207:                 () -> shoppingBasketUseCases.getShoppingBasketAsCurrencyValue( nonExistingEmailAddress ) );
208:     }
209: 
210: 
211:     @Test
212:     public void testUnsuccessfulCheckout() {
213:         // given user buying product 0 (which is not in stock), and user 1 buying product 1
214:         // in a bigger quantity (11) than available (10)
215:         depotTestHelper.addAllDepots( true );
216:         EmailAddressType userEmailAddress0 =
217:                 userTestHelper.getUserEmailAddress( 0 );
218:         EmailAddressType userEmailAddress1 =
219:                 userTestHelper.getUserEmailAddress( 1 );
220:         UUID productId0 = productTestHelper.getProductId( 0 );
221:         UUID productId1 = productTestHelper.getProductId( 1 );
222: 
223:         // when
224:         shoppingBasketUseCases.addProductToShoppingBasket(
225:                 userEmailAddress0, productId0, 1 );
226:         shoppingBasketUseCases.addProductToShoppingBasket(
227:                 userEmailAddress1, productId1, 11 );
228: 
229:         // then
230:         assertThrows( InsufficientStockException.class,
231:                 () -> shoppingBasketUseCases.checkout( userEmailAddress0 ) );
232:         assertThrows( InsufficientStockException.class,
233:                 () -> shoppingBasketUseCases.checkout( userEmailAddress1 ) );
234:     }
235: 
236: }
237: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
1: package thkoeln.archilab.ecommerce.tests.testtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.domain.JavaMethod;
6: import com.tngtech.archunit.core.importer.ClassFileImporter;
7: import com.tngtech.archunit.lang.ArchRule;
8: import org.junit.jupiter.api.BeforeEach;
9: import org.junit.jupiter.api.Test;
10: import org.springframework.web.bind.annotation.RestController;
11: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
12: import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
13: import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingBasketRESTTest;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
18: 
19: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
20: import static org.springframework.test.util.AssertionErrors.assertTrue;
21: 
22: /**
23:  * This test checks if there are the appropriate tests in the test class(es) for domain
24:  * primitives.
25:  */
26: 
27: public class RulesForOwnTests {
28:     private JavaClass dpTestClass, restTestClass;
29:     private JavaClasses dpTestClasses, restTestClasses;
30:     private static final String DEPOT_DOMAIN_PACKAGE =
31:             "thkoeln.archilab.ecommerce.solution.depot.domain";
32:     private static final String DEPOT_CLASS_NAME =
33:             DEPOT_DOMAIN_PACKAGE + ".Depot";
34: 
35: 
36:     @BeforeEach
37:     public void setUp() throws Exception {
38:         dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
39:         restTestClass = new ClassFileImporter().importClass( OwnShoppingBasketRESTTest.class );
40: 
41:         dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
42:         restTestClasses = new ClassFileImporter().importClasses( OwnShoppingBasketRESTTest.class );
43:     }
44: 
45: 
46:     @Test
47:     public void ensureMinimumNumberOfTestMethods() {
48:         // given
49:         // when
50:         int dpTestMethodCount = getTestMethodCount( dpTestClass );
51:         int restTestMethodCount = getTestMethodCount( restTestClass );
52: 
53:         // then
54:         assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
55:                         + dpTestMethodCount,dpTestMethodCount >= 2 );
56:         assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
57:                         + restTestMethodCount, restTestMethodCount >= 5 );
58:     }
59: 
60:     private int getTestMethodCount( JavaClass testClass ) {
61:         int testMethodCount = 0;
62:         for ( JavaMethod method : testClass.getMethods() ) {
63:             if ( isTestMethod( method ) ) {
64:                 testMethodCount++;
65:             }
66:         }
67:         return testMethodCount;
68:     }
69: 
70:     private boolean isTestMethod( JavaMethod method ) {
71:         return method.isAnnotatedWith( Test.class );
72:     }
73: 
74: 
75:     @Test
76:     public void dpTestsShouldReferenceTheRightClasses() {
77:         ArchRule rule = classes()
78:                 .should().dependOnClassesThat()
79:                 .areAssignableTo( PostalCodeType.class )
80:                 .andShould().dependOnClassesThat()
81:                 .areAssignableTo( CurrencyType.class )
82:                 .andShould().dependOnClassesThat()
83:                 .areAssignableTo( PhysicalAddressType.class )
84:                 .andShould().dependOnClassesThat()
85:                 .areAssignableTo( EmailAddressType.class )
86:                 .because( "DomainPrimitiveJSONSerializationTest should reference PostalCode, " +
87:                         "Currency, EmailAddress, and PhysicalAddress!" );
88:         rule.check( dpTestClasses );
89:     }
90: 
91: 
92:     @Test
93:     public void restTestsShouldReferenceEmailAddress() {
94:         ArchRule rule = classes()
95:                 .should().dependOnClassesThat()
96:                 .areAssignableTo( EmailAddressType.class )
97:                 .because( "DepotComparatorUnitTest should reference EmailAddressType!" );
98:         rule.check( restTestClasses );
99:     }
100: 
101: 
102:     @Test
103:     public void restTestsShouldReferenceRESTControllers() {
104:         ArchRule rule = classes()
105:                 .should().dependOnClassesThat()
106:                 .areAnnotatedWith( RestController.class )
107:                 .orShould().dependOnClassesThat()
108:                 .areAssignableTo( ShoppingBasketRESTHelper.class )
109:                 .because( "DepotComparatorUnitTest should call REST controllers! " +
110:                         "(either directly or via the ShoppingBasketRESTHelper REST helper)" );
111:         rule.check( restTestClasses );
112:     }
113: 
114: }
115: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\user\UserRegistrationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.user;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
12: import thkoeln.archilab.ecommerce.usecases.UserType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
15: 
16: import static org.junit.jupiter.api.Assertions.*;
17: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
18: 
19: 
20: @SpringBootTest
21: public class UserRegistrationTest {
22:     @Autowired
23:     private UserRegistrationUseCases userRegistrationUseCases;
24:     @Autowired
25:     private Purgatory purgatory;
26:     @Autowired
27:     private UserTestHelper userTestHelper;
28: 
29:     private EmailAddressType nonExistingEmailAddress;
30:     private PhysicalAddressType somePhysicalAddress;
31: 
32:     @BeforeEach
33:     public void setUp() {
34:         purgatory.deleteEverything();
35:         nonExistingEmailAddress = instantiateEmailAddress( "this@nononono.de" );
36:         somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
37:                 instantiatePostalCode( "90001" ) );
38:     }
39: 
40:     @Test
41:     public void testAllUsersRegistered() {
42:         // given
43:         userTestHelper.registerAllUsers();
44:         EmailAddressType emailAddress3 =
45:                 userTestHelper.getUserEmailAddress( 3 );
46:         String name3 = userTestHelper.getUserName( 3 );
47:         PhysicalAddressType physicalAddress3 = userTestHelper.getUserPhysicalAddress( 3 );
48: 
49:         // when
50:         UserType user3 = userRegistrationUseCases.getUserData(
51:                 emailAddress3 );
52: 
53:         // then
54:         Assertions.assertEquals( name3, user3.getName() );
55:         Assertions.assertEquals( emailAddress3, user3.getEmailAddress() );
56:         Assertions.assertEquals( physicalAddress3, user3.getPhysicalAddress() );
57:     }
58: 
59: 
60:     @Test
61:     public void testRegisterUserWithDuplicateEmailAddress() {
62:         // given
63:         userTestHelper.registerAllUsers();
64:         PhysicalAddressType physicalAddress5 = userTestHelper.getUserPhysicalAddress( 5 );
65:         EmailAddressType emailAddress5 =
66:                 userTestHelper.getUserEmailAddress( 5 );
67: 
68:         // when
69:         // then
70:         assertThrows( ShopException.class, () ->
71:                 userRegistrationUseCases.register( "Gandalf The Grey",
72:                         emailAddress5, physicalAddress5 ) );
73:     }
74: 
75: 
76:     @Test
77:     public void testRegisterUserWithDuplicateNameOrPhysicalAddress() {
78:         // given
79:         userTestHelper.registerAllUsers();
80:         EmailAddressType newEmailAddress =
81:                 instantiateEmailAddress( "some@this.de" );
82:         PhysicalAddressType physicalAddress2 = userTestHelper.getUserPhysicalAddress( 2 );
83:         String name2 = userTestHelper.getUserName( 2 );
84: 
85:         // when
86:         // then
87:         assertDoesNotThrow( () ->
88:                 userRegistrationUseCases.register( name2, newEmailAddress, physicalAddress2 ) );
89:     }
90: 
91: 
92:     @Test
93:     public void testRegisterUserWithInvalidData() {
94:         // given
95:         EmailAddressType emailAddress5 =
96:                 userTestHelper.getUserEmailAddress( 5 );
97:         PhysicalAddressType physicalAddress5 = userTestHelper.getUserPhysicalAddress( 5 );
98:         String name5 = userTestHelper.getUserName( 5 );
99: 
100:         // when
101:         // then
102:         assertThrows( ShopException.class, () ->
103:                 userRegistrationUseCases.register( null, emailAddress5, physicalAddress5 ) );
104:         assertThrows( ShopException.class, () ->
105:                 userRegistrationUseCases.register("", emailAddress5, physicalAddress5 ) );
106:         assertThrows( ShopException.class, () ->
107:                 userRegistrationUseCases.register( name5, null, physicalAddress5 ) );
108:         assertThrows( ShopException.class, () ->
109:                 userRegistrationUseCases.register( name5, emailAddress5, null ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testChangeAddressWithInvalidData() {
115:         // given
116:         userTestHelper.registerAllUsers();
117:         PhysicalAddressType physicalAddress7 = userTestHelper.getUserPhysicalAddress( 7 );
118:         EmailAddressType emailAddress7 =
119:                 userTestHelper.getUserEmailAddress( 7 );
120: 
121:         // when
122:         // then
123:         assertThrows( ShopException.class, () ->
124:                 userRegistrationUseCases.changeAddress( nonExistingEmailAddress, physicalAddress7 ) );
125:         assertThrows( ShopException.class, () ->
126:                 userRegistrationUseCases.changeAddress( null, physicalAddress7 ) );
127:         assertThrows( ShopException.class, () ->
128:                 userRegistrationUseCases.changeAddress( emailAddress7, null ) );
129:     }
130: 
131: 
132:     @Test
133:     public void testGetDataForNonexistingEmailAddress() {
134:         // given
135:         userTestHelper.registerAllUsers();
136: 
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 userRegistrationUseCases.getUserData( nonExistingEmailAddress ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testDeleteUsersNoMoreUsers() {
146:         // given
147:         userTestHelper.registerAllUsers();
148:         EmailAddressType emailAddress0 =
149:                 userTestHelper.getUserEmailAddress( 0 );
150: 
151: 
152:         // when
153:         userRegistrationUseCases.deleteAllUsers();
154: 
155:         // then
156:         assertThrows( ShopException.class, () -> userRegistrationUseCases.getUserData(
157:                 emailAddress0 ) );
158:     }
159: 
160: 
161:     @Test
162:     public void testChangeAddressSuccessful() {
163:         // given
164:         userTestHelper.registerAllUsers();
165:         EmailAddressType emailAddress6 =
166:                 userTestHelper.getUserEmailAddress( 6 );
167: 
168:         // when
169:         userRegistrationUseCases.changeAddress( emailAddress6, somePhysicalAddress );
170:         UserType newUser6 =
171:                 userRegistrationUseCases.getUserData( emailAddress6 );
172: 
173:         // then
174:         Assertions.assertEquals( emailAddress6, newUser6.getEmailAddress() );
175:         Assertions.assertEquals( somePhysicalAddress, newUser6.getPhysicalAddress() );
176:     }
177: 
178: 
179:     @Test
180:     public void testChangeAddressForNonexistingEmailAddress() {
181:         // given
182:         userTestHelper.registerAllUsers();
183: 
184:         // when
185:         // then
186:         assertThrows( ShopException.class, () ->
187:                 userRegistrationUseCases.changeAddress( nonExistingEmailAddress, somePhysicalAddress ) );
188:     }
189: 
190: 
191: }
192: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\user\UserRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.user;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
12: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
13: import thkoeln.archilab.ecommerce.usecases.UserType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
16: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
17: 
18: import java.util.UUID;
19: 
20: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
21: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
22: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
23: 
24: @SpringBootTest
25: @Transactional
26: @AutoConfigureMockMvc
27: @Import( RESTTestHelperConfiguration.class )
28: public class UserRESTTest {
29:     @Autowired
30:     private UserRegistrationUseCases userRegistrationUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private UserTestHelper userTestHelper;
35:     @Autowired
36:     private MockMvc mockMvc;
37: 
38:     private UUID randomId;
39:     private EmailAddressType nonExistingEmailAddress;
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         userTestHelper.registerAllUsers();
45: 
46:         nonExistingEmailAddress = FactoryMethodInvoker.instantiateEmailAddress(
47:                 "harry@sally.de" );
48:         randomId = UUID.randomUUID();
49:     }
50: 
51: 
52:     @Test
53:     public void testInvalidUserUris() throws Exception {
54:         // given
55:         String allUsersUri = "/users";
56:         String randomIdUri = "/users/" +  randomId;
57:         String nonExistingEmailAddressUri = "/users?emailAddress=" + nonExistingEmailAddress;
58:         String randomParamUri = "/users?randomParam=randomValue";
59: 
60:         // when
61:         // then
62:         mockMvc.perform( get( allUsersUri ) ).andExpect( status().isMethodNotAllowed() );
63:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
64:         mockMvc.perform( get( nonExistingEmailAddressUri ) ).andExpect( status().isNotFound() );
65:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
66:     }
67: 
68: 
69:     @Test
70:     public void testRandomUserId() throws Exception {
71:         // given
72:         String invalidUri = "/users/" +  randomId;
73: 
74:         // when
75:         // then
76:         mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
77:     }
78: 
79: 
80:     @Test
81:     public void testQueryUser() throws Exception {
82:         // given
83:         EmailAddressType emailAddress4 =
84:                 userTestHelper.getUserEmailAddress( 4 );
85:         String userUri4 = "/users?emailAddress=" + emailAddress4;
86: 
87:         // when
88:         UserType user4 = userRegistrationUseCases.getUserData( emailAddress4 );
89:         String name = userTestHelper.getUserName( 4 );
90:         PhysicalAddressType physicalAddress4 = userTestHelper.getUserPhysicalAddress( 4 );
91: 
92:         // then (check using JSONPath)
93:         mockMvc.perform( get( userUri4 ) )
94:                 .andExpect( status().isOk() )
95:                 .andExpect( jsonPath( "$.name" ).value( name ) )
96:                 // id is position 0 (cannot be tested with current API structure), name is position 1,
97:                 // email address is 2, physical address is 3)
98:                 .andExpect( jsonPath( "$..emailAddressString" ).value( emailAddress4.toString() ) )
99:                 .andExpect( jsonPath( "$..city" ).value( physicalAddress4.getCity() ) )
100:                 .andExpect( jsonPath( "$..postalCodeString" ).value(
101:                         physicalAddress4.getPostalCode().toString() ) );
102:     }
103: 
104: }
105: 

[RESPONSE]:
Ich werde die Dateien systematisch nach den genannten Code Smells durchsuchen.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Currency.java**

- **Currency** [Zeile 99-105]: **dead code** : Die Methode `isValidCurrency` wird nur intern in Zeile 27 aufgerufen, aber sie ist `public static` und könnte vereinfacht werden, da die Validierung bereits in `of()` erfolgt und die Methode extern nicht genutzt wird.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\application\DepotService.java**

- **DepotService** [Zeilen 173-175]: **dead code** : Methode `validateFromToDigitRange` wird nirgends aufgerufen.
- **DepotService** [Zeilen 181-184]: **dead code** : Methode `validatePostalCodeDigit` wird nirgends aufgerufen.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\Address.java**

- **Address** [Zeilen 20-28]: **dead code** : Methode `validateAddress` wird nirgends im Projekt aufgerufen.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\DepotIdConverter.java**

- **DepotIdConverter** [Zeile 5]: **dead code** : Import `thkoeln.archilab.ecommerce.solution.user.domain.UserId` wird nicht verwendet.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\StockLevel.java**

- **-Anemic Entity-**

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\Product.java**

- **-Anemic Entity-**

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePosition.java**

- **-Anemic Entity-**

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingApplicationService.java**

- **ShoppingApplicationService** [Zeilen 49-66]: **dead code** : Methode `addPositionToBasket` wird nirgends im Projekt aufgerufen.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingService.java**

- **ShoppingService** [Zeilen 68-99 und 101-129]: **Duplication** : Die Methoden `addProductToShoppingBasket(EmailAddressType, ProductId, int)` und `addProductToShoppingBasket(UUID, ShoppingBasketPositionDTO)` haben nahezu identische Logik (Validierung, ShoppingBasket laden, Position suchen/erstellen, Menge aktualisieren, speichern). Original: Zeilen 68-99, Duplikat: Zeilen 101-129.
- **ShoppingService** [Zeilen 131-158 und 159-172]: **Duplication** : Die Methoden `removeProductFromShoppingBasket(EmailAddressType, ProductId, int)` und `removeProductFromShoppingBasket(ShoppingBasketId, ProductId)` haben stark ähnliche Logik. Original: Zeilen 131-158, Duplikat: Zeilen 159-172.
- **ShoppingService** [Zeilen 218-255 und 256-291]: **Duplication** : Die Methoden `checkout(EmailAddress)` und `checkout(ShoppingBasketId)` haben nahezu identische Implementierung (Basket laden, Depots sortieren, Purchases erstellen). Original: Zeilen 218-255, Duplikat: Zeilen 256-291.
- **ShoppingService** [Zeilen 194-196]: **Duplication** : `EmailAddress emailAddress = (EmailAddress) userEmailAddress;` ist redundant, da der Parameter bereits `EmailAddress` ist. Ähnlich auch in Zeilen 220-221.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java**

- **-Anemic Entity-**

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketRepository.java**

- **ShoppingBasketRepository** [Zeilen 13 und 15]: **Duplication** : `getShoppingBasketById` und `findShoppingBasketById` haben identische Signaturen und Zweck. Eine der beiden Methoden ist redundant.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserController.java**

- **UserController** [Zeilen 165-171]: **dead code** : Private Methode `nullThrow` wird nirgends in der Klasse aufgerufen.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\User.java**

- **-Anemic Entity-**

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java**

- **ShoppingBasketController** [Zeile 14]: **layer violation** : Import aus `thkoeln.archilab.ecommerce.solution.purchase.application` - Controller im `shoppingbasket`-Package greift auf Application-Layer eines anderen Packages zu.
- **ShoppingBasketController** [Zeilen 15-17]: **layer violation** : Imports aus `thkoeln.archilab.ecommerce.solution.purchase.domain` - Controller greift auf Domain-Schicht eines anderen Packages zu.
- **ShoppingBasketController** [Zeile 40]: **misplaced responsibility** : `PurchaseService` wird im `ShoppingBasketController` injiziert - Purchase-Logik gehört nicht in den ShoppingBasket-Controller.
- **ShoppingBasketController** [Zeilen 156-168]: **shared persistency** : Der ShoppingBasketController nutzt `purchaseService.getPurchaseById()` und greift damit indirekt auf das PurchaseRepository zu.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingService.java**

- **ShoppingService** [Zeile 19]: **layer violation** : Import `thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository` - Zugriff auf Repository eines anderen Packages.
- **ShoppingService** [Zeilen 17-18]: **layer violation** : Imports aus `thkoeln.archilab.ecommerce.solution.purchase.domain` (Purchase, PurchasePosition) - Zugriff auf Domain-Entities eines anderen Packages.
- **ShoppingService** [Zeile 55]: **shared persistency** : `PurchaseRepository` wird im ShoppingService injiziert und in Zeile 309 verwendet (`purchaseRepository.save(purchase)`).

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseService.java**

- **PurchaseService** [Zeilen 11-13]: **layer violation** : Imports aus `thkoeln.archilab.ecommerce.solution.user.application` und `thkoeln.archilab.ecommerce.solution.user.domain` - Zugriff auf Domain und Application eines anderen Packages.
- **PurchaseService** [Zeile 23]: **shared persistency** : `UserService` wird injiziert und `userService.findUserByEmailAddress()` in Zeile 33 aufgerufen, was indirekt auf das UserRepository zugreift.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\application\DepotService.java**

- **DepotService** [Zeilen 10-11]: **layer violation** : Imports aus `thkoeln.archilab.ecommerce.solution.product.application` und `thkoeln.archilab.ecommerce.solution.product.domain` - Zugriff auf Application und Domain eines anderen Packages.
- **DepotService** [Zeile 21]: **shared persistency** : `ProductService` wird injiziert und verwendet (z.B. Zeile 59, 62, 85, 88, etc.), was indirekt Zugriff auf das ProductRepository ermöglicht.

---

## **C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\DepotComparator.java**

- **DepotComparator** [Zeile 4]: **layer violation** : Import `thkoeln.archilab.ecommerce.solution.product.domain.ProductId` - Domain-Klasse im depot-Package referenziert Domain-Klasse aus product-Package.

---

ENDE
Generated by claude-opus-4-5-20251101
-----------------------------------