--- DATE: 13.1.2026, 14:26:44 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
        Architektur: 4-Layer (Eric Evans).
        Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
        Regeln:
        1. Begründe kurz jeden Fund.
        4. Gruppiere nach Datei (mit Pfad). 
        2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
        3. Keine Code-Wiederholung, nur Referenzen.
        5. Wenn fertig, schreibe "ENDE". 
        6. Nutze die Zeilenangaben die mitgeschickt worden sind.



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Address.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Embeddable;
4: import jakarta.persistence.Embedded;
5: import lombok.Getter;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
9: 
10: import java.util.Objects;
11: 
12: @Embeddable
13: @Getter
14: public class Address implements AddressType {
15: 
16:     private final String street;
17:     private final String city;
18:     //@Convert(converter = ZipCodeConverter.class)
19:     @Embedded
20:     private final ZipCode zipCode;
21: 
22: 
23:     public Address(String street, String city, ZipCodeType zipCode) {
24:         this.street = street;
25:         this.city = city;
26:         this.zipCode =(ZipCode) zipCode;
27:     }
28: 
29:     protected Address() {
30:         this.street = null;
31:         this.city = null;
32:         this.zipCode = null;
33:     }
34: 
35: 
36:     /**
37:      * @return the street as a string
38:      */
39:     @Override
40:     public String getStreet() {
41:         return this.street;
42:     }
43: 
44:     /**
45:      * @return the city as a string
46:      */
47:     @Override
48:     public String getCity() {
49:         return this.city;
50:     }
51: 
52:     /**
53:      * @return the zip code
54:      */
55:     @Override
56:     public ZipCodeType getZipCode() {
57:         return this.zipCode;
58:     }
59: 
60:      public static AddressType of( String street, String city, ZipCodeType zipCode ) throws ShopException {
61:          if(street == null || street.isEmpty()) {
62:              throw new ShopException("street is null or empty");
63:          }
64:          if(city == null || city.isEmpty()) {
65:              throw new ShopException("city is null or empty");
66:          }
67:          if(zipCode == null) {
68:              throw new ShopException("zipCode is null");
69:          }
70:          return new Address( street, city, zipCode );
71:      }
72:      @Override
73:      public boolean equals( Object o ) {
74:         if(this == o) { return true; }
75:         if(o == null || getClass() != o.getClass()) { return false; }
76:         Address that = (Address) o;
77:         return street.equals(that.street) && city.equals(that.city) && zipCode.equals(that.zipCode);
78:     }
79:     @Override
80:     public int hashCode() {
81:         return Objects.hash(street, city, zipCode);
82:     }
83: }
84: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\EmailAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import jakarta.persistence.Embeddable;
5: import lombok.Getter;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
8: 
9: import java.util.Objects;
10: 
11: 
12: @Embeddable
13: @Getter
14: public class EmailAddress implements EmailAddressType {
15: 
16:     @JsonProperty("emailAddressString")
17:     private final String emailAddress;
18: 
19:     public EmailAddress(String emailAddress) {
20:         this.emailAddress = emailAddress;
21:     }
22: 
23:     protected EmailAddress() {
24:         this.emailAddress = null;
25:     }
26: 
27:     /**
28:      * @return the email address as a string
29:      */
30:     @Override
31:     public String toString() {
32:         return emailAddress;
33:     }
34: 
35:     @Override
36:     public EmailAddressType sameIdentifyerDifferentDomain(String domainString) throws ShopException {
37:         if(domainString.isEmpty()){
38:             throw new ShopException("Domain is empty");
39:         }
40: 
41:         int j=0;
42:         for (char c : emailAddress.toCharArray()) {
43:             if(c=='@') {
44:                 break;
45:             }
46:             j++;
47:         }
48: 
49:         String tmp=emailAddress.substring(0,j+1).concat(domainString);
50:         //System.out.println("sameIdentifyerDifferentDomain"+tmp);
51:         if(isInvalidEmailAddress(tmp)) {
52:             throw new ShopException("Invalid email address");
53:         }
54:         return new EmailAddress(tmp);
55:     }
56: 
57: 
58:     @Override
59:     public EmailAddressType sameDomainDifferentIdentifyer(String identifyerString) throws ShopException {
60:         int j=0;
61:         for (char c : emailAddress.toCharArray()) {
62:             if(c=='@') {
63:                 break;
64:             }
65:             j++;
66:         }
67: 
68:         String tmp=identifyerString.concat(emailAddress.substring(j));
69:        // System.out.println("sameDomainDifferentIdentifyer"+tmp);
70:         if(isInvalidEmailAddress(tmp)) {
71:             throw new ShopException("Invalid email address");
72:         }
73:         return new EmailAddress(tmp);
74:     }
75: 
76:     public static EmailAddressType of( String emailAddressAsString ) {
77:         if (emailAddressAsString==null || emailAddressAsString.isEmpty()) {
78:             throw new GenericUnprocessableEntityException("email address cannot be null");
79:         }
80:         if (!emailAddressAsString.matches("^[a-zA-Z0-9]+(?:\\.(?!\\.)[a-zA-Z0-9]+)*@[a-zA-Z0-9]+(?:\\.(?!\\.)[a-zA-Z0-9]+)*\\.(?:de|at|ch|com|org)$")) {
81:             throw new GenericUnprocessableEntityException("Invalid email address");
82:         }
83: 
84:         return new EmailAddress(emailAddressAsString);
85:     }
86:     public boolean isInvalidEmailAddress(String emailAddress) {
87:         if (emailAddress == null || emailAddress.isEmpty()) {
88:             return true;
89:         }
90:        // System.out.println("printing email:"+emailAddress);
91:         return !emailAddress.matches("^[a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)*@[a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)*\\.(?:de|at|ch|com|org)$");
92:     }
93: 
94:     @Override
95:     public boolean equals(Object o) {
96:         if (this == o) return true;
97:         if (o == null || getClass() != o.getClass()) return false;
98:         EmailAddress that = (EmailAddress) o;
99:         return emailAddress.equals(that.emailAddress);
100:     }
101: 
102:     @Override
103:     public int hashCode() {
104:         return Objects.hash(emailAddress);
105:     }
106: }
107: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\GenericConflictException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.InsufficientStockException;
6: 
7: 
8: @ResponseStatus(HttpStatus.CONFLICT)
9: public class GenericConflictException extends InsufficientStockException {
10:     public GenericConflictException(String message) {
11:         super(message);
12:     }
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\GenericNotFoundException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code= HttpStatus.NOT_FOUND, reason ="object not found")
8: public class GenericNotFoundException  extends ShopException {
9:     public GenericNotFoundException(String message) {
10:         super(message);
11:     }
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\GenericUnprocessableEntityException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: 
8: @ResponseStatus (value = HttpStatus.UNPROCESSABLE_ENTITY,reason = "Invalid Parameters")
9: public class GenericUnprocessableEntityException extends ShopException {
10:     public GenericUnprocessableEntityException(String message) {
11:         super(message);
12:     }
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\InternalCustomerDto.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import lombok.Getter;
4: import lombok.Setter;
5: import thkoeln.archilab.ecommerce.usecases.CustomerType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
8: 
9: import java.util.Objects;
10: 
11: @Setter
12: @Getter
13: public class InternalCustomerDto implements CustomerType {
14:     private String name;
15:     private AddressType address;
16:     private EmailAddressType email;
17:     public InternalCustomerDto(String name, AddressType address, EmailAddressType email) {
18:         this.name = name;
19:         this.address = address;
20:         this.email = email;
21:     }
22: 
23:     @Override
24:     public String getName() {
25:         return this.name;
26:     }
27: 
28:     @Override
29:     public EmailAddressType getEmailAddress() {
30:         return this.email;
31:     }
32:     @Override
33:     public AddressType getAddress() {
34:         return this.address;
35:     }
36: 
37:     public boolean equals( Object o ) {
38:         if(this == o) { return true; }
39:         if(o == null || getClass() != o.getClass()) { return false; }
40:         InternalCustomerDto that = (InternalCustomerDto) o;
41:         return name.equals(that.name) && email.equals(that.email) && address.equals(that.address);
42:     }
43:     @Override
44:     public int hashCode() {
45:         return Objects.hash(name,email,address);
46:     }
47: }
48: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.Getter;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
7: 
8: import java.util.Objects;
9: 
10: @Embeddable
11: @Getter
12: public class Money implements MoneyType {
13:     private final Float amount;
14:     private final String currencyUnit;
15: 
16:     public Money(Float amount, String currencyUnit) throws ShopException {
17:         if (amount == null || amount < 0) {
18:             throw new ShopException("Amount cannot be negative or Null");
19:         }
20:         if (currencyUnit == null) {
21:             throw new ShopException("CurrencyUnit cannot be null");
22:         }
23:         if (!currencyUnit.equals("EUR") && !currencyUnit.equals("CHF")) {
24:             throw new ShopException("CurrencyUnit must be EUR or CHF");
25:         }
26:         this.amount = amount;
27:         this.currencyUnit = currencyUnit;
28: 
29:     }
30:     protected Money() {
31:         this.amount = null;
32:         this.currencyUnit = null;
33:     }
34: 
35: 
36:     @Override
37:     public Float getAmount() {
38:         return amount;
39:     }
40: 
41:     @Override
42:     public String getCurrencyUnit() {
43:         return currencyUnit;
44:     }
45: 
46:     @Override
47:     public MoneyType add(MoneyType otherMoney) throws ShopException {
48:         if (otherMoney == null  || !Objects.equals(otherMoney.getCurrencyUnit(), this.getCurrencyUnit())) {
49:             throw new ShopException("Cannot add money to " + this.getCurrencyUnit());
50:         }
51:         return new Money(this.amount + otherMoney.getAmount(), this.currencyUnit);
52:     }
53: 
54:     @Override
55:     public MoneyType subtract(MoneyType otherMoney) {
56:         if (otherMoney == null  || !Objects.equals(otherMoney.getCurrencyUnit(), this.getCurrencyUnit())) {
57:             throw new ShopException("Cannot subtract money from " + this.getCurrencyUnit());
58:         }
59:         if (otherMoney.getAmount() > this.getAmount()) {
60:             throw new ShopException("Cannot subtract more money than owned: " + this.getAmount() + ", subtracted amount:" + otherMoney.getAmount());
61:         }
62:         return new Money(this.amount - otherMoney.getAmount(), this.currencyUnit);
63:     }
64: 
65:     @Override
66:     public MoneyType multiplyBy(int factor) {
67:         if (factor < 0) {
68:             throw new ShopException("Cannot multiply money by negative factor");
69:         }
70:         return new Money(this.amount * factor, this.currencyUnit);
71:     }
72: 
73:     @Override
74:     public boolean largerThan(MoneyType otherMoney) {
75:         if (otherMoney == null  || !Objects.equals(otherMoney.getCurrencyUnit(), this.getCurrencyUnit())) {
76:             throw new ShopException("Cannot compare money to " + this.getCurrencyUnit());
77:         }
78: 
79:         return this.amount > otherMoney.getAmount();
80:     }
81: 
82:     public static MoneyType of(Float amount, String currencyUnit) throws ShopException {
83:         return new Money(amount, currencyUnit);
84:     }
85:     @Override
86:     public boolean equals(Object o) {
87:         if (this == o) return true;
88:         if (o == null || getClass() != o.getClass()) return false;
89:         Money money = (Money) o;
90:         return Objects.equals(amount, money.amount) && currencyUnit.equals(money.currencyUnit);
91:     }
92:     @Override
93:     public int hashCode() {
94:         return Objects.hash(amount, currencyUnit);
95:     }
96: 
97: }
98: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import jakarta.persistence.Embeddable;
5: import lombok.Getter;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
8: 
9: import java.util.Objects;
10: 
11: @Embeddable
12: @Getter
13: public class ZipCode implements ZipCodeType {
14:     @JsonProperty("zipCodeString")
15:     private final String zipCode;
16:     public ZipCode(String zipCode) {
17:         this.zipCode = zipCode;
18:     }
19: 
20:     protected ZipCode() {
21:         this.zipCode = null;
22:     }
23: 
24:     @Override
25:     public String toString() {
26:         return zipCode;
27:     }
28: 
29:     @Override
30:     public int difference(ZipCodeType otherZipCode) {
31:         if(otherZipCode==null) {
32:             throw new ShopException("ZipCode cannot be null");
33:         }
34:         String otherZipCodeAsString=otherZipCode.toString();
35:         String thisZipCodeAsString=this.toString();
36: 
37:         if (otherZipCodeAsString.equals(thisZipCodeAsString)) {
38:             return 0;
39:         }
40:         int differentAt=0;
41:         char[] charArray = thisZipCodeAsString.toCharArray();
42: 
43: 
44:         for (int i = 0; i < 5; i++) {
45:             if (thisZipCodeAsString.charAt(i) != otherZipCodeAsString.charAt(i)) {
46:                 differentAt = i + 1;
47:                 break; // Found the first difference, no need to check further
48:             }
49:         }
50:         int x=6;
51:         differentAt =x-differentAt;
52: 
53:         int firstDigitThis = getFirstDigitZipCode();
54:         int firstDigitOther = Character.getNumericValue(otherZipCodeAsString.charAt(0));
55: 
56:         int distanceFirstDigit = 0;
57:         if (firstDigitThis != firstDigitOther) {
58:             int diff = Math.abs(firstDigitOther - firstDigitThis);
59:             distanceFirstDigit = Math.min(diff, 10 - diff);
60:         }
61:         return differentAt + distanceFirstDigit*10;
62:     }
63: 
64:     @Override
65:     public Integer getFirstDigitZipCode() {
66:         return Integer.valueOf(zipCode.substring(0,1));
67:     }
68: 
69: 
70:     public static ZipCodeType of( String zipCodeAsString ) {
71:         if ( zipCodeAsString == null || zipCodeAsString.isEmpty() ) {
72:             throw new ShopException("Zip code is empty");
73:         }
74:         if(!zipCodeAsString.matches("\\d{5}")) {
75:             throw new ShopException("Zip code is not a valid zip code");
76:         }
77:         if(zipCodeAsString.endsWith("0000")) {
78:             throw new ShopException("Zip code ends with a valid zip code");
79:         }
80:         return new ZipCode(zipCodeAsString);
81:     }
82: 
83:     @Override
84:     public boolean equals(Object o) {
85:         if (this == o) return true;
86:         if (o == null || getClass() != o.getClass()) return false;
87:         ZipCode that = (ZipCode) o;
88:         return zipCode.equals(that.zipCode);
89:     }
90: 
91:     @Override
92:     public int hashCode() {
93:         return Objects.hash(zipCode);
94:     }
95: 
96: }
97: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
1: /*
2:  * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.Column;
7: import jakarta.persistence.MappedSuperclass;
8: import lombok.EqualsAndHashCode;
9: import lombok.Getter;
10: import lombok.ToString;
11: 
12: import java.io.Serializable;
13: import java.util.UUID;
14: 
15: @MappedSuperclass
16: @Getter
17: @EqualsAndHashCode(of = "id")
18: @ToString(of = "id")
19: public abstract class GenericId implements Serializable {
20:     @Column(nullable = false, updatable = false)
21:     private final UUID id;
22: 
23:     protected GenericId() {
24:         this( UUID.randomUUID() );
25:     }
26: 
27:     protected GenericId( UUID id ) {
28:         this.id = id;
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
1: /*
2:  * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.AttributeConverter;
7: 
8: import java.util.UUID;
9: import java.util.function.Function;
10: 
11: 
12: public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
13:     private final Function<UUID, T> factory;
14: 
15:     protected GenericIdConverter( Function<UUID, T> factory ) {
16:         this.factory = factory;
17:     }
18: 
19:     @Override
20:     public UUID convertToDatabaseColumn( T attribute ) {
21:         return attribute == null ? null : attribute.getId();
22:     }
23: 
24:     @Override
25:     public T convertToEntityAttribute( UUID dbData ) {
26:         return dbData == null ? null : factory.apply( dbData );
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\InsufficientStockException.java ---
1: /*
2:  * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: /**
7:  * Exception is thrown if the product's stock level is not sufficient to serve the order.
8:  */
9: public class InsufficientStockException extends ShopException {
10:     public InsufficientStockException( String message ) {
11:         super( message );
12:     }
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
1: /*
2:  * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import org.springframework.boot.SpringApplication;
7: import org.springframework.boot.autoconfigure.SpringBootApplication;
8: 
9: 
10: @SpringBootApplication
11: public class ProjectApplication {
12: 
13: 	/**
14: 	 * Entry method
15: 	 * @param args
16: 	 */
17: 	public static void main(String[] args) {
18: 		SpringApplication.run(ProjectApplication.class, args);
19: 	}
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
1: /*
2:  * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: public class ShopException extends RuntimeException {
7:     public ShopException( String message ) {
8:         super( message );
9:     }
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerController.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.application;
2: 
3: 
4: import lombok.extern.slf4j.Slf4j;
5: import org.modelmapper.ModelMapper;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.http.ResponseEntity;
8: import org.springframework.web.bind.annotation.*;
9: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
10: import thkoeln.archilab.ecommerce.domainprimitives.InternalCustomerDto;
11: import org.springframework.http.HttpStatus;
12: import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
13: 
14: import java.util.List;
15: 
16: @Slf4j
17: @RestController
18: @RequestMapping("/customers")
19: public class CustomerController {
20:     private final CustomerRegistrationService customerRegistrationService;
21: 
22:     @Autowired
23:     public CustomerController(CustomerRegistrationService customerRegistrationService) {
24:         this.customerRegistrationService = customerRegistrationService;
25:     }
26:     @GetMapping
27:     public ResponseEntity<List<CustomerDto>> getCustomers() {
28:         return new ResponseEntity<>(null,HttpStatus.METHOD_NOT_ALLOWED);
29:     }
30: 
31:     @GetMapping(params = "emailAddress")
32:     public ResponseEntity<CustomerDto> getCustomerByEmail(@RequestParam("emailAddress") String emailAddress) {
33:         if(emailAddress == null) {
34:             return new ResponseEntity<>(HttpStatus.METHOD_NOT_ALLOWED);
35:         }
36:         EmailAddress email = (EmailAddress) EmailAddress.of(emailAddress);
37:         Customer customer = customerRegistrationService.findByEmail(email);
38:         if (customer == null) {
39:             return new ResponseEntity<>(HttpStatus.NOT_FOUND);
40:         }
41:         ModelMapper modelMapper = new ModelMapper();
42:         CustomerDto customerDto = modelMapper.map(customer, CustomerDto.class);
43:         return new ResponseEntity<>(customerDto, HttpStatus.OK);
44:     }
45: 
46: 
47: }
48: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerDto.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.application;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.domainprimitives.Address;
8: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
9: 
10: import java.util.UUID;
11: 
12: 
13: @AllArgsConstructor
14: @NoArgsConstructor
15: @Setter
16: @Getter
17: public class CustomerDto {
18:     private UUID id;
19:     private String name;
20:     private EmailAddress emailAddress;
21:     private Address address;
22: 
23:     public static CustomerDto fromCustomerDto(CustomerDto customerDto) {
24:         CustomerDto customerDto1 = new CustomerDto();
25:         customerDto1.setId(customerDto.getId());
26:         customerDto1.setName(customerDto.getName());
27:         customerDto1.setEmailAddress(customerDto.getEmailAddress());
28:         customerDto1.setAddress(customerDto.getAddress());
29:         return customerDto1;
30:     }
31: 
32: }
33: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerRegistrationAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.domainprimitives.Address;
6: import thkoeln.archilab.ecommerce.domainprimitives.InternalCustomerDto;
7: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
8: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
9: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
10: import thkoeln.archilab.ecommerce.usecases.CustomerType;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
13: 
14: @Service
15: public class CustomerRegistrationAdapterService implements CustomerRegistrationUseCases {
16: 
17:     private final CustomerRegistrationService customerRegistrationService;
18:     public CustomerRegistrationAdapterService(CustomerRegistrationService customerRegistrationService) {
19:         this.customerRegistrationService = customerRegistrationService;
20:     }
21: 
22:     @Override
23:     public void register(String name, EmailAddressType emailAddress, AddressType address) {
24:         if (name == null || emailAddress == null || address == null) {
25:             throw new ShopException("Name or CustomerEmailAddress or address cannot be null");
26:         }
27:         customerRegistrationService.register(name, emailAddress.toString(), address.getStreet(), address.getCity(), (ZipCode) address.getZipCode());
28:     }
29: 
30:     @Override
31:     public void changeAddress(EmailAddressType customerEmailAddress, AddressType address)throws ShopException {
32:         if (customerEmailAddress == null || address == null) {
33:             throw new ShopException("CustomerEmailAddress or address cannot be null");
34:         }
35:         customerRegistrationService.changeAddress(customerEmailAddress.toString(), address.getStreet(), address.getCity(), (ZipCode) address.getZipCode());
36: 
37:     }
38:     @Override
39:     public CustomerType getCustomerData(EmailAddressType customerEmailAddress)throws ShopException {
40:         String[] data= customerRegistrationService.getCustomerData(customerEmailAddress.toString());
41: 
42:         //Maybe wrap into an If-Statement when i return null, not sure if that branch is ever taken though.
43:         AddressType address = new Address(data[2],data[3],new ZipCode(data[4]));
44:         EmailAddressType email = new EmailAddress(data[1]);
45:         return new InternalCustomerDto(data[0],address,email);
46:     }
47: 
48: 
49: 
50:     @Override
51:     public void deleteAllCustomers() {
52:         customerRegistrationService.deleteAllCustomers();
53:     }
54: }
55: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerRegistrationService.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.application;
2: 
3: import jakarta.transaction.Transactional;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.stereotype.Service;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.domainprimitives.*;
8: import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
9: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
10: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerRepository;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
12: 
13: import java.util.Optional;
14: import java.util.UUID;
15: 
16: @Service
17: public class CustomerRegistrationService {
18: 
19:     private final CustomerRepository customerRepository;
20:     @Autowired
21:     public CustomerRegistrationService(CustomerRepository customerRepository) {
22:         this.customerRepository = customerRepository;
23:     }
24: 
25: 
26:     public void register(String name, String emailAddress, String street, String city, ZipCode zipCode) {
27:         if(areFieldsInvalid(name, emailAddress, street, city, zipCode.toString())) {
28:             throw new GenericUnprocessableEntityException("Invalid Parameterrrrr");
29:         }
30: 
31:         if(!isValidZipCode(zipCode.toString())) {
32:             throw new GenericUnprocessableEntityException("Invalid Zipcode");
33:         }
34:         EmailAddress email = (EmailAddress) EmailAddress.of(emailAddress);
35:         if(customerRepository.findByEmail(email).isPresent()) {
36:             throw new GenericConflictException("Customer already exists");
37:         }
38:         Customer newCustomer = new Customer();
39:         Address address = (Address) Address.of(street,city,zipCode);
40:         CustomerId customerId = new CustomerId(UUID.randomUUID());
41: 
42:         newCustomer.setCustomerId(customerId);
43:         newCustomer.setName(name);
44:         newCustomer.setEmail(email);
45:         newCustomer.setAddress(address);
46:         customerRepository.save(newCustomer);
47:     }
48: 
49: 
50:     public void changeAddress(String customerEmailAddress, String street, String city, ZipCode zipCode) {
51:         if(areFieldsInvalid(customerEmailAddress, street, city, zipCode.toString())) {
52:             throw new GenericUnprocessableEntityException("Invalid Parameter(s)");
53:         }
54:         EmailAddressType email = EmailAddress.of(customerEmailAddress);
55:         Optional<Customer> optionalCustomer = customerRepository.findByEmail(email);
56:         if(optionalCustomer.isPresent()) {
57:             Customer customer = optionalCustomer.get();
58:             Address newAddress = (Address) Address.of(street,city,zipCode);
59:             customer.setAddress(newAddress);
60:             customerRepository.save(customer);
61:         } else {
62:             throw new GenericNotFoundException("Customer with email address " + customerEmailAddress + " does not exist");
63:         }
64: 
65:     }
66: 
67: 
68:     public String[] getCustomerData(String customerEmailAddress) throws ShopException {
69:         EmailAddressType email = EmailAddress.of(customerEmailAddress);
70:         if(customerRepository.findByEmail(email).isPresent()) {
71:             Customer customer=customerRepository.findByEmail(email).get();
72:             Address address = customer.getAddress();
73:             if(address !=null) {
74:                 return new String[]{
75:                         customer.getName(),
76:                         String.valueOf(customer.getEmail()),
77:                         address.getStreet(),
78:                         address.getCity(),
79:                         String.valueOf(address.getZipCode())
80:                 };
81:             } else {
82:                 System.out.println("Are we ever here?");
83:                 return new String[]{
84:                         customer.getName(),
85:                         String.valueOf(customer.getEmail()),
86:                         null,
87:                         null,
88:                         null
89: 
90:                 };
91:             }
92:         } else
93:             throw new GenericNotFoundException("Customer with email address " + customerEmailAddress + " does not exists");
94:     }
95:     public Customer findByEmail(EmailAddress customerEmailAddress) throws ShopException {
96:         if (customerRepository.findByEmail(customerEmailAddress).isPresent()) {
97: 
98:             Customer customer = customerRepository.findByEmail(customerEmailAddress).get();
99:             Address address = customer.getAddress();
100:             if (address != null) {
101:                 return customer;
102: 
103: 
104:             }
105:         }
106:         throw new GenericNotFoundException("Customer with email address " + customerEmailAddress + " does not exists");
107:     }
108:     public Customer findByCustomerId(CustomerId customerId) throws ShopException {
109:        return customerRepository.findByCustomerId(customerId).orElseThrow(()->new GenericNotFoundException("Customer with id " + customerId + " does not exists"));
110:     }
111:     @Transactional
112:     public void deleteAllCustomers() {
113:         customerRepository.deleteAll();
114:     }
115: 
116:     public boolean areFieldsInvalid(String... fields) {
117:         for (String field : fields) {
118:             if (field == null || field.isEmpty()) {
119:                 return true;
120:             }
121:         }
122:         return false;
123:     }
124:     public boolean isValidZipCode(String zipCode) {
125:         return zipCode.matches("\\d{5}");
126:     }
127: }
128: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\Customer.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.domain;
2: 
3: import jakarta.persistence.EmbeddedId;
4: import jakarta.persistence.Entity;
5: import lombok.AccessLevel;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.domainprimitives.Address;
8: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
9: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
10: import thkoeln.archilab.ecommerce.usecases.CustomerType;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
12: 
13: @Entity
14: public class Customer implements CustomerType {
15: 
16:     @Setter(AccessLevel.PRIVATE)
17:     @EmbeddedId
18:     private CustomerId customerId;
19: 
20:     //@Convert(converter = EmailAddressConverter.class)
21:     private EmailAddress email;
22:     private String name;
23: 
24: 
25:     private Address address;
26: 
27:     public Customer() {}
28:     public Customer(CustomerId customerId,EmailAddressType email, String name, Address address) {
29:         this.customerId = customerId;
30:         this.email = (EmailAddress) email;
31:         this.name = name;
32:         this.address = address;
33: 
34: 
35:     }
36:     public CustomerId getCustomerId() { return customerId; }
37:     public void setCustomerId(CustomerId customerId) { this.customerId = customerId; }
38: 
39:     public EmailAddress getEmail() { return email; }
40:     public void setEmail(EmailAddress email) { this.email = email; }
41: 
42:     public String getName() { return name; }
43: 
44:     @Override
45:     public EmailAddressType getEmailAddress() {
46:         return this.email;
47:     }
48: 
49:     public void setName(String name) { this.name = name; }
50: 
51:     public Address getAddress() {
52:         return new Address(address.getStreet(), address.getCity(), address.getZipCode());
53:     }
54:     public void setAddress(Address address) { this.address = address; }
55:     public void updateAddress(String street, String city, ZipCode zipCode) {
56:         this.address = new Address(street,city,zipCode);
57:     }
58: 
59: }
60: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\CustomerId.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: 
13: @Embeddable
14: @NoArgsConstructor(access = AccessLevel.PROTECTED)
15: @AttributeOverride(name = "id", column = @Column(name = "CustomerId"))
16: public class CustomerId extends GenericId {
17:     public CustomerId(UUID customerId) {
18:         super(customerId);
19:     }
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\CustomerIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.domain;
2: 
3: 
4: import jakarta.persistence.Converter;
5: import thkoeln.archilab.ecommerce.GenericIdConverter;
6: 
7: 
8: @Converter(autoApply = true)
9: public class CustomerIdConverter extends GenericIdConverter<CustomerId> {
10:     public CustomerIdConverter() {
11:         super(CustomerId::new);
12:     }
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\CustomerRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.domain;
2: 
3: 
4: import org.springframework.data.jpa.repository.JpaRepository;
5: import org.springframework.stereotype.Repository;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
7: 
8: import java.util.Optional;
9: 
10: @Repository
11: public interface CustomerRepository extends JpaRepository<Customer,CustomerId> {
12:     Optional<Customer> findByEmail(EmailAddressType email);
13:     Optional<Customer> findByCustomerId(CustomerId customerId);
14: }
15: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
6: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
7: import thkoeln.archilab.ecommerce.usecases.OrderUseCases;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
9: 
10: import java.util.HashMap;
11: import java.util.Map;
12: import java.util.UUID;
13: 
14: @Service
15: public class OrderAdapterService implements OrderUseCases {
16: 
17:     private final OrderService orderService;
18:     public OrderAdapterService(OrderService orderService) {
19:         this.orderService = orderService;
20:     }
21: 
22:     @Override
23:     public Map<UUID, Integer> getOrderHistory(EmailAddressType customerEmailAddress) throws ShopException {
24:         if (customerEmailAddress == null) { throw new ShopException("customerEmailAddress is null"); }
25:         Map<ProductId, Integer> orderHistory = orderService.getOrderHistory(customerEmailAddress.toString());
26:         Map<UUID, Integer> newOrderHistory = new HashMap<>();
27:         for (ProductId productId : orderHistory.keySet()) {
28:             newOrderHistory.put(productId.getId(), orderHistory.get(productId));
29:         }
30:         return newOrderHistory;
31:     }
32: 
33:     /**
34:      * @param orderId   - the id of the order to be checked
35:      * @param productId - the id of the product for which we want to know the quantity
36:      * @return the number of products in a given order. If the product is not a part of the order, the method
37:      * returns 0. No exception is thrown.
38:      * @throws ShopException if
39:      *                       - orderId is null, or doesn't exist in the system
40:      *                       - productId is null, or doesn't exist in the system
41:      */
42:     @Override
43:     public Integer getOrderQuantForProduct(UUID orderId, UUID productId) {
44:         if (orderId == null || productId == null) { throw new ShopException("orderId and productId is null"); }
45:         OrderId orderToCheck = new OrderId(orderId);
46:         ProductId productToCheck = new ProductId(productId);
47:         return orderService.getOrderQuantForProduct(orderToCheck, productToCheck);
48:     }
49: 
50:     /**
51:      * @param orderId - the id of the order to be checked
52:      * @return the id of the storage unit that is responsible for the given order
53:      * @throws ShopException if
54:      *                       - orderId is null, or doesn't exist in the system
55:      */
56:     @Override
57:     public UUID getStorageUnitIdForOrder(UUID orderId) {
58:         OrderId orderToCheck = new OrderId(orderId);
59:         return orderService.getStorageUnitIdForOrder(orderToCheck).getId();
60:     }
61: 
62:     @Override
63:     public void deleteAllOrders() {
64: 
65:         orderService.deleteAllOrders();
66:     }
67: }
68: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderDto.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: import lombok.AllArgsConstructor;
3: import lombok.Getter;
4: import lombok.NoArgsConstructor;
5: import lombok.Setter;
6: 
7: import java.util.List;
8: import java.util.UUID;
9: 
10: @AllArgsConstructor
11: @NoArgsConstructor
12: @Setter
13: @Getter
14: public class OrderDto {
15:     private UUID id;
16:     private String customerName;
17:     private UUID storageUnitId;
18:     private List<OrderPartDto> parts;
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderPartDto.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.UUID;
9: 
10: 
11: @AllArgsConstructor
12: @NoArgsConstructor
13: @Setter
14: @Getter
15: public class OrderPartDto {
16:     private UUID productId;
17:     int quantity;
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderQueryService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPart;
5: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPartRepository;
6: import thkoeln.archilab.ecommerce.solution.product.application.ProductUsageInOrdersChecker;
7: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
8: import thkoeln.archilab.ecommerce.solution.product.dto.ReferencedOrderPart;
9: 
10: import java.util.List;
11: import java.util.stream.Collectors;
12: 
13: @Service
14: public class OrderQueryService implements ProductUsageInOrdersChecker {
15: 
16:     private final OrderPartRepository orderPartRepository;
17:     public OrderQueryService(OrderPartRepository orderPartRepository) {
18:         this.orderPartRepository = orderPartRepository;
19:     }
20: 
21:     @Override
22:     public boolean isProductInAnyOrder(Product product) {
23:         return orderPartRepository.existsByProduct(product);
24:     }
25: 
26:     @Override
27:     public List<ReferencedOrderPart> findOrderPartsByProduct(Product product) {
28:         return orderPartRepository.findByProduct(product).stream()
29:                 .map(orderPart ->  new ReferencedOrderPart(orderPart.getProduct().getProductId()))
30:                 .collect(Collectors.toList());
31:     }
32: 
33:     @Override
34:     public void deleteAllOrderParts(Iterable<ReferencedOrderPart> referencedParts) {
35:         List<OrderPart> partsToDelete = orderPartRepository.findAll();
36:         if (!partsToDelete.isEmpty()) {
37:             orderPartRepository.deleteAll(partsToDelete);
38:         }
39:     }
40: }
41: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import jakarta.transaction.Transactional;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.stereotype.Service;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
8: import thkoeln.archilab.ecommerce.domainprimitives.GenericNotFoundException;
9: import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
10: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
11: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerRepository;
12: import thkoeln.archilab.ecommerce.solution.order.domain.*;
13: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
14: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
15: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
17: 
18: import java.util.*;
19: 
20: @Service
21: public class OrderService {
22: 
23: 
24:     private final OrderRepository orderRepository;
25:     private final CustomerRepository customerRepository;
26:     private final OrderPartRepository orderPartRepository;
27: 
28: 
29:     @Autowired
30:     public OrderService(OrderRepository orderRepository, CustomerRepository customerRepository, OrderPartRepository orderPartRepository) {
31:         this.orderRepository = orderRepository;
32:         this.customerRepository = customerRepository;
33:         this.orderPartRepository = orderPartRepository;
34:     }
35:     public Integer getOrderQuantForProduct(OrderId orderId, ProductId productId) {
36:         if (orderId == null || productId == null) {
37:             throw new ShopException("Order id or product id is null");
38:         }
39:         Optional<Order> orderOptional = orderRepository.findById(orderId);
40:         Order order = orderOptional.orElseThrow(() -> new ShopException("Order not found"));
41:         List<OrderPart> orderParts = orderPartRepository.findByOrder(order);
42: 
43:         Optional<OrderPart> orderPartOptional = orderParts.stream()
44:                 .filter(part -> part.getProduct().getProductId().equals(productId))
45:                 .findFirst();
46:         return orderPartOptional.map(OrderPart::getQuantity).orElse(0);
47:     }
48:     public StorageUnitId getStorageUnitIdForOrder(OrderId orderId) {
49:         if (orderId ==null) {
50:             throw new ShopException("OrderId cannot be null");
51:         }
52:         Optional<Order> orderOptional = orderRepository.findById(orderId);
53:         Order order = orderOptional.orElseThrow(() -> new ShopException("Order not found"));
54:         return order.getStorageUnitId();
55:     }
56:     public Map<ProductId,Integer> getOrderHistory( String customerEmailAddress) {
57:         if (customerEmailAddress!= null && !customerEmailAddress.isEmpty()) {
58:             Map<ProductId,Integer> orderHistory = new HashMap<>();
59:             EmailAddressType email = EmailAddress.of(customerEmailAddress);
60:             Optional<Customer> customer = customerRepository.findByEmail(email);
61:             if (customer.isEmpty()) {
62:                 throw new ShopException("Customer not found");
63:             }
64:             CustomerId customerId = customer.get().getCustomerId();
65:             List<Order> orders = orderRepository.findByCustomerId(Optional.ofNullable(customerId));
66: 
67:             if(orders != null && !orders.isEmpty()) {
68:                 for (Order order : orders) {
69:                     List<OrderPart> orderParts=orderPartRepository.findByOrder(order);
70:                     for (OrderPart orderPart : orderParts) {
71:                         ProductId productId=orderPart.getProduct().getProductId();
72:                         int quantitiy=orderPart.getQuantity();
73:                         orderHistory.put(productId, orderHistory.getOrDefault(productId, 0) + quantitiy);
74: 
75:                     }
76:                 }
77:             }
78: 
79:             return orderHistory;
80:         }else
81:             throw new ShopException("The Customer with "+customerEmailAddress+" does not exist");
82: 
83:     }
84:     @Transactional
85:     public void deleteAllOrders() {
86:         orderPartRepository.deleteAll();
87:         orderRepository.deleteAll();
88: 
89:     }
90:     @Transactional
91:     public Order createOrder(CustomerId customerId,StorageUnitId storageUnitId) {
92:         OrderId orderId = new OrderId(UUID.randomUUID());
93:         Order newOrder = new Order(orderId,customerId,storageUnitId);
94:         return orderRepository.save(newOrder);
95:     }
96:     @Transactional
97:     public void addOrderItem(Order order, Product product, int quantity) {
98: 
99:         OrderPart orderPart = new OrderPart();
100:         orderPart.setOrder(order);
101:         orderPart.setProduct(product);
102:         orderPart.setQuantity(quantity);
103:         orderPartRepository.save(orderPart);
104:     }
105:     public List<Order> findOrdersByCustomerId(CustomerId customerId) {
106:         return orderRepository.findByCustomerId(Optional.ofNullable(customerId));
107:     }
108:     public List<OrderPart> findOrderPartsByOrder(Order order) {
109:         return orderPartRepository.findByOrder(order);
110:     }
111:     public Order findByOrderId(OrderId orderId) {
112:         return orderRepository.findById(orderId).orElseThrow(() -> new GenericNotFoundException("Order not found"));
113:     }
114: 
115: 
116: 
117: }
118: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.Column;
4: import jakarta.persistence.EmbeddedId;
5: import jakarta.persistence.Entity;
6: import jakarta.persistence.Table;
7: import lombok.AccessLevel;
8: import lombok.Setter;
9: import thkoeln.archilab.ecommerce.GenericId;
10: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
11: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
12: 
13: @Entity
14: @Table(name="orders")
15: public class Order extends GenericId {
16: 
17:     @Setter(AccessLevel.PRIVATE)
18:     @EmbeddedId
19:     private OrderId orderId;
20: 
21: 
22:     @Column(name="customerId")
23:     private CustomerId customerId;
24: 
25:     @Column(name="storageUnitId")
26:     private StorageUnitId storageUnitId;
27: 
28:     public Order() {}
29:     public Order(OrderId orderId, CustomerId customerId, StorageUnitId storageUnitId) {
30:         super(orderId.getId());
31:         this.orderId = orderId;
32:         this.customerId = customerId;
33:         this.storageUnitId = storageUnitId;
34:     }
35: 
36:     public void setOrderId(OrderId id) {
37:         this.orderId = id;
38:     }
39:     public OrderId getOrderId() {
40:         return orderId;
41:     }
42:     public void setCustomerId(CustomerId customerId) {this.customerId = customerId;}
43:     public CustomerId getCustomer() { return customerId;}
44:     public void setStorageUnitId(StorageUnitId storageUnitId) {this.storageUnitId = storageUnitId;}
45:     public StorageUnitId getStorageUnitId() {return storageUnitId;}
46: }
47: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderId.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "OrderId"))
15: public class OrderId extends GenericId {
16:     public OrderId(UUID id) {
17:         super(id);
18:     }
19: 
20: 
21: }
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class OrderIdConverter extends GenericIdConverter<OrderId> {
8:     public OrderIdConverter() {
9:         super(OrderId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPart.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.AccessLevel;
5: import lombok.Setter;
6: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
7: 
8: 
9: @Entity
10: public class OrderPart {
11: 
12:     @Setter(AccessLevel.PRIVATE)
13:     @EmbeddedId
14:     private OrderPartId orderPartId;
15: 
16:     @ManyToOne
17:     @JoinColumn(name="orderId")
18:     private Order order;
19: 
20: 
21:     @ManyToOne
22:     @JoinColumn(name="productId")
23:     private Product product;
24: 
25:     @Column
26:     private Integer quantity;
27: 
28:     public OrderPart() {
29:         this.orderPartId = new OrderPartId();
30:     }
31:     public OrderPart(Order order, Product product, Integer quantity, OrderPartId orderPartId) {
32:         this.orderPartId = new OrderPartId();
33:         this.order = order;
34:         this.product = product;
35:         this.quantity = quantity;
36:         this.orderPartId = orderPartId;
37:     }
38: 
39:     public OrderPartId getOrderId() {
40:         return orderPartId;
41:     }
42:     public void setOrderId(OrderPartId orderPartId) {
43:         this.orderPartId = orderPartId;
44:     }
45: 
46:     public Order getOrder() {
47:         return order;
48:     }
49:     public void setOrder(Order order) {
50:         this.order = order;
51:     }
52:     public  Product getProduct() {
53:         return product;
54:     }
55:     public void setProduct(Product product) {
56:         this.product = product;
57:     }
58:     public Integer getQuantity() { return quantity;}
59:     public void setQuantity(Integer quantity) {
60:         this.quantity = quantity;
61:     }
62: }
63: 
64: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPartId.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "OrderPartId"))
15: public class OrderPartId extends GenericId {
16:     public OrderPartId(UUID id) {
17:         super(id);
18:     }
19: 
20: 
21: }
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPartIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class OrderPartIdConverter extends GenericIdConverter<OrderPartId> {
8:     public OrderPartIdConverter() {
9:         super(OrderPartId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPartRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
6: 
7: import java.util.List;
8: 
9: @Repository
10: public interface OrderPartRepository extends JpaRepository<OrderPart, OrderPartId> {
11:     List<OrderPart> findByOrder(Order order);
12:     boolean existsByProduct(Product product);
13:     List<OrderPart> findByProduct(Product product);
14: }
15: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: 
4: import org.springframework.data.jpa.repository.JpaRepository;
5: import org.springframework.stereotype.Repository;
6: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
7: 
8: import java.util.List;
9: import java.util.Optional;
10: 
11: @Repository
12: public interface OrderRepository extends JpaRepository<Order, OrderId> {
13:     List<Order> findByCustomerId(Optional<CustomerId> customerId);
14: }
15: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.domainprimitives.Money;
6: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
7: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: 
10: import java.util.UUID;
11: 
12: @Service
13: public class ProductAdapterService implements ProductCatalogUseCases {
14: 
15: 
16:     private final ProductService productService;
17: 
18:     public ProductAdapterService(ProductService productService) {
19:         this.productService = productService;
20:     }
21: 
22:     @Override
23:     public UUID addProductToCatalog(String name, String descriptionOf, Float size, MoneyType buyingPrice, MoneyType sellingPrice) throws ShopException {
24:         if (buyingPrice == null || sellingPrice == null) {
25:             throw new ShopException("buyingPrice or sellingPrice cannot be null");
26:         }
27:         ProductId productId = productService.addProductToCatalog(name, descriptionOf, size, (Money) buyingPrice, (Money) sellingPrice);
28:         return productId.getId();
29:     }
30: 
31:     @Override
32:     public void removeProductFromCatalog(UUID productId) throws ShopException {
33:         if (productId == null) {
34:             throw new ShopException("Invalid productId");
35:         }
36:         ProductId productIdToRemove = new ProductId(productId);
37:         productService.removeProductFromCatalog(productIdToRemove);
38: 
39:     }
40: 
41:     @Override
42:     public MoneyType getSellingPrice(UUID productId) {
43:         if (productId == null) {
44:             throw new ShopException("Invalid productId");
45:         }
46:         ProductId productIdObject = new ProductId(productId);
47:         return new Money(productService.getSellingPrice(productIdObject), "EUR");
48:     }
49: 
50:     @Override
51:     public void deleteProductCatalog() {
52:         productService.deleteProductCatalog();
53:     }
54: 
55: }
56: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductService.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: 
3: import jakarta.transaction.Transactional;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.dao.DataIntegrityViolationException;
6: import org.springframework.stereotype.Service;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.domainprimitives.GenericNotFoundException;
9: import thkoeln.archilab.ecommerce.domainprimitives.Money;
10: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
11: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
12: import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
13: import thkoeln.archilab.ecommerce.solution.product.dto.ReferencedOrderPart;
14: import thkoeln.archilab.ecommerce.solution.product.dto.ReferencedStockLevel;
15: 
16: import java.util.List;
17: import java.util.UUID;
18: 
19: @Service
20: public class ProductService {
21: 
22: 
23:     private final ProductRepository productRepository;
24:     private final ProductUsageInOrdersChecker productUsageInOrdersChecker;
25:     private final ProductUsageInShoppingBasketsChecker productUsageInShoppingBasketsChecker;
26:     private final ProductUsageInStockLevelChecker productUsageInStockLevelChecker;
27:     @Autowired
28:     public ProductService(ProductRepository productRepository, ProductUsageInOrdersChecker productUsageInOrdersChecker,
29:                           ProductUsageInShoppingBasketsChecker productUsageInShoppingBasketsChecker, ProductUsageInStockLevelChecker productUsageInStockLevelChecker) {
30:         this.productRepository = productRepository;
31:         this.productUsageInOrdersChecker = productUsageInOrdersChecker;
32:         this.productUsageInShoppingBasketsChecker = productUsageInShoppingBasketsChecker;
33:         this.productUsageInStockLevelChecker = productUsageInStockLevelChecker;
34:     }
35: 
36: 
37:     @Transactional
38:     public ProductId addProductToCatalog(String name, String descriptionOf, Float size, Money buyingPrice, Money sellingPrice) {
39:         if(name == null || name.isEmpty()) {
40:             throw new ShopException("Name Invalid");
41:         }
42:         if(descriptionOf == null || descriptionOf.isEmpty()) {
43:             throw new ShopException("Description Invalid");
44:         }
45:         if (buyingPrice == null|| buyingPrice.getAmount() <= 0) {
46:             throw new ShopException("Buying Price Invalid");
47:         }
48:         if (sellingPrice == null|| sellingPrice.getAmount() <= 0) {
49:             throw new ShopException("Selling Price Invalid");
50:         }
51:         if(sellingPrice.getAmount() < buyingPrice.getAmount()) {
52:             throw new ShopException("Selling cannot be lower than buying");
53:         }
54:         if(size!=null &&size <=0) {
55:             throw new ShopException("Size Invalid");
56:         }
57:         ProductId productId = new ProductId(UUID.randomUUID());
58:         Product product = new Product();
59: 
60:         product.setProductId(productId);
61:         product.setName(name);
62:         product.setDescription(descriptionOf);
63:         product.setSize(size);
64:         product.setBuyingPrice(buyingPrice);
65:         product.setSellingPrice(sellingPrice);
66: 
67:         try {
68:             Product savedProduct=productRepository.save(product);
69:             return savedProduct.getProductId();
70:         } catch (DataIntegrityViolationException e) {
71:             throw new ShopException("ProductId already exists");
72:         }
73: 
74:     }
75: 
76:     @Transactional
77:     public void removeProductFromCatalog(ProductId productId) {
78:         Product product = productRepository.findById(productId)
79:                 .orElseThrow(() -> new ShopException("Product not found"));
80:         if(productUsageInStockLevelChecker.existsByProductAndQuantityGreaterThan(product,0)) {
81:             throw new ShopException("Product"+productId+" still has stockLevel");
82:         }
83: 
84:         if(productUsageInShoppingBasketsChecker.isProductInAnyShoppingBasket(product)) {
85:             throw new ShopException("Product"+productId+" still has shoppingBasket");
86:         }
87:         if(productUsageInOrdersChecker.isProductInAnyOrder(product)) {
88:             throw new ShopException("Product"+productId+" is still referenced by a completed Order");
89:         }
90:         List<ReferencedOrderPart> referencedParts= productUsageInOrdersChecker.findOrderPartsByProduct(product);
91:         List<ReferencedStockLevel> referencedStock = productUsageInStockLevelChecker.findStockLevelsByProduct(product);
92: 
93:         productUsageInStockLevelChecker.deleteAllStockLevels(referencedStock);
94:         productUsageInOrdersChecker.deleteAllOrderParts(referencedParts);
95:         productRepository.delete(product);
96:     }
97: 
98:     public Float getSellingPrice(ProductId productId) {
99:         Product product = productRepository.findById(productId)
100:                 .orElseThrow(() -> new ShopException("Product not found"));
101:         return product.getSellingPrice().getAmount();
102:     }
103: 
104: 
105:     @Transactional
106:     public void deleteProductCatalog() {
107:         List<Product> allProducts = productRepository.findAll();
108:         for(Product product : allProducts) {
109:             List<ReferencedOrderPart> orderParts = productUsageInOrdersChecker.findOrderPartsByProduct(product);
110:             productUsageInOrdersChecker.deleteAllOrderParts(orderParts);
111:         }
112:         productRepository.deleteAll();
113:     }
114:     public Product findProductById(ProductId productId) {
115:         return productRepository.findById(productId).orElseThrow(()-> new GenericNotFoundException("Product not found"));
116:     }
117: }
118: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductUsageInOrdersChecker.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: 
3: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
4: import thkoeln.archilab.ecommerce.solution.product.dto.ReferencedOrderPart;
5: 
6: import java.util.List;
7: 
8: public interface ProductUsageInOrdersChecker {
9:     boolean isProductInAnyOrder(Product product);
10:     List<ReferencedOrderPart> findOrderPartsByProduct(Product product);
11:     void deleteAllOrderParts(Iterable<ReferencedOrderPart> orderParts);
12: 
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductUsageInShoppingBasketsChecker.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: 
3: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
4: 
5: public interface ProductUsageInShoppingBasketsChecker {
6:     boolean isProductInAnyShoppingBasket(Product product);
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductUsageInStockLevelChecker.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: 
3: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
4: import thkoeln.archilab.ecommerce.solution.product.dto.ReferencedStockLevel;
5: 
6: import java.util.List;
7: 
8: public interface ProductUsageInStockLevelChecker {
9:     boolean existsByProductAndQuantityGreaterThan(Product product, int quantity);
10:     List<ReferencedStockLevel> findStockLevelsByProduct (Product product);
11:     void deleteAllStockLevels(Iterable<ReferencedStockLevel> stockLevels);
12: 
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\Product.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import jakarta.persistence.EmbeddedId;
4: import jakarta.persistence.Entity;
5: import lombok.AccessLevel;
6: import lombok.Getter;
7: import lombok.Setter;
8: import thkoeln.archilab.ecommerce.GenericId;
9: import thkoeln.archilab.ecommerce.domainprimitives.Money;
10: 
11: @Setter
12: @Getter
13: @Entity
14: public class Product extends GenericId {
15: 
16:     @Setter(AccessLevel.PRIVATE)
17:     @EmbeddedId
18:     private ProductId productId;
19: 
20:     private String name;
21:     private String description;
22:     private Float size;
23:     private Money buyingPrice;
24:     private Money sellingPrice;
25: 
26: 
27:     public Product() {}
28:     public Product(ProductId productId,String name, String description, Float size, Money buyingPrice, Money sellingPrice) {
29:         super(productId.getId());
30:         this.productId = productId;
31:         this.name = name;
32:         this.description = description;
33:         this.size = size;
34:         this.buyingPrice = buyingPrice;
35:         this.sellingPrice = sellingPrice;
36: 
37:     }
38:     public void setProductId(ProductId productId) {
39:         this.productId = productId;
40:     }
41:     public void setName(String name) {this.name = name;}
42:     public void setDescription(String description) {this.description = description;}
43:     public void setSize(Float size) {this.size = size;}
44:     public void setBuyingPrice(Money buyingPrice) {this.buyingPrice = buyingPrice;}
45:     public void setSellingPrice(Money sellingPrice) {this.sellingPrice = sellingPrice;}
46: 
47:     public ProductId getProductId() {
48:         return productId;
49:     }
50:     public String getName() { return name; }
51:     public String getDescription() { return description;}
52:     public Float getSize() { return size;}
53:     public Money getBuyingPrice() { return buyingPrice;}
54:     public Money getSellingPrice() { return sellingPrice;}
55: 
56: 
57: }
58: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductId.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "ProductId"))
15: public class ProductId extends GenericId {
16:     public ProductId(UUID id) {
17:         super(id);
18:     }
19: 
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ProductIdConverter extends GenericIdConverter<ProductId> {
8:     public ProductIdConverter() {
9:         super(ProductId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: 
4: import org.springframework.data.jpa.repository.JpaRepository;
5: import org.springframework.stereotype.Repository;
6: 
7: 
8: @Repository
9: public interface ProductRepository extends JpaRepository<Product, ProductId> {
10:     //Optional<Product> findById(ProductId productId);
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\dto\ReferencedOrderPart.java ---
1: package thkoeln.archilab.ecommerce.solution.product.dto;
2: 
3: import lombok.Getter;
4: import lombok.Setter;
5: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
6: 
7: @Setter
8: @Getter
9: public class ReferencedOrderPart {
10:     private ProductId productId;
11: 
12:     public ReferencedOrderPart(ProductId productId) {
13:         this.productId = productId;
14:     }
15: 
16: }
17: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\dto\ReferencedShoppingBasketPart.java ---
1: package thkoeln.archilab.ecommerce.solution.product.dto;
2: 
3: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
4: 
5: public class ReferencedShoppingBasketPart {
6: 
7:     private ProductId productId;
8: 
9:     public ReferencedShoppingBasketPart (ProductId productId) {
10:         this.productId = productId;
11:     }
12:     public ProductId getProductId() {
13:         return productId;
14:     }
15:     public void setProductId(ProductId productId) {
16:         this.productId = productId;
17:     }
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\dto\ReferencedStockLevel.java ---
1: package thkoeln.archilab.ecommerce.solution.product.dto;
2: 
3: import lombok.Getter;
4: import lombok.Setter;
5: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
6: 
7: @Setter
8: @Getter
9: public class ReferencedStockLevel {
10:     private ProductId productId;
11: 
12:     public ReferencedStockLevel(ProductId productId) {
13:         this.productId = productId;
14:     }
15: 
16: }
17: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\AddProductToBasketRequest.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import java.util.UUID;
4: 
5: 
6: public class AddProductToBasketRequest {
7:     private UUID productId;
8:     private Integer quantity;
9: 
10:     public UUID getProductId() {
11:         return productId;
12:     }
13: 
14:     public void setProductId(UUID productId) {
15:         this.productId = productId;
16:     }
17: 
18:     public Integer getQuantity() {
19:         return quantity;
20:     }
21: 
22:     public void setQuantity(Integer quantity) {
23:         this.quantity = quantity;
24:     }
25: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.domainprimitives.Money;
6: import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
7: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
8: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
11: 
12: import java.util.*;
13: 
14: @Service
15: public class ShoppingBasketAdapterService implements ShoppingBasketUseCases {
16: 
17:     private final ShoppingBasketService shoppingBasketService;
18: 
19:     public ShoppingBasketAdapterService(ShoppingBasketService shoppingBasketService) {
20:         this.shoppingBasketService = shoppingBasketService;
21:     }
22: 
23: 
24:     @Override
25:     public void addProductToShoppingBasket(EmailAddressType customerEmailAddress, UUID productId, int quantFor)throws ShopException {
26:         if (customerEmailAddress ==null || productId == null) {
27:             throw new ShopException("CustomerEmailAddress or productId cannot be null");
28:         }
29:         ProductId productIdObj = new ProductId(productId);
30:         shoppingBasketService.addProductToShoppingBasket(customerEmailAddress.toString(), productIdObj, quantFor);
31:     }
32: 
33:     @Override
34:     public void removeProductFromShoppingBasket(EmailAddressType customerEmailAddress, UUID productId, int quantFor) throws ShopException {
35:         if (customerEmailAddress ==null || productId == null) {
36:             throw new ShopException("CustomerEmailAddress or productId cannot be null");
37:         }
38:         ProductId productIdObj = new ProductId(productId);
39:         shoppingBasketService.removeProductFromShoppingBasket(customerEmailAddress.toString(), productIdObj, quantFor);
40:     }
41: 
42:     @Override
43:     public Map<UUID, Integer> getShoppingBasketAsMap(EmailAddressType customerEmailAddress) throws ShopException {
44:         if (customerEmailAddress == null) {
45:             throw new ShopException("CustomerEmailAddress cannot be null");
46:         }
47: 
48:         Map<ProductId, Integer> shoppingBasketAsMap =shoppingBasketService.getShoppingBasketAsMap(customerEmailAddress.toString());
49:         Map<UUID, Integer> newShoppingBasketAsMap = new HashMap<>();
50:         for (ProductId productId : shoppingBasketAsMap.keySet()) {
51:             newShoppingBasketAsMap.put(productId.getId(), shoppingBasketAsMap.get(productId));
52:         }
53:         return newShoppingBasketAsMap;
54:     }
55: 
56:     @Override
57:     public MoneyType getShoppingBasketAsMoneyValue(EmailAddressType customerEmailAddress) throws ShopException {
58:         if (customerEmailAddress == null) {
59:             throw new ShopException("CustomerEmailAddress cannot be null");
60:         }
61:         return new Money(shoppingBasketService.getShoppingBasketAsMoneyValue(customerEmailAddress.toString()), "EUR");
62:     }
63: 
64:     @Override
65:     public Set<UUID> checkout(EmailAddressType customerEmailAddress) throws ShopException {
66:         if (customerEmailAddress == null || customerEmailAddress.toString().isEmpty() ) {
67:             throw new ShopException("CustomerEmailAddress cannot be null");
68:         }
69:         Set<OrderId> orderIds = shoppingBasketService.checkout(customerEmailAddress.toString());
70:         Set<UUID> orderIdSet = new HashSet<>();
71:         for (OrderId orderId : orderIds) {
72:             orderIdSet.add(orderId.getId());
73:         }
74:         return orderIdSet;
75:     }
76: 
77:     @Override
78:     public void emptyAllShoppingBaskets() {
79:         shoppingBasketService.emptyAllShoppingBaskets();
80:     }
81: }
82: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: 
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.http.HttpStatus;
6: import org.springframework.http.ResponseEntity;
7: import org.springframework.web.bind.annotation.*;
8: import thkoeln.archilab.ecommerce.domainprimitives.GenericNotFoundException;
9: import thkoeln.archilab.ecommerce.domainprimitives.GenericUnprocessableEntityException;
10: import thkoeln.archilab.ecommerce.solution.customer.application.CustomerRegistrationService;
11: import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
12: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
13: import thkoeln.archilab.ecommerce.solution.order.application.OrderDto;
14: import thkoeln.archilab.ecommerce.solution.order.application.OrderPartDto;
15: import thkoeln.archilab.ecommerce.solution.order.application.OrderService;
16: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
17: import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
18: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPart;
19: import thkoeln.archilab.ecommerce.solution.product.application.ProductService;
20: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
21: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
22: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
23: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketId;
24: 
25: import java.text.DecimalFormat;
26: import java.text.DecimalFormatSymbols;
27: import java.text.NumberFormat;
28: import java.util.*;
29: import java.util.stream.Collectors;
30: 
31: @RestController
32: @RequestMapping("/shoppingBaskets")
33: public class ShoppingBasketController {
34:     private final ShoppingBasketService shoppingBasketService;
35:     private final CustomerRegistrationService customerRegistrationService;
36:     private final ProductService productService;
37:     private final OrderService orderService;
38: 
39:     @Autowired
40:     public ShoppingBasketController(ShoppingBasketService shoppingBasketService,
41:                                     CustomerRegistrationService customerRegistrationService, ProductService productService, OrderService orderService) {
42:         this.shoppingBasketService = shoppingBasketService;
43:         this.customerRegistrationService = customerRegistrationService;
44:         this.productService = productService;
45:         this.orderService = orderService;
46:     }
47:     @GetMapping
48:     public ResponseEntity<List<ShoppingBasketDto>> getShoppingBaskets() {
49:         return new ResponseEntity<>(null,HttpStatus.METHOD_NOT_ALLOWED);
50:     }
51: 
52:     @GetMapping(params="customerId")
53:     public ResponseEntity<ShoppingBasketDto> getShoppingBasket(
54:             @RequestParam String customerId) {
55:         try {
56:             UUID customerUuid = UUID.fromString(customerId);
57:             CustomerId customerIdDp = new CustomerId(customerUuid);
58:             Customer customer=customerRegistrationService.findByCustomerId(customerIdDp);
59:             ShoppingBasket shoppingBasket = shoppingBasketService.getShoppingBasketForCustomerId(customerUuid).orElseThrow(()-> new GenericNotFoundException("Shopping basket not found"));
60: 
61: 
62:             String customerEmail = customer.getEmail().getEmailAddress();
63:             float totalMoneyValue = shoppingBasketService.getShoppingBasketAsMoneyValue(customerEmail);
64:             Map<ProductId,Integer> basketPartsMap = shoppingBasketService.getShoppingBasketAsMap(customerEmail);
65: 
66:             ShoppingBasketDto shoppingBasketDto = convertToDto(shoppingBasket,totalMoneyValue,basketPartsMap);
67:             return new ResponseEntity<>(shoppingBasketDto, HttpStatus.OK);
68: 
69:         } catch (IllegalArgumentException e) {
70:             return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
71:         }
72: 
73: 
74: 
75:     }
76:     @PostMapping("/{shoppingBasket-Id}/parts")
77:     public ResponseEntity<Void> addProductToShoppingBasket(
78:             @PathVariable("shoppingBasket-Id") UUID shoppingBasketId,
79:             @RequestBody AddProductToBasketRequest request) {
80:         if (request.getProductId()==null || request.getQuantity()==null) {
81:             throw new GenericUnprocessableEntityException("ProductId and quantity are required");
82:         }
83:         ShoppingBasketId basketId = new ShoppingBasketId(shoppingBasketId);
84:         ShoppingBasket shoppingBasket=shoppingBasketService.getShoppingBasketForShoppingBasketId(basketId);
85:         Customer customer = customerRegistrationService.findByCustomerId(shoppingBasket.getCustomerId());
86:         ProductId productId = new ProductId(request.getProductId());
87:         shoppingBasketService.addProductToShoppingBasket(customer.getEmailAddress().toString(),productId,request.getQuantity());
88:         return new ResponseEntity<>(HttpStatus.CREATED);
89:     }
90:     @DeleteMapping("/{shoppingBasket-Id}/parts/{product-Id}")
91:     public ResponseEntity<Void> removeProductFromShoppingBasket(
92:             @PathVariable("shoppingBasket-Id") UUID shoppingBasketId,
93:             @PathVariable("product-Id") UUID productId) {
94:         ShoppingBasketId basketId = new ShoppingBasketId(shoppingBasketId);
95:         ShoppingBasket shoppingBasket = shoppingBasketService.getShoppingBasketForShoppingBasketId(basketId);
96:         Customer customer = customerRegistrationService.findByCustomerId(shoppingBasket.getCustomerId());
97:         ProductId productIdDp = new ProductId(productId);
98:         shoppingBasketService.deleteProductFromShoppingBasket(customer.getEmailAddress().toString(), productIdDp);
99:         return new ResponseEntity<>(HttpStatus.OK);
100:     }
101:     @PostMapping("/{shoppingBasket-Id}/checkout")
102:     public ResponseEntity <List<OrderDto>> checkoutFromShoppingBasket(
103:             @PathVariable("shoppingBasket-Id") UUID shoppingBasketId
104:     ) {
105:         ShoppingBasketId basketId = new ShoppingBasketId(shoppingBasketId);
106:         ShoppingBasket shoppingBasket = shoppingBasketService.getShoppingBasketForShoppingBasketId(basketId);
107:         Customer customer = customerRegistrationService.findByCustomerId(shoppingBasket.getCustomerId());
108:         Set<OrderId> createdOrderIds =shoppingBasketService.checkout(customer.getEmailAddress().toString());
109:         List<OrderDto> orderDtos = new ArrayList<>();
110:         if (createdOrderIds.isEmpty()) {
111:             return new ResponseEntity<>(orderDtos,HttpStatus.NO_CONTENT);
112:         }
113:         for (OrderId orderId: createdOrderIds) {
114:             Order order = orderService.findByOrderId(orderId);
115:             OrderDto orderDto = new OrderDto();
116:             orderDto.setId(order.getOrderId().getId());
117:             orderDto.setCustomerName(customer.getName());
118:             orderDto.setStorageUnitId(order.getStorageUnitId().getId());
119: 
120:             List<OrderPart> orderParts = orderService.findOrderPartsByOrder(order);
121:             List<OrderPartDto> orderPartDtos = orderParts.stream()
122:                     .map(orderPart -> {
123:                                 OrderPartDto partDto = new OrderPartDto();
124:                                 partDto.setProductId(orderPart.getProduct().getProductId().getId());
125:                                 partDto.setQuantity(orderPart.getQuantity());
126:                                 return partDto;
127:                             }).collect(Collectors.toList());
128:             orderDto.setParts(orderPartDtos);
129:             orderDtos.add(orderDto);
130:         }
131:         return new ResponseEntity<>(orderDtos,HttpStatus.CREATED);
132:     }
133: 
134: 
135:     private ShoppingBasketDto convertToDto (ShoppingBasket shoppingBasket, float totalMoneyValue, Map<ProductId,Integer> basketPartsMap) {
136:         if (shoppingBasket == null) {
137:             return null;
138:         }
139:         ShoppingBasketDto dto = new ShoppingBasketDto();
140:         if(shoppingBasket.getShoppingBasketId()!=null) {
141:             dto.setId(shoppingBasket.getShoppingBasketId().getId());
142:         }
143:         if (shoppingBasket.getCustomerId() != null) {
144:             dto.setCustomerId(shoppingBasket.getCustomerId().getId());
145:         }
146:        // NumberFormat currencyFormat = NumberFormat.getCurrencyInstance(Locale.GERMANY);
147:         DecimalFormatSymbols symbols = new DecimalFormatSymbols(Locale.US);
148:         symbols.setGroupingSeparator('\u0000');
149:         symbols.setCurrencySymbol("€");
150:         DecimalFormat decimalFormat = new DecimalFormat("0.00 \u00A4", symbols);
151: 
152: 
153:         String formattedPrice = decimalFormat.format(totalMoneyValue);
154:         //formattedPrice = formattedPrice.replace('\u00A0', ' ');
155:         //formattedPrice = formattedPrice.replace(".",",");
156:         dto.setTotalSellingPrice(formattedPrice);
157:         if (basketPartsMap != null && !basketPartsMap.isEmpty()) {
158:             List<ShoppingBasketPartDto> partDtos = new ArrayList<>();
159:             for (Map.Entry<ProductId, Integer> entry : basketPartsMap.entrySet()) {
160:                 ProductId productId = entry.getKey();
161:                 Integer quantity = entry.getValue();
162: 
163:                 // Not allowed maybe call productService here
164:                 Product product = productService.findProductById(productId);
165: 
166:                 ShoppingBasketPartDto partDto = new ShoppingBasketPartDto();
167:                 if (product != null) {
168:                     partDto.setProductId(product.getProductId().getId());
169:                 } else {
170:                     partDto.setProductId(productId.getId());
171:                     System.err.println("Warning: Product with ID " + productId.getId() + " not found when mapping shopping basket parts.");
172:                 }
173:                 partDto.setQuantity(quantity);
174:                 partDtos.add(partDto);
175:             }
176:             dto.setParts(partDtos);
177:         } else {
178:             dto.setParts(new ArrayList<>());
179:         }
180:         return dto;
181: 
182:     }
183: 
184: }
185: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketDto.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.List;
9: import java.util.UUID;
10: 
11: @AllArgsConstructor
12: @NoArgsConstructor
13: @Setter
14: @Getter
15: public class ShoppingBasketDto {
16:     private UUID id;
17:     private UUID customerId;
18:     private String totalSellingPrice;
19:     private List<ShoppingBasketPartDto> parts;
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketPartDto.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.UUID;
9: 
10: 
11: @AllArgsConstructor
12: @NoArgsConstructor
13: @Setter
14: @Getter
15: public class ShoppingBasketPartDto {
16:     private UUID productId;
17:     private int quantity;
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketQueryService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.stereotype.Service;
4: import org.springframework.transaction.annotation.Transactional;
5: import thkoeln.archilab.ecommerce.solution.product.application.ProductUsageInShoppingBasketsChecker;
6: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
7: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPartRepository;
8: 
9: @Service
10: public class ShoppingBasketQueryService implements ProductUsageInShoppingBasketsChecker {
11:     private final ShoppingBasketPartRepository shoppingBasketPartRepository;
12: 
13:     public ShoppingBasketQueryService ( ShoppingBasketPartRepository shoppingBasketPartRepository) {
14:         this.shoppingBasketPartRepository = shoppingBasketPartRepository;
15:     }
16: 
17:     @Transactional (readOnly = true)
18:     @Override
19:     public boolean isProductInAnyShoppingBasket(Product product) {
20:         return shoppingBasketPartRepository.existsByProduct(product);
21:     }
22: }
23: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import jakarta.transaction.Transactional;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.stereotype.Service;
6: import thkoeln.archilab.ecommerce.InsufficientStockException;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
9: import thkoeln.archilab.ecommerce.domainprimitives.GenericConflictException;
10: import thkoeln.archilab.ecommerce.domainprimitives.GenericNotFoundException;
11: import thkoeln.archilab.ecommerce.domainprimitives.GenericUnprocessableEntityException;
12: import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
13: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
14: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerRepository;
15: import thkoeln.archilab.ecommerce.solution.order.application.OrderService;
16: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
17: import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
18: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
19: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
20: import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
21: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.*;
22: import thkoeln.archilab.ecommerce.solution.storageunit.application.StorageUnitService;
23: import thkoeln.archilab.ecommerce.solution.storageunit.dip.StockLevelQueryDip;
24: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnit;
25: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitComparator;
26: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
27: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
28: 
29: import java.util.*;
30: import java.util.stream.Collectors;
31: 
32: @Service
33: public class ShoppingBasketService {
34: 
35:     private final CustomerRepository customerRepository;
36:     private final ShoppingBasketRepository shoppingBasketRepository;
37:     private final ShoppingBasketPartRepository shoppingBasketPartRepository;
38:     private final ProductRepository productRepository;
39:     private final StorageUnitService storageUnitService;
40:     private final OrderService orderService;
41:     private final StockLevelQueryDip stockLevelQueryDip;
42: 
43: 
44:     @Autowired
45:     public ShoppingBasketService(ShoppingBasketRepository shoppingBasketRepository,  CustomerRepository customerRepository
46:     , ShoppingBasketPartRepository shoppingBasketPartRepository, ProductRepository productRepository, StorageUnitService storageUnitService,
47:                                    OrderService orderService, StockLevelQueryDip stockLevelQueryDip) {
48:         this.shoppingBasketRepository = shoppingBasketRepository;
49:         this.customerRepository = customerRepository;
50:         this.shoppingBasketPartRepository = shoppingBasketPartRepository;
51:         this.productRepository = productRepository;
52:         this.storageUnitService = storageUnitService;
53:         this.orderService = orderService;
54:         this.stockLevelQueryDip = stockLevelQueryDip;
55:     }
56: 
57: 
58:     @Transactional
59:     public void addProductToShoppingBasket(String customerEmailAddress, ProductId productId, int quantFor) {
60:         if(customerEmailAddress == null || customerEmailAddress.isEmpty() || productId == null|| quantFor<0 ) {
61:             throw new GenericUnprocessableEntityException("Invalid Input");
62:         }
63:         ShoppingBasket shoppingBasket = createShoppingBasketForCustomer(customerEmailAddress);
64: 
65:         Optional<ShoppingBasketPart> existingPart = shoppingBasketPartRepository.findByShoppingBasketAndProductId(shoppingBasket, productId);
66: 
67:         Product product = productRepository.findById(productId)
68:                 .orElseThrow(() -> new GenericNotFoundException("Product not found"));
69: 
70:         ShoppingBasketPart part;
71:         if(existingPart.isPresent()) {
72:             part = existingPart.get();
73:             part.setQuantity(part.getQuantity()+quantFor);
74:         } else {
75:             part = new ShoppingBasketPart();
76: 
77:             part.setShoppingBasket(shoppingBasket);
78:             part.setProductId(productId);
79:             part.setProduct(product);
80:             part.setQuantity(quantFor);
81:         }
82:         shoppingBasketPartRepository.save(part);
83: 
84:     }
85: 
86:     @Transactional
87:     public void removeProductFromShoppingBasket(String customerEmailAddress, ProductId productId, int quantFor) {
88:         if(customerEmailAddress == null || customerEmailAddress.isEmpty() || productId == null|| quantFor<0 ) {
89:             throw new GenericUnprocessableEntityException("Invalid Input");
90:         }
91:         ShoppingBasket shoppingBasket = getShoppingBasketForCustomer(customerEmailAddress);
92:         Optional<ShoppingBasketPart> existingPart = shoppingBasketPartRepository.findByShoppingBasketAndProductId(shoppingBasket, productId);
93: 
94: 
95:         if(existingPart.isPresent()) {
96:             ShoppingBasketPart part = existingPart.get();
97:             int currentQuantity = part.getQuantity();
98:             if(currentQuantity >= quantFor) {
99:                     part.setQuantity(currentQuantity-quantFor);
100:                     shoppingBasketPartRepository.save(part);
101:             } else {
102:                 throw new GenericConflictException("Quantity exceeds quant");
103:             }
104:         } else {
105:             throw new GenericNotFoundException("Product not found in Shopping Basket");
106:         }
107:     }
108:     @Transactional
109:     public void deleteProductFromShoppingBasket(String customerEmailAddress, ProductId productId) {
110:         if(customerEmailAddress == null || customerEmailAddress.isEmpty() || productId == null) {
111:             throw new GenericUnprocessableEntityException("Invalid Input");
112:         }
113:         ShoppingBasket shoppingBasket = getShoppingBasketForCustomer(customerEmailAddress);
114:         Optional<ShoppingBasketPart> existingPart = shoppingBasketPartRepository.findByShoppingBasketAndProductId(shoppingBasket, productId);
115:         if(existingPart.isPresent()) {
116:             ShoppingBasketPart partToDelete = existingPart.get();
117:             shoppingBasketPartRepository.delete(partToDelete);
118:         } else {
119:             throw new GenericNotFoundException("Product with ID " + productId.getId() + " not found in the shopping basket of customer " + customerEmailAddress + ".");
120:         }
121: 
122:     }
123: 
124:     @Transactional
125:     public Map<ProductId, Integer> getShoppingBasketAsMap(String customerEmailAddress) {
126:         if(customerEmailAddress == null || customerEmailAddress.isEmpty() ) {
127:             throw new GenericUnprocessableEntityException("Invalid Input");
128:         }
129:             Map<ProductId,Integer> shoppingBasketMap = new HashMap<>();
130: 
131:             ShoppingBasket shoppingBasket = getShoppingBasketForCustomer(customerEmailAddress);
132: 
133:             List<ShoppingBasketPart> shoppingBasketParts = shoppingBasketPartRepository
134:                     .findByShoppingBasket(shoppingBasket);
135:             if (shoppingBasketParts!=null && !shoppingBasketParts.isEmpty()) {
136:                 for (ShoppingBasketPart part : shoppingBasketParts) {
137:                     shoppingBasketMap.put(part.getProduct().getProductId(), part.getQuantity());
138:                 }
139:             }
140:             return shoppingBasketMap;
141:     }
142: 
143:     @Transactional
144:     public float getShoppingBasketAsMoneyValue(String customerEmailAddress) {
145:         ShoppingBasket shoppingBasket = getShoppingBasketForCustomer(customerEmailAddress);
146: 
147:         List<ShoppingBasketPart> shoppingBasketParts = shoppingBasketPartRepository
148:                 .findByShoppingBasket(shoppingBasket);
149:         float shoppingBasketMoneyValue = 0f;
150:         if (shoppingBasketParts!=null && !shoppingBasketParts.isEmpty()) {
151: 
152:             for (ShoppingBasketPart part : shoppingBasketParts) {
153:                 Product product = productRepository.findById(part.getProduct().getProductId())
154:                         .orElseThrow(() -> new GenericNotFoundException("Product not found"));
155:                 float buyingPrice=product.getSellingPrice().getAmount(); // Log product details
156:                 int quantity = part.getQuantity();
157:                 shoppingBasketMoneyValue=shoppingBasketMoneyValue+buyingPrice*quantity;
158:             }
159:         }
160: 
161:         return shoppingBasketMoneyValue;
162:     }
163:     private Customer getCustomer(EmailAddressType email) {
164:         Optional<Customer> emptyOrCustomer = customerRepository.findByEmail(email);
165:         return emptyOrCustomer.orElseThrow(() -> new GenericNotFoundException("Customer not found"));
166: 
167:     }
168:     private Map<ProductId,Integer> getRemainingShoppingBasketParts(List<ShoppingBasketPart> shoppingBasketParts) {
169:         Map<ProductId,Integer> remainingShoppingBasketParts = shoppingBasketParts.stream()
170:                 .collect(Collectors.toMap(
171:                         ShoppingBasketPart::getProductId,
172:                         ShoppingBasketPart::getQuantity
173:                 ));
174:         return remainingShoppingBasketParts;
175:     }
176:     @Transactional
177:     public Set<OrderId> checkout(String customerEmailAddress) {
178:         ShoppingBasket shoppingBasket = getShoppingBasket(customerEmailAddress);
179:         EmailAddressType email = EmailAddress.of(customerEmailAddress);
180:         Customer customer = getCustomer(email);
181: 
182:         List<ShoppingBasketPart> shoppingBasketParts = validateAndGetShoppingBasketParts(shoppingBasket);
183: 
184:         Map<ProductId,Integer> remainingShoppingBasketParts = getRemainingShoppingBasketParts(shoppingBasketParts);
185:         Set<OrderId> orderIds = new HashSet<>();
186:         ZipCodeType customerZipCode = customer.getAddress().getZipCode();
187: 
188:         Set<ProductId> initiallyRequestedProductIds = new HashSet<>(remainingShoppingBasketParts.keySet());
189: 
190:         while (!remainingShoppingBasketParts.isEmpty()) {
191:             StorageUnitComparator comparator = new StorageUnitComparator(remainingShoppingBasketParts, customerZipCode, stockLevelQueryDip);
192:             List<StorageUnit> allStorageUnits = storageUnitService.getAllStorageUnits();
193: 
194:             Optional<StorageUnit> bestStorageUnitOptional = allStorageUnits.stream()
195:                     .filter(unit -> !unit.fulfillableShoppingBasketParts(remainingShoppingBasketParts,stockLevelQueryDip).isEmpty())
196:                     .max(comparator);
197: 
198:             if (bestStorageUnitOptional.isEmpty()) {
199:                 break;
200:             }
201:             StorageUnit bestStorageUnit = bestStorageUnitOptional.get();
202:             Set<ProductId> fulfillableByBestUnit = bestStorageUnit.fulfillableShoppingBasketParts(remainingShoppingBasketParts,stockLevelQueryDip);
203: 
204:             if (fulfillableByBestUnit.isEmpty()) {break;}
205: 
206:             List<ShoppingBasketPart> partsForCurrentOrder = filterParts(shoppingBasketParts,fulfillableByBestUnit,remainingShoppingBasketParts);
207:             if (partsForCurrentOrder.isEmpty()) {break;}
208: 
209:             Order newOrder = orderService.createOrder(customer.getCustomerId(),bestStorageUnit.getStorageUnitId());
210:             orderIds.add(newOrder.getOrderId());
211: 
212:             for (ShoppingBasketPart part : partsForCurrentOrder) {
213:                 orderService.addOrderItem(newOrder,part.getProduct(),part.getQuantity());
214:                 storageUnitService.removeFromStock(bestStorageUnit.getStorageUnitId(),part.getProduct().getProductId(),part.getQuantity());
215:                 remainingShoppingBasketParts.remove(part.getProduct().getProductId());
216:             }
217:         }
218:         Set<ProductId> unfulfillableProductIds = remainingShoppingBasketParts.keySet();
219:         if (!unfulfillableProductIds.isEmpty()) {
220:             deleteUnfulfillableParts(shoppingBasketParts,unfulfillableProductIds);
221:         }
222:         if (orderIds.isEmpty() && !initiallyRequestedProductIds.isEmpty()) {
223:             shoppingBasketRepository.delete(shoppingBasket);
224:             throw new GenericConflictException("No products in the shopping basket could be fulfilled. Basket cleared.");
225:         }
226:         if (!orderIds.isEmpty()) {
227:             deleteFulfillableParts(shoppingBasket,shoppingBasketParts,unfulfillableProductIds);
228: 
229:         }
230: 
231:         return orderIds;
232:     }
233:     private void deleteFulfillableParts (ShoppingBasket shoppingBasket,List<ShoppingBasketPart> shoppingBasketParts,
234:                                          Set<ProductId> unfulfillableProductIds) {
235:         shoppingBasket.setStatus(ShoppingBasketStatus.CHECKED_OUT);
236:         shoppingBasketRepository.save(shoppingBasket);
237:         List<ShoppingBasketPart> fulfilledParts = shoppingBasketParts.stream()
238:                 .filter(part -> !unfulfillableProductIds.contains(part.getProductId()))
239:                 .toList();
240:         shoppingBasketPartRepository.deleteAll(fulfilledParts);
241:     }
242:     private void deleteUnfulfillableParts(List<ShoppingBasketPart> shoppingBasketParts,
243:                                           Set<ProductId> unfulfillableProductIds) {
244:         List<ShoppingBasketPart> partsToRemoveFromBasket = shoppingBasketParts.stream()
245:                 .filter(part -> unfulfillableProductIds.contains(part.getProductId()))
246:                 .toList();
247:         shoppingBasketPartRepository.deleteAll(partsToRemoveFromBasket);
248:     }
249: 
250:     @Transactional
251:     public void emptyAllShoppingBaskets() {
252:         List<ShoppingBasket> allShoppingBaskets = shoppingBasketRepository.findAll();
253: 
254:         for (ShoppingBasket shoppingBasket : allShoppingBaskets) {
255:             List<ShoppingBasketPart> shoppingBasketParts = shoppingBasketPartRepository
256:                     .findByShoppingBasket(shoppingBasket);
257:             shoppingBasketPartRepository.deleteAll(shoppingBasketParts);
258:             shoppingBasketRepository.delete(shoppingBasket);
259:         }
260:         shoppingBasketRepository.deleteAll();
261:     }
262:     public void emptyShoppingBasket(ShoppingBasketId shoppingBasketId) {
263:         shoppingBasketRepository.deleteById(shoppingBasketId);
264:     }
265:     @Transactional
266:     public ShoppingBasket createShoppingBasketForCustomer(String customerEmailAddress) {
267:         EmailAddressType email = EmailAddress.of(customerEmailAddress);
268:         Customer customer = customerRepository.findByEmail(email)
269:                 .orElseThrow(() -> new GenericNotFoundException("Customer not found"));
270:         return shoppingBasketRepository.findByCustomerId(customer.getCustomerId())
271:                 .orElseGet(() -> {
272:                     ShoppingBasketId shoppingBasketId = new ShoppingBasketId(customer.getCustomerId().getId());
273:                     ShoppingBasket newBasket = new ShoppingBasket(shoppingBasketId,customer.getCustomerId(),ShoppingBasketStatus.OPEN);
274:                     newBasket.setShoppingBasketId(shoppingBasketId);
275:                     newBasket.setCustomerId(customer.getCustomerId());
276:                     newBasket.setStatus(ShoppingBasketStatus.OPEN);
277:                     return shoppingBasketRepository.save(newBasket);
278:                 });
279:     }
280:     public ShoppingBasket getShoppingBasketForCustomer(String customerEmailAddress) {
281:         EmailAddressType email = EmailAddress.of(customerEmailAddress);
282:         Customer customer = customerRepository.findByEmail(email)
283:                 .orElseThrow(() -> new GenericNotFoundException("Customer not found"));
284:         return shoppingBasketRepository.findByCustomerId(customer.getCustomerId())
285:                 .orElseThrow(() -> new GenericNotFoundException("Shopping basket not found for customer: " + customerEmailAddress));
286: 
287:     }
288:     public Optional<ShoppingBasket> getShoppingBasketForCustomerId(UUID id) {
289:         CustomerId customerId = new CustomerId(id);
290: 
291:         Optional<ShoppingBasket> shoppingBasketOptional= shoppingBasketRepository.findByCustomerId(customerId);
292:         if(shoppingBasketOptional.isPresent()) {
293:             return shoppingBasketOptional;
294:         } else {
295:             Customer customer = customerRepository.findById(customerId)
296:                     .orElseThrow(() -> new GenericNotFoundException("Customer not found"));
297:             ShoppingBasketId shoppingBasketId = new ShoppingBasketId(customer.getCustomerId().getId());
298:             ShoppingBasket newBasket = new ShoppingBasket(shoppingBasketId,customer.getCustomerId(),ShoppingBasketStatus.OPEN);
299:             return Optional.of(shoppingBasketRepository.save(newBasket));
300: 
301:         }
302:     }
303:     public ShoppingBasket getShoppingBasketForShoppingBasketId(ShoppingBasketId id) {
304:         return shoppingBasketRepository.findByShoppingBasketId(id).orElseThrow(() -> new GenericNotFoundException("No ShoppingBasket found for ShoppingBasketId"));
305:     }
306:     @Transactional
307:     public Optional<Integer> getProductQuantityInShoppingBasket(UUID shoppingBasketUuid, ProductId productId) {
308:         if (shoppingBasketUuid == null || productId == null) {
309:             throw new GenericUnprocessableEntityException("Shopping Basket ID and Product ID cannot be null.");
310:         }
311: 
312:         ShoppingBasketId shoppingBasketId = new ShoppingBasketId(shoppingBasketUuid);
313:         ShoppingBasket shoppingBasket = shoppingBasketRepository.findByShoppingBasketId(shoppingBasketId)
314:                 .orElseThrow(() -> new GenericNotFoundException("Shopping basket not found for ID: " + shoppingBasketUuid));
315: 
316:         Optional<ShoppingBasketPart> part = shoppingBasketPartRepository.findByShoppingBasketAndProductId(shoppingBasket, productId);
317: 
318:         return part.map(ShoppingBasketPart::getQuantity);
319:     }
320:     private List<ShoppingBasketPart> validateAndGetShoppingBasketParts(ShoppingBasket shoppingBasket) {
321:         List<ShoppingBasketPart> shoppingBasketParts = shoppingBasketPartRepository
322:                 .findByShoppingBasket(shoppingBasket);
323:         if(shoppingBasketParts==null || shoppingBasketParts.isEmpty()) {
324:             if (shoppingBasket.getStatus()==ShoppingBasketStatus.CHECKED_OUT) {
325:                 throw new GenericConflictException("Shopping Basket is checked out");
326:             } else throw new GenericNotFoundException("ShoppingBasket is empty");
327:         }
328:         return shoppingBasketParts;
329: 
330:     }
331:     private List<ShoppingBasketPart> filterParts(List<ShoppingBasketPart> shoppingBasketParts,Set<ProductId> productIds,Map<ProductId,Integer> remainingShoppingBasketParts) {
332: 
333:         List<ShoppingBasketPart> partsForCurrentOrder = shoppingBasketParts.stream()
334:                 .filter(shoppingBasketPart -> productIds.contains(shoppingBasketPart.getProductId()))
335:                 .filter(shoppingBasketPart -> remainingShoppingBasketParts.containsKey(shoppingBasketPart.getProductId()))
336:                 .toList();
337:         return partsForCurrentOrder;
338:     }
339:     private ShoppingBasket getShoppingBasket(String customerEmail) {
340:         ShoppingBasket shoppingBasket =getShoppingBasketForCustomer(customerEmail);
341:         if(shoppingBasket == null) {
342:             throw new GenericConflictException("Shopping Basket is Empty");
343:         }
344:         return shoppingBasket;
345: 
346:     }
347: 
348: 
349: 
350: }
351: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.AccessLevel;
5: import lombok.Getter;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.GenericId;
8: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
9: 
10: 
11: @Entity
12: @Setter
13: @Getter
14: public class ShoppingBasket extends GenericId {
15: 
16:     @Setter(AccessLevel.PRIVATE)
17:     @EmbeddedId
18:     private ShoppingBasketId shoppingBasketId;
19: 
20:     @Setter
21:     @Column(name = "customerId")
22:     private CustomerId customerId;
23: 
24:     @Enumerated(EnumType.STRING)
25:     private ShoppingBasketStatus status;
26: 
27: 
28: 
29: 
30:     public ShoppingBasket() {}
31:     public ShoppingBasket(ShoppingBasketId shoppingBasketId, CustomerId customerId, ShoppingBasketStatus status) {
32:         super(shoppingBasketId.getId());
33:         this.shoppingBasketId = shoppingBasketId;
34:         this.customerId = customerId;
35:         this.status = status;
36:     }
37: 
38:     public void setShoppingBasketId(ShoppingBasketId shoppingBasketId) {
39:         this.shoppingBasketId = shoppingBasketId;
40:     }
41: 
42:     public ShoppingBasketId getShoppingBasketId() {
43:         return shoppingBasketId;
44:     }
45: 
46:     public CustomerId getCustomerId() {
47:         return customerId;
48:     }
49: 
50: 
51: }
52: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.Getter;
8: import lombok.NoArgsConstructor;
9: import lombok.Setter;
10: import thkoeln.archilab.ecommerce.GenericId;
11: 
12: import java.util.UUID;
13: 
14: @Getter
15: @Setter
16: @Embeddable
17: @NoArgsConstructor(access = AccessLevel.PUBLIC)
18: @AttributeOverride(name = "id", column = @Column(name = "ShoppingBasketId"))
19: public class ShoppingBasketId extends GenericId {
20:     public ShoppingBasketId(UUID id) {
21:         super(id);
22:     }
23: }
24: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ShoppingBasketIdConverter extends GenericIdConverter<ShoppingBasketId> {
8:     public ShoppingBasketIdConverter() {
9:         super(ShoppingBasketId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPart.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.AccessLevel;
5: import lombok.Getter;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
8: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
9: 
10: 
11: @Entity
12: @Getter
13: @Setter
14: public class ShoppingBasketPart {
15: 
16:     @Setter (AccessLevel.PRIVATE)
17:     @EmbeddedId
18:     private ShoppingBasketPartId shoppingBasketPartId;
19: 
20:     @ManyToOne
21:     @JoinColumn(name = "shoppingBasketId")
22:     private ShoppingBasket shoppingBasket;
23: 
24:     @Embedded
25:     private ProductId productId;
26: 
27:     @OneToOne (fetch = FetchType.EAGER)
28:     @JoinColumn(name="productId", insertable=false, updatable=false)
29:     private Product product;
30: 
31:     @Column
32:     private Integer quantity;
33: 
34: 
35:     public ShoppingBasketPart() {
36:         this.shoppingBasketPartId = new ShoppingBasketPartId();
37:     }
38:     public ShoppingBasketPart(ShoppingBasket shoppingBasket,Product product, ProductId productId, Integer quantity) {
39:         this.shoppingBasketPartId = new ShoppingBasketPartId();
40:         this.product =product;
41:         this.shoppingBasket = shoppingBasket;
42:         this.productId = productId;
43:         this.quantity = quantity;
44: 
45:     }
46: 
47:     public ShoppingBasketPartId getShoppingBasketPartId() {
48:         return shoppingBasketPartId;
49:     }
50:     public ProductId getProductId() {
51:         return productId;
52:     }
53:     public Product getProduct() {
54:         return product;
55:     }
56:     public void setProduct(Product product) {
57:         this.product = product;
58:     }
59:     public void setShoppingBasket(ShoppingBasket shoppingBasket) {
60:         this.shoppingBasket = shoppingBasket;
61:     }
62:     public Integer getQuantity() {
63:         return quantity;
64:     }
65:     public void setQuantity(Integer quantity) {
66:         this.quantity = quantity;
67:     }
68: 
69: 
70: 
71: 
72: }
73: /*    public static class ShoppingBasketPartId implements Serializable {
74:         private ProductId product;
75:         private ShoppingBasketId shoppingBasket;
76: 
77: 
78:         public ShoppingBasketPartId() {}
79:         public ShoppingBasketPartId(ProductId product, ShoppingBasketId shoppingBasket) {
80:             this.product = product;
81:             this.shoppingBasket = shoppingBasket;
82:         }
83: 
84:         @Override
85:         public boolean equals(Object o) {
86:             if (this == o) return true;
87:             if (o == null || getClass() != o.getClass()) return false;
88:             ShoppingBasketPartId that = (ShoppingBasketPartId) o;
89:             if(!product.equals(that.product)) return false;
90:             return shoppingBasket.equals(that.shoppingBasket);
91:         }
92:         @Override
93:         public int hashCode() {
94:             int result = product.hashCode();
95:             result = 31 * result + shoppingBasket.hashCode();
96:             return result;
97:         }
98: */

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPartId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "ShoppingBasketPartId"))
15: public class ShoppingBasketPartId extends GenericId {
16:     public ShoppingBasketPartId(UUID id) {
17:         super(id);
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPartIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: 
4: import jakarta.persistence.Converter;
5: import thkoeln.archilab.ecommerce.GenericIdConverter;
6: 
7: @Converter(autoApply = true)
8: public class ShoppingBasketPartIdConverter extends GenericIdConverter<ShoppingBasketPartId> {
9:     public ShoppingBasketPartIdConverter() {
10:         super (ShoppingBasketPartId::new);
11:     }
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPartRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
6: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
7: 
8: import java.util.List;
9: import java.util.Optional;
10: 
11: @Repository
12: public interface ShoppingBasketPartRepository extends JpaRepository<ShoppingBasketPart, ShoppingBasketPartId> {
13:     boolean existsByProduct(Product product);
14:     List<ShoppingBasketPart> findByShoppingBasket(ShoppingBasket shoppingBasket);
15:     Optional<ShoppingBasketPart> findByShoppingBasketAndProductId(ShoppingBasket shoppingBasket, ProductId productId);
16: 
17: 
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: 
4: import org.springframework.data.jpa.repository.JpaRepository;
5: import org.springframework.stereotype.Repository;
6: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
7: 
8: import java.util.Optional;
9: 
10: @Repository
11: public interface ShoppingBasketRepository extends JpaRepository<ShoppingBasket, ShoppingBasketId> {
12:     Optional<ShoppingBasket> findByCustomerId(CustomerId customerId);
13:     Optional<ShoppingBasket> findByShoppingBasketId(ShoppingBasketId shoppingBasketId);
14: 
15: 
16: 
17: }
18: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketStatus.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: public enum ShoppingBasketStatus {
4:     OPEN,
5:     CHECKED_OUT
6: }
7: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\StockLevelQueryService.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.solution.product.application.ProductUsageInStockLevelChecker;
5: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
6: import thkoeln.archilab.ecommerce.solution.product.dto.ReferencedStockLevel;
7: import thkoeln.archilab.ecommerce.solution.storageunit.dip.StockLevelQueryDip;
8: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StockLevel;
9: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StockLevelRepository;
10: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
11: import thkoeln.archilab.ecommerce.solution.storageunit.dto.StockLevelDto;
12: 
13: import java.util.List;
14: import java.util.stream.Collectors;
15: 
16: @Service
17: public class StockLevelQueryService implements ProductUsageInStockLevelChecker, StockLevelQueryDip {
18:     private final StockLevelRepository stockLevelRepository;
19: 
20:     public StockLevelQueryService(StockLevelRepository stockLevelRepository) {
21:         this.stockLevelRepository = stockLevelRepository;
22:     }
23:     @Override
24:     public boolean existsByProductAndQuantityGreaterThan(Product product, int quantity) {
25:         return stockLevelRepository.existsByProductAndQuantityGreaterThan(product, quantity);
26:     }
27: 
28:     @Override
29:     public List<ReferencedStockLevel> findStockLevelsByProduct(Product product) {
30:         return stockLevelRepository.findByProduct(product).stream()
31:                 .map(stockLevel -> new ReferencedStockLevel(stockLevel.getProduct().getProductId()))
32:                 .collect(Collectors.toList());
33: 
34:     }
35: 
36:     @Override
37:     public void deleteAllStockLevels(Iterable<ReferencedStockLevel> stockLevels) {
38:         List<StockLevel> stockLevelsToDelete = stockLevelRepository.findAll();
39:         if (!stockLevelsToDelete.isEmpty()) {
40:             stockLevelRepository.deleteAll(stockLevelsToDelete);
41:         }
42:     }
43: 
44: 
45:     @Override
46:     public List<StockLevelDto> getStockDataForFulfillment(StorageUnitId storageUnitId) {
47:         return stockLevelRepository.findByStorageUnitStorageUnitId(storageUnitId).stream()
48:                 .map(stockLevel -> new StockLevelDto(
49:                         stockLevel.getProduct().getProductId(),
50:                         stockLevel.getStorageUnit().getStorageUnitId(),
51:                         stockLevel.getQuantity()
52:                 ))
53:                 .collect(Collectors.toList());    }
54: }
55: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\StorageUnitAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
6: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StockLevelRepository;
7: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
8: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
10: 
11: import java.util.UUID;
12: 
13: @Service
14: public class StorageUnitAdapterService implements StorageUnitUseCases {
15: 
16:     private final StorageUnitService storageUnitService;
17:     private final StockLevelRepository stockLevelRepository;
18: 
19:     public StorageUnitAdapterService(StorageUnitService storageUnitService, StockLevelRepository stockLevelRepository) {
20:         this.storageUnitService = storageUnitService;
21:         this.stockLevelRepository = stockLevelRepository;
22:     }
23: 
24: 
25: 
26:     /**
27:      * @param name
28:      * @param address
29:      * @return the id of the new storage unit
30:      * @throws ShopException if ...
31:      *                       - name is null or empty
32:      *                       - address is null
33:      */
34:     @Override
35:     public UUID addNewStorageUnit(String name, AddressType address) {
36:         if (name==null || address==null) {
37:             throw new ShopException("Invalid Parameters");
38:         }
39:         StorageUnitId storageUnitId=storageUnitService.addNewStorageUnit(name,address.getStreet(),address.getCity(),address.getZipCode());
40:         return storageUnitId.getId();
41:     }
42: 
43:     @Override
44:     public void deleteAllStorageUnits() {
45:         stockLevelRepository.deleteAll();
46:         storageUnitService.deleteAllStorageUnits();
47: 
48:     }
49: 
50: 
51: 
52:     @Override
53:     public void addToStock(UUID storageUnitId, UUID productId, int addedQuantFor) throws ShopException {
54:         if (storageUnitId==null || productId==null) {
55:             throw new ShopException("storageUnitId or ProductId cannot be null");
56:         }
57:         StorageUnitId storageToAddTo = new StorageUnitId(storageUnitId);
58:         ProductId stockToAdd = new ProductId(productId);
59:         storageUnitService.addToStock(storageToAddTo, stockToAdd, addedQuantFor);
60:     }
61: 
62:     @Override
63:     public void removeFromStock(UUID storageUnitId, UUID productId, int removedQuantFor) throws ShopException {
64:         if (storageUnitId==null || productId==null) {
65:             throw new ShopException("storageUnitId or ProductId cannot be null");
66:         }
67:         StorageUnitId storageToRemoveFrom = new StorageUnitId(storageUnitId);
68:         ProductId stockToRemove = new ProductId(productId);
69:         storageUnitService.removeFromStock(storageToRemoveFrom, stockToRemove, removedQuantFor);
70: 
71:     }
72: 
73:     @Override
74:     public void changeStockTo(UUID storageUnitId, UUID productId, int newTotalQuantFor) throws ShopException {
75:         if (storageUnitId==null || productId==null) {
76:             throw new ShopException("storageUnitId or ProductId cannot be null");
77:         }
78:         StorageUnitId storageToChangeTo = new StorageUnitId(storageUnitId);
79:         ProductId stockToChange = new ProductId(productId);
80:         storageUnitService.changeStockTo(storageToChangeTo, stockToChange, newTotalQuantFor);
81: 
82:     }
83: 
84:     @Override
85:     public int getAvailableStock(UUID storageUnitId, UUID productId) throws ShopException {
86:         if (storageUnitId==null || productId==null) {
87:             throw new ShopException("storageUnitId or ProductId cannot be null");
88:         }
89:         StorageUnitId storageUnitIdToCheck = new StorageUnitId(storageUnitId);
90:         ProductId stockToCheck = new ProductId(productId);
91:         return storageUnitService.getAvailableStock(storageUnitIdToCheck, stockToCheck);
92:     }
93: }
94: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\StorageUnitService.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.application;
2: 
3: import jakarta.transaction.Transactional;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.stereotype.Service;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.domainprimitives.Address;
8: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
9: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
10: import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
11: import thkoeln.archilab.ecommerce.solution.storageunit.Tuple3;
12: import thkoeln.archilab.ecommerce.solution.storageunit.domain.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
14: 
15: import java.util.List;
16: import java.util.Optional;
17: import java.util.UUID;
18: 
19: @Service
20: public class StorageUnitService {
21: 
22:     private final ProductRepository productRepository;
23:     private final StockLevelRepository stockLevelRepository;
24:     private final StorageUnitRepository storageUnitRepository;
25:     @Autowired
26:     public StorageUnitService(StorageUnitRepository storageUnitRepository, ProductRepository productRepository, StockLevelRepository stockLevelRepository) {
27:         this.storageUnitRepository = storageUnitRepository;
28:         this.productRepository = productRepository;
29:         this.stockLevelRepository = stockLevelRepository;
30:     }
31:     @Transactional
32:     public StorageUnitId addNewStorageUnit(String name, String street, String city, ZipCodeType zipCode) {
33:         if(!areFieldsValid(name,street,city)) {
34:             throw new ShopException("Invalid name or street or city");
35:         }
36:         if(zipCode == null || isInvalidZipCode(zipCode.toString())) {
37:             throw new ShopException("Invalid zip code");
38:         }
39:         StorageUnit storageUnit = new StorageUnit();
40:         StorageUnitId storageUnitId = new StorageUnitId(UUID.randomUUID());
41: 
42:         storageUnit.setStorageUnitId(storageUnitId);
43:         storageUnit.setName(name);
44:         Address address = (Address) Address.of(city,street,zipCode);
45:         storageUnit.setAddress(address);
46: 
47: 
48:         StorageUnit savedStorageUnit = storageUnitRepository.save(storageUnit);
49:         return savedStorageUnit.getStorageUnitId();
50:     }
51:     @Transactional
52:     public void deleteAllStorageUnits() {
53:         stockLevelRepository.deleteAll();
54:         storageUnitRepository.deleteAll();
55:     }
56: 
57: 
58: 
59: 
60:     @Transactional
61:     public void addToStock(StorageUnitId storageUnitId, ProductId productId, int addedQuantFor) {
62:         Tuple3<Product,StorageUnit,Optional<StockLevel>>details= checkParameters(storageUnitId, productId, addedQuantFor);
63:         Product product = details.a;
64:         StorageUnit storageUnit = details.b;
65:         Optional<StockLevel> existingStockLevel=details.c;
66:         if (existingStockLevel.isPresent()) {
67:             StockLevel stockLevel = existingStockLevel.get();
68:             stockLevel.setQuantity(stockLevel.getQuantity() + addedQuantFor);
69:             stockLevelRepository.save(stockLevel);
70:         } else {
71:             createNewStock(product, storageUnit, addedQuantFor);
72:         }
73:     }
74: 
75:     @Transactional
76:     public void removeFromStock(StorageUnitId storageUnitId, ProductId productId, int removedQuantFor) {
77:         Tuple3<Product,StorageUnit,Optional<StockLevel>>details= checkParameters(storageUnitId, productId, removedQuantFor);
78:         //System.out.println("PRINTING DETAILS:"+details);
79:         Optional<StockLevel> existingStockLevel=details.c;
80: 
81: 
82:         if (existingStockLevel.isPresent()) {
83:             StockLevel stockLevel = existingStockLevel.get();
84:             int newQuantity = stockLevel.getQuantity() - removedQuantFor;
85: 
86:             if (newQuantity>=0) {
87:                 stockLevel.setQuantity(newQuantity);
88:                 stockLevelRepository.save(stockLevel);
89:                 return;
90: 
91:             } else {
92:                 throw new ShopException("Insufficient stock for product" + productId + " to remove " + removedQuantFor + " from " + storageUnitId);
93:             }
94:         } else if (removedQuantFor==0) {
95:             Product product = details.a;
96:             StorageUnit storageUnit = details.b;
97:             createNewStock(product, storageUnit, removedQuantFor);
98: 
99:         } else {
100:             throw new ShopException("Cannot remove negative negative quantity from Stock");
101:         }
102:     }
103: 
104:     @Transactional
105:     public void changeStockTo(StorageUnitId storageUnitId, ProductId productId, int newTotalQuantFor) {
106:         Tuple3<Product,StorageUnit,Optional<StockLevel>>details= checkParameters(storageUnitId, productId, newTotalQuantFor);
107:         Product product = details.a;
108:         StorageUnit storageUnit = details.b;
109:         Optional<StockLevel> existingStockLevel=details.c;
110:         if (existingStockLevel.isPresent()) {
111:             StockLevel stockLevel = existingStockLevel.get();
112:             stockLevel.setQuantity(newTotalQuantFor);
113:             stockLevelRepository.save(stockLevel);
114:         } else {
115:             createNewStock(product,storageUnit,newTotalQuantFor);
116:         }
117:     }
118: 
119:     public int getAvailableStock(StorageUnitId storageUnitId, ProductId productId) {
120:         if (storageUnitId == null) { throw new ShopException("Storage unit id is null"); }
121:         if (productId == null) { throw new ShopException("Product id is null"); }
122:         StorageUnit storageUnit = storageUnitRepository.findById(storageUnitId)
123:                 .orElseThrow(() -> new ShopException("Storage unit not found"));
124: 
125:         Product product = productRepository.findById(productId)
126:                 .orElseThrow(() -> new ShopException("Product not found"));
127: 
128:         Optional<StockLevel> existingStockLevel = stockLevelRepository.findByProductAndStorageUnit(product, storageUnit);
129:         return existingStockLevel.map(StockLevel::getQuantity).orElse(0);
130: 
131:     }
132: 
133: 
134: 
135:     public boolean areFieldsValid(String... fields) {
136:         for (String field : fields) {
137:             if (field == null || field.isEmpty()) {
138:                 return false;
139:             }
140:         }
141:         return true;
142:     }
143:     public boolean isInvalidZipCode(String zipCode) {
144:         return !zipCode.matches("\\d{5}");
145:     }
146: 
147:     public Tuple3<Product,StorageUnit,Optional<StockLevel>>
148:     checkParameters (StorageUnitId storageUnitId, ProductId productId, int quant) {
149: 
150:         if (storageUnitId == null) { throw new ShopException("Storage unit id is null"); }
151:         if (productId == null) { throw new ShopException("Product id is null"); }
152:         if (quant < 0) { throw new ShopException("Quant is less than zero"); }
153:         StorageUnit storageUnit = storageUnitRepository.findById(storageUnitId)
154:                 .orElseThrow(() -> new ShopException("Storage unit not found"));
155: 
156:         Product product = productRepository.findById(productId)
157:                 .orElseThrow(() -> new ShopException("Product not found"));
158: 
159:         Optional<StockLevel> existingStockLevel = stockLevelRepository.findByProductAndStorageUnit(product, storageUnit);
160:         return Tuple3.of(product, storageUnit, existingStockLevel);
161:     }
162:     @Transactional
163:     public void createNewStock(Product product, StorageUnit storageUnit, int quantity) {
164:         StockLevel newStockLevel = new StockLevel();
165:         StockLevelId newStockLevelId = new StockLevelId(UUID.randomUUID());
166: 
167:         newStockLevel.setStockLevelId(newStockLevelId);
168:         newStockLevel.setProduct(product);
169:         newStockLevel.setStorageUnit(storageUnit);
170:         newStockLevel.setQuantity(quantity);
171:         stockLevelRepository.save(newStockLevel);
172:     }
173:     public List<StorageUnit> getAllStorageUnits () {
174:         //DEBUG
175:        /* List<StorageUnit> storageUnits = storageUnitRepository.findAll();
176:         int i =0;
177:         for (StorageUnit storageUnit : storageUnits) {
178:             i++;
179:             //System.out.println("StorageUnit"+i+storageUnit);
180:         }*/
181:         return storageUnitRepository.findAll();
182: 
183:     }
184:     public Optional<StorageUnit> findStorageUnitById(StorageUnitId storageUnitId) {
185:         return storageUnitRepository.findById(storageUnitId);
186:     }
187: 
188: 
189: }
190: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\dip\StockLevelQueryDip.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.dip;
2: 
3: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
4: import thkoeln.archilab.ecommerce.solution.storageunit.dto.StockLevelDto;
5: 
6: import java.util.List;
7: 
8: public interface StockLevelQueryDip {
9:     List<StockLevelDto> getStockDataForFulfillment(StorageUnitId storageUnitId);
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StockLevel.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import jakarta.persistence.EmbeddedId;
4: import jakarta.persistence.Entity;
5: import jakarta.persistence.JoinColumn;
6: import jakarta.persistence.ManyToOne;
7: import lombok.AccessLevel;
8: import lombok.Setter;
9: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
10: 
11: 
12: @Entity
13: public class StockLevel {
14: 
15:     @Setter(AccessLevel.PRIVATE)
16:     @EmbeddedId
17:     private StockLevelId stockLevelId;
18: 
19:     @ManyToOne
20:     @JoinColumn(name = "productId")
21:     private Product product;
22: 
23:     @ManyToOne
24:     @JoinColumn(name="storageUnitId")
25:     private StorageUnit storageUnit;
26: 
27:     private int quantity;
28: 
29:     public StockLevel() {}
30:     public StockLevel(StockLevelId stockLevelId, Product product, StorageUnit storageUnit, int quantity) {
31:         this.stockLevelId = stockLevelId;
32:         this.product = product;
33:         this.storageUnit = storageUnit;
34:         this.quantity = quantity;
35: 
36:     }
37: 
38: 
39:     public StockLevelId getStockLevelId() { return this.stockLevelId; }
40:     public Product getProduct() { return this.product; }
41:     public int getQuantity() { return this.quantity; }
42:     public StorageUnit getStorageUnit() { return this.storageUnit; }
43: 
44: 
45:     public void setStockLevelId(StockLevelId stockLevelId) { this.stockLevelId = stockLevelId; }
46:     public void setProduct(Product product) { this.product = product; }
47:     public void setQuantity(int quantity) { this.quantity = quantity; }
48:     public void setStorageUnit(StorageUnit storageUnit) { this.storageUnit = storageUnit; }
49: }
50: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StockLevelId.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "StockLevelId"))
15: public class StockLevelId extends GenericId {
16:     public StockLevelId(UUID id) {
17:         super(id);
18:     }
19: 
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StockLevelIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class StockLevelIdConverter extends GenericIdConverter<StockLevelId> {
8:     public StockLevelIdConverter() {
9:         super(StockLevelId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StockLevelRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
6: 
7: import java.util.List;
8: import java.util.Optional;
9: 
10: @Repository
11: public interface StockLevelRepository extends JpaRepository<StockLevel, StockLevelId> {
12:     boolean existsByProductAndQuantityGreaterThan(Product product, int quantity);
13:     List<StockLevel> findByProduct(Product product);
14:     List<StockLevel> findByStorageUnitStorageUnitId(StorageUnitId storageUnitId);
15:     Optional<StockLevel> findByProductAndStorageUnit(Product product, StorageUnit storageUnit);
16: 
17: }
18: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnit.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import jakarta.persistence.EmbeddedId;
4: import jakarta.persistence.Entity;
5: import lombok.AccessLevel;
6: import lombok.Setter;
7: import org.springframework.beans.factory.annotation.Autowired;
8: import org.springframework.stereotype.Component;
9: import thkoeln.archilab.ecommerce.domainprimitives.Address;
10: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
11: import thkoeln.archilab.ecommerce.solution.storageunit.dip.StockLevelQueryDip;
12: import thkoeln.archilab.ecommerce.solution.storageunit.dto.StockLevelDto;
13: 
14: import java.util.*;
15: 
16: 
17: @Entity
18: @Component
19: public class StorageUnit {
20: 
21:     @Setter(AccessLevel.PRIVATE)
22:     @EmbeddedId
23:     private StorageUnitId storageUnitId;
24: 
25:     private String name;
26:     private Address address;
27: 
28: 
29:     public StorageUnit() {}
30:     public StorageUnit(StorageUnitId storageUnitId,String name, Address address) {
31:         this.storageUnitId = storageUnitId;
32:         this.name = name;
33:         this.address = address;
34:     }
35:     public StorageUnitId getStorageUnitId() { return storageUnitId; }
36:     public String getName() { return name; }
37:     public Address getAddress() { return address; }
38: 
39: 
40:     public void setStorageUnitId(StorageUnitId storageUnitId) { this.storageUnitId = storageUnitId; }
41:     public void setName(String name) { this.name = name; }
42:     public void setAddress(Address address) { this.address = address; }
43: 
44: 
45: 
46:     public Set<ProductId> fulfillableShoppingBasketParts(Map<ProductId, Integer> productQuantityMap,
47:                                                          StockLevelQueryDip stockLevelQueryDip) {
48: 
49: 
50:         List<StockLevelDto> currentStockData= stockLevelQueryDip.getStockDataForFulfillment(this.getStorageUnitId());
51:         StorageUnitId x =this.storageUnitId;
52:         Set<ProductId> fulfillableShoppingBasketProducts = new HashSet<>();
53:         for (Map.Entry<ProductId, Integer> entry : productQuantityMap.entrySet()) {
54:             ProductId productId = entry.getKey();
55:             Integer quantity = entry.getValue();
56:             Optional<StockLevelDto> optionalStockLevelDto = currentStockData.stream()
57:                     .filter(stockData -> stockData.getProductId().equals(productId))
58:                     .findFirst();
59:             if (optionalStockLevelDto.isPresent()) {
60:                 StockLevelDto stockLevel = optionalStockLevelDto.get();
61:                 if(stockLevel.getQuantity() >= quantity) {
62:                     fulfillableShoppingBasketProducts.add(productId);
63:                 }
64:             }
65:         }
66:         return fulfillableShoppingBasketProducts;
67:     }
68: }
69: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitComparator.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
4: import thkoeln.archilab.ecommerce.solution.storageunit.dip.StockLevelQueryDip;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
6: 
7: import java.util.Comparator;
8: import java.util.Map;
9: 
10: public class StorageUnitComparator implements Comparator<StorageUnit> {
11: 
12:     private final Map<ProductId,Integer> productQuantityMap;
13:     private final ZipCodeType customerZipCode;
14:     private final StockLevelQueryDip stockLevelQueryDip;
15: 
16:     public StorageUnitComparator(Map<ProductId,Integer> productQuantityMap, ZipCodeType customerZipCode,
17:                                  StockLevelQueryDip stockLevelQueryDip) {
18:         this.productQuantityMap = productQuantityMap;
19:         this.customerZipCode = customerZipCode;
20:         this.stockLevelQueryDip = stockLevelQueryDip;
21:     }
22: 
23:     @Override
24:     public int compare(StorageUnit unitA, StorageUnit unitB) {
25:         int fulfillableCount1 = unitA.fulfillableShoppingBasketParts(productQuantityMap,stockLevelQueryDip).size();
26:         int fulfillableCount2 = unitB.fulfillableShoppingBasketParts(productQuantityMap,stockLevelQueryDip).size();
27: 
28:         int fulfillableComparison = Integer.compare(fulfillableCount1, fulfillableCount2);
29:         if (fulfillableComparison != 0) {
30:            // System.out.println(fulfillableCount1 +"\n"+ fulfillableCount2);
31:             return fulfillableComparison;
32:         }
33:         int distance1 = customerZipCode.difference(unitA.getAddress().getZipCode());
34:         int distance2 = customerZipCode.difference(unitB.getAddress().getZipCode());
35: 
36:         //System.out.println(Integer.compare(distance2, distance1));
37:         return Integer.compare(distance2, distance1);
38: 
39:     }
40: }
41: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitId.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "StorageUnitId"))
15: public class StorageUnitId extends GenericId {
16:     public StorageUnitId(UUID id) {
17:         super(id);
18:     }
19: 
20: }
21: 
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class StorageUnitIdConverter extends GenericIdConverter<StorageUnitId> {
8:     public StorageUnitIdConverter() {
9:         super(StorageUnitId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.domain;
2: 
3: 
4: import org.springframework.data.jpa.repository.JpaRepository;
5: import org.springframework.stereotype.Repository;
6: 
7: 
8: @Repository
9: public interface StorageUnitRepository extends JpaRepository<StorageUnit, StorageUnitId> {
10: 
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\dto\StockLevelDto.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit.dto;
2: 
3: import lombok.Getter;
4: import lombok.Setter;
5: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
6: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
7: 
8: @Getter
9: @Setter
10: public class StockLevelDto {
11:     private ProductId productId;
12:     private StorageUnitId storageUnitId;
13:     private int quantity;
14:     public StockLevelDto(ProductId productId, StorageUnitId storageUnitId, int quantity) {
15:         this.productId = productId;
16:         this.storageUnitId = storageUnitId;
17:         this.quantity = quantity;
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\Tuple3.java ---
1: package thkoeln.archilab.ecommerce.solution.storageunit;
2: 
3: import java.util.Objects;
4: 
5: public class Tuple3<A, B, C> {
6:     public final A a;
7:     public final B b;
8:     public final C c;
9: 
10:     public Tuple3(A item1, B item2, C item3) {
11:         this.a = item1;
12:         this.b = item2;
13:         this.c = item3;
14:     }
15: 
16:     public static <A, B, C> Tuple3<A, B, C> of(A a, B b, C c) {
17:         return new Tuple3<>(a, b, c);
18:     }
19: 
20:     @Override
21:     public boolean equals(Object obj) {
22:         if (this == obj) return true;
23:         if (obj == null || getClass() != obj.getClass()) return false;
24:         Tuple3<?, ?, ?> other = (Tuple3<?, ?, ?>) obj;
25:         return Objects.equals(a, other.a) && Objects.equals(b, other.b) && Objects.equals(c, other.c);
26:     }
27: 
28:     @Override
29:     public int hashCode() {
30:         return Objects.hash(a, b, c);
31:     }
32: 
33:     @Override
34:     public String toString() {
35:         return "(" + a + ", " + b + ", " + c + ")";
36:     }
37: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\CustomerRegistrationUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
10: 
11: /**
12:  * This interface contains methods needed in the context of use cases concerning the registration of a customer.
13:  * The interface is probably incomplete, and will grow over time ...
14:  */
15: public interface CustomerRegistrationUseCases {
16:     /**
17:      * Registers a new customer
18:      *
19:      * @param name
20:      * @param emailAddress
21:      * @param address
22:      * @throws ShopException if ...
23:      *      - the customer with the given email address already exists
24:      *      - address is null
25:      */
26:     public void register( String name, EmailAddressType emailAddress, AddressType address );
27: 
28: 
29:     /**
30:      * Changes the address of a customer
31:      *
32:      * @param customerEmailAddress
33:      * @param customerEmailAddress
34:      * @param address
35:      * @throws ShopException if ...
36:      *      - the customer with the given email address does not exist,
37:      *      - address is null
38:      */
39:     public void changeAddress( EmailAddressType customerEmailAddress,
40:                                AddressType address );
41: 
42: 
43:     /**
44:      * Returns the data of a customer as an array of strings (name, emailAddress, street, city, zipCode)
45:      * @param customerEmailAddress
46:      * @return the customer data
47:      * @throws ShopException the customer with the given email address does not exist,
48:      */
49:     public CustomerType getCustomerData( EmailAddressType customerEmailAddress );
50: 
51: 
52: 
53:     /**
54:      * Clears all customers, including all orders and shopping baskets
55:      */
56:     public void deleteAllCustomers();
57: }
58: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\CustomerType.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
5: 
6: /**
7:  * This interface expresses the essence of a shop customer
8:  */
9: public interface CustomerType {
10:     String getName();
11:     EmailAddressType getEmailAddress();
12:     AddressType getAddress();
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\AddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface AddressType {
6:     /**
7:      * @return the street as a string
8:      */
9:     public String getStreet();
10: 
11:     /**
12:      * @return the city as a string
13:      */
14:     public String getCity();
15: 
16:     /**
17:      * @return the zip code
18:      */
19:     public ZipCodeType getZipCode();
20: 
21:     /**
22:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
23:      * implementing class to provide a static factory method (simply named "of(...)"),
24:      * which creates an zip code, given as a string.
25:      * We specify this factory method here as a comment, using the Javadoc documentation style.
26:      *
27:      * @param street the street as a string
28:      * @param city the city as a string
29:      * @param zipCode the zip code
30:      * @return the address object matching the parameters
31:      * @throws ShopException if ...
32:      *      - street is null or empty
33:      *      - city is null or empty
34:      *      - zipCode is null
35:      */
36:      // public static AddressType of( String street, String city, ZipCodeType zipCode );
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\EmailAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface EmailAddressType {
6:     /**
7:      * @return the email address as a string
8:      */
9:     public String toString();
10: 
11: 
12:     /**
13:      * A special kind of "copy constructor": Returns a new email address object with
14:      * the same identifyer (the substring left of the "@" sign) as the current one, but
15:      * with a new domain substring (right of the "@" sign).
16:      * @param domainString - the new domain for the copied email address
17:      * @return the new email address
18:      * @throws ShopException if ...
19:      *     - domainString is null
20:      *     - the new email address would not be valid (see `of(...)` method)
21:      */
22:     public EmailAddressType sameIdentifyerDifferentDomain( String domainString );
23: 
24:     /**
25:      * Another special kind of "copy constructor": Returns a new email address object
26:      * with the same domain (the substring right of the "@" sign) as the current one, but
27:      * with a new identifyer substring (left of the "@" sign).
28:      * @param identifyerString - the new identifyer for the copied email address
29:      * @return the new email address
30:      * @throws ShopException if ...
31:      *     - identifyerString is null
32:      *     - the new email address would not be valid (see `of(...)` method)
33:      */
34:     public EmailAddressType sameDomainDifferentIdentifyer( String identifyerString );
35: 
36: 
37:     /**
38:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
39:      * implementing class to provide a static factory method (simply named "of(...)"),
40:      * which creates an email address, given as a string.
41:      * We specify this factory method here as a comment, using the Javadoc documentation style.
42:      *
43:      * @param emailAddressAsString - the email address as a string.
44:      *      We will use a much simplified validation method to check if the email address is valid:
45:      *      - it must contain exactly one '@' character.
46:      *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
47:      *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
48:      *      - the substrings before and after the '@' may contain one or several '.' as separators
49:      *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
50:      *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
51:      *        (for simplicity we do not allow any other domains)
52:      * @return a new EmailAddressType object matching the given email address
53:      * @throws ShopException if ...
54:      *      - emailAddressAsString is null
55:      *      - emailAddressAsString is not a valid email address (see above)
56:      */
57:      // public static EmailAddressType of( String emailAddressAsString );
58: }
59: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MoneyType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface MoneyType {
6:     /**
7:      * @return the amount of money
8:      */
9:     public Float getAmount();
10: 
11: 
12:     /**
13:      * @return the currency unit of the money
14:      */
15:     public String getCurrencyUnit();
16: 
17: 
18:     /**
19:      * @param otherMoney
20:      * @return this + otherMoney, as a new object
21:      * @throws ShopException if ...
22:      *      - otherMoney is null
23:      *      - otherMoney.currencyUnit != this.currencyUnit
24:      */
25:     public MoneyType add( MoneyType otherMoney );
26: 
27: 
28:     /**
29:      * @param otherMoney
30:      * @return this - otherMoney, as a new object
31:      * @throws ShopException if ...
32:      *      - otherMoney is null
33:      *      - otherMoney.currencyUnit != this.currencyUnit
34:      *      - otherMoney > this
35:      */
36:     public MoneyType subtract( MoneyType otherMoney );
37: 
38: 
39:     /**
40:      * @param factor
41:      * @return this * factor, as a new object
42:      * @throws ShopException if ...
43:      *     - factor < 0
44:      */
45:     public MoneyType multiplyBy( int factor );
46: 
47:     /**
48:      * @param otherMoney
49:      * @return true, if this > otherMoney
50:      * @throws ShopException if ...
51:      *      - otherMoney is null
52:      *      - otherMoney.currencyUnit != this.currencyUnit
53:      */
54:     public boolean largerThan( MoneyType otherMoney );
55: 
56: 
57:     /**
58:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
59:      * implementing class to provide a static factory method (simply named "of(...)"),
60:      * which creates a money object from an amount and a currency unit (as string).
61:      * We specify this factory method here as a comment, using the Javadoc documentation style.
62:      *
63:      * @param amount the amount of money (must be >= 0)
64:      * @param currencyUnit the currency unit of the money (allowed values: "EUR", "CHF")
65:      * @return a new Money object with the given amount and currency unit
66:      * @throws ShopException if ...
67:      *   - amount is null
68:      *   - amount < 0
69:      *   - currency unit is null
70:      *   - currency unit is not one of the allowed values
71:      */
72:      // public static MoneyType of( Float amount, String currencyUnit );
73: }
74: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\ZipCodeType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnore;
4: import thkoeln.archilab.ecommerce.ShopException;
5: 
6: public interface ZipCodeType {
7:     /**
8:      * @return the zip code as a string
9:      */
10:     public String toString();
11: 
12:     /**
13:      * You will need some idea of "imprecise difference" between two zip codes for properly
14:      * implementing storage units in your shopping platform. This method calculates such a
15:      * difference. You can decide for yourself what values you return, unless you comply
16:      * with the following rules.
17:      * - The return value is 0 if both zip codes are the same
18:      * - If not:
19:      *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
20:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
21:      *        So, 56733 and 56734 have the same difference as 56733 and 56739.
22:      *      - The difference grows if more digits (counted from the right side) differ.
23:      *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
24:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
25:      *        53876 and 54876 have the same difference as 53876 and 57261.
26:      *      - However, the difference between 5abcd and 6rstu must be smaller than the one
27:      *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
28:      *        one between 5abcd and 9rstu.
29:      *      - This last condition reflects the fact the first digits of a zip code marks a region
30:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
31:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
32:      *        other.
33:      * @param otherZipCode
34:      * @return the calculated difference
35:      * @throws ShopException if otherZipCode is null
36:      */
37:     public int difference( ZipCodeType otherZipCode );
38: 
39: 
40:     /**
41:      * For the currently used way of deciding on the best fitting storage unit for a order,
42:      * we need to know the first digit of the zip code.
43:      */
44:     @JsonIgnore
45:     public Integer getFirstDigitZipCode();
46: 
47: 
48:     /**
49:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
50:      * implementing class to provide a static factory method (simply named "of(...)"),
51:      * which creates an zip code, given as a string.
52:      * We specify this factory method here as a comment, using the Javadoc documentation style.
53:      *
54:      * @param zipCodeAsString - the zip code as a string.
55:      *      We will use a much simplified validation method to check if the zip code is valid:
56:      *      - It must contain exactly 5 digits.
57:      *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid zip code, but 20001 is valid)
58:      * @return a new zip code object matching the given string
59:      * @throws ShopException if ...
60:      *      - zipCodeAsString is null
61:      *      - zipCodeAsString is not a valid zip code (see above)
62:      */
63:      // public static ZipCodeType of( String zipCodeAsString );
64: }
65: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\CustomerTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: 
4: import thkoeln.archilab.ecommerce.usecases.CustomerType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
7: 
8: /**
9:  * This is a test helper interface provides access to predefined test data for
10:  * customers.
11:  */
12: public interface CustomerTestHelper {
13:     /**
14:      * This method calls the use case implementation to register all customers specified in the
15:      * test data set.
16:      * If you use the debugger and want to identify _which_ test customer you currently look at:
17:      * The indices are coded into the house number (in the customer's address) and in the first
18:      * cipher of the zip code. This is the list of customers:
19:      *
20:      * +-------+-------------------+--------+---------------------
21:      * | Index | Name              | PLZ    | EmailAddress
22:      * +-------+-------------------+--------+---------------------
23:      * | 0     | Max Mueller       | 02314  | 99Z@example.com
24:      * | 1     | Sophie Schmitz    | 02368  | a@4.com
25:      * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
26:      * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
27:      * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
28:      * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
29:      * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
30:      * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
31:      * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
32:      * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
33:      * +-------+-------------------+--------+---------------------
34:      */
35:     void registerAllCustomers();
36: 
37: 
38:     /**
39:      * @return the number of test customers in the test data set.
40:      */
41:     int getNumberOfCustomers();
42: 
43: 
44:     /**
45:      * @param index the index of the customer in the test data set.
46:      * @return the name of the test customer with the given index.
47:      */
48:     String getCustomerName( int index );
49: 
50: 
51:     /**
52:      * @param index the index of the customer in the test data set.
53:      * @return the email address of the test customer with the given index.
54:      */
55:     EmailAddressType getCustomerEmailAddress( int index );
56: 
57: 
58:     /**
59:      * @param index the index of the customer in the test data set.
60:      * @return the address of the test customer with the given index.
61:      */
62:     AddressType getCustomerAddress( int index );
63: 
64: 
65:     /**
66:      * @param index the index of the customer in the test data set.
67:      * @return the test customer with the given index.
68:      */
69:     CustomerType getCustomer( int index );
70: 
71: }
72: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
8: 
9: import java.io.File;
10: import java.io.IOException;
11: import java.lang.reflect.InvocationTargetException;
12: import java.lang.reflect.Method;
13: import java.lang.reflect.Modifier;
14: import java.net.URL;
15: import java.net.URLDecoder;
16: import java.nio.charset.StandardCharsets;
17: import java.util.Enumeration;
18: 
19: import static org.junit.jupiter.api.Assertions.*;
20: 
21: public class FactoryMethodInvoker {
22: 
23:     public static EmailAddressType instantiateEmailAddress( String emailAddressAsString ) {
24:         Method factoryMethod = null;
25:         try {
26:             Class<?> interfaceClass = Class.forName(
27:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType" );
28:             Class<?> implementingClass = findImplementation( interfaceClass );
29: 
30:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
31:             assertNotNull( factoryMethod );
32:             int modifiers = factoryMethod.getModifiers();
33:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
34:         } catch (Exception e) {
35:             fail( "Failed to find implementation for EmailAddressType", e );
36:         }
37: 
38:         Object instance = null;
39:         try {
40:             instance = factoryMethod.invoke( null, emailAddressAsString );
41:         } catch (Exception e) {
42:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
43:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
44:             fail( "Failed to invoke factory method 'of' for '" + emailAddressAsString + "'", e );
45:         }
46:         assertNotNull( instance );
47:         return (EmailAddressType) instance;
48:     }
49: 
50: 
51:     public static AddressType instantiateAddress(
52:             String street, String city, ZipCodeType zipCode ) {
53:         Method factoryMethod = null;
54:         try {
55:             Class<?> interfaceClass = Class.forName(
56:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType" );
57:             Class<?> implementingClass = findImplementation( interfaceClass );
58: 
59:             factoryMethod = implementingClass.getDeclaredMethod( "of",
60:                     String.class, String.class, ZipCodeType.class );
61:             assertNotNull( factoryMethod );
62:             int modifiers = factoryMethod.getModifiers();
63:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
64:         } catch (Exception e) {
65:             fail( "Failed to find implementation for AddressType", e );
66:         }
67: 
68:         Object instance = null;
69:         try {
70:             instance = factoryMethod.invoke( null, street, city, zipCode );
71:         } catch (Exception e) {
72:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
73:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
74:             fail( "Failed to invoke factory method 'of' for '" +
75:                     street + "', '" + city + "', '" + zipCode + "'", e );
76:         }
77:         assertNotNull( instance );
78:         return (AddressType) instance;
79:     }
80: 
81: 
82:     public static ZipCodeType instantiateZipCode( String zipCodeAsString ) {
83:         Method factoryMethod = null;
84:         try {
85:             Class<?> interfaceClass = Class.forName(
86:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType" );
87:             Class<?> implementingClass = findImplementation( interfaceClass );
88: 
89:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
90:             assertNotNull( factoryMethod );
91:             int modifiers = factoryMethod.getModifiers();
92:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
93:         } catch (Exception e) {
94:             fail( "Failed to find implementation for ZipCodeType", e );
95:         }
96: 
97:         Object instance = null;
98:         try {
99:             instance = factoryMethod.invoke( null, zipCodeAsString );
100:         } catch (Exception e) {
101:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
102:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
103:             fail( "Failed to invoke factory method 'of' for '" + zipCodeAsString + "'", e );
104:         }
105:         assertNotNull( instance );
106:         return (ZipCodeType) instance;
107:     }
108: 
109: 
110:     public static MoneyType instantiateMoney( Float amount, String currencyUnit ) {
111:         Method factoryMethod = null;
112:         try {
113:             Class<?> interfaceClass = Class.forName(
114:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType" );
115:             Class<?> implementingClass = findImplementation( interfaceClass );
116: 
117:             factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
118:             assertNotNull( factoryMethod );
119:             int modifiers = factoryMethod.getModifiers();
120:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
121:         } catch (Exception e) {
122:             fail( "Failed to find implementation for MoneyType", e );
123:         }
124: 
125:         Object instance = null;
126:         try {
127:             instance = factoryMethod.invoke( null, amount, currencyUnit );
128:         } catch (Exception e) {
129:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
130:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
131:             fail( "Failed to invoke factory method 'of' for '" + amount + "', '" + currencyUnit + "'", e );
132:         }
133:         assertNotNull( instance );
134:         return (MoneyType) instance;
135:     }
136: 
137: 
138:     private static Class<?> findImplementation( Class<?> interfaceClass ) {
139:         Method factoryMethod = null;
140:         try {
141:             String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
142:             Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
143:             assertNotNull( implementingClass );
144:             return implementingClass;
145:         } catch (Exception e) {
146:             fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
147:             return null; // This line will never be reached, but it's necessary to satisfy the compiler
148:         }
149:     }
150: 
151: 
152:     private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
153:             throws ClassNotFoundException, IOException {
154:         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
155:         String path = packageName.replace( '.', '/' );
156:         Enumeration<URL> resources = classLoader.getResources( path );
157:         int count = 0;
158:         Class<?> result = null;
159:         while (resources.hasMoreElements()) {
160:             URL resource = resources.nextElement();
161:             File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
162:             File[] files = directory.listFiles();
163:             for ( File file : files ) {
164:                 if ( file.getName().endsWith( ".class" ) ) {
165:                     String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
166:                     Class<?> clazz = Class.forName( className );
167:                     if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
168:                         count++;
169:                         result = clazz;
170:                     }
171:                 }
172:             }
173:         }
174:         assertEquals( 1, count, "There should be exactly one implementing class" );
175:         return result;
176:     }
177: }
178: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\CustomerTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
7: import thkoeln.archilab.ecommerce.usecases.CustomerType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.MockCustomer;
12: 
13: import static org.junit.jupiter.api.Assertions.assertThrows;
14: 
15: /**
16:  * This is a test helper class that initializes and registers customers in the system,
17:  * using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class CustomerTestHelperImpl implements CustomerTestHelper {
22: 
23:     private CustomerRegistrationUseCases customerRegistrationUseCases;
24: 
25:     @Autowired
26:     public CustomerTestHelperImpl( CustomerRegistrationUseCases customerRegistrationUseCases ) {
27:         this.customerRegistrationUseCases = customerRegistrationUseCases;
28:     }
29: 
30:     private final static String[] CUSTOMER_NAME = new String[]{
31:             "Max Mueller",
32:             "Sophie Schmitz",
33:             "Irene Mihalic",
34:             "Emilia Fischer",
35:             "Filiz Polat",
36:             "Lina Wagner",
37:             "Leon Becker",
38:             "Agnieszka Kalterer",
39:             "Felix Bauer",
40:             "Lara Schulz"
41:     };
42: 
43:     private final static EmailAddressType[] CUSTOMER_EMAIL = new EmailAddressType[]{
44:             FactoryMethodInvoker.instantiateEmailAddress( "99Z@example.com" ),
45:             FactoryMethodInvoker.instantiateEmailAddress( "a@4.com" ),
46:             FactoryMethodInvoker.instantiateEmailAddress( "irene@wearefreedomnow.com" ),
47:             FactoryMethodInvoker.instantiateEmailAddress( "emilia.fischer@example.com" ),
48:             FactoryMethodInvoker.instantiateEmailAddress( "j877d3@example.this.com" ),
49:             FactoryMethodInvoker.instantiateEmailAddress( "lina.marie.wagner@example.com" ),
50:             FactoryMethodInvoker.instantiateEmailAddress( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
51:             FactoryMethodInvoker.instantiateEmailAddress( "agna@here.ch" ),
52:             FactoryMethodInvoker.instantiateEmailAddress( "felix.bauer@example.org" ),
53:             FactoryMethodInvoker.instantiateEmailAddress( "lara.schulz@example.at" )
54:     };
55: 
56:     // The following array is used to create a list of addresss for the customers.
57:     // The indices are coded into the house number.
58:     // - Persons 0 - 5 are used for proximity tests with one storage unit.
59:     private final static AddressType[] CUSTOMER_ADDRESS = new AddressType[]{
60:             FactoryMethodInvoker.instantiateAddress(
61:                     "Marktstraße 0", "Viertelstadt",
62:                     FactoryMethodInvoker.instantiateZipCode( "02314" ) ),
63:             FactoryMethodInvoker.instantiateAddress(
64:                     "Hauptstraße 1", "Viertelstadt",
65:                     FactoryMethodInvoker.instantiateZipCode( "02368" ) ),
66:             FactoryMethodInvoker.instantiateAddress(
67:                     "Kirchplatz 2", "Niemandstown",
68:                     FactoryMethodInvoker.instantiateZipCode( "12345" ) ),
69:             FactoryMethodInvoker.instantiateAddress(
70:                     "Schulstraße 3", "Geisterhausen",
71:                     FactoryMethodInvoker.instantiateZipCode( "31463" ) ),
72:             FactoryMethodInvoker.instantiateAddress(
73:                     "Rosenweg 4", "Kuhhausen",
74:                     FactoryMethodInvoker.instantiateZipCode( "72162" ) ),
75:             FactoryMethodInvoker.instantiateAddress(
76:                     "Wiesenstraße 5", "Waldschenkensdorf",
77:                     FactoryMethodInvoker.instantiateZipCode( "82195" ) ),
78:             FactoryMethodInvoker.instantiateAddress(
79:                     "Muehlenweg 6", "Koeln",
80:                     FactoryMethodInvoker.instantiateZipCode( "50667" ) ),
81:             FactoryMethodInvoker.instantiateAddress(
82:                     "Goethestraße 7", "Frankfurt am Main",
83:                     FactoryMethodInvoker.instantiateZipCode( "60311" ) ),
84:             FactoryMethodInvoker.instantiateAddress(
85:                     "Dorfstraße 8", "Stuttgart",
86:                     FactoryMethodInvoker.instantiateZipCode( "70173" ) ),
87:             FactoryMethodInvoker.instantiateAddress(
88:                     "Bahnhofstraße 9", "Muenchen",
89:                     FactoryMethodInvoker.instantiateZipCode( "80331" ) )
90:     };
91: 
92:     private final static CustomerType[] mockCustomers;
93: 
94:     static {
95:         mockCustomers = new CustomerType[CUSTOMER_NAME.length];
96:         for ( int i = 0; i < CUSTOMER_NAME.length; i++ ) {
97:             mockCustomers[i] = new MockCustomer(
98:                     CUSTOMER_NAME[i], CUSTOMER_EMAIL[i], CUSTOMER_ADDRESS[i] );
99:         }
100:     }
101: 
102: 
103:     @Override
104:     public void registerAllCustomers() {
105:         for ( int i = 0; i < CUSTOMER_NAME.length; i++ ) {
106:             registerCustomer( CUSTOMER_NAME[i], CUSTOMER_EMAIL[i], CUSTOMER_ADDRESS[i] );
107:         }
108:     }
109: 
110: 
111:     private void registerCustomer( String name, EmailAddressType emailAddress, AddressType address ) {
112:         customerRegistrationUseCases.register( name, emailAddress, address );
113:     }
114: 
115: 
116:     @Override
117:     public int getNumberOfCustomers() {
118:         return CUSTOMER_NAME.length;
119:     }
120: 
121: 
122:     @Override
123:     public String getCustomerName( int index ) {
124:         if ( index < 0 || index >= CUSTOMER_NAME.length ) {
125:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
126:         }
127:         return CUSTOMER_NAME[index];
128:     }
129: 
130: 
131:     @Override
132:     public EmailAddressType getCustomerEmailAddress( int index ) {
133:         if ( index < 0 || index >= CUSTOMER_NAME.length ) {
134:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
135:         }
136:         return CUSTOMER_EMAIL[index];
137:     }
138: 
139: 
140:     @Override
141:     public AddressType getCustomerAddress( int index ) {
142:         if ( index < 0 || index >= CUSTOMER_NAME.length ) {
143:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
144:         }
145:         return CUSTOMER_ADDRESS[index];
146:     }
147: 
148: 
149:     @Override
150:     public CustomerType getCustomer( int index ) {
151:         if ( index < 0 || index >= CUSTOMER_NAME.length ) {
152:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
153:         }
154:         return mockCustomers[index];
155:     }
156: }
157: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\StockTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
7: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
8: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
12: 
13: import java.util.*;
14: 
15: /**
16:  * This is a test helper class that initializes and registers products (but without stock)
17:  * in the system, using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class StockTestHelperImpl
22:                         implements ProductTestHelper, StorageUnitTestHelper {
23:     private ProductCatalogUseCases productCatalogUseCases;
24:     private StorageUnitUseCases storageUnitUseCases;
25:     private static Random random = new Random();
26: 
27:     private static final String EUR = "EUR";
28:     private static final int PRODUCT_NUMOF = 15;
29:     private static final Object[][] PRODUCT_DATA = new Object[][]{
30:             {null, "0-TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
31:                     1.5f, FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
32:                     FactoryMethodInvoker.instantiateMoney( 10.0f, EUR ),
33:                     "0"},
34:             {null, "1-EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
35:                     0.3f, FactoryMethodInvoker.instantiateMoney( 2.5f, EUR ),
36:                     FactoryMethodInvoker.instantiateMoney( 4.0f, EUR ),
37:                     "0"},
38:             {null, "2-MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
39:                     7.2f, FactoryMethodInvoker.instantiateMoney( 50.0f, EUR ),
40:                     FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
41:                     "0"},
42:             {null, "3-Gh-25", "Kompakter und leichter Akku für mobile Geräte",
43:                     null, FactoryMethodInvoker.instantiateMoney( 6.0f, EUR ),
44:                     FactoryMethodInvoker.instantiateMoney( 8.0f, EUR ),
45:                     "0"},
46:             {null, "4-MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
47:                     null, FactoryMethodInvoker.instantiateMoney( 0.6f, EUR ),
48:                     FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
49:                     "0"},
50:             {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
51:                     1.0f, FactoryMethodInvoker.instantiateMoney( 150.0f, EUR ),
52:                     FactoryMethodInvoker.instantiateMoney( 250.0f, EUR ),
53:                     "0"},
54:             {null, "6-Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
55:                     null, FactoryMethodInvoker.instantiateMoney( 0.3f, EUR ),
56:                     FactoryMethodInvoker.instantiateMoney( 0.5f, EUR ),
57:                     "0"},
58:             {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
59:                     6.0f, FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
60:                     FactoryMethodInvoker.instantiateMoney( 120.0f, EUR ),
61:                     "123"},
62:             {null, "8-JKL-67", "Wasserdichtes Gehäuse",
63:                     3.0f, FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
64:                     FactoryMethodInvoker.instantiateMoney( 1.2f, EUR ),
65:                     "467"},
66:             {null, "9-MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
67:                     5.5f, FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
68:                     FactoryMethodInvoker.instantiateMoney( 45.0f, EUR ),
69:                     "578"},
70:             {null, "10-PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
71:                     4.0f, FactoryMethodInvoker.instantiateMoney( 20.0f, EUR ),
72:                     FactoryMethodInvoker.instantiateMoney( 35.0f, EUR ),
73:                     "567"},
74:             {null, "11-STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
75:                     null, FactoryMethodInvoker.instantiateMoney( 200.0f, EUR ),
76:                     FactoryMethodInvoker.instantiateMoney( 350.0f, EUR ),
77:                     "478"},
78:             {null, "12-VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
79:                     null, FactoryMethodInvoker.instantiateMoney( 15.0f, EUR ),
80:                     FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
81:                     "5"},
82:             {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
83:                     3.5f, FactoryMethodInvoker.instantiateMoney( 60.0f, EUR ),
84:                     FactoryMethodInvoker.instantiateMoney( 100.0f, EUR ),
85:                     "78"},
86:             {null, "14-Nosedive", "Klammer zum Verschließen der Nase beim Tauchen",
87:                     5.0f, FactoryMethodInvoker.instantiateMoney( 2.0f, EUR ),
88:                     FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
89:                     "457"}
90:     };
91:     
92: 
93:     // These addresss are used for the storage units. The storage unit name will equal
94:     // the zip code of the site. Their index number will be visible in the house number.
95:     // The storage units are used as such:
96:     // - storage unit 0 is holds all products 0 - 6, and is used for all tests where multiple
97:     //   deliveries are irrelevant.
98:     // - storage units 1 - 3 are used for the proximity tests, where you can deliver products 7 to
99:     //   to a customer from the closest storage unit.
100:     // - storage units 4 - 8 are used for the tests where you need to deliver products 8 - 14 in
101:     //   the most cost-efficient way, as multiple deliveries.
102:     // - storage unit 9 is empty.
103:     private final static int STORAGE_UNIT_NUMOF = 10;
104:     private final static AddressType[] STORAGE_UNIT_ADDRESS = new AddressType[]{
105:             FactoryMethodInvoker.instantiateAddress(
106:                     "Stapelallee 0", "Potsdam",
107:                     FactoryMethodInvoker.instantiateZipCode( "14476" ) ),
108:             FactoryMethodInvoker.instantiateAddress(
109:                     "Lagerhausstr. 1", "Viertelstadt",
110:                     FactoryMethodInvoker.instantiateZipCode( "02345" ) ),
111:             FactoryMethodInvoker.instantiateAddress(
112:                     "Speicherplatz 2", "Viertelstadt",
113:                     FactoryMethodInvoker.instantiateZipCode( "02313" ) ),
114:             FactoryMethodInvoker.instantiateAddress(
115:                     "Ablageweg 3", "Reichswürgen",
116:                     FactoryMethodInvoker.instantiateZipCode( "44923" ) ),
117:             FactoryMethodInvoker.instantiateAddress(
118:                     "Paketstellenallee 4", "Düsseldorf",
119:                     FactoryMethodInvoker.instantiateZipCode( "40588" ) ),
120:             FactoryMethodInvoker.instantiateAddress(
121:                     "Kaputte-Sachen-Straße 5", "Düren",
122:                     FactoryMethodInvoker.instantiateZipCode( "52355" ) ),
123:             FactoryMethodInvoker.instantiateAddress(
124:                     "Aufbewahrungsweg 6", "Viernheim",
125:                     FactoryMethodInvoker.instantiateZipCode( "68519" ) ),
126:             FactoryMethodInvoker.instantiateAddress(
127:                     "Paketallee 7", "Baden-Baden",
128:                     FactoryMethodInvoker.instantiateZipCode( "76532" ) ),
129:             FactoryMethodInvoker.instantiateAddress(
130:                     "Sendenstr. 8", "Senden",
131:                     FactoryMethodInvoker.instantiateZipCode( "89250" ) ),
132:             FactoryMethodInvoker.instantiateAddress(
133:                     "Schickweg 9", "Hohenroth",
134:                     FactoryMethodInvoker.instantiateZipCode( "97618" ) )
135:     };
136:     private final static UUID[] STORAGE_UNIT_ID = new UUID[STORAGE_UNIT_NUMOF];
137: 
138: 
139:     // These data structures contain the stock of the products in the storage units.
140:     // PRODUCT_STOCK is a map product name -> Integer[STORAGE_UNIT_NUMOF].
141:     // The Integer[STORAGE_UNIT_NUMOF] contains the stock of the product in each of
142:     // the storage units.
143:     //
144:     // The following rules apply:
145:     // - product 0 is out of stock
146:     // - product 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in storage unit 0
147:     // - product 4 / 5 / 6 have a random stock between 30 and 130, also all ONLY in storage unit 0
148:     //   (these are the products used for tests on how to add and remove stock)
149:     // - the others have a random stock between 30 and 130, distributed over several
150:     //   storage units. Here we follow this convention for simplicity:
151:     //   - Assume that the product is available in <n> storage units. Then the first <n-1> storage units
152:     //     in the list (in ascending sequence) contain 3, and all the remaining stock is in the
153:     //     last storage unit.
154: 
155:     private static final Map<String, Integer[]> PRODUCT_STOCK = new HashMap<>();
156: 
157:     static {
158:         // products 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
159:         PRODUCT_STOCK.put( (String) PRODUCT_DATA[0][1],
160:                 getStockDistribution( 0, (String) PRODUCT_DATA[0][6] ) );
161:         PRODUCT_STOCK.put( (String) PRODUCT_DATA[1][1],
162:                 getStockDistribution( 10, (String) PRODUCT_DATA[1][6] ) );
163:         PRODUCT_STOCK.put( (String) PRODUCT_DATA[2][1],
164:                 getStockDistribution( 20, (String) PRODUCT_DATA[2][6] ) );
165:         PRODUCT_STOCK.put( (String) PRODUCT_DATA[3][1],
166:                 getStockDistribution( 30, (String) PRODUCT_DATA[3][6] ) );
167: 
168:         // The other products have a random stock between 30 and 130,
169:         for ( int i = 4; i < PRODUCT_NUMOF; i++ ) {
170:             Integer totalNumber = random.nextInt( 100 ) + 30;
171:             Integer[] stockInStorageUnits =
172:                     getStockDistribution( totalNumber, (String) PRODUCT_DATA[i][6] );
173:             PRODUCT_STOCK.put( (String) PRODUCT_DATA[i][1], stockInStorageUnits );
174:         }
175:     }
176: 
177:     /**
178:      * This method creates a random stock distribution for the given product.
179:      *
180:      * @param totalQuantity - the total number of products in the storage units
181:      * @param zeroToNine  - a string with numbers between 0 and 9, representing the storage units
182:      * @return an Integer array with the stock distribution for the product, according to
183:      * the rules described above.
184:      */
185:     private static Integer[] getStockDistribution( Integer totalQuantity, String zeroToNine ) {
186:         Integer[] stockInStorageUnits = new Integer[STORAGE_UNIT_NUMOF];
187:         for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) stockInStorageUnits[i] = 0;
188:         TreeSet<Integer> storageUnitIndices = getStorageUnitIndices( zeroToNine );
189:         int numOfIndices = storageUnitIndices.size();
190:         int currentIndexNumber = 0;
191:         int currentQuantity = totalQuantity;
192:         for ( Integer storageUnitIndex : storageUnitIndices ) {
193:             currentIndexNumber++;
194:             if ( currentIndexNumber < numOfIndices ) {
195:                 stockInStorageUnits[storageUnitIndex] = 3;
196:                 currentQuantity -= 3;
197:             } else {
198:                 stockInStorageUnits[storageUnitIndex] = currentQuantity;
199:             }
200:         }
201:         return stockInStorageUnits;
202:     }
203: 
204:     private static TreeSet<Integer> getStorageUnitIndices( String zeroToNine ) {
205:         TreeSet<Integer> storageUnitIndices = new TreeSet<>();
206:         for ( int i = 0; i < zeroToNine.length(); i++ ) {
207:             storageUnitIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
208:         }
209:         return storageUnitIndices;
210:     }
211: 
212: 
213:     @Autowired
214:     public StockTestHelperImpl( ProductCatalogUseCases productCatalogUseCases,
215:                                          StorageUnitUseCases storageUnitUseCases ) {
216:         this.productCatalogUseCases = productCatalogUseCases;
217:         this.storageUnitUseCases = storageUnitUseCases;
218:     }
219: 
220: 
221:     @Override
222:     public void addAllProducts() {
223:         int i = 0;
224:         for ( Object[] productData : PRODUCT_DATA ) {
225:             UUID newId = productCatalogUseCases.addProductToCatalog(
226:                     (String) productData[1], (String) productData[2],
227:                     (Float) productData[3], (MoneyType) productData[4],
228:                     (MoneyType) productData[5] );
229:             // The first element of the product data is the id, which was initialized with null before, but can now be set
230:             PRODUCT_DATA[i][0] = newId;
231:             i++;
232:         }
233:     }
234: 
235: 
236:     @Override
237:     public int numberOfProducts() {
238:         return PRODUCT_NUMOF;
239:     }
240: 
241: 
242:     @Override
243:     public UUID getProductId( int index ) {
244:         if ( index < 0 || index >= PRODUCT_NUMOF ) {
245:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
246:         }
247:         return (UUID) PRODUCT_DATA[index][0];
248:     }
249: 
250: 
251:     @Override
252:     public MoneyType getBuyingPrice( int index ) {
253:         if ( index < 0 || index >= PRODUCT_NUMOF ) {
254:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
255:         }
256:         return (MoneyType) PRODUCT_DATA[index][4];
257:     }
258: 
259: 
260:     @Override
261:     public MoneyType getSellingPrice( int index ) {
262:         if ( index < 0 || index >= PRODUCT_NUMOF ) {
263:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
264:         }
265:         return (MoneyType) PRODUCT_DATA[index][5];
266:     }
267: 
268: 
269:     @Override
270:     public void addAllStorageUnits( boolean withStock ) {
271:         for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) {
272:             STORAGE_UNIT_ID[i] = storageUnitUseCases.addNewStorageUnit(
273:                     STORAGE_UNIT_ADDRESS[i].getStreet(),
274:                     STORAGE_UNIT_ADDRESS[i] );
275:         }
276:         if ( withStock ) {
277:             addAllStock();
278:         }
279:     }
280: 
281: 
282:     private void addAllStock() {
283:         for ( Object[] productData : PRODUCT_DATA ) {
284:             Integer[] stockInStorageUnits =
285:                     PRODUCT_STOCK.get( productData[1] );
286:             for ( int iStorageUnit = 0; iStorageUnit < STORAGE_UNIT_NUMOF; iStorageUnit++ ) {
287:                 if ( stockInStorageUnits[iStorageUnit] > 0 )
288:                     storageUnitUseCases.addToStock(
289:                             STORAGE_UNIT_ID[iStorageUnit], (UUID) productData[0],
290:                             stockInStorageUnits[iStorageUnit] );
291:             }
292:         }
293:     }
294: 
295: 
296:     @Override
297:     public int numberOfStorageUnits() {
298:         return STORAGE_UNIT_NUMOF;
299:     }
300: 
301: 
302:     @Override
303:     public UUID getStorageUnitId( int index ) {
304:         if ( index < 0 || index >= STORAGE_UNIT_NUMOF ) {
305:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
306:         }
307:         return STORAGE_UNIT_ID[index];
308:     }
309: 
310: 
311:     @Override
312:     public Integer getStorageUnitStock( int storageUnitIndex, int productIndex ) {
313:         if ( storageUnitIndex < 0 || storageUnitIndex >= STORAGE_UNIT_NUMOF ) {
314:             throw new IndexOutOfBoundsException( "Index out of bounds: " + storageUnitIndex );
315:         }
316:         if ( productIndex < 0 || productIndex >= PRODUCT_NUMOF ) {
317:             throw new IndexOutOfBoundsException( "Index out of bounds: " + productIndex );
318:         }
319:         String productName = (String) PRODUCT_DATA[productIndex][1];
320:         Integer[] stockInStorageUnits = PRODUCT_STOCK.get( productName );
321:         Integer foundStock = stockInStorageUnits[storageUnitIndex];
322:         return foundStock == null ? 0 : foundStock;
323:     }
324: 
325: 
326:     @Override
327:     public int findStorageUnitIndex( UUID storageUnitId ) {
328:         for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) {
329:             if ( STORAGE_UNIT_ID[i].equals( storageUnitId ) ) {
330:                 return i;
331:             }
332:         }
333:         throw new IllegalArgumentException( "No test storage unit with UUID id " + storageUnitId );
334:     }
335: 
336: 
337:     @Override
338:     public int findProductIndex( UUID productId ) {
339:         for ( int iProductData = 0; iProductData < STORAGE_UNIT_NUMOF; iProductData++ ) {
340:             Object[] productData = PRODUCT_DATA[iProductData];
341:             if ( productData[0].equals( productId ) ) {
342:                 return iProductData;
343:             }
344:         }
345:         throw new IllegalArgumentException( "No test product with UUID id " + productId );
346:     }
347: }
348: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockCustomer.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.Setter;
4: import thkoeln.archilab.ecommerce.usecases.CustomerType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;
6: 
7: 
8: import java.util.Objects;
9: 
10: @Setter
11: public class MockCustomer implements CustomerType {
12:     private String name;
13:     private EmailAddressType emailAddressType;
14:     private AddressType addressType;
15: 
16: 
17:     public MockCustomer( String name, EmailAddressType emailAddressType, AddressType addressType) {
18:         this.name = name;
19:         this.emailAddressType = emailAddressType;
20:         this.addressType = addressType;
21:     }
22: 
23:     @Override
24:     public String getName() {
25:         return name;
26:     }
27: 
28:     @Override
29:     public EmailAddressType getEmailAddress() {
30:         return emailAddressType;
31:     }
32: 
33:     @Override
34:     public AddressType getAddress() {
35:         return addressType;
36:     }
37: 
38:     @Override
39:     public boolean equals( Object o ) {
40:         if ( this == o ) return true;
41:         if ( !( o instanceof MockCustomer ) ) return false;
42:         MockCustomer that = (MockCustomer) o;
43:         return Objects.equals( getName(), that.getName() ) &&
44:                 Objects.equals( emailAddressType, that.emailAddressType ) &&
45:                 Objects.equals( addressType, that.addressType );
46:     }
47: 
48:     @Override
49:     public int hashCode() {
50:         return Objects.hash( getName(), emailAddressType, addressType );
51:     }
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ProductTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
4: 
5: import java.util.UUID;
6: 
7: public interface ProductTestHelper {
8:     /**
9:      * Adds all test products to the database.
10:      * If you use the debugger and want to identify _which_ test product you currently look at:
11:      * The indices are coded into the first number in the name string of the product, like e.g.
12:      * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
13:      */
14:     void addAllProducts();
15: 
16: 
17:     /**
18:      * @return the number of test products in the database
19:      */
20:     int numberOfProducts();
21: 
22: 
23:     /**
24:      * @param index
25:      * @return the id of the test product at the given index
26:      */
27:     UUID getProductId( int index );
28: 
29: 
30:     /**
31:      * @param productId - the id of the product in the test data
32:      * @return the index of the test product with that id
33:      */
34:     int findProductIndex( UUID productId );
35: 
36: 
37:     /**
38:      * @param index
39:      * @return the buying price of test product at the given index
40:      */
41:     MoneyType getBuyingPrice( int index );
42: 
43: 
44:     /**
45:      * @param index
46:      * @return the selling price of test product at the given index
47:      */
48:     MoneyType getSellingPrice( int index );
49: }
50: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.usecases.*;
6: 
7: /**
8:  * Removes everything :-)
9:  */
10: @Service
11: public class Purgatory {
12:     @Autowired
13:     private CustomerRegistrationUseCases customerRegistrationUseCases;
14:     @Autowired
15:     private ShoppingBasketUseCases shoppingBasketUseCases;
16:     @Autowired
17:     private OrderUseCases orderUseCases;
18:     @Autowired
19:     private ProductCatalogUseCases productCatalogUseCases;
20:     @Autowired
21:     private StorageUnitUseCases storageUnitUseCases;
22: 
23:     public void deleteEverything() {
24:         orderUseCases.deleteAllOrders();
25:         shoppingBasketUseCases.emptyAllShoppingBaskets();
26:         storageUnitUseCases.deleteAllStorageUnits();
27:         customerRegistrationUseCases.deleteAllCustomers();
28:         productCatalogUseCases.deleteProductCatalog();
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.context.ApplicationListener;
6: import org.springframework.context.annotation.Profile;
7: import org.springframework.context.event.ContextRefreshedEvent;
8: import org.springframework.stereotype.Component;
9: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
12: 
13: @Component
14: @Slf4j
15: @Profile("!test")
16: @SuppressWarnings("PMD")
17: public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
18:     private Purgatory purgatory;
19:     private CustomerTestHelper customerTestHelper;
20:     private ProductTestHelper productTestHelper;
21:     private StorageUnitTestHelper storageUnitTestHelper;
22: 
23: 
24:     @Autowired
25:     public StartupListener( Purgatory purgatory,
26:                             CustomerTestHelper customerTestHelper,
27:                             ProductTestHelper productTestHelper,
28:                             StorageUnitTestHelper storageUnitTestHelper ) {
29:         this.purgatory = purgatory;
30:         this.customerTestHelper = customerTestHelper;
31:         this.productTestHelper = productTestHelper;
32:         this.storageUnitTestHelper = storageUnitTestHelper;
33:     }
34: 
35:     @Override
36:     public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
37:         log.info( "StartupListener initializing master data ..." );
38:         purgatory.deleteEverything();
39:         customerTestHelper.registerAllCustomers();
40:         productTestHelper.addAllProducts();
41:         storageUnitTestHelper.addAllStorageUnits( true );
42:     }
43: }
44: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StorageUnitTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import java.util.UUID;
4: 
5: public interface StorageUnitTestHelper {
6:     /**
7:      * Adds the test storage units to the system.
8:      * If you want to use the storage units, or want to know which index the storage unit has that you see
9:      * in the debugger, the following rules apply:
10:      * - The storage unit name will equal the street name of the address of the storage unit.
11:      * - The index number is visible in the house number. Example: storage unit 3 is located at
12:      *   "Ablageweg 3", and that is also its name.
13:      *
14:      *  The storage units are used in the tests as follows:
15:      *  - storage unit 0 holds all products 0 - 6, and is used for all tests where it is not relevant
16:      *    to split one shopping basket into several orders.
17:      *  - storage units 1 - 3 are used for the proximity tests, where you can deliver product 7 to
18:      *    to a customer from the closest storage unit.
19:      *  - storage units 4 - 8 are used for the tests where you need to deliver products 8 - 14 in
20:      *    the most cost-efficient way, as multiple deliveries.
21:      *  - storage unit 9 is empty.
22:      *
23:      *  If withStock is true, then the storage units are filled with products. This happens
24:      *  according to the following rules:
25:      *  - products 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
26:      *    ONLY available in storage unit 0. (This means that product 0 out of stock everywhere.)
27:      *  - products 4, 5, 6 have a random stock between 30 and 130, also all ONLY in storage unit 0
28:           (these are the products used for tests on how to add and remove stock)
29:      *  - product 7 has a random stock between 30 and 130, distributed over
30:      *    storage units 1, 2, and 3. You can use this to test if the appropriate storage unit is found
31:      *    for a shopping basket with only product 7 in it, but with different quantities (<= 3, or > 3).
32:      *  - The other products (8 - 14) have also a random stock between 30 and 130, all distributed
33:      *    over several storage units. The distribution is done as follows:
34:      *    Assume that the product is available in <n> storage units. Then the first <n-1> storage units
35:      *    in the list (in ascending sequence) contain 3, and all the remaining stock is in the
36:      *    last storage unit.
37:      *
38:      *    This is how the stock of products could be distributed
39:      *    (Wx = storage unit x with its zip code, Px = product x,
40:      *    numbers marked with (*) are random large numbers):
41:      *
42:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
43:      *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
44:      *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
45:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
46:      *    | P0   |      |     |     |      |     |      |     |       |      |     |
47:      *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
48:      *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
49:      *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
50:      *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
51:      *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
52:      *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
53:      *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
54:      *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
55:      *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
56:      *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
57:      *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
58:      *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
59:      *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
60:      *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
61:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
62:      *
63:      * @param withStock if true, the stock of the products is added to the storage unit. Otherwise, the
64:      *                           the stock is not added and the storage unit is empty.
65:      */
66:     public void addAllStorageUnits( boolean withStock );
67: 
68: 
69:     /**
70:      * @return the number of test storage units in the database
71:      */
72:     int numberOfStorageUnits();
73: 
74: 
75:     /**
76:      * @param index
77:      * @return the id of the test storage unit at the given index
78:      */
79:     UUID getStorageUnitId( int index );
80: 
81: 
82:     /**
83:      * @param storageUnitId - the id of the storage unit in the test data
84:      * @return the index of the test storage unit with that id
85:      */
86:     int findStorageUnitIndex( UUID storageUnitId );
87: 
88: 
89:     /**
90:      * @param productIndex - the index of the product in the test data
91:      * @param storageUnitIndex - the index of the storage unit in the test data
92:      * @return the number of products (stock) available in the storage unit at the given index
93:      */
94:     Integer getStorageUnitStock( int storageUnitIndex, int productIndex );
95: 
96: }
97: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\OrderUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
3:  */
4: package thkoeln.archilab.ecommerce.usecases;
5: 
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
9: 
10: import java.util.Map;
11: import java.util.UUID;
12: 
13: /**
14:  * This interface contains methods needed in the context of the order history of a customer.
15:  */
16: public interface OrderUseCases {
17: 
18:     /**
19:      * Returns a map showing which products have been ordered by a customer and how many of each product
20:      *
21:      * @param customerEmailAddress
22:      * @return the order history of the customer (map is empty if the customer has not ordered anything yet)
23:      * @throws ShopException if
24:      *      - customerEmailAddress is null
25:      *      - the customer with the given email address does not exist
26:      */
27:     public Map<UUID, Integer> getOrderHistory( EmailAddressType customerEmailAddress );
28: 
29: 
30: 
31:     /**
32:      * @return the number of products in a given order. If the product is not a part of the order, the method
33:      *         returns 0. No exception is thrown.
34:      * @param orderId - the id of the order to be checked
35:      * @param productId - the id of the product for which we want to know the quantity
36:      * @throws ShopException if
37:      *     - orderId is null, or doesn't exist in the system
38:      *     - productId is null, or doesn't exist in the system
39:      */
40:     public Integer getOrderQuantForProduct( UUID orderId, UUID productId );
41: 
42: 
43:     /**
44:      * @return the id of the storage unit that is responsible for the given order
45:      * @param orderId - the id of the order to be checked
46:      * @throws ShopException if
47:      *      - orderId is null, or doesn't exist in the system
48:      */
49:     public UUID getStorageUnitIdForOrder( UUID orderId );
50: 
51: 
52:     /**
53:      * Deletes all orders in the system
54:      */
55:     public void deleteAllOrders();
56: }
57: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\ProductCatalogUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: 
10: import java.util.UUID;
11: 
12: 
13: /**
14:  * This interface contains methods needed in the context of use cases concerning the product catalog.
15:  * The interface is probably incomplete, and will grow over time ...
16:  */
17: 
18: public interface ProductCatalogUseCases {
19:     /**
20:      * Adds a new product to the shop catalog
21:      * @param name
22:      * @param descriptionOf
23:      * @param size
24:      * @param buyingPrice
25:      * @param sellingPrice
26:      * @return the id of the new product
27:      * @throws ShopException if ...
28:      *      - the product id already exists,
29:      *      - name or description are null or empty,
30:      *      - the size is <= 0 (but can be null!),
31:      *      - the buying price is null or <= 0,
32:      *      - the buyingPrice is null,
33:      *      - the selling price is null,
34:      *      - the selling price is lower than the buyingPrice
35:      */
36:     public UUID addProductToCatalog( String name, String descriptionOf, Float size,
37:                                            MoneyType buyingPrice, MoneyType sellingPrice );
38: 
39: 
40:     /**
41:      * Removes a product from the shop catalog
42:      * @param productId
43:      * @throws ShopException if
44:      *      - productId is null
45:      *      - the product id does not exist
46:      *      - the product is still in stock
47:      *      - the product is still in a shopping basket, or referenced by a completed order
48:      */
49:     public void removeProductFromCatalog( UUID productId );
50: 
51: 
52:     /**
53:      * Get the selling price of a given product
54:      * @param productId
55:      * @return the selling price
56:      * @throws ShopException if ...
57:      *      - productId is null,
58:      *      - the product with that id does not exist
59:      */
60:     public MoneyType getSellingPrice( UUID productId );
61: 
62: 
63:     /**
64:      * Clears the product catalog, i.e. removes all products from the catalog, including all the stock,
65:      * all the reservations and all the orders.
66:      */
67:     public void deleteProductCatalog();
68: 
69: }
70: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingBasketUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
10: 
11: import java.util.Map;
12: import java.util.Set;
13: import java.util.UUID;
14: 
15: /**
16:  * This interface contains methods needed in the context of use cases handling the shopping basket.
17:  * The interface is probably incomplete, and will grow over time ...
18:  */
19: public interface ShoppingBasketUseCases {
20:     /**
21:      * Adds a product to the cart of a customer
22:      *
23:      * @param customerEmailAddress
24:      * @param productId
25:      * @param quantFor
26:      * @throws ShopException if ...
27:      *          - customerEmailAddress is null,
28:      *          - the customer with the given email address does not exist,
29:      *          - productId is null,
30:      *          - the product with productId does not exist
31:      *          - the Quantity is negative,
32:      */
33:     public void addProductToShoppingBasket( EmailAddressType customerEmailAddress,
34:                                                  UUID productId, int quantFor );
35: 
36: 
37:     /**
38:      * Removes a product from the cart of a customer
39:      *
40:      * @param customerEmailAddress
41:      * @param productId
42:      * @param quantFor
43:      * @throws ShopException if ...
44:      *          - customerEmailAddress is null,
45:      *          - the customer with the given email address does not exist,
46:      *          - productId is null,
47:      *          - the product with productId does not exist
48:      *          - the Quantity is negative
49:      *          - the product is not in the shopping basket in the requested Quantity
50:      */
51:     public void removeProductFromShoppingBasket( EmailAddressType customerEmailAddress,
52:                                                       UUID productId, int quantFor );
53: 
54: 
55:     /**
56:      * Returns a map showing which products are in the cart of a customer and how many of each product
57:      *
58:      * @param customerEmailAddress
59:      * @return the cart of the customer (map is empty if the cart is empty)
60:      * @throws ShopException if
61:      *          - customerEmailAddress is null,
62:      *          - the customer with the given email address does not exist
63:      */
64:     public Map<UUID, Integer> getShoppingBasketAsMap( EmailAddressType customerEmailAddress );
65: 
66: 
67:     /**
68:      * Returns the current value of all products in the cart of a customer
69:      *
70:      * @param customerEmailAddress
71:      * @return the cart of the customer
72:      * @throws ShopException if
73:      *          - customerEmailAddress is null,
74:      *          - the customer with the given email address does not exist
75:      */
76:     public MoneyType getShoppingBasketAsMoneyValue( EmailAddressType customerEmailAddress );
77: 
78: 
79: 
80: 
81:     /**
82:      * Checks out the cart of a customer
83:      *
84:      * @param customerEmailAddress
85:      * @return A set of ids belonging to orders that were created during the checkout. If the shopping basket can
86:      *         only be served from more than one storage unit, each delivery from a storage unit gets a
87:      *         dedicated order. I.e. if there is just one delivery, then the set will contain just one order id.
88:      *         If there are multiple deliveries, the set will contain multiple order ids.
89:      * @throws ShopException if
90:      *      - customerEmailAddress is null or empty
91:      *      - the customer with the given email address does not exist, or if the cart is empty
92:      * @throws
93:      *      - ShopException if customerEmailAddress is null
94:      *      - InsufficientStockException if there is not enough stock level for to serve the order
95:      *        for all products in the shopping basket
96:      */
97:     public Set<UUID> checkout( EmailAddressType customerEmailAddress );
98: 
99: 
100:     /**
101:      * Empties all shopping baskets in the system
102:      */
103:     public void emptyAllShoppingBaskets();
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\StorageUnitUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
9: 
10: import java.util.UUID;
11: 
12: /**
13:  * This interface contains methods needed in the context of handling the shop stock,
14:  * i.e. managing storage units, and adding / removing products in the storage unit.
15:  */
16: public interface StorageUnitUseCases {
17:     /**
18:      *
19:      * @param name
20:      * @param address
21:      * @return the id of the new storage unit
22:      * @throws ShopException if ...
23:      *      - name is null or empty
24:      *      - address is null
25:      */
26:     public UUID addNewStorageUnit( String name, AddressType address );
27: 
28: 
29:     /**
30:      * Deletes all storage units from the shop. Intended for testing purposes.
31:      */
32:     public void deleteAllStorageUnits();
33: 
34: 
35:     /**
36:      * Adds a certain Quantity of a given product to the stock
37:      * @param storageUnitId
38:      * @param productId
39:      * @param addedQuantFor
40:      * @throws ShopException if ...
41:      *      - storageUnitId is null
42:      *      - the storage unit with that id does not exist
43:      *      - productId is null
44:      *      - the product with that id does not exist
45:      *      - addedQuantFor < 0
46:      */
47:     public void addToStock( UUID storageUnitId, UUID productId, int addedQuantFor );
48: 
49: 
50:     /**
51:      * Removes a certain Quantity of a given product from the stock.
52:      * @param storageUnitId
53:      * @param productId
54:      * @param removedQuantFor
55:      * @throws ShopException if ...
56:      *      - storageUnitId is null
57:      *      - the storage unit with that id does not exist
58:      *      - productId is null
59:      *      - the product with that id does not exist
60:      *      - removedQuantFor < 0
61:      */
62:     public void removeFromStock( UUID storageUnitId, UUID productId, int removedQuantFor );
63: 
64: 
65:     /**
66:      * Changes the total Quantity of a given product in the stock.
67:      * @param storageUnitId
68:      * @param productId
69:      * @param newTotalQuantFor
70:      * @throws ShopException if ...
71:      *      - storageUnitId is null
72:      *      - the storage unit with that id does not exist
73:      *      - productId is null
74:      *      - the product with that id does not exist
75:      *      - newTotalQuantFor < 0
76:      */
77:     public void changeStockTo( UUID storageUnitId, UUID productId, int newTotalQuantFor );
78: 
79: 
80:     /**
81:      * Get the current stock of a given product in one specific storage unit.
82:      * @param storageUnitId
83:      * @param productId
84:      * @return the current total stock of the product
85:      * @throws ShopException if ...
86:      *      - storageUnitId is null
87:      *      - the storage unit with that id does not exist
88:      *      - productId is null
89:      *      - the product with that id does not exist
90:      */
91:     public int getAvailableStock( UUID storageUnitId, UUID productId );
92: 
93: 
94: }
95: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import org.springframework.boot.test.context.TestConfiguration;
4: import org.springframework.context.annotation.Bean;
5: import org.springframework.test.web.servlet.MockMvc;
6: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
7: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
8: 
9: 
10: @TestConfiguration
11: public class RESTTestHelperConfiguration {
12: 
13:     @Bean
14:     public ShoppingBasketRESTHelper shoppingBasketRESTHelper(
15:             MockMvc mockMvc, ProductCatalogUseCases productCatalogUseCases ) {
16:         return new ShoppingBasketRESTHelperImpl( mockMvc, productCatalogUseCases );
17:     }
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingBasketRESTHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import com.fasterxml.jackson.databind.ObjectMapper;
5: import lombok.AllArgsConstructor;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import lombok.Setter;
9: import lombok.extern.slf4j.Slf4j;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.MvcResult;
12: import org.springframework.test.web.servlet.ResultActions;
13: import org.springframework.test.web.servlet.ResultMatcher;
14: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
15: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
18: 
19: import java.util.Map;
20: import java.util.UUID;
21: 
22: import static org.springframework.http.MediaType.APPLICATION_JSON;
23: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
24: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
25: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
26: 
27: @Slf4j
28: public class ShoppingBasketRESTHelperImpl implements ShoppingBasketRESTHelper {
29:     private MockMvc mockMvc;
30:     private ProductCatalogUseCases productCatalogUseCases;
31: 
32:     private static final ResultMatcher CREATED = status().isCreated();
33:     private static final ResultMatcher OK = status().isOk();
34: 
35:     public ShoppingBasketRESTHelperImpl( MockMvc mockMvc, ProductCatalogUseCases productCatalogUseCases ) {
36:         this.mockMvc = mockMvc;
37:         this.productCatalogUseCases = productCatalogUseCases;
38:     }
39: 
40: 
41:     @Override
42:     public UUID getQueryShoppingBasket( EmailAddressType emailAddress, Map<UUID, Integer> quantityMap )
43:             throws Exception {
44:         // first query the customers API to get the proper customerId
45:         UUID customerId;
46:         String customerUri = "/customers?emailAddress=" + emailAddress.toString();
47:         MvcResult customerGetResult = mockMvc.perform( get( customerUri ) )
48:                 .andExpect( status().isOk() )
49:                 .andReturn();
50:         ObjectMapper objectMapper = new ObjectMapper();
51:         IdDTO idDTO = objectMapper.readValue( customerGetResult.getResponse().getContentAsString(), IdDTO.class );
52:         customerId = idDTO.getId();
53: 
54:         // then query the shopping basket API and extract the shopping basket id
55:         String shoppingBasketUri = "/shoppingBaskets?customerId=" + customerId.toString();
56:         ResultActions resultActions = mockMvc.perform( get( shoppingBasketUri ) )
57:                 .andExpect( status().isOk() );
58:         idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
59:         UUID shoppingBasketId = idDTO.getId();
60: 
61:         // additional checks, if desired
62:         if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
63:         return shoppingBasketId;
64:     }
65: 
66: 
67:     private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
68:         if ( quantityMap == null ) return;
69:         int numOfProducts = quantityMap.size();
70:         resultActions.andExpect( jsonPath( "$.parts.length()" ).value( numOfProducts ) );
71:         float totalSellingPriceAsFloat = 0f;
72:         for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
73:             UUID productId = entry.getKey();
74:             Integer quantity = entry.getValue();
75:             resultActions.andExpect( jsonPath( "$.parts.[?(@.productId == '" + productId + "')].quantity" )
76:                     .value( quantity ) );
77:             MoneyType sellingPrice = productCatalogUseCases.getSellingPrice( productId );
78:             totalSellingPriceAsFloat += sellingPrice.getAmount() * quantity;
79:         }
80:         // last thing - check the total selling price
81:         String totalSellingPriceString = String.format( "%.2f €", totalSellingPriceAsFloat );
82:         resultActions
83:                 .andExpect( jsonPath( "$.totalSellingPrice" ).value( totalSellingPriceString ) );
84:     }
85: 
86: 
87:     @Override
88:     public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity )
89:             throws Exception {
90:         addProductToShoppingBasket( shoppingBasketId, productId, quantity, null );
91:     }
92: 
93: 
94:     @Override
95:     public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity,
96:                                                   ResultMatcher expectedStatus ) throws Exception {
97:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
98:         ObjectMapper objectMapper = new ObjectMapper();
99:         QuantityDTO dto = new QuantityDTO( productId, quantity );
100:         String quantityJson = objectMapper.writeValueAsString( dto );
101:         mockMvc.perform( post( "/shoppingBaskets/" + shoppingBasketId + "/parts" )
102:                         .contentType( APPLICATION_JSON ).content( quantityJson ) )
103:                 .andExpect( status );
104:     }
105: 
106: 
107: 
108:     @Override
109:     public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId )
110:             throws Exception {
111:         deleteProductFromShoppingBasket( shoppingBasketId, productId, null );
112:     }
113: 
114: 
115: 
116:     @Override
117:     public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId,
118:                                                       ResultMatcher expectedStatus ) throws Exception {
119:         ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
120:         String uri = "/shoppingBaskets/" + shoppingBasketId + "/parts/" + productId;
121:         mockMvc.perform( delete( uri ) ).andExpect( status );
122:     }
123: 
124: 
125:     @Override
126:     public void checkout( UUID shoppingBasketId, String expectedCustomerName,
127:                           ResultMatcher expectedStatus,
128:                           Map<UUID, Map<UUID, Integer>> expectedOrders ) throws Exception {
129:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
130:         String uri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
131:         MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
132:         ObjectMapper objectMapper = new ObjectMapper();
133: 
134:         // check the response content
135:         if ( expectedOrders != null || expectedCustomerName != null ) {
136:             String responseContent = result.getResponse().getContentAsString();
137:             log.info( "ShoppingBasketRESTHelperImpl - checkout: found response content " + responseContent );
138:             OrderDTO[] orders = objectMapper.readValue( responseContent, OrderDTO[].class );
139:             checkExpectedCustomerName( expectedCustomerName, orders );
140:             checkExpectedOrders( expectedOrders, orders );
141:         }
142:     }
143: 
144: 
145:     private void checkExpectedCustomerName( String expectedCustomerName, OrderDTO[] orders ) {
146:         if ( expectedCustomerName == null ) return;
147:         for ( OrderDTO order : orders ) {
148:             if ( !order.getCustomerName().equals( expectedCustomerName ) ) {
149:                 throw new AssertionError( "Expected customerName '" + expectedCustomerName +
150:                         "' but got '" + order.getCustomerName() + "'" );
151:             }
152:         }
153:     }
154: 
155: 
156:     private void checkExpectedOrders( Map<UUID, Map<UUID, Integer>> expectedOrders,
157:                                             OrderDTO[] orders ) {
158:         if ( expectedOrders == null ) return;
159:         for ( OrderDTO order : orders ) {
160:             UUID storageUnitId = order.getStorageUnitId();
161:             Map<UUID, Integer> expectedQuantities = expectedOrders.get( storageUnitId );
162:             if ( expectedQuantities == null ) {
163:                 throw new AssertionError( "No expected quantities for storage unit " + storageUnitId );
164:             }
165:             QuantityDTO[] parts = order.getParts();
166:             for ( QuantityDTO quantityDTO : parts ) {
167:                 UUID productId = quantityDTO.getProductId();
168:                 Integer expectedQuantity = expectedQuantities.get( productId );
169:                 if ( expectedQuantity == null ) {
170:                     throw new AssertionError( "No expected quantity for product " + productId +
171:                             " in storage unit " + storageUnitId );
172:                 }
173:                 if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
174:                     throw new AssertionError( "Expected quantity " + expectedQuantity + " for product " +
175:                             productId + " in storage unit " + storageUnitId +
176:                             ", but got " + quantityDTO.getQuantity() );
177:                 }
178:             }
179:         }
180:     }
181: 
182: 
183:     /**
184:      * A DTO containing just a quantity, used in testing.
185:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
186:      * Therefore, constructors and getters/setters are manually defined.
187:      */
188:     @NoArgsConstructor
189:     @JsonIgnoreProperties(ignoreUnknown = true)
190:     private static class QuantityDTO {
191:         private UUID productId;
192:         private Integer quantity;
193: 
194:         public QuantityDTO( UUID productId, Integer quantity ) {
195:             this.productId = productId;
196:             this.quantity = quantity;
197:         }
198:         public UUID getProductId() {
199:             return productId;
200:         }
201:         public Integer getQuantity() {
202:             return quantity;
203:         }
204:         public void setProductId( UUID productId ) {
205:             this.productId = productId;
206:         }
207:         public void setQuantity( Integer quantity ) {
208:             this.quantity = quantity;
209:         }
210:     }
211: 
212: 
213:     /**
214:      * A DTO containing just the id of an entity, used in testing.
215:      */
216:     @AllArgsConstructor
217:     @NoArgsConstructor
218:     @Getter
219:     @Setter
220:     @JsonIgnoreProperties(ignoreUnknown = true)
221:     private static class IdDTO {
222:         private UUID id;
223:     }
224: 
225: 
226:     /**
227:      * A DTO containing the order data, used in testing.
228:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
229:      * Therefore, constructors and getters/setters are manually defined.
230:      */
231:     @NoArgsConstructor
232:     @JsonIgnoreProperties(ignoreUnknown = true)
233:     private static class OrderDTO {
234:         private UUID id;
235:         private String customerName;
236:         private UUID storageUnitId;
237:         private QuantityDTO[] parts;
238: 
239:         public UUID getId() {
240:             return id;
241:         }
242:         public String getCustomerName() {
243:             return customerName;
244:         }
245:         public UUID getStorageUnitId() {
246:             return storageUnitId;
247:         }
248:         public QuantityDTO[] getParts() {
249:             return parts;
250:         }
251:         public void setId( UUID id ) {
252:             this.id = id;
253:         }
254:         public void setCustomerName( String customerName ) {
255:             this.customerName = customerName;
256:         }
257:         public void setStorageUnitId( UUID storageUnitId ) {
258:             this.storageUnitId = storageUnitId;
259:         }
260:         public void setParts( QuantityDTO[] parts ) {
261:             this.parts = parts;
262:         }
263:     }
264: 
265: }
266: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingBasketRESTHelper.java ---
1: package thkoeln.archilab.ecommerce.helpers;
2: 
3: import org.springframework.test.web.servlet.ResultMatcher;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
5: 
6: import java.util.Map;
7: import java.util.UUID;
8: 
9: /**
10:  * A REST helper for shopping basket-related operations.
11:  * This interface defines methods to interact with a shopping basket via REST calls, such as querying, adding,
12:  * deleting, and checking out.
13:  */
14: public interface ShoppingBasketRESTHelper {
15:     /**
16:      * Executes a REST GET query on a shopping basket and returns its id, with the customer's email address as a
17:      * starting point. The resulting shopping basket is checked against the given expected quantity map.
18:      * @param emailAddress The emailAddress of the customer whose shopping basket is queried.
19:      * @param expectedQuantityMap A map of products and their quantities in the shopping basket. (If null, then don't check.)
20:      * @return The id of the customer's shopping basket.
21:      * @throws Exception (whenever the REST call fails, or the shopping basket does not match the expected quantity map)
22:      */
23:     public UUID getQueryShoppingBasket( EmailAddressType emailAddress,
24:                                        Map<UUID, Integer> expectedQuantityMap ) throws Exception;
25: 
26: 
27:     /**
28:      * Adds a product to a shopping basket via a REST call.
29:      * @param shoppingBasketId Id of the shopping basket.
30:      * @param productId Id of the product.
31:      * @param quantity Quantity of the product.
32:      * @throws Exception (whenever the REST call fails)
33:      */
34:     public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity )
35:             throws Exception;
36: 
37: 
38:     /**
39:      * Adds a product to a shopping basket via a REST call.
40:      * @param shoppingBasketId Id of the shopping basket.
41:      * @param productId Id of the product.
42:      * @param quantity Quantity of the product.
43:      * @param expectedStatus expected status of the operation (null = CREATED)
44:      * @throws Exception (whenever the REST call fails or the status does not match)
45:      */
46:     public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity,
47:                                                   ResultMatcher expectedStatus ) throws Exception;
48: 
49: 
50:     /**
51:      * Deletes a product from a shopping basket via a REST call.
52:      * @param shoppingBasketId Id of the shopping basket.
53:      * @param productId Id of the product.
54:      * @throws Exception (whenever the REST call fails)
55:      */
56:     public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId )
57:             throws Exception;
58: 
59: 
60:     /**
61:      * Deletes a product from a shopping basket via a REST call.
62:      * @param shoppingBasketId Id of the shopping basket.
63:      * @param productId Id of the product.
64:      * @param expectedStatus expected status of the operation (null = OK)
65:      * @throws Exception (whenever the REST call fails or the status does not match)
66:      */
67:     public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId,
68:                                                       ResultMatcher expectedStatus ) throws Exception;
69: 
70: 
71:     /**
72:      * Checks out a shopping basket via REST call, and returns the id of the created order.
73:      * @param shoppingBasketId
74:      * @param expectedCustomerName expected name of the customer who owns the shopping basket (null = don't check)
75:      * @param expectedStatus expected status of the operation (null = don't check)
76:      * @param expectedOrders the expected orders to be created as a result of the checkout. This is
77:      *                            a map of the following form:
78:      *                            <pre>
79:      *                               storageUnitId -> Map<productId,Integer>
80:      *                            </pre>
81:      *                            where the inner map contains the products and their quantities
82:      * @return
83:      * @throws Exception
84:      */
85:     public void checkout( UUID shoppingBasketId, String expectedCustomerName,
86:                           ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedOrders )
87:            throws Exception;
88: }
89: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\customer\CustomerRegistrationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.customer;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
12: import thkoeln.archilab.ecommerce.usecases.CustomerType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
15: 
16: import static org.junit.jupiter.api.Assertions.*;
17: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
18: 
19: 
20: @SpringBootTest
21: public class CustomerRegistrationTest {
22:     @Autowired
23:     private CustomerRegistrationUseCases customerRegistrationUseCases;
24:     @Autowired
25:     private Purgatory purgatory;
26:     @Autowired
27:     private CustomerTestHelper customerTestHelper;
28: 
29:     private EmailAddressType nonExistingEmailAddress;
30:     private AddressType someAddress;
31: 
32:     @BeforeEach
33:     public void setUp() {
34:         purgatory.deleteEverything();
35:         nonExistingEmailAddress = instantiateEmailAddress( "this@nononono.de" );
36:         someAddress = instantiateAddress( "Some Street", "Some City",
37:                 instantiateZipCode( "90001" ) );
38:     }
39: 
40:     @Test
41:     public void testAllCustomersRegistered() {
42:         // given
43:         customerTestHelper.registerAllCustomers();
44:         EmailAddressType emailAddress3 =
45:                 customerTestHelper.getCustomerEmailAddress( 3 );
46:         String name3 = customerTestHelper.getCustomerName( 3 );
47:         AddressType address3 = customerTestHelper.getCustomerAddress( 3 );
48: 
49:         // when
50:         CustomerType customer3 = customerRegistrationUseCases.getCustomerData(
51:                 emailAddress3 );
52: 
53:         // then
54:         Assertions.assertEquals( name3, customer3.getName() );
55:         Assertions.assertEquals( emailAddress3, customer3.getEmailAddress() );
56:         Assertions.assertEquals( address3, customer3.getAddress() );
57:     }
58: 
59: 
60:     @Test
61:     public void testRegisterCustomerWithDuplicateEmailAddress() {
62:         // given
63:         customerTestHelper.registerAllCustomers();
64:         AddressType address5 = customerTestHelper.getCustomerAddress( 5 );
65:         EmailAddressType emailAddress5 =
66:                 customerTestHelper.getCustomerEmailAddress( 5 );
67: 
68:         // when
69:         // then
70:         assertThrows( ShopException.class, () ->
71:                 customerRegistrationUseCases.register( "Gandalf The Grey",
72:                         emailAddress5, address5 ) );
73:     }
74: 
75: 
76:     @Test
77:     public void testRegisterCustomerWithDuplicateNameOrAddress() {
78:         // given
79:         customerTestHelper.registerAllCustomers();
80:         EmailAddressType newEmailAddress =
81:                 instantiateEmailAddress( "some@this.de" );
82:         AddressType address2 = customerTestHelper.getCustomerAddress( 2 );
83:         String name2 = customerTestHelper.getCustomerName( 2 );
84: 
85:         // when
86:         // then
87:         assertDoesNotThrow( () ->
88:                 customerRegistrationUseCases.register( name2, newEmailAddress, address2 ) );
89:     }
90: 
91: 
92:     @Test
93:     public void testRegisterCustomerWithInvalidData() {
94:         // given
95:         EmailAddressType emailAddress5 =
96:                 customerTestHelper.getCustomerEmailAddress( 5 );
97:         AddressType address5 = customerTestHelper.getCustomerAddress( 5 );
98:         String name5 = customerTestHelper.getCustomerName( 5 );
99: 
100:         // when
101:         // then
102:         assertThrows( ShopException.class, () ->
103:                 customerRegistrationUseCases.register( null, emailAddress5, address5 ) );
104:         assertThrows( ShopException.class, () ->
105:                 customerRegistrationUseCases.register("", emailAddress5, address5 ) );
106:         assertThrows( ShopException.class, () ->
107:                 customerRegistrationUseCases.register( name5, null, address5 ) );
108:         assertThrows( ShopException.class, () ->
109:                 customerRegistrationUseCases.register( name5, emailAddress5, null ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testChangeAddressWithInvalidData() {
115:         // given
116:         customerTestHelper.registerAllCustomers();
117:         AddressType address7 = customerTestHelper.getCustomerAddress( 7 );
118:         EmailAddressType emailAddress7 =
119:                 customerTestHelper.getCustomerEmailAddress( 7 );
120: 
121:         // when
122:         // then
123:         assertThrows( ShopException.class, () ->
124:                 customerRegistrationUseCases.changeAddress( nonExistingEmailAddress, address7 ) );
125:         assertThrows( ShopException.class, () ->
126:                 customerRegistrationUseCases.changeAddress( null, address7 ) );
127:         assertThrows( ShopException.class, () ->
128:                 customerRegistrationUseCases.changeAddress( emailAddress7, null ) );
129:     }
130: 
131: 
132:     @Test
133:     public void testGetDataForNonexistingEmailAddress() {
134:         // given
135:         customerTestHelper.registerAllCustomers();
136: 
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 customerRegistrationUseCases.getCustomerData( nonExistingEmailAddress ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testDeleteCustomersNoMoreCustomers() {
146:         // given
147:         customerTestHelper.registerAllCustomers();
148:         EmailAddressType emailAddress0 =
149:                 customerTestHelper.getCustomerEmailAddress( 0 );
150: 
151: 
152:         // when
153:         customerRegistrationUseCases.deleteAllCustomers();
154: 
155:         // then
156:         assertThrows( ShopException.class, () -> customerRegistrationUseCases.getCustomerData(
157:                 emailAddress0 ) );
158:     }
159: 
160: 
161:     @Test
162:     public void testChangeAddressSuccessful() {
163:         // given
164:         customerTestHelper.registerAllCustomers();
165:         EmailAddressType emailAddress6 =
166:                 customerTestHelper.getCustomerEmailAddress( 6 );
167: 
168:         // when
169:         customerRegistrationUseCases.changeAddress( emailAddress6, someAddress );
170:         CustomerType newCustomer6 =
171:                 customerRegistrationUseCases.getCustomerData( emailAddress6 );
172: 
173:         // then
174:         Assertions.assertEquals( emailAddress6, newCustomer6.getEmailAddress() );
175:         Assertions.assertEquals( someAddress, newCustomer6.getAddress() );
176:     }
177: 
178: 
179:     @Test
180:     public void testChangeAddressForNonexistingEmailAddress() {
181:         // given
182:         customerTestHelper.registerAllCustomers();
183: 
184:         // when
185:         // then
186:         assertThrows( ShopException.class, () ->
187:                 customerRegistrationUseCases.changeAddress( nonExistingEmailAddress, someAddress ) );
188:     }
189: 
190: 
191: }
192: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\customer\CustomerRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.customer;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
12: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
13: import thkoeln.archilab.ecommerce.usecases.CustomerType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
16: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
17: 
18: import java.util.UUID;
19: 
20: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
21: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
22: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
23: 
24: @SpringBootTest
25: @Transactional
26: @AutoConfigureMockMvc
27: @Import( RESTTestHelperConfiguration.class )
28: public class CustomerRESTTest {
29:     @Autowired
30:     private CustomerRegistrationUseCases customerRegistrationUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private CustomerTestHelper customerTestHelper;
35:     @Autowired
36:     private MockMvc mockMvc;
37: 
38:     private UUID randomId;
39:     private EmailAddressType nonExistingEmailAddress;
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         customerTestHelper.registerAllCustomers();
45: 
46:         nonExistingEmailAddress = FactoryMethodInvoker.instantiateEmailAddress(
47:                 "harry@sally.de" );
48:         randomId = UUID.randomUUID();
49:     }
50: 
51: 
52:     @Test
53:     public void testInvalidCustomerUris() throws Exception {
54:         // given
55:         String allCustomersUri = "/customers";
56:         String randomIdUri = "/customers/" +  randomId;
57:         String nonExistingEmailAddressUri = "/customers?emailAddress=" + nonExistingEmailAddress;
58:         String randomParamUri = "/customers?randomParam=randomValue";
59: 
60:         // when
61:         // then
62:         mockMvc.perform( get( allCustomersUri ) ).andExpect( status().isMethodNotAllowed() );
63:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
64:         mockMvc.perform( get( nonExistingEmailAddressUri ) ).andExpect( status().isNotFound() );
65:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
66:     }
67: 
68: 
69:     @Test
70:     public void testRandomCustomerId() throws Exception {
71:         // given
72:         String invalidUri = "/customers/" +  randomId;
73: 
74:         // when
75:         // then
76:         mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
77:     }
78: 
79: 
80:     @Test
81:     public void testQueryCustomer() throws Exception {
82:         // given
83:         EmailAddressType emailAddress4 =
84:                 customerTestHelper.getCustomerEmailAddress( 4 );
85:         String customerUri4 = "/customers?emailAddress=" + emailAddress4;
86: 
87:         // when
88:         CustomerType customer4 = customerRegistrationUseCases.getCustomerData( emailAddress4 );
89:         String name = customerTestHelper.getCustomerName( 4 );
90:         AddressType address4 = customerTestHelper.getCustomerAddress( 4 );
91: 
92:         // then (check using JSONPath)
93:         mockMvc.perform( get( customerUri4 ) )
94:                 .andExpect( status().isOk() )
95:                 .andExpect( jsonPath( "$.name" ).value( name ) )
96:                 // id is position 0 (cannot be tested with current API structure), name is position 1,
97:                 // email address is 2, address is 3)
98:                 .andExpect( jsonPath( "$..emailAddressString" ).value( emailAddress4.toString() ) )
99:                 .andExpect( jsonPath( "$..city" ).value( address4.getCity() ) )
100:                 .andExpect( jsonPath( "$..zipCodeString" ).value(
101:                         address4.getZipCode().toString() ) );
102:     }
103: 
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class BasicNoOutsideSolutionRulesTest {
14: 
15:     @ArchTest
16:     static final ArchRule noClassesOnTopLevel =
17:             classes().should().resideInAPackage( "..solution.*.." )
18:                     .allowEmptyShould( true );
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.library.Architectures.layeredArchitecture;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln")
12: @SuppressWarnings("PMD")
13: public class BasicProperDependenciesTest {
14: 
15:     @ArchTest
16:     static final ArchRule properDependencies =
17:             layeredArchitecture()
18:                     .consideringAllDependencies()
19:                     //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
20:                     .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
21:                     .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )
22: 
23:                     //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
24:                     .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
25:                     .allowEmptyShould( true );
26: }
27: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
5: import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
6: import org.springframework.core.type.classreading.MetadataReader;
7: import org.springframework.core.type.classreading.MetadataReaderFactory;
8: 
9: import java.io.IOException;
10: import java.util.Arrays;
11: import java.util.HashSet;
12: import java.util.Set;
13: 
14: import static org.junit.jupiter.api.Assertions.assertTrue;
15: 
16: public class BasicRequiredClassesTest {
17:     private static final String[] REQUIRED_CLASSES = {
18:             "Customer",
19:             "CustomerRepository",
20:             "Product",
21:             "ProductRepository",
22:             "Order",
23:             "OrderRepository",
24:             "StockLevel",
25:             "ShoppingBasket",
26:             "ShoppingBasketRepository",
27:             "StorageUnitRepository",
28:             "ShoppingBasketPart",
29:             "OrderPart",
30:             "StorageUnit",
31:     };
32: 
33:     @Test
34:     public void testRequiredClassesDeclared() throws IOException {
35:         String basePackage = "thkoeln.archilab.ecommerce";
36:         String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";
37: 
38:         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
39:         MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );
40: 
41:         Set<String> foundClasses = new HashSet<>();
42: 
43:         Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
44:             try {
45:                 MetadataReader reader = readerFactory.getMetadataReader( resource );
46:                 foundClasses.add( reader.getClassMetadata().getClassName() );
47:             } catch (IOException e) {
48:                 e.printStackTrace();
49:             }
50:         } );
51: 
52:         Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
53:             boolean found = foundClasses.stream().anyMatch(className ->
54:                     className.startsWith(basePackage) && className.endsWith("." + requiredClass)
55:             );
56:             assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
57:         });
58:     }
59: }
60: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.boot.test.context.SpringBootTest;
6: import org.springframework.context.ApplicationContext;
7: 
8: import java.util.Arrays;
9: import java.util.HashMap;
10: import java.util.List;
11: import java.util.Map;
12: 
13: import static org.junit.jupiter.api.Assertions.*;
14: 
15: @SpringBootTest
16: public class BasicUseCaseImplementationPackageTest {
17: 
18:     @Autowired
19:     private ApplicationContext applicationContext;
20: 
21:     private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
22:         put("CustomerRegistrationUseCases", Arrays.asList("customer"));
23:         put("StorageUnitUseCases", Arrays.asList("storageunit"));
24:         put("ProductCatalogUseCases", Arrays.asList("product"));
25:         put("ShoppingBasketUseCases", Arrays.asList("shoppingbasket"));
26:         put("OrderUseCases", Arrays.asList("order"));
27:     }};
28:     private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
29:     private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";
30: 
31:     @Test
32:     public void testRequiredClassesDeclared() {
33:         for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
34:             String interfaceName = USECASE_PATH + "." + entry.getKey();
35:             List<String> correctTopLevelPackages = entry.getValue();
36:             Class<?> useCaseInterfaceClass = null;
37:             try {
38:                 useCaseInterfaceClass = Class.forName( interfaceName );
39:             } catch (ClassNotFoundException e) {
40:                 fail( "Use case interface " + interfaceName + " not found.", e );
41:                 continue;
42:             }
43:             String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
44:             assertEquals( 1, beans.length,
45:                     "There should be exactly 1 service implementation for the interface " +
46:                             entry.getKey() + ", but found " + beans.length );
47:             Object bean = applicationContext.getBean( beans[0] );
48:             boolean isValid = false;
49:             for ( String correctTopLevelPackage : correctTopLevelPackages ) {
50:                 String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
51:                 if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
52:                     isValid = true;
53:                     break;
54:                 }
55:             }
56:             assertTrue( isValid,
57:                     "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
58:                             + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
59:         }
60:     }
61: }
62: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: import org.springframework.data.repository.CrudRepository;
8: import org.springframework.stereotype.Service;
9: 
10: import jakarta.persistence.Entity;
11: import org.springframework.web.bind.annotation.RestController;
12: 
13: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
14: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
15: 
16: @ArchTag("layerRules")
17: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
18: @SuppressWarnings("PMD")
19: public class DDDRulesTest {
20: 
21:     @ArchTest
22:     static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
23:             noClasses().that().resideInAPackage( "..domain.." )
24:                     .should().dependOnClassesThat().resideInAPackage( "..application.." )
25:                     .allowEmptyShould( true );
26: 
27:     @ArchTest
28:     static final ArchRule entitiesMustResideInADomainPackage =
29:             classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
30:                     .as( "Entities must reside in a package '..domain..'" )
31:                     .allowEmptyShould( true );
32: 
33:     @ArchTest
34:     static final ArchRule entitiesMustNotAccessRepositories =
35:             noClasses().that().areAnnotatedWith( Entity.class )
36:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
37:                     .allowEmptyShould( true );
38: 
39:     @ArchTest
40:     static final ArchRule repositoriesMustResideInADomainPackage =
41:             classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
42:                     .as( "Repositories must reside in a package '..domain..'" )
43:                     .allowEmptyShould( true );
44: 
45:     @ArchTest
46:     static final ArchRule repositoryNamesMustHaveProperSuffix =
47:             classes().that().areAssignableTo( CrudRepository.class )
48:                     .should().haveSimpleNameEndingWith( "Repository" )
49:                     .allowEmptyShould( true );
50: 
51:     @ArchTest
52:     static final ArchRule servicesMustResideInAnApplicationPackage =
53:             classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
54:                     .as( "Application Services must reside in a package '..application..'" )
55:                     .allowEmptyShould( true );
56: 
57:     @ArchTest
58:     static final ArchRule serviceNamesMustHaveProperSuffix =
59:             classes().that().areAnnotatedWith( Service.class )
60:                     .should().haveSimpleNameEndingWith( "Service" )
61:                     .allowEmptyShould( true );
62: 
63:     @ArchTest
64:     static final ArchRule controllersMustResideInAnApplicationPackage =
65:             classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
66:                     .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );
67: 
68:     @ArchTest
69:     static final ArchRule controllersNamesMustHaveProperSuffix =
70:             classes().that().areAnnotatedWith( RestController.class )
71:                     .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );
72: 
73:     @ArchTest
74:     static final ArchRule controllersMustNotAccessRepositories =
75:             noClasses().that().areAnnotatedWith( RestController.class )
76:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
77:                     .allowEmptyShould( false );
78: }
79: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.importer.ClassFileImporter;
6: import com.tngtech.archunit.lang.ArchRule;
7: import com.tngtech.archunit.library.dependencies.SliceAssignment;
8: import com.tngtech.archunit.library.dependencies.SliceIdentifier;
9: import org.junit.jupiter.api.Test;
10: 
11: import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
12: 
13: public class NoCycleTest {
14:     private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");
15: 
16:     private SliceAssignment inAllClasses() {
17:         return new SliceAssignment() {
18:             @Override
19:             public String getDescription() {
20:                 return "every class in it's own slice";
21:             }
22: 
23:             @Override
24:             public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
25:                 return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
26:             }
27:         };
28:     }
29: 
30:     @Test
31:     public void testNoCyclicDependenciesBetweenClasses() {
32:         slices().assignedFrom(inAllClasses())
33:                 .namingSlices("$1[$2.$3]")
34:                 .should().beFreeOfCycles()
35:                 .check(importedClasses);
36:     }
37: 
38:     @Test
39:     public void testNoCyclicDependenciesBetweenPackages() {
40:         ArchRule rule = slices().matching("..solution.(*)..")
41:                 .should().beFreeOfCycles().allowEmptyShould( true );
42:         rule.check(importedClasses);
43:     }
44: }
45: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.base.DescribedPredicate;
4: import com.tngtech.archunit.core.domain.JavaClass;
5: import com.tngtech.archunit.core.domain.JavaField;
6: import com.tngtech.archunit.core.domain.JavaParameterizedType;
7: import com.tngtech.archunit.core.domain.JavaType;
8: import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
9: import com.tngtech.archunit.junit.AnalyzeClasses;
10: import com.tngtech.archunit.junit.ArchTag;
11: import com.tngtech.archunit.junit.ArchTest;
12: import com.tngtech.archunit.lang.ArchCondition;
13: import com.tngtech.archunit.lang.ArchRule;
14: import com.tngtech.archunit.lang.ConditionEvents;
15: import com.tngtech.archunit.lang.SimpleConditionEvent;
16: import jakarta.persistence.*;
17: import lombok.extern.slf4j.Slf4j;
18: import thkoeln.archilab.ecommerce.GenericId;
19: 
20: import java.util.List;
21: 
22: import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
23: import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
24: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;
25: 
26: @ArchTag("layerRules")
27: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
28: @SuppressWarnings("PMD")
29: @Slf4j
30: public class OnlyReferenceViaIDTest { //STORAGE_UNIT
31:     private static final String SHOPPING_BASKET_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingbasket.domain";
32:     private static final String CUSTOMER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.customer.domain";
33:     private static final String PRODUCT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.product.domain";
34:     private static final String ORDER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.order.domain";
35:     private static final String STORAGE_UNIT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.storageunit.domain";
36: 
37:     @ArchTest
38:     static final ArchRule idFieldsMustUseGenericId =
39:             fields()
40:                     .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
41:                     .and().areAnnotatedWith( Id.class )
42:                     .should().haveRawType( assignableTo( GenericId.class ) )
43:                     .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
44:                     .allowEmptyShould( true );
45: 
46: 
47:     private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
48:             annotatedWith( ManyToOne.class )
49:                     .or( annotatedWith( OneToOne.class ) )
50:                     .or( annotatedWith( Embedded.class ) )
51:                     .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );
52: 
53:     private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
54:             annotatedWith( OneToMany.class )
55:                     .or( annotatedWith( ManyToMany.class ) )
56:                     .or( annotatedWith( ElementCollection.class ) )
57:                     .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );
58: 
59: 
60:     private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
61:         String description = "an entity or value object from same aggregate, or a domain primitive";
62:         return new DescribedPredicate<>( description ) {
63:             @Override
64:             public boolean test( JavaClass type ) {
65:                 // check if the class is an entity or value object, and resides in the allowed package
66:                 if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
67:                     return false;
68:                 }
69:                 // a GenericId is always allowed
70:                 if ( type.isAssignableTo( GenericId.class ) ) {
71:                     return true;
72:                 }
73:                 // a domain primitive is also always allowed
74:                 if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
75:                     return true;
76:                 }
77:                 return type.getPackageName().startsWith( allowedPackage );
78:             }
79:         };
80:     }
81: 
82: 
83:     @ArchTest
84:     static final ArchRule shoppingBasketToOneReferences =
85:             fields()
86:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
87:                     .and( isToOneAnnotation )
88:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) ) )
89:                     .allowEmptyShould( true );
90: 
91:     @ArchTest
92:     static final ArchRule customerToOneReferences =
93:             fields()
94:                     .that().areDeclaredInClassesThat().resideInAPackage( CUSTOMER_DOMAIN_PACKAGE )
95:                     .and( isToOneAnnotation )
96:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( CUSTOMER_DOMAIN_PACKAGE ) ) )
97:                     .allowEmptyShould( true );
98: 
99:     @ArchTest
100:     static final ArchRule productToOneReferences =
101:             fields()
102:                     .that().areDeclaredInClassesThat().resideInAPackage( PRODUCT_DOMAIN_PACKAGE )
103:                     .and( isToOneAnnotation )
104:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( PRODUCT_DOMAIN_PACKAGE ) ) )
105:                     .allowEmptyShould( true );
106: 
107:     @ArchTest
108:     static final ArchRule orderToOneReferences =
109:             fields()
110:                     .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
111:                     .and( isToOneAnnotation )
112:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) ) )
113:                     .allowEmptyShould( true );
114: 
115:     @ArchTest
116:     static final ArchRule storageUnitToOneReferences =
117:             fields()
118:                     .that().areDeclaredInClassesThat().resideInAPackage( STORAGE_UNIT_DOMAIN_PACKAGE )
119:                     .and( isToOneAnnotation )
120:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( STORAGE_UNIT_DOMAIN_PACKAGE ) ) )
121:                     .allowEmptyShould( true );
122: 
123: 
124:     private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
125:         return new ArchCondition<JavaField>(
126:                 "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
127:             @Override
128:             public void check( JavaField field, ConditionEvents events ) {
129:                 JavaClass rawType = field.getRawType();
130:                 String rawTypeName = rawType.getFullName();
131:                 if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
132:                     events.add( SimpleConditionEvent.violated( field,
133:                             field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
134:                     return;
135:                 }
136:                 JavaType fieldType = field.getType();
137:                 if ( !( fieldType instanceof JavaParameterizedType ) ) {
138:                     events.add( SimpleConditionEvent.violated( field,
139:                             field.getFullName() + " is a raw List/Set without a type argument" ) );
140:                     return;
141:                 }
142:                 List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
143:                 if ( typeArguments.isEmpty() ) {
144:                     events.add( SimpleConditionEvent.violated( field,
145:                             field.getFullName() + " has no type arguments" ) );
146:                     return;
147:                 }
148:                 JavaType elementType = typeArguments.get( 0 );
149:                 if ( !( elementType instanceof JavaClass ) ) {
150:                     events.add( SimpleConditionEvent.violated( field,
151:                             field.getFullName() + " has an unknown element type" ) );
152:                     return;
153:                 }
154:                 JavaClass elementClass = (JavaClass) elementType;
155:                 boolean hasAnnotation =
156:                         elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
157:                 boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
158:                 boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
159:                 boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
160:                 boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
161:                 if ( !ok ) {
162:                     events.add( SimpleConditionEvent.violated( field,
163:                             field.getFullName() + " refers to " + elementClass.getFullName()
164:                                     + " which is not a DP, or an entity/value object in " + allowedPackage ) );
165:                 }
166:             }
167:         };
168:     }
169: 
170: 
171:     @ArchTest
172:     static final ArchRule shoppingBasketToManyReferences =
173:             fields()
174:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
175:                     .and( isToManyAnnotation )
176:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) )
177:                     .allowEmptyShould( true );
178: 
179:     @ArchTest
180:     static final ArchRule customerToManyReferences =
181:             fields()
182:                     .that().areDeclaredInClassesThat().resideInAPackage( CUSTOMER_DOMAIN_PACKAGE )
183:                     .and( isToManyAnnotation )
184:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( CUSTOMER_DOMAIN_PACKAGE ) )
185:                     .allowEmptyShould( true );
186: 
187:     @ArchTest
188:     static final ArchRule productToManyReferences =
189:             fields()
190:                     .that().areDeclaredInClassesThat().resideInAPackage( PRODUCT_DOMAIN_PACKAGE )
191:                     .and( isToManyAnnotation )
192:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( PRODUCT_DOMAIN_PACKAGE ) )
193:                     .allowEmptyShould( true );
194: 
195:     @ArchTest
196:     static final ArchRule orderToManyReferences =
197:             fields()
198:                     .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
199:                     .and( isToManyAnnotation )
200:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) )
201:                     .allowEmptyShould( true );
202: 
203:     @ArchTest
204:     static final ArchRule storageUnitToManyReferences =
205:             fields()
206:                     .that().areDeclaredInClassesThat().resideInAPackage( STORAGE_UNIT_DOMAIN_PACKAGE )
207:                     .and( isToManyAnnotation )
208:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( STORAGE_UNIT_DOMAIN_PACKAGE ) )
209:                     .allowEmptyShould( true );
210: 
211: }
212: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: /**
4:  * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
5:  */
6: 
7: public class OwnTestsTest {
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClasses;
4: import com.tngtech.archunit.core.importer.ClassFileImporter;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: 
8: import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
9: 
10: public class PackageStructureTest {
11: 
12:     private static final String[] REQUIRED_PACKAGES = {"customer", "shoppingbasket", "product", "order", "storageunit"};
13:     private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
14:     private JavaClasses importedClasses;
15: 
16: 
17:     @BeforeEach
18:     public void setUp() {
19:         importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
20:     }
21: 
22:     @Test
23:     void testRequiredPackagesAreThere() {
24:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
25:             String packageName = BASE_PACKAGE + "." + requiredPackage;
26:             assertThat( importedClasses.containPackage( packageName ) )
27:                     .as( "Expected package %s not found!", packageName )
28:                     .isTrue();
29:         }
30:     }
31: 
32:     @Test
33:     void testRequiredDomainPackagesAreThere() {
34:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
35:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
36:             assertThat( importedClasses.containPackage( packageName ) )
37:                     .as( "Expected domain sub-package %s not found!", packageName )
38:                     .isTrue();
39:         }
40:     }
41: 
42:     @Test
43:     void testRequiredApplicationPackagesAreThere() {
44:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
45:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
46:             assertThat( importedClasses.containPackage( packageName ) )
47:                     .as( "Expected application sub-package %s not found!", packageName )
48:                     .isTrue();
49:         }
50:     }
51: 
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\AddressTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateAddress;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
11: 
12: class AddressTest {
13: 
14:     @Test
15:     public void testGetterAddress() {
16:         // given
17:         String street = "Irgendeinestraße 42";
18:         String city = "Irgendeinestadt";
19:         ZipCodeType plz = instantiateZipCode( "12345" );
20: 
21:         // when
22:         AddressType instance = instantiateAddress( street, city, plz );
23: 
24:         // then
25:         assertEquals( street, instance.getStreet() );
26:         assertEquals( city, instance.getCity() );
27:         assertEquals( plz, instance.getZipCode() );
28:     }
29: 
30:     @Test
31:     public void testFactoryValidAddress() {
32:         // given
33:         String street = "Irgendeinestraße 42";
34:         String city = "Irgendeinestadt";
35:         ZipCodeType plz = instantiateZipCode( "12345" );
36: 
37:         // when
38:         // then
39:         assertDoesNotThrow( () -> instantiateAddress( street, city, plz ) );
40:     }
41: 
42:     @Test
43:     public void testFactoryInvalidAddress() {
44:         // given
45:         String street = "Irgendeinestraße 42";
46:         String city = "Irgendeinestadt";
47:         ZipCodeType plz = instantiateZipCode( "12345" );
48: 
49:         // when
50:         // then
51:         assertThrows( ShopException.class, () -> instantiateAddress( null, city, plz ) );
52:         assertThrows( ShopException.class, () -> instantiateAddress( "", city, plz ) );
53:         assertThrows( ShopException.class, () -> instantiateAddress( street, null, plz ) );
54:         assertThrows( ShopException.class, () -> instantiateAddress( street, "", plz ) );
55:         assertThrows( ShopException.class, () -> instantiateAddress( street, city, null ) );
56:     }
57: 
58:     @Test
59:     public void testEqualityAddress() {
60:         // given
61:         String street = "Irgendeinestraße 42";
62:         String city = "Irgendeinestadt";
63:         ZipCodeType plz = instantiateZipCode( "12345" );
64: 
65:         // when
66:         AddressType instance1 = instantiateAddress( street, city, plz );
67:         AddressType instance2 = instantiateAddress( street, city, plz );
68:         AddressType instance3 = instantiateAddress( "Anderestr. 12", city, plz );
69:         AddressType instance4 = instantiateAddress( street, "AndereStadt", plz );
70:         AddressType instance5 = instantiateAddress( street, city, instantiateZipCode( "54321" ) );
71: 
72:         // then
73:         assertEquals( instance1, instance2 );
74:         assertNotEquals( instance1, instance3 );
75:         assertNotEquals( instance1, instance4 );
76:         assertNotEquals( instance1, instance5 );
77:     }
78: 
79:     @Test
80:     public void testImmutabilityAddress() {
81:         // given
82:         String street = "Irgendeinestraße 42";
83:         String city = "Irgendeinestadt";
84:         ZipCodeType plz = instantiateZipCode( "12345" );
85: 
86:         // when
87:         AddressType instance = instantiateAddress( street, city, plz );
88: 
89:         // then
90:         try {
91:             instance.getClass().getMethod( "setStreet", String.class );
92:             fail( "setStreet method should not exist" );
93:         } catch (NoSuchMethodException e) {
94:             // Success: the object is immutable
95:         }
96:         try {
97:             instance.getClass().getMethod( "setCity", String.class );
98:             fail( "setCity method should not exist" );
99: 
100:         } catch (NoSuchMethodException e) {
101:             // Success: the object is immutable
102:         }
103:         try {
104:             instance.getClass().getMethod( "setZipCode", ZipCodeType.class );
105:             fail( "setZipCode method should not exist" );
106:         } catch (NoSuchMethodException e) {
107:             // Success: the object is immutable
108:         }
109:     }
110: }
111: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("domainPrimitivesUsageRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class DomainPrimitivesUsageRulesTest {
14:     private static final String EMAIL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.EmailAddress";
15:     private static final String MONEY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Money";
16:     private static final String ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Address";
17: 
18:     @ArchTest
19:     static final ArchRule customerShouldReferenceEmailAddress =
20:             classes()
21:                     .that().haveSimpleName( "Customer" )
22:                     .should().dependOnClassesThat().haveFullyQualifiedName( EMAIL_ADDRESS_CLASS )
23:                     .because( "Customer should use EmailAddress instead of String" );
24: 
25:     @ArchTest
26:     static final ArchRule customerShouldReferenceAddress =
27:             classes()
28:                     .that().haveSimpleName( "Customer" )
29:                     .should().dependOnClassesThat().haveFullyQualifiedName( ADDRESS_CLASS )
30:                     .because( "Customer should use Address instead of whatever else" );
31: 
32:     @ArchTest
33:     static final ArchRule storageUnitShouldReferenceAddress =
34:             classes()
35:                     .that().haveSimpleName( "StorageUnit" )
36:                     .should().dependOnClassesThat().haveFullyQualifiedName( ADDRESS_CLASS )
37:                     .because( "Customer should use Address instead of whatever else" );
38: 
39:     @ArchTest
40:     static final ArchRule productShouldReferenceMoney =
41:             classes()
42:                     .that().haveSimpleName( "Product" )
43:                     .should().dependOnClassesThat().haveFullyQualifiedName( MONEY_CLASS )
44:                     .because( "Product should use Money instead of float or whatever else" );
45: }
46: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\EmailAddressTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmailAddress;
10: 
11: class EmailAddressTest {
12: 
13:     @Test
14:     public void testToStringEmailAddress() {
15:         // given
16:         String input = "test@example.com";
17: 
18:         // when
19:         EmailAddressType instance = instantiateEmailAddress( input );
20: 
21:         // then
22:         assertEquals( input, instance.toString() );
23:     }
24: 
25:     @Test
26:     public void testEqualityEmailAddress() {
27:         // given
28:         // when
29:         EmailAddressType instance1 = instantiateEmailAddress( "test@example.com" );
30:         EmailAddressType instance2 = instantiateEmailAddress( "test@example.com" );
31:         EmailAddressType instance3 = instantiateEmailAddress( "different@example.com" );
32: 
33:         // then
34:         assertEquals( instance1, instance2 );
35:         assertNotEquals( instance1, instance3 );
36:     }
37: 
38:     @Test
39:     public void testImmutabilityEmailAddress() {
40:         // given
41:         // when
42:         EmailAddressType instance = instantiateEmailAddress( "test@example.com" );
43: 
44:         // then
45:         try {
46:             instance.getClass().getMethod( "setEmailAddress", String.class );
47:             fail( "setEmailAddress method should not exist" );
48:         } catch (NoSuchMethodException e) {
49:             // Success: the object is immutable
50:         }
51:     }
52: 
53: 
54: 
55:     @Test
56:     public void smokeTestForCopyConstructors() {
57:         // given
58:         EmailAddressType emailAddress =
59:                 instantiateEmailAddress( "peter.schmidt@web.de" );
60: 
61:         // when
62:         EmailAddressType emailAddressOtherIdentifyer =
63:                 emailAddress.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
64:         assertThrows( ShopException.class, () ->
65:                 emailAddress.sameDomainDifferentIdentifyer( "p...eter" ) );
66:         EmailAddressType emailAddressOtherDomain =
67:                 emailAddress.sameIdentifyerDifferentDomain( "web.ch" );
68:         assertThrows( ShopException.class, () ->
69:                 emailAddress.sameIdentifyerDifferentDomain( "web.edu" ) );
70: 
71:         // then
72:         assertEquals( "p.e.t.e.r@web.de", emailAddressOtherIdentifyer.toString() );
73:         assertEquals( "peter.schmidt@web.ch", emailAddressOtherDomain.toString() );
74:     }
75: 
76: 
77:     @Test
78:     public void testFactoryValidEmailAddress() {
79:         // given
80:         // when
81:         // then
82:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.com" ) );
83:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "99Z@example.com" ) );
84:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "GGGhh@s77.com" ) );
85:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "a@4.com" ) );
86:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "Max.Hammer@example.com" ) );
87:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "Max.Gideon.Hammer@example.com" ) );
88:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.this.com" ) );
89:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.de" ) );
90:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.at" ) );
91:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.ch" ) );
92:         Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.org" ) );
93:     }
94: 
95: 
96:     @Test
97:     public void testFactoryInvalidEmailAddress() {
98:         // given
99:         // when
100:         // then
101:         assertThrows( ShopException.class, () -> instantiateEmailAddress( null ) );
102:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "testexample.com" ) );
103:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@" ) );
104:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "@example.com" ) );
105:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "Max..Gideon.Hammer@example.com" ) );
106:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@examplecom" ) );
107:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example..com" ) );
108:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example@that.com" ) );
109:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test example@that.com" ) );
110:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test#example@that.com" ) );
111:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.biz" ) );
112:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.biz" ) );
113:         assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.42" ) );
114:     }
115: }
116: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\MoneyTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMoney;
9: 
10: class MoneyTest {
11: 
12:     @Test
13:     public void testGetAmountMoney() {
14:         // given
15:         Float inputAmount = 10.0f;
16: 
17:         // when
18:         MoneyType instance = instantiateMoney( inputAmount, "EUR" );
19: 
20:         // then
21:         assertEquals( inputAmount, instance.getAmount() );
22:     }
23: 
24:     @Test
25:     public void testGetCurrencyUnitMoney() {
26:         // given
27:         String inputCurrencyUnit = "EUR";
28: 
29:         // when
30:         MoneyType instance = instantiateMoney( 10.0f, inputCurrencyUnit );
31: 
32:         // then
33:         assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
34:     }
35: 
36:     @Test
37:     public void testAddToMoney() {
38:         // given
39:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
40:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
41:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
42: 
43:         // when
44:         MoneyType result12 = instance1.add( instance2 );
45:         MoneyType result13 = instance1.add( instance3 );
46: 
47:         // then
48:         assertEquals( 30.0f, result12.getAmount() );
49:         assertEquals( "EUR", result12.getCurrencyUnit() );
50:         assertEquals( 10.0f, result13.getAmount() );
51:         assertEquals( "EUR", result12.getCurrencyUnit() );
52:     }
53: 
54:     @Test
55:     public void testInvalidAddToMoney() {
56:         // given
57:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
58:         MoneyType instance2 = instantiateMoney( 20.0f, "CHF" );
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
63:     }
64: 
65:     @Test
66:     public void testSubtractFromMoney() {
67:         // given
68:         MoneyType instance1 = instantiateMoney( 30.0f, "EUR" );
69:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
70:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
71:         MoneyType instance4 = instantiateMoney( 30.0f, "EUR" );
72: 
73:         // when
74:         MoneyType result12 = instance1.subtract( instance2 );
75:         MoneyType result13 = instance1.subtract( instance3 );
76:         MoneyType result14 = instance1.subtract( instance4 );
77: 
78:         // then
79:         assertEquals( 10.0f, result12.getAmount() );
80:         assertEquals( "EUR", result12.getCurrencyUnit() );
81:         assertEquals( 30.0f, result13.getAmount() );
82:         assertEquals( "EUR", result13.getCurrencyUnit() );
83:         assertEquals( 0.0f, result14.getAmount() );
84:         assertEquals( "EUR", result14.getCurrencyUnit() );
85:     }
86: 
87:     @Test
88:     public void testInvalidSubtractFromMoney() {
89:         // given
90:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
91:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
92:         MoneyType instance3 = instantiateMoney( 5.0f, "CHF" );
93: 
94:         // when
95:         // then
96:         assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
97:         assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
98:     }
99: 
100:     @Test
101:     public void testMultiplyByMoney() {
102:         // given
103:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
104: 
105:         // when
106:         MoneyType result = instance.multiplyBy( 3 );
107: 
108:         // then
109:         assertEquals( 30.0f, result.getAmount() );
110:         assertEquals( "EUR", result.getCurrencyUnit() );
111:     }
112: 
113:     @Test
114:     public void testFactoryValidCurrencyUnitMoney() {
115:         // given
116:         // when
117:         // then
118:         assertDoesNotThrow( () -> instantiateMoney( 10.0f, "EUR" ) );
119:     }
120: 
121:     @Test
122:     public void testFactoryInvalidCurrencyUnitMoney() {
123:         // given
124:         // when
125:         // then
126:         assertThrows( ShopException.class, () -> instantiateMoney( -10.0f, "EUR" ) );
127:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, "USD" ) );
128:         assertThrows( ShopException.class, () -> instantiateMoney( null, "EUR" ) );
129:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, null ) );
130:     }
131: 
132:     @Test
133:     public void testLargerThanCurrencyUnitMoney() {
134:         // given
135:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
136:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
137:         MoneyType instance3 = instantiateMoney( 10.0f, "EUR" );
138:         MoneyType instance4 = instantiateMoney( 10.0f, "CHF" );
139: 
140:         // when
141:         // then
142:         assertTrue( instance2.largerThan( instance1 ) );
143:         assertFalse( instance1.largerThan( instance2 ) );
144:         assertFalse( instance1.largerThan( instance3 ) );
145:         assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
146:     }
147: 
148: 
149:     @Test
150:     public void testEqualityCurrencyUnitMoney() {
151:         // given
152:         // when
153:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
154:         MoneyType instance2 = instantiateMoney( 10.0f, "EUR" );
155:         MoneyType instance3 = instantiateMoney( 20.0f, "EUR" );
156: 
157:         // then
158:         assertEquals( instance1, instance2 );
159:         assertNotEquals( instance1, instance3 );
160:     }
161: 
162:     @Test
163:     public void testImmutabilityCurrencyUnitMoney() {
164:         // given
165:         // when
166:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
167: 
168:         // then
169:         try {
170:             instance.getClass().getMethod( "setAmount", Float.class );
171:             fail( "setAmount method should not exist" );
172:         } catch (NoSuchMethodException e) {
173:             // Success: the object is immutable
174:         }
175: 
176:         try {
177:             instance.getClass().getMethod( "setCurrencyUnit", String.class );
178:             fail( "setCurrencyUnit method should not exist" );
179:         } catch (NoSuchMethodException e) {
180:             // Success: the object is immutable
181:         }
182:     }
183: }
184: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\ZipCodeTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
8: 
9: import static org.junit.jupiter.api.Assertions.*;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
11: 
12: class ZipCodeTest {
13: 
14:     private String input1, input4;
15:     private ZipCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
16:             _04233, _02544, _99123, _56323, _79332;
17: 
18: 
19:     @BeforeEach
20:     public void setUp() {
21:         input1 = "12345";
22:         input4 = "49188";
23:         _12345 = FactoryMethodInvoker.instantiateZipCode( "12345" );
24:         _12345b = FactoryMethodInvoker.instantiateZipCode( "12345" );
25:         _23455 = FactoryMethodInvoker.instantiateZipCode( "23455" );
26:         _01234 = FactoryMethodInvoker.instantiateZipCode( "01234" );
27:         _01235 = FactoryMethodInvoker.instantiateZipCode( "01235" );
28:         _01238 = FactoryMethodInvoker.instantiateZipCode( "01238" );
29:         _01263 = FactoryMethodInvoker.instantiateZipCode( "01263" );
30:         _01213 = FactoryMethodInvoker.instantiateZipCode( "01213" );
31:         _01823 = FactoryMethodInvoker.instantiateZipCode( "01823" );
32:         _01312 = FactoryMethodInvoker.instantiateZipCode( "01312" );
33:         _04233 = FactoryMethodInvoker.instantiateZipCode( "04233" );
34:         _02544 = FactoryMethodInvoker.instantiateZipCode( "02544" );
35:         _99123 = FactoryMethodInvoker.instantiateZipCode( "99123" );
36:         _56323 = FactoryMethodInvoker.instantiateZipCode( "56323" );
37:         _79332 = FactoryMethodInvoker.instantiateZipCode( "79332" );
38: 
39:     }
40: 
41: 
42:     @Test
43:     public void testToStringZipCode() {
44:         // given
45:         // when
46:         ZipCodeType instance = instantiateZipCode( input1 );
47: 
48:         // then
49:         assertEquals( input1, instance.toString() );
50:     }
51: 
52:     @Test
53:     public void testFactoryValidZipCode() {
54:         // given
55:         // when
56:         // then
57:         assertDoesNotThrow( () -> instantiateZipCode( input1 ) );
58:     }
59: 
60:     @Test
61:     public void testFactoryInvalidZipCode() {
62:         // given
63:         // when
64:         // then
65:         assertThrows( ShopException.class, () -> instantiateZipCode( "123456" ) );
66:         assertThrows( ShopException.class, () -> instantiateZipCode( "1234" ) );
67:         assertThrows( ShopException.class, () -> instantiateZipCode( "20000" ) );
68:         assertThrows( ShopException.class, () -> instantiateZipCode( null ) );
69:     }
70: 
71:     @Test
72:     public void testEqualityZipCode() {
73:         // given
74:         // when
75:         ZipCodeType instance1a = instantiateZipCode( input1 );
76:         ZipCodeType instance1b = instantiateZipCode( input1 );
77:         ZipCodeType instance4 = instantiateZipCode( input4 );
78: 
79:         // then
80:         assertEquals( instance1a, instance1b );
81:         assertNotEquals( instance1a, instance4 );
82:     }
83: 
84:     @Test
85:     public void testImmutabilityZipCode() {
86:         // given
87:         // when
88:         ZipCodeType instance = instantiateZipCode( input1 );
89: 
90:         // then
91:         try {
92:             instance.getClass().getMethod( "setzipCode", String.class );
93:             fail( "setzipCode method should not exist" );
94:         } catch (NoSuchMethodException e) {
95:             // Success: the object is immutable
96:         }
97:     }
98: 
99: 
100:     @Test
101:     public void smokeTestForDifference() {
102:         // given
103:         ZipCodeType instance1a = instantiateZipCode( input1 );
104:         ZipCodeType instance1b = instantiateZipCode( input1 );
105:         ZipCodeType instance12479 = instantiateZipCode( "12479" );
106:         ZipCodeType instance21456 = instantiateZipCode( "21456" );
107: 
108:         // when
109:         int differenceAB = instance1a.difference( instance1b );
110:         int difference12 = instance1a.difference( instance12479 );
111:         int difference23 = instance12479.difference( instance21456 );
112: 
113:         // then
114:         assertEquals( 0, differenceAB );
115:         assertTrue( difference12 > 0 );
116:         assertTrue( difference23 > difference12 );
117:     }
118: 
119: 
120:     @Test
121:     public void testZipCodeFirstDigit() {
122:         // given
123:         ZipCodeType instance1 = instantiateZipCode( input1 );
124:         ZipCodeType instance4 = instantiateZipCode( input4 );
125: 
126:         // when
127:         // then
128:         assertEquals( 1, instance1.getFirstDigitZipCode() );
129:         assertEquals( 4, instance4.getFirstDigitZipCode() );
130:     }
131: 
132: 
133: 
134:     @Test
135:     public void testInvalidParameters() {
136:         // given
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 _12345.difference( null ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testSameZipCode() {
146:         // given
147:         // when
148:         int diff = _12345.difference( _12345b );
149: 
150:         // then
151:         assertEquals( 0, diff );
152:     }
153: 
154: 
155:     /**
156:      *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
157:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
158:      *        So, 56733 and 56734 have the same difference as 56733 and 56739.
159:      *      - The difference grows if more digits (counted from the right side) differ.
160:      *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
161:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
162:      *        53876 and 54876 have the same difference as 53876 and 57261.
163:      */
164:     @Test
165:     public void testZipCodeDifferenceInAllButFirstDigit() {
166:         // given
167:         // when
168:         int diff5a = _01234.difference( _01235 );
169:         int diff5b = _01234.difference( _01238 );
170:         int diff4a = _01234.difference( _01263 );
171:         int diff4b = _01234.difference( _01213 );
172:         int diff3a = _01234.difference( _01823 );
173:         int diff3b = _01234.difference( _01312 );
174:         int diff2a = _01234.difference( _04233 );
175:         int diff2b = _01234.difference( _02544 );
176: 
177:         // then
178:         assertEquals( diff5a, diff5b, "difference 01234-01235 must be the same as difference 01234-01238" );
179:         assertEquals( diff4a, diff4b, "difference 01234-01263 must be the same as difference 01234-01213" );
180:         assertEquals( diff3a, diff3b, "difference 01234-01823 must be the same as difference 01234-01312" );
181:         assertEquals( diff2a, diff2b, "difference 01234-04233 must be the same as difference 01234-02544" );
182: 
183:         assertTrue( diff5a < diff4a,
184:                 "difference 01234-01235 must be smaller than difference 01234-01263" );
185:         assertTrue( diff4a < diff3a,
186:                 "difference 01234-01263 must be smaller than difference 01234-01823" );
187:         assertTrue( diff3a < diff2a,
188:                 "difference 01234-01823 must be smaller than difference 01234-04233" );
189:     }
190: 
191: 
192:     /**
193:      *      - However, the difference between 5abcd and 6rstu must be smaller than the one
194:      *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
195:      *        one between 5abcd and 9rstu.
196:      *      - This last condition reflects the fact the first digits of a zip code marks a region
197:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
198:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
199:      *        other.
200:      */
201:     @Test
202:     public void testZipCodedifferenceInFirstDigit() {
203:         // given
204:         // when
205:         int diff1_1 = _01234.difference( _99123 );
206:         int diff1_2 = _01234.difference( _23455 );
207:         int diff1_5 = _01234.difference( _56323 );
208:         int diff1_3 = _01234.difference( _79332 );
209: 
210:         // then
211:         assertTrue( diff1_1 < diff1_2,
212:                 "difference 01234-99123 must be smaller than difference 01234-23455"  );
213:         assertTrue( diff1_2 < diff1_3,
214:                 "difference 01234-23455 must be smaller than difference 01234-79332" );
215:         assertTrue( diff1_3 < diff1_5,
216:                 "difference 01234-79332 must be smaller than difference 01234-56323"  );
217:     }
218: 
219: 
220: 
221: }
222: 
223: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
1: package thkoeln.archilab.ecommerce.tests.e1restcalls;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;
5: 
6: 
7: public class E1RestCallTableTest {
8: 
9:     private GenericTableSpecificationTests genericTableSpecificationTests = null;
10: 
11: 
12:     public E1RestCallTableTest() {
13:         this.genericTableSpecificationTests = new GenericTableSpecificationTests();
14:     }
15: 
16:     @Test
17:     public void restTest() throws Exception {
18:         genericTableSpecificationTests.testTableSpecification("E1" );
19:     }
20: }
21: 
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\order\OrderTest.java ---
1: package thkoeln.archilab.ecommerce.tests.order;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: 
15: import java.util.Map;
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.assertEquals;
19: import static org.junit.jupiter.api.Assertions.assertThrows;
20: 
21: 
22: @SpringBootTest
23: public class OrderTest {
24:     @Autowired
25:     private CustomerRegistrationUseCases customerRegistrationUseCases;
26:     @Autowired
27:     private ShoppingBasketUseCases shoppingBasketUseCases;
28:     @Autowired
29:     private ProductCatalogUseCases productCatalogUseCases;
30:     @Autowired
31:     private StorageUnitUseCases storageUnitUseCases;
32:     @Autowired
33:     private OrderUseCases orderUseCases;
34:     @Autowired
35:     private Purgatory purgatory;
36:     @Autowired
37:     private CustomerTestHelper customerTestHelper;
38:     @Autowired
39:     private ProductTestHelper productTestHelper;
40:     @Autowired
41:     private StorageUnitTestHelper storageUnitTestHelper;
42: 
43:     private UUID nonExistingId1;
44:     private UUID nonExistingId2;
45: 
46:     @BeforeEach
47:     public void setUp() {
48:         purgatory.deleteEverything();
49:         customerTestHelper.registerAllCustomers();
50:         productTestHelper.addAllProducts();
51:         storageUnitTestHelper.addAllStorageUnits( true );
52:         nonExistingId1 = UUID.randomUUID();
53:         nonExistingId2 = UUID.randomUUID();
54:     }
55: 
56: 
57:     @Test
58:     public void testOrderHistory() {
59:         // given
60:         UUID productId1 = productTestHelper.getProductId( 1 );
61:         UUID productId2 = productTestHelper.getProductId( 2 );
62:         EmailAddressType customerEmailAddress7 =
63:                 customerTestHelper.getCustomerEmailAddress( 7 );
64:         Map<UUID, Integer> orderHistoryBefore = orderUseCases.getOrderHistory( customerEmailAddress7 );
65: 
66:         // when
67:         shoppingBasketUseCases.addProductToShoppingBasket(
68:                 customerEmailAddress7, productId1, 3 );
69:         shoppingBasketUseCases.addProductToShoppingBasket(
70:                 customerEmailAddress7, productId2, 2 );
71:         shoppingBasketUseCases.checkout( customerEmailAddress7 );
72:         Map<UUID, Integer> orderHistory1 =
73:                 orderUseCases.getOrderHistory( customerEmailAddress7 );
74:         shoppingBasketUseCases.addProductToShoppingBasket(
75:                 customerEmailAddress7, productId1, 6 );
76:         shoppingBasketUseCases.addProductToShoppingBasket(
77:                 customerEmailAddress7, productId2, 2 );
78:         shoppingBasketUseCases.checkout( customerEmailAddress7 );
79:         Map<UUID, Integer> orderHistory2 =
80:                 orderUseCases.getOrderHistory( customerEmailAddress7 );
81:         shoppingBasketUseCases.addProductToShoppingBasket(
82:                 customerEmailAddress7, productId1, 1 );
83:         shoppingBasketUseCases.addProductToShoppingBasket(
84:                 customerEmailAddress7, productId2, 6 );
85:         shoppingBasketUseCases.checkout( customerEmailAddress7 );
86:         Map<UUID, Integer> orderHistory3 =
87:                 orderUseCases.getOrderHistory( customerEmailAddress7 );
88: 
89:         // then
90:         assertEquals( 0, orderHistoryBefore.size() );
91:         assertEquals( 2, orderHistory1.size() );
92:         assertEquals( 2, orderHistory2.size() );
93:         assertEquals( 2, orderHistory3.size() );
94:         assertEquals( 3, orderHistory1.get( productId1 ) );
95:         assertEquals( 2, orderHistory1.get( productId2 ) );
96:         assertEquals( 9, orderHistory2.get( productId1 ) );
97:         assertEquals( 4, orderHistory2.get( productId2 ) );
98:         assertEquals( 10, orderHistory3.get( productId1 ) );
99:         assertEquals( 10, orderHistory3.get( productId2 ) );
100:     }
101: 
102: 
103:     @Test
104:     public void testForEmptyOrderHistory() {
105:         // given
106:         EmailAddressType customerEmailAddress4 =
107:                 customerTestHelper.getCustomerEmailAddress( 4 );
108:         // when
109:         Map<UUID, Integer> orderHistory =
110:                 orderUseCases.getOrderHistory( customerEmailAddress4 );
111:         // then
112:         assertEquals( 0, orderHistory.size() );
113:     }
114: 
115: 
116:     @Test
117:     public void testInvalidParamsForGetOrderQuantForProduct() {
118:         // given
119:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
120: 
121:         // when / then
122:         assertThrows ( ShopException.class,
123:                 () -> orderUseCases.getOrderQuantForProduct( null, null ) );
124:         assertThrows ( ShopException.class,
125:                 () -> orderUseCases.getOrderQuantForProduct( nonExistingId1, null ) );
126:         assertThrows ( ShopException.class,
127:                 () -> orderUseCases.getOrderQuantForProduct( null, nonExistingId2 ) );
128:         assertThrows ( ShopException.class,
129:                 () -> orderUseCases.getOrderQuantForProduct( nonExistingId1, nonExistingId2 ) );
130:         assertThrows ( ShopException.class,
131:                 () -> orderUseCases.getOrderQuantForProduct( storageUnitId0, null ) );
132:         assertThrows ( ShopException.class,
133:                 () -> orderUseCases.getOrderQuantForProduct( storageUnitId0, nonExistingId2 ) );
134:     }
135: 
136: 
137:     @Test
138:     public void testInvalidParamsForGetStorageUnitIdForOrder() {
139:         // given / when / then
140:         assertThrows ( ShopException.class,
141:                 () -> orderUseCases.getStorageUnitIdForOrder( null ) );
142:         assertThrows ( ShopException.class,
143:                 () -> orderUseCases.getStorageUnitIdForOrder( nonExistingId1 ) );
144:     }
145: }
146: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.assertj.core.api.Assert;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: import com.fasterxml.jackson.annotation.JsonProperty;
8: import com.fasterxml.jackson.databind.ObjectMapper;
9: import com.jayway.jsonpath.JsonPath;
10: import thkoeln.archilab.ecommerce.domainprimitives.Address;
11: import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
12: import thkoeln.archilab.ecommerce.domainprimitives.Money;
13: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
14: 
15: import static org.junit.jupiter.api.Assertions.assertEquals;
16: import static org.junit.jupiter.api.Assertions.fail;
17: 
18: @Slf4j
19: public class DomainPrimitiveJSONSerializationTest {
20: 
21:     @BeforeEach
22:     public void setUp() {
23:         // ... add own setup code here
24:     }
25: 
26: 
27:     /**
28:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
29:      * EmailAddress.
30:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
31:      * on how to implement this test, and how to change property names.
32:      * @throws Exception
33:      */
34:     @Test
35:     public void test_EmailAddress_Serialization() throws Exception {
36:         // TODO: implement this test
37:         // given
38:         EmailAddress email = (EmailAddress) EmailAddress.of("ZitronenKuchen@gmail.com");
39:         ObjectMapper mapper = new ObjectMapper();
40:         // when
41:         String json = mapper.writeValueAsString(email);
42:         // then
43:         log.info(json);
44:         String emailAddress = JsonPath.read(json,"$.emailAddressString");
45: 
46:     }
47: 
48: 
49:     /**
50:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
51:      * ZipCode.
52:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
53:      * on how to implement this test, and how to change property names.
54:      * @throws Exception
55:      */
56:     @Test
57:     public void test_ZipCode_Serialization() throws Exception {
58:         // TODO: implement this test
59:         // given
60:         ZipCode zipCode = (ZipCode) ZipCode.of("12345");
61:         ObjectMapper mapper = new ObjectMapper();
62:         // when
63:         String json = mapper.writeValueAsString(zipCode);
64:         // then
65:         log.info(json);
66:         String expectedZipCode = JsonPath.read(json,"$.zipCodeString");
67:     }
68: 
69: 
70:     /**
71:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
72:      * Address.
73:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
74:      * on how to implement this test, and how to change property names.
75:      * @throws Exception
76:      */
77:     @Test
78:     public void test_Address_Serialization() throws Exception {
79:         // TODO: implement this test
80:         // given
81:         Address address = (Address) Address.of("Bundesstrasse","Berlin",ZipCode.of("10171"));
82:         ObjectMapper mapper= new ObjectMapper();
83:         // when
84:         String json = mapper.writeValueAsString(address);
85:         // then
86:         log.info(json);
87:         String expectedStreet = JsonPath.read(json,"$.street");
88:         String expectedCity = JsonPath.read(json,"$.city");
89:         String expectedZip = JsonPath.read(json,"$.zipCode.zipCodeString");
90:     }
91: 
92: 
93:     /**
94:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
95:      * Money.
96:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
97:      * on how to implement this test, and how to change property names.
98:      * @throws Exception
99:      */
100:     @Test
101:     public void test_Money_Serialization() throws Exception {
102:         // TODO: implement this test
103:         // given
104:         Money money = (Money) Money.of(100F,"EUR");
105:         ObjectMapper mapper = new ObjectMapper();
106:         // when
107:         String json = mapper.writeValueAsString(money);
108:         // then
109:         log.info(json);
110:         Double expectedAmount = JsonPath.read(json,"$.amount");
111:         String expectedCurrency = JsonPath.read(json,"$.currencyUnit");
112: 
113: 
114:     }
115: 
116: }
117: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingBasketRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Disabled;
6: import org.junit.jupiter.api.Test;
7: import org.springframework.beans.factory.annotation.Autowired;
8: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
9: import org.springframework.boot.test.context.SpringBootTest;
10: import org.springframework.context.annotation.Import;
11: import org.springframework.http.HttpStatus;
12: import org.springframework.http.ResponseEntity;
13: import thkoeln.archilab.ecommerce.domainprimitives.GenericNotFoundException;
14: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
15: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
16: import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
17: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
18: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerRepository;
19: import thkoeln.archilab.ecommerce.solution.order.application.OrderService;
20: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
21: import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
22: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPart;
23: import thkoeln.archilab.ecommerce.solution.product.domain.Product;
24: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
25: import thkoeln.archilab.ecommerce.solution.shoppingbasket.application.ShoppingBasketController;
26: import thkoeln.archilab.ecommerce.solution.shoppingbasket.application.ShoppingBasketDto;
27: import thkoeln.archilab.ecommerce.solution.shoppingbasket.application.ShoppingBasketService;
28: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
29: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketId;
30: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
31: import thkoeln.archilab.ecommerce.solution.storageunit.application.StorageUnitService;
32: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnit;
33: import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
34: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
35: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
36: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
37: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
38: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
39: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
40: 
41: import java.util.*;
42: 
43: import static org.junit.jupiter.api.Assertions.*;
44: import static org.junit.jupiter.api.Assertions.fail;
45: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
46: 
47: 
48: @SpringBootTest
49: @Transactional
50: @AutoConfigureMockMvc
51: @Import( RESTTestHelperConfiguration.class )
52: public class OwnShoppingBasketRESTTest {
53:     @Autowired
54:     private Purgatory purgatory;
55:     @Autowired
56:     private CustomerTestHelper customerTestHelper;
57:     @Autowired
58:     private ProductTestHelper productTestHelper;
59:     @Autowired
60:     private StorageUnitTestHelper storageUnitTestHelper;
61:     @Autowired
62:     private ShoppingBasketService shoppingBasketService;
63:     @Autowired
64:     private ShoppingBasketController shoppingBasketController;
65:     @Autowired
66:     private CustomerRepository customerRepository;
67:     @Autowired
68:     private ShoppingBasketRESTHelper shoppingBasketRESTHelper;
69:     @Autowired
70:     private ShoppingBasketRepository shoppingBasketRepository;
71:     @Autowired
72:     private OrderService orderService;
73: 
74: 
75: 
76: 
77:     private EmailAddressType customerEmail;
78:     private Customer customer;
79:     private ShoppingBasket shoppingBasket;
80:     private ShoppingBasketId shoppingBasketId;
81:     private ProductId productId1;
82:     private ProductId productId2;
83:     private ProductId productId8;
84:     private StorageUnitId singleStorageUnitId1;
85:     private StorageUnitId otherStorageUnitId2;
86:     @Autowired
87:     private StorageUnitService storageUnitService;
88:     @BeforeEach
89:     public void setUp() {
90:         purgatory.deleteEverything();
91:         customerTestHelper.registerAllCustomers();
92:         productTestHelper.addAllProducts();
93:         storageUnitTestHelper.addAllStorageUnits( true );
94:         customerEmail = customerTestHelper.getCustomerEmailAddress(0);
95:         customer = customerRepository.findByEmail(customerEmail)
96:                 .orElseThrow(() -> new IllegalStateException("Customer not found during setup"));
97: 
98: 
99: 
100:         UUID storageUnitUuid = storageUnitTestHelper.getStorageUnitId(0);
101:         singleStorageUnitId1 = new StorageUnitId(storageUnitUuid);
102: 
103: 
104:         storageUnitUuid = storageUnitTestHelper.getStorageUnitId(7);
105:         otherStorageUnitId2 = new StorageUnitId(storageUnitUuid);
106: 
107: 
108: 
109:         UUID productUuid =productTestHelper.getProductId(1);
110:         productId1 = new ProductId(productUuid);
111:         productUuid = productTestHelper.getProductId(2);
112:         productId2 = new ProductId(productUuid);
113:         productUuid = productTestHelper.getProductId(8);
114:         productId8 = new ProductId(productUuid);
115: 
116:         shoppingBasket = shoppingBasketService.createShoppingBasketForCustomer(customerEmail.toString());
117:         shoppingBasketId = shoppingBasket.getShoppingBasketId();
118: 
119:         shoppingBasketService.emptyShoppingBasket(shoppingBasketId);
120: 
121: 
122:     }
123: 
124: 
125:     /**
126:      * Provide a test that implements a simple call to the REST endpoint (3):
127:      * <pre>
128:      *     GET /shoppingBaskets?customerId=<customer id as uuid>
129:      * </pre>
130:      * - Use the {@link CustomerTestHelper} to obtain to obtain the email address
131:      *   of some example customer.
132:      * - Use your shopping basket service to add entries to the shopping basket of that person.
133:      * - then use the `ShoppingBasketRESTHelper` to create the GET call, and check the results.
134:      * - (or do it by directly calling your REST controller, if you prefer)
135:      * @throws Exception
136:      */
137:     @Test
138:     public void test_getQuery_ShoppingBasket() throws Exception {
139:         // given
140:         EmailAddressType email1= customerTestHelper.getCustomerEmailAddress(0);
141:         ProductId productId1 = new ProductId( productTestHelper.getProductId(1));
142:         ProductId productId2 = new ProductId( productTestHelper.getProductId(8));
143:         Customer customer = customerRepository.findByEmail(email1)
144:                 .orElseThrow(() -> new IllegalStateException("Customer not found"));
145:         UUID customerId = customer.getCustomerId().getId();
146: 
147:         // when
148:         shoppingBasketService.addProductToShoppingBasket(email1.toString(),productId1,2);
149:         shoppingBasketService.addProductToShoppingBasket(email1.toString(),productId2,4);
150: 
151:         // then
152:         Map<UUID,Integer> expectedQuantityMap = new HashMap<>();
153:         expectedQuantityMap.put(productId1.getId(),2);
154:         expectedQuantityMap.put(productId2.getId(),4);
155: 
156:         UUID retrievedShoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket(
157:                 email1,
158:                 expectedQuantityMap
159:         );
160:         assertNotNull(retrievedShoppingBasketId,"The retrieved shopping basket should not be null");
161:         assertEquals(customer.getCustomerId().getId(),retrievedShoppingBasketId,"ShoppingBasketId from REST call should match customers ID");
162: 
163:         ResponseEntity<ShoppingBasketDto> response = shoppingBasketController.getShoppingBasket(customerId.toString());
164:         assertEquals(HttpStatus.OK, response.getStatusCode());
165:         assertNotNull(response.getBody());
166:         ShoppingBasketDto shoppingBasketDto = response.getBody();
167:         assertNotNull(shoppingBasketDto,"Shopping basket should not be null");
168:         assertEquals(customerId,shoppingBasketDto.getId(),"ID in DTO should match CustomerID");
169:         assertNotNull(shoppingBasketDto.getTotalSellingPrice(),"Total selling price should not be null");
170:         assertFalse(shoppingBasketDto.getParts().isEmpty(),"Shopping Basket should contain parts");
171:         assertEquals(2,shoppingBasketDto.getParts().size(),"Shopping Basket should contain 2 parts");
172: 
173:         boolean foundProduct1=shoppingBasketDto.getParts().stream()
174:                         .anyMatch(part -> part.getProductId().equals(productId1.getId()) && part.getQuantity()==2);
175:         assertTrue(foundProduct1,"Product 1 in Shopping Basket should contain 2 parts");
176: 
177:         boolean foundProduct2 = shoppingBasketDto.getParts().stream()
178:                 .anyMatch(part -> part.getProductId().equals(productId2.getId()) && part.getQuantity()==4);
179:         assertTrue(foundProduct2,"Product 2 in Shopping Basket should contain 4 parts");
180:     }
181:     /**
182:      * Provide a test that implements the addition of one product to the shopping basket via
183:      * REST endpoint (6):
184:      * <pre>
185:      *     POST /shoppingBaskets/{shoppingBasket-Id}/parts
186:      * </pre>
187:      * You can test now "the other way around" as in test_getQuery_ShoppingBasket():
188:      * - Use `ShoppingBasketRESTHelper` to add products via REST, then use shopping basket service methods
189:      *   to check of the shopping basket contains the right stuff.
190:      * - (or do it by directly calling your REST controller, if you prefer)
191:      *
192:      * @throws Exception
193:      */
194:     @Test
195:     public void test_post_ShoppingBasketParts() throws Exception {
196: 
197:         // given
198:         EmailAddressType email1= customerTestHelper.getCustomerEmailAddress(0);
199:         ProductId productId1 = new ProductId( productTestHelper.getProductId(1));
200:         Integer quantity = 5;
201:         Customer customer = customerRepository.findByEmail(email1)
202:                 .orElseThrow(() -> new IllegalStateException("Customer not found"));
203:         ShoppingBasket basket = shoppingBasketService.createShoppingBasketForCustomer(email1.toString());
204:         ShoppingBasketId shoppingBasketId = basket.getShoppingBasketId();
205:         // when
206:         shoppingBasketRESTHelper.addProductToShoppingBasket(shoppingBasketId.getId(),productId1.getId(),quantity);
207: 
208:         // then
209:         Optional<ShoppingBasket> shoppingBasketOptional = shoppingBasketRepository.findByCustomerId(customer.getCustomerId());
210:         assertTrue(shoppingBasketOptional.isPresent(),"Shopping basket shoudl exist for customer");
211: 
212:         Optional<Integer> actualQuantityOptional = shoppingBasketService.getProductQuantityInShoppingBasket(
213:                 shoppingBasketId.getId(), productId1);
214: 
215:         assertTrue(actualQuantityOptional.isPresent(), "Product should be found in the shopping basket.");
216:         assertEquals(quantity, actualQuantityOptional.get(), "Quantity of product in shopping basket should match.");
217:     }
218:     /**
219:      * Provide a test that implements the deletion of one product in the shopping basket via
220:      * REST endpoint (10):
221:      * <pre>
222:      *     DELETE /shoppingBaskets/{shoppingBasket-Id}/parts/{product-Id}
223:      * </pre>
224:      * This should be just a slight variation of the test_post_ShoppingBasketParts()
225:      * method, but instead of adding an product to the shopping basket, you delete it.
226:      *
227:      * @throws Exception
228:      */
229:     @Test
230:     public void test_delete_ShoppingBasketParts() throws Exception {
231:         // given
232:         Integer quantity = 5;
233:         EmailAddressType email1= customerTestHelper.getCustomerEmailAddress(0);
234:         ProductId productId1 = new ProductId( productTestHelper.getProductId(1));
235:         Customer customer = customerRepository.findByEmail(email1)
236:                 .orElseThrow(() -> new IllegalStateException("Customer not found"));
237:         ShoppingBasket basket = shoppingBasketService.createShoppingBasketForCustomer(email1.toString());
238:         ShoppingBasketId shoppingBasketId = basket.getShoppingBasketId();
239:         // when
240:         System.out.println(shoppingBasketId);
241:         System.out.println(shoppingBasketId.getId());
242:         System.out.println(email1);
243:         System.out.println(productId1);
244:         System.out.println(productId1.getId());
245:         shoppingBasketRESTHelper.addProductToShoppingBasket(shoppingBasketId.getId(),productId1.getId(),quantity);
246: 
247:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket(shoppingBasketId.getId(),productId1.getId());
248: 
249:         // then
250:         Optional<ShoppingBasket> shoppingBasketOptional = shoppingBasketRepository.findByCustomerId(customer.getCustomerId());
251:         assertTrue(shoppingBasketOptional.isPresent(),"Shopping basket should exist for customer");
252: 
253:         Optional<Integer> actualQuantityOptional = shoppingBasketService.getProductQuantityInShoppingBasket(
254:                 shoppingBasketId.getId(), productId1);
255: 
256:         assertFalse(actualQuantityOptional.isPresent(), "Product should not be found in the shopping basket.");
257:     }
258:     /**
259:      * Provide a test that implements the checkout of a shopping basket that can be served
260:      * by just 1 storage unit, using the REST endpoint (11):
261:      * <pre>
262:      *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
263:      * </pre>
264:      * - Use your shopping basket service to add entries to the shopping basket of some example customer,
265:      * - then use the `ShoppingBasketRESTHelper to post the checkout call, and to check the results.
266:      * - (or do it by directly calling your REST controller, if you prefer)
267:      *
268:      * @throws Exception
269:      */
270:     @Test
271:     public void test_checkout_1_storageUnit() throws Exception {
272:         // given
273:         shoppingBasketService.addProductToShoppingBasket(customer.getEmailAddress().toString(),productId1,1);
274:         shoppingBasketService.addProductToShoppingBasket(customer.getEmailAddress().toString(),productId2,2);
275:         // when
276:         Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>();
277:         Map<UUID, Integer> expectedProductsInOrder = new HashMap<>();
278:         expectedProductsInOrder.put(productId1.getId(), 1);
279:         expectedProductsInOrder.put(productId2.getId(), 2);
280:         expectedOrders.put(singleStorageUnitId1.getId(), expectedProductsInOrder);
281: 
282:         shoppingBasketRESTHelper.checkout(
283:                 shoppingBasketId.getId(),
284:                 customer.getName(),
285:                 status().isCreated(),
286:                 expectedOrders
287:         );
288:         // then
289:         Optional<ShoppingBasket> currentBasket = shoppingBasketService.getShoppingBasketForCustomerId(customer.getCustomerId().getId());
290: 
291:         assertEquals(9, storageUnitService.getAvailableStock(singleStorageUnitId1, productId1));
292:         assertEquals(18, storageUnitService.getAvailableStock(singleStorageUnitId1, productId2));
293: 
294:         List<Order> createdOrders = orderService.findOrdersByCustomerId(customer.getCustomerId());
295:         assertEquals(1, createdOrders.size(), "Exactly one order should have been created.");
296:         Order createdOrder = createdOrders.get(0);
297:         assertEquals(2, orderService.findOrderPartsByOrder(createdOrder).size(), "Order should have 2 parts.");
298:     }
299:     /**
300:      * Provide a test that implements the checkout of a shopping basket that can only be served
301:      * by using 2 storage units, using the REST endpoint (11):
302:      * <pre>
303:      *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
304:      * </pre>
305:      * This should be just a slight variation of thetest_checkout_1_storageUnit() test.
306:      *
307:      * @throws Exception
308:      */
309:     @Test
310:     public void test_checkout_2_storageUnits() throws Exception {
311:         // given
312:         int quantityProd1 = 1;
313:         int quantityProd8 = 1;
314: 
315:         shoppingBasketService.addProductToShoppingBasket(customer.getEmailAddress().toString(),productId1,quantityProd1);
316:         shoppingBasketService.addProductToShoppingBasket(customer.getEmailAddress().toString(),productId8,quantityProd8);
317: 
318:         // when
319:         Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>();
320: 
321: 
322:         Map<UUID, Integer> order1 = new HashMap<>();
323:         order1.put(productId1.getId(), quantityProd1);
324:         expectedOrders.put(singleStorageUnitId1.getId(), order1);
325: 
326:         Map<UUID, Integer> order2 = new HashMap<>();
327:         order2.put(productId8.getId(), quantityProd8);
328:         expectedOrders.put(otherStorageUnitId2.getId(), order2);
329: 
330: 
331:         shoppingBasketRESTHelper.checkout(
332:                 shoppingBasketId.getId(),
333:                 customer.getName(),
334:                 status().isCreated(),
335:                 expectedOrders
336:         );
337:         // then
338: 
339:         Optional<ShoppingBasket> currentBasket = shoppingBasketService.getShoppingBasketForCustomerId(customer.getCustomerId().getId());
340:         assertEquals(9, storageUnitService.getAvailableStock(singleStorageUnitId1, productId1));
341: 
342: 
343:         List<Order> createdOrders = orderService.findOrdersByCustomerId(customer.getCustomerId());
344:         assertEquals(2, createdOrders.size(), "Exactly one order should have been created.");
345:         thkoeln.archilab.ecommerce.solution.order.domain.Order createdOrder = createdOrders.get(0);
346:         assertEquals(singleStorageUnitId1.getId(), createdOrder.getStorageUnitId().getId(), "Order should be from the single storage unit.");
347: 
348:         }
349:     }
350: 
351: 
352: 
353: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\product\ProductCatalogTest.java ---
1: package thkoeln.archilab.ecommerce.tests.product;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
9: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
15: 
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.*;
19: 
20: 
21: @SpringBootTest
22: public class ProductCatalogTest {
23:     @Autowired
24:     private CustomerRegistrationUseCases customerRegistrationUseCases;
25:     @Autowired
26:     private ShoppingBasketUseCases shoppingBasketUseCases;
27:     @Autowired
28:     private ProductCatalogUseCases productCatalogUseCases;
29:     @Autowired
30:     private StorageUnitUseCases storageUnitUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private CustomerTestHelper customerTestHelper;
35:     @Autowired
36:     private ProductTestHelper productTestHelper;
37:     @Autowired
38:     private StorageUnitTestHelper storageUnitTestHelper;
39: 
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         customerTestHelper.registerAllCustomers();
45:         productTestHelper.addAllProducts();
46:     }
47: 
48: 
49:     @Test
50:     public void testAddProductToCatalog() {
51:         // given
52:         UUID productId4 = productTestHelper.getProductId( 4 );
53:         MoneyType sellingPrice4 = productTestHelper.getSellingPrice( 4 );
54: 
55:         // when
56:         MoneyType foundSellingPrice = productCatalogUseCases.getSellingPrice( productId4 );
57: 
58:         // then
59:         assertEquals( sellingPrice4, foundSellingPrice );
60:     }
61: 
62: 
63:     @Test
64:     public void testAddProductWithInvalidData() {
65:         // given
66:         String name = "SomeStuff";
67:         String description = "Some more explanation on the stuff";
68:         Float size = 5.0f;
69:         MoneyType buyingPrice =
70:                 FactoryMethodInvoker.instantiateMoney( 5.0f, "EUR" );
71:         MoneyType sellingPrice =
72:                 FactoryMethodInvoker.instantiateMoney( 10.0f, "EUR" );
73:         MoneyType tooLowSellingPrice =
74:                 FactoryMethodInvoker.instantiateMoney( 4.0f, "EUR" );
75: 
76:         // when / then
77:         assertThrows( ShopException.class, () ->
78:                 productCatalogUseCases.addProductToCatalog(
79:                         null, description, size, buyingPrice, sellingPrice ) );
80:         assertThrows( ShopException.class, () ->
81:                 productCatalogUseCases.addProductToCatalog(
82:                         "", description, size, buyingPrice, sellingPrice ) );
83:         assertThrows( ShopException.class, () ->
84:                 productCatalogUseCases.addProductToCatalog(
85:                         name, null, size, buyingPrice, sellingPrice ) );
86:         assertThrows( ShopException.class, () ->
87:                 productCatalogUseCases.addProductToCatalog(
88:                         name, "", size, buyingPrice, sellingPrice ) );
89:         assertThrows( ShopException.class, () ->
90:                 productCatalogUseCases.addProductToCatalog(
91:                         name, description, size, null, sellingPrice ) );
92:         assertThrows( ShopException.class, () ->
93:                 productCatalogUseCases.addProductToCatalog(
94:                         name, description, size, buyingPrice, null ) );
95:         assertThrows( ShopException.class, () ->
96:                 productCatalogUseCases.addProductToCatalog(
97:                         name, description, size, buyingPrice, tooLowSellingPrice ) );
98:     }
99: 
100: 
101:     @Test
102:     public void testRemoveNonExistentProduct() {
103:         // given product 2 is not in stock anywhere - should be removable
104:         UUID nonExistentProductId = UUID.randomUUID();
105: 
106:         // when
107:         // then
108:         assertThrows( ShopException.class,
109:                 () -> productCatalogUseCases.removeProductFromCatalog( nonExistentProductId ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testRemoveProductWithNoStock() {
115:         // given product 0 is not in stock anywhere - should be removable
116:         UUID productId0 = productTestHelper.getProductId( 0 );
117:         storageUnitTestHelper.addAllStorageUnits( true );
118: 
119:         // when
120:         assertDoesNotThrow( () -> productCatalogUseCases.getSellingPrice( productId0 ) );
121:         productCatalogUseCases.removeProductFromCatalog( productId0 );
122: 
123:         // then
124:         assertThrows( ShopException.class, () ->
125:                 productCatalogUseCases.getSellingPrice( productId0 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testRemoveProductThatIsInStock() {
131:         // given
132:         storageUnitTestHelper.addAllStorageUnits( false );
133:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
134:         UUID productId3 = productTestHelper.getProductId( 3 );
135:         UUID productId4 = productTestHelper.getProductId( 4 );
136:         storageUnitUseCases.addToStock( storageUnitId0, productId3, 3 );
137: 
138:         // then product 3 must not be removable, but product 4 must be removable
139:         assertThrows( ShopException.class,
140:                 () -> productCatalogUseCases.removeProductFromCatalog( productId3 ) );
141:         assertDoesNotThrow( () -> productCatalogUseCases.removeProductFromCatalog( productId4 ) );
142:     }
143: 
144: 
145:     @Test
146:     public void testRemoveProductThatIsInOrder() {
147:         // given
148:         storageUnitTestHelper.addAllStorageUnits( false );
149:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
150:         UUID productId4 = productTestHelper.getProductId( 4 );
151:         EmailAddressType customerEmailAddress4 =
152:                 customerTestHelper.getCustomerEmailAddress( 4 );
153:         storageUnitUseCases.addToStock( storageUnitId0, productId4, 4 );
154: 
155:         // when customer 4 adds 4x product 4 to his shopping basket and checks out ...
156:         shoppingBasketUseCases.addProductToShoppingBasket(
157:                 customerEmailAddress4, productId4, 4 );
158:         shoppingBasketUseCases.checkout( customerEmailAddress4 );
159: 
160:         // then product 4 must not be removable
161:         assertThrows( ShopException.class,
162:                 () -> productCatalogUseCases.removeProductFromCatalog( productId4 ) );
163:     }
164: 
165: 
166:     @Test
167:     public void testClearProductCatalog() {
168:         // given
169:         UUID productId4 = productTestHelper.getProductId( 4 );
170: 
171:         // when
172:         productCatalogUseCases.deleteProductCatalog();
173: 
174:         // then
175:         assertThrows( ShopException.class, () -> productCatalogUseCases.getSellingPrice( productId4 ) );
176:     }
177: 
178: }
179: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\CheckoutAcceptanceTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingbasket;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
14: 
15: import java.util.*;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: 
19: /**
20:  * This test checks the management of stock across storage units. It focuses on the
21:  * cases where more than one storage unit are needed to serve the shopping basket of a customer.
22:  */
23: @Slf4j
24: @SpringBootTest
25: public class CheckoutAcceptanceTest {
26:     @Autowired
27:     private CustomerRegistrationUseCases customerRegistrationUseCases;
28:     @Autowired
29:     private ShoppingBasketUseCases shoppingBasketUseCases;
30:     @Autowired
31:     private ProductCatalogUseCases productCatalogUseCases;
32:     @Autowired
33:     private OrderUseCases orderUseCases;
34:     @Autowired
35:     private StorageUnitUseCases storageUnitUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private CustomerTestHelper customerTestHelper;
40:     @Autowired
41:     private ProductTestHelper productTestHelper;
42:     @Autowired
43:     private StorageUnitTestHelper storageUnitTestHelper;
44: 
45:     private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
46:                                 map8_11_14_quantity_3_3_4,
47:                                 map10_12_quantity_1_1, 
48:                                 map11_quantity_1, 
49:                                 map12_quantity_10,
50:                                 map8_9_10_11_quantity_2_1_4_2;
51:     private EmailAddressType customerEmailAddress3, customerEmailAddress6,
52:             customerEmailAddress2;
53:     private UUID productId8, productId9, productId10, productId11, productId12,
54:             productId14;
55: 
56: 
57:     @BeforeEach
58:     public void setUp() {
59:         purgatory.deleteEverything();
60:         customerTestHelper.registerAllCustomers();
61:         productTestHelper.addAllProducts();
62:         storageUnitTestHelper.addAllStorageUnits( true );
63: 
64:         customerEmailAddress3 = customerTestHelper.getCustomerEmailAddress( 3 );
65:         customerEmailAddress6 = customerTestHelper.getCustomerEmailAddress( 6 );
66:         customerEmailAddress2 = customerTestHelper.getCustomerEmailAddress( 2 );
67: 
68:         productId8 = productTestHelper.getProductId( 8 );
69:         productId9 = productTestHelper.getProductId( 9 );
70:         productId10 = productTestHelper.getProductId( 10 );
71:         productId11 = productTestHelper.getProductId( 11 );
72:         productId12 = productTestHelper.getProductId( 12 );
73:         productId14 = productTestHelper.getProductId( 14 );
74: 
75:         map8_11_14_quantity_2_2_2 = new HashMap<>() {{
76:             put( productId8, 2 );
77:             put( productId11, 2 );
78:             put( productId14, 2 );
79:         }};
80:         map8_11_14_quantity_3_3_4 = new HashMap<>() {{
81:             put( productId8, 3 );
82:             put( productId11, 3 );
83:             put( productId14, 4 );
84:         }};
85:         map10_12_quantity_1_1 = new HashMap<>() {{
86:             put( productId10, 1 );
87:             put( productId12, 1 );
88:         }};
89:         map11_quantity_1 = new HashMap<>() {{
90:             put( productId11, 1 );
91:         }};
92:         map12_quantity_10 = new HashMap<>() {{
93:             put( productId12, 10 );
94:         }};
95:         map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
96:             put( productId8, 2 );
97:             put( productId9, 1 );
98:             put( productId10, 4 );
99:             put( productId11, 2 );
100:         }};
101: 
102:     }
103: 
104: 
105:     /**
106:      * Hint: to better understand the expected results of this test, see the distribution of stock
107:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
108:      */
109:     @Test
110:     public void testClosestSingleStorageUnitWins() {
111:         log.info( "testClosestSingleStorageUnitWins" );
112: 
113:         // given
114:         shoppingBasketUseCases.addProductToShoppingBasket(
115:                 customerEmailAddress3, productId8, 2 );
116:         shoppingBasketUseCases.addProductToShoppingBasket(
117:                 customerEmailAddress3, productId11, 2 );
118:         shoppingBasketUseCases.addProductToShoppingBasket(
119:                 customerEmailAddress3, productId14, 2 );
120:         // that basket could have been served from storage unit 4 or 7, but 4 is closer to the customer
121:         UUID storageUnitId4 = storageUnitTestHelper.getStorageUnitId( 4 );
122: 
123:         // when
124:         Set<UUID> orderIds = shoppingBasketUseCases.checkout( customerEmailAddress3 );
125: 
126:         // then
127:         checkStorageUnitIds( orderIds, storageUnitId4 );
128:         checkProductNumbers( orderIds, storageUnitId4, map8_11_14_quantity_2_2_2 );
129:     }
130: 
131: 
132:     /**
133:      * Hint: to better understand the expected results of this test, see the distribution of stock
134:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
135:      */
136:     @Test
137:     public void testStorageUnitWithEnoughCapacityWins() {
138:         log.info( "testStorageUnitWithEnoughCapacityWins" );
139: 
140:         // given
141:         shoppingBasketUseCases.addProductToShoppingBasket(
142:                 customerEmailAddress3, productId8, 3 );
143:         shoppingBasketUseCases.addProductToShoppingBasket(
144:                 customerEmailAddress3, productId11, 3 );
145:         shoppingBasketUseCases.addProductToShoppingBasket(
146:                 customerEmailAddress3, productId14, 4 );
147:         // that basket could have been served from storage unit 4 or 7, 4 is closer to the customer,
148:         // but only 7 has enough capacity
149:         UUID storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );
150: 
151:         // when
152:         Set<UUID> orderIds = shoppingBasketUseCases.checkout( customerEmailAddress3 );
153: 
154:         // then
155:         checkStorageUnitIds( orderIds, storageUnitId7 );
156:         checkProductNumbers( orderIds, storageUnitId7, map8_11_14_quantity_3_3_4 );
157:     }
158: 
159: 
160:     /**
161:      * Hint: to better understand the expected results of this test, see the distribution of stock
162:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
163:      */
164:     @Test
165:     public void testTwoStorageUnits() {
166:         log.info( "testTwoStorageUnits" );
167: 
168:         // given
169:         shoppingBasketUseCases.addProductToShoppingBasket(
170:                 customerEmailAddress6, productId10, 1 );
171:         shoppingBasketUseCases.addProductToShoppingBasket(
172:                 customerEmailAddress6, productId11, 1 );
173:         shoppingBasketUseCases.addProductToShoppingBasket(
174:                 customerEmailAddress6, productId12, 1 );
175:         // that basket needs two deliveries (2 + 1 products) anyway, and there
176:         // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
177:         // closer. The smaller can then be served from 4 (closest), 7, or 8.
178:         UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
179:                 // should cover map10_12_quantity_1_1
180:         UUID storageUnitId4 = storageUnitTestHelper.getStorageUnitId( 4 );
181:                 // should cover map11_quantity_1
182: 
183:         // when
184:         Set<UUID> orderIds = shoppingBasketUseCases.checkout( customerEmailAddress6 );
185: 
186:         // then
187:         checkStorageUnitIds( orderIds, storageUnitId5, storageUnitId4 );
188:         checkProductNumbers( orderIds, storageUnitId5, map10_12_quantity_1_1 );
189:         checkProductNumbers( orderIds, storageUnitId4, map11_quantity_1 );
190:     }
191: 
192: 
193:     /**
194:      * Hint: to better understand the expected results of this test, see the distribution of stock
195:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
196:      */
197:     @Test
198:     public void testTwoBigDeliverys() {
199:         log.info( "testTwoBigDeliverys" );
200: 
201:         // given
202:         shoppingBasketUseCases.addProductToShoppingBasket(
203:                 customerEmailAddress2, productId8, 2 );
204:         shoppingBasketUseCases.addProductToShoppingBasket(
205:                 customerEmailAddress2, productId9, 1 );
206:         shoppingBasketUseCases.addProductToShoppingBasket(
207:                 customerEmailAddress2, productId10, 4 );
208:         shoppingBasketUseCases.addProductToShoppingBasket(
209:                 customerEmailAddress2, productId11, 2 );
210:         shoppingBasketUseCases.addProductToShoppingBasket(
211:                 customerEmailAddress2, productId12, 10 );
212:         // when
213:         Set<UUID> orderIds = shoppingBasketUseCases.checkout( customerEmailAddress2 );
214:         UUID storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );
215:                 // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 products
216:         UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
217:                 // should cover map12_quantity_10 - the only storage unit with enough capacity for 10 products
218: 
219:         // then
220:         checkStorageUnitIds( orderIds, storageUnitId7, storageUnitId5 );
221:         checkProductNumbers( orderIds, storageUnitId7, map8_9_10_11_quantity_2_1_4_2 );
222:         checkProductNumbers( orderIds, storageUnitId5, map12_quantity_10 );
223:     }
224: 
225: 
226:     /**
227:      * Hint: to better understand the expected results of this test, see the distribution of stock
228:      * across storage units, as specified in the StorageUnitTestHelper and in the README file.
229:      */
230:     @Test
231:     public void testOnlyOneSolution() {
232:         log.info( "testOnlyOneSolution" );
233: 
234:         // given
235:         shoppingBasketUseCases.addProductToShoppingBasket(
236:                 customerEmailAddress6, productId12, 10 );
237:         // when
238:         Set<UUID> orderIds = shoppingBasketUseCases.checkout( customerEmailAddress6 );
239:         UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
240:         // should cover map12_quantity_10 - the only storage unit with enough capacity for 10 products
241: 
242:         // then
243:         checkStorageUnitIds( orderIds, storageUnitId5 );
244:         checkProductNumbers( orderIds, storageUnitId5, map12_quantity_10 );
245:     }
246: 
247: 
248: 
249:     private void checkProductNumbers( Set<UUID> orderIds, UUID storageUnitId, Map<UUID, Integer> expectedMap ) {
250:         UUID fittingOrderId = null;
251:         for ( UUID orderId : orderIds ) {
252:             UUID foundStorageUnitId = orderUseCases.getStorageUnitIdForOrder( orderId );
253:             if ( foundStorageUnitId.equals( storageUnitId ) ) {
254:                 fittingOrderId = orderId;
255:                 break;
256:             }
257:         }
258:         assertNotNull( fittingOrderId, "No fitting order found for storage unit " + storageUnitId );
259: 
260:         int totalExpected = 0;
261:         int totalActual = 0;
262:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
263:             totalExpected += entry.getValue();
264:         }
265:         log.info( "Check order numbers for product {} in storage unit {}", fittingOrderId, storageUnitId );
266:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
267:             UUID productId = entry.getKey();
268:             Integer foundNumber =
269:                     orderUseCases.getOrderQuantForProduct( fittingOrderId, productId );
270:             assertEquals( entry.getValue(), foundNumber );
271:             totalActual += foundNumber;
272:         }
273:         // last check - do the total sums match?
274:         assertEquals( totalExpected, totalActual );
275:     }
276: 
277: 
278:     private void checkStorageUnitIds( Set<UUID> orderIds, UUID... expectedStorageUnitIds ) {
279:         assertEquals( expectedStorageUnitIds.length, orderIds.size() );
280:         Set<UUID> foundStorageUnitIds = new HashSet<>();
281:         for ( UUID orderId : orderIds ) {
282:             UUID storageUnitId = orderUseCases.getStorageUnitIdForOrder( orderId );
283:             foundStorageUnitIds.add( storageUnitId );
284:         }
285:         for ( UUID expectedStorageUnitId : expectedStorageUnitIds ) {
286:             assertTrue( foundStorageUnitIds.contains( expectedStorageUnitId ) );
287:         }
288:     }
289: 
290: }
291: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingbasket;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.ResultMatcher;
12: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
13: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
14: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
15: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
17: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
18: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
19: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
20: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
21: 
22: import java.util.HashMap;
23: import java.util.Map;
24: import java.util.UUID;
25: 
26: import static org.junit.jupiter.api.Assertions.assertEquals;
27: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
28: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
29: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmailAddress;
30: 
31: 
32: @SpringBootTest
33: @Transactional
34: @AutoConfigureMockMvc
35: @Import( RESTTestHelperConfiguration.class )
36: public class ShoppingBasketRESTTest {
37:     @Autowired
38:     private StorageUnitUseCases storageUnitUseCases;
39:     @Autowired
40:     private ShoppingBasketUseCases shoppingBasketUseCases;
41:     @Autowired
42:     private Purgatory purgatory;
43:     @Autowired
44:     private CustomerTestHelper customerTestHelper;
45:     @Autowired
46:     private ProductTestHelper productTestHelper;
47:     @Autowired
48:     private StorageUnitTestHelper storageUnitTestHelper;
49:     @Autowired
50:     private MockMvc mockMvc;
51:     @Autowired
52:     private ShoppingBasketRESTHelper shoppingBasketRESTHelper;
53: 
54:     private EmailAddressType nonExistingEmailAddress;
55:     private final Map<UUID, Integer> emptyMap = new HashMap<>();
56: 
57:     private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
58:     private EmailAddressType
59:             customerEmailAddress0,
60:             customerEmailAddress3,
61:             customerEmailAddress6,
62:             customerEmailAddress8;
63:     private String customerName0, customerName8;
64:     private UUID productId0, productId1, productId2, productId3, productId5,
65:                  productId7, productId9, productId11, nonExistentProductId;
66:     private UUID storageUnitId0, storageUnitId3, storageUnitId7, storageUnitId8;
67: 
68: 
69:     private static final ResultMatcher NOT_FOUND = status().isNotFound();
70:     private static final ResultMatcher OK = status().isOk();
71:     private static final ResultMatcher CREATED = status().isCreated();
72:     private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
73:     private static final ResultMatcher CONFLICT = status().isConflict();
74: 
75:     @BeforeEach
76:     public void setUp() {
77:         purgatory.deleteEverything();
78:         customerTestHelper.registerAllCustomers();
79:         productTestHelper.addAllProducts();
80:         storageUnitTestHelper.addAllStorageUnits( true );
81:         nonExistingEmailAddress = instantiateEmailAddress( "harry@sally.de" );
82: 
83:         customerEmailAddress0 = customerTestHelper.getCustomerEmailAddress( 0 );
84:         customerEmailAddress3 = customerTestHelper.getCustomerEmailAddress( 3 );
85:         customerEmailAddress6 = customerTestHelper.getCustomerEmailAddress( 6 );
86:         customerEmailAddress8 = customerTestHelper.getCustomerEmailAddress( 8 );
87:         customerName0 = customerTestHelper.getCustomerName( 0 );
88:         customerName8 = customerTestHelper.getCustomerName( 8 );
89: 
90:         productId0 = productTestHelper.getProductId( 0 );
91:         productId1 = productTestHelper.getProductId( 1 );
92:         productId2 = productTestHelper.getProductId( 2 );
93:         productId3 = productTestHelper.getProductId( 3 );
94:         productId5 = productTestHelper.getProductId( 5 );
95:         productId7 = productTestHelper.getProductId( 7 );
96:         productId9 = productTestHelper.getProductId( 9 );
97:         productId11 = productTestHelper.getProductId( 11 );
98:         nonExistentProductId = UUID.randomUUID();
99: 
100:         storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
101:         storageUnitId3 = storageUnitTestHelper.getStorageUnitId( 3 );
102:         storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );
103:         storageUnitId8 = storageUnitTestHelper.getStorageUnitId( 8 );
104: 
105:         map9_quantity_1 = new HashMap<>() {{
106:             put( productId9, 1 );
107:         }};
108:         map5_quantity_2 = new HashMap<>() {{
109:             put( productId5, 2 );
110:         }};
111:         map7_quantity_7 = new HashMap<>() {{
112:             put( productId7, 7 );
113:         }};
114:         map9_11_quantity_2_2 = new HashMap<>() {{
115:             put( productId9, 2 );
116:             put( productId11, 2 );
117:         }};
118:     }
119: 
120: 
121:     @Test
122:     public void testInvalidShoppingBasketBaseUris() throws Exception {
123:         // given
124:         String allShoppingBasketsUri = "/shoppingBaskets";
125:         String randomIdUri = "/shoppingBaskets/" + UUID.randomUUID();
126:         String randomCustomerUUID = "/shoppingBaskets?customerId=" + UUID.randomUUID();
127:         String invalidCustomerUUID = "/shoppingBaskets?customerId=invalidUUID";
128:         String randomParamUri = "/shoppingBaskets?randomParam=randomValue";
129: 
130:         // when
131:         // then
132:         mockMvc.perform( get( allShoppingBasketsUri ) ).andExpect( status().isMethodNotAllowed() );
133:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
134:         mockMvc.perform( get( randomCustomerUUID ) ).andExpect( status().isNotFound() );
135:         mockMvc.perform( get( invalidCustomerUUID ) ).andExpect( status().isNotFound() );
136:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
137:     }
138: 
139: 
140:     @Test
141:     public void testInvalidPartUris() throws Exception {
142:         // given
143:         UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress8, emptyMap );
144:         String randomPartUri = "/shoppingBaskets/" + shoppingBasketId8.toString() + "/random";
145:         String randomProductUri = "/shoppingBaskets/" + shoppingBasketId8.toString()
146:                 + "/parts/" + UUID.randomUUID();
147: 
148:         // when
149:         // then
150:         mockMvc.perform( post( randomPartUri ) ).andExpect( status().isNotFound() );
151:         mockMvc.perform( delete( randomProductUri ) ).andExpect( status().isNotFound() );
152:     }
153: 
154: 
155:     @Test
156:     public void testInvalidAddToShoppingBasket() throws Exception {
157:         // given
158:         Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
159:         expectedStartQuantityMap.put( productId2, 19 );
160: 
161:         // when
162:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress0, emptyMap );
163:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId, productId2, 6 );
164:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId, productId2, 13 );
165: 
166:         // then
167:         shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress0, expectedStartQuantityMap );
168: 
169:         // ... and check a couple of invalid cases
170:         shoppingBasketRESTHelper.addProductToShoppingBasket(
171:                 shoppingBasketId, nonExistentProductId, 12, NOT_FOUND );
172:         shoppingBasketRESTHelper.addProductToShoppingBasket(
173:                 UUID.randomUUID(), productId5, 12, NOT_FOUND );
174:         shoppingBasketRESTHelper.addProductToShoppingBasket(
175:                 shoppingBasketId, productId5, -1, UNPROCESSABLE_ENTITY );
176: 
177:         // check if the shopping basket is still the same
178:         shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress0, expectedStartQuantityMap );
179:     }
180: 
181: 
182:     @Test
183:     public void testInvalidCheckout_unavailableProduct() throws Exception {
184:         // given
185:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress0, emptyMap );
186: 
187:         // when
188:         // productId0 is not available in the requested quantity (or rather, not at all)
189:         shoppingBasketRESTHelper.addProductToShoppingBasket(
190:                 shoppingBasketId, productId0, 1, CREATED );
191: 
192:         // check if the shopping basket is still the same
193:         shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
194:     }
195: 
196: 
197:     @Test
198:     public void testInvalidCheckout_tooLittleStock() throws Exception {
199:         // given
200:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress0, emptyMap );
201: 
202:         // when
203:         // There are only 10 pieces of productId1 available
204:         shoppingBasketRESTHelper.addProductToShoppingBasket(
205:                 shoppingBasketId, productId1, 11, CREATED );
206: 
207:         // check if the shopping basket is still the same
208:         shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
209:     }
210: 
211: 
212: 
213:     @Test
214:     public void testDeleteProductFromShoppingBasket() throws Exception {
215:         // given
216:         UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress6, emptyMap );
217:         Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
218:         expectedQuantityMap1.put( productId1, 1 );
219:         expectedQuantityMap1.put( productId2, 2 );
220:         expectedQuantityMap1.put( productId3, 3 );
221:         Map<UUID, Integer> quantityMap2 = new HashMap<>();
222:         quantityMap2.put( productId1, 1 );
223:         quantityMap2.put( productId3, 3 );
224: 
225:         // when
226:         // then
227:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId1, 1 );
228:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId2, 2 );
229:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId3, 3 );
230:         shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress6, expectedQuantityMap1 );
231: 
232:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId2 );
233:         shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress6, quantityMap2 );
234:     }
235: 
236: 
237:     @Test
238:     public void testNoDoubleDelete() throws Exception {
239:         // given
240:         UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress6, emptyMap );
241: 
242:         // when
243:         // then
244:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId3, 3 );
245:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId3 );
246:         shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress6, new HashMap<>() );
247:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId3, NOT_FOUND );
248:     }
249: 
250: 
251:     @Test
252:     public void testAddRemoveProductsFromAndToShoppingBasket() throws Exception {
253:         // given
254:         UUID shoppingBasketId3 = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress3, emptyMap );
255:         UUID shoppingBasketId5 = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress6, emptyMap );
256: 
257:         // when
258:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId1, 2 );
259:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId2, 3 );
260:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId3, productId1 );
261:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId1, 1 );
262:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId2, 6 );
263: 
264:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId1, 2 );
265:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId2, 8 );
266:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId5, productId1 );
267:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId1, 1 );
268:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId2, 2 );
269: 
270:         // then
271:         // customer3 has 1x productId1 and 9x productId2 expected in cart
272:         Map<UUID, Integer> expectedMap3 = new HashMap<>();
273:         expectedMap3.put( productId1, 1 );
274:         expectedMap3.put( productId2, 9 );
275:         shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress3, expectedMap3 );
276: 
277:         // customer6 has 1x productId1 and 10x productId2 in cart
278:         Map<UUID, Integer> expectedMap5 = new HashMap<>();
279:         expectedMap5.put( productId1, 1 );
280:         expectedMap5.put( productId2, 10 );
281:         shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress6, expectedMap5 );
282:     }
283: 
284: 
285:     @Test
286:     public void testNoDoubleCheckout() throws Exception {
287:         // given
288:         UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress8, emptyMap );
289: 
290:         // when
291:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId2, 3 );
292: 
293:         // then
294:         shoppingBasketRESTHelper.checkout( shoppingBasketId8, customerName8, CREATED, null );
295:         shoppingBasketRESTHelper.checkout( shoppingBasketId8, null, CONFLICT, null );
296:     }
297: 
298: 
299:     @Test
300:     public void testCheckout_1_Order() throws Exception {
301:         // given:
302:         // Customer 0 wants to buy 1x product 9. This is in storage unit 5, 7, and 8. Out of these,
303:         // storage unit 8 with zip code 89250 is closest to customer 0 with zip code 02314.
304:         Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
305:             put( storageUnitId8, map9_quantity_1 );
306:         }};
307:         UUID shoppingBasketId0 = shoppingBasketRESTHelper.getQueryShoppingBasket(
308:                 customerEmailAddress0, null );
309:         int stock9before =
310:                 storageUnitUseCases.getAvailableStock( storageUnitId8, productId9 );
311: 
312:         // when
313:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId0, productId9, 1 );
314:         shoppingBasketRESTHelper.checkout( shoppingBasketId0, customerName0, CREATED, expectedOrders );
315:         int stock9after =
316:                 storageUnitUseCases.getAvailableStock( storageUnitId8, productId9 );
317: 
318:         // then
319:         assertEquals( 1, stock9before - stock9after );
320:     }
321: 
322: 
323:     @Test
324:     public void testCheckout_3_Order() throws Exception {
325:         // given:
326:         // Customer 8 (Felix Bauer) wants to buy 2x each of products 5, 9, 11; and 7x product 7.
327:         //       - products 9 and 11 can both be found in storage units 7 and 8. Storage units 7 (76532) is closer to
328:         //         the customer (70173)
329:         //       - product 7 is available in storage units 1, 2, and 3, but only storage unit 3 has enough stock.
330:         //       - product 5 is only available in storage unit 0.
331:         Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
332:             put( storageUnitId0, map5_quantity_2 );
333:             put( storageUnitId3, map7_quantity_7 );
334:             put( storageUnitId7, map9_11_quantity_2_2 );
335:         }};
336:         UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket(
337:                 customerEmailAddress8, null );
338:         int stock5before =
339:                 storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
340:         int stock7before =
341:                 storageUnitUseCases.getAvailableStock( storageUnitId3, productId7 );
342:         int stock9before =
343:                 storageUnitUseCases.getAvailableStock( storageUnitId7, productId9 );
344:         int stock11before =
345:                 storageUnitUseCases.getAvailableStock( storageUnitId7, productId11 );
346: 
347:         // when
348:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId5, 2 );
349:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId7, 7 );
350:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId9, 2 );
351:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId11, 2 );
352:         shoppingBasketRESTHelper.checkout( shoppingBasketId8, customerName8, CREATED, expectedOrders );
353:         int stock5after =
354:                 storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
355:         int stock7after =
356:                 storageUnitUseCases.getAvailableStock( storageUnitId3, productId7 );
357:         int stock9after =
358:                 storageUnitUseCases.getAvailableStock( storageUnitId7, productId9 );
359:         int stock11after =
360:                 storageUnitUseCases.getAvailableStock( storageUnitId7, productId11 );
361: 
362:         // then
363:         assertEquals( 2, stock5before - stock5after );
364:         assertEquals( 7, stock7before - stock7after );
365:         assertEquals( 2, stock9before - stock9after );
366:         assertEquals( 2, stock11before - stock11after );
367:     }
368: 
369: 
370: }
371: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingbasket;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.InsufficientStockException;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
12: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
13: import thkoeln.archilab.ecommerce.usecases.*;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
16: 
17: 
18: import java.util.Map;
19: import java.util.UUID;
20: 
21: import static org.junit.jupiter.api.Assertions.*;
22: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
23: 
24: @SpringBootTest
25: public class ShoppingBasketTest {
26:     @Autowired
27:     private CustomerRegistrationUseCases customerRegistrationUseCases;
28:     @Autowired
29:     private ShoppingBasketUseCases shoppingBasketUseCases;
30:     @Autowired
31:     private ProductCatalogUseCases productCatalogUseCases;
32:     @Autowired
33:     private StorageUnitUseCases storageUnitUseCases;
34:     @Autowired
35:     private OrderUseCases orderUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private CustomerTestHelper customerTestHelper;
40:     @Autowired
41:     private ProductTestHelper productTestHelper;
42:     @Autowired
43:     private StorageUnitTestHelper storageUnitTestHelper;
44: 
45:     private EmailAddressType nonExistingEmailAddress;
46: 
47:     @BeforeEach
48:     public void setUp() {
49:         purgatory.deleteEverything();
50:         customerTestHelper.registerAllCustomers();
51:         productTestHelper.addAllProducts();
52: 
53:         nonExistingEmailAddress = instantiateEmailAddress( "this@nononono.de" );
54:     }
55: 
56: 
57:     @Test
58:     public void testInvalidAddToShoppingBasket() {
59:         // given
60:         UUID nonExistentProductId = UUID.randomUUID();
61:         UUID productId5 = productTestHelper.getProductId( 5 );
62:         UUID productId0 = productTestHelper.getProductId( 0 );
63:         EmailAddressType customerEmailAddress0 =
64:                 customerTestHelper.getCustomerEmailAddress( 0 );
65:         storageUnitTestHelper.addAllStorageUnits( true );
66: 
67:         // then
68:         assertThrows( ShopException.class,
69:                 () -> shoppingBasketUseCases.addProductToShoppingBasket(
70:                         nonExistingEmailAddress, productId0, 1 ) );
71:         assertThrows( ShopException.class,
72:                 () -> shoppingBasketUseCases.addProductToShoppingBasket(
73:                         null, productId0, 1 ) );
74:         assertThrows( ShopException.class,
75:                 () -> shoppingBasketUseCases.addProductToShoppingBasket(
76:                         customerEmailAddress0, nonExistentProductId, 1 ) );
77:         assertThrows( ShopException.class,
78:                 () -> shoppingBasketUseCases.addProductToShoppingBasket(
79:                         customerEmailAddress0, null, 1 ) );
80:         assertThrows( ShopException.class,
81:                 () -> shoppingBasketUseCases.addProductToShoppingBasket(
82:                         customerEmailAddress0, productId5, -1 ) );
83:     }
84: 
85: 
86:     @Test
87:     public void testInvalidRemoveFromShoppingBasket() {
88:         // given
89:         UUID nonExistentProductId = UUID.randomUUID();
90:         UUID productId5 = productTestHelper.getProductId( 5 );
91:         UUID productId1 = productTestHelper.getProductId( 1 );
92:         UUID productId2 = productTestHelper.getProductId( 2 );
93:         storageUnitTestHelper.addAllStorageUnits( true );
94:         EmailAddressType customerEmailAddress0 =
95:                 customerTestHelper.getCustomerEmailAddress( 0 );
96:         shoppingBasketUseCases.addProductToShoppingBasket(
97:                 customerEmailAddress0, productId1, 5 );
98:         shoppingBasketUseCases.addProductToShoppingBasket(
99:                 customerEmailAddress0, productId2, 15 );
100: 
101:         // when
102:         shoppingBasketUseCases.removeProductFromShoppingBasket(
103:                 customerEmailAddress0, productId1, 2 );
104:         shoppingBasketUseCases.removeProductFromShoppingBasket(
105:                 customerEmailAddress0, productId2, 4 );
106:         shoppingBasketUseCases.removeProductFromShoppingBasket(
107:                 customerEmailAddress0, productId2, 7 );
108:         // now we should have 3x productId1 and 4x productId2 in the shopping basket
109: 
110:         // then
111:         assertThrows( ShopException.class,
112:                 () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
113:                         customerEmailAddress0, nonExistentProductId, 12 ) );
114:         assertThrows( ShopException.class,
115:                 () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
116:                         nonExistingEmailAddress, productId5, 12 ) );
117:         assertThrows( ShopException.class,
118:                 () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
119:                         customerEmailAddress0, productId5, -1 ) );
120:         assertThrows( ShopException.class,
121:                 () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
122:                         customerEmailAddress0, productId1, 4 ) );
123:         assertThrows( ShopException.class,
124:                 () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
125:                         customerEmailAddress0, productId2, 5 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testAddRemoveProductsFromAndToShoppingBasket() {
131:         // given
132:         UUID productId1 = productTestHelper.getProductId( 1 );
133:         UUID productId2 = productTestHelper.getProductId( 2 );
134:         EmailAddressType customerEmailAddress3 =
135:                 customerTestHelper.getCustomerEmailAddress( 3 );
136:         EmailAddressType customerEmailAddress5 =
137:                 customerTestHelper.getCustomerEmailAddress( 5 );
138: 
139:         // when customer 3 ...
140:         shoppingBasketUseCases.addProductToShoppingBasket(
141:                 customerEmailAddress3, productId1, 2 );
142:         shoppingBasketUseCases.addProductToShoppingBasket(
143:                 customerEmailAddress3, productId2, 3 );
144:         shoppingBasketUseCases.removeProductFromShoppingBasket(
145:                 customerEmailAddress3, productId1, 2 );
146:         shoppingBasketUseCases.addProductToShoppingBasket(
147:                 customerEmailAddress3, productId1, 1 );
148:         shoppingBasketUseCases.addProductToShoppingBasket(
149:                 customerEmailAddress3, productId2, 6 );
150:         Map<UUID, Integer> cart3 = shoppingBasketUseCases.getShoppingBasketAsMap( customerEmailAddress3 );
151:         // customer3 has 1x productId1 and 9x productId2 in cart
152: 
153:         // ... and when customer 5 ...
154:         shoppingBasketUseCases.addProductToShoppingBasket(
155:                 customerEmailAddress5, productId1, 2 );
156:         shoppingBasketUseCases.addProductToShoppingBasket(
157:                 customerEmailAddress5, productId2, 8 );
158:         shoppingBasketUseCases.removeProductFromShoppingBasket(
159:                 customerEmailAddress5, productId1, 1 );
160:         shoppingBasketUseCases.addProductToShoppingBasket(
161:                 customerEmailAddress5, productId2, 2 );
162:         Map<UUID, Integer> cart5 = shoppingBasketUseCases.getShoppingBasketAsMap( customerEmailAddress5 );
163:         // customer5 has 1x productId1 and 10x productId2 in cart
164: 
165:         // then
166:         assertEquals( 2, cart3.size() );
167:         assertEquals( 1, cart3.get( productId1 ) );
168:         assertEquals( 9, cart3.get( productId2 ) );
169: 
170:         assertEquals( 2, cart5.size() );
171:         assertEquals( 1, cart5.get( productId1 ) );
172:         assertEquals( 10, cart5.get( productId2 ) );
173:     }
174: 
175: 
176:     @Test
177:     public void testShoppingBasketValue() {
178:         // given
179:         UUID productId3 = productTestHelper.getProductId( 3 );
180:         UUID productId6 = productTestHelper.getProductId( 6 );
181:         UUID productId8 = productTestHelper.getProductId( 8 );
182:         MoneyType price3 = productTestHelper.getSellingPrice( 3 );
183:         MoneyType price6 = productTestHelper.getSellingPrice( 6 );
184:         MoneyType price8 = productTestHelper.getSellingPrice( 8 );
185:         EmailAddressType customerEmailAddress3 =
186:                 customerTestHelper.getCustomerEmailAddress( 3 );
187: 
188:         // when
189:         shoppingBasketUseCases.addProductToShoppingBasket( customerEmailAddress3, productId3, 3 );
190:         shoppingBasketUseCases.addProductToShoppingBasket( customerEmailAddress3, productId6, 2 );
191:         shoppingBasketUseCases.addProductToShoppingBasket( customerEmailAddress3, productId8, 5 );
192:         // customer3 has 3x productId3, 2x productId6 and 5x productId8 in cart
193:         MoneyType cartValue = shoppingBasketUseCases.getShoppingBasketAsMoneyValue( customerEmailAddress3 );
194: 
195:         // then
196:         assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
197:                 cartValue );
198:     }
199: 
200: 
201:     @Test
202:     public void testShoppingBasketValueInvalid() {
203:         // given
204:         // when
205:         // then
206:         assertThrows( ShopException.class,
207:                 () -> shoppingBasketUseCases.getShoppingBasketAsMoneyValue( nonExistingEmailAddress ) );
208:     }
209: 
210: 
211:     @Test
212:     public void testUnsuccessfulCheckout() {
213:         // given customer buying product 0 (which is not in stock), and customer 1 buying product 1
214:         // in a bigger quantity (11) than available (10)
215:         storageUnitTestHelper.addAllStorageUnits( true );
216:         EmailAddressType customerEmailAddress0 =
217:                 customerTestHelper.getCustomerEmailAddress( 0 );
218:         EmailAddressType customerEmailAddress1 =
219:                 customerTestHelper.getCustomerEmailAddress( 1 );
220:         UUID productId0 = productTestHelper.getProductId( 0 );
221:         UUID productId1 = productTestHelper.getProductId( 1 );
222: 
223:         // when
224:         shoppingBasketUseCases.addProductToShoppingBasket(
225:                 customerEmailAddress0, productId0, 1 );
226:         shoppingBasketUseCases.addProductToShoppingBasket(
227:                 customerEmailAddress1, productId1, 11 );
228: 
229:         // then
230:         assertThrows( InsufficientStockException.class,
231:                 () -> shoppingBasketUseCases.checkout( customerEmailAddress0 ) );
232:         assertThrows( InsufficientStockException.class,
233:                 () -> shoppingBasketUseCases.checkout( customerEmailAddress1 ) );
234:     }
235: 
236: }
237: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\storageunit\StorageUnitManagementTest.java ---
1: package thkoeln.archilab.ecommerce.tests.storageunit;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
12: import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
14: 
15: import java.util.UUID;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
19: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateAddress;
20: 
21: 
22: /**
23:  * This test checks the management and lifecycle of storage units.
24:  */
25: @SpringBootTest
26: public class StorageUnitManagementTest {
27:     @Autowired
28:     private StorageUnitUseCases storageUnitUseCases;
29:     @Autowired
30:     private ProductCatalogUseCases productCatalogUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private ProductTestHelper productTestHelper;
35:     @Autowired
36:     private StorageUnitTestHelper storageUnitTestHelper;
37: 
38:     private AddressType someAddress;
39:     private UUID nonExistingId1;
40:     private UUID nonExistingId2;
41: 
42: 
43:     @BeforeEach
44:     public void setUp() {
45:         purgatory.deleteEverything();
46:         productTestHelper.addAllProducts();
47: 
48:         someAddress = instantiateAddress( "Some Street", "Some City",
49:                 instantiateZipCode( "90001" ) );
50:         nonExistingId1 = UUID.randomUUID();
51:         nonExistingId2 = UUID.randomUUID();
52:     }
53: 
54: 
55:     @Test
56:     public void testAddInvalidStorageUnit() {
57:         // given
58:         String name = "Lager1";
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class,
63:                 () -> storageUnitUseCases.addNewStorageUnit(
64:                         null, someAddress ) );
65:         assertThrows( ShopException.class,
66:                 () -> storageUnitUseCases.addNewStorageUnit(
67:                         "", someAddress ) );
68:         assertThrows( ShopException.class,
69:                 () -> storageUnitUseCases.addNewStorageUnit(
70:                         name, null ) );
71:     }
72: 
73: 
74:     @Test
75:     public void testDeleteAllStorageUnitsWhenEmpty() {
76:         // given
77:         storageUnitTestHelper.addAllStorageUnits( false );
78:         UUID productId9 = productTestHelper.getProductId( 9 );
79:         UUID storageUnitId1 = storageUnitTestHelper.getStorageUnitId( 1 );
80:         UUID storageUnitId2 = storageUnitTestHelper.getStorageUnitId( 2 );
81: 
82:         // when
83:         int numOf1 = storageUnitUseCases.getAvailableStock( storageUnitId1, productId9 );
84:         int numOf2 = storageUnitUseCases.getAvailableStock( storageUnitId2, productId9 );
85: 
86:         // then
87:         assertEquals( 0, numOf1 );
88:         assertEquals( 0, numOf2 );
89:         storageUnitUseCases.deleteAllStorageUnits();
90:         // ... ids must be invalid now
91:         assertThrows( ShopException.class,
92:                 () -> storageUnitUseCases.getAvailableStock( storageUnitId1, productId9 ) );
93:         assertThrows( ShopException.class,
94:                 () -> storageUnitUseCases.getAvailableStock( storageUnitId2, productId9 ) );
95:     }
96: 
97: 
98:     @Test
99:     public void testDeleteAllStorageUnitsWhenFull() {
100:         // given
101:         storageUnitTestHelper.addAllStorageUnits( true );
102:         UUID productId7 = productTestHelper.getProductId( 7 );
103:         UUID storageUnitId1 = storageUnitTestHelper.getStorageUnitId( 1 );
104:         UUID storageUnitId2 = storageUnitTestHelper.getStorageUnitId( 2 );
105: 
106:         // when
107:         int numOf1 = storageUnitUseCases.getAvailableStock( storageUnitId1, productId7 );
108:         int numOf2 = storageUnitUseCases.getAvailableStock( storageUnitId2, productId7 );
109: 
110:         // then
111:         assertTrue( numOf1 == 3 );
112:         assertTrue( numOf2 == 3 );
113:         storageUnitUseCases.deleteAllStorageUnits();
114:         // ... ids must be invalid now
115:         assertThrows( ShopException.class,
116:                 () -> storageUnitUseCases.getAvailableStock( storageUnitId1, productId7 ) );
117:         assertThrows( ShopException.class,
118:                 () -> storageUnitUseCases.getAvailableStock( storageUnitId2, productId7 ) );
119:     }
120: 
121: 
122: 
123:     @Test
124:     public void testAddToStock() {
125:         // given
126:         storageUnitTestHelper.addAllStorageUnits( true );
127:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in storage unit 0
128:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
129:         int originalStock5 =
130:                 storageUnitTestHelper.getStorageUnitStock( 0, 5 );
131: 
132:         // when
133:         int stock5before = storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
134:         storageUnitUseCases.addToStock( storageUnitId0, productId5, 23 );
135:         int stock5after = storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
136:         storageUnitUseCases.addToStock( storageUnitId0, productId5, 0 );
137:         int stock5after2 = storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
138: 
139:         // then
140:         assertEquals( originalStock5, stock5before );
141:         assertEquals( stock5before + 23, stock5after );
142:         assertEquals( stock5after, stock5after2 );
143:     }
144: 
145: 
146:     @Test
147:     public void testInvalidAddToStock() {
148:         // given
149:         storageUnitTestHelper.addAllStorageUnits( true );
150:         UUID productId2 = productTestHelper.getProductId( 2 );
151:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
152: 
153:         // when
154:         // then
155:         assertThrows( ShopException.class,
156:                 () -> storageUnitUseCases.addToStock( nonExistingId1, nonExistingId2, 12 ) );
157:         assertThrows( ShopException.class,
158:                 () -> storageUnitUseCases.addToStock(
159:                         storageUnitId0, nonExistingId2, 12 ) );
160:         assertThrows( ShopException.class,
161:                 () -> storageUnitUseCases.addToStock(
162:                         nonExistingId1, productId2, 12 ) );
163:         assertThrows( ShopException.class,
164:                 () -> storageUnitUseCases.addToStock(
165:                         storageUnitId0, productId2, -1 ) );
166:     }
167: 
168: 
169:     @Test
170:     public void testRemoveFromStock() {
171:         // given
172:         storageUnitTestHelper.addAllStorageUnits( true );
173:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
174:         UUID productId0 = productTestHelper.getProductId( 0 ); // 0 in storage unit 0
175:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in storage unit 0
176:         UUID productId6 = productTestHelper.getProductId( 6 ); // random >30 in storage unit 0
177:         int stock0before =
178:                 storageUnitTestHelper.getStorageUnitStock( 0, 0 );
179:         int stock5before =
180:                 storageUnitTestHelper.getStorageUnitStock( 0, 5 );
181:         int stock6before =
182:                 storageUnitTestHelper.getStorageUnitStock( 0, 6 );
183: 
184:         // when
185:         storageUnitUseCases.removeFromStock( storageUnitId0, productId5, 1 );
186:         int stock5after = storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
187:         storageUnitUseCases.removeFromStock( storageUnitId0, productId0, 0 );
188:         int stock0after = storageUnitUseCases.getAvailableStock( storageUnitId0, productId0 );
189:         storageUnitUseCases.removeFromStock(
190:                 storageUnitId0, productId6, stock6before );
191:         int stock6after = storageUnitUseCases.getAvailableStock( storageUnitId0, productId6 );
192: 
193:         // then
194:         assertEquals( stock5before - 1, stock5after );
195:         assertEquals( stock0before, stock0after );
196:         assertEquals( 0, stock6after );
197:     }
198: 
199: 
200:     @Test
201:     public void testInvalidRemoveFromStock() {
202:         // given
203:         storageUnitTestHelper.addAllStorageUnits( true );
204:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
205:         UUID productId0 = productTestHelper.getProductId( 0 ); // 0 in storage unit 0
206:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in storage unit 0
207:         int stock5before =
208:                 storageUnitTestHelper.getStorageUnitStock( 0, 5 );
209: 
210:         // when
211:         // then
212:         assertThrows( ShopException.class,
213:                 () -> storageUnitUseCases.removeFromStock( nonExistingId1, nonExistingId2, 12 ) );
214:         assertThrows( ShopException.class,
215:                 () -> storageUnitUseCases.removeFromStock(
216:                         storageUnitId0, nonExistingId2, 12 ) );
217:         assertThrows( ShopException.class,
218:                 () -> storageUnitUseCases.removeFromStock(
219:                         nonExistingId1, productId5, 12 ) );
220:         assertThrows( ShopException.class,
221:                 () -> storageUnitUseCases.removeFromStock(
222:                         storageUnitId0, productId5, -1 ) );
223:         assertThrows( ShopException.class,
224:                 () -> storageUnitUseCases.removeFromStock(
225:                         storageUnitId0, productId5, stock5before + 1 ) );
226:         assertThrows( ShopException.class,
227:                 () -> storageUnitUseCases.removeFromStock(
228:                         storageUnitId0, productId0, 1 ) ); // already 0 in storage unit 0
229:     }
230: 
231: 
232:     @Test
233:     public void testChangeStock() {
234:         // given
235:         storageUnitTestHelper.addAllStorageUnits( true );
236:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
237:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in storage unit 0
238: 
239:         // when
240:         storageUnitUseCases.changeStockTo( storageUnitId0, productId5, 111 );
241:         int stock5after = storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
242: 
243:         // then
244:         assertEquals( 111, stock5after );
245:     }
246: 
247: 
248:     @Test
249:     public void testInvalidChangeStock() {
250:         // given
251:         storageUnitTestHelper.addAllStorageUnits( true );
252:         UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
253:         UUID productId6 = productTestHelper.getProductId( 6 );
254: 
255:         // when
256:         // then
257:         assertThrows( ShopException.class, () -> storageUnitUseCases.changeStockTo(
258:                 nonExistingId1, nonExistingId2, 12 ) );
259:         assertThrows( ShopException.class, () -> storageUnitUseCases.changeStockTo(
260:                 nonExistingId1, productId6, 12 ) );
261:         assertThrows( ShopException.class, () -> storageUnitUseCases.changeStockTo(
262:                 storageUnitId0, nonExistingId2, 12 ) );
263:         assertThrows( ShopException.class, () -> storageUnitUseCases.changeStockTo(
264:                 storageUnitId0, productId6, -1 ) );
265:     }
266: 
267: 
268:     @Test
269:     public void testEmptyStorageUnit() {
270:         // given
271:         storageUnitTestHelper.addAllStorageUnits( true );
272:         UUID storageUnitId9 = storageUnitTestHelper.getStorageUnitId( 9 ); // empty storage unit
273: 
274:         // when
275:         int totalStock = 0;
276:         for ( int iProduct = 0; iProduct < productTestHelper.numberOfProducts(); iProduct++ ) {
277:             UUID productId = productTestHelper.getProductId( iProduct );
278:             totalStock += storageUnitUseCases.getAvailableStock(
279:                     storageUnitId9, productId );
280:         }
281: 
282:         // then
283:         assertEquals( 0, totalStock );
284:     }
285: 
286: 
287: 
288: }
289: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
1: package thkoeln.archilab.ecommerce.tests.testtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.domain.JavaMethod;
6: import com.tngtech.archunit.core.importer.ClassFileImporter;
7: import com.tngtech.archunit.lang.ArchRule;
8: import org.junit.jupiter.api.BeforeEach;
9: import org.junit.jupiter.api.Test;
10: import org.springframework.web.bind.annotation.RestController;
11: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
12: import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
13: import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingBasketRESTTest;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
18: 
19: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
20: import static org.springframework.test.util.AssertionErrors.assertTrue;
21: 
22: /**
23:  * This test checks if there are the appropriate tests in the test class(es) for domain
24:  * primitives.
25:  */
26: 
27: public class RulesForOwnTests {
28:     private JavaClass dpTestClass, restTestClass;
29:     private JavaClasses dpTestClasses, restTestClasses;
30:     private static final String STORAGE_UNIT_DOMAIN_PACKAGE =
31:             "thkoeln.archilab.ecommerce.solution.storageunit.domain";
32:     private static final String STORAGE_UNIT_CLASS_NAME =
33:             STORAGE_UNIT_DOMAIN_PACKAGE + ".StorageUnit";
34: 
35: 
36:     @BeforeEach
37:     public void setUp() throws Exception {
38:         dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
39:         restTestClass = new ClassFileImporter().importClass( OwnShoppingBasketRESTTest.class );
40: 
41:         dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
42:         restTestClasses = new ClassFileImporter().importClasses( OwnShoppingBasketRESTTest.class );
43:     }
44: 
45: 
46:     @Test
47:     public void ensureMinimumNumberOfTestMethods() {
48:         // given
49:         // when
50:         int dpTestMethodCount = getTestMethodCount( dpTestClass );
51:         int restTestMethodCount = getTestMethodCount( restTestClass );
52: 
53:         // then
54:         assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
55:                         + dpTestMethodCount,dpTestMethodCount >= 2 );
56:         assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
57:                         + restTestMethodCount, restTestMethodCount >= 5 );
58:     }
59: 
60:     private int getTestMethodCount( JavaClass testClass ) {
61:         int testMethodCount = 0;
62:         for ( JavaMethod method : testClass.getMethods() ) {
63:             if ( isTestMethod( method ) ) {
64:                 testMethodCount++;
65:             }
66:         }
67:         return testMethodCount;
68:     }
69: 
70:     private boolean isTestMethod( JavaMethod method ) {
71:         return method.isAnnotatedWith( Test.class );
72:     }
73: 
74: 
75:     @Test
76:     public void dpTestsShouldReferenceTheRightClasses() {
77:         ArchRule rule = classes()
78:                 .should().dependOnClassesThat()
79:                 .areAssignableTo( ZipCodeType.class )
80:                 .andShould().dependOnClassesThat()
81:                 .areAssignableTo( MoneyType.class )
82:                 .andShould().dependOnClassesThat()
83:                 .areAssignableTo( AddressType.class )
84:                 .andShould().dependOnClassesThat()
85:                 .areAssignableTo( EmailAddressType.class )
86:                 .because( "DomainPrimitiveJSONSerializationTest should reference ZipCode, " +
87:                         "Money, EmailAddress, and Address!" );
88:         rule.check( dpTestClasses );
89:     }
90: 
91: 
92:     @Test
93:     public void restTestsShouldReferenceEmailAddress() {
94:         ArchRule rule = classes()
95:                 .should().dependOnClassesThat()
96:                 .areAssignableTo( EmailAddressType.class )
97:                 .because( "StorageUnitComparatorUnitTest should reference EmailAddressType!" );
98:         rule.check( restTestClasses );
99:     }
100: 
101: 
102:     @Test
103:     public void restTestsShouldReferenceRESTControllers() {
104:         ArchRule rule = classes()
105:                 .should().dependOnClassesThat()
106:                 .areAnnotatedWith( RestController.class )
107:                 .orShould().dependOnClassesThat()
108:                 .areAssignableTo( ShoppingBasketRESTHelper.class )
109:                 .because( "StorageUnitComparatorUnitTest should call REST controllers! " +
110:                         "(either directly or via the ShoppingBasketRESTHelper REST helper)" );
111:         rule.check( restTestClasses );
112:     }
113: 
114: }
115: 

[RESPONSE]:
Thkoeln\archilab\ecommerce\domainprimitives\EmailAddress.java
41-47: Duplication: 60-66 : Die Iteration durch das Char-Array, um das '@' Zeichen zu finden, ist identisch implementiert.

Thkoeln\archilab\ecommerce\domainprimitives\Money.java
56-57: Duplication: 48-49 : Die Überprüfung, ob das andere Money-Objekt null ist oder eine andere Währung hat, wird mehrfach identisch durchgeführt.
75-76: Duplication: 48-49 : Die Überprüfung, ob das andere Money-Objekt null ist oder eine andere Währung hat, wird mehrfach identisch durchgeführt.

Thkoeln\archilab\ecommerce\solution\customer\domain\Customer.java
-Anemic Entity-

Thkoeln\archilab\ecommerce\solution\order\application\OrderService.java
25: Shared persistency : Der OrderService greift direkt auf das CustomerRepository aus dem Customer-Package zu.

Thkoeln\archilab\ecommerce\solution\order\domain\Order.java
-Anemic Entity-

Thkoeln\archilab\ecommerce\solution\order\domain\OrderPart.java
-Anemic Entity-

Thkoeln\archilab\ecommerce\solution\product\domain\Product.java
-Anemic Entity-

Thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java
35: Shared persistency : Der ShoppingBasketService greift direkt auf das CustomerRepository aus dem Customer-Package zu.
38: Shared persistency : Der ShoppingBasketService greift direkt auf das ProductRepository aus dem Product-Package zu.
88-89: Duplication: 60-61 : Die Validierung der Eingabeparameter (Email, ProductId, Quantity) ist in mehreren Methoden identisch.
110-111: Duplication: 60-61 : Die Validierung der Eingabeparameter (Email, ProductId) ist in mehreren Methoden identisch.
144-162: missplaced resonsibility : Die Berechnung des Gesamtwertes des Warenkorbs ist Geschäftslogik, die in die ShoppingBasket Entity gehört, nicht in den Service.

Thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java
-Anemic Entity-

Thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPart.java
-Anemic Entity-

Thkoeln\archilab\ecommerce\solution\storageunit\application\StorageUnitAdapterService.java
64-66: Duplication: 54-56 : Die Prüfung auf Null-Werte für storageUnitId und productId ist in mehreren Methoden identisch.
75-77: Duplication: 54-56 : Die Prüfung auf Null-Werte für storageUnitId und productId ist in mehreren Methoden identisch.
86-88: Duplication: 54-56 : Die Prüfung auf Null-Werte für storageUnitId und productId ist in mehreren Methoden identisch.

Thkoeln\archilab\ecommerce\solution\storageunit\application\StorageUnitService.java
22: Shared persistency : Der StorageUnitService greift direkt auf das ProductRepository aus dem Product-Package zu.

Thkoeln\archilab\ecommerce\solution\storageunit\domain\StockLevel.java
-Anemic Entity-

Thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnit.java
46-67: missplaced resonsibility : Die Entity StorageUnit injiziert einen Service/Interface (StockLevelQueryDip), um Daten abzurufen. Entities sollten keine Abhängigkeiten zu Services haben; die benötigten Daten sollten übergeben werden.

ENDE
Generated by gemini-3-pro-preview
-----------------------------------