--- DATE: 13.1.2026, 16:11:36 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
        Architektur: 4-Layer (Eric Evans).
        Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
        Regeln:
        1. Begründe kurz jeden Fund.
        4. Gruppiere nach Datei (mit Pfad). 
        2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
        3. Keine Code-Wiederholung, nur Referenzen.
        5. Wenn fertig, schreibe "ENDE". 
        6. Nutze die Zeilenangaben die mitgeschickt worden sind.



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Email.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonCreator;
4: import com.fasterxml.jackson.annotation.JsonProperty;
5: import jakarta.persistence.Embeddable;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
7: import thkoeln.archilab.ecommerce.ShopException;
8: 
9: @Embeddable
10: public class Email implements EmailType {
11:     @JsonProperty
12:     private final String email;
13: 
14:     // Parameterloser Konstruktor für JPA
15:     protected Email() {
16:         this.email = null; // Platzhalter-Wert, wird durch JPA/Hibernate überschrieben
17:     }
18: 
19:     private Email(String email) {
20:         this.email = email;
21:     }
22: 
23:     @JsonCreator
24:     public static Email of(@JsonProperty("email") String emailAsString) {
25:         validateEmail(emailAsString);
26:         return new Email(emailAsString);
27:     }
28: 
29:     private static void validateEmail(String email) throws ShopException {
30:         if (email == null) {
31:             throw new ShopException("Email cannot be null");
32:         }
33:         String[] parts = email.split("@");
34:         if (parts.length != 2) {
35:             throw new ShopException("Email must contain exactly one '@' character");
36:         }
37: 
38:         String identifier = parts[0];
39:         String domain = parts[1];
40: 
41:         if (!isValidIdentifier(identifier)) {
42:             throw new ShopException("Invalid identifier");
43:         }
44: 
45:         if (!isValidDomain(domain)) {
46:             throw new ShopException("Invalid domain");
47:         }
48:     }
49: 
50:     private static boolean isValidDomain(String domain) {
51:         if (domain.isEmpty() || domain.contains("..")) {
52:             return false;
53:         }
54:         String[] domainParts = domain.split("\\.");
55:         if (domainParts.length < 2) {
56:             return false;
57:         }
58:         String topLevelDomain = domainParts[domainParts.length - 1];
59:         if (!(topLevelDomain.equals("de") || topLevelDomain.equals("at") || topLevelDomain.equals("ch")
60:                 || topLevelDomain.equals("com") || topLevelDomain.equals("org"))) {
61:             return false;
62:         }
63:         for (String part : domainParts) {
64:             if (!part.matches("[A-Za-z0-9]+")) {
65:                 return false;
66:             }
67:         }
68:         return true;
69:     }
70: 
71:     private static boolean isValidIdentifier(String identifier) {
72:         if (identifier.isEmpty() || identifier.contains("..") || identifier.contains(" ")) {
73:             return false;
74:         }
75:         String[] identifierParts = identifier.split("\\.");
76:         for (String part : identifierParts) {
77:             if (!part.matches("[A-Za-z0-9]+")) {
78:                 return false;
79:             }
80:         }
81:         return true;
82:     }
83: 
84:     @Override
85:     public String toString() {
86:         return email;
87:     }
88: 
89:     @Override
90:     public EmailType sameIdentifyerDifferentDomain(String domainString) throws ShopException {
91:         if (domainString == null || !isValidDomain(domainString)) {
92:             throw new ShopException("Invalid domain");
93:         }
94:         String[] parts = email.split("@");
95:         String newEmail = parts[0] + "@" + domainString;
96:         return Email.of(newEmail);
97:     }
98: 
99:     @Override
100:     public EmailType sameDomainDifferentIdentifyer(String identifyerString) throws ShopException {
101:         if (identifyerString == null || !isValidIdentifier(identifyerString)) {
102:             throw new ShopException("Invalid identifier");
103:         }
104:         String[] parts = email.split("@");
105:         String newEmail = identifyerString + "@" + parts[1];
106:         return Email.of(newEmail);
107:     }
108: 
109:     @Override
110:     public boolean equals(Object obj) {
111:         if (this == obj) return true;
112:         if (obj == null || getClass() != obj.getClass()) return false;
113:         Email email1 = (Email) obj;
114:         return email.equals(email1.email);
115:     }
116: 
117:     @Override
118:     public int hashCode() {
119:         return email.hashCode();
120:     }
121: }
122: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\EmailDTO.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: public class EmailDTO {
4:     private String emailString;
5: 
6:     public EmailDTO(String emailString) {
7:         this.emailString = emailString;
8:     }
9: 
10:     // Getter method
11:     public String getEmailString() { return emailString; }
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Column;
4: import jakarta.persistence.Embeddable;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: import thkoeln.archilab.ecommerce.ShopException;
7: 
8: @Embeddable
9: public class Money implements MoneyType {
10:     private final Float amount;
11: 
12:     @Column(insertable = false, updatable = false)
13:     private final String currencyUnit;
14: 
15:     // Parameterloser Konstruktor für JPA/Hibernate
16:     protected Money() {
17:         // Default-Werte setzen; keine Initialisierung finaler Felder erlauben.
18:         this.amount = null;
19:         this.currencyUnit = null;
20:     }
21: 
22:     private Money(Float amount, String currencyUnit) {
23:         this.amount = amount;
24:         this.currencyUnit = currencyUnit;
25:     }
26: 
27:     public static Money of(Float amount, String currencyUnit) throws ShopException {
28:         if (amount == null || amount < 0) {
29:             throw new ShopException("Invalid amount");
30:         }
31:         if (currencyUnit == null || !(currencyUnit.equals("EUR") || currencyUnit.equals("CHF"))) {
32:             throw new ShopException("Invalid currency unit");
33:         }
34:         return new Money(amount, currencyUnit);
35:     }
36: 
37:     @Override
38:     public Float getAmount() {
39:         return amount;
40:     }
41: 
42:     @Override
43:     public String getCurrencyUnit() {
44:         return currencyUnit;
45:     }
46: 
47:     @Override
48:     public MoneyType add(MoneyType otherMoney) throws ShopException {
49:         String thisCurrency = (currencyUnit != null) ? currencyUnit : "EUR"; // Standardwährung
50:         String otherCurrency = (otherMoney.getCurrencyUnit() != null) ? otherMoney.getCurrencyUnit() : "EUR"; // Standardwährung
51: 
52:         if (otherMoney == null || !thisCurrency.equals(otherCurrency)) {
53:             throw new ShopException("Invalid add operation");
54:         }
55:         return new Money(amount + otherMoney.getAmount(), thisCurrency);
56:     }
57: 
58:     @Override
59:     public MoneyType subtract(MoneyType otherMoney) throws ShopException {
60:         if (otherMoney == null || !currencyUnit.equals(otherMoney.getCurrencyUnit()) || otherMoney.getAmount() > amount) {
61:             throw new ShopException("Invalid subtract operation");
62:         }
63:         return new Money(amount - otherMoney.getAmount(), currencyUnit);
64:     }
65: 
66:     @Override
67:     public MoneyType multiplyBy(int factor) throws ShopException {
68:         if (factor < 0) {
69:             throw new ShopException("Invalid multiply operation");
70:         }
71:         return new Money(amount * factor, currencyUnit);
72:     }
73: 
74:     @Override
75:     public boolean largerThan(MoneyType otherMoney) throws ShopException {
76:         if (otherMoney == null || !currencyUnit.equals(otherMoney.getCurrencyUnit())) {
77:             throw new ShopException("Invalid comparison");
78:         }
79:         return amount > otherMoney.getAmount();
80:     }
81: 
82:     @Override
83:     public boolean equals(Object obj) {
84:         if (this == obj) return true;
85:         if (obj == null || getClass() != obj.getClass()) return false;
86:         Money money = (Money) obj;
87: 
88:         // Debug-Ausgaben
89:         System.out.println("Comparing Money objects: ");
90:         System.out.println("This Money - amount: " + this.amount + ", currencyUnit: " + this.currencyUnit);
91:         System.out.println("Other Money - amount: " + money.amount + ", currencyUnit: " + money.currencyUnit);
92: 
93:         return (amount != null ? amount.equals(money.amount) : money.amount == null) &&
94:                 (currencyUnit != null ? currencyUnit.equals(money.currencyUnit) : money.currencyUnit == null);
95:     }
96: 
97:     @Override
98:     public int hashCode() {
99:         int result = (amount != null) ? amount.hashCode() : 0;
100:         result = 31 * result + ((currencyUnit != null) ? currencyUnit.hashCode() : 0);
101:         return result;
102:     }
103: 
104:     public String toFormattedString() {
105:         if (currencyUnit.equals("EUR")) {
106:             return String.format("%.2f €", amount);
107:         } else if (currencyUnit.equals("CHF")) {
108:             return String.format("%.2f CHF", amount);
109:         }
110:         return String.format("%.2f %s", amount, currencyUnit);
111:     }
112: 
113: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PhysicalAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import jakarta.persistence.Embeddable;
5: import jakarta.persistence.Embedded;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
9: 
10: @Embeddable
11: public class PhysicalAddress implements PhysicalAddressType {
12:     @JsonProperty
13:     private String street;
14: 
15:     @JsonProperty
16:     private String city;
17: 
18:     @Embedded
19:     @JsonProperty
20:     private ZipCode zipCode; // Änderung hier, um sicherzustellen, dass ZipCode korrekt angemerkt ist
21: 
22:     private PhysicalAddress(String street, String city, ZipCodeType zipCode) {
23:         this.street = street;
24:         this.city = city;
25:         this.zipCode = (ZipCode) zipCode;
26:     }
27: 
28:     public static PhysicalAddress of(String street, String city, ZipCodeType zipCode) throws ShopException {
29:         if (street == null || street.isEmpty()) {
30:             throw new ShopException("Invalid street");
31:         }
32:         if (city == null || city.isEmpty()) {
33:             throw new ShopException("Invalid city");
34:         }
35:         if (zipCode == null) {
36:             throw new ShopException("Invalid zip code");
37:         }
38:         return new PhysicalAddress(street, city, zipCode);
39:     }
40: 
41:     @Override
42:     public String getStreet() {
43:         return street;
44:     }
45: 
46:     @Override
47:     public String getCity() {
48:         return city;
49:     }
50: 
51:     @Override
52:     public ZipCodeType getZipCode() {
53:         return zipCode;
54:     }
55: 
56:     @Override
57:     public boolean equals(Object o) {
58:         if (this == o) return true;
59:         if (o == null || getClass() != o.getClass()) return false;
60: 
61:         PhysicalAddress that = (PhysicalAddress) o;
62: 
63:         if (!street.equals(that.street)) return false;
64:         if (!city.equals(that.city)) return false;
65:         return zipCode.equals(that.zipCode);
66:     }
67: 
68:     @Override
69:     public int hashCode() {
70:         int result = street.hashCode();
71:         result = 31 * result + city.hashCode();
72:         result = 31 * result + zipCode.hashCode();
73:         return result;
74:     }
75: 
76:     // Default constructor for JPA and Jackson
77:     protected PhysicalAddress() {
78:         this.street = null;
79:         this.city = null;
80:         this.zipCode = null;
81:     }
82: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PhysicalAddressDTO.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
4: 
5: public class PhysicalAddressDTO {
6:     private String street;
7:     private String city;
8:     private ZipCodeDTO zipCode;
9: 
10:     public PhysicalAddressDTO(PhysicalAddressType physicalAddress) {
11:         this.street = physicalAddress.getStreet();
12:         this.city = physicalAddress.getCity();
13:         this.zipCode = new ZipCodeDTO(physicalAddress.getZipCode().toString());
14:     }
15: 
16:     // Getter methods
17:     public String getStreet() { return street; }
18:     public String getCity() { return city; }
19:     public ZipCodeDTO getZipCode() { return zipCode; }
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import jakarta.persistence.Embeddable;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
6: import thkoeln.archilab.ecommerce.ShopException;
7: 
8: @Embeddable
9: public class ZipCode implements ZipCodeType {
10:     @JsonProperty
11:     private String zipCode;
12: 
13:     protected ZipCode() {
14:         this.zipCode = null; // Placeholder, overwritten by JPA/Hibernate
15:     }
16: 
17:     private ZipCode(String zipCode) {
18:         this.zipCode = zipCode;
19:     }
20: 
21:     public static ZipCode of(String zipCodeAsString) throws ShopException {
22:         if (!isValidZipCode(zipCodeAsString)) {
23:             throw new ShopException("Invalid zip code");
24:         }
25:         return new ZipCode(zipCodeAsString);
26:     }
27: 
28:     private static boolean isValidZipCode(String zipCode) {
29:         return zipCode != null && zipCode.matches("\\d{5}") && !zipCode.endsWith("0000");
30:     }
31: 
32:     @Override
33:     public String toString() {
34:         return zipCode;
35:     }
36: 
37:     @Override
38:     public int difference(ZipCodeType otherZipCode) {
39:         if (otherZipCode == null) {
40:             throw new ShopException("Zip code must not be null");
41:         }
42: 
43:         String zip1 = this.zipCode;
44:         String zip2 = otherZipCode.toString();
45: 
46:         if (zip1.equals(zip2)) {
47:             return 0;
48:         }
49: 
50:         int maxDiffPos = 0;
51:         for (int i = 4; i >= 1; i--) {
52:             if (zip1.charAt(i) != zip2.charAt(i)) {
53:                 maxDiffPos = Math.max(maxDiffPos, 5 - i);
54:             }
55:         }
56: 
57:         int d1 = Character.getNumericValue(zip1.charAt(0));
58:         int d2 = Character.getNumericValue(zip2.charAt(0));
59:         int regionDiff = Math.min(Math.abs(d1 - d2), 10 - Math.abs(d1 - d2));
60: 
61:         return regionDiff * 10 + maxDiffPos;
62:     }
63: 
64:     private int calculateDifference(String zip1, String zip2) {
65:         int difference = 0;
66:         int weight = 1;
67: 
68:         for (int i = zip1.length() - 1; i >= 0; i--) {
69:             if (zip1.charAt(i) != zip2.charAt(i)) {
70:                 difference += weight;
71:             }
72:             weight *= 10;
73:         }
74: 
75:         // Zusätzliche Bearbeitung der ersten Ziffern als benachbarte Bereiche
76:         if (areAdjacent(zip1.charAt(0), zip2.charAt(0))) {
77:             difference -= (weight / 100);  // Korrigiere die Differenz für benachbarte Regionen
78:         }
79: 
80:         return difference;
81:     }
82: 
83:     private boolean areAdjacent(char a, char b) {
84:         // Benachbarte Ziffern in einem numerischen Kreis
85:         int diff = Math.abs(Character.getNumericValue(a) - Character.getNumericValue(b));
86:         return diff == 1 || diff == 9; // Ziffern 0 und 9 sind auch benachbart
87:     }
88: 
89:     @Override
90:     public Integer getFirstDigitZipCode() {
91:         return Character.getNumericValue(zipCode.charAt(0));
92:     }
93: 
94:     @Override
95:     public boolean equals(Object obj) {
96:         if (this == obj) return true;
97:         if (obj == null || getClass() != obj.getClass()) return false;
98:         ZipCode zipCode1 = (ZipCode) obj;
99:         return zipCode != null && zipCode.equals(zipCode1.zipCode);
100:     }
101: 
102:     @Override
103:     public int hashCode() {
104:         return zipCode != null ? zipCode.hashCode() : 0;
105:     }
106: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCodeDTO.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: public class ZipCodeDTO {
4:     private String zipCodeString;
5: 
6:     public ZipCodeDTO(String zipCodeString) {
7:         this.zipCodeString = zipCodeString;
8:     }
9: 
10:     // Getter method
11:     public String getZipCodeString() { return zipCodeString; }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.Column;
7: import jakarta.persistence.MappedSuperclass;
8: import lombok.EqualsAndHashCode;
9: import lombok.Getter;
10: import lombok.ToString;
11: 
12: import java.io.Serializable;
13: import java.util.UUID;
14: 
15: @MappedSuperclass
16: @Getter
17: @EqualsAndHashCode(of = "id")
18: @ToString(of = "id")
19: public abstract class GenericId implements Serializable {
20:     @Column(nullable = false, updatable = false)
21:     private final UUID id;
22: 
23:     protected GenericId() {
24:         this( UUID.randomUUID() );
25:     }
26: 
27:     protected GenericId( UUID id ) {
28:         this.id = id;
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.AttributeConverter;
7: 
8: import java.util.UUID;
9: import java.util.function.Function;
10: 
11: 
12: public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
13:     private final Function<UUID, T> factory;
14: 
15:     protected GenericIdConverter( Function<UUID, T> factory ) {
16:         this.factory = factory;
17:     }
18: 
19:     @Override
20:     public UUID convertToDatabaseColumn( T attribute ) {
21:         return attribute == null ? null : attribute.getId();
22:     }
23: 
24:     @Override
25:     public T convertToEntityAttribute( UUID dbData ) {
26:         return dbData == null ? null : factory.apply( dbData );
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\InsufficientStockException.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: /**
7:  * Exception is thrown if the item's stock level is not sufficient to serve the order.
8:  */
9: public class InsufficientStockException extends ShopException {
10:     public InsufficientStockException( String message ) {
11:         super( message );
12:     }
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import org.springframework.boot.SpringApplication;
7: import org.springframework.boot.autoconfigure.SpringBootApplication;
8: 
9: 
10: @SpringBootApplication
11: public class ProjectApplication {
12: 
13: 	/**
14: 	 * Entry method
15: 	 * @param args
16: 	 */
17: 	public static void main(String[] args) {
18: 		SpringApplication.run(ProjectApplication.class, args);
19: 	}
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: public class ShopException extends RuntimeException {
7:     public ShopException( String message ) {
8:         super( message );
9:     }
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientAdapterHelper.java ---
1: package thkoeln.archilab.ecommerce.solution.client.application;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.domainprimitives.Email;
5: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
8: 
9: public class ClientAdapterHelper {
10:     public static Email convertToEmail(EmailType emailType) throws ShopException {
11:         if (emailType instanceof Email) {
12:             return (Email) emailType;
13:         }
14:         throw new ShopException("Invalid EmailType");
15:     }
16: 
17:     public static PhysicalAddress convertToPhysicalAddress(PhysicalAddressType addressType) throws ShopException {
18:         if (addressType instanceof PhysicalAddress) {
19:             return (PhysicalAddress) addressType;
20:         }
21:         throw new ShopException("Invalid PhysicalAddressType");
22:     }
23: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientController.java ---
1: package thkoeln.archilab.ecommerce.solution.client.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.http.HttpStatus;
5: import org.springframework.http.MediaType;
6: import org.springframework.http.ResponseEntity;
7: import org.springframework.web.bind.annotation.GetMapping;
8: import org.springframework.web.bind.annotation.RequestMapping;
9: import org.springframework.web.bind.annotation.RequestParam;
10: import org.springframework.web.bind.annotation.RestController;
11: import thkoeln.archilab.ecommerce.ShopException;
12: import thkoeln.archilab.ecommerce.domainprimitives.Email;
13: import thkoeln.archilab.ecommerce.domainprimitives.EmailDTO;
14: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddressDTO;
15: import thkoeln.archilab.ecommerce.domainprimitives.ZipCodeDTO;
16: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
17: import thkoeln.archilab.ecommerce.solution.client.domain.ClientResponseDTO;
18: import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
19: import thkoeln.archilab.ecommerce.usecases.ClientType;
20: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
21: 
22: import java.util.UUID;
23: 
24: @RestController
25: @RequestMapping("/clients")
26: public class ClientController {
27: 
28:     @Autowired
29:     private ClientRegistrationUseCases clientRegistrationService;
30: 
31:     @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
32:     public ResponseEntity<ClientResponseDTO> getClientByEmail(@RequestParam(name = "email", required = false) String emailString) {
33:         if (emailString == null || emailString.isEmpty()) {
34:             return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).build();
35:         }
36: 
37:         try {
38:             Email email = Email.of(emailString);
39:             ClientType clientData = clientRegistrationService.getClientData(email);
40:             ClientResponseDTO response = mapToClientResponseDTO(clientData);
41:             return ResponseEntity.ok(response);
42:         } catch (ShopException e) {
43:             return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
44:         }
45:     }
46: 
47:     private ClientResponseDTO mapToClientResponseDTO(ClientType client) {
48:         UUID clientId = ((Client) client).getId().getId();
49:         Email email = (Email) client.getEmail();
50:         PhysicalAddressDTO addressDTO = new PhysicalAddressDTO(client.getPhysicalAddress());
51: 
52:         return new ClientResponseDTO(
53:                 clientId,
54:                 client.getName(),
55:                 email.toString(),
56:                 addressDTO
57:         );
58:     }
59: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientRegistrationService.java ---
1: package thkoeln.archilab.ecommerce.solution.client.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Email;
7: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
8: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
9: import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
10: import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
11: import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
12: import thkoeln.archilab.ecommerce.usecases.ClientType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
15: 
16: import java.util.Optional;
17: import java.util.UUID;
18: 
19: @Service
20: public class ClientRegistrationService implements ClientRegistrationUseCases {
21: 
22:     @Autowired
23:     private ClientRepository clientRepository;
24: 
25:     @Autowired
26:     private ClientSBServiceInterface clientSBServiceInterface;
27: 
28:     @Override
29:     public void register(String name, EmailType email, PhysicalAddressType physicalAddress) {
30:         if (name == null || name.isEmpty()) {
31:             throw new ShopException("Error: Name cannot be null or empty");
32:         }
33: 
34:         Email emailEntity = ClientAdapterHelper.convertToEmail(email);
35:         PhysicalAddress addressEntity = ClientAdapterHelper.convertToPhysicalAddress(physicalAddress);
36: 
37:         ClientId clientId = ClientId.fromEmail(emailEntity.toString());
38: 
39:         if (clientRepository.existsById(clientId)) {
40:             throw new ShopException("Error: A client with the given email already exists");
41:         }
42: 
43:         UUID basketId = clientSBServiceInterface.createShoppingBasketForClient();
44: 
45:         Client client = new Client(name, emailEntity, addressEntity, basketId);
46:         clientRepository.save(client);
47:     }
48: 
49:     @Override
50:     public void changeAddress(EmailType clientEmail, PhysicalAddressType physicalAddress) {
51:         Email emailEntity = ClientAdapterHelper.convertToEmail(clientEmail);
52:         PhysicalAddress addressEntity = ClientAdapterHelper.convertToPhysicalAddress(physicalAddress);
53: 
54:         ClientId clientId = ClientId.fromEmail(emailEntity.toString());
55: 
56:         Client client = clientRepository.findById(clientId)
57:                 .orElseThrow(() -> new ShopException("The client with the given email does not exist"));
58: 
59:         client.setPhysicalAddress(addressEntity);
60:         clientRepository.save(client);
61:     }
62: 
63:     @Override
64:     public ClientType getClientData(EmailType clientEmail) {
65:         Email emailEntity = ClientAdapterHelper.convertToEmail(clientEmail);
66:         ClientId clientId = ClientId.fromEmail(emailEntity.toString());
67: 
68:         return clientRepository.findById(clientId)
69:                 .orElseThrow(() -> new ShopException("Error: Client not found"));
70:     }
71: 
72:     @Override
73:     public void deleteAllClients() {
74:         clientRepository.deleteAll();
75:     }
76: 
77:     public EmailType getEmailByClientId(UUID clientId) {
78:         Client client = clientRepository.findById(new ClientId(clientId))
79:                 .orElseThrow(() -> new ShopException("Client not found"));
80:         return client.getEmail();
81:     }
82: 
83:     public Optional<Client> findById(ClientId clientId) {
84:         return clientRepository.findById(clientId);
85:     }
86: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientSBServiceInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.client.application;
2: 
3: import java.util.UUID;
4: 
5: public interface  ClientSBServiceInterface {
6:     UUID createShoppingBasketForClient();
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\Client.java ---
1: package thkoeln.archilab.ecommerce.solution.client.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.domainprimitives.Email;
8: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
9: import thkoeln.archilab.ecommerce.usecases.ClientType;
10: 
11: 
12: import java.util.UUID;
13: 
14: @Entity
15: @Getter
16: @Setter
17: @NoArgsConstructor
18: public class Client implements ClientType {
19: 
20:     @EmbeddedId
21:     private ClientId id;
22: 
23:     private String name;
24: 
25:     @Embedded
26:     private Email email;
27: 
28:     @Embedded
29:     private PhysicalAddress physicalAddress;
30: 
31:     @Column(name = "shopping_basket_id")
32:     private UUID shoppingBasketId;
33: 
34:     // Konstruktor mit Initialisierung
35:     public Client(String name, Email email, PhysicalAddress physicalAddress, UUID shoppingBasketId) {
36:         this.id = ClientId.fromEmail(email.toString());
37:         this.name = name;
38:         this.email = email;
39:         this.physicalAddress = physicalAddress;
40:         this.shoppingBasketId = shoppingBasketId;
41:     }
42: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ClientId.java ---
1: package thkoeln.archilab.ecommerce.solution.client.domain;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.AccessLevel;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.GenericId;
7: 
8: import java.util.UUID;
9: 
10: @Embeddable
11: @NoArgsConstructor(access = AccessLevel.PROTECTED)
12: public class ClientId extends GenericId {
13:     public ClientId(UUID id) {
14:         super(id);
15:     }
16: 
17:     public static ClientId fromEmail(String email) {
18:         return new ClientId(UUID.nameUUIDFromBytes(email.getBytes()));
19:     }
20: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ClientIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.client.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ClientIdConverter extends GenericIdConverter<ClientId> {
8:     public ClientIdConverter() {
9:         super(ClientId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ClientRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.client.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import thkoeln.archilab.ecommerce.domainprimitives.Email;
5: 
6: import java.util.Optional;
7: import java.util.UUID;
8: 
9: public interface ClientRepository extends CrudRepository<Client, ClientId> {
10: 
11:     Optional<Client> findByShoppingBasketId(UUID shoppingBasketId);
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ClientResponseDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.client.domain;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.EmailDTO;
4: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddressDTO;
5: 
6: import java.util.UUID;
7: 
8: public class ClientResponseDTO {
9:     private UUID id;
10:     private String name;
11:     private EmailDTO email;
12:     private PhysicalAddressDTO physicalAddress;
13: 
14:     public ClientResponseDTO(UUID id, String name, String email, PhysicalAddressDTO physicalAddress) {
15:         this.id = id;
16:         this.name = name;
17:         this.email = new EmailDTO(email);
18:         this.physicalAddress = physicalAddress;
19:     }
20: 
21:     public UUID getId() { return id; }
22:     public String getName() { return name; }
23:     public EmailDTO getEmail() { return email; }
24:     public PhysicalAddressDTO getPhysicalAddress() { return physicalAddress; }
25: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\Shoppable.java ---
1: package thkoeln.archilab.ecommerce.solution.client.domain;
2: 
3: import jakarta.persistence.*;
4: 
5: 
6: import java.util.HashMap;
7: import java.util.UUID;
8: 
9: @Entity
10: public abstract class Shoppable {
11: 
12:     @EmbeddedId
13:     private ShoppableId id;
14: 
15:     @Lob
16:     public HashMap<UUID, Integer> shoppingbasketInventory = new HashMap<UUID, Integer>();
17: 
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ShoppableId.java ---
1: package thkoeln.archilab.ecommerce.solution.client.domain;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.AccessLevel;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.GenericId;
7: 
8: import java.util.UUID;
9: 
10: @Embeddable
11: @NoArgsConstructor(access = AccessLevel.PROTECTED)
12: public class ShoppableId extends GenericId {
13:     public ShoppableId(UUID id) {
14:         super(id);
15:     }
16: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ShoppableIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.client.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ShoppableIdConverter extends GenericIdConverter<ShoppableId> {
8:     public ShoppableIdConverter() {
9:         super(ShoppableId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\application\DistributionCenterService.java ---
1: package thkoeln.archilab.ecommerce.solution.distributioncenter.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
7: import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.*;
8: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
9: import thkoeln.archilab.ecommerce.usecases.DistributionCenterUseCases;
10: import thkoeln.archilab.ecommerce.solution.item.domain.Item;
11: import thkoeln.archilab.ecommerce.solution.item.domain.ItemRepository;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
13: 
14: import java.util.HashSet;
15: import java.util.Map;
16: import java.util.Set;
17: import java.util.UUID;
18: 
19: @Service
20: public class DistributionCenterService implements DistributionCenterUseCases {
21: 
22:     @Autowired
23:     private DistributionCenterRepository distributionCenterRepository;
24: 
25:     @Autowired
26:     private StockLevelRepository stockLevelRepository;
27: 
28:     @Autowired
29:     private ItemRepository itemRepository;
30: 
31:     @Override
32:     public UUID addNewDistributionCenter(String name, PhysicalAddressType physicalAddress) {
33:         if (name == null || name.isEmpty()) {
34:             throw new ShopException("Name cannot be null or empty");
35:         }
36:         if (physicalAddress == null ||
37:                 physicalAddress.getStreet() == null || physicalAddress.getStreet().isEmpty() ||
38:                 physicalAddress.getCity() == null || physicalAddress.getCity().isEmpty() ||
39:                 physicalAddress.getZipCode() == null || physicalAddress.getZipCode().toString().isEmpty()) {
40:             throw new ShopException("Invalid address");
41:         }
42: 
43:         DistributionCenter distributionCenter = new DistributionCenter(name, (PhysicalAddress) physicalAddress, null);
44:         distributionCenterRepository.save(distributionCenter);
45:         return distributionCenter.getId().getId();
46:     }
47: 
48:     @Override
49:     public void deleteAllDistributionCenters() {
50:         // Zuerst alle StockLevels löschen, um referentielle Integrität zu gewährleisten
51:         stockLevelRepository.deleteAll();
52: 
53:         // Dann die DistributionCenters löschen
54:         distributionCenterRepository.deleteAll();
55:     }
56: 
57:     public UUID findSuitableDistributionCenter(String zipCode) {
58:         if (zipCode == null || zipCode.isEmpty()) {
59:             throw new ShopException("Invalid zip code");
60:         }
61: 
62:         // Logik zur Auswahl des Verteilzentrums basierend auf ZipCode
63:         for (DistributionCenter center : distributionCenterRepository.findAll()) {
64:             String zipCodeRange = center.getZipCodeRange();
65:             if (zipCodeRange == null) {
66:                 throw new ShopException("Zip code range not set for distribution center");
67:             }
68: 
69:             String[] range = zipCodeRange.split("-");
70:             if (range.length < 2) {
71:                 throw new ShopException("Zip code range format invalid");
72:             }
73: 
74:             int rangeStart = Integer.parseInt(range[0]);
75:             int rangeEnd = Integer.parseInt(range[1]);
76: 
77:             int firstDigitZip = Character.getNumericValue(zipCode.charAt(0));
78:             if (firstDigitZip >= rangeStart && firstDigitZip <= rangeEnd) {
79:                 return center.getId().getId();
80:             }
81:         }
82: 
83:         throw new ShopException("No suitable distribution center found for the given zip code");
84:     }
85: 
86:     private DistributionCenter findDistributionCenterById(UUID distributionCenterUuid) {
87:         if (distributionCenterUuid == null) {
88:             throw new ShopException("distributionCenterId is null");
89:         }
90: 
91:         // Konvertiere UUID in DistributionCenterId
92:         DistributionCenterId distributionCenterId = new DistributionCenterId(distributionCenterUuid);
93: 
94:         return distributionCenterRepository.findById(distributionCenterId)
95:                 .orElseThrow(() -> new ShopException("Distribution center does not exist"));
96:     }
97: 
98:     private Item findItemById(UUID itemIdUuid) {
99:         if (itemIdUuid == null) {
100:             throw new ShopException("itemId is null");
101:         }
102: 
103:         // Konvertiere die UUID in eine ItemId
104:         ItemId itemId = new ItemId(itemIdUuid);
105: 
106:         return itemRepository.findById(itemId)
107:                 .orElseThrow(() -> new ShopException("Item does not exist"));
108:     }
109: 
110:     @Override
111:     public void addToStock(UUID distributionCenterId, UUID itemId, int addedQuantFor) {
112:         if (addedQuantFor < 0) {
113:             throw new ShopException("addedQuantFor cannot be negative");
114:         }
115: 
116:         DistributionCenter distributionCenter = findDistributionCenterById(distributionCenterId);
117:         Item item = findItemById(itemId);
118: 
119:         StockLevel stockLevel = stockLevelRepository
120:                 .findByDistributionCenterAndItemId(distributionCenter, itemId)
121:                 .orElseGet(() -> {
122:                     StockLevel newStockLevel = new StockLevel(distributionCenter, itemId, 0);
123:                     newStockLevel.setId(new StockLevelId(UUID.randomUUID()));  // Zuweisung der ID
124:                     return stockLevelRepository.save(newStockLevel);
125:                 });
126: 
127:         stockLevel.setQuantity(stockLevel.getQuantity() + addedQuantFor);
128:         stockLevelRepository.save(stockLevel);
129:     }
130: 
131: 
132:     @Override
133:     public void removeFromStock(UUID distributionCenterId, UUID itemId, int removedQuantFor) {
134:         if (distributionCenterId == null) {
135:             throw new ShopException("distributionCenterId cannot be null");
136:         }
137:         if (itemId == null) {
138:             throw new ShopException("itemId cannot be null");
139:         }
140:         if (removedQuantFor < 0) {
141:             throw new ShopException("removedQuantFor cannot be negative");
142:         }
143:         if (removedQuantFor == 0) {
144:             // Verlassen der Methode, da keine Menge zu entfernen ist
145:             return;
146:         }
147: 
148:         DistributionCenter distributionCenter = findDistributionCenterById(distributionCenterId);
149:         if (distributionCenter == null) {
150:             throw new ShopException("Distribution center not found");
151:         }
152: 
153:         Item item = findItemById(itemId);
154:         if (item == null) {
155:             throw new ShopException("Item not found");
156:         }
157: 
158:         StockLevel stockLevel = stockLevelRepository
159:                 .findByDistributionCenterAndItemId(distributionCenter, itemId)
160:                 .orElseThrow(() -> new ShopException("Stock level not found"));
161: 
162:         if (stockLevel.getQuantity() < removedQuantFor) {
163:             throw new ShopException("Insufficient stock to remove");
164:         }
165: 
166:         stockLevel.setQuantity(stockLevel.getQuantity() - removedQuantFor);
167:         stockLevelRepository.save(stockLevel);
168:     }
169: 
170: 
171:     @Override
172:     public void changeStockTo(UUID distributionCenterId, UUID itemId, int newTotalQuantFor) {
173:         if (newTotalQuantFor < 0) {
174:             throw new ShopException("newTotalQuantFor cannot be negative");
175:         }
176: 
177:         DistributionCenter distributionCenter = findDistributionCenterById(distributionCenterId);
178:         Item item = findItemById(itemId);
179: 
180:         StockLevel stockLevel = stockLevelRepository
181:                 .findByDistributionCenterAndItemId(distributionCenter, itemId)
182:                 .orElseGet(() -> {
183:                     StockLevel newStockLevel = new StockLevel(distributionCenter, itemId, newTotalQuantFor);
184:                     return stockLevelRepository.save(newStockLevel);
185:                 });
186: 
187:         stockLevel.setQuantity(newTotalQuantFor);
188:         stockLevelRepository.save(stockLevel);
189:     }
190: 
191:     @Override
192:     public int getAvailableStock(UUID distributionCenterId, UUID itemId) {
193: // Überprüfen, ob Verteilzentrum existiert
194:         DistributionCenter distributionCenter = findDistributionCenterById(distributionCenterId);
195:         // Überprüfen, ob das Item existiert
196:         Item item = findItemById(itemId);
197: 
198:         // Direkt im Repository suchen oder mit 0 fallbacken
199:         StockLevel stockLevel = stockLevelRepository.findByDistributionCenterAndItemId(distributionCenter, itemId)
200:                 .orElse(null);
201: 
202:         // Rückgabe der Menge oder 0, falls nicht vorhanden
203:         if (stockLevel == null) {
204:             System.out.println("Kein Lagerbestand für dieses DistributionCenter und Item gefunden.");
205:             return 0;  // Oder ein indikativer Fehlerwert, falls Storage bei Nichtverfügbarkeit eine 0 als Bestand verwendet
206:         }
207: 
208:         return stockLevel.getQuantity();
209:     }
210: 
211:     public Iterable<DistributionCenter> findAll() {
212:         return distributionCenterRepository.findAll();
213:     }
214: 
215: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\application\StockService.java ---
1: package thkoeln.archilab.ecommerce.solution.distributioncenter.application;
2: 
3: import lombok.Getter;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.stereotype.Service;
6: import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.DistributionCenter;
7: import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.DistributionCenterRepository;
8: import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.StockLevel;
9: import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.StockLevelRepository;
10: import thkoeln.archilab.ecommerce.solution.item.application.StockServiceInterface;
11: 
12: import java.util.Optional;
13: import java.util.UUID;
14: 
15: @Service
16: public class StockService implements StockServiceInterface {
17: 
18:     @Getter
19:     private final StockLevelRepository stockLevelRepository;
20: 
21: 
22:     @Autowired
23:     public StockService(StockLevelRepository stockLevelRepository) {
24:         this.stockLevelRepository = stockLevelRepository;
25:     }
26: 
27:     @Override
28:     public boolean isItemInStock(UUID itemId) {
29:         return stockLevelRepository.existsByItemId(itemId);
30:     }
31: 
32:     @Override
33:     public void deleteAllStock() {
34:         stockLevelRepository.deleteAll();
35:     }
36: 
37:     @Override
38:     public boolean isItemReferenced(UUID itemId) {
39:         return stockLevelRepository.existsByItemId(itemId);
40:     }
41: 
42:     public Optional<StockLevel> findByDistributionCenterAndItemId(DistributionCenter center, UUID id) {
43:         return stockLevelRepository.findByDistributionCenterAndItemId(center, id);
44:     }
45: 
46: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\DistributionCenter.java ---
1: package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;
2: 
3: import jakarta.persistence.Embedded;
4: import jakarta.persistence.EmbeddedId;
5: import jakarta.persistence.Entity;
6: 
7: import lombok.Getter;
8: import lombok.NoArgsConstructor;
9: import lombok.Setter;
10: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
11: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
12: 
13: import java.util.*;
14: 
15: 
16: @Entity
17: @Getter
18: @Setter
19: @NoArgsConstructor
20: public class DistributionCenter {
21: 
22:     @EmbeddedId
23:     private DistributionCenterId id;
24: 
25:     private String name;
26: 
27:     @Embedded
28:     private PhysicalAddress physicalAddress;
29: 
30:     private String zipCodeRange;
31: 
32:     // Diese Map ist nicht persistiert in der DB, sondern dient der Laufzeitlogik:
33:     private transient Map<ItemId, Integer> stock = new HashMap<>();
34: 
35:     public DistributionCenter(String name, PhysicalAddress physicalAddress, String zipCodeRange) {
36:         this.id = new DistributionCenterId(UUID.randomUUID());
37:         this.name = name;
38:         this.physicalAddress = physicalAddress;
39:         this.zipCodeRange = zipCodeRange;
40:     }
41: 
42:     public Set<ItemId> fulfillableShoppingBasketPositions(Map<ItemId, Integer> itemQuantityMap) {
43:         Set<ItemId> fulfillableItems = new HashSet<>();
44:         for (Map.Entry<ItemId, Integer> entry : itemQuantityMap.entrySet()) {
45:             ItemId itemId = entry.getKey();
46:             int requiredQuantity = entry.getValue();
47: 
48:             Integer availableQuantity = stock.get(itemId);
49:             if (availableQuantity != null && availableQuantity >= requiredQuantity) {
50:                 fulfillableItems.add(itemId);
51:             }
52:             System.out.println("DC " + this.id + " has " + availableQuantity + " of item " + itemId + " (needed: " + requiredQuantity + ")");
53:         }
54:         return fulfillableItems;
55:     }
56: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\DistributionCenterComparator.java ---
1: package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;
2: 
3: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
4: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
5: 
6: import java.util.Comparator;
7: import java.util.Map;
8: import java.util.Set;
9: 
10: public class DistributionCenterComparator implements Comparator<DistributionCenter> {
11:     private Map<ItemId, Integer> shoppingBasketMap;
12:     private String clientZipCode;
13:     private StockLevelRepository stockLevelRepository;
14: 
15:     public DistributionCenterComparator(Map<ItemId, Integer> shoppingBasketMap, String clientZipCode, StockLevelRepository stockLevelRepository) {
16:         this.shoppingBasketMap = shoppingBasketMap;
17:         this.clientZipCode = clientZipCode;
18:         this.stockLevelRepository = stockLevelRepository;
19:     }
20: 
21:     @Override
22:     public int compare(DistributionCenter dc1, DistributionCenter dc2) {
23:         boolean canDc1Fulfill = canFulfillAllItems(dc1);
24:         boolean canDc2Fulfill = canFulfillAllItems(dc2);
25: 
26:         System.out.println("Comparing Distribution Centers:");
27:         System.out.println("dc1 ID: " + dc1.getId().getId() + ", can fulfill: " + canDc1Fulfill);
28:         System.out.println("dc2 ID: " + dc2.getId().getId() + ", can fulfill: " + canDc2Fulfill);
29: 
30:         if (canDc1Fulfill && !canDc2Fulfill) {
31:             System.out.println("Choosing dc1 because it can fulfill all items");
32:             return -1;
33:         }
34:         if (!canDc1Fulfill && canDc2Fulfill) {
35:             System.out.println("Choosing dc2 because it can fulfill all items");
36:             return 1;
37:         }
38: 
39:         int distance1 = dc1.getPhysicalAddress().getZipCode().difference(ZipCode.of(clientZipCode));
40:         int distance2 = dc2.getPhysicalAddress().getZipCode().difference(ZipCode.of(clientZipCode));
41:         System.out.println("Distance to client - dc1: " + distance1 + ", dc2: " + distance2);
42: 
43:         return Integer.compare(distance1, distance2);
44:     }
45: 
46:     private boolean canFulfillAllItems(DistributionCenter dc) {
47:         for (Map.Entry<ItemId, Integer> entry : shoppingBasketMap.entrySet()) {
48:             ItemId itemId = entry.getKey();
49:             int requiredQuantity = entry.getValue();
50:             int availableQuantity = stockLevelRepository.findByDistributionCenterAndItemId(dc, itemId.getId())
51:                     .map(StockLevel::getQuantity)
52:                     .orElse(0);
53: 
54:             if (availableQuantity < requiredQuantity) {
55:                 return false;
56:             }
57:         }
58:         return true;
59:     }
60: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\DistributionCenterId.java ---
1: package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.AccessLevel;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.GenericId;
7: 
8: import java.util.UUID;
9: 
10: @Embeddable
11: @NoArgsConstructor(access = AccessLevel.PROTECTED)
12: public class DistributionCenterId extends GenericId {
13:     public DistributionCenterId(UUID id) {
14:         super(id);
15:     }
16: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\DistributionCenterIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class DistributionCenterIdConverter extends GenericIdConverter<DistributionCenterId> {
8:     public DistributionCenterIdConverter() {
9:         super(DistributionCenterId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\DistributionCenterRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: 
5: import java.util.Optional;
6: import java.util.UUID;
7: 
8: public interface DistributionCenterRepository extends CrudRepository<DistributionCenter, DistributionCenterId> {
9: }
10: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\StockLevel.java ---
1: package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.solution.item.domain.Item;
8: 
9: import java.util.UUID;
10: 
11: @Entity
12: @Getter
13: @Setter
14: @NoArgsConstructor
15: public class StockLevel {
16: 
17:     @EmbeddedId
18:     private StockLevelId id;
19: 
20:     private int quantity;
21: 
22:     private UUID itemId;  // Hier speichern wir die UUID statt der direkten Item-Referenz
23: 
24:     @ManyToOne
25:     private DistributionCenter distributionCenter;
26: 
27:     public StockLevel(DistributionCenter distributionCenter, UUID itemId, int quantity) {
28:         this.id = new StockLevelId(UUID.randomUUID());
29:         this.distributionCenter = distributionCenter;
30:         this.itemId = itemId;
31:         this.quantity = quantity;
32:     }
33: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\StockLevelId.java ---
1: package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.AccessLevel;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.GenericId;
7: 
8: import java.util.UUID;
9: 
10: @Embeddable
11: @NoArgsConstructor(access = AccessLevel.PROTECTED)
12: public class StockLevelId extends GenericId {
13:     public StockLevelId(UUID id) {
14:         super(id);
15:     }
16: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\StockLevelIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class StockLevelIdConverter extends GenericIdConverter<StockLevelId> {
8:     public StockLevelIdConverter() {
9:         super(StockLevelId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\StockLevelRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: 
5: import java.util.Optional;
6: import java.util.UUID;
7: 
8: public interface StockLevelRepository extends CrudRepository<StockLevel, StockLevelId> {
9: 
10:     Optional<StockLevel> findByDistributionCenterAndItemId(DistributionCenter distributionCenter, UUID itemId);
11: 
12:     boolean existsByItemId(UUID itemId);
13: 
14: }
15: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\AddItemDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.item.application;
2: 
3: import java.util.UUID;
4: 
5: public class AddItemDTO {
6:     private UUID itemId;
7:     private int quantity;
8: 
9:     public AddItemDTO() {}
10: 
11:     public AddItemDTO(UUID itemId, int quantity) {
12:         this.itemId = itemId;
13:         this.quantity = quantity;
14:     }
15: 
16:     public UUID getItemId() {
17:         return itemId;
18:     }
19: 
20:     public void setItemId(UUID itemId) {
21:         this.itemId = itemId;
22:     }
23: 
24:     public int getQuantity() {
25:         return quantity;
26:     }
27: 
28:     public void setQuantity(int quantity) {
29:         this.quantity = quantity;
30:     }
31: }
32: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ItemCatalogService.java ---
1: package thkoeln.archilab.ecommerce.solution.item.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Money;
7: import thkoeln.archilab.ecommerce.solution.item.domain.Item;
8: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
9: import thkoeln.archilab.ecommerce.solution.item.domain.ItemRepository;
10: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
11: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
12: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
13: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
15: 
16: import java.util.UUID;
17: 
18: @Service
19: public class ItemCatalogService implements ItemCatalogUseCases {
20: 
21:     @Autowired
22:     private ItemRepository itemRepository;
23: 
24:     @Autowired
25:     private OrderItemServiceInterface orderService;
26: 
27:     @Autowired
28:     private ItemSBServiceInterface itemSBService; // Verwendet das Interface
29: 
30:     @Autowired
31:     private StockServiceInterface stockService;
32: 
33:     @Override
34:     public UUID addItemToCatalog(String name, String descriptOf, Float size, MoneyType buyingPrice, MoneyType salesPrice) {
35: 
36:         if (name == null || name.isEmpty() || descriptOf == null || descriptOf.isEmpty()) {
37:             throw new ShopException("Name and description cannot be null or empty");
38:         }
39:         if (size != null && size <= 0) {
40:             throw new ShopException("Size must be greater than 0 if provided");
41:         }
42:         if (buyingPrice == null || buyingPrice.getAmount() <= 0) {
43:             throw new ShopException("Buying price must be greater than 0");
44:         }
45:         if (salesPrice == null || salesPrice.getAmount() <= 0) {
46:             throw new ShopException("Sales price must be greater than 0");
47:         }
48:         if (salesPrice.getAmount() < buyingPrice.getAmount()) {
49:             throw new ShopException("Sales price cannot be lower than buying price");
50:         }
51: 
52:         Item item = new Item();
53:         item.setId(new ItemId(UUID.randomUUID()));
54:         item.setName(name);
55:         item.setDescription(descriptOf);
56:         item.setSize(size);
57:         item.setBuyingPrice((Money) buyingPrice);
58:         item.setSalesPrice((Money) salesPrice);
59: 
60:         itemRepository.save(item);
61: 
62:         return item.getId().getId();
63:     }
64: 
65:     @Override
66:     public void removeItemFromCatalog(UUID itemIdUuid) {
67:         if (itemIdUuid == null) {
68:             throw new ShopException("The item ID is null");
69:         }
70: 
71:         ItemId itemId = new ItemId(itemIdUuid);
72: 
73:         // Überprüfungen
74:         if (!itemRepository.existsById(itemId)) { throw new ShopException("The item id does not exist"); }
75:         if (stockService.isItemInStock(itemIdUuid)) { throw new ShopException("The item is still in stock"); }
76:         if (itemSBService.isItemInAnyShoppingBasket(itemIdUuid)) { throw new ShopException("The item is still present in a shopping basket"); }
77:         if (orderService.isItemInAnyOrder(itemIdUuid)) { throw new ShopException("The item is still referenced by a completed order"); }
78: 
79:         // Löschen, falls alle Tests bestanden
80:         itemRepository.deleteById(itemId);
81:     }
82: 
83:     @Override
84:     public MoneyType getSalesPrice(UUID itemId) {
85:         if (itemId == null) {
86:             throw new ShopException("The item ID is null");
87:         }
88: 
89:         // Konvertiere UUID in ItemId
90:         ItemId itemId1d = new ItemId(itemId);
91: 
92:         // Suche das Item mit der konvertierten ItemId
93:         Item item = itemRepository.findById(itemId1d)
94:                 .orElseThrow(() -> new ShopException("The item id does not exist"));
95:         return item.getSalesPrice();
96:     }
97: 
98:     @Override
99:     public void deleteItemCatalog() {
100:         itemSBService.deleteAllShoppingBaskets();
101:         stockService.deleteAllStock();
102:         orderService.deleteAllOrders();
103:         itemRepository.deleteAll();
104:     }
105: }
106: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ItemSBServiceInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.item.application;
2: 
3: import java.util.UUID;
4: 
5: public interface ItemSBServiceInterface {
6:     boolean isItemInAnyShoppingBasket(UUID itemId);
7:     void deleteAllShoppingBaskets();
8: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\OrderItemServiceInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.item.application;
2: 
3: import java.util.UUID;
4: 
5: public interface OrderItemServiceInterface {
6:     boolean isItemInAnyOrder(UUID itemId);
7: 
8:     void deleteAllOrders();
9: }
10: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\StockServiceInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.item.application;
2: 
3: import java.util.UUID;
4: 
5: public interface StockServiceInterface {
6:     boolean isItemInStock(UUID itemId);
7:     void deleteAllStock();
8:     boolean isItemReferenced(UUID itemId);
9: }
10: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\Item.java ---
1: package thkoeln.archilab.ecommerce.solution.item.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.AllArgsConstructor;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import lombok.Setter;
8: import thkoeln.archilab.ecommerce.domainprimitives.Money;
9: 
10: @Entity
11: @Getter
12: @Setter
13: @NoArgsConstructor
14: @AllArgsConstructor
15: public class Item {
16: 
17:     @EmbeddedId
18:     private ItemId id;
19: 
20:     private String name;
21:     private String description;
22:     private Float size;
23: 
24:     @Embedded
25:     @AttributeOverrides({
26:             @AttributeOverride(name = "amount", column = @Column(name = "buyingpriceamount")),
27:             @AttributeOverride(name = "currencyUnit", column = @Column(name = "buyingpricecurrency"))
28:     })
29:     private Money buyingPrice;
30: 
31:     @Embedded
32:     @AttributeOverrides({
33:             @AttributeOverride(name = "amount", column = @Column(name = "salespriceamount")),
34:             @AttributeOverride(name = "currencyUnit", column = @Column(name = "salespricecurrency"))
35:     })
36:     private Money salesPrice;
37: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemId.java ---
1: package thkoeln.archilab.ecommerce.solution.item.domain;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.AccessLevel;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.GenericId;
7: 
8: import java.util.UUID;
9: 
10: @Embeddable
11: @NoArgsConstructor(access = AccessLevel.PROTECTED)
12: public class ItemId extends GenericId {
13:     public ItemId(UUID id) {
14:         super(id);
15:     }
16: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.item.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ItemIdConverter extends GenericIdConverter<ItemId> {
8:     public ItemIdConverter() {
9:         super(ItemId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.item.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.data.repository.CrudRepository;
5: 
6: import java.util.UUID;
7: 
8: public interface ItemRepository extends CrudRepository<Item, ItemId> {}
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderItemService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.item.application.OrderItemServiceInterface;
6: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
7: import thkoeln.archilab.ecommerce.solution.order.domain.OrderpositionRepository;
8: 
9: import java.util.UUID;
10: 
11: @Service
12: public class OrderItemService implements OrderItemServiceInterface {
13: 
14:     @Autowired
15:     private OrderpositionRepository orderPositionRepository;
16: 
17:     @Override
18:     public boolean isItemInAnyOrder(UUID itemId) {
19:         Iterable<OrderPosition> orderPositions = orderPositionRepository.findAll();
20:         for (OrderPosition orderPosition : orderPositions) {
21:             if (orderPosition.getItemId().equals(itemId)) {
22:                 return true;
23:             }
24:         }
25:         return false;
26:     }
27: 
28:     @Override
29:     public void deleteAllOrders() {
30:         orderPositionRepository.deleteAll();
31:     }
32: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
7: import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
8: import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.DistributionCenter;
9: import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.DistributionCenterRepository;
10: import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.StockLevel;
11: import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.StockLevelRepository;
12: import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
13: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
14: import thkoeln.archilab.ecommerce.usecases.OrderUseCases;
15: import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
16: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
17: import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
18: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
19: 
20: import java.util.*;
21: import java.util.stream.Collectors;
22: import java.util.stream.StreamSupport;
23: 
24: @Service
25: public class OrderService implements OrderUseCases {
26: 
27:     @Autowired
28:     private OrderRepository orderRepository;
29: 
30:     @Autowired
31:     private ClientRepository clientRepository;
32: 
33:     @Autowired
34:     private DistributionCenterRepository distributionCenterRepository;
35: 
36:     @Autowired
37:     private StockLevelRepository stockLevelRepository;
38: 
39:     @Override
40:     public Map<UUID, Integer> getOrderHistory(EmailType clientEmail) {
41:         if (clientEmail == null) {
42:             throw new ShopException("Client email cannot be null");
43:         }
44: 
45:         ClientId clientId = ClientId.fromEmail(String.valueOf(clientEmail));
46: 
47:         Client client = clientRepository.findById(clientId)
48:                 .orElseThrow(() -> new ShopException("Client not found"));
49: 
50:         // Verwende die Methode 'findByClientId'
51:         List<Order> orders = orderRepository.findByClientId(client.getId());
52:         Map<UUID, Integer> orderHistory = new HashMap<>();
53: 
54:         // Initialisierung der OrderPositions
55:         for (Order order : orders) {
56:             order.getOrderPositions().size();
57:             for (OrderPosition op : order.getOrderPositions()) {
58:                 orderHistory.merge(op.getItemId(), op.getQuantity(), Integer::sum);
59:             }
60:         }
61: 
62:         return orderHistory;
63:     }
64: 
65:     @Override
66:     public Integer getOrderQuantForItem(UUID orderId, UUID itemId) {
67:         if (orderId == null) {
68:             throw new ShopException("Order ID cannot be null");
69:         }
70:         if (itemId == null) {
71:             throw new ShopException("Item ID cannot be null");
72:         }
73: 
74:         Order order = orderRepository.findById(new OrderId(orderId))
75:                 .orElseThrow(() -> new ShopException("Order does not exist"));
76: 
77:         return order.getOrderPositions().stream()
78:                 .filter(position -> position.getItemId().equals(itemId))
79:                 .map(OrderPosition::getQuantity)
80:                 .findFirst()
81:                 .orElse(0); // Wenn das Item nicht gefunden wird, 0 zurückgeben
82:     }
83: 
84:     @Override
85:     public UUID getDistributionCenterIdForOrder(UUID orderId) {
86:         Order order = orderRepository.findById(new OrderId(orderId))
87:                 .orElseThrow(() -> new ShopException("Order does not exist"));
88: 
89:         System.out.println("Retrieving Distribution Center ID for Order ID: " + orderId);
90: 
91:         if (order.getDistributionCenterId() != null) {
92:             System.out.println("Order ID " + orderId + " directly assigned to Distribution Center ID " + order.getDistributionCenterId());
93:             return order.getDistributionCenterId();
94:         }
95: 
96:         List<DistributionCenter> distributionCenters = StreamSupport
97:                 .stream(distributionCenterRepository.findAll().spliterator(), false)
98:                 .collect(Collectors.toList());
99: 
100:         for (DistributionCenter center : distributionCenters) {
101:             boolean allItemsAvailable = true;
102: 
103:             for (OrderPosition position : order.getOrderPositions()) {
104:                 StockLevel stockLevel = stockLevelRepository.findByDistributionCenterAndItemId(center, position.getItemId()).orElse(null);
105: 
106:                 if (stockLevel == null || stockLevel.getQuantity() < position.getQuantity()) {
107:                     allItemsAvailable = false;
108:                     break;
109:                 }
110:             }
111: 
112:             if (allItemsAvailable) {
113:                 System.out.println("Order ID " + orderId + " is fully assignable to Distribution Center ID " + center.getId().getId());
114:                 order.setDistributionCenterId(center.getId().getId());
115:                 orderRepository.save(order);
116:                 return center.getId().getId();
117:             }
118:         }
119: 
120:         throw new ShopException("No suitable distribution center can fulfill the entire order");
121:     }
122: 
123: 
124:     @Override
125:     public void deleteAllOrders() {
126:         orderRepository.deleteAll();
127:     }
128: }
129: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
8: 
9: import java.util.ArrayList;
10: import java.util.List;
11: import java.util.UUID;
12: 
13: @Entity
14: @Getter
15: @Setter
16: @NoArgsConstructor
17: @Table(name = "client_orders")
18: public class Order extends Orderable {
19: 
20:     @EmbeddedId
21:     @AttributeOverride(name = "id", column = @Column(name = "order_id"))
22:     private OrderId id;
23: 
24:     @Column(name = "client_id", nullable = false)
25:     private ClientId clientId;
26: 
27:     @Column(name = "distribution_center_id", nullable = false)
28:     private UUID distributionCenterId;  // Neues Feld hinzugefügt
29: 
30:     @OneToMany(mappedBy = "id.orderId", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
31:     private List<OrderPosition> orderPositions = new ArrayList<>();
32: 
33:     @Override
34:     public UUID getOrderId() {
35:         return id.getId();
36:     }
37: 
38:     @Override
39:     public ClientId getClientId() {
40:         return clientId;
41:     }
42: 
43:     @Override
44:     public List<OrderPosition> getOrderPositions() {
45:         return orderPositions;
46:     }
47: 
48:     public void setDistributionCenterId(UUID distributionCenterId) {
49:         this.distributionCenterId = distributionCenterId;
50:     }
51: 
52:     public UUID getDistributionCenterId() {
53:         return distributionCenterId;
54:     }
55: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Orderable.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.Id;
4: import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
5: 
6: import java.util.List;
7: import java.util.UUID;
8: 
9: public abstract class Orderable {
10:     @Id
11:     private UUID id;
12: 
13: 
14:     public abstract UUID getOrderId();
15: 
16:     public abstract ClientId getClientId();
17: 
18:     public abstract List<OrderPosition> getOrderPositions();
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import java.util.List;
4: import java.util.UUID;
5: 
6: public class OrderDTO {
7:     private UUID id;
8:     private String clientName;
9:     private UUID distributionCenterId;
10:     private List<OrderPositionDTO> positions;
11: 
12:     public OrderDTO(UUID id, String clientName, UUID distributionCenterId, List<OrderPositionDTO> positions) {
13:         this.id = id;
14:         this.clientName = clientName;
15:         this.distributionCenterId = distributionCenterId;
16:         this.positions = positions;
17:     }
18: 
19:     // Getter und Setter
20:     public UUID getId() {
21:         return id;
22:     }
23: 
24:     public void setId(UUID id) {
25:         this.id = id;
26:     }
27: 
28:     public String getClientName() {
29:         return clientName;
30:     }
31: 
32:     public void setClientName(String clientName) {
33:         this.clientName = clientName;
34:     }
35: 
36:     public UUID getDistributionCenterId() {
37:         return distributionCenterId;
38:     }
39: 
40:     public void setDistributionCenterId(UUID distributionCenterId) {
41:         this.distributionCenterId = distributionCenterId;
42:     }
43: 
44:     public List<OrderPositionDTO> getPositions() {
45:         return positions;
46:     }
47: 
48:     public void setPositions(List<OrderPositionDTO> positions) {
49:         this.positions = positions;
50:     }
51: }
52: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderId.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.AccessLevel;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.GenericId;
7: 
8: import java.util.UUID;
9: 
10: @Embeddable
11: @NoArgsConstructor(access = AccessLevel.PROTECTED)
12: public class OrderId extends GenericId {
13:     public OrderId(UUID id) {
14:         super(id);
15:     }
16: }
17: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class OrderIdConverter extends GenericIdConverter<OrderId> {
8:     public OrderIdConverter() {
9:         super(OrderId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPosition.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.UUID;
9: 
10: @Entity
11: @Getter
12: @Setter
13: @NoArgsConstructor
14: public class OrderPosition {
15: 
16:     @EmbeddedId
17:     private OrderPositionId id; // OrderPositionId enthält itemId
18: 
19:     private int quantity;
20: 
21:     // Getter und Setter für itemId über OrderPositionId
22:     public UUID getItemId() {
23:         return id != null ? id.getItemId() : null;
24:     }
25: 
26:     public void setItemId(UUID itemId) {
27:         if (id == null) {
28:             id = new OrderPositionId();
29:         }
30:         id.setItemId(itemId);
31:     }
32: 
33:     // Getter und Setter für andere Felder
34:     public int getQuantity() {
35:         return quantity;
36:     }
37: 
38:     public void setQuantity(int quantity) {
39:         this.quantity = quantity;
40:     }
41: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import java.util.UUID;
4: 
5: public class OrderPositionDTO {
6:     private UUID itemId;
7:     private int quantity;
8: 
9:     public OrderPositionDTO() {}
10: 
11:     public OrderPositionDTO(UUID itemId, int quantity) {
12:         this.itemId = itemId;
13:         this.quantity = quantity;
14:     }
15: 
16:     // Getter und Setter
17:     public UUID getItemId() {
18:         return itemId;
19:     }
20: 
21:     public void setItemId(UUID itemId) {
22:         this.itemId = itemId;
23:     }
24: 
25:     public int getQuantity() {
26:         return quantity;
27:     }
28: 
29:     public void setQuantity(int quantity) {
30:         this.quantity = quantity;
31:     }
32: }
33: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionId.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.Column;
4: import jakarta.persistence.Embeddable;
5: import lombok.AccessLevel;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.GenericId;
8: 
9: import java.util.UUID;
10: 
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: public class OrderPositionId extends GenericId {
15:     @Column(name = "item_id")
16:     private UUID itemId;
17: 
18:     @Column(name = "order_id")
19:     private UUID orderId;
20: 
21:     public OrderPositionId(UUID orderId, UUID itemId) {
22:         super(UUID.randomUUID()); // Aufruf des Konstruktors der Superklasse
23:         this.orderId = orderId;
24:         this.itemId = itemId;
25:     }
26: 
27:     // Getter und Setter für itemId und orderId
28:     public UUID getItemId() {
29:         return itemId;
30:     }
31: 
32:     public void setItemId(UUID itemId) {
33:         this.itemId = itemId;
34:     }
35: 
36:     public UUID getOrderId() {
37:         return orderId;
38:     }
39: 
40:     public void setOrderId(UUID orderId) {
41:         this.orderId = orderId;
42:     }
43: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: import java.util.UUID;
7: 
8: 
9: @Converter(autoApply = true)
10: public class OrderPositionIdConverter extends GenericIdConverter<OrderPositionId> {
11: 
12:     public OrderPositionIdConverter() {
13:         super(OrderPositionIdConverter::createOrderPositionId); // Verwende die statische Methode zur Erzeugung von OrderPositionId
14:     }
15: 
16:     // Statische Methode, die den Konstruktor von OrderPositionId mit zwei UUIDs aufruft
17:     private static OrderPositionId createOrderPositionId(UUID combinedId) {
18:         // Zerlege den kombinierten UUID in zwei Teile
19:         UUID orderId = UUID.fromString(combinedId.toString().substring(0, 36));  // Nehme die ersten 36 Zeichen für orderId
20:         UUID itemId = UUID.fromString(combinedId.toString().substring(36));      // Nehme die restlichen 36 Zeichen für itemId
21:         return new OrderPositionId(orderId, itemId);
22:     }
23: 
24:     @Override
25:     public UUID convertToDatabaseColumn(OrderPositionId attribute) {
26:         if (attribute == null) {
27:             return null;
28:         }
29:         // Kombiniere die beiden UUIDs in einen einzigen UUID-Wert (hier: String + dann zurück zu UUID)
30:         String combined = attribute.getOrderId().toString() + attribute.getItemId().toString();
31:         return UUID.fromString(combined);  // Rückgabe als kombinierte UUID
32:     }
33: 
34:     @Override
35:     public OrderPositionId convertToEntityAttribute(UUID dbData) {
36:         if (dbData == null) {
37:             return null;
38:         }
39:         return createOrderPositionId(dbData);  // Rufe die Methode zur Umwandlung in OrderPositionId auf
40:     }
41: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderpositionRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: 
5: import java.util.UUID;
6: 
7: public interface OrderpositionRepository extends CrudRepository<OrderPosition, OrderPositionId> {
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
5: import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
6: 
7: import java.util.List;
8: import java.util.UUID;
9: 
10: public interface OrderRepository extends CrudRepository<Order, OrderId> {
11:     // Suche nach Orders anhand der ClientId
12:     List<Order> findByClientId(ClientId clientId);
13: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ClientSBService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.client.application.ClientSBServiceInterface;
6: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
7: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
8: 
9: import java.util.UUID;
10: 
11: @Service
12: public class ClientSBService implements ClientSBServiceInterface {
13:     @Autowired
14:     private ShoppingBasketRepository shoppingBasketRepository;
15: 
16:     public UUID createShoppingBasketForClient() {
17:         ShoppingBasket newBasket = new ShoppingBasket();
18:         shoppingBasketRepository.save(newBasket);
19:         return newBasket.getId().getId();
20:     }
21: }
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ItemSBService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.item.application.ItemSBServiceInterface;
6: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
7: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
8: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
9: 
10: import java.util.UUID;
11: 
12: @Service
13: public class ItemSBService implements ItemSBServiceInterface {
14: 
15:     private final ShoppingBasketRepository shoppingBasketRepository;
16: 
17:     @Autowired
18:     public ItemSBService(ShoppingBasketRepository shoppingBasketRepository) {
19:         this.shoppingBasketRepository = shoppingBasketRepository;
20:     }
21: 
22:     @Override
23:     public boolean isItemInAnyShoppingBasket(UUID itemId) {
24:         Iterable<ShoppingBasket> shoppingBaskets = shoppingBasketRepository.findAll();
25:         for (ShoppingBasket shoppingBasket : shoppingBaskets) {
26:             for (ShoppingBasketPosition position : shoppingBasket.getShoppingBasketPositions()) {
27:                 if (position.getItemId().equals(itemId)) {
28:                     return true;
29:                 }
30:             }
31:         }
32:         return false;
33:     }
34: 
35:     @Override
36:     public void deleteAllShoppingBaskets() {
37:         shoppingBasketRepository.deleteAll();
38:     }
39: }
40: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.http.HttpStatus;
5: import org.springframework.http.MediaType;
6: import org.springframework.http.ResponseEntity;
7: import org.springframework.web.bind.annotation.*;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.domainprimitives.Money;
10: import thkoeln.archilab.ecommerce.solution.client.application.ClientRegistrationService;
11: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
12: import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
13: import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
14: import thkoeln.archilab.ecommerce.solution.distributioncenter.application.DistributionCenterService;
15: import thkoeln.archilab.ecommerce.solution.distributioncenter.application.StockService;
16: import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.*;
17: import thkoeln.archilab.ecommerce.solution.item.application.AddItemDTO;
18: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
19: import thkoeln.archilab.ecommerce.solution.order.domain.OrderDTO;
20: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.*;
21: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
22: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
23: 
24: import java.util.*;
25: 
26: @RestController
27: @RequestMapping("/shoppingBaskets")
28: public class ShoppingBasketController {
29: 
30:     @Autowired
31:     private ShoppingBasketService shoppingBasketService;  // Verwenden Sie ShoppingBasketService direkt
32: 
33:     @Autowired
34:     private DistributionCenterService distributionCenterService;
35: 
36:     @Autowired
37:     private StockService stockService;
38: 
39:     @Autowired
40:     private ClientRegistrationService clientRegistrationService;
41: 
42: 
43:     @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
44:     public ResponseEntity<?> getShoppingBasket(@RequestParam(name = "clientId", required = false) String clientId) {
45:         if (clientId == null) {
46:             return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).body("Client ID is required");
47:         }
48: 
49:         UUID clientUuid;
50:         try {
51:             clientUuid = UUID.fromString(clientId);
52:         } catch (IllegalArgumentException ex) {
53:             return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Invalid client ID format");
54:         }
55: 
56:         Optional<Client> optionalClient = clientRegistrationService.findById(new ClientId(clientUuid));
57:         if (optionalClient.isEmpty()) {
58:             return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Client not found");
59:         }
60: 
61:         Client client = optionalClient.get();
62:         ShoppingBasket shoppingBasket = shoppingBasketService.getShoppingBasketByEmail(client.getEmail().toString());
63:         if (shoppingBasket == null) {
64:             return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Shopping basket not found");
65:         }
66: 
67:         Map<UUID, Integer> basketMap = shoppingBasketService.getShoppingBasketAsMap(client.getEmail());
68:         ShoppingBasketResponseDTO shoppingBasketDTO = mapToDTO(shoppingBasket, basketMap, shoppingBasketService, client.getEmail());
69: 
70:         return ResponseEntity.ok(shoppingBasketDTO);
71:     }
72: 
73:     @PostMapping("/{shoppingBasketId}/positions")
74:     public ResponseEntity<?> addItemToShoppingBasket(@PathVariable("shoppingBasketId") UUID shoppingBasketId,
75:                                                      @RequestBody AddItemDTO addItemDTO) {
76:         if (addItemDTO.getQuantity() <= 0) {
77:             return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body("Quantity must be greater than 0");
78:         }
79: 
80:         try {
81:             Client client = shoppingBasketService.getClientByShoppingBasketId(shoppingBasketId);
82: 
83:             shoppingBasketService.addItemToShoppingBasket(client.getEmail(), addItemDTO.getItemId(), addItemDTO.getQuantity());
84:             return ResponseEntity.status(HttpStatus.CREATED).build();
85:         } catch (ShopException e) {
86:             return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
87:         }
88:     }
89: 
90:     @DeleteMapping("/{shoppingBasketId}/positions/{itemId}")
91:     public ResponseEntity<?> deleteItemFromShoppingBasket(@PathVariable("shoppingBasketId") UUID shoppingBasketId,
92:                                                           @PathVariable("itemId") UUID itemId) {
93:         try {
94:             // Client über die ShoppingBasketId finden
95:             Client client = shoppingBasketService.getClientByShoppingBasketId(shoppingBasketId);
96: 
97:             // Ermitteln der aktuellen Menge des Artikels im Einkaufswagen
98:             Map<UUID, Integer> basketContents = shoppingBasketService.getShoppingBasketAsMap(client.getEmail());
99:             int currentQuantity = basketContents.getOrDefault(itemId, 0);
100: 
101:             if (currentQuantity > 0) {
102:                 // Entfernt nur die Menge, die tatsächlich vorhanden ist
103:                 shoppingBasketService.removeItemFromShoppingBasket(client.getEmail(), itemId, currentQuantity);
104:                 return ResponseEntity.ok().build();
105:             } else {
106:                 return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Item not found in basket");
107:             }
108:         } catch (ShopException e) {
109:             return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
110:         }
111:     }
112: 
113:     @PostMapping("/{shoppingBasketId}/checkout")
114:     public ResponseEntity<?> checkout(@PathVariable("shoppingBasketId") UUID shoppingBasketId) {
115:         Optional<ShoppingBasket> optionalBasket = shoppingBasketService.findById(new ShoppingBasketId(shoppingBasketId));
116:         if (optionalBasket.isEmpty()) {
117:             return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Shopping basket not found");
118:         }
119: 
120:         ShoppingBasket shoppingBasket = optionalBasket.get();
121: 
122:         // Prüfen, ob der Einkaufswagen leer ist oder bereits ausgecheckt wurde
123:         if (isShoppingBasketEmptyOrCheckedOut(shoppingBasket)) {
124:             return ResponseEntity.status(HttpStatus.CONFLICT).body("Shopping basket is already empty or checked out");
125:         }
126: 
127:         Client client = shoppingBasketService.getClientByShoppingBasketId(shoppingBasketId);
128:         if (client == null) {
129:             return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Client not found");
130:         }
131: 
132:         try {
133:             // Sammeln der Artikel und deren Mengen
134:             Map<ItemId, Integer> itemQuantities = gatherItemQuantities(shoppingBasket);
135: 
136:             // Verteilzentren auswählen
137:             Map<UUID, Map<ItemId, Integer>> ordersByDistributionCenter = selectDistributionCenters(itemQuantities, client);
138: 
139:             // Bestände entfernen und Einkaufswagen leeren
140:             processOrdersAndClearBasket(ordersByDistributionCenter, shoppingBasket);
141: 
142:             // Bestellungen erstellen
143:             List<OrderDTO> orders = createOrders(ordersByDistributionCenter, client);
144: 
145:             return ResponseEntity.status(HttpStatus.CREATED).body(orders);
146:         } catch (ShopException e) {
147:             return ResponseEntity.status(HttpStatus.CONFLICT).body(e.getMessage());
148:         }
149:     }
150: 
151:     private boolean isShoppingBasketEmptyOrCheckedOut(ShoppingBasket shoppingBasket) {
152:         return shoppingBasket.getShoppingBasketPositions().isEmpty();
153:     }
154: 
155:     private Map<ItemId, Integer> gatherItemQuantities(ShoppingBasket shoppingBasket) {
156:         Map<ItemId, Integer> itemQuantities = new HashMap<>();
157:         for (ShoppingBasketPosition position : shoppingBasket.getShoppingBasketPositions()) {
158:             itemQuantities.put(new ItemId(position.getItemId()), position.getQuantity());
159:         }
160:         return itemQuantities;
161:     }
162: 
163:     private Map<UUID, Map<ItemId, Integer>> selectDistributionCenters(Map<ItemId, Integer> itemQuantities, Client client) throws ShopException {
164:         Iterable<DistributionCenter> dcIterable = distributionCenterService.findAll();
165:         Map<UUID, Map<ItemId, Integer>> ordersByDistributionCenter = new HashMap<>();
166: 
167:         for (Map.Entry<ItemId, Integer> entry : itemQuantities.entrySet()) {
168:             ItemId itemId = entry.getKey();
169:             int quantityNeeded = entry.getValue();
170: 
171:             // Übergabe von itemQuantities an die findBestDistributionCenter-Methode
172:             DistributionCenter selectedCenter = findBestDistributionCenter(itemQuantities, itemId, quantityNeeded, dcIterable, client);
173: 
174:             if (selectedCenter == null) {
175:                 throw new ShopException("No suitable distribution center found for item: " + itemId);
176:             }
177: 
178:             ordersByDistributionCenter.computeIfAbsent(selectedCenter.getId().getId(), k -> new HashMap<>())
179:                     .put(itemId, quantityNeeded);
180:         }
181: 
182:         return ordersByDistributionCenter;
183:     }
184: 
185:     private DistributionCenter findBestDistributionCenter(Map<ItemId, Integer> itemQuantities, ItemId itemId, int quantityNeeded, Iterable<DistributionCenter> dcIterable, Client client) {
186:         DistributionCenter selectedCenter = null;
187: 
188:         for (DistributionCenter center : dcIterable) {
189:             StockLevel stockLevel = stockService.findByDistributionCenterAndItemId(center, itemId.getId()).orElse(null);
190: 
191:             if (stockLevel != null && stockLevel.getQuantity() >= quantityNeeded) {
192:                 if (selectedCenter == null ||
193:                         new DistributionCenterComparator(itemQuantities, client.getPhysicalAddress().getZipCode().toString(), stockService.getStockLevelRepository())
194:                                 .compare(center, selectedCenter) < 0) {
195:                     selectedCenter = center;
196:                 }
197:             }
198:         }
199:         return selectedCenter;
200:     }
201: 
202:     private void processOrdersAndClearBasket(Map<UUID, Map<ItemId, Integer>> ordersByDistributionCenter, ShoppingBasket shoppingBasket) throws ShopException {
203:         // Artikel aus dem Lager entfernen
204:         for (Map.Entry<UUID, Map<ItemId, Integer>> order : ordersByDistributionCenter.entrySet()) {
205:             UUID dcId = order.getKey();
206:             for (Map.Entry<ItemId, Integer> itemEntry : order.getValue().entrySet()) {
207:                 distributionCenterService.removeFromStock(dcId, itemEntry.getKey().getId(), itemEntry.getValue());
208:             }
209:         }
210: 
211:         // Leeren des Einkaufswagens
212:         shoppingBasket.getShoppingBasketPositions().clear();
213:         shoppingBasketService.save(shoppingBasket);
214:     }
215: 
216:     private List<OrderDTO> createOrders(Map<UUID, Map<ItemId, Integer>> ordersByDistributionCenter, Client client) {
217:         List<OrderDTO> orders = new ArrayList<>();
218:         for (UUID dcId : ordersByDistributionCenter.keySet()) {
219:             orders.add(new OrderDTO(UUID.randomUUID(), client.getName(), dcId, Collections.emptyList()));
220:         }
221:         return orders;
222:     }
223: 
224:     private ShoppingBasketResponseDTO mapToDTO(ShoppingBasket shoppingBasket, Map<UUID, Integer> basketMap,
225:                                                ShoppingBasketUseCases shoppingBasketService, EmailType clientEmail) {
226:         List<ShoppingBasketItemResponseDTO> positions = new ArrayList<>();
227:         basketMap.forEach((itemId, quantity) -> positions.add(new ShoppingBasketItemResponseDTO(itemId, quantity)));
228: 
229:         String totalSalesPrice = ((Money) shoppingBasketService.getShoppingBasketAsMoneyValue(clientEmail)).toFormattedString();
230:         return new ShoppingBasketResponseDTO(shoppingBasket.getId().getId(), totalSalesPrice, positions);
231:     }
232: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketItemResponseDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import java.io.Serializable;
4: import java.util.UUID;
5: 
6: public class ShoppingBasketItemResponseDTO implements Serializable {
7:     private UUID itemId;
8:     private int quantity;
9: 
10:     public ShoppingBasketItemResponseDTO(UUID itemId, int quantity) {
11:         this.itemId = itemId;
12:         this.quantity = quantity;
13:     }
14: 
15:     public UUID getItemId() {
16:         return itemId;
17:     }
18: 
19:     public void setItemId(UUID itemId) {
20:         this.itemId = itemId;
21:     }
22: 
23:     public int getQuantity() {
24:         return quantity;
25:     }
26: 
27:     public void setQuantity(int quantity) {
28:         this.quantity = quantity;
29:     }
30: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketResponseDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import java.util.List;
4: import java.util.UUID;
5: 
6: public class ShoppingBasketResponseDTO {
7:     private UUID id;
8:     private String totalSalesPrice;
9:     private List<ShoppingBasketItemResponseDTO> positions;
10: 
11:     public ShoppingBasketResponseDTO(UUID id, String totalSalesPrice, List<ShoppingBasketItemResponseDTO> positions) {
12:         this.id = id;
13:         this.totalSalesPrice = totalSalesPrice;
14:         this.positions = positions;
15:     }
16: 
17:     // Getter und Setter
18:     public UUID getId() {
19:         return id;
20:     }
21: 
22:     public void setId(UUID id) {
23:         this.id = id;
24:     }
25: 
26:     public String getTotalSalesPrice() {
27:         return totalSalesPrice;
28:     }
29: 
30:     public void setTotalSalesPrice(String totalSalesPrice) {
31:         this.totalSalesPrice = totalSalesPrice;
32:     }
33: 
34:     public List<ShoppingBasketItemResponseDTO> getPositions() {
35:         return positions;
36:     }
37: 
38:     public void setPositions(List<ShoppingBasketItemResponseDTO> positions) {
39:         this.positions = positions;
40:     }
41: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.InsufficientStockException;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.domainprimitives.Money;
8: import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
9: import thkoeln.archilab.ecommerce.solution.distributioncenter.application.DistributionCenterService;
10: import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.*;
11: import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
12: import thkoeln.archilab.ecommerce.solution.order.domain.*;
13: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
14: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketId;
15: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
16: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
17: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
18: import thkoeln.archilab.ecommerce.solution.item.domain.Item;
19: import thkoeln.archilab.ecommerce.solution.item.domain.ItemRepository;
20: import thkoeln.archilab.ecommerce.solution.client.domain.Client;
21: import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
22: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
23: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
24: 
25: import java.util.*;
26: import java.util.stream.Collectors;
27: import java.util.stream.StreamSupport;
28: 
29: @Service
30: public class ShoppingBasketService implements ShoppingBasketUseCases {
31: 
32:     @Autowired
33:     private ClientRepository clientRepository;
34: 
35:     @Autowired
36:     private ItemRepository itemRepository;
37: 
38:     @Autowired
39:     private OrderRepository orderRepository;
40: 
41:     @Autowired
42:     private StockLevelRepository stockLevelRepository;
43: 
44:     @Autowired
45:     private ShoppingBasketRepository shoppingBasketRepository;
46: 
47:     @Autowired
48:     private DistributionCenterService distributionCenterService;
49: 
50:     @Autowired
51:     private DistributionCenterRepository distributionCenterRepository;
52: 
53:     @Override
54:     public void addItemToShoppingBasket(EmailType clientEmail, UUID itemId, int quantFor) {
55:         // Validierung führt bei den erwarteten Fehlerbedingungen zu einer Exception
56:         validateInputs(String.valueOf(clientEmail), itemId, quantFor);
57: 
58:         // Wenn keine Exception geworfen wird, fortfahren:
59:         ShoppingBasket shoppingBasket = getShoppingBasketByEmail(String.valueOf(clientEmail));
60: 
61:         ShoppingBasketPosition position = shoppingBasket.getShoppingBasketPositions().stream()
62:                 .filter(pos -> pos.getItemId().equals(itemId))
63:                 .findFirst()
64:                 .orElse(null);
65: 
66:         if (position == null) {
67:             // Erstelle eine neue Position und füge sie dem ShoppingBasket hinzu
68:             position = new ShoppingBasketPosition(itemId, quantFor); // Jetzt nur itemId und quantFor übergeben
69:             shoppingBasket.getShoppingBasketPositions().add(position);
70:         } else {
71:             // Wenn die Position bereits existiert, die Menge aktualisieren
72:             position.setQuantity(position.getQuantity() + quantFor);
73:         }
74: 
75:         // Speichere das ShoppingBasket mit der neuen oder aktualisierten Position
76:         shoppingBasketRepository.save(shoppingBasket);
77:     }
78: 
79:     @Override
80:     public void removeItemFromShoppingBasket(EmailType clientEmail, UUID itemId, int quantFor) {
81:         validateInputs(String.valueOf(clientEmail), itemId, quantFor);
82:         ShoppingBasket shoppingBasket = getShoppingBasketByEmail(String.valueOf(clientEmail));
83: 
84:         ShoppingBasketPosition position = shoppingBasket.getShoppingBasketPositions().stream()
85:                 .filter(pos -> pos.getItemId().equals(itemId))
86:                 .findFirst()
87:                 .orElseThrow(() -> new ShopException("Item not found in shopping basket"));
88: 
89:         if (position.getQuantity() < quantFor) {
90:             throw new ShopException("Not enough quantity to remove");
91:         }
92: 
93:         position.setQuantity(position.getQuantity() - quantFor);
94:         if (position.getQuantity() == 0) {
95:             shoppingBasket.getShoppingBasketPositions().remove(position);
96:         }
97: 
98:         shoppingBasketRepository.save(shoppingBasket);
99:     }
100: 
101:     @Override
102:     public Map<UUID, Integer> getShoppingBasketAsMap(EmailType clientEmail) {
103:         ClientId clientId = ClientId.fromEmail(clientEmail.toString());
104: 
105:         Client client = clientRepository.findById(clientId)
106:                 .orElseThrow(() -> new IllegalArgumentException("Invalid client email"));
107: 
108:         ShoppingBasket shoppingBasket = shoppingBasketRepository.findById(new ShoppingBasketId(client.getShoppingBasketId()))
109:                 .orElseThrow(() -> new IllegalArgumentException("Shopping basket not found for client"));
110: 
111:         Map<UUID, Integer> basketContents = new HashMap<>();
112:         shoppingBasket.getShoppingBasketPositions().forEach(position ->
113:                 basketContents.put(new ItemId(position.getItemId()).getId(), position.getQuantity()));
114: 
115:         return basketContents;
116:     }
117: 
118:     @Override
119:     public MoneyType getShoppingBasketAsMoneyValue(EmailType clientEmail) {
120:         ShoppingBasket shoppingBasket = getShoppingBasketByEmail(String.valueOf(clientEmail));
121:         Money totalValue = Money.of(0.0f, "EUR");  // Verwendung der statischen Fabrikmethode
122:         for (ShoppingBasketPosition position : shoppingBasket.getShoppingBasketPositions()) {
123:             Item item = itemRepository.findById(new ItemId(position.getItemId()))
124:                     .orElseThrow(() -> new ShopException("Item not found"));
125:             MoneyType itemTotal = item.getSalesPrice().multiplyBy(position.getQuantity());
126:             totalValue = (Money) totalValue.add(itemTotal);
127:         }
128:         return totalValue;
129:     }
130: 
131:     @Override
132:     public Set<UUID> checkout(EmailType clientEmail) {
133:         Set<UUID> orderIds = new HashSet<>();
134:         ShoppingBasket shoppingBasket = validateAndPrepareBasket(clientEmail);
135:         Client client = getClient(clientEmail);
136:         Map<ItemId, Integer> itemQuantities = mapBasketToItemQuantities(shoppingBasket);
137: 
138:         List<DistributionCenter> distributionCenters = prepareDistributionCenters(itemQuantities, client);
139: 
140:         Map<UUID, Map<ItemId, Integer>> ordersByDistributionCenter = processOrders(itemQuantities, distributionCenters);
141: 
142:         // Hier sicherstellen, dass Verteilzentrum-IDs zu den erwarteten IDs passen
143:         System.out.println("Orders processed with distribution centers: " + ordersByDistributionCenter);
144: 
145:         createAndPersistOrders(client, ordersByDistributionCenter, orderIds);
146: 
147:         // Einkaufswagen bei erfolgreichem Checkout leeren
148:         clearShoppingBasket(shoppingBasket);
149: 
150:         return orderIds;
151:     }
152: 
153:     private ShoppingBasket validateAndPrepareBasket(EmailType clientEmail) {
154:         ShoppingBasket shoppingBasket = getShoppingBasketByEmail(clientEmail.toString());
155:         if (shoppingBasket.getShoppingBasketPositions().isEmpty()) {
156:             throw new ShopException("The shopping basket is empty");
157:         }
158:         return shoppingBasket;
159:     }
160: 
161:     private Client getClient(EmailType clientEmail) {
162:         return clientRepository.findById(ClientId.fromEmail(clientEmail.toString()))
163:                 .orElseThrow(() -> new ShopException("Client not found"));
164:     }
165: 
166:     private Map<ItemId, Integer> mapBasketToItemQuantities(ShoppingBasket shoppingBasket) {
167:         return shoppingBasket.getShoppingBasketPositions().stream()
168:                 .collect(Collectors.toMap(
169:                         pos -> new ItemId(pos.getItemId()),
170:                         ShoppingBasketPosition::getQuantity
171:                 ));
172:     }
173: 
174:     private List<DistributionCenter> prepareDistributionCenters(Map<ItemId, Integer> itemQuantities, Client client) {
175:         // Debug-Ausgabe zur Überprüfung der Vorbereitung der Verteilzentren
176:         System.out.println("Preparing distribution centers for client: " + client.getId());
177:         for (Map.Entry<ItemId, Integer> entry : itemQuantities.entrySet()) {
178:             System.out.println("Item ID: " + entry.getKey() + ", Quantity Needed: " + entry.getValue());
179:         }
180: 
181:         return StreamSupport.stream(distributionCenterRepository.findAll().spliterator(), false)
182:                 .sorted(new DistributionCenterComparator(itemQuantities, client.getPhysicalAddress().getZipCode().toString(), stockLevelRepository))
183:                 .collect(Collectors.toList());
184:     }
185: 
186:     private Map<UUID, Map<ItemId, Integer>> processOrders(Map<ItemId, Integer> itemQuantities, List<DistributionCenter> distributionCenters) {
187:         Map<UUID, Map<ItemId, Integer>> ordersByDistributionCenter = new HashMap<>();
188: 
189:         // Verfolgung der verbleibenden und erfüllten Artikel
190:         Map<ItemId, Integer> remainingItems = new HashMap<>(itemQuantities);
191: 
192:         while (!remainingItems.isEmpty()) {
193:             DistributionCenter bestCenter = null;
194:             Map<ItemId, Integer> bestCenterOrder = new HashMap<>();
195:             int maxItemsFulfilled = 0;
196: 
197:             // Durchlaufe jedes Distribution Center, um das Beste zu finden
198:             for (DistributionCenter dc : distributionCenters) {
199:                 Map<ItemId, Integer> currentCenterOrder = new HashMap<>();
200:                 int itemsFulfilled = 0;
201: 
202:                 for (Map.Entry<ItemId, Integer> entry : remainingItems.entrySet()) {
203:                     ItemId itemId = entry.getKey();
204:                     int quantityNeeded = entry.getValue();
205: 
206:                     StockLevel stockLevel = stockLevelRepository.findByDistributionCenterAndItemId(dc, itemId.getId()).orElse(null);
207:                     int availableQuantity = (stockLevel != null) ? stockLevel.getQuantity() : 0;
208: 
209:                     if (availableQuantity >= quantityNeeded) {
210:                         currentCenterOrder.put(itemId, quantityNeeded);
211:                         itemsFulfilled++;
212:                     }
213:                 }
214: 
215:                 if (itemsFulfilled > maxItemsFulfilled) {
216:                     bestCenter = dc;
217:                     bestCenterOrder = currentCenterOrder;
218:                     maxItemsFulfilled = itemsFulfilled;
219:                 }
220:             }
221: 
222:             if (bestCenter == null) {
223:                 throw new InsufficientStockException("Nicht genügend Bestand um alle Artikel zu erfüllen");
224:             }
225: 
226:             // Aktualisiere Bestände und verbleibende Artikel
227:             UUID centerId = bestCenter.getId().getId();
228:             for (Map.Entry<ItemId, Integer> entry : bestCenterOrder.entrySet()) {
229:                 ItemId itemId = entry.getKey();
230:                 int quantity = entry.getValue();
231: 
232:                 StockLevel stockLevel = stockLevelRepository.findByDistributionCenterAndItemId(bestCenter, itemId.getId()).orElse(null);
233:                 if (stockLevel != null) {
234:                     stockLevel.setQuantity(stockLevel.getQuantity() - quantity);
235:                     stockLevelRepository.save(stockLevel);
236:                 }
237: 
238:                 remainingItems.remove(itemId);
239:             }
240: 
241:             ordersByDistributionCenter.put(centerId, bestCenterOrder);
242: 
243:             // Überprüfung, ob die spezifischen Zuweisungen (wie itemId12) im Code sichergestellt werden können.
244:         }
245: 
246:         return ordersByDistributionCenter;
247:     }
248: 
249:     private void createAndPersistOrders(Client client, Map<UUID, Map<ItemId, Integer>> ordersByDistributionCenter, Set<UUID> orderIds) {
250:         for (Map.Entry<UUID, Map<ItemId, Integer>> entry : ordersByDistributionCenter.entrySet()) {
251:             Order order = new Order();
252:             order.setId(new OrderId(UUID.randomUUID()));
253:             order.setClientId(client.getId());
254:             order.setDistributionCenterId(entry.getKey());  // DistributionCenterId hier setzen
255: 
256:             for (Map.Entry<ItemId, Integer> itemEntry : entry.getValue().entrySet()) {
257:                 OrderPosition orderPosition = new OrderPosition();
258:                 orderPosition.setId(new OrderPositionId(order.getOrderId(), itemEntry.getKey().getId()));
259:                 orderPosition.setQuantity(itemEntry.getValue());
260: 
261:                 order.getOrderPositions().add(orderPosition);
262:             }
263: 
264:             orderRepository.save(order);
265:             orderIds.add(order.getId().getId());
266:         }
267:     }
268: 
269:     @Override
270:     public void emptyAllShoppingBaskets() {
271:         Iterable<ShoppingBasket> shoppingBaskets = shoppingBasketRepository.findAll();
272:         for (ShoppingBasket shoppingBasket : shoppingBaskets) {
273:             shoppingBasket.getShoppingBasketPositions().clear();
274:             shoppingBasketRepository.save(shoppingBasket);
275:         }
276:     }
277: 
278:     private void validateInputs(String clientEmail, UUID itemId, int quantFor) {
279:         if (clientEmail == null || clientEmail.isEmpty()) {
280:             throw new ShopException("Client email cannot be null or empty");
281:         }
282:         if (itemId == null) {
283:             throw new ShopException("Item ID cannot be null");
284:         }
285:         if (quantFor < 0) {
286:             throw new ShopException("Quantity cannot be negative");
287:         }
288: 
289:         // Prüfen, ob der Client existiert
290:         if (!clientRepository.existsById(ClientId.fromEmail(clientEmail))) {
291:             throw new ShopException("Client does not exist.");
292:         }
293: 
294:         // Prüfen, ob das Item existiert
295:         if (!itemRepository.existsById(new ItemId(itemId))) {
296:             throw new ShopException("Item does not exist.");
297:         }
298:     }
299: 
300:     public ShoppingBasket getShoppingBasketByEmail(String clientEmail) {
301:         Client client = clientRepository.findById(ClientId.fromEmail(clientEmail))
302:                 .orElseThrow(() -> new ShopException("Client not found"));
303: 
304:         UUID shoppingBasketId = client.getShoppingBasketId();
305:         return shoppingBasketRepository.findById(new ShoppingBasketId(shoppingBasketId))
306:                 .orElseThrow(() -> new ShopException("Shopping basket does not exist"));
307:     }
308: 
309: 
310:     private void clearShoppingBasket(ShoppingBasket shoppingBasket) {
311:         shoppingBasket.getShoppingBasketPositions().clear();
312:         shoppingBasketRepository.save(shoppingBasket);
313: 
314:     }
315: 
316:     public Client getClientByShoppingBasketId(UUID shoppingBasketId) {
317:         // Sicherstellen, dass Debugging-Informationen für die Diagnose hinzugefügt werden
318:         System.out.println("Attempting to find client for Shopping Basket ID: " + shoppingBasketId);
319: 
320:         return clientRepository.findByShoppingBasketId(shoppingBasketId)
321:                 .orElseThrow(() -> new ShopException("Client not found for provided shopping basket ID"));
322:     }
323: 
324:     public Optional<ShoppingBasket> findById(ShoppingBasketId shoppingBasketId) {
325:         return shoppingBasketRepository.findById(shoppingBasketId);
326:     }
327: 
328:     public void save(ShoppingBasket shoppingBasket) {
329:         shoppingBasketRepository.save(shoppingBasket);
330:     }
331: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppableInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import java.util.List;
4: import java.util.UUID;
5: 
6: public interface ShoppableInterface {
7:     UUID getShoppingBasketId();
8:     List<ShoppingBasketPosition> getShoppingBasketPositions();
9: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Getter;
5: import lombok.Setter;
6: import thkoeln.archilab.ecommerce.solution.client.domain.Shoppable;
7: 
8: import java.util.*;
9: 
10: @Entity
11: @Getter
12: @Setter
13: public class ShoppingBasket {
14: 
15:     @EmbeddedId
16:     private ShoppingBasketId id;
17: 
18:     // Verknüpft die Positionen über JoinColumn, aber ohne redundante Spaltenbenennung
19:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
20:     @JoinColumn(name = "shopping_basket_id")
21:     private List<ShoppingBasketPosition> shoppingBasketPositions = new ArrayList<>();
22: 
23:     // Default-Konstruktor
24:     public ShoppingBasket() {
25:         this.id = new ShoppingBasketId(UUID.randomUUID());
26:     }
27: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.AccessLevel;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.GenericId;
7: 
8: import java.util.UUID;
9: 
10: @Embeddable
11: public class ShoppingBasketId extends GenericId {
12:     // No-Argument-Konstruktor benötigt von Hibernate
13:     protected ShoppingBasketId() {
14:         super();
15:     }
16: 
17:     public ShoppingBasketId(UUID id) {
18:         super(id);
19:     }
20: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ShoppingBasketIdConverter extends GenericIdConverter<ShoppingBasketId> {
8:     public ShoppingBasketIdConverter() {
9:         super(ShoppingBasketId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.UUID;
9: 
10: 
11: @Entity
12: @Getter
13: @Setter
14: @NoArgsConstructor
15: public class ShoppingBasketPosition {
16: 
17:     @EmbeddedId
18:     private ShoppingBasketPositionId id;
19: 
20:     private int quantity;
21: 
22:     private UUID itemId;
23: 
24:     // Konstruktor ohne die shoppingBasketId
25:     public ShoppingBasketPosition(UUID itemId, int quantity) {
26:         this.id = new ShoppingBasketPositionId(UUID.randomUUID());
27:         this.itemId = itemId;
28:         this.quantity = quantity;
29:     }
30: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import java.util.UUID;
4: 
5: public class ShoppingBasketPositionDTO {
6:     private UUID itemId;
7:     private int quantity;
8: 
9:     public ShoppingBasketPositionDTO(UUID itemId, int quantity) {
10:         this.itemId = itemId;
11:         this.quantity = quantity;
12:     }
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.AccessLevel;
5: import lombok.NoArgsConstructor;
6: import thkoeln.archilab.ecommerce.GenericId;
7: 
8: import java.util.UUID;
9: 
10: @Embeddable
11: @NoArgsConstructor(access = AccessLevel.PROTECTED) // Sicherstellen, dass ein geschützter No-Args-Konstruktor existiert
12: public class ShoppingBasketPositionId extends GenericId {
13: 
14:     public ShoppingBasketPositionId(UUID id) {
15:         super(id);
16:     }
17: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ShoppingBasketPositionIdConverter extends GenericIdConverter<ShoppingBasketPositionId> {
8:     public ShoppingBasketPositionIdConverter() {
9:         super(ShoppingBasketPositionId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: 
5: public interface ShoppingBasketRepository extends CrudRepository<ShoppingBasket, ShoppingBasketId> {}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\ClientRegistrationUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: 
11: /**
12:  * This interface contains methods needed in the context of use cases concerning the registration of a client.
13:  * The interface is probably incomplete, and will grow over time ...
14:  */
15: public interface ClientRegistrationUseCases {
16:     /**
17:      * Registers a new client
18:      *
19:      * @param name
20:      * @param email
21:      * @param physicalAddress
22:      * @throws ShopException if ...
23:      *      - the client with the given email already exists
24:      *      - physicalAddress is null
25:      */
26:     public void register( String name, EmailType email, PhysicalAddressType physicalAddress );
27: 
28: 
29:     /**
30:      * Changes the address of a client
31:      *
32:      * @param clientEmail
33:      * @param clientEmail
34:      * @param physicalAddress
35:      * @throws ShopException if ...
36:      *      - the client with the given email does not exist,
37:      *      - physicalAddress is null
38:      */
39:     public void changeAddress( EmailType clientEmail,
40:                                PhysicalAddressType physicalAddress );
41: 
42: 
43:     /**
44:      * Returns the data of a client as an array of strings (name, email, street, city, zipCode)
45:      * @param clientEmail
46:      * @return the client data
47:      * @throws ShopException the client with the given email does not exist,
48:      */
49:     public ClientType getClientData( EmailType clientEmail );
50: 
51: 
52: 
53:     /**
54:      * Clears all clients, including all orders and shopping baskets
55:      */
56:     public void deleteAllClients();
57: }
58: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\ClientType.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
5: 
6: /**
7:  * This interface expresses the essence of a shop client
8:  */
9: public interface ClientType {
10:     String getName();
11:     EmailType getEmail();
12:     PhysicalAddressType getPhysicalAddress();
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\DistributionCenterUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
9: 
10: import java.util.UUID;
11: 
12: /**
13:  * This interface contains methods needed in the context of handling the shop stock,
14:  * i.e. managing distribution centers, and adding / removing items in the distribution center.
15:  */
16: public interface DistributionCenterUseCases {
17:     /**
18:      *
19:      * @param name
20:      * @param physicalAddress
21:      * @return the id of the new distribution center
22:      * @throws ShopException if ...
23:      *      - name is null or empty
24:      *      - physicalAddress is null
25:      */
26:     public UUID addNewDistributionCenter( String name, PhysicalAddressType physicalAddress );
27: 
28: 
29:     /**
30:      * Deletes all distribution centers from the shop. Intended for testing purposes.
31:      */
32:     public void deleteAllDistributionCenters();
33: 
34: 
35:     /**
36:      * Adds a certain Quantity of a given item to the stock
37:      * @param distributionCenterId
38:      * @param itemId
39:      * @param addedQuantFor
40:      * @throws ShopException if ...
41:      *      - distributionCenterId is null
42:      *      - the distribution center with that id does not exist
43:      *      - itemId is null
44:      *      - the item with that id does not exist
45:      *      - addedQuantFor < 0
46:      */
47:     public void addToStock( UUID distributionCenterId, UUID itemId, int addedQuantFor );
48: 
49: 
50:     /**
51:      * Removes a certain Quantity of a given item from the stock.
52:      * @param distributionCenterId
53:      * @param itemId
54:      * @param removedQuantFor
55:      * @throws ShopException if ...
56:      *      - distributionCenterId is null
57:      *      - the distribution center with that id does not exist
58:      *      - itemId is null
59:      *      - the item with that id does not exist
60:      *      - removedQuantFor < 0
61:      */
62:     public void removeFromStock( UUID distributionCenterId, UUID itemId, int removedQuantFor );
63: 
64: 
65:     /**
66:      * Changes the total Quantity of a given item in the stock.
67:      * @param distributionCenterId
68:      * @param itemId
69:      * @param newTotalQuantFor
70:      * @throws ShopException if ...
71:      *      - distributionCenterId is null
72:      *      - the distribution center with that id does not exist
73:      *      - itemId is null
74:      *      - the item with that id does not exist
75:      *      - newTotalQuantFor < 0
76:      */
77:     public void changeStockTo( UUID distributionCenterId, UUID itemId, int newTotalQuantFor );
78: 
79: 
80:     /**
81:      * Get the current stock of a given item in one specific distribution center.
82:      * @param distributionCenterId
83:      * @param itemId
84:      * @return the current total stock of the item
85:      * @throws ShopException if ...
86:      *      - distributionCenterId is null
87:      *      - the distribution center with that id does not exist
88:      *      - itemId is null
89:      *      - the item with that id does not exist
90:      */
91:     public int getAvailableStock( UUID distributionCenterId, UUID itemId );
92: 
93: 
94: }
95: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\EmailType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface EmailType {
6:     /**
7:      * @return the email as a string
8:      */
9:     public String toString();
10: 
11: 
12:     /**
13:      * A special kind of "copy constructor": Returns a new email object with
14:      * the same identifyer (the substring left of the "@" sign) as the current one, but
15:      * with a new domain substring (right of the "@" sign).
16:      * @param domainString - the new domain for the copied email
17:      * @return the new email
18:      * @throws ShopException if ...
19:      *     - domainString is null
20:      *     - the new email would not be valid (see `of(...)` method)
21:      */
22:     public EmailType sameIdentifyerDifferentDomain( String domainString );
23: 
24:     /**
25:      * Another special kind of "copy constructor": Returns a new email object
26:      * with the same domain (the substring right of the "@" sign) as the current one, but
27:      * with a new identifyer substring (left of the "@" sign).
28:      * @param identifyerString - the new identifyer for the copied email
29:      * @return the new email
30:      * @throws ShopException if ...
31:      *     - identifyerString is null
32:      *     - the new email would not be valid (see `of(...)` method)
33:      */
34:     public EmailType sameDomainDifferentIdentifyer( String identifyerString );
35: 
36: 
37:     /**
38:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
39:      * implementing class to provide a static factory method (simply named "of(...)"),
40:      * which creates an email, given as a string.
41:      * We specify this factory method here as a comment, using the Javadoc documentation style.
42:      *
43:      * @param emailAsString - the email as a string.
44:      *      We will use a much simplified validation method to check if the email is valid:
45:      *      - it must contain exactly one '@' character.
46:      *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
47:      *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
48:      *      - the substrings before and after the '@' may contain one or several '.' as separators
49:      *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
50:      *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
51:      *        (for simplicity we do not allow any other domains)
52:      * @return a new EmailType object matching the given email
53:      * @throws ShopException if ...
54:      *      - emailAsString is null
55:      *      - emailAsString is not a valid email (see above)
56:      */
57:      // public static EmailType of( String emailAsString );
58: }
59: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MoneyType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface MoneyType {
6:     /**
7:      * @return the amount of money
8:      */
9:     public Float getAmount();
10: 
11: 
12:     /**
13:      * @return the currency unit of the money
14:      */
15:     public String getCurrencyUnit();
16: 
17: 
18:     /**
19:      * @param otherMoney
20:      * @return this + otherMoney, as a new object
21:      * @throws ShopException if ...
22:      *      - otherMoney is null
23:      *      - otherMoney.currencyUnit != this.currencyUnit
24:      */
25:     public MoneyType add( MoneyType otherMoney );
26: 
27: 
28:     /**
29:      * @param otherMoney
30:      * @return this - otherMoney, as a new object
31:      * @throws ShopException if ...
32:      *      - otherMoney is null
33:      *      - otherMoney.currencyUnit != this.currencyUnit
34:      *      - otherMoney > this
35:      */
36:     public MoneyType subtract( MoneyType otherMoney );
37: 
38: 
39:     /**
40:      * @param factor
41:      * @return this * factor, as a new object
42:      * @throws ShopException if ...
43:      *     - factor < 0
44:      */
45:     public MoneyType multiplyBy( int factor );
46: 
47:     /**
48:      * @param otherMoney
49:      * @return true, if this > otherMoney
50:      * @throws ShopException if ...
51:      *      - otherMoney is null
52:      *      - otherMoney.currencyUnit != this.currencyUnit
53:      */
54:     public boolean largerThan( MoneyType otherMoney );
55: 
56: 
57:     /**
58:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
59:      * implementing class to provide a static factory method (simply named "of(...)"),
60:      * which creates a money object from an amount and a currency unit (as string).
61:      * We specify this factory method here as a comment, using the Javadoc documentation style.
62:      *
63:      * @param amount the amount of money (must be >= 0)
64:      * @param currencyUnit the currency unit of the money (allowed values: "EUR", "CHF")
65:      * @return a new Money object with the given amount and currency unit
66:      * @throws ShopException if ...
67:      *   - amount is null
68:      *   - amount < 0
69:      *   - currency unit is null
70:      *   - currency unit is not one of the allowed values
71:      */
72:      // public static MoneyType of( Float amount, String currencyUnit );
73: }
74: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PhysicalAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface PhysicalAddressType {
6:     /**
7:      * @return the street as a string
8:      */
9:     public String getStreet();
10: 
11:     /**
12:      * @return the city as a string
13:      */
14:     public String getCity();
15: 
16:     /**
17:      * @return the zip code
18:      */
19:     public ZipCodeType getZipCode();
20: 
21:     /**
22:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
23:      * implementing class to provide a static factory method (simply named "of(...)"),
24:      * which creates an zip code, given as a string.
25:      * We specify this factory method here as a comment, using the Javadoc documentation style.
26:      *
27:      * @param street the street as a string
28:      * @param city the city as a string
29:      * @param zipCode the zip code
30:      * @return the physical address object matching the parameters
31:      * @throws ShopException if ...
32:      *      - street is null or empty
33:      *      - city is null or empty
34:      *      - zipCode is null
35:      */
36:      // public static PhysicalAddressType of( String street, String city, ZipCodeType zipCode );
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\ZipCodeType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnore;
4: import thkoeln.archilab.ecommerce.ShopException;
5: 
6: public interface ZipCodeType {
7:     /**
8:      * @return the zip code as a string
9:      */
10:     public String toString();
11: 
12:     /**
13:      * You will need some idea of "imprecise difference" between two zip codes for properly
14:      * implementing distribution centers in your shopping platform. This method calculates such a
15:      * difference. You can decide for yourself what values you return, unless you comply
16:      * with the following rules.
17:      * - The return value is 0 if both zip codes are the same
18:      * - If not:
19:      *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
20:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
21:      *        So, 56733 and 56734 have the same difference as 56733 and 56739.
22:      *      - The difference grows if more digits (counted from the right side) differ.
23:      *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
24:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
25:      *        53876 and 54876 have the same difference as 53876 and 57261.
26:      *      - However, the difference between 5abcd and 6rstu must be smaller than the one
27:      *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
28:      *        one between 5abcd and 9rstu.
29:      *      - This last condition reflects the fact the first digits of a zip code marks a region
30:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
31:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
32:      *        other.
33:      * @param otherZipCode
34:      * @return the calculated difference
35:      * @throws ShopException if otherZipCode is null
36:      */
37:     public int difference( ZipCodeType otherZipCode );
38: 
39: 
40:     /**
41:      * For the currently used way of deciding on the best fitting distribution center for a order,
42:      * we need to know the first digit of the zip code.
43:      */
44:     @JsonIgnore
45:     public Integer getFirstDigitZipCode();
46: 
47: 
48:     /**
49:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
50:      * implementing class to provide a static factory method (simply named "of(...)"),
51:      * which creates an zip code, given as a string.
52:      * We specify this factory method here as a comment, using the Javadoc documentation style.
53:      *
54:      * @param zipCodeAsString - the zip code as a string.
55:      *      We will use a much simplified validation method to check if the zip code is valid:
56:      *      - It must contain exactly 5 digits.
57:      *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid zip code, but 20001 is valid)
58:      * @return a new zip code object matching the given string
59:      * @throws ShopException if ...
60:      *      - zipCodeAsString is null
61:      *      - zipCodeAsString is not a valid zip code (see above)
62:      */
63:      // public static ZipCodeType of( String zipCodeAsString );
64: }
65: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\ItemCatalogUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: 
10: import java.util.UUID;
11: 
12: 
13: /**
14:  * This interface contains methods needed in the context of use cases concerning the item catalog.
15:  * The interface is probably incomplete, and will grow over time ...
16:  */
17: 
18: public interface ItemCatalogUseCases {
19:     /**
20:      * Adds a new item to the shop catalog
21:      * @param name
22:      * @param descriptOf
23:      * @param size
24:      * @param buyingPrice
25:      * @param salesPrice
26:      * @return the id of the new item
27:      * @throws ShopException if ...
28:      *      - the item id already exists,
29:      *      - name or description are null or empty,
30:      *      - the size is <= 0 (but can be null!),
31:      *      - the buying price is null or <= 0,
32:      *      - the buyingPrice is null,
33:      *      - the sales price is null,
34:      *      - the sales price is lower than the buyingPrice
35:      */
36:     public UUID addItemToCatalog( String name, String descriptOf, Float size,
37:                                            MoneyType buyingPrice, MoneyType salesPrice );
38: 
39: 
40:     /**
41:      * Removes a item from the shop catalog
42:      * @param itemId
43:      * @throws ShopException if
44:      *      - itemId is null
45:      *      - the item id does not exist
46:      *      - the item is still in stock
47:      *      - the item is still in a shopping basket, or referenced by a completed order
48:      */
49:     public void removeItemFromCatalog( UUID itemId );
50: 
51: 
52:     /**
53:      * Get the sales price of a given item
54:      * @param itemId
55:      * @return the sales price
56:      * @throws ShopException if ...
57:      *      - itemId is null,
58:      *      - the item with that id does not exist
59:      */
60:     public MoneyType getSalesPrice( UUID itemId );
61: 
62: 
63:     /**
64:      * Clears the item catalog, i.e. removes all items from the catalog, including all the stock,
65:      * all the reservations and all the orders.
66:      */
67:     public void deleteItemCatalog();
68: 
69: }
70: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ClientTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: 
4: import thkoeln.archilab.ecommerce.usecases.ClientType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
7: 
8: /**
9:  * This is a test helper interface provides access to predefined test data for
10:  * clients.
11:  */
12: public interface ClientTestHelper {
13:     /**
14:      * This method calls the use case implementation to register all clients specified in the
15:      * test data set.
16:      * If you use the debugger and want to identify _which_ test client you currently look at:
17:      * The indices are coded into the house number (in the client's physical address) and in the first
18:      * cipher of the zip code. This is the list of clients:
19:      *
20:      * +-------+-------------------+--------+---------------------
21:      * | Index | Name              | PLZ    | Email
22:      * +-------+-------------------+--------+---------------------
23:      * | 0     | Max Mueller       | 02314  | 99Z@example.com
24:      * | 1     | Sophie Schmitz    | 02368  | a@4.com
25:      * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
26:      * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
27:      * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
28:      * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
29:      * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
30:      * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
31:      * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
32:      * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
33:      * +-------+-------------------+--------+---------------------
34:      */
35:     void registerAllClients();
36: 
37: 
38:     /**
39:      * @return the number of test clients in the test data set.
40:      */
41:     int getNumberOfClients();
42: 
43: 
44:     /**
45:      * @param index the index of the client in the test data set.
46:      * @return the name of the test client with the given index.
47:      */
48:     String getClientName( int index );
49: 
50: 
51:     /**
52:      * @param index the index of the client in the test data set.
53:      * @return the email of the test client with the given index.
54:      */
55:     EmailType getClientEmail( int index );
56: 
57: 
58:     /**
59:      * @param index the index of the client in the test data set.
60:      * @return the physical address of the test client with the given index.
61:      */
62:     PhysicalAddressType getClientPhysicalAddress( int index );
63: 
64: 
65:     /**
66:      * @param index the index of the client in the test data set.
67:      * @return the test client with the given index.
68:      */
69:     ClientType getClient( int index );
70: 
71: }
72: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\DistributionCenterTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import java.util.UUID;
4: 
5: public interface DistributionCenterTestHelper {
6:     /**
7:      * Adds the test distribution centers to the system.
8:      * If you want to use the distribution centers, or want to know which index the distribution center has that you see
9:      * in the debugger, the following rules apply:
10:      * - The distribution center name will equal the street name of the physical address of the distribution center.
11:      * - The index number is visible in the house number. Example: distribution center 3 is located at
12:      *   "Ablageweg 3", and that is also its name.
13:      *
14:      *  The distribution centers are used in the tests as follows:
15:      *  - distribution center 0 holds all items 0 - 6, and is used for all tests where it is not relevant
16:      *    to split one shopping basket into several orders.
17:      *  - distribution centers 1 - 3 are used for the proximity tests, where you can deliver item 7 to
18:      *    to a client from the closest distribution center.
19:      *  - distribution centers 4 - 8 are used for the tests where you need to deliver items 8 - 14 in
20:      *    the most cost-efficient way, as multiple shipments.
21:      *  - distribution center 9 is empty.
22:      *
23:      *  If withStock is true, then the distribution centers are filled with items. This happens
24:      *  according to the following rules:
25:      *  - items 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
26:      *    ONLY available in distribution center 0. (This means that item 0 out of stock everywhere.)
27:      *  - items 4, 5, 6 have a random stock between 30 and 130, also all ONLY in distribution center 0
28:           (these are the items used for tests on how to add and remove stock)
29:      *  - item 7 has a random stock between 30 and 130, distributed over
30:      *    distribution centers 1, 2, and 3. You can use this to test if the appropriate distribution center is found
31:      *    for a shopping basket with only item 7 in it, but with different quantities (<= 3, or > 3).
32:      *  - The other items (8 - 14) have also a random stock between 30 and 130, all distributed
33:      *    over several distribution centers. The distribution is done as follows:
34:      *    Assume that the item is available in <n> distribution centers. Then the first <n-1> distribution centers
35:      *    in the list (in ascending sequence) contain 3, and all the remaining stock is in the
36:      *    last distribution center.
37:      *
38:      *    This is how the stock of items could be distributed
39:      *    (Wx = distribution center x with its zip code, Px = item x,
40:      *    numbers marked with (*) are random large numbers):
41:      *
42:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
43:      *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
44:      *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
45:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
46:      *    | P0   |      |     |     |      |     |      |     |       |      |     |
47:      *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
48:      *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
49:      *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
50:      *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
51:      *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
52:      *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
53:      *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
54:      *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
55:      *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
56:      *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
57:      *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
58:      *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
59:      *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
60:      *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
61:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
62:      *
63:      * @param withStock if true, the stock of the items is added to the distribution center. Otherwise, the
64:      *                           the stock is not added and the distribution center is empty.
65:      */
66:     public void addAllDistributionCenters( boolean withStock );
67: 
68: 
69:     /**
70:      * @return the number of test distribution centers in the database
71:      */
72:     int numberOfDistributionCenters();
73: 
74: 
75:     /**
76:      * @param index
77:      * @return the id of the test distribution center at the given index
78:      */
79:     UUID getDistributionCenterId( int index );
80: 
81: 
82:     /**
83:      * @param distributionCenterId - the id of the distribution center in the test data
84:      * @return the index of the test distribution center with that id
85:      */
86:     int findDistributionCenterIndex( UUID distributionCenterId );
87: 
88: 
89:     /**
90:      * @param itemIndex - the index of the item in the test data
91:      * @param distributionCenterIndex - the index of the distribution center in the test data
92:      * @return the number of items (stock) available in the distribution center at the given index
93:      */
94:     Integer getDistributionCenterStock( int distributionCenterIndex, int itemIndex );
95: 
96: }
97: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
8: 
9: import java.io.File;
10: import java.io.IOException;
11: import java.lang.reflect.InvocationTargetException;
12: import java.lang.reflect.Method;
13: import java.lang.reflect.Modifier;
14: import java.net.URL;
15: import java.net.URLDecoder;
16: import java.nio.charset.StandardCharsets;
17: import java.util.Enumeration;
18: 
19: import static org.junit.jupiter.api.Assertions.*;
20: 
21: public class FactoryMethodInvoker {
22: 
23:     public static EmailType instantiateEmail( String emailAsString ) {
24:         Method factoryMethod = null;
25:         try {
26:             Class<?> interfaceClass = Class.forName(
27:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType" );
28:             Class<?> implementingClass = findImplementation( interfaceClass );
29: 
30:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
31:             assertNotNull( factoryMethod );
32:             int modifiers = factoryMethod.getModifiers();
33:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
34:         } catch (Exception e) {
35:             fail( "Failed to find implementation for EmailType", e );
36:         }
37: 
38:         Object instance = null;
39:         try {
40:             instance = factoryMethod.invoke( null, emailAsString );
41:         } catch (Exception e) {
42:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
43:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
44:             fail( "Failed to invoke factory method 'of' for '" + emailAsString + "'", e );
45:         }
46:         assertNotNull( instance );
47:         return (EmailType) instance;
48:     }
49: 
50: 
51:     public static PhysicalAddressType instantiatePhysicalAddress(
52:             String street, String city, ZipCodeType zipCode ) {
53:         Method factoryMethod = null;
54:         try {
55:             Class<?> interfaceClass = Class.forName(
56:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType" );
57:             Class<?> implementingClass = findImplementation( interfaceClass );
58: 
59:             factoryMethod = implementingClass.getDeclaredMethod( "of",
60:                     String.class, String.class, ZipCodeType.class );
61:             assertNotNull( factoryMethod );
62:             int modifiers = factoryMethod.getModifiers();
63:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
64:         } catch (Exception e) {
65:             fail( "Failed to find implementation for PhysicalAddressType", e );
66:         }
67: 
68:         Object instance = null;
69:         try {
70:             instance = factoryMethod.invoke( null, street, city, zipCode );
71:         } catch (Exception e) {
72:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
73:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
74:             fail( "Failed to invoke factory method 'of' for '" +
75:                     street + "', '" + city + "', '" + zipCode + "'", e );
76:         }
77:         assertNotNull( instance );
78:         return (PhysicalAddressType) instance;
79:     }
80: 
81: 
82:     public static ZipCodeType instantiateZipCode( String zipCodeAsString ) {
83:         Method factoryMethod = null;
84:         try {
85:             Class<?> interfaceClass = Class.forName(
86:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType" );
87:             Class<?> implementingClass = findImplementation( interfaceClass );
88: 
89:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
90:             assertNotNull( factoryMethod );
91:             int modifiers = factoryMethod.getModifiers();
92:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
93:         } catch (Exception e) {
94:             fail( "Failed to find implementation for ZipCodeType", e );
95:         }
96: 
97:         Object instance = null;
98:         try {
99:             instance = factoryMethod.invoke( null, zipCodeAsString );
100:         } catch (Exception e) {
101:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
102:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
103:             fail( "Failed to invoke factory method 'of' for '" + zipCodeAsString + "'", e );
104:         }
105:         assertNotNull( instance );
106:         return (ZipCodeType) instance;
107:     }
108: 
109: 
110:     public static MoneyType instantiateMoney( Float amount, String currencyUnit ) {
111:         Method factoryMethod = null;
112:         try {
113:             Class<?> interfaceClass = Class.forName(
114:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType" );
115:             Class<?> implementingClass = findImplementation( interfaceClass );
116: 
117:             factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
118:             assertNotNull( factoryMethod );
119:             int modifiers = factoryMethod.getModifiers();
120:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
121:         } catch (Exception e) {
122:             fail( "Failed to find implementation for MoneyType", e );
123:         }
124: 
125:         Object instance = null;
126:         try {
127:             instance = factoryMethod.invoke( null, amount, currencyUnit );
128:         } catch (Exception e) {
129:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
130:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
131:             fail( "Failed to invoke factory method 'of' for '" + amount + "', '" + currencyUnit + "'", e );
132:         }
133:         assertNotNull( instance );
134:         return (MoneyType) instance;
135:     }
136: 
137: 
138:     private static Class<?> findImplementation( Class<?> interfaceClass ) {
139:         Method factoryMethod = null;
140:         try {
141:             String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
142:             Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
143:             assertNotNull( implementingClass );
144:             return implementingClass;
145:         } catch (Exception e) {
146:             fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
147:             return null; // This line will never be reached, but it's necessary to satisfy the compiler
148:         }
149:     }
150: 
151: 
152:     private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
153:             throws ClassNotFoundException, IOException {
154:         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
155:         String path = packageName.replace( '.', '/' );
156:         Enumeration<URL> resources = classLoader.getResources( path );
157:         int count = 0;
158:         Class<?> result = null;
159:         while (resources.hasMoreElements()) {
160:             URL resource = resources.nextElement();
161:             File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
162:             File[] files = directory.listFiles();
163:             for ( File file : files ) {
164:                 if ( file.getName().endsWith( ".class" ) ) {
165:                     String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
166:                     Class<?> clazz = Class.forName( className );
167:                     if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
168:                         count++;
169:                         result = clazz;
170:                     }
171:                 }
172:             }
173:         }
174:         assertEquals( 1, count, "There should be exactly one implementing class" );
175:         return result;
176:     }
177: }
178: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\ClientTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
7: import thkoeln.archilab.ecommerce.usecases.ClientType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.MockClient;
12: 
13: import static org.junit.jupiter.api.Assertions.assertThrows;
14: 
15: /**
16:  * This is a test helper class that initializes and registers clients in the system,
17:  * using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class ClientTestHelperImpl implements ClientTestHelper {
22: 
23:     private ClientRegistrationUseCases clientRegistrationUseCases;
24: 
25:     @Autowired
26:     public ClientTestHelperImpl( ClientRegistrationUseCases clientRegistrationUseCases ) {
27:         this.clientRegistrationUseCases = clientRegistrationUseCases;
28:     }
29: 
30:     private final static String[] CLIENT_NAME = new String[]{
31:             "Max Mueller",
32:             "Sophie Schmitz",
33:             "Irene Mihalic",
34:             "Emilia Fischer",
35:             "Filiz Polat",
36:             "Lina Wagner",
37:             "Leon Becker",
38:             "Agnieszka Kalterer",
39:             "Felix Bauer",
40:             "Lara Schulz"
41:     };
42: 
43:     private final static EmailType[] CLIENT_EMAIL = new EmailType[]{
44:             FactoryMethodInvoker.instantiateEmail( "99Z@example.com" ),
45:             FactoryMethodInvoker.instantiateEmail( "a@4.com" ),
46:             FactoryMethodInvoker.instantiateEmail( "irene@wearefreedomnow.com" ),
47:             FactoryMethodInvoker.instantiateEmail( "emilia.fischer@example.com" ),
48:             FactoryMethodInvoker.instantiateEmail( "j877d3@example.this.com" ),
49:             FactoryMethodInvoker.instantiateEmail( "lina.marie.wagner@example.com" ),
50:             FactoryMethodInvoker.instantiateEmail( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
51:             FactoryMethodInvoker.instantiateEmail( "agna@here.ch" ),
52:             FactoryMethodInvoker.instantiateEmail( "felix.bauer@example.org" ),
53:             FactoryMethodInvoker.instantiateEmail( "lara.schulz@example.at" )
54:     };
55: 
56:     // The following array is used to create a list of physicalAddresss for the clients.
57:     // The indices are coded into the house number.
58:     // - Persons 0 - 5 are used for proximity tests with one distribution center.
59:     private final static PhysicalAddressType[] CLIENT_ADDRESS = new PhysicalAddressType[]{
60:             FactoryMethodInvoker.instantiatePhysicalAddress(
61:                     "Marktstraße 0", "Viertelstadt",
62:                     FactoryMethodInvoker.instantiateZipCode( "02314" ) ),
63:             FactoryMethodInvoker.instantiatePhysicalAddress(
64:                     "Hauptstraße 1", "Viertelstadt",
65:                     FactoryMethodInvoker.instantiateZipCode( "02368" ) ),
66:             FactoryMethodInvoker.instantiatePhysicalAddress(
67:                     "Kirchplatz 2", "Niemandstown",
68:                     FactoryMethodInvoker.instantiateZipCode( "12345" ) ),
69:             FactoryMethodInvoker.instantiatePhysicalAddress(
70:                     "Schulstraße 3", "Geisterhausen",
71:                     FactoryMethodInvoker.instantiateZipCode( "31463" ) ),
72:             FactoryMethodInvoker.instantiatePhysicalAddress(
73:                     "Rosenweg 4", "Kuhhausen",
74:                     FactoryMethodInvoker.instantiateZipCode( "72162" ) ),
75:             FactoryMethodInvoker.instantiatePhysicalAddress(
76:                     "Wiesenstraße 5", "Waldschenkensdorf",
77:                     FactoryMethodInvoker.instantiateZipCode( "82195" ) ),
78:             FactoryMethodInvoker.instantiatePhysicalAddress(
79:                     "Muehlenweg 6", "Koeln",
80:                     FactoryMethodInvoker.instantiateZipCode( "50667" ) ),
81:             FactoryMethodInvoker.instantiatePhysicalAddress(
82:                     "Goethestraße 7", "Frankfurt am Main",
83:                     FactoryMethodInvoker.instantiateZipCode( "60311" ) ),
84:             FactoryMethodInvoker.instantiatePhysicalAddress(
85:                     "Dorfstraße 8", "Stuttgart",
86:                     FactoryMethodInvoker.instantiateZipCode( "70173" ) ),
87:             FactoryMethodInvoker.instantiatePhysicalAddress(
88:                     "Bahnhofstraße 9", "Muenchen",
89:                     FactoryMethodInvoker.instantiateZipCode( "80331" ) )
90:     };
91: 
92:     private final static ClientType[] mockClients;
93: 
94:     static {
95:         mockClients = new ClientType[CLIENT_NAME.length];
96:         for ( int i = 0; i < CLIENT_NAME.length; i++ ) {
97:             mockClients[i] = new MockClient(
98:                     CLIENT_NAME[i], CLIENT_EMAIL[i], CLIENT_ADDRESS[i] );
99:         }
100:     }
101: 
102: 
103:     @Override
104:     public void registerAllClients() {
105:         for ( int i = 0; i < CLIENT_NAME.length; i++ ) {
106:             registerClient( CLIENT_NAME[i], CLIENT_EMAIL[i], CLIENT_ADDRESS[i] );
107:         }
108:     }
109: 
110: 
111:     private void registerClient( String name, EmailType email, PhysicalAddressType physicalAddress ) {
112:         clientRegistrationUseCases.register( name, email, physicalAddress );
113:     }
114: 
115: 
116:     @Override
117:     public int getNumberOfClients() {
118:         return CLIENT_NAME.length;
119:     }
120: 
121: 
122:     @Override
123:     public String getClientName( int index ) {
124:         if ( index < 0 || index >= CLIENT_NAME.length ) {
125:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
126:         }
127:         return CLIENT_NAME[index];
128:     }
129: 
130: 
131:     @Override
132:     public EmailType getClientEmail( int index ) {
133:         if ( index < 0 || index >= CLIENT_NAME.length ) {
134:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
135:         }
136:         return CLIENT_EMAIL[index];
137:     }
138: 
139: 
140:     @Override
141:     public PhysicalAddressType getClientPhysicalAddress( int index ) {
142:         if ( index < 0 || index >= CLIENT_NAME.length ) {
143:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
144:         }
145:         return CLIENT_ADDRESS[index];
146:     }
147: 
148: 
149:     @Override
150:     public ClientType getClient( int index ) {
151:         if ( index < 0 || index >= CLIENT_NAME.length ) {
152:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
153:         }
154:         return mockClients[index];
155:     }
156: }
157: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\StockTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.DistributionCenterTestHelper;
7: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
8: import thkoeln.archilab.ecommerce.usecases.DistributionCenterUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
12: 
13: import java.util.*;
14: 
15: /**
16:  * This is a test helper class that initializes and registers items (but without stock)
17:  * in the system, using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class StockTestHelperImpl
22:                         implements ItemTestHelper, DistributionCenterTestHelper {
23:     private ItemCatalogUseCases itemCatalogUseCases;
24:     private DistributionCenterUseCases distributionCenterUseCases;
25:     private static Random random = new Random();
26: 
27:     private static final String EUR = "EUR";
28:     private static final int ITEM_NUMOF = 15;
29:     private static final Object[][] ITEM_DATA = new Object[][]{
30:             {null, "0-TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
31:                     1.5f, FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
32:                     FactoryMethodInvoker.instantiateMoney( 10.0f, EUR ),
33:                     "0"},
34:             {null, "1-EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
35:                     0.3f, FactoryMethodInvoker.instantiateMoney( 2.5f, EUR ),
36:                     FactoryMethodInvoker.instantiateMoney( 4.0f, EUR ),
37:                     "0"},
38:             {null, "2-MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
39:                     7.2f, FactoryMethodInvoker.instantiateMoney( 50.0f, EUR ),
40:                     FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
41:                     "0"},
42:             {null, "3-Gh-25", "Kompakter und leichter Akku für mobile Geräte",
43:                     null, FactoryMethodInvoker.instantiateMoney( 6.0f, EUR ),
44:                     FactoryMethodInvoker.instantiateMoney( 8.0f, EUR ),
45:                     "0"},
46:             {null, "4-MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
47:                     null, FactoryMethodInvoker.instantiateMoney( 0.6f, EUR ),
48:                     FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
49:                     "0"},
50:             {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
51:                     1.0f, FactoryMethodInvoker.instantiateMoney( 150.0f, EUR ),
52:                     FactoryMethodInvoker.instantiateMoney( 250.0f, EUR ),
53:                     "0"},
54:             {null, "6-Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
55:                     null, FactoryMethodInvoker.instantiateMoney( 0.3f, EUR ),
56:                     FactoryMethodInvoker.instantiateMoney( 0.5f, EUR ),
57:                     "0"},
58:             {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
59:                     6.0f, FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
60:                     FactoryMethodInvoker.instantiateMoney( 120.0f, EUR ),
61:                     "123"},
62:             {null, "8-JKL-67", "Wasserdichtes Gehäuse",
63:                     3.0f, FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
64:                     FactoryMethodInvoker.instantiateMoney( 1.2f, EUR ),
65:                     "467"},
66:             {null, "9-MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
67:                     5.5f, FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
68:                     FactoryMethodInvoker.instantiateMoney( 45.0f, EUR ),
69:                     "578"},
70:             {null, "10-PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
71:                     4.0f, FactoryMethodInvoker.instantiateMoney( 20.0f, EUR ),
72:                     FactoryMethodInvoker.instantiateMoney( 35.0f, EUR ),
73:                     "567"},
74:             {null, "11-STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
75:                     null, FactoryMethodInvoker.instantiateMoney( 200.0f, EUR ),
76:                     FactoryMethodInvoker.instantiateMoney( 350.0f, EUR ),
77:                     "478"},
78:             {null, "12-VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
79:                     null, FactoryMethodInvoker.instantiateMoney( 15.0f, EUR ),
80:                     FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
81:                     "5"},
82:             {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
83:                     3.5f, FactoryMethodInvoker.instantiateMoney( 60.0f, EUR ),
84:                     FactoryMethodInvoker.instantiateMoney( 100.0f, EUR ),
85:                     "78"},
86:             {null, "14-Nosedive", "Klammer zum Verschließen der Nase beim Tauchen",
87:                     5.0f, FactoryMethodInvoker.instantiateMoney( 2.0f, EUR ),
88:                     FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
89:                     "457"}
90:     };
91:     
92: 
93:     // These physical addresss are used for the distribution centers. The distribution center name will equal
94:     // the zip code of the site. Their index number will be visible in the house number.
95:     // The distribution centers are used as such:
96:     // - distribution center 0 is holds all items 0 - 6, and is used for all tests where multiple
97:     //   shipments are irrelevant.
98:     // - distribution centers 1 - 3 are used for the proximity tests, where you can deliver items 7 to
99:     //   to a client from the closest distribution center.
100:     // - distribution centers 4 - 8 are used for the tests where you need to deliver items 8 - 14 in
101:     //   the most cost-efficient way, as multiple shipments.
102:     // - distribution center 9 is empty.
103:     private final static int DISTRIBUTION_CENTER_NUMOF = 10;
104:     private final static PhysicalAddressType[] DISTRIBUTION_CENTER_PHYSICAL_ADDRESS = new PhysicalAddressType[]{
105:             FactoryMethodInvoker.instantiatePhysicalAddress(
106:                     "Stapelallee 0", "Potsdam",
107:                     FactoryMethodInvoker.instantiateZipCode( "14476" ) ),
108:             FactoryMethodInvoker.instantiatePhysicalAddress(
109:                     "Lagerhausstr. 1", "Viertelstadt",
110:                     FactoryMethodInvoker.instantiateZipCode( "02345" ) ),
111:             FactoryMethodInvoker.instantiatePhysicalAddress(
112:                     "Speicherplatz 2", "Viertelstadt",
113:                     FactoryMethodInvoker.instantiateZipCode( "02313" ) ),
114:             FactoryMethodInvoker.instantiatePhysicalAddress(
115:                     "Ablageweg 3", "Reichswürgen",
116:                     FactoryMethodInvoker.instantiateZipCode( "44923" ) ),
117:             FactoryMethodInvoker.instantiatePhysicalAddress(
118:                     "Paketstellenallee 4", "Düsseldorf",
119:                     FactoryMethodInvoker.instantiateZipCode( "40588" ) ),
120:             FactoryMethodInvoker.instantiatePhysicalAddress(
121:                     "Kaputte-Sachen-Straße 5", "Düren",
122:                     FactoryMethodInvoker.instantiateZipCode( "52355" ) ),
123:             FactoryMethodInvoker.instantiatePhysicalAddress(
124:                     "Aufbewahrungsweg 6", "Viernheim",
125:                     FactoryMethodInvoker.instantiateZipCode( "68519" ) ),
126:             FactoryMethodInvoker.instantiatePhysicalAddress(
127:                     "Paketallee 7", "Baden-Baden",
128:                     FactoryMethodInvoker.instantiateZipCode( "76532" ) ),
129:             FactoryMethodInvoker.instantiatePhysicalAddress(
130:                     "Sendenstr. 8", "Senden",
131:                     FactoryMethodInvoker.instantiateZipCode( "89250" ) ),
132:             FactoryMethodInvoker.instantiatePhysicalAddress(
133:                     "Schickweg 9", "Hohenroth",
134:                     FactoryMethodInvoker.instantiateZipCode( "97618" ) )
135:     };
136:     private final static UUID[] DISTRIBUTION_CENTER_ID = new UUID[DISTRIBUTION_CENTER_NUMOF];
137: 
138: 
139:     // These data structures contain the stock of the items in the distribution centers.
140:     // ITEM_STOCK is a map item name -> Integer[DISTRIBUTION_CENTER_NUMOF].
141:     // The Integer[DISTRIBUTION_CENTER_NUMOF] contains the stock of the item in each of
142:     // the distribution centers.
143:     //
144:     // The following rules apply:
145:     // - item 0 is out of stock
146:     // - item 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in distribution center 0
147:     // - item 4 / 5 / 6 have a random stock between 30 and 130, also all ONLY in distribution center 0
148:     //   (these are the items used for tests on how to add and remove stock)
149:     // - the others have a random stock between 30 and 130, distributed over several
150:     //   distribution centers. Here we follow this convention for simplicity:
151:     //   - Assume that the item is available in <n> distribution centers. Then the first <n-1> distribution centers
152:     //     in the list (in ascending sequence) contain 3, and all the remaining stock is in the
153:     //     last distribution center.
154: 
155:     private static final Map<String, Integer[]> ITEM_STOCK = new HashMap<>();
156: 
157:     static {
158:         // items 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
159:         ITEM_STOCK.put( (String) ITEM_DATA[0][1],
160:                 getStockDistribution( 0, (String) ITEM_DATA[0][6] ) );
161:         ITEM_STOCK.put( (String) ITEM_DATA[1][1],
162:                 getStockDistribution( 10, (String) ITEM_DATA[1][6] ) );
163:         ITEM_STOCK.put( (String) ITEM_DATA[2][1],
164:                 getStockDistribution( 20, (String) ITEM_DATA[2][6] ) );
165:         ITEM_STOCK.put( (String) ITEM_DATA[3][1],
166:                 getStockDistribution( 30, (String) ITEM_DATA[3][6] ) );
167: 
168:         // The other items have a random stock between 30 and 130,
169:         for ( int i = 4; i < ITEM_NUMOF; i++ ) {
170:             Integer totalNumber = random.nextInt( 100 ) + 30;
171:             Integer[] stockInDistributionCenters =
172:                     getStockDistribution( totalNumber, (String) ITEM_DATA[i][6] );
173:             ITEM_STOCK.put( (String) ITEM_DATA[i][1], stockInDistributionCenters );
174:         }
175:     }
176: 
177:     /**
178:      * This method creates a random stock distribution for the given item.
179:      *
180:      * @param totalQuantity - the total number of items in the distribution centers
181:      * @param zeroToNine  - a string with numbers between 0 and 9, representing the distribution centers
182:      * @return an Integer array with the stock distribution for the item, according to
183:      * the rules described above.
184:      */
185:     private static Integer[] getStockDistribution( Integer totalQuantity, String zeroToNine ) {
186:         Integer[] stockInDistributionCenters = new Integer[DISTRIBUTION_CENTER_NUMOF];
187:         for ( int i = 0; i < DISTRIBUTION_CENTER_NUMOF; i++ ) stockInDistributionCenters[i] = 0;
188:         TreeSet<Integer> distributionCenterIndices = getDistributionCenterIndices( zeroToNine );
189:         int numOfIndices = distributionCenterIndices.size();
190:         int currentIndexNumber = 0;
191:         int currentQuantity = totalQuantity;
192:         for ( Integer distributionCenterIndex : distributionCenterIndices ) {
193:             currentIndexNumber++;
194:             if ( currentIndexNumber < numOfIndices ) {
195:                 stockInDistributionCenters[distributionCenterIndex] = 3;
196:                 currentQuantity -= 3;
197:             } else {
198:                 stockInDistributionCenters[distributionCenterIndex] = currentQuantity;
199:             }
200:         }
201:         return stockInDistributionCenters;
202:     }
203: 
204:     private static TreeSet<Integer> getDistributionCenterIndices( String zeroToNine ) {
205:         TreeSet<Integer> distributionCenterIndices = new TreeSet<>();
206:         for ( int i = 0; i < zeroToNine.length(); i++ ) {
207:             distributionCenterIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
208:         }
209:         return distributionCenterIndices;
210:     }
211: 
212: 
213:     @Autowired
214:     public StockTestHelperImpl( ItemCatalogUseCases itemCatalogUseCases,
215:                                          DistributionCenterUseCases distributionCenterUseCases ) {
216:         this.itemCatalogUseCases = itemCatalogUseCases;
217:         this.distributionCenterUseCases = distributionCenterUseCases;
218:     }
219: 
220: 
221:     @Override
222:     public void addAllItems() {
223:         int i = 0;
224:         for ( Object[] itemData : ITEM_DATA ) {
225:             UUID newId = itemCatalogUseCases.addItemToCatalog(
226:                     (String) itemData[1], (String) itemData[2],
227:                     (Float) itemData[3], (MoneyType) itemData[4],
228:                     (MoneyType) itemData[5] );
229:             // The first element of the item data is the id, which was initialized with null before, but can now be set
230:             ITEM_DATA[i][0] = newId;
231:             i++;
232:         }
233:     }
234: 
235: 
236:     @Override
237:     public int numberOfItems() {
238:         return ITEM_NUMOF;
239:     }
240: 
241: 
242:     @Override
243:     public UUID getItemId( int index ) {
244:         if ( index < 0 || index >= ITEM_NUMOF ) {
245:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
246:         }
247:         return (UUID) ITEM_DATA[index][0];
248:     }
249: 
250: 
251:     @Override
252:     public MoneyType getBuyingPrice( int index ) {
253:         if ( index < 0 || index >= ITEM_NUMOF ) {
254:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
255:         }
256:         return (MoneyType) ITEM_DATA[index][4];
257:     }
258: 
259: 
260:     @Override
261:     public MoneyType getSalesPrice( int index ) {
262:         if ( index < 0 || index >= ITEM_NUMOF ) {
263:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
264:         }
265:         return (MoneyType) ITEM_DATA[index][5];
266:     }
267: 
268: 
269:     @Override
270:     public void addAllDistributionCenters( boolean withStock ) {
271:         for ( int i = 0; i < DISTRIBUTION_CENTER_NUMOF; i++ ) {
272:             DISTRIBUTION_CENTER_ID[i] = distributionCenterUseCases.addNewDistributionCenter(
273:                     DISTRIBUTION_CENTER_PHYSICAL_ADDRESS[i].getStreet(),
274:                     DISTRIBUTION_CENTER_PHYSICAL_ADDRESS[i] );
275:         }
276:         if ( withStock ) {
277:             addAllStock();
278:         }
279:     }
280: 
281: 
282:     private void addAllStock() {
283:         for ( Object[] itemData : ITEM_DATA ) {
284:             Integer[] stockInDistributionCenters =
285:                     ITEM_STOCK.get( itemData[1] );
286:             for ( int iDistributionCenter = 0; iDistributionCenter < DISTRIBUTION_CENTER_NUMOF; iDistributionCenter++ ) {
287:                 if ( stockInDistributionCenters[iDistributionCenter] > 0 )
288:                     distributionCenterUseCases.addToStock(
289:                             DISTRIBUTION_CENTER_ID[iDistributionCenter], (UUID) itemData[0],
290:                             stockInDistributionCenters[iDistributionCenter] );
291:             }
292:         }
293:     }
294: 
295: 
296:     @Override
297:     public int numberOfDistributionCenters() {
298:         return DISTRIBUTION_CENTER_NUMOF;
299:     }
300: 
301: 
302:     @Override
303:     public UUID getDistributionCenterId( int index ) {
304:         if ( index < 0 || index >= DISTRIBUTION_CENTER_NUMOF ) {
305:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
306:         }
307:         return DISTRIBUTION_CENTER_ID[index];
308:     }
309: 
310: 
311:     @Override
312:     public Integer getDistributionCenterStock( int distributionCenterIndex, int itemIndex ) {
313:         if ( distributionCenterIndex < 0 || distributionCenterIndex >= DISTRIBUTION_CENTER_NUMOF ) {
314:             throw new IndexOutOfBoundsException( "Index out of bounds: " + distributionCenterIndex );
315:         }
316:         if ( itemIndex < 0 || itemIndex >= ITEM_NUMOF ) {
317:             throw new IndexOutOfBoundsException( "Index out of bounds: " + itemIndex );
318:         }
319:         String itemName = (String) ITEM_DATA[itemIndex][1];
320:         Integer[] stockInDistributionCenters = ITEM_STOCK.get( itemName );
321:         Integer foundStock = stockInDistributionCenters[distributionCenterIndex];
322:         return foundStock == null ? 0 : foundStock;
323:     }
324: 
325: 
326:     @Override
327:     public int findDistributionCenterIndex( UUID distributionCenterId ) {
328:         for ( int i = 0; i < DISTRIBUTION_CENTER_NUMOF; i++ ) {
329:             if ( DISTRIBUTION_CENTER_ID[i].equals( distributionCenterId ) ) {
330:                 return i;
331:             }
332:         }
333:         throw new IllegalArgumentException( "No test distribution center with UUID id " + distributionCenterId );
334:     }
335: 
336: 
337:     @Override
338:     public int findItemIndex( UUID itemId ) {
339:         for ( int iItemData = 0; iItemData < DISTRIBUTION_CENTER_NUMOF; iItemData++ ) {
340:             Object[] itemData = ITEM_DATA[iItemData];
341:             if ( itemData[0].equals( itemId ) ) {
342:                 return iItemData;
343:             }
344:         }
345:         throw new IllegalArgumentException( "No test item with UUID id " + itemId );
346:     }
347: }
348: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ItemTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
4: 
5: import java.util.UUID;
6: 
7: public interface ItemTestHelper {
8:     /**
9:      * Adds all test items to the database.
10:      * If you use the debugger and want to identify _which_ test item you currently look at:
11:      * The indices are coded into the first number in the name string of the item, like e.g.
12:      * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
13:      */
14:     void addAllItems();
15: 
16: 
17:     /**
18:      * @return the number of test items in the database
19:      */
20:     int numberOfItems();
21: 
22: 
23:     /**
24:      * @param index
25:      * @return the id of the test item at the given index
26:      */
27:     UUID getItemId( int index );
28: 
29: 
30:     /**
31:      * @param itemId - the id of the item in the test data
32:      * @return the index of the test item with that id
33:      */
34:     int findItemIndex( UUID itemId );
35: 
36: 
37:     /**
38:      * @param index
39:      * @return the buying price of test item at the given index
40:      */
41:     MoneyType getBuyingPrice( int index );
42: 
43: 
44:     /**
45:      * @param index
46:      * @return the sales price of test item at the given index
47:      */
48:     MoneyType getSalesPrice( int index );
49: }
50: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockClient.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.Setter;
4: import thkoeln.archilab.ecommerce.usecases.ClientType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;
6: 
7: 
8: import java.util.Objects;
9: 
10: @Setter
11: public class MockClient implements ClientType {
12:     private String name;
13:     private EmailType emailType;
14:     private PhysicalAddressType physicalAddressType;
15: 
16: 
17:     public MockClient( String name, EmailType emailType, PhysicalAddressType physicalAddressType) {
18:         this.name = name;
19:         this.emailType = emailType;
20:         this.physicalAddressType = physicalAddressType;
21:     }
22: 
23:     @Override
24:     public String getName() {
25:         return name;
26:     }
27: 
28:     @Override
29:     public EmailType getEmail() {
30:         return emailType;
31:     }
32: 
33:     @Override
34:     public PhysicalAddressType getPhysicalAddress() {
35:         return physicalAddressType;
36:     }
37: 
38:     @Override
39:     public boolean equals( Object o ) {
40:         if ( this == o ) return true;
41:         if ( !( o instanceof MockClient ) ) return false;
42:         MockClient that = (MockClient) o;
43:         return Objects.equals( getName(), that.getName() ) &&
44:                 Objects.equals( emailType, that.emailType ) &&
45:                 Objects.equals( physicalAddressType, that.physicalAddressType );
46:     }
47: 
48:     @Override
49:     public int hashCode() {
50:         return Objects.hash( getName(), emailType, physicalAddressType );
51:     }
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.usecases.*;
6: 
7: /**
8:  * Removes everything :-)
9:  */
10: @Service
11: public class Purgatory {
12:     @Autowired
13:     private ClientRegistrationUseCases clientRegistrationUseCases;
14:     @Autowired
15:     private ShoppingBasketUseCases shoppingBasketUseCases;
16:     @Autowired
17:     private OrderUseCases orderUseCases;
18:     @Autowired
19:     private ItemCatalogUseCases itemCatalogUseCases;
20:     @Autowired
21:     private DistributionCenterUseCases distributionCenterUseCases;
22: 
23:     public void deleteEverything() {
24:         orderUseCases.deleteAllOrders();
25:         shoppingBasketUseCases.emptyAllShoppingBaskets();
26:         distributionCenterUseCases.deleteAllDistributionCenters();
27:         clientRegistrationUseCases.deleteAllClients();
28:         itemCatalogUseCases.deleteItemCatalog();
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.context.ApplicationListener;
6: import org.springframework.context.annotation.Profile;
7: import org.springframework.context.event.ContextRefreshedEvent;
8: import org.springframework.stereotype.Component;
9: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.DistributionCenterUseCases;
12: 
13: @Component
14: @Slf4j
15: @Profile("!test")
16: @SuppressWarnings("PMD")
17: public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
18:     private Purgatory purgatory;
19:     private ClientTestHelper clientTestHelper;
20:     private ItemTestHelper itemTestHelper;
21:     private DistributionCenterTestHelper distributionCenterTestHelper;
22: 
23: 
24:     @Autowired
25:     public StartupListener( Purgatory purgatory,
26:                             ClientTestHelper clientTestHelper,
27:                             ItemTestHelper itemTestHelper,
28:                             DistributionCenterTestHelper distributionCenterTestHelper ) {
29:         this.purgatory = purgatory;
30:         this.clientTestHelper = clientTestHelper;
31:         this.itemTestHelper = itemTestHelper;
32:         this.distributionCenterTestHelper = distributionCenterTestHelper;
33:     }
34: 
35:     @Override
36:     public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
37:         log.info( "StartupListener initializing master data ..." );
38:         purgatory.deleteEverything();
39:         clientTestHelper.registerAllClients();
40:         itemTestHelper.addAllItems();
41:         distributionCenterTestHelper.addAllDistributionCenters( true );
42:     }
43: }
44: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\OrderUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
3:  */
4: package thkoeln.archilab.ecommerce.usecases;
5: 
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
9: 
10: import java.util.Map;
11: import java.util.UUID;
12: 
13: /**
14:  * This interface contains methods needed in the context of the order history of a client.
15:  */
16: public interface OrderUseCases {
17: 
18:     /**
19:      * Returns a map showing which items have been ordered by a client and how many of each item
20:      *
21:      * @param clientEmail
22:      * @return the order history of the client (map is empty if the client has not ordered anything yet)
23:      * @throws ShopException if
24:      *      - clientEmail is null
25:      *      - the client with the given email does not exist
26:      */
27:     public Map<UUID, Integer> getOrderHistory( EmailType clientEmail );
28: 
29: 
30: 
31:     /**
32:      * @return the number of items in a given order. If the item is not a position of the order, the method
33:      *         returns 0. No exception is thrown.
34:      * @param orderId - the id of the order to be checked
35:      * @param itemId - the id of the item for which we want to know the quantity
36:      * @throws ShopException if
37:      *     - orderId is null, or doesn't exist in the system
38:      *     - itemId is null, or doesn't exist in the system
39:      */
40:     public Integer getOrderQuantForItem( UUID orderId, UUID itemId );
41: 
42: 
43:     /**
44:      * @return the id of the distribution center that is responsible for the given order
45:      * @param orderId - the id of the order to be checked
46:      * @throws ShopException if
47:      *      - orderId is null, or doesn't exist in the system
48:      */
49:     public UUID getDistributionCenterIdForOrder( UUID orderId );
50: 
51: 
52:     /**
53:      * Deletes all orders in the system
54:      */
55:     public void deleteAllOrders();
56: }
57: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingBasketUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
10: 
11: import java.util.Map;
12: import java.util.Set;
13: import java.util.UUID;
14: 
15: /**
16:  * This interface contains methods needed in the context of use cases handling the shopping basket.
17:  * The interface is probably incomplete, and will grow over time ...
18:  */
19: public interface ShoppingBasketUseCases {
20:     /**
21:      * Adds a item to the cart of a client
22:      *
23:      * @param clientEmail
24:      * @param itemId
25:      * @param quantFor
26:      * @throws ShopException if ...
27:      *          - clientEmail is null,
28:      *          - the client with the given email does not exist,
29:      *          - itemId is null,
30:      *          - the item with itemId does not exist
31:      *          - the Quantity is negative,
32:      */
33:     public void addItemToShoppingBasket( EmailType clientEmail,
34:                                                  UUID itemId, int quantFor );
35: 
36: 
37:     /**
38:      * Removes a item from the cart of a client
39:      *
40:      * @param clientEmail
41:      * @param itemId
42:      * @param quantFor
43:      * @throws ShopException if ...
44:      *          - clientEmail is null,
45:      *          - the client with the given email does not exist,
46:      *          - itemId is null,
47:      *          - the item with itemId does not exist
48:      *          - the Quantity is negative
49:      *          - the item is not in the shopping basket in the requested Quantity
50:      */
51:     public void removeItemFromShoppingBasket( EmailType clientEmail,
52:                                                       UUID itemId, int quantFor );
53: 
54: 
55:     /**
56:      * Returns a map showing which items are in the cart of a client and how many of each item
57:      *
58:      * @param clientEmail
59:      * @return the cart of the client (map is empty if the cart is empty)
60:      * @throws ShopException if
61:      *          - clientEmail is null,
62:      *          - the client with the given email does not exist
63:      */
64:     public Map<UUID, Integer> getShoppingBasketAsMap( EmailType clientEmail );
65: 
66: 
67:     /**
68:      * Returns the current value of all items in the cart of a client
69:      *
70:      * @param clientEmail
71:      * @return the cart of the client
72:      * @throws ShopException if
73:      *          - clientEmail is null,
74:      *          - the client with the given email does not exist
75:      */
76:     public MoneyType getShoppingBasketAsMoneyValue( EmailType clientEmail );
77: 
78: 
79: 
80: 
81:     /**
82:      * Checks out the cart of a client
83:      *
84:      * @param clientEmail
85:      * @return A set of ids belonging to orders that were created during the checkout. If the shopping basket can
86:      *         only be served from more than one distribution center, each shipment from a distribution center gets a
87:      *         dedicated order. I.e. if there is just one shipment, then the set will contain just one order id.
88:      *         If there are multiple shipments, the set will contain multiple order ids.
89:      * @throws ShopException if
90:      *      - clientEmail is null or empty
91:      *      - the client with the given email does not exist, or if the cart is empty
92:      * @throws
93:      *      - ShopException if clientEmail is null
94:      *      - InsufficientStockException if there is not enough stock level for to serve the order
95:      *        for all items in the shopping basket
96:      */
97:     public Set<UUID> checkout( EmailType clientEmail );
98: 
99: 
100:     /**
101:      * Empties all shopping baskets in the system
102:      */
103:     public void emptyAllShoppingBaskets();
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import org.springframework.boot.test.context.TestConfiguration;
4: import org.springframework.context.annotation.Bean;
5: import org.springframework.test.web.servlet.MockMvc;
6: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
7: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
8: 
9: 
10: @TestConfiguration
11: public class RESTTestHelperConfiguration {
12: 
13:     @Bean
14:     public ShoppingBasketRESTHelper shoppingBasketRESTHelper(
15:             MockMvc mockMvc, ItemCatalogUseCases itemCatalogUseCases ) {
16:         return new ShoppingBasketRESTHelperImpl( mockMvc, itemCatalogUseCases );
17:     }
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingBasketRESTHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import com.fasterxml.jackson.databind.ObjectMapper;
5: import lombok.AllArgsConstructor;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import lombok.Setter;
9: import lombok.extern.slf4j.Slf4j;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.MvcResult;
12: import org.springframework.test.web.servlet.ResultActions;
13: import org.springframework.test.web.servlet.ResultMatcher;
14: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
15: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
18: 
19: import java.util.Map;
20: import java.util.UUID;
21: 
22: import static org.springframework.http.MediaType.APPLICATION_JSON;
23: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
24: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
25: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
26: 
27: @Slf4j
28: public class ShoppingBasketRESTHelperImpl implements ShoppingBasketRESTHelper {
29:     private MockMvc mockMvc;
30:     private ItemCatalogUseCases itemCatalogUseCases;
31: 
32:     private static final ResultMatcher CREATED = status().isCreated();
33:     private static final ResultMatcher OK = status().isOk();
34: 
35:     public ShoppingBasketRESTHelperImpl( MockMvc mockMvc, ItemCatalogUseCases itemCatalogUseCases ) {
36:         this.mockMvc = mockMvc;
37:         this.itemCatalogUseCases = itemCatalogUseCases;
38:     }
39: 
40: 
41:     @Override
42:     public UUID getQueryShoppingBasket( EmailType email, Map<UUID, Integer> quantityMap )
43:             throws Exception {
44:         // first query the clients API to get the proper clientId
45:         UUID clientId;
46:         String clientUri = "/clients?email=" + email.toString();
47:         MvcResult clientGetResult = mockMvc.perform( get( clientUri ) )
48:                 .andExpect( status().isOk() )
49:                 .andReturn();
50:         ObjectMapper objectMapper = new ObjectMapper();
51:         IdDTO idDTO = objectMapper.readValue( clientGetResult.getResponse().getContentAsString(), IdDTO.class );
52:         clientId = idDTO.getId();
53: 
54:         // then query the shopping basket API and extract the shopping basket id
55:         String shoppingBasketUri = "/shoppingBaskets?clientId=" + clientId.toString();
56:         ResultActions resultActions = mockMvc.perform( get( shoppingBasketUri ) )
57:                 .andExpect( status().isOk() );
58:         idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
59:         UUID shoppingBasketId = idDTO.getId();
60: 
61:         // additional checks, if desired
62:         if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
63:         return shoppingBasketId;
64:     }
65: 
66: 
67:     private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
68:         if ( quantityMap == null ) return;
69:         int numOfItems = quantityMap.size();
70:         resultActions.andExpect( jsonPath( "$.positions.length()" ).value( numOfItems ) );
71:         float totalSalesPriceAsFloat = 0f;
72:         for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
73:             UUID itemId = entry.getKey();
74:             Integer quantity = entry.getValue();
75:             resultActions.andExpect( jsonPath( "$.positions.[?(@.itemId == '" + itemId + "')].quantity" )
76:                     .value( quantity ) );
77:             MoneyType salesPrice = itemCatalogUseCases.getSalesPrice( itemId );
78:             totalSalesPriceAsFloat += salesPrice.getAmount() * quantity;
79:         }
80:         // last thing - check the total sales price
81:         String totalSalesPriceString = String.format( "%.2f €", totalSalesPriceAsFloat );
82:         resultActions
83:                 .andExpect( jsonPath( "$.totalSalesPrice" ).value( totalSalesPriceString ) );
84:     }
85: 
86: 
87:     @Override
88:     public void addItemToShoppingBasket( UUID shoppingBasketId, UUID itemId, Integer quantity )
89:             throws Exception {
90:         addItemToShoppingBasket( shoppingBasketId, itemId, quantity, null );
91:     }
92: 
93: 
94:     @Override
95:     public void addItemToShoppingBasket( UUID shoppingBasketId, UUID itemId, Integer quantity,
96:                                                   ResultMatcher expectedStatus ) throws Exception {
97:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
98:         ObjectMapper objectMapper = new ObjectMapper();
99:         QuantityDTO dto = new QuantityDTO( itemId, quantity );
100:         String quantityJson = objectMapper.writeValueAsString( dto );
101:         mockMvc.perform( post( "/shoppingBaskets/" + shoppingBasketId + "/positions" )
102:                         .contentType( APPLICATION_JSON ).content( quantityJson ) )
103:                 .andExpect( status );
104:     }
105: 
106: 
107: 
108:     @Override
109:     public void deleteItemFromShoppingBasket( UUID shoppingBasketId, UUID itemId )
110:             throws Exception {
111:         deleteItemFromShoppingBasket( shoppingBasketId, itemId, null );
112:     }
113: 
114: 
115: 
116:     @Override
117:     public void deleteItemFromShoppingBasket( UUID shoppingBasketId, UUID itemId,
118:                                                       ResultMatcher expectedStatus ) throws Exception {
119:         ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
120:         String uri = "/shoppingBaskets/" + shoppingBasketId + "/positions/" + itemId;
121:         mockMvc.perform( delete( uri ) ).andExpect( status );
122:     }
123: 
124: 
125:     @Override
126:     public void checkout( UUID shoppingBasketId, String expectedClientName,
127:                           ResultMatcher expectedStatus,
128:                           Map<UUID, Map<UUID, Integer>> expectedOrders ) throws Exception {
129:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
130:         String uri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
131:         MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
132:         ObjectMapper objectMapper = new ObjectMapper();
133: 
134:         // check the response content
135:         if ( expectedOrders != null || expectedClientName != null ) {
136:             String responseContent = result.getResponse().getContentAsString();
137:             log.info( "ShoppingBasketRESTHelperImpl - checkout: found response content " + responseContent );
138:             OrderDTO[] orders = objectMapper.readValue( responseContent, OrderDTO[].class );
139:             checkExpectedClientName( expectedClientName, orders );
140:             checkExpectedOrders( expectedOrders, orders );
141:         }
142:     }
143: 
144: 
145:     private void checkExpectedClientName( String expectedClientName, OrderDTO[] orders ) {
146:         if ( expectedClientName == null ) return;
147:         for ( OrderDTO order : orders ) {
148:             if ( !order.getClientName().equals( expectedClientName ) ) {
149:                 throw new AssertionError( "Expected clientName '" + expectedClientName +
150:                         "' but got '" + order.getClientName() + "'" );
151:             }
152:         }
153:     }
154: 
155: 
156:     private void checkExpectedOrders( Map<UUID, Map<UUID, Integer>> expectedOrders,
157:                                             OrderDTO[] orders ) {
158:         if ( expectedOrders == null ) return;
159:         for ( OrderDTO order : orders ) {
160:             UUID distributionCenterId = order.getDistributionCenterId();
161:             Map<UUID, Integer> expectedQuantities = expectedOrders.get( distributionCenterId );
162:             if ( expectedQuantities == null ) {
163:                 throw new AssertionError( "No expected quantities for distribution center " + distributionCenterId );
164:             }
165:             QuantityDTO[] positions = order.getPositions();
166:             for ( QuantityDTO quantityDTO : positions ) {
167:                 UUID itemId = quantityDTO.getItemId();
168:                 Integer expectedQuantity = expectedQuantities.get( itemId );
169:                 if ( expectedQuantity == null ) {
170:                     throw new AssertionError( "No expected quantity for item " + itemId +
171:                             " in distribution center " + distributionCenterId );
172:                 }
173:                 if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
174:                     throw new AssertionError( "Expected quantity " + expectedQuantity + " for item " +
175:                             itemId + " in distribution center " + distributionCenterId +
176:                             ", but got " + quantityDTO.getQuantity() );
177:                 }
178:             }
179:         }
180:     }
181: 
182: 
183:     /**
184:      * A DTO containing just a quantity, used in testing.
185:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
186:      * Therefore, constructors and getters/setters are manually defined.
187:      */
188:     @NoArgsConstructor
189:     @JsonIgnoreProperties(ignoreUnknown = true)
190:     private static class QuantityDTO {
191:         private UUID itemId;
192:         private Integer quantity;
193: 
194:         public QuantityDTO( UUID itemId, Integer quantity ) {
195:             this.itemId = itemId;
196:             this.quantity = quantity;
197:         }
198:         public UUID getItemId() {
199:             return itemId;
200:         }
201:         public Integer getQuantity() {
202:             return quantity;
203:         }
204:         public void setItemId( UUID itemId ) {
205:             this.itemId = itemId;
206:         }
207:         public void setQuantity( Integer quantity ) {
208:             this.quantity = quantity;
209:         }
210:     }
211: 
212: 
213:     /**
214:      * A DTO containing just the id of an entity, used in testing.
215:      */
216:     @AllArgsConstructor
217:     @NoArgsConstructor
218:     @Getter
219:     @Setter
220:     @JsonIgnoreProperties(ignoreUnknown = true)
221:     private static class IdDTO {
222:         private UUID id;
223:     }
224: 
225: 
226:     /**
227:      * A DTO containing the order data, used in testing.
228:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
229:      * Therefore, constructors and getters/setters are manually defined.
230:      */
231:     @NoArgsConstructor
232:     @JsonIgnoreProperties(ignoreUnknown = true)
233:     private static class OrderDTO {
234:         private UUID id;
235:         private String clientName;
236:         private UUID distributionCenterId;
237:         private QuantityDTO[] positions;
238: 
239:         public UUID getId() {
240:             return id;
241:         }
242:         public String getClientName() {
243:             return clientName;
244:         }
245:         public UUID getDistributionCenterId() {
246:             return distributionCenterId;
247:         }
248:         public QuantityDTO[] getPositions() {
249:             return positions;
250:         }
251:         public void setId( UUID id ) {
252:             this.id = id;
253:         }
254:         public void setClientName( String clientName ) {
255:             this.clientName = clientName;
256:         }
257:         public void setDistributionCenterId( UUID distributionCenterId ) {
258:             this.distributionCenterId = distributionCenterId;
259:         }
260:         public void setPositions( QuantityDTO[] positions ) {
261:             this.positions = positions;
262:         }
263:     }
264: 
265: }
266: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingBasketRESTHelper.java ---
1: package thkoeln.archilab.ecommerce.helpers;
2: 
3: import org.springframework.test.web.servlet.ResultMatcher;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
5: 
6: import java.util.Map;
7: import java.util.UUID;
8: 
9: /**
10:  * A REST helper for shopping basket-related operations.
11:  * This interface defines methods to interact with a shopping basket via REST calls, such as querying, adding,
12:  * deleting, and checking out.
13:  */
14: public interface ShoppingBasketRESTHelper {
15:     /**
16:      * Executes a REST GET query on a shopping basket and returns its id, with the client's email as a
17:      * starting point. The resulting shopping basket is checked against the given expected quantity map.
18:      * @param email The email of the client whose shopping basket is queried.
19:      * @param expectedQuantityMap A map of items and their quantities in the shopping basket. (If null, then don't check.)
20:      * @return The id of the client's shopping basket.
21:      * @throws Exception (whenever the REST call fails, or the shopping basket does not match the expected quantity map)
22:      */
23:     public UUID getQueryShoppingBasket( EmailType email,
24:                                        Map<UUID, Integer> expectedQuantityMap ) throws Exception;
25: 
26: 
27:     /**
28:      * Adds a item to a shopping basket via a REST call.
29:      * @param shoppingBasketId Id of the shopping basket.
30:      * @param itemId Id of the item.
31:      * @param quantity Quantity of the item.
32:      * @throws Exception (whenever the REST call fails)
33:      */
34:     public void addItemToShoppingBasket( UUID shoppingBasketId, UUID itemId, Integer quantity )
35:             throws Exception;
36: 
37: 
38:     /**
39:      * Adds a item to a shopping basket via a REST call.
40:      * @param shoppingBasketId Id of the shopping basket.
41:      * @param itemId Id of the item.
42:      * @param quantity Quantity of the item.
43:      * @param expectedStatus expected status of the operation (null = CREATED)
44:      * @throws Exception (whenever the REST call fails or the status does not match)
45:      */
46:     public void addItemToShoppingBasket( UUID shoppingBasketId, UUID itemId, Integer quantity,
47:                                                   ResultMatcher expectedStatus ) throws Exception;
48: 
49: 
50:     /**
51:      * Deletes a item from a shopping basket via a REST call.
52:      * @param shoppingBasketId Id of the shopping basket.
53:      * @param itemId Id of the item.
54:      * @throws Exception (whenever the REST call fails)
55:      */
56:     public void deleteItemFromShoppingBasket( UUID shoppingBasketId, UUID itemId )
57:             throws Exception;
58: 
59: 
60:     /**
61:      * Deletes a item from a shopping basket via a REST call.
62:      * @param shoppingBasketId Id of the shopping basket.
63:      * @param itemId Id of the item.
64:      * @param expectedStatus expected status of the operation (null = OK)
65:      * @throws Exception (whenever the REST call fails or the status does not match)
66:      */
67:     public void deleteItemFromShoppingBasket( UUID shoppingBasketId, UUID itemId,
68:                                                       ResultMatcher expectedStatus ) throws Exception;
69: 
70: 
71:     /**
72:      * Checks out a shopping basket via REST call, and returns the id of the created order.
73:      * @param shoppingBasketId
74:      * @param expectedClientName expected name of the client who owns the shopping basket (null = don't check)
75:      * @param expectedStatus expected status of the operation (null = don't check)
76:      * @param expectedOrders the expected orders to be created as a result of the checkout. This is
77:      *                            a map of the following form:
78:      *                            <pre>
79:      *                               distributionCenterId -> Map<itemId,Integer>
80:      *                            </pre>
81:      *                            where the inner map contains the items and their quantities
82:      * @return
83:      * @throws Exception
84:      */
85:     public void checkout( UUID shoppingBasketId, String expectedClientName,
86:                           ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedOrders )
87:            throws Exception;
88: }
89: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\client\ClientRegistrationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.client;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
12: import thkoeln.archilab.ecommerce.usecases.ClientType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
15: 
16: import static org.junit.jupiter.api.Assertions.*;
17: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
18: 
19: 
20: @SpringBootTest
21: public class ClientRegistrationTest {
22:     @Autowired
23:     private ClientRegistrationUseCases clientRegistrationUseCases;
24:     @Autowired
25:     private Purgatory purgatory;
26:     @Autowired
27:     private ClientTestHelper clientTestHelper;
28: 
29:     private EmailType nonExistingEmail;
30:     private PhysicalAddressType somePhysicalAddress;
31: 
32:     @BeforeEach
33:     public void setUp() {
34:         purgatory.deleteEverything();
35:         nonExistingEmail = instantiateEmail( "this@nononono.de" );
36:         somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
37:                 instantiateZipCode( "90001" ) );
38:     }
39: 
40:     @Test
41:     public void testAllClientsRegistered() {
42:         // given
43:         clientTestHelper.registerAllClients();
44:         EmailType email3 =
45:                 clientTestHelper.getClientEmail( 3 );
46:         String name3 = clientTestHelper.getClientName( 3 );
47:         PhysicalAddressType physicalAddress3 = clientTestHelper.getClientPhysicalAddress( 3 );
48: 
49:         // when
50:         ClientType client3 = clientRegistrationUseCases.getClientData(
51:                 email3 );
52: 
53:         // then
54:         Assertions.assertEquals( name3, client3.getName() );
55:         Assertions.assertEquals( email3, client3.getEmail() );
56:         Assertions.assertEquals( physicalAddress3, client3.getPhysicalAddress() );
57:     }
58: 
59: 
60:     @Test
61:     public void testRegisterClientWithDuplicateEmail() {
62:         // given
63:         clientTestHelper.registerAllClients();
64:         PhysicalAddressType physicalAddress5 = clientTestHelper.getClientPhysicalAddress( 5 );
65:         EmailType email5 =
66:                 clientTestHelper.getClientEmail( 5 );
67: 
68:         // when
69:         // then
70:         assertThrows( ShopException.class, () ->
71:                 clientRegistrationUseCases.register( "Gandalf The Grey",
72:                         email5, physicalAddress5 ) );
73:     }
74: 
75: 
76:     @Test
77:     public void testRegisterClientWithDuplicateNameOrPhysicalAddress() {
78:         // given
79:         clientTestHelper.registerAllClients();
80:         EmailType newEmail =
81:                 instantiateEmail( "some@this.de" );
82:         PhysicalAddressType physicalAddress2 = clientTestHelper.getClientPhysicalAddress( 2 );
83:         String name2 = clientTestHelper.getClientName( 2 );
84: 
85:         // when
86:         // then
87:         assertDoesNotThrow( () ->
88:                 clientRegistrationUseCases.register( name2, newEmail, physicalAddress2 ) );
89:     }
90: 
91: 
92:     @Test
93:     public void testRegisterClientWithInvalidData() {
94:         // given
95:         EmailType email5 =
96:                 clientTestHelper.getClientEmail( 5 );
97:         PhysicalAddressType physicalAddress5 = clientTestHelper.getClientPhysicalAddress( 5 );
98:         String name5 = clientTestHelper.getClientName( 5 );
99: 
100:         // when
101:         // then
102:         assertThrows( ShopException.class, () ->
103:                 clientRegistrationUseCases.register( null, email5, physicalAddress5 ) );
104:         assertThrows( ShopException.class, () ->
105:                 clientRegistrationUseCases.register("", email5, physicalAddress5 ) );
106:         assertThrows( ShopException.class, () ->
107:                 clientRegistrationUseCases.register( name5, null, physicalAddress5 ) );
108:         assertThrows( ShopException.class, () ->
109:                 clientRegistrationUseCases.register( name5, email5, null ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testChangeAddressWithInvalidData() {
115:         // given
116:         clientTestHelper.registerAllClients();
117:         PhysicalAddressType physicalAddress7 = clientTestHelper.getClientPhysicalAddress( 7 );
118:         EmailType email7 =
119:                 clientTestHelper.getClientEmail( 7 );
120: 
121:         // when
122:         // then
123:         assertThrows( ShopException.class, () ->
124:                 clientRegistrationUseCases.changeAddress( nonExistingEmail, physicalAddress7 ) );
125:         assertThrows( ShopException.class, () ->
126:                 clientRegistrationUseCases.changeAddress( null, physicalAddress7 ) );
127:         assertThrows( ShopException.class, () ->
128:                 clientRegistrationUseCases.changeAddress( email7, null ) );
129:     }
130: 
131: 
132:     @Test
133:     public void testGetDataForNonexistingEmail() {
134:         // given
135:         clientTestHelper.registerAllClients();
136: 
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 clientRegistrationUseCases.getClientData( nonExistingEmail ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testDeleteClientsNoMoreClients() {
146:         // given
147:         clientTestHelper.registerAllClients();
148:         EmailType email0 =
149:                 clientTestHelper.getClientEmail( 0 );
150: 
151: 
152:         // when
153:         clientRegistrationUseCases.deleteAllClients();
154: 
155:         // then
156:         assertThrows( ShopException.class, () -> clientRegistrationUseCases.getClientData(
157:                 email0 ) );
158:     }
159: 
160: 
161:     @Test
162:     public void testChangeAddressSuccessful() {
163:         // given
164:         clientTestHelper.registerAllClients();
165:         EmailType email6 =
166:                 clientTestHelper.getClientEmail( 6 );
167: 
168:         // when
169:         clientRegistrationUseCases.changeAddress( email6, somePhysicalAddress );
170:         ClientType newClient6 =
171:                 clientRegistrationUseCases.getClientData( email6 );
172: 
173:         // then
174:         Assertions.assertEquals( email6, newClient6.getEmail() );
175:         Assertions.assertEquals( somePhysicalAddress, newClient6.getPhysicalAddress() );
176:     }
177: 
178: 
179:     @Test
180:     public void testChangeAddressForNonexistingEmail() {
181:         // given
182:         clientTestHelper.registerAllClients();
183: 
184:         // when
185:         // then
186:         assertThrows( ShopException.class, () ->
187:                 clientRegistrationUseCases.changeAddress( nonExistingEmail, somePhysicalAddress ) );
188:     }
189: 
190: 
191: }
192: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\client\ClientRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.client;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
12: import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
13: import thkoeln.archilab.ecommerce.usecases.ClientType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
16: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
17: 
18: import java.util.UUID;
19: 
20: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
21: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
22: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
23: 
24: @SpringBootTest
25: @Transactional
26: @AutoConfigureMockMvc
27: @Import( RESTTestHelperConfiguration.class )
28: public class ClientRESTTest {
29:     @Autowired
30:     private ClientRegistrationUseCases clientRegistrationUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private ClientTestHelper clientTestHelper;
35:     @Autowired
36:     private MockMvc mockMvc;
37: 
38:     private UUID randomId;
39:     private EmailType nonExistingEmail;
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         clientTestHelper.registerAllClients();
45: 
46:         nonExistingEmail = FactoryMethodInvoker.instantiateEmail(
47:                 "harry@sally.de" );
48:         randomId = UUID.randomUUID();
49:     }
50: 
51: 
52:     @Test
53:     public void testInvalidClientUris() throws Exception {
54:         // given
55:         String allClientsUri = "/clients";
56:         String randomIdUri = "/clients/" +  randomId;
57:         String nonExistingEmailUri = "/clients?email=" + nonExistingEmail;
58:         String randomParamUri = "/clients?randomParam=randomValue";
59: 
60:         // when
61:         // then
62:         mockMvc.perform( get( allClientsUri ) ).andExpect( status().isMethodNotAllowed() );
63:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
64:         mockMvc.perform( get( nonExistingEmailUri ) ).andExpect( status().isNotFound() );
65:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
66:     }
67: 
68: 
69:     @Test
70:     public void testRandomClientId() throws Exception {
71:         // given
72:         String invalidUri = "/clients/" +  randomId;
73: 
74:         // when
75:         // then
76:         mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
77:     }
78: 
79: 
80:     @Test
81:     public void testQueryClient() throws Exception {
82:         // given
83:         EmailType email4 =
84:                 clientTestHelper.getClientEmail( 4 );
85:         String clientUri4 = "/clients?email=" + email4;
86: 
87:         // when
88:         ClientType client4 = clientRegistrationUseCases.getClientData( email4 );
89:         String name = clientTestHelper.getClientName( 4 );
90:         PhysicalAddressType physicalAddress4 = clientTestHelper.getClientPhysicalAddress( 4 );
91: 
92:         // then (check using JSONPath)
93:         mockMvc.perform( get( clientUri4 ) )
94:                 .andExpect( status().isOk() )
95:                 .andExpect( jsonPath( "$.name" ).value( name ) )
96:                 // id is position 0 (cannot be tested with current API structure), name is position 1,
97:                 // email is 2, physical address is 3)
98:                 .andExpect( jsonPath( "$..emailString" ).value( email4.toString() ) )
99:                 .andExpect( jsonPath( "$..city" ).value( physicalAddress4.getCity() ) )
100:                 .andExpect( jsonPath( "$..zipCodeString" ).value(
101:                         physicalAddress4.getZipCode().toString() ) );
102:     }
103: 
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class BasicNoOutsideSolutionRulesTest {
14: 
15:     @ArchTest
16:     static final ArchRule noClassesOnTopLevel =
17:             classes().should().resideInAPackage( "..solution.*.." )
18:                     .allowEmptyShould( true );
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.library.Architectures.layeredArchitecture;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln")
12: @SuppressWarnings("PMD")
13: public class BasicProperDependenciesTest {
14: 
15:     @ArchTest
16:     static final ArchRule properDependencies =
17:             layeredArchitecture()
18:                     .consideringAllDependencies()
19:                     //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
20:                     .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
21:                     .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )
22: 
23:                     //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
24:                     .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
25:                     .allowEmptyShould( true );
26: }
27: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
5: import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
6: import org.springframework.core.type.classreading.MetadataReader;
7: import org.springframework.core.type.classreading.MetadataReaderFactory;
8: 
9: import java.io.IOException;
10: import java.util.Arrays;
11: import java.util.HashSet;
12: import java.util.Set;
13: 
14: import static org.junit.jupiter.api.Assertions.assertTrue;
15: 
16: public class BasicRequiredClassesTest {
17:     private static final String[] REQUIRED_CLASSES = {
18:             "Client",
19:             "ClientRepository",
20:             "Item",
21:             "ItemRepository",
22:             "Order",
23:             "OrderRepository",
24:             "StockLevel",
25:             "ShoppingBasket",
26:             "ShoppingBasketRepository",
27:             "DistributionCenterRepository",
28:             "ShoppingBasketPosition",
29:             "OrderPosition",
30:             "DistributionCenter",
31:     };
32: 
33:     @Test
34:     public void testRequiredClassesDeclared() throws IOException {
35:         String basePackage = "thkoeln.archilab.ecommerce";
36:         String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";
37: 
38:         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
39:         MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );
40: 
41:         Set<String> foundClasses = new HashSet<>();
42: 
43:         Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
44:             try {
45:                 MetadataReader reader = readerFactory.getMetadataReader( resource );
46:                 foundClasses.add( reader.getClassMetadata().getClassName() );
47:             } catch (IOException e) {
48:                 e.printStackTrace();
49:             }
50:         } );
51: 
52:         Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
53:             boolean found = foundClasses.stream().anyMatch(className ->
54:                     className.startsWith(basePackage) && className.endsWith("." + requiredClass)
55:             );
56:             assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
57:         });
58:     }
59: }
60: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.boot.test.context.SpringBootTest;
6: import org.springframework.context.ApplicationContext;
7: 
8: import java.util.Arrays;
9: import java.util.HashMap;
10: import java.util.List;
11: import java.util.Map;
12: 
13: import static org.junit.jupiter.api.Assertions.*;
14: 
15: @SpringBootTest
16: public class BasicUseCaseImplementationPackageTest {
17: 
18:     @Autowired
19:     private ApplicationContext applicationContext;
20: 
21:     private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
22:         put("ClientRegistrationUseCases", Arrays.asList("client"));
23:         put("DistributionCenterUseCases", Arrays.asList("distributioncenter"));
24:         put("ItemCatalogUseCases", Arrays.asList("item"));
25:         put("ShoppingBasketUseCases", Arrays.asList("shoppingbasket"));
26:         put("OrderUseCases", Arrays.asList("order"));
27:     }};
28:     private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
29:     private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";
30: 
31:     @Test
32:     public void testRequiredClassesDeclared() {
33:         for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
34:             String interfaceName = USECASE_PATH + "." + entry.getKey();
35:             List<String> correctTopLevelPackages = entry.getValue();
36:             Class<?> useCaseInterfaceClass = null;
37:             try {
38:                 useCaseInterfaceClass = Class.forName( interfaceName );
39:             } catch (ClassNotFoundException e) {
40:                 fail( "Use case interface " + interfaceName + " not found.", e );
41:                 continue;
42:             }
43:             String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
44:             assertEquals( 1, beans.length,
45:                     "There should be exactly 1 service implementation for the interface " +
46:                             entry.getKey() + ", but found " + beans.length );
47:             Object bean = applicationContext.getBean( beans[0] );
48:             boolean isValid = false;
49:             for ( String correctTopLevelPackage : correctTopLevelPackages ) {
50:                 String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
51:                 if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
52:                     isValid = true;
53:                     break;
54:                 }
55:             }
56:             assertTrue( isValid,
57:                     "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
58:                             + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
59:         }
60:     }
61: }
62: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: import org.springframework.data.repository.CrudRepository;
8: import org.springframework.stereotype.Service;
9: 
10: import jakarta.persistence.Entity;
11: import org.springframework.web.bind.annotation.RestController;
12: 
13: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
14: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
15: 
16: @ArchTag("layerRules")
17: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
18: @SuppressWarnings("PMD")
19: public class DDDRulesTest {
20: 
21:     @ArchTest
22:     static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
23:             noClasses().that().resideInAPackage( "..domain.." )
24:                     .should().dependOnClassesThat().resideInAPackage( "..application.." )
25:                     .allowEmptyShould( true );
26: 
27:     @ArchTest
28:     static final ArchRule entitiesMustResideInADomainPackage =
29:             classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
30:                     .as( "Entities must reside in a package '..domain..'" )
31:                     .allowEmptyShould( true );
32: 
33:     @ArchTest
34:     static final ArchRule entitiesMustNotAccessRepositories =
35:             noClasses().that().areAnnotatedWith( Entity.class )
36:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
37:                     .allowEmptyShould( true );
38: 
39:     @ArchTest
40:     static final ArchRule repositoriesMustResideInADomainPackage =
41:             classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
42:                     .as( "Repositories must reside in a package '..domain..'" )
43:                     .allowEmptyShould( true );
44: 
45:     @ArchTest
46:     static final ArchRule repositoryNamesMustHaveProperSuffix =
47:             classes().that().areAssignableTo( CrudRepository.class )
48:                     .should().haveSimpleNameEndingWith( "Repository" )
49:                     .allowEmptyShould( true );
50: 
51:     @ArchTest
52:     static final ArchRule servicesMustResideInAnApplicationPackage =
53:             classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
54:                     .as( "Application Services must reside in a package '..application..'" )
55:                     .allowEmptyShould( true );
56: 
57:     @ArchTest
58:     static final ArchRule serviceNamesMustHaveProperSuffix =
59:             classes().that().areAnnotatedWith( Service.class )
60:                     .should().haveSimpleNameEndingWith( "Service" )
61:                     .allowEmptyShould( true );
62: 
63:     @ArchTest
64:     static final ArchRule controllersMustResideInAnApplicationPackage =
65:             classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
66:                     .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );
67: 
68:     @ArchTest
69:     static final ArchRule controllersNamesMustHaveProperSuffix =
70:             classes().that().areAnnotatedWith( RestController.class )
71:                     .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );
72: 
73:     @ArchTest
74:     static final ArchRule controllersMustNotAccessRepositories =
75:             noClasses().that().areAnnotatedWith( RestController.class )
76:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
77:                     .allowEmptyShould( false );
78: }
79: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.importer.ClassFileImporter;
6: import com.tngtech.archunit.lang.ArchRule;
7: import com.tngtech.archunit.library.dependencies.SliceAssignment;
8: import com.tngtech.archunit.library.dependencies.SliceIdentifier;
9: import org.junit.jupiter.api.Test;
10: 
11: import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
12: 
13: public class NoCycleTest {
14:     private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");
15: 
16:     private SliceAssignment inAllClasses() {
17:         return new SliceAssignment() {
18:             @Override
19:             public String getDescription() {
20:                 return "every class in it's own slice";
21:             }
22: 
23:             @Override
24:             public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
25:                 return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
26:             }
27:         };
28:     }
29: 
30:     @Test
31:     public void testNoCyclicDependenciesBetweenClasses() {
32:         slices().assignedFrom(inAllClasses())
33:                 .namingSlices("$1[$2.$3]")
34:                 .should().beFreeOfCycles()
35:                 .check(importedClasses);
36:     }
37: 
38:     @Test
39:     public void testNoCyclicDependenciesBetweenPackages() {
40:         ArchRule rule = slices().matching("..solution.(*)..")
41:                 .should().beFreeOfCycles().allowEmptyShould( true );
42:         rule.check(importedClasses);
43:     }
44: }
45: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.base.DescribedPredicate;
4: import com.tngtech.archunit.core.domain.JavaClass;
5: import com.tngtech.archunit.core.domain.JavaField;
6: import com.tngtech.archunit.core.domain.JavaParameterizedType;
7: import com.tngtech.archunit.core.domain.JavaType;
8: import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
9: import com.tngtech.archunit.junit.AnalyzeClasses;
10: import com.tngtech.archunit.junit.ArchTag;
11: import com.tngtech.archunit.junit.ArchTest;
12: import com.tngtech.archunit.lang.ArchCondition;
13: import com.tngtech.archunit.lang.ArchRule;
14: import com.tngtech.archunit.lang.ConditionEvents;
15: import com.tngtech.archunit.lang.SimpleConditionEvent;
16: import jakarta.persistence.*;
17: import lombok.extern.slf4j.Slf4j;
18: import thkoeln.archilab.ecommerce.GenericId;
19: 
20: import java.util.List;
21: 
22: import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
23: import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
24: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;
25: 
26: @ArchTag("layerRules")
27: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
28: @SuppressWarnings("PMD")
29: @Slf4j
30: public class OnlyReferenceViaIDTest { //DISTRIBUTION_CENTER
31:     private static final String SHOPPING_BASKET_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingbasket.domain";
32:     private static final String CLIENT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.client.domain";
33:     private static final String ITEM_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.item.domain";
34:     private static final String ORDER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.order.domain";
35:     private static final String DISTRIBUTION_CENTER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.distributioncenter.domain";
36: 
37:     @ArchTest
38:     static final ArchRule idFieldsMustUseGenericId =
39:             fields()
40:                     .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
41:                     .and().areAnnotatedWith( Id.class )
42:                     .should().haveRawType( assignableTo( GenericId.class ) )
43:                     .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
44:                     .allowEmptyShould( true );
45: 
46: 
47:     private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
48:             annotatedWith( ManyToOne.class )
49:                     .or( annotatedWith( OneToOne.class ) )
50:                     .or( annotatedWith( Embedded.class ) )
51:                     .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );
52: 
53:     private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
54:             annotatedWith( OneToMany.class )
55:                     .or( annotatedWith( ManyToMany.class ) )
56:                     .or( annotatedWith( ElementCollection.class ) )
57:                     .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );
58: 
59: 
60:     private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
61:         String description = "an entity or value object from same aggregate, or a domain primitive";
62:         return new DescribedPredicate<>( description ) {
63:             @Override
64:             public boolean test( JavaClass type ) {
65:                 // check if the class is an entity or value object, and resides in the allowed package
66:                 if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
67:                     return false;
68:                 }
69:                 // a GenericId is always allowed
70:                 if ( type.isAssignableTo( GenericId.class ) ) {
71:                     return true;
72:                 }
73:                 // a domain primitive is also always allowed
74:                 if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
75:                     return true;
76:                 }
77:                 return type.getPackageName().startsWith( allowedPackage );
78:             }
79:         };
80:     }
81: 
82: 
83:     @ArchTest
84:     static final ArchRule shoppingBasketToOneReferences =
85:             fields()
86:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
87:                     .and( isToOneAnnotation )
88:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) ) )
89:                     .allowEmptyShould( true );
90: 
91:     @ArchTest
92:     static final ArchRule clientToOneReferences =
93:             fields()
94:                     .that().areDeclaredInClassesThat().resideInAPackage( CLIENT_DOMAIN_PACKAGE )
95:                     .and( isToOneAnnotation )
96:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( CLIENT_DOMAIN_PACKAGE ) ) )
97:                     .allowEmptyShould( true );
98: 
99:     @ArchTest
100:     static final ArchRule itemToOneReferences =
101:             fields()
102:                     .that().areDeclaredInClassesThat().resideInAPackage( ITEM_DOMAIN_PACKAGE )
103:                     .and( isToOneAnnotation )
104:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( ITEM_DOMAIN_PACKAGE ) ) )
105:                     .allowEmptyShould( true );
106: 
107:     @ArchTest
108:     static final ArchRule orderToOneReferences =
109:             fields()
110:                     .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
111:                     .and( isToOneAnnotation )
112:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) ) )
113:                     .allowEmptyShould( true );
114: 
115:     @ArchTest
116:     static final ArchRule distributionCenterToOneReferences =
117:             fields()
118:                     .that().areDeclaredInClassesThat().resideInAPackage( DISTRIBUTION_CENTER_DOMAIN_PACKAGE )
119:                     .and( isToOneAnnotation )
120:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( DISTRIBUTION_CENTER_DOMAIN_PACKAGE ) ) )
121:                     .allowEmptyShould( true );
122: 
123: 
124:     private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
125:         return new ArchCondition<JavaField>(
126:                 "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
127:             @Override
128:             public void check( JavaField field, ConditionEvents events ) {
129:                 JavaClass rawType = field.getRawType();
130:                 String rawTypeName = rawType.getFullName();
131:                 if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
132:                     events.add( SimpleConditionEvent.violated( field,
133:                             field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
134:                     return;
135:                 }
136:                 JavaType fieldType = field.getType();
137:                 if ( !( fieldType instanceof JavaParameterizedType ) ) {
138:                     events.add( SimpleConditionEvent.violated( field,
139:                             field.getFullName() + " is a raw List/Set without a type argument" ) );
140:                     return;
141:                 }
142:                 List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
143:                 if ( typeArguments.isEmpty() ) {
144:                     events.add( SimpleConditionEvent.violated( field,
145:                             field.getFullName() + " has no type arguments" ) );
146:                     return;
147:                 }
148:                 JavaType elementType = typeArguments.get( 0 );
149:                 if ( !( elementType instanceof JavaClass ) ) {
150:                     events.add( SimpleConditionEvent.violated( field,
151:                             field.getFullName() + " has an unknown element type" ) );
152:                     return;
153:                 }
154:                 JavaClass elementClass = (JavaClass) elementType;
155:                 boolean hasAnnotation =
156:                         elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
157:                 boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
158:                 boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
159:                 boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
160:                 boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
161:                 if ( !ok ) {
162:                     events.add( SimpleConditionEvent.violated( field,
163:                             field.getFullName() + " refers to " + elementClass.getFullName()
164:                                     + " which is not a DP, or an entity/value object in " + allowedPackage ) );
165:                 }
166:             }
167:         };
168:     }
169: 
170: 
171:     @ArchTest
172:     static final ArchRule shoppingBasketToManyReferences =
173:             fields()
174:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
175:                     .and( isToManyAnnotation )
176:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) )
177:                     .allowEmptyShould( true );
178: 
179:     @ArchTest
180:     static final ArchRule clientToManyReferences =
181:             fields()
182:                     .that().areDeclaredInClassesThat().resideInAPackage( CLIENT_DOMAIN_PACKAGE )
183:                     .and( isToManyAnnotation )
184:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( CLIENT_DOMAIN_PACKAGE ) )
185:                     .allowEmptyShould( true );
186: 
187:     @ArchTest
188:     static final ArchRule itemToManyReferences =
189:             fields()
190:                     .that().areDeclaredInClassesThat().resideInAPackage( ITEM_DOMAIN_PACKAGE )
191:                     .and( isToManyAnnotation )
192:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( ITEM_DOMAIN_PACKAGE ) )
193:                     .allowEmptyShould( true );
194: 
195:     @ArchTest
196:     static final ArchRule orderToManyReferences =
197:             fields()
198:                     .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
199:                     .and( isToManyAnnotation )
200:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) )
201:                     .allowEmptyShould( true );
202: 
203:     @ArchTest
204:     static final ArchRule distributionCenterToManyReferences =
205:             fields()
206:                     .that().areDeclaredInClassesThat().resideInAPackage( DISTRIBUTION_CENTER_DOMAIN_PACKAGE )
207:                     .and( isToManyAnnotation )
208:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( DISTRIBUTION_CENTER_DOMAIN_PACKAGE ) )
209:                     .allowEmptyShould( true );
210: 
211: }
212: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: /**
4:  * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
5:  */
6: 
7: public class OwnTestsTest {
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClasses;
4: import com.tngtech.archunit.core.importer.ClassFileImporter;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: 
8: import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
9: 
10: public class PackageStructureTest {
11: 
12:     private static final String[] REQUIRED_PACKAGES = {"client", "shoppingbasket", "item", "order", "distributioncenter"};
13:     private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
14:     private JavaClasses importedClasses;
15: 
16: 
17:     @BeforeEach
18:     public void setUp() {
19:         importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
20:     }
21: 
22:     @Test
23:     void testRequiredPackagesAreThere() {
24:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
25:             String packageName = BASE_PACKAGE + "." + requiredPackage;
26:             assertThat( importedClasses.containPackage( packageName ) )
27:                     .as( "Expected package %s not found!", packageName )
28:                     .isTrue();
29:         }
30:     }
31: 
32:     @Test
33:     void testRequiredDomainPackagesAreThere() {
34:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
35:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
36:             assertThat( importedClasses.containPackage( packageName ) )
37:                     .as( "Expected domain sub-package %s not found!", packageName )
38:                     .isTrue();
39:         }
40:     }
41: 
42:     @Test
43:     void testRequiredApplicationPackagesAreThere() {
44:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
45:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
46:             assertThat( importedClasses.containPackage( packageName ) )
47:                     .as( "Expected application sub-package %s not found!", packageName )
48:                     .isTrue();
49:         }
50:     }
51: 
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\distributioncenter\DistributionCenterManagementTest.java ---
1: package thkoeln.archilab.ecommerce.tests.distributioncenter;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.DistributionCenterTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
12: import thkoeln.archilab.ecommerce.usecases.DistributionCenterUseCases;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
14: 
15: import java.util.UUID;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
19: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
20: 
21: 
22: /**
23:  * This test checks the management and lifecycle of distribution centers.
24:  */
25: @SpringBootTest
26: public class DistributionCenterManagementTest {
27:     @Autowired
28:     private DistributionCenterUseCases distributionCenterUseCases;
29:     @Autowired
30:     private ItemCatalogUseCases itemCatalogUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private ItemTestHelper itemTestHelper;
35:     @Autowired
36:     private DistributionCenterTestHelper distributionCenterTestHelper;
37: 
38:     private PhysicalAddressType somePhysicalAddress;
39:     private UUID nonExistingId1;
40:     private UUID nonExistingId2;
41: 
42: 
43:     @BeforeEach
44:     public void setUp() {
45:         purgatory.deleteEverything();
46:         itemTestHelper.addAllItems();
47: 
48:         somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
49:                 instantiateZipCode( "90001" ) );
50:         nonExistingId1 = UUID.randomUUID();
51:         nonExistingId2 = UUID.randomUUID();
52:     }
53: 
54: 
55:     @Test
56:     public void testAddInvalidDistributionCenter() {
57:         // given
58:         String name = "Lager1";
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class,
63:                 () -> distributionCenterUseCases.addNewDistributionCenter(
64:                         null, somePhysicalAddress ) );
65:         assertThrows( ShopException.class,
66:                 () -> distributionCenterUseCases.addNewDistributionCenter(
67:                         "", somePhysicalAddress ) );
68:         assertThrows( ShopException.class,
69:                 () -> distributionCenterUseCases.addNewDistributionCenter(
70:                         name, null ) );
71:     }
72: 
73: 
74:     @Test
75:     public void testDeleteAllDistributionCentersWhenEmpty() {
76:         // given
77:         distributionCenterTestHelper.addAllDistributionCenters( false );
78:         UUID itemId9 = itemTestHelper.getItemId( 9 );
79:         UUID distributionCenterId1 = distributionCenterTestHelper.getDistributionCenterId( 1 );
80:         UUID distributionCenterId2 = distributionCenterTestHelper.getDistributionCenterId( 2 );
81: 
82:         // when
83:         int numOf1 = distributionCenterUseCases.getAvailableStock( distributionCenterId1, itemId9 );
84:         int numOf2 = distributionCenterUseCases.getAvailableStock( distributionCenterId2, itemId9 );
85: 
86:         // then
87:         assertEquals( 0, numOf1 );
88:         assertEquals( 0, numOf2 );
89:         distributionCenterUseCases.deleteAllDistributionCenters();
90:         // ... ids must be invalid now
91:         assertThrows( ShopException.class,
92:                 () -> distributionCenterUseCases.getAvailableStock( distributionCenterId1, itemId9 ) );
93:         assertThrows( ShopException.class,
94:                 () -> distributionCenterUseCases.getAvailableStock( distributionCenterId2, itemId9 ) );
95:     }
96: 
97: 
98:     @Test
99:     public void testDeleteAllDistributionCentersWhenFull() {
100:         // given
101:         distributionCenterTestHelper.addAllDistributionCenters( true );
102:         UUID itemId7 = itemTestHelper.getItemId( 7 );
103:         UUID distributionCenterId1 = distributionCenterTestHelper.getDistributionCenterId( 1 );
104:         UUID distributionCenterId2 = distributionCenterTestHelper.getDistributionCenterId( 2 );
105: 
106:         // when
107:         int numOf1 = distributionCenterUseCases.getAvailableStock( distributionCenterId1, itemId7 );
108:         int numOf2 = distributionCenterUseCases.getAvailableStock( distributionCenterId2, itemId7 );
109: 
110:         // then
111:         assertTrue( numOf1 == 3 );
112:         assertTrue( numOf2 == 3 );
113:         distributionCenterUseCases.deleteAllDistributionCenters();
114:         // ... ids must be invalid now
115:         assertThrows( ShopException.class,
116:                 () -> distributionCenterUseCases.getAvailableStock( distributionCenterId1, itemId7 ) );
117:         assertThrows( ShopException.class,
118:                 () -> distributionCenterUseCases.getAvailableStock( distributionCenterId2, itemId7 ) );
119:     }
120: 
121: 
122: 
123:     @Test
124:     public void testAddToStock() {
125:         // given
126:         distributionCenterTestHelper.addAllDistributionCenters( true );
127:         UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in distribution center 0
128:         UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
129:         int originalStock5 =
130:                 distributionCenterTestHelper.getDistributionCenterStock( 0, 5 );
131: 
132:         // when
133:         int stock5before = distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId5 );
134:         distributionCenterUseCases.addToStock( distributionCenterId0, itemId5, 23 );
135:         int stock5after = distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId5 );
136:         distributionCenterUseCases.addToStock( distributionCenterId0, itemId5, 0 );
137:         int stock5after2 = distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId5 );
138: 
139:         // then
140:         assertEquals( originalStock5, stock5before );
141:         assertEquals( stock5before + 23, stock5after );
142:         assertEquals( stock5after, stock5after2 );
143:     }
144: 
145: 
146:     @Test
147:     public void testInvalidAddToStock() {
148:         // given
149:         distributionCenterTestHelper.addAllDistributionCenters( true );
150:         UUID itemId2 = itemTestHelper.getItemId( 2 );
151:         UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
152: 
153:         // when
154:         // then
155:         assertThrows( ShopException.class,
156:                 () -> distributionCenterUseCases.addToStock( nonExistingId1, nonExistingId2, 12 ) );
157:         assertThrows( ShopException.class,
158:                 () -> distributionCenterUseCases.addToStock(
159:                         distributionCenterId0, nonExistingId2, 12 ) );
160:         assertThrows( ShopException.class,
161:                 () -> distributionCenterUseCases.addToStock(
162:                         nonExistingId1, itemId2, 12 ) );
163:         assertThrows( ShopException.class,
164:                 () -> distributionCenterUseCases.addToStock(
165:                         distributionCenterId0, itemId2, -1 ) );
166:     }
167: 
168: 
169:     @Test
170:     public void testRemoveFromStock() {
171:         // given
172:         distributionCenterTestHelper.addAllDistributionCenters( true );
173:         UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
174:         UUID itemId0 = itemTestHelper.getItemId( 0 ); // 0 in distribution center 0
175:         UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in distribution center 0
176:         UUID itemId6 = itemTestHelper.getItemId( 6 ); // random >30 in distribution center 0
177:         int stock0before =
178:                 distributionCenterTestHelper.getDistributionCenterStock( 0, 0 );
179:         int stock5before =
180:                 distributionCenterTestHelper.getDistributionCenterStock( 0, 5 );
181:         int stock6before =
182:                 distributionCenterTestHelper.getDistributionCenterStock( 0, 6 );
183: 
184:         // when
185:         distributionCenterUseCases.removeFromStock( distributionCenterId0, itemId5, 1 );
186:         int stock5after = distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId5 );
187:         distributionCenterUseCases.removeFromStock( distributionCenterId0, itemId0, 0 );
188:         int stock0after = distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId0 );
189:         distributionCenterUseCases.removeFromStock(
190:                 distributionCenterId0, itemId6, stock6before );
191:         int stock6after = distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId6 );
192: 
193:         // then
194:         assertEquals( stock5before - 1, stock5after );
195:         assertEquals( stock0before, stock0after );
196:         assertEquals( 0, stock6after );
197:     }
198: 
199: 
200:     @Test
201:     public void testInvalidRemoveFromStock() {
202:         // given
203:         distributionCenterTestHelper.addAllDistributionCenters( true );
204:         UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
205:         UUID itemId0 = itemTestHelper.getItemId( 0 ); // 0 in distribution center 0
206:         UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in distribution center 0
207:         int stock5before =
208:                 distributionCenterTestHelper.getDistributionCenterStock( 0, 5 );
209: 
210:         // when
211:         // then
212:         assertThrows( ShopException.class,
213:                 () -> distributionCenterUseCases.removeFromStock( nonExistingId1, nonExistingId2, 12 ) );
214:         assertThrows( ShopException.class,
215:                 () -> distributionCenterUseCases.removeFromStock(
216:                         distributionCenterId0, nonExistingId2, 12 ) );
217:         assertThrows( ShopException.class,
218:                 () -> distributionCenterUseCases.removeFromStock(
219:                         nonExistingId1, itemId5, 12 ) );
220:         assertThrows( ShopException.class,
221:                 () -> distributionCenterUseCases.removeFromStock(
222:                         distributionCenterId0, itemId5, -1 ) );
223:         assertThrows( ShopException.class,
224:                 () -> distributionCenterUseCases.removeFromStock(
225:                         distributionCenterId0, itemId5, stock5before + 1 ) );
226:         assertThrows( ShopException.class,
227:                 () -> distributionCenterUseCases.removeFromStock(
228:                         distributionCenterId0, itemId0, 1 ) ); // already 0 in distribution center 0
229:     }
230: 
231: 
232:     @Test
233:     public void testChangeStock() {
234:         // given
235:         distributionCenterTestHelper.addAllDistributionCenters( true );
236:         UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
237:         UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in distribution center 0
238: 
239:         // when
240:         distributionCenterUseCases.changeStockTo( distributionCenterId0, itemId5, 111 );
241:         int stock5after = distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId5 );
242: 
243:         // then
244:         assertEquals( 111, stock5after );
245:     }
246: 
247: 
248:     @Test
249:     public void testInvalidChangeStock() {
250:         // given
251:         distributionCenterTestHelper.addAllDistributionCenters( true );
252:         UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
253:         UUID itemId6 = itemTestHelper.getItemId( 6 );
254: 
255:         // when
256:         // then
257:         assertThrows( ShopException.class, () -> distributionCenterUseCases.changeStockTo(
258:                 nonExistingId1, nonExistingId2, 12 ) );
259:         assertThrows( ShopException.class, () -> distributionCenterUseCases.changeStockTo(
260:                 nonExistingId1, itemId6, 12 ) );
261:         assertThrows( ShopException.class, () -> distributionCenterUseCases.changeStockTo(
262:                 distributionCenterId0, nonExistingId2, 12 ) );
263:         assertThrows( ShopException.class, () -> distributionCenterUseCases.changeStockTo(
264:                 distributionCenterId0, itemId6, -1 ) );
265:     }
266: 
267: 
268:     @Test
269:     public void testEmptyDistributionCenter() {
270:         // given
271:         distributionCenterTestHelper.addAllDistributionCenters( true );
272:         UUID distributionCenterId9 = distributionCenterTestHelper.getDistributionCenterId( 9 ); // empty distribution center
273: 
274:         // when
275:         int totalStock = 0;
276:         for ( int iItem = 0; iItem < itemTestHelper.numberOfItems(); iItem++ ) {
277:             UUID itemId = itemTestHelper.getItemId( iItem );
278:             totalStock += distributionCenterUseCases.getAvailableStock(
279:                     distributionCenterId9, itemId );
280:         }
281: 
282:         // then
283:         assertEquals( 0, totalStock );
284:     }
285: 
286: 
287: 
288: }
289: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("domainPrimitivesUsageRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class DomainPrimitivesUsageRulesTest {
14:     private static final String EMAIL_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Email";
15:     private static final String MONEY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Money";
16:     private static final String PHYSICAL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress";
17: 
18:     @ArchTest
19:     static final ArchRule clientShouldReferenceEmail =
20:             classes()
21:                     .that().haveSimpleName( "Client" )
22:                     .should().dependOnClassesThat().haveFullyQualifiedName( EMAIL_CLASS )
23:                     .because( "Client should use Email instead of String" );
24: 
25:     @ArchTest
26:     static final ArchRule clientShouldReferencePhysicalAddress =
27:             classes()
28:                     .that().haveSimpleName( "Client" )
29:                     .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
30:                     .because( "Client should use PhysicalAddress instead of whatever else" );
31: 
32:     @ArchTest
33:     static final ArchRule distributionCenterShouldReferencePhysicalAddress =
34:             classes()
35:                     .that().haveSimpleName( "DistributionCenter" )
36:                     .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
37:                     .because( "Client should use PhysicalAddress instead of whatever else" );
38: 
39:     @ArchTest
40:     static final ArchRule itemShouldReferenceMoney =
41:             classes()
42:                     .that().haveSimpleName( "Item" )
43:                     .should().dependOnClassesThat().haveFullyQualifiedName( MONEY_CLASS )
44:                     .because( "Item should use Money instead of float or whatever else" );
45: }
46: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\EmailTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmail;
10: 
11: class EmailTest {
12: 
13:     @Test
14:     public void testToStringEmail() {
15:         // given
16:         String input = "test@example.com";
17: 
18:         // when
19:         EmailType instance = instantiateEmail( input );
20: 
21:         // then
22:         assertEquals( input, instance.toString() );
23:     }
24: 
25:     @Test
26:     public void testEqualityEmail() {
27:         // given
28:         // when
29:         EmailType instance1 = instantiateEmail( "test@example.com" );
30:         EmailType instance2 = instantiateEmail( "test@example.com" );
31:         EmailType instance3 = instantiateEmail( "different@example.com" );
32: 
33:         // then
34:         assertEquals( instance1, instance2 );
35:         assertNotEquals( instance1, instance3 );
36:     }
37: 
38:     @Test
39:     public void testImmutabilityEmail() {
40:         // given
41:         // when
42:         EmailType instance = instantiateEmail( "test@example.com" );
43: 
44:         // then
45:         try {
46:             instance.getClass().getMethod( "setEmail", String.class );
47:             fail( "setEmail method should not exist" );
48:         } catch (NoSuchMethodException e) {
49:             // Success: the object is immutable
50:         }
51:     }
52: 
53: 
54: 
55:     @Test
56:     public void smokeTestForCopyConstructors() {
57:         // given
58:         EmailType email =
59:                 instantiateEmail( "peter.schmidt@web.de" );
60: 
61:         // when
62:         EmailType emailOtherIdentifyer =
63:                 email.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
64:         assertThrows( ShopException.class, () ->
65:                 email.sameDomainDifferentIdentifyer( "p...eter" ) );
66:         EmailType emailOtherDomain =
67:                 email.sameIdentifyerDifferentDomain( "web.ch" );
68:         assertThrows( ShopException.class, () ->
69:                 email.sameIdentifyerDifferentDomain( "web.edu" ) );
70: 
71:         // then
72:         assertEquals( "p.e.t.e.r@web.de", emailOtherIdentifyer.toString() );
73:         assertEquals( "peter.schmidt@web.ch", emailOtherDomain.toString() );
74:     }
75: 
76: 
77:     @Test
78:     public void testFactoryValidEmail() {
79:         // given
80:         // when
81:         // then
82:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.com" ) );
83:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "99Z@example.com" ) );
84:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "GGGhh@s77.com" ) );
85:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "a@4.com" ) );
86:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "Max.Hammer@example.com" ) );
87:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "Max.Gideon.Hammer@example.com" ) );
88:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.this.com" ) );
89:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.de" ) );
90:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.at" ) );
91:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.ch" ) );
92:         Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.org" ) );
93:     }
94: 
95: 
96:     @Test
97:     public void testFactoryInvalidEmail() {
98:         // given
99:         // when
100:         // then
101:         assertThrows( ShopException.class, () -> instantiateEmail( null ) );
102:         assertThrows( ShopException.class, () -> instantiateEmail( "testexample.com" ) );
103:         assertThrows( ShopException.class, () -> instantiateEmail( "test@" ) );
104:         assertThrows( ShopException.class, () -> instantiateEmail( "@example.com" ) );
105:         assertThrows( ShopException.class, () -> instantiateEmail( "Max..Gideon.Hammer@example.com" ) );
106:         assertThrows( ShopException.class, () -> instantiateEmail( "test@examplecom" ) );
107:         assertThrows( ShopException.class, () -> instantiateEmail( "test@example..com" ) );
108:         assertThrows( ShopException.class, () -> instantiateEmail( "test@example@that.com" ) );
109:         assertThrows( ShopException.class, () -> instantiateEmail( "test example@that.com" ) );
110:         assertThrows( ShopException.class, () -> instantiateEmail( "test#example@that.com" ) );
111:         assertThrows( ShopException.class, () -> instantiateEmail( "test@example.biz" ) );
112:         assertThrows( ShopException.class, () -> instantiateEmail( "test@example.biz" ) );
113:         assertThrows( ShopException.class, () -> instantiateEmail( "test@example.42" ) );
114:     }
115: }
116: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\MoneyTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMoney;
9: 
10: class MoneyTest {
11: 
12:     @Test
13:     public void testGetAmountMoney() {
14:         // given
15:         Float inputAmount = 10.0f;
16: 
17:         // when
18:         MoneyType instance = instantiateMoney( inputAmount, "EUR" );
19: 
20:         // then
21:         assertEquals( inputAmount, instance.getAmount() );
22:     }
23: 
24:     @Test
25:     public void testGetCurrencyUnitMoney() {
26:         // given
27:         String inputCurrencyUnit = "EUR";
28: 
29:         // when
30:         MoneyType instance = instantiateMoney( 10.0f, inputCurrencyUnit );
31: 
32:         // then
33:         assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
34:     }
35: 
36:     @Test
37:     public void testAddToMoney() {
38:         // given
39:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
40:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
41:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
42: 
43:         // when
44:         MoneyType result12 = instance1.add( instance2 );
45:         MoneyType result13 = instance1.add( instance3 );
46: 
47:         // then
48:         assertEquals( 30.0f, result12.getAmount() );
49:         assertEquals( "EUR", result12.getCurrencyUnit() );
50:         assertEquals( 10.0f, result13.getAmount() );
51:         assertEquals( "EUR", result12.getCurrencyUnit() );
52:     }
53: 
54:     @Test
55:     public void testInvalidAddToMoney() {
56:         // given
57:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
58:         MoneyType instance2 = instantiateMoney( 20.0f, "CHF" );
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
63:     }
64: 
65:     @Test
66:     public void testSubtractFromMoney() {
67:         // given
68:         MoneyType instance1 = instantiateMoney( 30.0f, "EUR" );
69:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
70:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
71:         MoneyType instance4 = instantiateMoney( 30.0f, "EUR" );
72: 
73:         // when
74:         MoneyType result12 = instance1.subtract( instance2 );
75:         MoneyType result13 = instance1.subtract( instance3 );
76:         MoneyType result14 = instance1.subtract( instance4 );
77: 
78:         // then
79:         assertEquals( 10.0f, result12.getAmount() );
80:         assertEquals( "EUR", result12.getCurrencyUnit() );
81:         assertEquals( 30.0f, result13.getAmount() );
82:         assertEquals( "EUR", result13.getCurrencyUnit() );
83:         assertEquals( 0.0f, result14.getAmount() );
84:         assertEquals( "EUR", result14.getCurrencyUnit() );
85:     }
86: 
87:     @Test
88:     public void testInvalidSubtractFromMoney() {
89:         // given
90:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
91:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
92:         MoneyType instance3 = instantiateMoney( 5.0f, "CHF" );
93: 
94:         // when
95:         // then
96:         assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
97:         assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
98:     }
99: 
100:     @Test
101:     public void testMultiplyByMoney() {
102:         // given
103:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
104: 
105:         // when
106:         MoneyType result = instance.multiplyBy( 3 );
107: 
108:         // then
109:         assertEquals( 30.0f, result.getAmount() );
110:         assertEquals( "EUR", result.getCurrencyUnit() );
111:     }
112: 
113:     @Test
114:     public void testFactoryValidCurrencyUnitMoney() {
115:         // given
116:         // when
117:         // then
118:         assertDoesNotThrow( () -> instantiateMoney( 10.0f, "EUR" ) );
119:     }
120: 
121:     @Test
122:     public void testFactoryInvalidCurrencyUnitMoney() {
123:         // given
124:         // when
125:         // then
126:         assertThrows( ShopException.class, () -> instantiateMoney( -10.0f, "EUR" ) );
127:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, "USD" ) );
128:         assertThrows( ShopException.class, () -> instantiateMoney( null, "EUR" ) );
129:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, null ) );
130:     }
131: 
132:     @Test
133:     public void testLargerThanCurrencyUnitMoney() {
134:         // given
135:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
136:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
137:         MoneyType instance3 = instantiateMoney( 10.0f, "EUR" );
138:         MoneyType instance4 = instantiateMoney( 10.0f, "CHF" );
139: 
140:         // when
141:         // then
142:         assertTrue( instance2.largerThan( instance1 ) );
143:         assertFalse( instance1.largerThan( instance2 ) );
144:         assertFalse( instance1.largerThan( instance3 ) );
145:         assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
146:     }
147: 
148: 
149:     @Test
150:     public void testEqualityCurrencyUnitMoney() {
151:         // given
152:         // when
153:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
154:         MoneyType instance2 = instantiateMoney( 10.0f, "EUR" );
155:         MoneyType instance3 = instantiateMoney( 20.0f, "EUR" );
156: 
157:         // then
158:         assertEquals( instance1, instance2 );
159:         assertNotEquals( instance1, instance3 );
160:     }
161: 
162:     @Test
163:     public void testImmutabilityCurrencyUnitMoney() {
164:         // given
165:         // when
166:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
167: 
168:         // then
169:         try {
170:             instance.getClass().getMethod( "setAmount", Float.class );
171:             fail( "setAmount method should not exist" );
172:         } catch (NoSuchMethodException e) {
173:             // Success: the object is immutable
174:         }
175: 
176:         try {
177:             instance.getClass().getMethod( "setCurrencyUnit", String.class );
178:             fail( "setCurrencyUnit method should not exist" );
179:         } catch (NoSuchMethodException e) {
180:             // Success: the object is immutable
181:         }
182:     }
183: }
184: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\PhysicalAddressTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
11: 
12: class PhysicalAddressTest {
13: 
14:     @Test
15:     public void testGetterPhysicalAddress() {
16:         // given
17:         String street = "Irgendeinestraße 42";
18:         String city = "Irgendeinestadt";
19:         ZipCodeType plz = instantiateZipCode( "12345" );
20: 
21:         // when
22:         PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );
23: 
24:         // then
25:         assertEquals( street, instance.getStreet() );
26:         assertEquals( city, instance.getCity() );
27:         assertEquals( plz, instance.getZipCode() );
28:     }
29: 
30:     @Test
31:     public void testFactoryValidPhysicalAddress() {
32:         // given
33:         String street = "Irgendeinestraße 42";
34:         String city = "Irgendeinestadt";
35:         ZipCodeType plz = instantiateZipCode( "12345" );
36: 
37:         // when
38:         // then
39:         assertDoesNotThrow( () -> instantiatePhysicalAddress( street, city, plz ) );
40:     }
41: 
42:     @Test
43:     public void testFactoryInvalidPhysicalAddress() {
44:         // given
45:         String street = "Irgendeinestraße 42";
46:         String city = "Irgendeinestadt";
47:         ZipCodeType plz = instantiateZipCode( "12345" );
48: 
49:         // when
50:         // then
51:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( null, city, plz ) );
52:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( "", city, plz ) );
53:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, null, plz ) );
54:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, "", plz ) );
55:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, city, null ) );
56:     }
57: 
58:     @Test
59:     public void testEqualityPhysicalAddress() {
60:         // given
61:         String street = "Irgendeinestraße 42";
62:         String city = "Irgendeinestadt";
63:         ZipCodeType plz = instantiateZipCode( "12345" );
64: 
65:         // when
66:         PhysicalAddressType instance1 = instantiatePhysicalAddress( street, city, plz );
67:         PhysicalAddressType instance2 = instantiatePhysicalAddress( street, city, plz );
68:         PhysicalAddressType instance3 = instantiatePhysicalAddress( "Anderestr. 12", city, plz );
69:         PhysicalAddressType instance4 = instantiatePhysicalAddress( street, "AndereStadt", plz );
70:         PhysicalAddressType instance5 = instantiatePhysicalAddress( street, city, instantiateZipCode( "54321" ) );
71: 
72:         // then
73:         assertEquals( instance1, instance2 );
74:         assertNotEquals( instance1, instance3 );
75:         assertNotEquals( instance1, instance4 );
76:         assertNotEquals( instance1, instance5 );
77:     }
78: 
79:     @Test
80:     public void testImmutabilityPhysicalAddress() {
81:         // given
82:         String street = "Irgendeinestraße 42";
83:         String city = "Irgendeinestadt";
84:         ZipCodeType plz = instantiateZipCode( "12345" );
85: 
86:         // when
87:         PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );
88: 
89:         // then
90:         try {
91:             instance.getClass().getMethod( "setStreet", String.class );
92:             fail( "setStreet method should not exist" );
93:         } catch (NoSuchMethodException e) {
94:             // Success: the object is immutable
95:         }
96:         try {
97:             instance.getClass().getMethod( "setCity", String.class );
98:             fail( "setCity method should not exist" );
99: 
100:         } catch (NoSuchMethodException e) {
101:             // Success: the object is immutable
102:         }
103:         try {
104:             instance.getClass().getMethod( "setZipCode", ZipCodeType.class );
105:             fail( "setZipCode method should not exist" );
106:         } catch (NoSuchMethodException e) {
107:             // Success: the object is immutable
108:         }
109:     }
110: }
111: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\ZipCodeTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
8: 
9: import static org.junit.jupiter.api.Assertions.*;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
11: 
12: class ZipCodeTest {
13: 
14:     private String input1, input4;
15:     private ZipCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
16:             _04233, _02544, _99123, _56323, _79332;
17: 
18: 
19:     @BeforeEach
20:     public void setUp() {
21:         input1 = "12345";
22:         input4 = "49188";
23:         _12345 = FactoryMethodInvoker.instantiateZipCode( "12345" );
24:         _12345b = FactoryMethodInvoker.instantiateZipCode( "12345" );
25:         _23455 = FactoryMethodInvoker.instantiateZipCode( "23455" );
26:         _01234 = FactoryMethodInvoker.instantiateZipCode( "01234" );
27:         _01235 = FactoryMethodInvoker.instantiateZipCode( "01235" );
28:         _01238 = FactoryMethodInvoker.instantiateZipCode( "01238" );
29:         _01263 = FactoryMethodInvoker.instantiateZipCode( "01263" );
30:         _01213 = FactoryMethodInvoker.instantiateZipCode( "01213" );
31:         _01823 = FactoryMethodInvoker.instantiateZipCode( "01823" );
32:         _01312 = FactoryMethodInvoker.instantiateZipCode( "01312" );
33:         _04233 = FactoryMethodInvoker.instantiateZipCode( "04233" );
34:         _02544 = FactoryMethodInvoker.instantiateZipCode( "02544" );
35:         _99123 = FactoryMethodInvoker.instantiateZipCode( "99123" );
36:         _56323 = FactoryMethodInvoker.instantiateZipCode( "56323" );
37:         _79332 = FactoryMethodInvoker.instantiateZipCode( "79332" );
38: 
39:     }
40: 
41: 
42:     @Test
43:     public void testToStringZipCode() {
44:         // given
45:         // when
46:         ZipCodeType instance = instantiateZipCode( input1 );
47: 
48:         // then
49:         assertEquals( input1, instance.toString() );
50:     }
51: 
52:     @Test
53:     public void testFactoryValidZipCode() {
54:         // given
55:         // when
56:         // then
57:         assertDoesNotThrow( () -> instantiateZipCode( input1 ) );
58:     }
59: 
60:     @Test
61:     public void testFactoryInvalidZipCode() {
62:         // given
63:         // when
64:         // then
65:         assertThrows( ShopException.class, () -> instantiateZipCode( "123456" ) );
66:         assertThrows( ShopException.class, () -> instantiateZipCode( "1234" ) );
67:         assertThrows( ShopException.class, () -> instantiateZipCode( "20000" ) );
68:         assertThrows( ShopException.class, () -> instantiateZipCode( null ) );
69:     }
70: 
71:     @Test
72:     public void testEqualityZipCode() {
73:         // given
74:         // when
75:         ZipCodeType instance1a = instantiateZipCode( input1 );
76:         ZipCodeType instance1b = instantiateZipCode( input1 );
77:         ZipCodeType instance4 = instantiateZipCode( input4 );
78: 
79:         // then
80:         assertEquals( instance1a, instance1b );
81:         assertNotEquals( instance1a, instance4 );
82:     }
83: 
84:     @Test
85:     public void testImmutabilityZipCode() {
86:         // given
87:         // when
88:         ZipCodeType instance = instantiateZipCode( input1 );
89: 
90:         // then
91:         try {
92:             instance.getClass().getMethod( "setzipCode", String.class );
93:             fail( "setzipCode method should not exist" );
94:         } catch (NoSuchMethodException e) {
95:             // Success: the object is immutable
96:         }
97:     }
98: 
99: 
100:     @Test
101:     public void smokeTestForDifference() {
102:         // given
103:         ZipCodeType instance1a = instantiateZipCode( input1 );
104:         ZipCodeType instance1b = instantiateZipCode( input1 );
105:         ZipCodeType instance12479 = instantiateZipCode( "12479" );
106:         ZipCodeType instance21456 = instantiateZipCode( "21456" );
107: 
108:         // when
109:         int differenceAB = instance1a.difference( instance1b );
110:         int difference12 = instance1a.difference( instance12479 );
111:         int difference23 = instance12479.difference( instance21456 );
112: 
113:         // then
114:         assertEquals( 0, differenceAB );
115:         assertTrue( difference12 > 0 );
116:         assertTrue( difference23 > difference12 );
117:     }
118: 
119: 
120:     @Test
121:     public void testZipCodeFirstDigit() {
122:         // given
123:         ZipCodeType instance1 = instantiateZipCode( input1 );
124:         ZipCodeType instance4 = instantiateZipCode( input4 );
125: 
126:         // when
127:         // then
128:         assertEquals( 1, instance1.getFirstDigitZipCode() );
129:         assertEquals( 4, instance4.getFirstDigitZipCode() );
130:     }
131: 
132: 
133: 
134:     @Test
135:     public void testInvalidParameters() {
136:         // given
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 _12345.difference( null ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testSameZipCode() {
146:         // given
147:         // when
148:         int diff = _12345.difference( _12345b );
149: 
150:         // then
151:         assertEquals( 0, diff );
152:     }
153: 
154: 
155:     /**
156:      *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
157:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
158:      *        So, 56733 and 56734 have the same difference as 56733 and 56739.
159:      *      - The difference grows if more digits (counted from the right side) differ.
160:      *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
161:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
162:      *        53876 and 54876 have the same difference as 53876 and 57261.
163:      */
164:     @Test
165:     public void testZipCodeDifferenceInAllButFirstDigit() {
166:         // given
167:         // when
168:         int diff5a = _01234.difference( _01235 );
169:         int diff5b = _01234.difference( _01238 );
170:         int diff4a = _01234.difference( _01263 );
171:         int diff4b = _01234.difference( _01213 );
172:         int diff3a = _01234.difference( _01823 );
173:         int diff3b = _01234.difference( _01312 );
174:         int diff2a = _01234.difference( _04233 );
175:         int diff2b = _01234.difference( _02544 );
176: 
177:         // then
178:         assertEquals( diff5a, diff5b, "difference 01234-01235 must be the same as difference 01234-01238" );
179:         assertEquals( diff4a, diff4b, "difference 01234-01263 must be the same as difference 01234-01213" );
180:         assertEquals( diff3a, diff3b, "difference 01234-01823 must be the same as difference 01234-01312" );
181:         assertEquals( diff2a, diff2b, "difference 01234-04233 must be the same as difference 01234-02544" );
182: 
183:         assertTrue( diff5a < diff4a,
184:                 "difference 01234-01235 must be smaller than difference 01234-01263" );
185:         assertTrue( diff4a < diff3a,
186:                 "difference 01234-01263 must be smaller than difference 01234-01823" );
187:         assertTrue( diff3a < diff2a,
188:                 "difference 01234-01823 must be smaller than difference 01234-04233" );
189:     }
190: 
191: 
192:     /**
193:      *      - However, the difference between 5abcd and 6rstu must be smaller than the one
194:      *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
195:      *        one between 5abcd and 9rstu.
196:      *      - This last condition reflects the fact the first digits of a zip code marks a region
197:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
198:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
199:      *        other.
200:      */
201:     @Test
202:     public void testZipCodedifferenceInFirstDigit() {
203:         // given
204:         // when
205:         int diff1_1 = _01234.difference( _99123 );
206:         int diff1_2 = _01234.difference( _23455 );
207:         int diff1_5 = _01234.difference( _56323 );
208:         int diff1_3 = _01234.difference( _79332 );
209: 
210:         // then
211:         assertTrue( diff1_1 < diff1_2,
212:                 "difference 01234-99123 must be smaller than difference 01234-23455"  );
213:         assertTrue( diff1_2 < diff1_3,
214:                 "difference 01234-23455 must be smaller than difference 01234-79332" );
215:         assertTrue( diff1_3 < diff1_5,
216:                 "difference 01234-79332 must be smaller than difference 01234-56323"  );
217:     }
218: 
219: 
220: 
221: }
222: 
223: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
1: package thkoeln.archilab.ecommerce.tests.e1restcalls;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;
5: 
6: 
7: public class E1RestCallTableTest {
8: 
9:     private GenericTableSpecificationTests genericTableSpecificationTests = null;
10: 
11: 
12:     public E1RestCallTableTest() {
13:         this.genericTableSpecificationTests = new GenericTableSpecificationTests();
14:     }
15: 
16:     @Test
17:     public void restTest() throws Exception {
18:         genericTableSpecificationTests.testTableSpecification("E1" );
19:     }
20: }
21: 
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\item\ItemCatalogTest.java ---
1: package thkoeln.archilab.ecommerce.tests.item;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
9: import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.DistributionCenterUseCases;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
14: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
15: 
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.*;
19: 
20: 
21: @SpringBootTest
22: public class ItemCatalogTest {
23:     @Autowired
24:     private ClientRegistrationUseCases clientRegistrationUseCases;
25:     @Autowired
26:     private ShoppingBasketUseCases shoppingBasketUseCases;
27:     @Autowired
28:     private ItemCatalogUseCases itemCatalogUseCases;
29:     @Autowired
30:     private DistributionCenterUseCases distributionCenterUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private ClientTestHelper clientTestHelper;
35:     @Autowired
36:     private ItemTestHelper itemTestHelper;
37:     @Autowired
38:     private DistributionCenterTestHelper distributionCenterTestHelper;
39: 
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         clientTestHelper.registerAllClients();
45:         itemTestHelper.addAllItems();
46:     }
47: 
48: 
49:     @Test
50:     public void testAddItemToCatalog() {
51:         // given
52:         UUID itemId4 = itemTestHelper.getItemId( 4 );
53:         MoneyType salesPrice4 = itemTestHelper.getSalesPrice( 4 );
54: 
55:         // when
56:         MoneyType foundSalesPrice = itemCatalogUseCases.getSalesPrice( itemId4 );
57: 
58:         // then
59:         assertEquals( salesPrice4, foundSalesPrice );
60:     }
61: 
62: 
63:     @Test
64:     public void testAddItemWithInvalidData() {
65:         // given
66:         String name = "SomeStuff";
67:         String description = "Some more explanation on the stuff";
68:         Float size = 5.0f;
69:         MoneyType buyingPrice =
70:                 FactoryMethodInvoker.instantiateMoney( 5.0f, "EUR" );
71:         MoneyType salesPrice =
72:                 FactoryMethodInvoker.instantiateMoney( 10.0f, "EUR" );
73:         MoneyType tooLowSalesPrice =
74:                 FactoryMethodInvoker.instantiateMoney( 4.0f, "EUR" );
75: 
76:         // when / then
77:         assertThrows( ShopException.class, () ->
78:                 itemCatalogUseCases.addItemToCatalog(
79:                         null, description, size, buyingPrice, salesPrice ) );
80:         assertThrows( ShopException.class, () ->
81:                 itemCatalogUseCases.addItemToCatalog(
82:                         "", description, size, buyingPrice, salesPrice ) );
83:         assertThrows( ShopException.class, () ->
84:                 itemCatalogUseCases.addItemToCatalog(
85:                         name, null, size, buyingPrice, salesPrice ) );
86:         assertThrows( ShopException.class, () ->
87:                 itemCatalogUseCases.addItemToCatalog(
88:                         name, "", size, buyingPrice, salesPrice ) );
89:         assertThrows( ShopException.class, () ->
90:                 itemCatalogUseCases.addItemToCatalog(
91:                         name, description, size, null, salesPrice ) );
92:         assertThrows( ShopException.class, () ->
93:                 itemCatalogUseCases.addItemToCatalog(
94:                         name, description, size, buyingPrice, null ) );
95:         assertThrows( ShopException.class, () ->
96:                 itemCatalogUseCases.addItemToCatalog(
97:                         name, description, size, buyingPrice, tooLowSalesPrice ) );
98:     }
99: 
100: 
101:     @Test
102:     public void testRemoveNonExistentItem() {
103:         // given item 2 is not in stock anywhere - should be removable
104:         UUID nonExistentItemId = UUID.randomUUID();
105: 
106:         // when
107:         // then
108:         assertThrows( ShopException.class,
109:                 () -> itemCatalogUseCases.removeItemFromCatalog( nonExistentItemId ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testRemoveItemWithNoStock() {
115:         // given item 0 is not in stock anywhere - should be removable
116:         UUID itemId0 = itemTestHelper.getItemId( 0 );
117:         distributionCenterTestHelper.addAllDistributionCenters( true );
118: 
119:         // when
120:         assertDoesNotThrow( () -> itemCatalogUseCases.getSalesPrice( itemId0 ) );
121:         itemCatalogUseCases.removeItemFromCatalog( itemId0 );
122: 
123:         // then
124:         assertThrows( ShopException.class, () ->
125:                 itemCatalogUseCases.getSalesPrice( itemId0 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testRemoveItemThatIsInStock() {
131:         // given
132:         distributionCenterTestHelper.addAllDistributionCenters( false );
133:         UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
134:         UUID itemId3 = itemTestHelper.getItemId( 3 );
135:         UUID itemId4 = itemTestHelper.getItemId( 4 );
136:         distributionCenterUseCases.addToStock( distributionCenterId0, itemId3, 3 );
137: 
138:         // then item 3 must not be removable, but item 4 must be removable
139:         assertThrows( ShopException.class,
140:                 () -> itemCatalogUseCases.removeItemFromCatalog( itemId3 ) );
141:         assertDoesNotThrow( () -> itemCatalogUseCases.removeItemFromCatalog( itemId4 ) );
142:     }
143: 
144: 
145:     @Test
146:     public void testRemoveItemThatIsInOrder() {
147:         // given
148:         distributionCenterTestHelper.addAllDistributionCenters( false );
149:         UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
150:         UUID itemId4 = itemTestHelper.getItemId( 4 );
151:         EmailType clientEmail4 =
152:                 clientTestHelper.getClientEmail( 4 );
153:         distributionCenterUseCases.addToStock( distributionCenterId0, itemId4, 4 );
154: 
155:         // when client 4 adds 4x item 4 to his shopping basket and checks out ...
156:         shoppingBasketUseCases.addItemToShoppingBasket(
157:                 clientEmail4, itemId4, 4 );
158:         shoppingBasketUseCases.checkout( clientEmail4 );
159: 
160:         // then item 4 must not be removable
161:         assertThrows( ShopException.class,
162:                 () -> itemCatalogUseCases.removeItemFromCatalog( itemId4 ) );
163:     }
164: 
165: 
166:     @Test
167:     public void testClearItemCatalog() {
168:         // given
169:         UUID itemId4 = itemTestHelper.getItemId( 4 );
170: 
171:         // when
172:         itemCatalogUseCases.deleteItemCatalog();
173: 
174:         // then
175:         assertThrows( ShopException.class, () -> itemCatalogUseCases.getSalesPrice( itemId4 ) );
176:     }
177: 
178: }
179: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\order\OrderTest.java ---
1: package thkoeln.archilab.ecommerce.tests.order;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.DistributionCenterTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
14: 
15: import java.util.Map;
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.assertEquals;
19: import static org.junit.jupiter.api.Assertions.assertThrows;
20: 
21: 
22: @SpringBootTest
23: public class OrderTest {
24:     @Autowired
25:     private ClientRegistrationUseCases clientRegistrationUseCases;
26:     @Autowired
27:     private ShoppingBasketUseCases shoppingBasketUseCases;
28:     @Autowired
29:     private ItemCatalogUseCases itemCatalogUseCases;
30:     @Autowired
31:     private DistributionCenterUseCases distributionCenterUseCases;
32:     @Autowired
33:     private OrderUseCases orderUseCases;
34:     @Autowired
35:     private Purgatory purgatory;
36:     @Autowired
37:     private ClientTestHelper clientTestHelper;
38:     @Autowired
39:     private ItemTestHelper itemTestHelper;
40:     @Autowired
41:     private DistributionCenterTestHelper distributionCenterTestHelper;
42: 
43:     private UUID nonExistingId1;
44:     private UUID nonExistingId2;
45: 
46:     @BeforeEach
47:     public void setUp() {
48:         purgatory.deleteEverything();
49:         clientTestHelper.registerAllClients();
50:         itemTestHelper.addAllItems();
51:         distributionCenterTestHelper.addAllDistributionCenters( true );
52:         nonExistingId1 = UUID.randomUUID();
53:         nonExistingId2 = UUID.randomUUID();
54:     }
55: 
56: 
57:     @Test
58:     public void testOrderHistory() {
59:         // given
60:         UUID itemId1 = itemTestHelper.getItemId( 1 );
61:         UUID itemId2 = itemTestHelper.getItemId( 2 );
62:         EmailType clientEmail7 =
63:                 clientTestHelper.getClientEmail( 7 );
64:         Map<UUID, Integer> orderHistoryBefore = orderUseCases.getOrderHistory( clientEmail7 );
65: 
66:         // when
67:         shoppingBasketUseCases.addItemToShoppingBasket(
68:                 clientEmail7, itemId1, 3 );
69:         shoppingBasketUseCases.addItemToShoppingBasket(
70:                 clientEmail7, itemId2, 2 );
71:         shoppingBasketUseCases.checkout( clientEmail7 );
72:         Map<UUID, Integer> orderHistory1 =
73:                 orderUseCases.getOrderHistory( clientEmail7 );
74:         shoppingBasketUseCases.addItemToShoppingBasket(
75:                 clientEmail7, itemId1, 6 );
76:         shoppingBasketUseCases.addItemToShoppingBasket(
77:                 clientEmail7, itemId2, 2 );
78:         shoppingBasketUseCases.checkout( clientEmail7 );
79:         Map<UUID, Integer> orderHistory2 =
80:                 orderUseCases.getOrderHistory( clientEmail7 );
81:         shoppingBasketUseCases.addItemToShoppingBasket(
82:                 clientEmail7, itemId1, 1 );
83:         shoppingBasketUseCases.addItemToShoppingBasket(
84:                 clientEmail7, itemId2, 6 );
85:         shoppingBasketUseCases.checkout( clientEmail7 );
86:         Map<UUID, Integer> orderHistory3 =
87:                 orderUseCases.getOrderHistory( clientEmail7 );
88: 
89:         // then
90:         assertEquals( 0, orderHistoryBefore.size() );
91:         assertEquals( 2, orderHistory1.size() );
92:         assertEquals( 2, orderHistory2.size() );
93:         assertEquals( 2, orderHistory3.size() );
94:         assertEquals( 3, orderHistory1.get( itemId1 ) );
95:         assertEquals( 2, orderHistory1.get( itemId2 ) );
96:         assertEquals( 9, orderHistory2.get( itemId1 ) );
97:         assertEquals( 4, orderHistory2.get( itemId2 ) );
98:         assertEquals( 10, orderHistory3.get( itemId1 ) );
99:         assertEquals( 10, orderHistory3.get( itemId2 ) );
100:     }
101: 
102: 
103:     @Test
104:     public void testForEmptyOrderHistory() {
105:         // given
106:         EmailType clientEmail4 =
107:                 clientTestHelper.getClientEmail( 4 );
108:         // when
109:         Map<UUID, Integer> orderHistory =
110:                 orderUseCases.getOrderHistory( clientEmail4 );
111:         // then
112:         assertEquals( 0, orderHistory.size() );
113:     }
114: 
115: 
116:     @Test
117:     public void testInvalidParamsForGetOrderQuantForItem() {
118:         // given
119:         UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
120: 
121:         // when / then
122:         assertThrows ( ShopException.class,
123:                 () -> orderUseCases.getOrderQuantForItem( null, null ) );
124:         assertThrows ( ShopException.class,
125:                 () -> orderUseCases.getOrderQuantForItem( nonExistingId1, null ) );
126:         assertThrows ( ShopException.class,
127:                 () -> orderUseCases.getOrderQuantForItem( null, nonExistingId2 ) );
128:         assertThrows ( ShopException.class,
129:                 () -> orderUseCases.getOrderQuantForItem( nonExistingId1, nonExistingId2 ) );
130:         assertThrows ( ShopException.class,
131:                 () -> orderUseCases.getOrderQuantForItem( distributionCenterId0, null ) );
132:         assertThrows ( ShopException.class,
133:                 () -> orderUseCases.getOrderQuantForItem( distributionCenterId0, nonExistingId2 ) );
134:     }
135: 
136: 
137:     @Test
138:     public void testInvalidParamsForGetDistributionCenterIdForOrder() {
139:         // given / when / then
140:         assertThrows ( ShopException.class,
141:                 () -> orderUseCases.getDistributionCenterIdForOrder( null ) );
142:         assertThrows ( ShopException.class,
143:                 () -> orderUseCases.getDistributionCenterIdForOrder( nonExistingId1 ) );
144:     }
145: }
146: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import com.fasterxml.jackson.databind.ObjectMapper;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import thkoeln.archilab.ecommerce.domainprimitives.Email;
7: import thkoeln.archilab.ecommerce.domainprimitives.Money;
8: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
9: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
10: 
11: import static org.junit.jupiter.api.Assertions.*;
12: 
13: 
14: public class DomainPrimitiveJSONSerializationTest {
15: 
16:     private ObjectMapper objectMapper;
17: 
18:     @BeforeEach
19:     public void setUp() {
20:         objectMapper = new ObjectMapper(); // Initialisiere den ObjectMapper
21:     }
22: 
23:     @Test
24:     public void test_Email_Serialization() throws Exception {
25:         // given
26:         String emailString = "test@example.com";
27:         Email email = Email.of(emailString);
28: 
29:         // when
30:         String json = objectMapper.writeValueAsString(email);
31:         Email deserializedEmail = objectMapper.readValue(json, Email.class);
32: 
33:         // then
34:         assertNotNull(deserializedEmail);
35:         assertEquals(email, deserializedEmail);
36:         assertTrue(json.contains(emailString));
37:     }
38: 
39:     @Test
40:     public void test_ZipCode_Serialization() throws Exception {
41:         // given
42:         String zipCodeString = "12345";
43:         ZipCode zipCode = ZipCode.of(zipCodeString);
44: 
45:         // when
46:         String json = objectMapper.writeValueAsString(zipCode);
47:         ZipCode deserializedZipCode = objectMapper.readValue(json, ZipCode.class);
48: 
49:         // then
50:         assertNotNull(deserializedZipCode);
51:         assertEquals(zipCode, deserializedZipCode);
52:         assertTrue(json.contains(zipCodeString));
53:     }
54: 
55:     @Test
56:     public void test_PhysicalAddress_Serialization() throws Exception {
57:         // given
58:         String street = "Musterstraße 1";
59:         String city = "Köln";
60:         ZipCode zipCode = ZipCode.of("12345");
61:         PhysicalAddress address = PhysicalAddress.of(street, city, zipCode);
62: 
63:         // when
64:         String json = objectMapper.writeValueAsString(address);
65:         PhysicalAddress deserializedAddress = objectMapper.readValue(json, PhysicalAddress.class);
66: 
67:         // then
68:         assertNotNull(deserializedAddress);
69:         assertEquals(address, deserializedAddress);
70:         assertTrue(json.contains(street));
71:         assertTrue(json.contains(city));
72:         assertTrue(json.contains(zipCode.toString()));
73:     }
74: 
75:     @Test
76:     public void test_Money_Serialization() throws Exception {
77:         // given
78:         float amount = 99.99f;
79:         String currency = "EUR";
80:         Money money = Money.of(amount, currency);
81: 
82:         // when
83:         String json = objectMapper.writeValueAsString(money);
84:         Money deserializedMoney = objectMapper.readValue(json, Money.class);
85: 
86:         // then
87:         assertNotNull(deserializedMoney);
88:         assertEquals(money, deserializedMoney);
89:         assertTrue(json.contains(String.valueOf(amount)));
90:         assertTrue(json.contains(currency));
91:     }
92: 
93: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingBasketRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.result.MockMvcResultMatchers;
11: import thkoeln.archilab.ecommerce.domainprimitives.Email;
12: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
13: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
14: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
15: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
16: import thkoeln.archilab.ecommerce.solution.distributioncenter.application.DistributionCenterService;
17: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
18: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
19: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
20: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
21: import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
22: import thkoeln.archilab.ecommerce.usecases.masterdata.DistributionCenterTestHelper;
23: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
24: 
25: import java.util.Map;
26: import java.util.UUID;
27: 
28: import static org.junit.jupiter.api.Assertions.*;
29: import static org.springframework.http.HttpStatus.CREATED;
30: 
31: 
32: @SpringBootTest
33: @Transactional
34: @AutoConfigureMockMvc
35: @Import( RESTTestHelperConfiguration.class )
36: public class OwnShoppingBasketRESTTest {
37:     @Autowired
38:     private Purgatory purgatory;
39:     @Autowired
40:     private ClientTestHelper clientTestHelper;
41:     @Autowired
42:     private ItemTestHelper itemTestHelper;
43:     @Autowired
44:     private DistributionCenterTestHelper distributionCenterTestHelper;
45: 
46:     @Autowired
47:     private ShoppingBasketRESTHelper shoppingBasketRESTHelper;
48:     @Autowired
49:     private ShoppingBasketUseCases shoppingBasketUseCases;
50:     @Autowired
51:     private DistributionCenterService distributionCenterService;
52: 
53:     @BeforeEach
54:     public void setUp() {
55:         purgatory.deleteEverything();
56:         clientTestHelper.registerAllClients();
57:         itemTestHelper.addAllItems();
58:         distributionCenterTestHelper.addAllDistributionCenters( true );
59: 
60:         // ... add own setup code here
61:     }
62: 
63: 
64:     /**
65:      * Provide a test that implements a simple call to the REST endpoint (3):
66:      * <pre>
67:      *     GET /shoppingBaskets?clientId=<client id as uuid>
68:      * </pre>
69:      * - Use the {@link ClientTestHelper} to obtain to obtain the email
70:      *   of some example client.
71:      * - Use your shopping basket service to add entries to the shopping basket of that person.
72:      * - then use the `ShoppingBasketRESTHelper` to create the GET call, and check the results.
73:      * - (or do it by directly calling your REST controller, if you prefer)
74:      * @throws Exception
75:      */
76:     @Test
77:     public void test_getQuery_ShoppingBasket() throws Exception {
78:         // given
79:         // EmailType korrekt verwendet
80:         EmailType clientEmail = clientTestHelper.getClientEmail(0);
81:         UUID itemId = itemTestHelper.getItemId(0);
82:         // EmailType in einer Methode verwendet
83:         shoppingBasketUseCases.addItemToShoppingBasket(clientEmail, itemId, 1);
84: 
85:         // when
86:         UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(clientEmail, Map.of(itemId, 1));
87: 
88:         // then
89:         assertNotNull(basketId, "The shopping basket should exist and return an ID.");
90:     }
91: 
92: 
93: 
94:     /**
95:      * Provide a test that implements the addition of one item to the shopping basket via
96:      * REST endpoint (6):
97:      * <pre>
98:      *     POST /shoppingBaskets/{shoppingBasket-Id}/positions
99:      * </pre>
100:      * You can test now "the other way around" as in test_getQuery_ShoppingBasket():
101:      * - Use `ShoppingBasketRESTHelper` to add items via REST, then use shopping basket service methods
102:      *   to check of the shopping basket contains the right stuff.
103:      * - (or do it by directly calling your REST controller, if you prefer)
104:      *
105:      * @throws Exception
106:      */
107:     @Test
108:     public void test_post_ShoppingBasketPositions() throws Exception {
109:         // given
110:         EmailType clientEmail = clientTestHelper.getClientEmail(0);
111:         UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(clientEmail, Map.of());
112:         UUID itemId = itemTestHelper.getItemId(0);
113: 
114:         // when
115:         shoppingBasketRESTHelper.addItemToShoppingBasket(basketId, itemId, 1);
116: 
117:         // then
118:         Map<UUID, Integer> basketContents = shoppingBasketUseCases.getShoppingBasketAsMap(clientEmail);
119:         assertEquals(1, basketContents.get(itemId), "The shopping basket should contain 1 item of the specified ID.");
120:     }
121: 
122: 
123: 
124:     /**
125:      * Provide a test that implements the deletion of one item in the shopping basket via
126:      * REST endpoint (10):
127:      * <pre>
128:      *     DELETE /shoppingBaskets/{shoppingBasket-Id}/positions/{item-Id}
129:      * </pre>
130:      * This should be just a slight variation of the test_post_ShoppingBasketPositions()
131:      * method, but instead of adding an item to the shopping basket, you delete it.
132:      *
133:      * @throws Exception
134:      */
135:     @Test
136:     public void test_delete_ShoppingBasketPositions() throws Exception {
137:         // given
138:         EmailType clientEmail = clientTestHelper.getClientEmail(0);
139:         UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(clientEmail, Map.of());
140:         UUID itemId = itemTestHelper.getItemId(0);
141: 
142:         // add item first
143:         shoppingBasketRESTHelper.addItemToShoppingBasket(basketId, itemId, 1);
144: 
145:         // when
146:         shoppingBasketRESTHelper.deleteItemFromShoppingBasket(basketId, itemId);
147: 
148:         // then
149:         Map<UUID, Integer> basketContents = shoppingBasketUseCases.getShoppingBasketAsMap(clientEmail);
150:         assertNull(basketContents.get(itemId), "The item should be removed from the shopping basket.");
151:     }
152: 
153: 
154: 
155:     /**
156:      * Provide a test that implements the checkout of a shopping basket that can be served
157:      * by just 1 distribution center, using the REST endpoint (11):
158:      * <pre>
159:      *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
160:      * </pre>
161:      * - Use your shopping basket service to add entries to the shopping basket of some example client,
162:      * - then use the `ShoppingBasketRESTHelper to post the checkout call, and to check the results.
163:      * - (or do it by directly calling your REST controller, if you prefer)
164:      *
165:      * @throws Exception
166:      */
167:     @Test
168:     public void test_checkout_1_distributionCenter() throws Exception {
169: // given
170:         EmailType clientEmail = clientTestHelper.getClientEmail(0);
171:         UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(clientEmail, Map.of());
172:         UUID itemId1 = itemTestHelper.getItemId(0);
173: 
174:         // Stellen sicher, dass ein Distribution Center existiert und holen dessen ID
175:         UUID distributionCenterId;
176:         PhysicalAddressType testAddress = PhysicalAddress.of("Musterstraße 1", "Köln", ZipCode.of("50667"));
177:         distributionCenterId = distributionCenterService.addNewDistributionCenter("Test Distribution Center", testAddress);
178: 
179:         // Stellen sicher, dass genügend Bestand im Distribution Center verfügbar ist
180:         distributionCenterService.addToStock(distributionCenterId, itemId1, 5);
181: 
182:         // Fügen Sie einen Artikel dem Warenkorb hinzu
183:         shoppingBasketRESTHelper.addItemToShoppingBasket(basketId, itemId1, 5);
184: 
185:         // when
186:         shoppingBasketRESTHelper.checkout(basketId, clientTestHelper.getClientName(0), MockMvcResultMatchers.status().isCreated(), null);
187: 
188:         // then
189:         // Deklarieren der Variable und Abrufen des Inhalts des Warenkorbs nach dem Checkout
190:         Map<UUID, Integer> basketContentsAfterCheckout = shoppingBasketUseCases.getShoppingBasketAsMap(clientEmail);
191:         assertTrue(basketContentsAfterCheckout.isEmpty(), "The shopping basket should be empty after checkout.");
192:     }
193: 
194: 
195: 
196: 
197:     /**
198:      * Provide a test that implements the checkout of a shopping basket that can only be served
199:      * by using 2 distribution centers, using the REST endpoint (11):
200:      * <pre>
201:      *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
202:      * </pre>
203:      * This should be just a slight variation of thetest_checkout_1_distributionCenter() test.
204:      *
205:      * @throws Exception
206:      */
207:     @Test
208:     public void test_checkout_2_distributionCenters() throws Exception {
209:         // given
210:         EmailType clientEmail = clientTestHelper.getClientEmail(1);
211:         UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(clientEmail, Map.of());
212:         UUID itemId1 = itemTestHelper.getItemId(1);
213:         UUID itemId2 = itemTestHelper.getItemId(2);
214: 
215:         // Zusätzliche explizite Verwendung von EmailType
216:         EmailType emailTypeInstance = Email.of("erika@example.com");
217:         assertNotNull(emailTypeInstance, "EmailType instance should be created and not null.");
218:         assertEquals("erika@example.com", emailTypeInstance.toString(), "EmailType instance should match the given string.");
219: 
220:         // Vertraue auf vordefinierte Bestände für den Test
221:         shoppingBasketRESTHelper.addItemToShoppingBasket(basketId, itemId1, 3);
222:         shoppingBasketRESTHelper.addItemToShoppingBasket(basketId, itemId2, 2);
223: 
224:         // when
225:         shoppingBasketRESTHelper.checkout(basketId, clientTestHelper.getClientName(1), MockMvcResultMatchers.status().isCreated(), null);
226: 
227:         // then
228:         Map<UUID, Integer> basketContentsAfterCheckout = shoppingBasketUseCases.getShoppingBasketAsMap(clientEmail);
229:         assertTrue(basketContentsAfterCheckout.isEmpty(), "The shopping basket should be empty after checkout.");
230:     }
231: }
232: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\CheckoutAcceptanceTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingbasket;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.DistributionCenterTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
14: 
15: import java.util.*;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: 
19: /**
20:  * This test checks the management of stock across distribution centers. It focuses on the
21:  * cases where more than one distribution center are needed to serve the shopping basket of a client.
22:  */
23: @Slf4j
24: @SpringBootTest
25: public class CheckoutAcceptanceTest {
26:     @Autowired
27:     private ClientRegistrationUseCases clientRegistrationUseCases;
28:     @Autowired
29:     private ShoppingBasketUseCases shoppingBasketUseCases;
30:     @Autowired
31:     private ItemCatalogUseCases itemCatalogUseCases;
32:     @Autowired
33:     private OrderUseCases orderUseCases;
34:     @Autowired
35:     private DistributionCenterUseCases distributionCenterUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private ClientTestHelper clientTestHelper;
40:     @Autowired
41:     private ItemTestHelper itemTestHelper;
42:     @Autowired
43:     private DistributionCenterTestHelper distributionCenterTestHelper;
44: 
45:     private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
46:                                 map8_11_14_quantity_3_3_4,
47:                                 map10_12_quantity_1_1, 
48:                                 map11_quantity_1, 
49:                                 map12_quantity_10,
50:                                 map8_9_10_11_quantity_2_1_4_2;
51:     private EmailType clientEmail3, clientEmail6,
52:             clientEmail2;
53:     private UUID itemId8, itemId9, itemId10, itemId11, itemId12,
54:             itemId14;
55: 
56: 
57:     @BeforeEach
58:     public void setUp() {
59:         purgatory.deleteEverything();
60:         clientTestHelper.registerAllClients();
61:         itemTestHelper.addAllItems();
62:         distributionCenterTestHelper.addAllDistributionCenters( true );
63: 
64:         clientEmail3 = clientTestHelper.getClientEmail( 3 );
65:         clientEmail6 = clientTestHelper.getClientEmail( 6 );
66:         clientEmail2 = clientTestHelper.getClientEmail( 2 );
67: 
68:         itemId8 = itemTestHelper.getItemId( 8 );
69:         itemId9 = itemTestHelper.getItemId( 9 );
70:         itemId10 = itemTestHelper.getItemId( 10 );
71:         itemId11 = itemTestHelper.getItemId( 11 );
72:         itemId12 = itemTestHelper.getItemId( 12 );
73:         itemId14 = itemTestHelper.getItemId( 14 );
74: 
75:         map8_11_14_quantity_2_2_2 = new HashMap<>() {{
76:             put( itemId8, 2 );
77:             put( itemId11, 2 );
78:             put( itemId14, 2 );
79:         }};
80:         map8_11_14_quantity_3_3_4 = new HashMap<>() {{
81:             put( itemId8, 3 );
82:             put( itemId11, 3 );
83:             put( itemId14, 4 );
84:         }};
85:         map10_12_quantity_1_1 = new HashMap<>() {{
86:             put( itemId10, 1 );
87:             put( itemId12, 1 );
88:         }};
89:         map11_quantity_1 = new HashMap<>() {{
90:             put( itemId11, 1 );
91:         }};
92:         map12_quantity_10 = new HashMap<>() {{
93:             put( itemId12, 10 );
94:         }};
95:         map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
96:             put( itemId8, 2 );
97:             put( itemId9, 1 );
98:             put( itemId10, 4 );
99:             put( itemId11, 2 );
100:         }};
101: 
102:     }
103: 
104: 
105:     /**
106:      * Hint: to better understand the expected results of this test, see the distribution of stock
107:      * across distribution centers, as specified in the DistributionCenterTestHelper and in the README file.
108:      */
109:     @Test
110:     public void testClosestSingleDistributionCenterWins() {
111:         log.info( "testClosestSingleDistributionCenterWins" );
112: 
113:         // given
114:         shoppingBasketUseCases.addItemToShoppingBasket(
115:                 clientEmail3, itemId8, 2 );
116:         shoppingBasketUseCases.addItemToShoppingBasket(
117:                 clientEmail3, itemId11, 2 );
118:         shoppingBasketUseCases.addItemToShoppingBasket(
119:                 clientEmail3, itemId14, 2 );
120:         // that basket could have been served from distribution center 4 or 7, but 4 is closer to the client
121:         UUID distributionCenterId4 = distributionCenterTestHelper.getDistributionCenterId( 4 );
122: 
123:         // when
124:         Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmail3 );
125: 
126:         // then
127:         checkDistributionCenterIds( orderIds, distributionCenterId4 );
128:         checkItemNumbers( orderIds, distributionCenterId4, map8_11_14_quantity_2_2_2 );
129:     }
130: 
131: 
132:     /**
133:      * Hint: to better understand the expected results of this test, see the distribution of stock
134:      * across distribution centers, as specified in the DistributionCenterTestHelper and in the README file.
135:      */
136:     @Test
137:     public void testDistributionCenterWithEnoughCapacityWins() {
138:         log.info( "testDistributionCenterWithEnoughCapacityWins" );
139: 
140:         // given
141:         shoppingBasketUseCases.addItemToShoppingBasket(
142:                 clientEmail3, itemId8, 3 );
143:         shoppingBasketUseCases.addItemToShoppingBasket(
144:                 clientEmail3, itemId11, 3 );
145:         shoppingBasketUseCases.addItemToShoppingBasket(
146:                 clientEmail3, itemId14, 4 );
147:         // that basket could have been served from distribution center 4 or 7, 4 is closer to the client,
148:         // but only 7 has enough capacity
149:         UUID distributionCenterId7 = distributionCenterTestHelper.getDistributionCenterId( 7 );
150: 
151:         // when
152:         Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmail3 );
153: 
154:         // then
155:         checkDistributionCenterIds( orderIds, distributionCenterId7 );
156:         checkItemNumbers( orderIds, distributionCenterId7, map8_11_14_quantity_3_3_4 );
157:     }
158: 
159: 
160:     /**
161:      * Hint: to better understand the expected results of this test, see the distribution of stock
162:      * across distribution centers, as specified in the DistributionCenterTestHelper and in the README file.
163:      */
164:     @Test
165:     public void testTwoDistributionCenters() {
166:         log.info( "testTwoDistributionCenters" );
167: 
168:         // given
169:         shoppingBasketUseCases.addItemToShoppingBasket(
170:                 clientEmail6, itemId10, 1 );
171:         shoppingBasketUseCases.addItemToShoppingBasket(
172:                 clientEmail6, itemId11, 1 );
173:         shoppingBasketUseCases.addItemToShoppingBasket(
174:                 clientEmail6, itemId12, 1 );
175:         // that basket needs two shipments (2 + 1 items) anyway, and there
176:         // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
177:         // closer. The smaller can then be served from 4 (closest), 7, or 8.
178:         UUID distributionCenterId5 = distributionCenterTestHelper.getDistributionCenterId( 5 );
179:                 // should cover map10_12_quantity_1_1
180:         UUID distributionCenterId4 = distributionCenterTestHelper.getDistributionCenterId( 4 );
181:                 // should cover map11_quantity_1
182: 
183:         // when
184:         Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmail6 );
185: 
186:         // then
187:         checkDistributionCenterIds( orderIds, distributionCenterId5, distributionCenterId4 );
188:         checkItemNumbers( orderIds, distributionCenterId5, map10_12_quantity_1_1 );
189:         checkItemNumbers( orderIds, distributionCenterId4, map11_quantity_1 );
190:     }
191: 
192: 
193:     /**
194:      * Hint: to better understand the expected results of this test, see the distribution of stock
195:      * across distribution centers, as specified in the DistributionCenterTestHelper and in the README file.
196:      */
197:     @Test
198:     public void testTwoBigShipments() {
199:         log.info( "testTwoBigShipments" );
200: 
201:         // given
202:         shoppingBasketUseCases.addItemToShoppingBasket(
203:                 clientEmail2, itemId8, 2 );
204:         shoppingBasketUseCases.addItemToShoppingBasket(
205:                 clientEmail2, itemId9, 1 );
206:         shoppingBasketUseCases.addItemToShoppingBasket(
207:                 clientEmail2, itemId10, 4 );
208:         shoppingBasketUseCases.addItemToShoppingBasket(
209:                 clientEmail2, itemId11, 2 );
210:         shoppingBasketUseCases.addItemToShoppingBasket(
211:                 clientEmail2, itemId12, 10 );
212:         // when
213:         Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmail2 );
214:         UUID distributionCenterId7 = distributionCenterTestHelper.getDistributionCenterId( 7 );
215:                 // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 items
216:         UUID distributionCenterId5 = distributionCenterTestHelper.getDistributionCenterId( 5 );
217:                 // should cover map12_quantity_10 - the only distribution center with enough capacity for 10 items
218: 
219:         // then
220:         checkDistributionCenterIds( orderIds, distributionCenterId7, distributionCenterId5 );
221:         checkItemNumbers( orderIds, distributionCenterId7, map8_9_10_11_quantity_2_1_4_2 );
222:         checkItemNumbers( orderIds, distributionCenterId5, map12_quantity_10 );
223:     }
224: 
225: 
226:     /**
227:      * Hint: to better understand the expected results of this test, see the distribution of stock
228:      * across distribution centers, as specified in the DistributionCenterTestHelper and in the README file.
229:      */
230:     @Test
231:     public void testOnlyOneSolution() {
232:         log.info( "testOnlyOneSolution" );
233: 
234:         // given
235:         shoppingBasketUseCases.addItemToShoppingBasket(
236:                 clientEmail6, itemId12, 10 );
237:         // when
238:         Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmail6 );
239:         UUID distributionCenterId5 = distributionCenterTestHelper.getDistributionCenterId( 5 );
240:         // should cover map12_quantity_10 - the only distribution center with enough capacity for 10 items
241: 
242:         // then
243:         checkDistributionCenterIds( orderIds, distributionCenterId5 );
244:         checkItemNumbers( orderIds, distributionCenterId5, map12_quantity_10 );
245:     }
246: 
247: 
248: 
249:     private void checkItemNumbers( Set<UUID> orderIds, UUID distributionCenterId, Map<UUID, Integer> expectedMap ) {
250:         UUID fittingOrderId = null;
251:         for ( UUID orderId : orderIds ) {
252:             UUID foundDistributionCenterId = orderUseCases.getDistributionCenterIdForOrder( orderId );
253:             if ( foundDistributionCenterId.equals( distributionCenterId ) ) {
254:                 fittingOrderId = orderId;
255:                 break;
256:             }
257:         }
258:         assertNotNull( fittingOrderId, "No fitting order found for distribution center " + distributionCenterId );
259: 
260:         int totalExpected = 0;
261:         int totalActual = 0;
262:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
263:             totalExpected += entry.getValue();
264:         }
265:         log.info( "Check order numbers for item {} in distribution center {}", fittingOrderId, distributionCenterId );
266:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
267:             UUID itemId = entry.getKey();
268:             Integer foundNumber =
269:                     orderUseCases.getOrderQuantForItem( fittingOrderId, itemId );
270:             assertEquals( entry.getValue(), foundNumber );
271:             totalActual += foundNumber;
272:         }
273:         // last check - do the total sums match?
274:         assertEquals( totalExpected, totalActual );
275:     }
276: 
277: 
278:     private void checkDistributionCenterIds( Set<UUID> orderIds, UUID... expectedDistributionCenterIds ) {
279:         assertEquals( expectedDistributionCenterIds.length, orderIds.size() );
280:         Set<UUID> foundDistributionCenterIds = new HashSet<>();
281:         for ( UUID orderId : orderIds ) {
282:             UUID distributionCenterId = orderUseCases.getDistributionCenterIdForOrder( orderId );
283:             foundDistributionCenterIds.add( distributionCenterId );
284:         }
285:         for ( UUID expectedDistributionCenterId : expectedDistributionCenterIds ) {
286:             assertTrue( foundDistributionCenterIds.contains( expectedDistributionCenterId ) );
287:         }
288:     }
289: 
290: }
291: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingbasket;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.ResultMatcher;
12: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
13: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
14: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
15: import thkoeln.archilab.ecommerce.usecases.DistributionCenterUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
17: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
18: import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
19: import thkoeln.archilab.ecommerce.usecases.masterdata.DistributionCenterTestHelper;
20: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
21: 
22: import java.util.HashMap;
23: import java.util.Map;
24: import java.util.UUID;
25: 
26: import static org.junit.jupiter.api.Assertions.assertEquals;
27: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
28: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
29: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmail;
30: 
31: 
32: @SpringBootTest
33: @Transactional
34: @AutoConfigureMockMvc
35: @Import( RESTTestHelperConfiguration.class )
36: public class ShoppingBasketRESTTest {
37:     @Autowired
38:     private DistributionCenterUseCases distributionCenterUseCases;
39:     @Autowired
40:     private ShoppingBasketUseCases shoppingBasketUseCases;
41:     @Autowired
42:     private Purgatory purgatory;
43:     @Autowired
44:     private ClientTestHelper clientTestHelper;
45:     @Autowired
46:     private ItemTestHelper itemTestHelper;
47:     @Autowired
48:     private DistributionCenterTestHelper distributionCenterTestHelper;
49:     @Autowired
50:     private MockMvc mockMvc;
51:     @Autowired
52:     private ShoppingBasketRESTHelper shoppingBasketRESTHelper;
53: 
54:     private EmailType nonExistingEmail;
55:     private final Map<UUID, Integer> emptyMap = new HashMap<>();
56: 
57:     private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
58:     private EmailType
59:             clientEmail0,
60:             clientEmail3,
61:             clientEmail6,
62:             clientEmail8;
63:     private String clientName0, clientName8;
64:     private UUID itemId0, itemId1, itemId2, itemId3, itemId5,
65:                  itemId7, itemId9, itemId11, nonExistentItemId;
66:     private UUID distributionCenterId0, distributionCenterId3, distributionCenterId7, distributionCenterId8;
67: 
68: 
69:     private static final ResultMatcher NOT_FOUND = status().isNotFound();
70:     private static final ResultMatcher OK = status().isOk();
71:     private static final ResultMatcher CREATED = status().isCreated();
72:     private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
73:     private static final ResultMatcher CONFLICT = status().isConflict();
74: 
75:     @BeforeEach
76:     public void setUp() {
77:         purgatory.deleteEverything();
78:         clientTestHelper.registerAllClients();
79:         itemTestHelper.addAllItems();
80:         distributionCenterTestHelper.addAllDistributionCenters( true );
81:         nonExistingEmail = instantiateEmail( "harry@sally.de" );
82: 
83:         clientEmail0 = clientTestHelper.getClientEmail( 0 );
84:         clientEmail3 = clientTestHelper.getClientEmail( 3 );
85:         clientEmail6 = clientTestHelper.getClientEmail( 6 );
86:         clientEmail8 = clientTestHelper.getClientEmail( 8 );
87:         clientName0 = clientTestHelper.getClientName( 0 );
88:         clientName8 = clientTestHelper.getClientName( 8 );
89: 
90:         itemId0 = itemTestHelper.getItemId( 0 );
91:         itemId1 = itemTestHelper.getItemId( 1 );
92:         itemId2 = itemTestHelper.getItemId( 2 );
93:         itemId3 = itemTestHelper.getItemId( 3 );
94:         itemId5 = itemTestHelper.getItemId( 5 );
95:         itemId7 = itemTestHelper.getItemId( 7 );
96:         itemId9 = itemTestHelper.getItemId( 9 );
97:         itemId11 = itemTestHelper.getItemId( 11 );
98:         nonExistentItemId = UUID.randomUUID();
99: 
100:         distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
101:         distributionCenterId3 = distributionCenterTestHelper.getDistributionCenterId( 3 );
102:         distributionCenterId7 = distributionCenterTestHelper.getDistributionCenterId( 7 );
103:         distributionCenterId8 = distributionCenterTestHelper.getDistributionCenterId( 8 );
104: 
105:         map9_quantity_1 = new HashMap<>() {{
106:             put( itemId9, 1 );
107:         }};
108:         map5_quantity_2 = new HashMap<>() {{
109:             put( itemId5, 2 );
110:         }};
111:         map7_quantity_7 = new HashMap<>() {{
112:             put( itemId7, 7 );
113:         }};
114:         map9_11_quantity_2_2 = new HashMap<>() {{
115:             put( itemId9, 2 );
116:             put( itemId11, 2 );
117:         }};
118:     }
119: 
120: 
121:     @Test
122:     public void testInvalidShoppingBasketBaseUris() throws Exception {
123:         // given
124:         String allShoppingBasketsUri = "/shoppingBaskets";
125:         String randomIdUri = "/shoppingBaskets/" + UUID.randomUUID();
126:         String randomClientUUID = "/shoppingBaskets?clientId=" + UUID.randomUUID();
127:         String invalidClientUUID = "/shoppingBaskets?clientId=invalidUUID";
128:         String randomParamUri = "/shoppingBaskets?randomParam=randomValue";
129: 
130:         // when
131:         // then
132:         mockMvc.perform( get( allShoppingBasketsUri ) ).andExpect( status().isMethodNotAllowed() );
133:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
134:         mockMvc.perform( get( randomClientUUID ) ).andExpect( status().isNotFound() );
135:         mockMvc.perform( get( invalidClientUUID ) ).andExpect( status().isNotFound() );
136:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
137:     }
138: 
139: 
140:     @Test
141:     public void testInvalidPositionUris() throws Exception {
142:         // given
143:         UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail8, emptyMap );
144:         String randomPositionUri = "/shoppingBaskets/" + shoppingBasketId8.toString() + "/random";
145:         String randomItemUri = "/shoppingBaskets/" + shoppingBasketId8.toString()
146:                 + "/positions/" + UUID.randomUUID();
147: 
148:         // when
149:         // then
150:         mockMvc.perform( post( randomPositionUri ) ).andExpect( status().isNotFound() );
151:         mockMvc.perform( delete( randomItemUri ) ).andExpect( status().isNotFound() );
152:     }
153: 
154: 
155:     @Test
156:     public void testInvalidAddToShoppingBasket() throws Exception {
157:         // given
158:         Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
159:         expectedStartQuantityMap.put( itemId2, 19 );
160: 
161:         // when
162:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail0, emptyMap );
163:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId, itemId2, 6 );
164:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId, itemId2, 13 );
165: 
166:         // then
167:         shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail0, expectedStartQuantityMap );
168: 
169:         // ... and check a couple of invalid cases
170:         shoppingBasketRESTHelper.addItemToShoppingBasket(
171:                 shoppingBasketId, nonExistentItemId, 12, NOT_FOUND );
172:         shoppingBasketRESTHelper.addItemToShoppingBasket(
173:                 UUID.randomUUID(), itemId5, 12, NOT_FOUND );
174:         shoppingBasketRESTHelper.addItemToShoppingBasket(
175:                 shoppingBasketId, itemId5, -1, UNPROCESSABLE_ENTITY );
176: 
177:         // check if the shopping basket is still the same
178:         shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail0, expectedStartQuantityMap );
179:     }
180: 
181: 
182:     @Test
183:     public void testInvalidCheckout_unavailableItem() throws Exception {
184:         // given
185:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail0, emptyMap );
186: 
187:         // when
188:         // productId0 is not available in the requested quantity (or rather, not at all)
189:         shoppingBasketRESTHelper.addItemToShoppingBasket(
190:                 shoppingBasketId, itemId0, 1, CREATED );
191: 
192:         // check if the shopping basket is still the same
193:         shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
194:     }
195: 
196: 
197:     @Test
198:     public void testInvalidCheckout_tooLittleStock() throws Exception {
199:         // given
200:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail0, emptyMap );
201: 
202:         // when
203:         // There are only 10 pieces of productId1 available
204:         shoppingBasketRESTHelper.addItemToShoppingBasket(
205:                 shoppingBasketId, itemId1, 11, CREATED );
206: 
207:         // check if the shopping basket is still the same
208:         shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
209:     }
210: 
211: 
212: 
213:     @Test
214:     public void testDeleteItemFromShoppingBasket() throws Exception {
215:         // given
216:         UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail6, emptyMap );
217:         Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
218:         expectedQuantityMap1.put( itemId1, 1 );
219:         expectedQuantityMap1.put( itemId2, 2 );
220:         expectedQuantityMap1.put( itemId3, 3 );
221:         Map<UUID, Integer> quantityMap2 = new HashMap<>();
222:         quantityMap2.put( itemId1, 1 );
223:         quantityMap2.put( itemId3, 3 );
224: 
225:         // when
226:         // then
227:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId6, itemId1, 1 );
228:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId6, itemId2, 2 );
229:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId6, itemId3, 3 );
230:         shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail6, expectedQuantityMap1 );
231: 
232:         shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId6, itemId2 );
233:         shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail6, quantityMap2 );
234:     }
235: 
236: 
237:     @Test
238:     public void testNoDoubleDelete() throws Exception {
239:         // given
240:         UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail6, emptyMap );
241: 
242:         // when
243:         // then
244:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId6, itemId3, 3 );
245:         shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId6, itemId3 );
246:         shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail6, new HashMap<>() );
247:         shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId6, itemId3, NOT_FOUND );
248:     }
249: 
250: 
251:     @Test
252:     public void testAddRemoveItemsFromAndToShoppingBasket() throws Exception {
253:         // given
254:         UUID shoppingBasketId3 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail3, emptyMap );
255:         UUID shoppingBasketId5 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail6, emptyMap );
256: 
257:         // when
258:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId3, itemId1, 2 );
259:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId3, itemId2, 3 );
260:         shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId3, itemId1 );
261:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId3, itemId1, 1 );
262:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId3, itemId2, 6 );
263: 
264:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId5, itemId1, 2 );
265:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId5, itemId2, 8 );
266:         shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId5, itemId1 );
267:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId5, itemId1, 1 );
268:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId5, itemId2, 2 );
269: 
270:         // then
271:         // client3 has 1x itemId1 and 9x itemId2 expected in cart
272:         Map<UUID, Integer> expectedMap3 = new HashMap<>();
273:         expectedMap3.put( itemId1, 1 );
274:         expectedMap3.put( itemId2, 9 );
275:         shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail3, expectedMap3 );
276: 
277:         // client6 has 1x itemId1 and 10x itemId2 in cart
278:         Map<UUID, Integer> expectedMap5 = new HashMap<>();
279:         expectedMap5.put( itemId1, 1 );
280:         expectedMap5.put( itemId2, 10 );
281:         shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail6, expectedMap5 );
282:     }
283: 
284: 
285:     @Test
286:     public void testNoDoubleCheckout() throws Exception {
287:         // given
288:         UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail8, emptyMap );
289: 
290:         // when
291:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId2, 3 );
292: 
293:         // then
294:         shoppingBasketRESTHelper.checkout( shoppingBasketId8, clientName8, CREATED, null );
295:         shoppingBasketRESTHelper.checkout( shoppingBasketId8, null, CONFLICT, null );
296:     }
297: 
298: 
299:     @Test
300:     public void testCheckout_1_Order() throws Exception {
301:         // given:
302:         // Client 0 wants to buy 1x item 9. This is in distribution center 5, 7, and 8. Out of these,
303:         // distribution center 8 with zip code 89250 is closest to client 0 with zip code 02314.
304:         Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
305:             put( distributionCenterId8, map9_quantity_1 );
306:         }};
307:         UUID shoppingBasketId0 = shoppingBasketRESTHelper.getQueryShoppingBasket(
308:                 clientEmail0, null );
309:         int stock9before =
310:                 distributionCenterUseCases.getAvailableStock( distributionCenterId8, itemId9 );
311: 
312:         // when
313:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId0, itemId9, 1 );
314:         shoppingBasketRESTHelper.checkout( shoppingBasketId0, clientName0, CREATED, expectedOrders );
315:         int stock9after =
316:                 distributionCenterUseCases.getAvailableStock( distributionCenterId8, itemId9 );
317: 
318:         // then
319:         assertEquals( 1, stock9before - stock9after );
320:     }
321: 
322: 
323:     @Test
324:     public void testCheckout_3_Order() throws Exception {
325:         // given:
326:         // Client 8 (Felix Bauer) wants to buy 2x each of items 5, 9, 11; and 7x item 7.
327:         //       - items 9 and 11 can both be found in distribution centers 7 and 8. Distribution centers 7 (76532) is closer to
328:         //         the client (70173)
329:         //       - item 7 is available in distribution centers 1, 2, and 3, but only distribution center 3 has enough stock.
330:         //       - item 5 is only available in distribution center 0.
331:         Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
332:             put( distributionCenterId0, map5_quantity_2 );
333:             put( distributionCenterId3, map7_quantity_7 );
334:             put( distributionCenterId7, map9_11_quantity_2_2 );
335:         }};
336:         UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket(
337:                 clientEmail8, null );
338:         int stock5before =
339:                 distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId5 );
340:         int stock7before =
341:                 distributionCenterUseCases.getAvailableStock( distributionCenterId3, itemId7 );
342:         int stock9before =
343:                 distributionCenterUseCases.getAvailableStock( distributionCenterId7, itemId9 );
344:         int stock11before =
345:                 distributionCenterUseCases.getAvailableStock( distributionCenterId7, itemId11 );
346: 
347:         // when
348:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId5, 2 );
349:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId7, 7 );
350:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId9, 2 );
351:         shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId11, 2 );
352:         shoppingBasketRESTHelper.checkout( shoppingBasketId8, clientName8, CREATED, expectedOrders );
353:         int stock5after =
354:                 distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId5 );
355:         int stock7after =
356:                 distributionCenterUseCases.getAvailableStock( distributionCenterId3, itemId7 );
357:         int stock9after =
358:                 distributionCenterUseCases.getAvailableStock( distributionCenterId7, itemId9 );
359:         int stock11after =
360:                 distributionCenterUseCases.getAvailableStock( distributionCenterId7, itemId11 );
361: 
362:         // then
363:         assertEquals( 2, stock5before - stock5after );
364:         assertEquals( 7, stock7before - stock7after );
365:         assertEquals( 2, stock9before - stock9after );
366:         assertEquals( 2, stock11before - stock11after );
367:     }
368: 
369: 
370: }
371: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingbasket;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.InsufficientStockException;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.DistributionCenterTestHelper;
12: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
13: import thkoeln.archilab.ecommerce.usecases.*;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
16: 
17: 
18: import java.util.Map;
19: import java.util.UUID;
20: 
21: import static org.junit.jupiter.api.Assertions.*;
22: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
23: 
24: @SpringBootTest
25: public class ShoppingBasketTest {
26:     @Autowired
27:     private ClientRegistrationUseCases clientRegistrationUseCases;
28:     @Autowired
29:     private ShoppingBasketUseCases shoppingBasketUseCases;
30:     @Autowired
31:     private ItemCatalogUseCases itemCatalogUseCases;
32:     @Autowired
33:     private DistributionCenterUseCases distributionCenterUseCases;
34:     @Autowired
35:     private OrderUseCases orderUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private ClientTestHelper clientTestHelper;
40:     @Autowired
41:     private ItemTestHelper itemTestHelper;
42:     @Autowired
43:     private DistributionCenterTestHelper distributionCenterTestHelper;
44: 
45:     private EmailType nonExistingEmail;
46: 
47:     @BeforeEach
48:     public void setUp() {
49:         purgatory.deleteEverything();
50:         clientTestHelper.registerAllClients();
51:         itemTestHelper.addAllItems();
52: 
53:         nonExistingEmail = instantiateEmail( "this@nononono.de" );
54:     }
55: 
56: 
57:     @Test
58:     public void testInvalidAddToShoppingBasket() {
59:         // given
60:         UUID nonExistentItemId = UUID.randomUUID();
61:         UUID itemId5 = itemTestHelper.getItemId( 5 );
62:         UUID itemId0 = itemTestHelper.getItemId( 0 );
63:         EmailType clientEmail0 =
64:                 clientTestHelper.getClientEmail( 0 );
65:         distributionCenterTestHelper.addAllDistributionCenters( true );
66: 
67:         // then
68:         assertThrows( ShopException.class,
69:                 () -> shoppingBasketUseCases.addItemToShoppingBasket(
70:                         nonExistingEmail, itemId0, 1 ) );
71:         assertThrows( ShopException.class,
72:                 () -> shoppingBasketUseCases.addItemToShoppingBasket(
73:                         null, itemId0, 1 ) );
74:         assertThrows( ShopException.class,
75:                 () -> shoppingBasketUseCases.addItemToShoppingBasket(
76:                         clientEmail0, nonExistentItemId, 1 ) );
77:         assertThrows( ShopException.class,
78:                 () -> shoppingBasketUseCases.addItemToShoppingBasket(
79:                         clientEmail0, null, 1 ) );
80:         assertThrows( ShopException.class,
81:                 () -> shoppingBasketUseCases.addItemToShoppingBasket(
82:                         clientEmail0, itemId5, -1 ) );
83:     }
84: 
85: 
86:     @Test
87:     public void testInvalidRemoveFromShoppingBasket() {
88:         // given
89:         UUID nonExistentItemId = UUID.randomUUID();
90:         UUID itemId5 = itemTestHelper.getItemId( 5 );
91:         UUID itemId1 = itemTestHelper.getItemId( 1 );
92:         UUID itemId2 = itemTestHelper.getItemId( 2 );
93:         distributionCenterTestHelper.addAllDistributionCenters( true );
94:         EmailType clientEmail0 =
95:                 clientTestHelper.getClientEmail( 0 );
96:         shoppingBasketUseCases.addItemToShoppingBasket(
97:                 clientEmail0, itemId1, 5 );
98:         shoppingBasketUseCases.addItemToShoppingBasket(
99:                 clientEmail0, itemId2, 15 );
100: 
101:         // when
102:         shoppingBasketUseCases.removeItemFromShoppingBasket(
103:                 clientEmail0, itemId1, 2 );
104:         shoppingBasketUseCases.removeItemFromShoppingBasket(
105:                 clientEmail0, itemId2, 4 );
106:         shoppingBasketUseCases.removeItemFromShoppingBasket(
107:                 clientEmail0, itemId2, 7 );
108:         // now we should have 3x itemId1 and 4x itemId2 in the shopping basket
109: 
110:         // then
111:         assertThrows( ShopException.class,
112:                 () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
113:                         clientEmail0, nonExistentItemId, 12 ) );
114:         assertThrows( ShopException.class,
115:                 () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
116:                         nonExistingEmail, itemId5, 12 ) );
117:         assertThrows( ShopException.class,
118:                 () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
119:                         clientEmail0, itemId5, -1 ) );
120:         assertThrows( ShopException.class,
121:                 () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
122:                         clientEmail0, itemId1, 4 ) );
123:         assertThrows( ShopException.class,
124:                 () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
125:                         clientEmail0, itemId2, 5 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testAddRemoveItemsFromAndToShoppingBasket() {
131:         // given
132:         UUID itemId1 = itemTestHelper.getItemId( 1 );
133:         UUID itemId2 = itemTestHelper.getItemId( 2 );
134:         EmailType clientEmail3 =
135:                 clientTestHelper.getClientEmail( 3 );
136:         EmailType clientEmail5 =
137:                 clientTestHelper.getClientEmail( 5 );
138: 
139:         // when client 3 ...
140:         shoppingBasketUseCases.addItemToShoppingBasket(
141:                 clientEmail3, itemId1, 2 );
142:         shoppingBasketUseCases.addItemToShoppingBasket(
143:                 clientEmail3, itemId2, 3 );
144:         shoppingBasketUseCases.removeItemFromShoppingBasket(
145:                 clientEmail3, itemId1, 2 );
146:         shoppingBasketUseCases.addItemToShoppingBasket(
147:                 clientEmail3, itemId1, 1 );
148:         shoppingBasketUseCases.addItemToShoppingBasket(
149:                 clientEmail3, itemId2, 6 );
150:         Map<UUID, Integer> cart3 = shoppingBasketUseCases.getShoppingBasketAsMap( clientEmail3 );
151:         // client3 has 1x itemId1 and 9x itemId2 in cart
152: 
153:         // ... and when client 5 ...
154:         shoppingBasketUseCases.addItemToShoppingBasket(
155:                 clientEmail5, itemId1, 2 );
156:         shoppingBasketUseCases.addItemToShoppingBasket(
157:                 clientEmail5, itemId2, 8 );
158:         shoppingBasketUseCases.removeItemFromShoppingBasket(
159:                 clientEmail5, itemId1, 1 );
160:         shoppingBasketUseCases.addItemToShoppingBasket(
161:                 clientEmail5, itemId2, 2 );
162:         Map<UUID, Integer> cart5 = shoppingBasketUseCases.getShoppingBasketAsMap( clientEmail5 );
163:         // client5 has 1x itemId1 and 10x itemId2 in cart
164: 
165:         // then
166:         assertEquals( 2, cart3.size() );
167:         assertEquals( 1, cart3.get( itemId1 ) );
168:         assertEquals( 9, cart3.get( itemId2 ) );
169: 
170:         assertEquals( 2, cart5.size() );
171:         assertEquals( 1, cart5.get( itemId1 ) );
172:         assertEquals( 10, cart5.get( itemId2 ) );
173:     }
174: 
175: 
176:     @Test
177:     public void testShoppingBasketValue() {
178:         // given
179:         UUID itemId3 = itemTestHelper.getItemId( 3 );
180:         UUID itemId6 = itemTestHelper.getItemId( 6 );
181:         UUID itemId8 = itemTestHelper.getItemId( 8 );
182:         MoneyType price3 = itemTestHelper.getSalesPrice( 3 );
183:         MoneyType price6 = itemTestHelper.getSalesPrice( 6 );
184:         MoneyType price8 = itemTestHelper.getSalesPrice( 8 );
185:         EmailType clientEmail3 =
186:                 clientTestHelper.getClientEmail( 3 );
187: 
188:         // when
189:         shoppingBasketUseCases.addItemToShoppingBasket( clientEmail3, itemId3, 3 );
190:         shoppingBasketUseCases.addItemToShoppingBasket( clientEmail3, itemId6, 2 );
191:         shoppingBasketUseCases.addItemToShoppingBasket( clientEmail3, itemId8, 5 );
192:         // client3 has 3x itemId3, 2x itemId6 and 5x itemId8 in cart
193:         MoneyType cartValue = shoppingBasketUseCases.getShoppingBasketAsMoneyValue( clientEmail3 );
194: 
195:         // then
196:         assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
197:                 cartValue );
198:     }
199: 
200: 
201:     @Test
202:     public void testShoppingBasketValueInvalid() {
203:         // given
204:         // when
205:         // then
206:         assertThrows( ShopException.class,
207:                 () -> shoppingBasketUseCases.getShoppingBasketAsMoneyValue( nonExistingEmail ) );
208:     }
209: 
210: 
211:     @Test
212:     public void testUnsuccessfulCheckout() {
213:         // given client buying item 0 (which is not in stock), and client 1 buying item 1
214:         // in a bigger quantity (11) than available (10)
215:         distributionCenterTestHelper.addAllDistributionCenters( true );
216:         EmailType clientEmail0 =
217:                 clientTestHelper.getClientEmail( 0 );
218:         EmailType clientEmail1 =
219:                 clientTestHelper.getClientEmail( 1 );
220:         UUID itemId0 = itemTestHelper.getItemId( 0 );
221:         UUID itemId1 = itemTestHelper.getItemId( 1 );
222: 
223:         // when
224:         shoppingBasketUseCases.addItemToShoppingBasket(
225:                 clientEmail0, itemId0, 1 );
226:         shoppingBasketUseCases.addItemToShoppingBasket(
227:                 clientEmail1, itemId1, 11 );
228: 
229:         // then
230:         assertThrows( InsufficientStockException.class,
231:                 () -> shoppingBasketUseCases.checkout( clientEmail0 ) );
232:         assertThrows( InsufficientStockException.class,
233:                 () -> shoppingBasketUseCases.checkout( clientEmail1 ) );
234:     }
235: 
236: }
237: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
1: package thkoeln.archilab.ecommerce.tests.testtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.domain.JavaMethod;
6: import com.tngtech.archunit.core.importer.ClassFileImporter;
7: import com.tngtech.archunit.lang.ArchRule;
8: import org.junit.jupiter.api.BeforeEach;
9: import org.junit.jupiter.api.Test;
10: import org.springframework.web.bind.annotation.RestController;
11: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
12: import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
13: import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingBasketRESTTest;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
18: 
19: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
20: import static org.springframework.test.util.AssertionErrors.assertTrue;
21: 
22: /**
23:  * This test checks if there are the appropriate tests in the test class(es) for domain
24:  * primitives.
25:  */
26: 
27: public class RulesForOwnTests {
28:     private JavaClass dpTestClass, restTestClass;
29:     private JavaClasses dpTestClasses, restTestClasses;
30:     private static final String DISTRIBUTION_CENTER_DOMAIN_PACKAGE =
31:             "thkoeln.archilab.ecommerce.solution.distributioncenter.domain";
32:     private static final String DISTRIBUTION_CENTER_CLASS_NAME =
33:             DISTRIBUTION_CENTER_DOMAIN_PACKAGE + ".DistributionCenter";
34: 
35: 
36:     @BeforeEach
37:     public void setUp() throws Exception {
38:         dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
39:         restTestClass = new ClassFileImporter().importClass( OwnShoppingBasketRESTTest.class );
40: 
41:         dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
42:         restTestClasses = new ClassFileImporter().importClasses( OwnShoppingBasketRESTTest.class );
43:     }
44: 
45: 
46:     @Test
47:     public void ensureMinimumNumberOfTestMethods() {
48:         // given
49:         // when
50:         int dpTestMethodCount = getTestMethodCount( dpTestClass );
51:         int restTestMethodCount = getTestMethodCount( restTestClass );
52: 
53:         // then
54:         assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
55:                         + dpTestMethodCount,dpTestMethodCount >= 2 );
56:         assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
57:                         + restTestMethodCount, restTestMethodCount >= 5 );
58:     }
59: 
60:     private int getTestMethodCount( JavaClass testClass ) {
61:         int testMethodCount = 0;
62:         for ( JavaMethod method : testClass.getMethods() ) {
63:             if ( isTestMethod( method ) ) {
64:                 testMethodCount++;
65:             }
66:         }
67:         return testMethodCount;
68:     }
69: 
70:     private boolean isTestMethod( JavaMethod method ) {
71:         return method.isAnnotatedWith( Test.class );
72:     }
73: 
74: 
75:     @Test
76:     public void dpTestsShouldReferenceTheRightClasses() {
77:         ArchRule rule = classes()
78:                 .should().dependOnClassesThat()
79:                 .areAssignableTo( ZipCodeType.class )
80:                 .andShould().dependOnClassesThat()
81:                 .areAssignableTo( MoneyType.class )
82:                 .andShould().dependOnClassesThat()
83:                 .areAssignableTo( PhysicalAddressType.class )
84:                 .andShould().dependOnClassesThat()
85:                 .areAssignableTo( EmailType.class )
86:                 .because( "DomainPrimitiveJSONSerializationTest should reference ZipCode, " +
87:                         "Money, Email, and PhysicalAddress!" );
88:         rule.check( dpTestClasses );
89:     }
90: 
91: 
92:     @Test
93:     public void restTestsShouldReferenceEmail() {
94:         ArchRule rule = classes()
95:                 .should().dependOnClassesThat()
96:                 .areAssignableTo( EmailType.class )
97:                 .because( "DistributionCenterComparatorUnitTest should reference EmailType!" );
98:         rule.check( restTestClasses );
99:     }
100: 
101: 
102:     @Test
103:     public void restTestsShouldReferenceRESTControllers() {
104:         ArchRule rule = classes()
105:                 .should().dependOnClassesThat()
106:                 .areAnnotatedWith( RestController.class )
107:                 .orShould().dependOnClassesThat()
108:                 .areAssignableTo( ShoppingBasketRESTHelper.class )
109:                 .because( "DistributionCenterComparatorUnitTest should call REST controllers! " +
110:                         "(either directly or via the ShoppingBasketRESTHelper REST helper)" );
111:         rule.check( restTestClasses );
112:     }
113: 
114: }
115: 

[RESPONSE]:
**Smell-Report:**

---

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java**  
Money [Zeile(n) 88-92]: Dead Code : Debug-Ausgaben in der equals-Methode sind für den Produktivbetrieb unnötig und sollten entfernt werden.

Money [Zeile(n) 88-92]: Duplication (Original: Zeile 90-91) : Die Debug-Ausgaben in equals() duplizieren die Logik der toString()-Darstellung.

---

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java**  
ZipCode [Zeile(n) 64-87]: Dead Code : Die Methoden calculateDifference() und areAdjacent() werden nicht verwendet (die difference()-Methode implementiert eine andere Logik).

---

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientAdapterHelper.java**  
ClientAdapterHelper [Zeile(n) 10-22]: Duplication (Original: Zeile 10-15) : Die Methoden convertToEmail() und convertToPhysicalAddress() sind strukturell identisch und könnten in einer generischen Methode zusammengefasst werden.

---

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientRegistrationService.java**  
ClientRegistrationService [Zeile(n) 34-35, 51-52, 65-66]: Duplication (Original: Zeile 34-35) : Die Konvertierung von EmailType/PhysicalAddressType zu Email/PhysicalAddress erfolgt mehrfach (register, changeAddress, getClientData) und könnte in eine separate Methode ausgelagert werden.

---

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\Client.java**  
Client: Anemic Entity : Die Klasse besteht nur aus Gettern/Settern ohne Domain-Logik.

---

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\Shoppable.java**  
Shoppable [Zeile(n) 9-18]: Dead Code : Die abstrakte Klasse wird nicht erweitert oder verwendet (keine Referenzen im Code).

---

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\application\DistributionCenterService.java**  
DistributionCenterService [Zeile(n) 57-84]: Dead Code : Die Methode findSuitableDistributionCenter() wird nicht aufgerufen (keine Referenzen).

---

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\DistributionCenter.java**  
DistributionCenter [Zeile(n) 42-55]: Dead Code : Die Methode fulfillableShoppingBasketPositions() wird nicht aufgerufen (keine Referenzen).  
DistributionCenter [Zeile(n) 33]: Dead Code : Das transiente Feld "stock" wird nur in der ungenutzten Methode fulfillableShoppingBasketPositions() verwendet.

---

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\Item.java**  
Item: Anemic Entity : Die Klasse besteht nur aus Gettern/Settern ohne Domain-Logik.

---

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java**  
Order: Anemic Entity : Die Klasse besteht nur aus Gettern/Settern ohne Domain-Logik.

---

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPosition.java**  
OrderPosition: Anemic Entity : Die Klasse besteht nur aus Gettern/Settern ohne Domain-Logik.

---

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java**  
ShoppingBasketController [Zeile(n) 163-200]: Missplaced Responsibility : Die Logik zur Auswahl des geeigneten Distribution Centers (findBestDistributionCenter) gehört in den Service-Layer (ShoppingBasketService), nicht in den Controller.  
ShoppingBasketController [Zeile(n) 202-214]: Missplaced Responsibility : Die Logik zur Verarbeitung der Bestellungen (processOrdersAndClearBasket) gehört in den Service-Layer.

---

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java**  
ShoppingBasket: Anemic Entity : Die Klasse besteht nur aus Gettern/Settern ohne Domain-Logik.

---

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java**  
ShoppingBasketPosition: Anemic Entity : Die Klasse besteht nur aus Gettern/Settern ohne Domain-Logik.

---

**ENDE**
Generated by deepseek-reasoner
-----------------------------------