--- DATE: 8.1.2026, 19:14:57 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
    Architektur: 4-Layer (Eric Evans).
    Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
    Regeln:
    1. Begründe kurz jeden Fund.
    4. Gruppiere nach Datei (mit Pfad). 
    2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
    3. Keine Code-Wiederholung, nur Referenzen.
    5. Wenn fertig, schreibe "ENDE".



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Address.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import jakarta.persistence.Embeddable;
import jakarta.persistence.Embedded;
import lombok.Getter;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import java.util.Objects;

@Embeddable
@Getter
public class Address implements AddressType {

    private final String street;
    private final String city;
    //@Convert(converter = ZipCodeConverter.class)
    @Embedded
    private final ZipCode zipCode;


    public Address(String street, String city, ZipCodeType zipCode) {
        this.street = street;
        this.city = city;
        this.zipCode =(ZipCode) zipCode;
    }

    protected Address() {
        this.street = null;
        this.city = null;
        this.zipCode = null;
    }


    /**
     * @return the street as a string
     */
    @Override
    public String getStreet() {
        return this.street;
    }

    /**
     * @return the city as a string
     */
    @Override
    public String getCity() {
        return this.city;
    }

    /**
     * @return the zip code
     */
    @Override
    public ZipCodeType getZipCode() {
        return this.zipCode;
    }

     public static AddressType of( String street, String city, ZipCodeType zipCode ) throws ShopException {
         if(street == null || street.isEmpty()) {
             throw new ShopException("street is null or empty");
         }
         if(city == null || city.isEmpty()) {
             throw new ShopException("city is null or empty");
         }
         if(zipCode == null) {
             throw new ShopException("zipCode is null");
         }
         return new Address( street, city, zipCode );
     }
     @Override
     public boolean equals( Object o ) {
        if(this == o) { return true; }
        if(o == null || getClass() != o.getClass()) { return false; }
        Address that = (Address) o;
        return street.equals(that.street) && city.equals(that.city) && zipCode.equals(that.zipCode);
    }
    @Override
    public int hashCode() {
        return Objects.hash(street, city, zipCode);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\EmailAddress.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.Embeddable;
import lombok.Getter;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Objects;


@Embeddable
@Getter
public class EmailAddress implements EmailAddressType {

    @JsonProperty("emailAddressString")
    private final String emailAddress;

    public EmailAddress(String emailAddress) {
        this.emailAddress = emailAddress;
    }

    protected EmailAddress() {
        this.emailAddress = null;
    }

    /**
     * @return the email address as a string
     */
    @Override
    public String toString() {
        return emailAddress;
    }

    @Override
    public EmailAddressType sameIdentifyerDifferentDomain(String domainString) throws ShopException {
        if(domainString.isEmpty()){
            throw new ShopException("Domain is empty");
        }

        int j=0;
        for (char c : emailAddress.toCharArray()) {
            if(c=='@') {
                break;
            }
            j++;
        }

        String tmp=emailAddress.substring(0,j+1).concat(domainString);
        //System.out.println("sameIdentifyerDifferentDomain"+tmp);
        if(isInvalidEmailAddress(tmp)) {
            throw new ShopException("Invalid email address");
        }
        return new EmailAddress(tmp);
    }


    @Override
    public EmailAddressType sameDomainDifferentIdentifyer(String identifyerString) throws ShopException {
        int j=0;
        for (char c : emailAddress.toCharArray()) {
            if(c=='@') {
                break;
            }
            j++;
        }

        String tmp=identifyerString.concat(emailAddress.substring(j));
       // System.out.println("sameDomainDifferentIdentifyer"+tmp);
        if(isInvalidEmailAddress(tmp)) {
            throw new ShopException("Invalid email address");
        }
        return new EmailAddress(tmp);
    }

    public static EmailAddressType of( String emailAddressAsString ) {
        if (emailAddressAsString==null || emailAddressAsString.isEmpty()) {
            throw new GenericUnprocessableEntityException("email address cannot be null");
        }
        if (!emailAddressAsString.matches("^[a-zA-Z0-9]+(?:\\.(?!\\.)[a-zA-Z0-9]+)*@[a-zA-Z0-9]+(?:\\.(?!\\.)[a-zA-Z0-9]+)*\\.(?:de|at|ch|com|org)$")) {
            throw new GenericUnprocessableEntityException("Invalid email address");
        }

        return new EmailAddress(emailAddressAsString);
    }
    public boolean isInvalidEmailAddress(String emailAddress) {
        if (emailAddress == null || emailAddress.isEmpty()) {
            return true;
        }
       // System.out.println("printing email:"+emailAddress);
        return !emailAddress.matches("^[a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)*@[a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)*\\.(?:de|at|ch|com|org)$");
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EmailAddress that = (EmailAddress) o;
        return emailAddress.equals(that.emailAddress);
    }

    @Override
    public int hashCode() {
        return Objects.hash(emailAddress);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\GenericConflictException.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.InsufficientStockException;


@ResponseStatus(HttpStatus.CONFLICT)
public class GenericConflictException extends InsufficientStockException {
    public GenericConflictException(String message) {
        super(message);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\GenericNotFoundException.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code= HttpStatus.NOT_FOUND, reason ="object not found")
public class GenericNotFoundException  extends ShopException {
    public GenericNotFoundException(String message) {
        super(message);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\GenericUnprocessableEntityException.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;


@ResponseStatus (value = HttpStatus.UNPROCESSABLE_ENTITY,reason = "Invalid Parameters")
public class GenericUnprocessableEntityException extends ShopException {
    public GenericUnprocessableEntityException(String message) {
        super(message);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\InternalCustomerDto.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.usecases.CustomerType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Objects;

@Setter
@Getter
public class InternalCustomerDto implements CustomerType {
    private String name;
    private AddressType address;
    private EmailAddressType email;
    public InternalCustomerDto(String name, AddressType address, EmailAddressType email) {
        this.name = name;
        this.address = address;
        this.email = email;
    }

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public EmailAddressType getEmailAddress() {
        return this.email;
    }
    @Override
    public AddressType getAddress() {
        return this.address;
    }

    public boolean equals( Object o ) {
        if(this == o) { return true; }
        if(o == null || getClass() != o.getClass()) { return false; }
        InternalCustomerDto that = (InternalCustomerDto) o;
        return name.equals(that.name) && email.equals(that.email) && address.equals(that.address);
    }
    @Override
    public int hashCode() {
        return Objects.hash(name,email,address);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import jakarta.persistence.Embeddable;
import lombok.Getter;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.Objects;

@Embeddable
@Getter
public class Money implements MoneyType {
    private final Float amount;
    private final String currencyUnit;

    public Money(Float amount, String currencyUnit) throws ShopException {
        if (amount == null || amount < 0) {
            throw new ShopException("Amount cannot be negative or Null");
        }
        if (currencyUnit == null) {
            throw new ShopException("CurrencyUnit cannot be null");
        }
        if (!currencyUnit.equals("EUR") && !currencyUnit.equals("CHF")) {
            throw new ShopException("CurrencyUnit must be EUR or CHF");
        }
        this.amount = amount;
        this.currencyUnit = currencyUnit;

    }
    protected Money() {
        this.amount = null;
        this.currencyUnit = null;
    }


    @Override
    public Float getAmount() {
        return amount;
    }

    @Override
    public String getCurrencyUnit() {
        return currencyUnit;
    }

    @Override
    public MoneyType add(MoneyType otherMoney) throws ShopException {
        if (otherMoney == null  || !Objects.equals(otherMoney.getCurrencyUnit(), this.getCurrencyUnit())) {
            throw new ShopException("Cannot add money to " + this.getCurrencyUnit());
        }
        return new Money(this.amount + otherMoney.getAmount(), this.currencyUnit);
    }

    @Override
    public MoneyType subtract(MoneyType otherMoney) {
        if (otherMoney == null  || !Objects.equals(otherMoney.getCurrencyUnit(), this.getCurrencyUnit())) {
            throw new ShopException("Cannot subtract money from " + this.getCurrencyUnit());
        }
        if (otherMoney.getAmount() > this.getAmount()) {
            throw new ShopException("Cannot subtract more money than owned: " + this.getAmount() + ", subtracted amount:" + otherMoney.getAmount());
        }
        return new Money(this.amount - otherMoney.getAmount(), this.currencyUnit);
    }

    @Override
    public MoneyType multiplyBy(int factor) {
        if (factor < 0) {
            throw new ShopException("Cannot multiply money by negative factor");
        }
        return new Money(this.amount * factor, this.currencyUnit);
    }

    @Override
    public boolean largerThan(MoneyType otherMoney) {
        if (otherMoney == null  || !Objects.equals(otherMoney.getCurrencyUnit(), this.getCurrencyUnit())) {
            throw new ShopException("Cannot compare money to " + this.getCurrencyUnit());
        }

        return this.amount > otherMoney.getAmount();
    }

    public static MoneyType of(Float amount, String currencyUnit) throws ShopException {
        return new Money(amount, currencyUnit);
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Money money = (Money) o;
        return Objects.equals(amount, money.amount) && currencyUnit.equals(money.currencyUnit);
    }
    @Override
    public int hashCode() {
        return Objects.hash(amount, currencyUnit);
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.Embeddable;
import lombok.Getter;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import java.util.Objects;

@Embeddable
@Getter
public class ZipCode implements ZipCodeType {
    @JsonProperty("zipCodeString")
    private final String zipCode;
    public ZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    protected ZipCode() {
        this.zipCode = null;
    }

    @Override
    public String toString() {
        return zipCode;
    }

    @Override
    public int difference(ZipCodeType otherZipCode) {
        if(otherZipCode==null) {
            throw new ShopException("ZipCode cannot be null");
        }
        String otherZipCodeAsString=otherZipCode.toString();
        String thisZipCodeAsString=this.toString();

        if (otherZipCodeAsString.equals(thisZipCodeAsString)) {
            return 0;
        }
        int differentAt=0;
        char[] charArray = thisZipCodeAsString.toCharArray();


        for (int i = 0; i < 5; i++) {
            if (thisZipCodeAsString.charAt(i) != otherZipCodeAsString.charAt(i)) {
                differentAt = i + 1;
                break; // Found the first difference, no need to check further
            }
        }
        int x=6;
        differentAt =x-differentAt;

        int firstDigitThis = getFirstDigitZipCode();
        int firstDigitOther = Character.getNumericValue(otherZipCodeAsString.charAt(0));

        int distanceFirstDigit = 0;
        if (firstDigitThis != firstDigitOther) {
            int diff = Math.abs(firstDigitOther - firstDigitThis);
            distanceFirstDigit = Math.min(diff, 10 - diff);
        }
        return differentAt + distanceFirstDigit*10;
    }

    @Override
    public Integer getFirstDigitZipCode() {
        return Integer.valueOf(zipCode.substring(0,1));
    }


    public static ZipCodeType of( String zipCodeAsString ) {
        if ( zipCodeAsString == null || zipCodeAsString.isEmpty() ) {
            throw new ShopException("Zip code is empty");
        }
        if(!zipCodeAsString.matches("\\d{5}")) {
            throw new ShopException("Zip code is not a valid zip code");
        }
        if(zipCodeAsString.endsWith("0000")) {
            throw new ShopException("Zip code ends with a valid zip code");
        }
        return new ZipCode(zipCodeAsString);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ZipCode that = (ZipCode) o;
        return zipCode.equals(that.zipCode);
    }

    @Override
    public int hashCode() {
        return Objects.hash(zipCode);
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
/*
 * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
 */
package thkoeln.archilab.ecommerce;

import jakarta.persistence.Column;
import jakarta.persistence.MappedSuperclass;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

import java.io.Serializable;
import java.util.UUID;

@MappedSuperclass
@Getter
@EqualsAndHashCode(of = "id")
@ToString(of = "id")
public abstract class GenericId implements Serializable {
    @Column(nullable = false, updatable = false)
    private final UUID id;

    protected GenericId() {
        this( UUID.randomUUID() );
    }

    protected GenericId( UUID id ) {
        this.id = id;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
/*
 * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
 */
package thkoeln.archilab.ecommerce;

import jakarta.persistence.AttributeConverter;

import java.util.UUID;
import java.util.function.Function;


public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
    private final Function<UUID, T> factory;

    protected GenericIdConverter( Function<UUID, T> factory ) {
        this.factory = factory;
    }

    @Override
    public UUID convertToDatabaseColumn( T attribute ) {
        return attribute == null ? null : attribute.getId();
    }

    @Override
    public T convertToEntityAttribute( UUID dbData ) {
        return dbData == null ? null : factory.apply( dbData );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\InsufficientStockException.java ---
/*
 * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
 */
package thkoeln.archilab.ecommerce;

/**
 * Exception is thrown if the product's stock level is not sufficient to serve the order.
 */
public class InsufficientStockException extends ShopException {
    public InsufficientStockException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
/*
 * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
 */
package thkoeln.archilab.ecommerce;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class ProjectApplication {

	/**
	 * Entry method
	 * @param args
	 */
	public static void main(String[] args) {
		SpringApplication.run(ProjectApplication.class, args);
	}
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
/*
 * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
 */
package thkoeln.archilab.ecommerce;

public class ShopException extends RuntimeException {
    public ShopException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerController.java ---
package thkoeln.archilab.ecommerce.solution.customer.application;


import lombok.extern.slf4j.Slf4j;
import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.InternalCustomerDto;
import org.springframework.http.HttpStatus;
import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;

import java.util.List;

@Slf4j
@RestController
@RequestMapping("/customers")
public class CustomerController {
    private final CustomerRegistrationService customerRegistrationService;

    @Autowired
    public CustomerController(CustomerRegistrationService customerRegistrationService) {
        this.customerRegistrationService = customerRegistrationService;
    }
    @GetMapping
    public ResponseEntity<List<CustomerDto>> getCustomers() {
        return new ResponseEntity<>(null,HttpStatus.METHOD_NOT_ALLOWED);
    }

    @GetMapping(params = "emailAddress")
    public ResponseEntity<CustomerDto> getCustomerByEmail(@RequestParam("emailAddress") String emailAddress) {
        if(emailAddress == null) {
            return new ResponseEntity<>(HttpStatus.METHOD_NOT_ALLOWED);
        }
        EmailAddress email = (EmailAddress) EmailAddress.of(emailAddress);
        Customer customer = customerRegistrationService.findByEmail(email);
        if (customer == null) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
        ModelMapper modelMapper = new ModelMapper();
        CustomerDto customerDto = modelMapper.map(customer, CustomerDto.class);
        return new ResponseEntity<>(customerDto, HttpStatus.OK);
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerDto.java ---
package thkoeln.archilab.ecommerce.solution.customer.application;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;

import java.util.UUID;


@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
public class CustomerDto {
    private UUID id;
    private String name;
    private EmailAddress emailAddress;
    private Address address;

    public static CustomerDto fromCustomerDto(CustomerDto customerDto) {
        CustomerDto customerDto1 = new CustomerDto();
        customerDto1.setId(customerDto.getId());
        customerDto1.setName(customerDto.getName());
        customerDto1.setEmailAddress(customerDto.getEmailAddress());
        customerDto1.setAddress(customerDto.getAddress());
        return customerDto1;
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerRegistrationAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.customer.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.domainprimitives.InternalCustomerDto;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.CustomerType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

@Service
public class CustomerRegistrationAdapterService implements CustomerRegistrationUseCases {

    private final CustomerRegistrationService customerRegistrationService;
    public CustomerRegistrationAdapterService(CustomerRegistrationService customerRegistrationService) {
        this.customerRegistrationService = customerRegistrationService;
    }

    @Override
    public void register(String name, EmailAddressType emailAddress, AddressType address) {
        if (name == null || emailAddress == null || address == null) {
            throw new ShopException("Name or CustomerEmailAddress or address cannot be null");
        }
        customerRegistrationService.register(name, emailAddress.toString(), address.getStreet(), address.getCity(), (ZipCode) address.getZipCode());
    }

    @Override
    public void changeAddress(EmailAddressType customerEmailAddress, AddressType address)throws ShopException {
        if (customerEmailAddress == null || address == null) {
            throw new ShopException("CustomerEmailAddress or address cannot be null");
        }
        customerRegistrationService.changeAddress(customerEmailAddress.toString(), address.getStreet(), address.getCity(), (ZipCode) address.getZipCode());

    }
    @Override
    public CustomerType getCustomerData(EmailAddressType customerEmailAddress)throws ShopException {
        String[] data= customerRegistrationService.getCustomerData(customerEmailAddress.toString());

        //Maybe wrap into an If-Statement when i return null, not sure if that branch is ever taken though.
        AddressType address = new Address(data[2],data[3],new ZipCode(data[4]));
        EmailAddressType email = new EmailAddress(data[1]);
        return new InternalCustomerDto(data[0],address,email);
    }



    @Override
    public void deleteAllCustomers() {
        customerRegistrationService.deleteAllCustomers();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerRegistrationService.java ---
package thkoeln.archilab.ecommerce.solution.customer.application;

import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.*;
import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerRepository;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Optional;
import java.util.UUID;

@Service
public class CustomerRegistrationService {

    private final CustomerRepository customerRepository;
    @Autowired
    public CustomerRegistrationService(CustomerRepository customerRepository) {
        this.customerRepository = customerRepository;
    }


    public void register(String name, String emailAddress, String street, String city, ZipCode zipCode) {
        if(areFieldsInvalid(name, emailAddress, street, city, zipCode.toString())) {
            throw new GenericUnprocessableEntityException("Invalid Parameterrrrr");
        }

        if(!isValidZipCode(zipCode.toString())) {
            throw new GenericUnprocessableEntityException("Invalid Zipcode");
        }
        EmailAddress email = (EmailAddress) EmailAddress.of(emailAddress);
        if(customerRepository.findByEmail(email).isPresent()) {
            throw new GenericConflictException("Customer already exists");
        }
        Customer newCustomer = new Customer();
        Address address = (Address) Address.of(street,city,zipCode);
        CustomerId customerId = new CustomerId(UUID.randomUUID());

        newCustomer.setCustomerId(customerId);
        newCustomer.setName(name);
        newCustomer.setEmail(email);
        newCustomer.setAddress(address);
        customerRepository.save(newCustomer);
    }


    public void changeAddress(String customerEmailAddress, String street, String city, ZipCode zipCode) {
        if(areFieldsInvalid(customerEmailAddress, street, city, zipCode.toString())) {
            throw new GenericUnprocessableEntityException("Invalid Parameter(s)");
        }
        EmailAddressType email = EmailAddress.of(customerEmailAddress);
        Optional<Customer> optionalCustomer = customerRepository.findByEmail(email);
        if(optionalCustomer.isPresent()) {
            Customer customer = optionalCustomer.get();
            Address newAddress = (Address) Address.of(street,city,zipCode);
            customer.setAddress(newAddress);
            customerRepository.save(customer);
        } else {
            throw new GenericNotFoundException("Customer with email address " + customerEmailAddress + " does not exist");
        }

    }


    public String[] getCustomerData(String customerEmailAddress) throws ShopException {
        EmailAddressType email = EmailAddress.of(customerEmailAddress);
        if(customerRepository.findByEmail(email).isPresent()) {
            Customer customer=customerRepository.findByEmail(email).get();
            Address address = customer.getAddress();
            if(address !=null) {
                return new String[]{
                        customer.getName(),
                        String.valueOf(customer.getEmail()),
                        address.getStreet(),
                        address.getCity(),
                        String.valueOf(address.getZipCode())
                };
            } else {
                System.out.println("Are we ever here?");
                return new String[]{
                        customer.getName(),
                        String.valueOf(customer.getEmail()),
                        null,
                        null,
                        null

                };
            }
        } else
            throw new GenericNotFoundException("Customer with email address " + customerEmailAddress + " does not exists");
    }
    public Customer findByEmail(EmailAddress customerEmailAddress) throws ShopException {
        if (customerRepository.findByEmail(customerEmailAddress).isPresent()) {

            Customer customer = customerRepository.findByEmail(customerEmailAddress).get();
            Address address = customer.getAddress();
            if (address != null) {
                return customer;


            }
        }
        throw new GenericNotFoundException("Customer with email address " + customerEmailAddress + " does not exists");
    }
    public Customer findByCustomerId(CustomerId customerId) throws ShopException {
       return customerRepository.findByCustomerId(customerId).orElseThrow(()->new GenericNotFoundException("Customer with id " + customerId + " does not exists"));
    }
    @Transactional
    public void deleteAllCustomers() {
        customerRepository.deleteAll();
    }

    public boolean areFieldsInvalid(String... fields) {
        for (String field : fields) {
            if (field == null || field.isEmpty()) {
                return true;
            }
        }
        return false;
    }
    public boolean isValidZipCode(String zipCode) {
        return zipCode.matches("\\d{5}");
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\Customer.java ---
package thkoeln.archilab.ecommerce.solution.customer.domain;

import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import lombok.AccessLevel;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
import thkoeln.archilab.ecommerce.usecases.CustomerType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

@Entity
public class Customer implements CustomerType {

    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private CustomerId customerId;

    //@Convert(converter = EmailAddressConverter.class)
    private EmailAddress email;
    private String name;


    private Address address;

    public Customer() {}
    public Customer(CustomerId customerId,EmailAddressType email, String name, Address address) {
        this.customerId = customerId;
        this.email = (EmailAddress) email;
        this.name = name;
        this.address = address;


    }
    public CustomerId getCustomerId() { return customerId; }
    public void setCustomerId(CustomerId customerId) { this.customerId = customerId; }

    public EmailAddress getEmail() { return email; }
    public void setEmail(EmailAddress email) { this.email = email; }

    public String getName() { return name; }

    @Override
    public EmailAddressType getEmailAddress() {
        return this.email;
    }

    public void setName(String name) { this.name = name; }

    public Address getAddress() {
        return new Address(address.getStreet(), address.getCity(), address.getZipCode());
    }
    public void setAddress(Address address) { this.address = address; }
    public void updateAddress(String street, String city, ZipCode zipCode) {
        this.address = new Address(street,city,zipCode);
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\CustomerId.java ---
package thkoeln.archilab.ecommerce.solution.customer.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;


@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "CustomerId"))
public class CustomerId extends GenericId {
    public CustomerId(UUID customerId) {
        super(customerId);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\CustomerIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.customer.domain;


import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;


@Converter(autoApply = true)
public class CustomerIdConverter extends GenericIdConverter<CustomerId> {
    public CustomerIdConverter() {
        super(CustomerId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\CustomerRepository.java ---
package thkoeln.archilab.ecommerce.solution.customer.domain;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Optional;

@Repository
public interface CustomerRepository extends JpaRepository<Customer,CustomerId> {
    Optional<Customer> findByEmail(EmailAddressType email);
    Optional<Customer> findByCustomerId(CustomerId customerId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.order.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.usecases.OrderUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Service
public class OrderAdapterService implements OrderUseCases {

    private final OrderService orderService;
    public OrderAdapterService(OrderService orderService) {
        this.orderService = orderService;
    }

    @Override
    public Map<UUID, Integer> getOrderHistory(EmailAddressType customerEmailAddress) throws ShopException {
        if (customerEmailAddress == null) { throw new ShopException("customerEmailAddress is null"); }
        Map<ProductId, Integer> orderHistory = orderService.getOrderHistory(customerEmailAddress.toString());
        Map<UUID, Integer> newOrderHistory = new HashMap<>();
        for (ProductId productId : orderHistory.keySet()) {
            newOrderHistory.put(productId.getId(), orderHistory.get(productId));
        }
        return newOrderHistory;
    }

    /**
     * @param orderId   - the id of the order to be checked
     * @param productId - the id of the product for which we want to know the quantity
     * @return the number of products in a given order. If the product is not a part of the order, the method
     * returns 0. No exception is thrown.
     * @throws ShopException if
     *                       - orderId is null, or doesn't exist in the system
     *                       - productId is null, or doesn't exist in the system
     */
    @Override
    public Integer getOrderQuantForProduct(UUID orderId, UUID productId) {
        if (orderId == null || productId == null) { throw new ShopException("orderId and productId is null"); }
        OrderId orderToCheck = new OrderId(orderId);
        ProductId productToCheck = new ProductId(productId);
        return orderService.getOrderQuantForProduct(orderToCheck, productToCheck);
    }

    /**
     * @param orderId - the id of the order to be checked
     * @return the id of the storage unit that is responsible for the given order
     * @throws ShopException if
     *                       - orderId is null, or doesn't exist in the system
     */
    @Override
    public UUID getStorageUnitIdForOrder(UUID orderId) {
        OrderId orderToCheck = new OrderId(orderId);
        return orderService.getStorageUnitIdForOrder(orderToCheck).getId();
    }

    @Override
    public void deleteAllOrders() {

        orderService.deleteAllOrders();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderDto.java ---
package thkoeln.archilab.ecommerce.solution.order.application;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.List;
import java.util.UUID;

@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
public class OrderDto {
    private UUID id;
    private String customerName;
    private UUID storageUnitId;
    private List<OrderPartDto> parts;
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderPartDto.java ---
package thkoeln.archilab.ecommerce.solution.order.application;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.UUID;


@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
public class OrderPartDto {
    private UUID productId;
    int quantity;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderQueryService.java ---
package thkoeln.archilab.ecommerce.solution.order.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderPart;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderPartRepository;
import thkoeln.archilab.ecommerce.solution.product.application.ProductUsageInOrdersChecker;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.product.dto.ReferencedOrderPart;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class OrderQueryService implements ProductUsageInOrdersChecker {

    private final OrderPartRepository orderPartRepository;
    public OrderQueryService(OrderPartRepository orderPartRepository) {
        this.orderPartRepository = orderPartRepository;
    }

    @Override
    public boolean isProductInAnyOrder(Product product) {
        return orderPartRepository.existsByProduct(product);
    }

    @Override
    public List<ReferencedOrderPart> findOrderPartsByProduct(Product product) {
        return orderPartRepository.findByProduct(product).stream()
                .map(orderPart ->  new ReferencedOrderPart(orderPart.getProduct().getProductId()))
                .collect(Collectors.toList());
    }

    @Override
    public void deleteAllOrderParts(Iterable<ReferencedOrderPart> referencedParts) {
        List<OrderPart> partsToDelete = orderPartRepository.findAll();
        if (!partsToDelete.isEmpty()) {
            orderPartRepository.deleteAll(partsToDelete);
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderService.java ---
package thkoeln.archilab.ecommerce.solution.order.application;

import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.GenericNotFoundException;
import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerRepository;
import thkoeln.archilab.ecommerce.solution.order.domain.*;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.*;

@Service
public class OrderService {


    private final OrderRepository orderRepository;
    private final CustomerRepository customerRepository;
    private final OrderPartRepository orderPartRepository;


    @Autowired
    public OrderService(OrderRepository orderRepository, CustomerRepository customerRepository, OrderPartRepository orderPartRepository) {
        this.orderRepository = orderRepository;
        this.customerRepository = customerRepository;
        this.orderPartRepository = orderPartRepository;
    }
    public Integer getOrderQuantForProduct(OrderId orderId, ProductId productId) {
        if (orderId == null || productId == null) {
            throw new ShopException("Order id or product id is null");
        }
        Optional<Order> orderOptional = orderRepository.findById(orderId);
        Order order = orderOptional.orElseThrow(() -> new ShopException("Order not found"));
        List<OrderPart> orderParts = orderPartRepository.findByOrder(order);

        Optional<OrderPart> orderPartOptional = orderParts.stream()
                .filter(part -> part.getProduct().getProductId().equals(productId))
                .findFirst();
        return orderPartOptional.map(OrderPart::getQuantity).orElse(0);
    }
    public StorageUnitId getStorageUnitIdForOrder(OrderId orderId) {
        if (orderId ==null) {
            throw new ShopException("OrderId cannot be null");
        }
        Optional<Order> orderOptional = orderRepository.findById(orderId);
        Order order = orderOptional.orElseThrow(() -> new ShopException("Order not found"));
        return order.getStorageUnitId();
    }
    public Map<ProductId,Integer> getOrderHistory( String customerEmailAddress) {
        if (customerEmailAddress!= null && !customerEmailAddress.isEmpty()) {
            Map<ProductId,Integer> orderHistory = new HashMap<>();
            EmailAddressType email = EmailAddress.of(customerEmailAddress);
            Optional<Customer> customer = customerRepository.findByEmail(email);
            if (customer.isEmpty()) {
                throw new ShopException("Customer not found");
            }
            CustomerId customerId = customer.get().getCustomerId();
            List<Order> orders = orderRepository.findByCustomerId(Optional.ofNullable(customerId));

            if(orders != null && !orders.isEmpty()) {
                for (Order order : orders) {
                    List<OrderPart> orderParts=orderPartRepository.findByOrder(order);
                    for (OrderPart orderPart : orderParts) {
                        ProductId productId=orderPart.getProduct().getProductId();
                        int quantitiy=orderPart.getQuantity();
                        orderHistory.put(productId, orderHistory.getOrDefault(productId, 0) + quantitiy);

                    }
                }
            }

            return orderHistory;
        }else
            throw new ShopException("The Customer with "+customerEmailAddress+" does not exist");

    }
    @Transactional
    public void deleteAllOrders() {
        orderPartRepository.deleteAll();
        orderRepository.deleteAll();

    }
    @Transactional
    public Order createOrder(CustomerId customerId,StorageUnitId storageUnitId) {
        OrderId orderId = new OrderId(UUID.randomUUID());
        Order newOrder = new Order(orderId,customerId,storageUnitId);
        return orderRepository.save(newOrder);
    }
    @Transactional
    public void addOrderItem(Order order, Product product, int quantity) {

        OrderPart orderPart = new OrderPart();
        orderPart.setOrder(order);
        orderPart.setProduct(product);
        orderPart.setQuantity(quantity);
        orderPartRepository.save(orderPart);
    }
    public List<Order> findOrdersByCustomerId(CustomerId customerId) {
        return orderRepository.findByCustomerId(Optional.ofNullable(customerId));
    }
    public List<OrderPart> findOrderPartsByOrder(Order order) {
        return orderPartRepository.findByOrder(order);
    }
    public Order findByOrderId(OrderId orderId) {
        return orderRepository.findById(orderId).orElseThrow(() -> new GenericNotFoundException("Order not found"));
    }



}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.Column;
import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.Setter;
import thkoeln.archilab.ecommerce.GenericId;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;

@Entity
@Table(name="orders")
public class Order extends GenericId {

    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private OrderId orderId;


    @Column(name="customerId")
    private CustomerId customerId;

    @Column(name="storageUnitId")
    private StorageUnitId storageUnitId;

    public Order() {}
    public Order(OrderId orderId, CustomerId customerId, StorageUnitId storageUnitId) {
        super(orderId.getId());
        this.orderId = orderId;
        this.customerId = customerId;
        this.storageUnitId = storageUnitId;
    }

    public void setOrderId(OrderId id) {
        this.orderId = id;
    }
    public OrderId getOrderId() {
        return orderId;
    }
    public void setCustomerId(CustomerId customerId) {this.customerId = customerId;}
    public CustomerId getCustomer() { return customerId;}
    public void setStorageUnitId(StorageUnitId storageUnitId) {this.storageUnitId = storageUnitId;}
    public StorageUnitId getStorageUnitId() {return storageUnitId;}
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderId.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "OrderId"))
public class OrderId extends GenericId {
    public OrderId(UUID id) {
        super(id);
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class OrderIdConverter extends GenericIdConverter<OrderId> {
    public OrderIdConverter() {
        super(OrderId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPart.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;


@Entity
public class OrderPart {

    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private OrderPartId orderPartId;

    @ManyToOne
    @JoinColumn(name="orderId")
    private Order order;


    @ManyToOne
    @JoinColumn(name="productId")
    private Product product;

    @Column
    private Integer quantity;

    public OrderPart() {
        this.orderPartId = new OrderPartId();
    }
    public OrderPart(Order order, Product product, Integer quantity, OrderPartId orderPartId) {
        this.orderPartId = new OrderPartId();
        this.order = order;
        this.product = product;
        this.quantity = quantity;
        this.orderPartId = orderPartId;
    }

    public OrderPartId getOrderId() {
        return orderPartId;
    }
    public void setOrderId(OrderPartId orderPartId) {
        this.orderPartId = orderPartId;
    }

    public Order getOrder() {
        return order;
    }
    public void setOrder(Order order) {
        this.order = order;
    }
    public  Product getProduct() {
        return product;
    }
    public void setProduct(Product product) {
        this.product = product;
    }
    public Integer getQuantity() { return quantity;}
    public void setQuantity(Integer quantity) {
        this.quantity = quantity;
    }
}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPartId.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "OrderPartId"))
public class OrderPartId extends GenericId {
    public OrderPartId(UUID id) {
        super(id);
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPartIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class OrderPartIdConverter extends GenericIdConverter<OrderPartId> {
    public OrderPartIdConverter() {
        super(OrderPartId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPartRepository.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;

import java.util.List;

@Repository
public interface OrderPartRepository extends JpaRepository<OrderPart, OrderPartId> {
    List<OrderPart> findByOrder(Order order);
    boolean existsByProduct(Product product);
    List<OrderPart> findByProduct(Product product);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderRepository.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;

import java.util.List;
import java.util.Optional;

@Repository
public interface OrderRepository extends JpaRepository<Order, OrderId> {
    List<Order> findByCustomerId(Optional<CustomerId> customerId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.product.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;

@Service
public class ProductAdapterService implements ProductCatalogUseCases {


    private final ProductService productService;

    public ProductAdapterService(ProductService productService) {
        this.productService = productService;
    }

    @Override
    public UUID addProductToCatalog(String name, String descriptionOf, Float size, MoneyType buyingPrice, MoneyType sellingPrice) throws ShopException {
        if (buyingPrice == null || sellingPrice == null) {
            throw new ShopException("buyingPrice or sellingPrice cannot be null");
        }
        ProductId productId = productService.addProductToCatalog(name, descriptionOf, size, (Money) buyingPrice, (Money) sellingPrice);
        return productId.getId();
    }

    @Override
    public void removeProductFromCatalog(UUID productId) throws ShopException {
        if (productId == null) {
            throw new ShopException("Invalid productId");
        }
        ProductId productIdToRemove = new ProductId(productId);
        productService.removeProductFromCatalog(productIdToRemove);

    }

    @Override
    public MoneyType getSellingPrice(UUID productId) {
        if (productId == null) {
            throw new ShopException("Invalid productId");
        }
        ProductId productIdObject = new ProductId(productId);
        return new Money(productService.getSellingPrice(productIdObject), "EUR");
    }

    @Override
    public void deleteProductCatalog() {
        productService.deleteProductCatalog();
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductService.java ---
package thkoeln.archilab.ecommerce.solution.product.application;

import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.GenericNotFoundException;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
import thkoeln.archilab.ecommerce.solution.product.dto.ReferencedOrderPart;
import thkoeln.archilab.ecommerce.solution.product.dto.ReferencedStockLevel;

import java.util.List;
import java.util.UUID;

@Service
public class ProductService {


    private final ProductRepository productRepository;
    private final ProductUsageInOrdersChecker productUsageInOrdersChecker;
    private final ProductUsageInShoppingBasketsChecker productUsageInShoppingBasketsChecker;
    private final ProductUsageInStockLevelChecker productUsageInStockLevelChecker;
    @Autowired
    public ProductService(ProductRepository productRepository, ProductUsageInOrdersChecker productUsageInOrdersChecker,
                          ProductUsageInShoppingBasketsChecker productUsageInShoppingBasketsChecker, ProductUsageInStockLevelChecker productUsageInStockLevelChecker) {
        this.productRepository = productRepository;
        this.productUsageInOrdersChecker = productUsageInOrdersChecker;
        this.productUsageInShoppingBasketsChecker = productUsageInShoppingBasketsChecker;
        this.productUsageInStockLevelChecker = productUsageInStockLevelChecker;
    }


    @Transactional
    public ProductId addProductToCatalog(String name, String descriptionOf, Float size, Money buyingPrice, Money sellingPrice) {
        if(name == null || name.isEmpty()) {
            throw new ShopException("Name Invalid");
        }
        if(descriptionOf == null || descriptionOf.isEmpty()) {
            throw new ShopException("Description Invalid");
        }
        if (buyingPrice == null|| buyingPrice.getAmount() <= 0) {
            throw new ShopException("Buying Price Invalid");
        }
        if (sellingPrice == null|| sellingPrice.getAmount() <= 0) {
            throw new ShopException("Selling Price Invalid");
        }
        if(sellingPrice.getAmount() < buyingPrice.getAmount()) {
            throw new ShopException("Selling cannot be lower than buying");
        }
        if(size!=null &&size <=0) {
            throw new ShopException("Size Invalid");
        }
        ProductId productId = new ProductId(UUID.randomUUID());
        Product product = new Product();

        product.setProductId(productId);
        product.setName(name);
        product.setDescription(descriptionOf);
        product.setSize(size);
        product.setBuyingPrice(buyingPrice);
        product.setSellingPrice(sellingPrice);

        try {
            Product savedProduct=productRepository.save(product);
            return savedProduct.getProductId();
        } catch (DataIntegrityViolationException e) {
            throw new ShopException("ProductId already exists");
        }

    }

    @Transactional
    public void removeProductFromCatalog(ProductId productId) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new ShopException("Product not found"));
        if(productUsageInStockLevelChecker.existsByProductAndQuantityGreaterThan(product,0)) {
            throw new ShopException("Product"+productId+" still has stockLevel");
        }

        if(productUsageInShoppingBasketsChecker.isProductInAnyShoppingBasket(product)) {
            throw new ShopException("Product"+productId+" still has shoppingBasket");
        }
        if(productUsageInOrdersChecker.isProductInAnyOrder(product)) {
            throw new ShopException("Product"+productId+" is still referenced by a completed Order");
        }
        List<ReferencedOrderPart> referencedParts= productUsageInOrdersChecker.findOrderPartsByProduct(product);
        List<ReferencedStockLevel> referencedStock = productUsageInStockLevelChecker.findStockLevelsByProduct(product);

        productUsageInStockLevelChecker.deleteAllStockLevels(referencedStock);
        productUsageInOrdersChecker.deleteAllOrderParts(referencedParts);
        productRepository.delete(product);
    }

    public Float getSellingPrice(ProductId productId) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new ShopException("Product not found"));
        return product.getSellingPrice().getAmount();
    }


    @Transactional
    public void deleteProductCatalog() {
        List<Product> allProducts = productRepository.findAll();
        for(Product product : allProducts) {
            List<ReferencedOrderPart> orderParts = productUsageInOrdersChecker.findOrderPartsByProduct(product);
            productUsageInOrdersChecker.deleteAllOrderParts(orderParts);
        }
        productRepository.deleteAll();
    }
    public Product findProductById(ProductId productId) {
        return productRepository.findById(productId).orElseThrow(()-> new GenericNotFoundException("Product not found"));
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductUsageInOrdersChecker.java ---
package thkoeln.archilab.ecommerce.solution.product.application;

import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.product.dto.ReferencedOrderPart;

import java.util.List;

public interface ProductUsageInOrdersChecker {
    boolean isProductInAnyOrder(Product product);
    List<ReferencedOrderPart> findOrderPartsByProduct(Product product);
    void deleteAllOrderParts(Iterable<ReferencedOrderPart> orderParts);

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductUsageInShoppingBasketsChecker.java ---
package thkoeln.archilab.ecommerce.solution.product.application;

import thkoeln.archilab.ecommerce.solution.product.domain.Product;

public interface ProductUsageInShoppingBasketsChecker {
    boolean isProductInAnyShoppingBasket(Product product);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductUsageInStockLevelChecker.java ---
package thkoeln.archilab.ecommerce.solution.product.application;

import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.product.dto.ReferencedStockLevel;

import java.util.List;

public interface ProductUsageInStockLevelChecker {
    boolean existsByProductAndQuantityGreaterThan(Product product, int quantity);
    List<ReferencedStockLevel> findStockLevelsByProduct (Product product);
    void deleteAllStockLevels(Iterable<ReferencedStockLevel> stockLevels);

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\Product.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.GenericId;
import thkoeln.archilab.ecommerce.domainprimitives.Money;

@Setter
@Getter
@Entity
public class Product extends GenericId {

    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private ProductId productId;

    private String name;
    private String description;
    private Float size;
    private Money buyingPrice;
    private Money sellingPrice;


    public Product() {}
    public Product(ProductId productId,String name, String description, Float size, Money buyingPrice, Money sellingPrice) {
        super(productId.getId());
        this.productId = productId;
        this.name = name;
        this.description = description;
        this.size = size;
        this.buyingPrice = buyingPrice;
        this.sellingPrice = sellingPrice;

    }
    public void setProductId(ProductId productId) {
        this.productId = productId;
    }
    public void setName(String name) {this.name = name;}
    public void setDescription(String description) {this.description = description;}
    public void setSize(Float size) {this.size = size;}
    public void setBuyingPrice(Money buyingPrice) {this.buyingPrice = buyingPrice;}
    public void setSellingPrice(Money sellingPrice) {this.sellingPrice = sellingPrice;}

    public ProductId getProductId() {
        return productId;
    }
    public String getName() { return name; }
    public String getDescription() { return description;}
    public Float getSize() { return size;}
    public Money getBuyingPrice() { return buyingPrice;}
    public Money getSellingPrice() { return sellingPrice;}


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductId.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "ProductId"))
public class ProductId extends GenericId {
    public ProductId(UUID id) {
        super(id);
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ProductIdConverter extends GenericIdConverter<ProductId> {
    public ProductIdConverter() {
        super(ProductId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductRepository.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;


@Repository
public interface ProductRepository extends JpaRepository<Product, ProductId> {
    //Optional<Product> findById(ProductId productId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\dto\ReferencedOrderPart.java ---
package thkoeln.archilab.ecommerce.solution.product.dto;

import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

@Setter
@Getter
public class ReferencedOrderPart {
    private ProductId productId;

    public ReferencedOrderPart(ProductId productId) {
        this.productId = productId;
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\dto\ReferencedShoppingBasketPart.java ---
package thkoeln.archilab.ecommerce.solution.product.dto;

import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

public class ReferencedShoppingBasketPart {

    private ProductId productId;

    public ReferencedShoppingBasketPart (ProductId productId) {
        this.productId = productId;
    }
    public ProductId getProductId() {
        return productId;
    }
    public void setProductId(ProductId productId) {
        this.productId = productId;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\dto\ReferencedStockLevel.java ---
package thkoeln.archilab.ecommerce.solution.product.dto;

import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

@Setter
@Getter
public class ReferencedStockLevel {
    private ProductId productId;

    public ReferencedStockLevel(ProductId productId) {
        this.productId = productId;
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\AddProductToBasketRequest.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import java.util.UUID;


public class AddProductToBasketRequest {
    private UUID productId;
    private Integer quantity;

    public UUID getProductId() {
        return productId;
    }

    public void setProductId(UUID productId) {
        this.productId = productId;
    }

    public Integer getQuantity() {
        return quantity;
    }

    public void setQuantity(Integer quantity) {
        this.quantity = quantity;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.*;

@Service
public class ShoppingBasketAdapterService implements ShoppingBasketUseCases {

    private final ShoppingBasketService shoppingBasketService;

    public ShoppingBasketAdapterService(ShoppingBasketService shoppingBasketService) {
        this.shoppingBasketService = shoppingBasketService;
    }


    @Override
    public void addProductToShoppingBasket(EmailAddressType customerEmailAddress, UUID productId, int quantFor)throws ShopException {
        if (customerEmailAddress ==null || productId == null) {
            throw new ShopException("CustomerEmailAddress or productId cannot be null");
        }
        ProductId productIdObj = new ProductId(productId);
        shoppingBasketService.addProductToShoppingBasket(customerEmailAddress.toString(), productIdObj, quantFor);
    }

    @Override
    public void removeProductFromShoppingBasket(EmailAddressType customerEmailAddress, UUID productId, int quantFor) throws ShopException {
        if (customerEmailAddress ==null || productId == null) {
            throw new ShopException("CustomerEmailAddress or productId cannot be null");
        }
        ProductId productIdObj = new ProductId(productId);
        shoppingBasketService.removeProductFromShoppingBasket(customerEmailAddress.toString(), productIdObj, quantFor);
    }

    @Override
    public Map<UUID, Integer> getShoppingBasketAsMap(EmailAddressType customerEmailAddress) throws ShopException {
        if (customerEmailAddress == null) {
            throw new ShopException("CustomerEmailAddress cannot be null");
        }

        Map<ProductId, Integer> shoppingBasketAsMap =shoppingBasketService.getShoppingBasketAsMap(customerEmailAddress.toString());
        Map<UUID, Integer> newShoppingBasketAsMap = new HashMap<>();
        for (ProductId productId : shoppingBasketAsMap.keySet()) {
            newShoppingBasketAsMap.put(productId.getId(), shoppingBasketAsMap.get(productId));
        }
        return newShoppingBasketAsMap;
    }

    @Override
    public MoneyType getShoppingBasketAsMoneyValue(EmailAddressType customerEmailAddress) throws ShopException {
        if (customerEmailAddress == null) {
            throw new ShopException("CustomerEmailAddress cannot be null");
        }
        return new Money(shoppingBasketService.getShoppingBasketAsMoneyValue(customerEmailAddress.toString()), "EUR");
    }

    @Override
    public Set<UUID> checkout(EmailAddressType customerEmailAddress) throws ShopException {
        if (customerEmailAddress == null || customerEmailAddress.toString().isEmpty() ) {
            throw new ShopException("CustomerEmailAddress cannot be null");
        }
        Set<OrderId> orderIds = shoppingBasketService.checkout(customerEmailAddress.toString());
        Set<UUID> orderIdSet = new HashSet<>();
        for (OrderId orderId : orderIds) {
            orderIdSet.add(orderId.getId());
        }
        return orderIdSet;
    }

    @Override
    public void emptyAllShoppingBaskets() {
        shoppingBasketService.emptyAllShoppingBaskets();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import thkoeln.archilab.ecommerce.domainprimitives.GenericNotFoundException;
import thkoeln.archilab.ecommerce.domainprimitives.GenericUnprocessableEntityException;
import thkoeln.archilab.ecommerce.solution.customer.application.CustomerRegistrationService;
import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
import thkoeln.archilab.ecommerce.solution.order.application.OrderDto;
import thkoeln.archilab.ecommerce.solution.order.application.OrderPartDto;
import thkoeln.archilab.ecommerce.solution.order.application.OrderService;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderPart;
import thkoeln.archilab.ecommerce.solution.product.application.ProductService;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketId;

import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/shoppingBaskets")
public class ShoppingBasketController {
    private final ShoppingBasketService shoppingBasketService;
    private final CustomerRegistrationService customerRegistrationService;
    private final ProductService productService;
    private final OrderService orderService;

    @Autowired
    public ShoppingBasketController(ShoppingBasketService shoppingBasketService,
                                    CustomerRegistrationService customerRegistrationService, ProductService productService, OrderService orderService) {
        this.shoppingBasketService = shoppingBasketService;
        this.customerRegistrationService = customerRegistrationService;
        this.productService = productService;
        this.orderService = orderService;
    }
    @GetMapping
    public ResponseEntity<List<ShoppingBasketDto>> getShoppingBaskets() {
        return new ResponseEntity<>(null,HttpStatus.METHOD_NOT_ALLOWED);
    }

    @GetMapping(params="customerId")
    public ResponseEntity<ShoppingBasketDto> getShoppingBasket(
            @RequestParam String customerId) {
        try {
            UUID customerUuid = UUID.fromString(customerId);
            CustomerId customerIdDp = new CustomerId(customerUuid);
            Customer customer=customerRegistrationService.findByCustomerId(customerIdDp);
            ShoppingBasket shoppingBasket = shoppingBasketService.getShoppingBasketForCustomerId(customerUuid).orElseThrow(()-> new GenericNotFoundException("Shopping basket not found"));


            String customerEmail = customer.getEmail().getEmailAddress();
            float totalMoneyValue = shoppingBasketService.getShoppingBasketAsMoneyValue(customerEmail);
            Map<ProductId,Integer> basketPartsMap = shoppingBasketService.getShoppingBasketAsMap(customerEmail);

            ShoppingBasketDto shoppingBasketDto = convertToDto(shoppingBasket,totalMoneyValue,basketPartsMap);
            return new ResponseEntity<>(shoppingBasketDto, HttpStatus.OK);

        } catch (IllegalArgumentException e) {
            return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
        }



    }
    @PostMapping("/{shoppingBasket-Id}/parts")
    public ResponseEntity<Void> addProductToShoppingBasket(
            @PathVariable("shoppingBasket-Id") UUID shoppingBasketId,
            @RequestBody AddProductToBasketRequest request) {
        if (request.getProductId()==null || request.getQuantity()==null) {
            throw new GenericUnprocessableEntityException("ProductId and quantity are required");
        }
        ShoppingBasketId basketId = new ShoppingBasketId(shoppingBasketId);
        ShoppingBasket shoppingBasket=shoppingBasketService.getShoppingBasketForShoppingBasketId(basketId);
        Customer customer = customerRegistrationService.findByCustomerId(shoppingBasket.getCustomerId());
        ProductId productId = new ProductId(request.getProductId());
        shoppingBasketService.addProductToShoppingBasket(customer.getEmailAddress().toString(),productId,request.getQuantity());
        return new ResponseEntity<>(HttpStatus.CREATED);
    }
    @DeleteMapping("/{shoppingBasket-Id}/parts/{product-Id}")
    public ResponseEntity<Void> removeProductFromShoppingBasket(
            @PathVariable("shoppingBasket-Id") UUID shoppingBasketId,
            @PathVariable("product-Id") UUID productId) {
        ShoppingBasketId basketId = new ShoppingBasketId(shoppingBasketId);
        ShoppingBasket shoppingBasket = shoppingBasketService.getShoppingBasketForShoppingBasketId(basketId);
        Customer customer = customerRegistrationService.findByCustomerId(shoppingBasket.getCustomerId());
        ProductId productIdDp = new ProductId(productId);
        shoppingBasketService.deleteProductFromShoppingBasket(customer.getEmailAddress().toString(), productIdDp);
        return new ResponseEntity<>(HttpStatus.OK);
    }
    @PostMapping("/{shoppingBasket-Id}/checkout")
    public ResponseEntity <List<OrderDto>> checkoutFromShoppingBasket(
            @PathVariable("shoppingBasket-Id") UUID shoppingBasketId
    ) {
        ShoppingBasketId basketId = new ShoppingBasketId(shoppingBasketId);
        ShoppingBasket shoppingBasket = shoppingBasketService.getShoppingBasketForShoppingBasketId(basketId);
        Customer customer = customerRegistrationService.findByCustomerId(shoppingBasket.getCustomerId());
        Set<OrderId> createdOrderIds =shoppingBasketService.checkout(customer.getEmailAddress().toString());
        List<OrderDto> orderDtos = new ArrayList<>();
        if (createdOrderIds.isEmpty()) {
            return new ResponseEntity<>(orderDtos,HttpStatus.NO_CONTENT);
        }
        for (OrderId orderId: createdOrderIds) {
            Order order = orderService.findByOrderId(orderId);
            OrderDto orderDto = new OrderDto();
            orderDto.setId(order.getOrderId().getId());
            orderDto.setCustomerName(customer.getName());
            orderDto.setStorageUnitId(order.getStorageUnitId().getId());

            List<OrderPart> orderParts = orderService.findOrderPartsByOrder(order);
            List<OrderPartDto> orderPartDtos = orderParts.stream()
                    .map(orderPart -> {
                                OrderPartDto partDto = new OrderPartDto();
                                partDto.setProductId(orderPart.getProduct().getProductId().getId());
                                partDto.setQuantity(orderPart.getQuantity());
                                return partDto;
                            }).collect(Collectors.toList());
            orderDto.setParts(orderPartDtos);
            orderDtos.add(orderDto);
        }
        return new ResponseEntity<>(orderDtos,HttpStatus.CREATED);
    }


    private ShoppingBasketDto convertToDto (ShoppingBasket shoppingBasket, float totalMoneyValue, Map<ProductId,Integer> basketPartsMap) {
        if (shoppingBasket == null) {
            return null;
        }
        ShoppingBasketDto dto = new ShoppingBasketDto();
        if(shoppingBasket.getShoppingBasketId()!=null) {
            dto.setId(shoppingBasket.getShoppingBasketId().getId());
        }
        if (shoppingBasket.getCustomerId() != null) {
            dto.setCustomerId(shoppingBasket.getCustomerId().getId());
        }
       // NumberFormat currencyFormat = NumberFormat.getCurrencyInstance(Locale.GERMANY);
        DecimalFormatSymbols symbols = new DecimalFormatSymbols(Locale.US);
        symbols.setGroupingSeparator('\u0000');
        symbols.setCurrencySymbol("€");
        DecimalFormat decimalFormat = new DecimalFormat("0.00 \u00A4", symbols);


        String formattedPrice = decimalFormat.format(totalMoneyValue);
        //formattedPrice = formattedPrice.replace('\u00A0', ' ');
        //formattedPrice = formattedPrice.replace(".",",");
        dto.setTotalSellingPrice(formattedPrice);
        if (basketPartsMap != null && !basketPartsMap.isEmpty()) {
            List<ShoppingBasketPartDto> partDtos = new ArrayList<>();
            for (Map.Entry<ProductId, Integer> entry : basketPartsMap.entrySet()) {
                ProductId productId = entry.getKey();
                Integer quantity = entry.getValue();

                // Not allowed maybe call productService here
                Product product = productService.findProductById(productId);

                ShoppingBasketPartDto partDto = new ShoppingBasketPartDto();
                if (product != null) {
                    partDto.setProductId(product.getProductId().getId());
                } else {
                    partDto.setProductId(productId.getId());
                    System.err.println("Warning: Product with ID " + productId.getId() + " not found when mapping shopping basket parts.");
                }
                partDto.setQuantity(quantity);
                partDtos.add(partDto);
            }
            dto.setParts(partDtos);
        } else {
            dto.setParts(new ArrayList<>());
        }
        return dto;

    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketDto.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.List;
import java.util.UUID;

@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
public class ShoppingBasketDto {
    private UUID id;
    private UUID customerId;
    private String totalSellingPrice;
    private List<ShoppingBasketPartDto> parts;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketPartDto.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.UUID;


@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
public class ShoppingBasketPartDto {
    private UUID productId;
    private int quantity;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketQueryService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import thkoeln.archilab.ecommerce.solution.product.application.ProductUsageInShoppingBasketsChecker;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPartRepository;

@Service
public class ShoppingBasketQueryService implements ProductUsageInShoppingBasketsChecker {
    private final ShoppingBasketPartRepository shoppingBasketPartRepository;

    public ShoppingBasketQueryService ( ShoppingBasketPartRepository shoppingBasketPartRepository) {
        this.shoppingBasketPartRepository = shoppingBasketPartRepository;
    }

    @Transactional (readOnly = true)
    @Override
    public boolean isProductInAnyShoppingBasket(Product product) {
        return shoppingBasketPartRepository.existsByProduct(product);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.InsufficientStockException;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.GenericConflictException;
import thkoeln.archilab.ecommerce.domainprimitives.GenericNotFoundException;
import thkoeln.archilab.ecommerce.domainprimitives.GenericUnprocessableEntityException;
import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerRepository;
import thkoeln.archilab.ecommerce.solution.order.application.OrderService;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.*;
import thkoeln.archilab.ecommerce.solution.storageunit.application.StorageUnitService;
import thkoeln.archilab.ecommerce.solution.storageunit.dip.StockLevelQueryDip;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnit;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitComparator;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class ShoppingBasketService {

    private final CustomerRepository customerRepository;
    private final ShoppingBasketRepository shoppingBasketRepository;
    private final ShoppingBasketPartRepository shoppingBasketPartRepository;
    private final ProductRepository productRepository;
    private final StorageUnitService storageUnitService;
    private final OrderService orderService;
    private final StockLevelQueryDip stockLevelQueryDip;


    @Autowired
    public ShoppingBasketService(ShoppingBasketRepository shoppingBasketRepository,  CustomerRepository customerRepository
    , ShoppingBasketPartRepository shoppingBasketPartRepository, ProductRepository productRepository, StorageUnitService storageUnitService,
                                   OrderService orderService, StockLevelQueryDip stockLevelQueryDip) {
        this.shoppingBasketRepository = shoppingBasketRepository;
        this.customerRepository = customerRepository;
        this.shoppingBasketPartRepository = shoppingBasketPartRepository;
        this.productRepository = productRepository;
        this.storageUnitService = storageUnitService;
        this.orderService = orderService;
        this.stockLevelQueryDip = stockLevelQueryDip;
    }


    @Transactional
    public void addProductToShoppingBasket(String customerEmailAddress, ProductId productId, int quantFor) {
        if(customerEmailAddress == null || customerEmailAddress.isEmpty() || productId == null|| quantFor<0 ) {
            throw new GenericUnprocessableEntityException("Invalid Input");
        }
        ShoppingBasket shoppingBasket = createShoppingBasketForCustomer(customerEmailAddress);

        Optional<ShoppingBasketPart> existingPart = shoppingBasketPartRepository.findByShoppingBasketAndProductId(shoppingBasket, productId);

        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new GenericNotFoundException("Product not found"));

        ShoppingBasketPart part;
        if(existingPart.isPresent()) {
            part = existingPart.get();
            part.setQuantity(part.getQuantity()+quantFor);
        } else {
            part = new ShoppingBasketPart();

            part.setShoppingBasket(shoppingBasket);
            part.setProductId(productId);
            part.setProduct(product);
            part.setQuantity(quantFor);
        }
        shoppingBasketPartRepository.save(part);

    }

    @Transactional
    public void removeProductFromShoppingBasket(String customerEmailAddress, ProductId productId, int quantFor) {
        if(customerEmailAddress == null || customerEmailAddress.isEmpty() || productId == null|| quantFor<0 ) {
            throw new GenericUnprocessableEntityException("Invalid Input");
        }
        ShoppingBasket shoppingBasket = getShoppingBasketForCustomer(customerEmailAddress);
        Optional<ShoppingBasketPart> existingPart = shoppingBasketPartRepository.findByShoppingBasketAndProductId(shoppingBasket, productId);


        if(existingPart.isPresent()) {
            ShoppingBasketPart part = existingPart.get();
            int currentQuantity = part.getQuantity();
            if(currentQuantity >= quantFor) {
                    part.setQuantity(currentQuantity-quantFor);
                    shoppingBasketPartRepository.save(part);
            } else {
                throw new GenericConflictException("Quantity exceeds quant");
            }
        } else {
            throw new GenericNotFoundException("Product not found in Shopping Basket");
        }
    }
    @Transactional
    public void deleteProductFromShoppingBasket(String customerEmailAddress, ProductId productId) {
        if(customerEmailAddress == null || customerEmailAddress.isEmpty() || productId == null) {
            throw new GenericUnprocessableEntityException("Invalid Input");
        }
        ShoppingBasket shoppingBasket = getShoppingBasketForCustomer(customerEmailAddress);
        Optional<ShoppingBasketPart> existingPart = shoppingBasketPartRepository.findByShoppingBasketAndProductId(shoppingBasket, productId);
        if(existingPart.isPresent()) {
            ShoppingBasketPart partToDelete = existingPart.get();
            shoppingBasketPartRepository.delete(partToDelete);
        } else {
            throw new GenericNotFoundException("Product with ID " + productId.getId() + " not found in the shopping basket of customer " + customerEmailAddress + ".");
        }

    }

    @Transactional
    public Map<ProductId, Integer> getShoppingBasketAsMap(String customerEmailAddress) {
        if(customerEmailAddress == null || customerEmailAddress.isEmpty() ) {
            throw new GenericUnprocessableEntityException("Invalid Input");
        }
            Map<ProductId,Integer> shoppingBasketMap = new HashMap<>();

            ShoppingBasket shoppingBasket = getShoppingBasketForCustomer(customerEmailAddress);

            List<ShoppingBasketPart> shoppingBasketParts = shoppingBasketPartRepository
                    .findByShoppingBasket(shoppingBasket);
            if (shoppingBasketParts!=null && !shoppingBasketParts.isEmpty()) {
                for (ShoppingBasketPart part : shoppingBasketParts) {
                    shoppingBasketMap.put(part.getProduct().getProductId(), part.getQuantity());
                }
            }
            return shoppingBasketMap;
    }

    @Transactional
    public float getShoppingBasketAsMoneyValue(String customerEmailAddress) {
        ShoppingBasket shoppingBasket = getShoppingBasketForCustomer(customerEmailAddress);

        List<ShoppingBasketPart> shoppingBasketParts = shoppingBasketPartRepository
                .findByShoppingBasket(shoppingBasket);
        float shoppingBasketMoneyValue = 0f;
        if (shoppingBasketParts!=null && !shoppingBasketParts.isEmpty()) {

            for (ShoppingBasketPart part : shoppingBasketParts) {
                Product product = productRepository.findById(part.getProduct().getProductId())
                        .orElseThrow(() -> new GenericNotFoundException("Product not found"));
                float buyingPrice=product.getSellingPrice().getAmount(); // Log product details
                int quantity = part.getQuantity();
                shoppingBasketMoneyValue=shoppingBasketMoneyValue+buyingPrice*quantity;
            }
        }

        return shoppingBasketMoneyValue;
    }
    private Customer getCustomer(EmailAddressType email) {
        Optional<Customer> emptyOrCustomer = customerRepository.findByEmail(email);
        return emptyOrCustomer.orElseThrow(() -> new GenericNotFoundException("Customer not found"));

    }
    private Map<ProductId,Integer> getRemainingShoppingBasketParts(List<ShoppingBasketPart> shoppingBasketParts) {
        Map<ProductId,Integer> remainingShoppingBasketParts = shoppingBasketParts.stream()
                .collect(Collectors.toMap(
                        ShoppingBasketPart::getProductId,
                        ShoppingBasketPart::getQuantity
                ));
        return remainingShoppingBasketParts;
    }
    @Transactional
    public Set<OrderId> checkout(String customerEmailAddress) {
        ShoppingBasket shoppingBasket = getShoppingBasket(customerEmailAddress);
        EmailAddressType email = EmailAddress.of(customerEmailAddress);
        Customer customer = getCustomer(email);

        List<ShoppingBasketPart> shoppingBasketParts = validateAndGetShoppingBasketParts(shoppingBasket);

        Map<ProductId,Integer> remainingShoppingBasketParts = getRemainingShoppingBasketParts(shoppingBasketParts);
        Set<OrderId> orderIds = new HashSet<>();
        ZipCodeType customerZipCode = customer.getAddress().getZipCode();

        Set<ProductId> initiallyRequestedProductIds = new HashSet<>(remainingShoppingBasketParts.keySet());

        while (!remainingShoppingBasketParts.isEmpty()) {
            StorageUnitComparator comparator = new StorageUnitComparator(remainingShoppingBasketParts, customerZipCode, stockLevelQueryDip);
            List<StorageUnit> allStorageUnits = storageUnitService.getAllStorageUnits();

            Optional<StorageUnit> bestStorageUnitOptional = allStorageUnits.stream()
                    .filter(unit -> !unit.fulfillableShoppingBasketParts(remainingShoppingBasketParts,stockLevelQueryDip).isEmpty())
                    .max(comparator);

            if (bestStorageUnitOptional.isEmpty()) {
                break;
            }
            StorageUnit bestStorageUnit = bestStorageUnitOptional.get();
            Set<ProductId> fulfillableByBestUnit = bestStorageUnit.fulfillableShoppingBasketParts(remainingShoppingBasketParts,stockLevelQueryDip);

            if (fulfillableByBestUnit.isEmpty()) {break;}

            List<ShoppingBasketPart> partsForCurrentOrder = filterParts(shoppingBasketParts,fulfillableByBestUnit,remainingShoppingBasketParts);
            if (partsForCurrentOrder.isEmpty()) {break;}

            Order newOrder = orderService.createOrder(customer.getCustomerId(),bestStorageUnit.getStorageUnitId());
            orderIds.add(newOrder.getOrderId());

            for (ShoppingBasketPart part : partsForCurrentOrder) {
                orderService.addOrderItem(newOrder,part.getProduct(),part.getQuantity());
                storageUnitService.removeFromStock(bestStorageUnit.getStorageUnitId(),part.getProduct().getProductId(),part.getQuantity());
                remainingShoppingBasketParts.remove(part.getProduct().getProductId());
            }
        }
        Set<ProductId> unfulfillableProductIds = remainingShoppingBasketParts.keySet();
        if (!unfulfillableProductIds.isEmpty()) {
            deleteUnfulfillableParts(shoppingBasketParts,unfulfillableProductIds);
        }
        if (orderIds.isEmpty() && !initiallyRequestedProductIds.isEmpty()) {
            shoppingBasketRepository.delete(shoppingBasket);
            throw new GenericConflictException("No products in the shopping basket could be fulfilled. Basket cleared.");
        }
        if (!orderIds.isEmpty()) {
            deleteFulfillableParts(shoppingBasket,shoppingBasketParts,unfulfillableProductIds);

        }

        return orderIds;
    }
    private void deleteFulfillableParts (ShoppingBasket shoppingBasket,List<ShoppingBasketPart> shoppingBasketParts,
                                         Set<ProductId> unfulfillableProductIds) {
        shoppingBasket.setStatus(ShoppingBasketStatus.CHECKED_OUT);
        shoppingBasketRepository.save(shoppingBasket);
        List<ShoppingBasketPart> fulfilledParts = shoppingBasketParts.stream()
                .filter(part -> !unfulfillableProductIds.contains(part.getProductId()))
                .toList();
        shoppingBasketPartRepository.deleteAll(fulfilledParts);
    }
    private void deleteUnfulfillableParts(List<ShoppingBasketPart> shoppingBasketParts,
                                          Set<ProductId> unfulfillableProductIds) {
        List<ShoppingBasketPart> partsToRemoveFromBasket = shoppingBasketParts.stream()
                .filter(part -> unfulfillableProductIds.contains(part.getProductId()))
                .toList();
        shoppingBasketPartRepository.deleteAll(partsToRemoveFromBasket);
    }

    @Transactional
    public void emptyAllShoppingBaskets() {
        List<ShoppingBasket> allShoppingBaskets = shoppingBasketRepository.findAll();

        for (ShoppingBasket shoppingBasket : allShoppingBaskets) {
            List<ShoppingBasketPart> shoppingBasketParts = shoppingBasketPartRepository
                    .findByShoppingBasket(shoppingBasket);
            shoppingBasketPartRepository.deleteAll(shoppingBasketParts);
            shoppingBasketRepository.delete(shoppingBasket);
        }
        shoppingBasketRepository.deleteAll();
    }
    public void emptyShoppingBasket(ShoppingBasketId shoppingBasketId) {
        shoppingBasketRepository.deleteById(shoppingBasketId);
    }
    @Transactional
    public ShoppingBasket createShoppingBasketForCustomer(String customerEmailAddress) {
        EmailAddressType email = EmailAddress.of(customerEmailAddress);
        Customer customer = customerRepository.findByEmail(email)
                .orElseThrow(() -> new GenericNotFoundException("Customer not found"));
        return shoppingBasketRepository.findByCustomerId(customer.getCustomerId())
                .orElseGet(() -> {
                    ShoppingBasketId shoppingBasketId = new ShoppingBasketId(customer.getCustomerId().getId());
                    ShoppingBasket newBasket = new ShoppingBasket(shoppingBasketId,customer.getCustomerId(),ShoppingBasketStatus.OPEN);
                    newBasket.setShoppingBasketId(shoppingBasketId);
                    newBasket.setCustomerId(customer.getCustomerId());
                    newBasket.setStatus(ShoppingBasketStatus.OPEN);
                    return shoppingBasketRepository.save(newBasket);
                });
    }
    public ShoppingBasket getShoppingBasketForCustomer(String customerEmailAddress) {
        EmailAddressType email = EmailAddress.of(customerEmailAddress);
        Customer customer = customerRepository.findByEmail(email)
                .orElseThrow(() -> new GenericNotFoundException("Customer not found"));
        return shoppingBasketRepository.findByCustomerId(customer.getCustomerId())
                .orElseThrow(() -> new GenericNotFoundException("Shopping basket not found for customer: " + customerEmailAddress));

    }
    public Optional<ShoppingBasket> getShoppingBasketForCustomerId(UUID id) {
        CustomerId customerId = new CustomerId(id);

        Optional<ShoppingBasket> shoppingBasketOptional= shoppingBasketRepository.findByCustomerId(customerId);
        if(shoppingBasketOptional.isPresent()) {
            return shoppingBasketOptional;
        } else {
            Customer customer = customerRepository.findById(customerId)
                    .orElseThrow(() -> new GenericNotFoundException("Customer not found"));
            ShoppingBasketId shoppingBasketId = new ShoppingBasketId(customer.getCustomerId().getId());
            ShoppingBasket newBasket = new ShoppingBasket(shoppingBasketId,customer.getCustomerId(),ShoppingBasketStatus.OPEN);
            return Optional.of(shoppingBasketRepository.save(newBasket));

        }
    }
    public ShoppingBasket getShoppingBasketForShoppingBasketId(ShoppingBasketId id) {
        return shoppingBasketRepository.findByShoppingBasketId(id).orElseThrow(() -> new GenericNotFoundException("No ShoppingBasket found for ShoppingBasketId"));
    }
    @Transactional
    public Optional<Integer> getProductQuantityInShoppingBasket(UUID shoppingBasketUuid, ProductId productId) {
        if (shoppingBasketUuid == null || productId == null) {
            throw new GenericUnprocessableEntityException("Shopping Basket ID and Product ID cannot be null.");
        }

        ShoppingBasketId shoppingBasketId = new ShoppingBasketId(shoppingBasketUuid);
        ShoppingBasket shoppingBasket = shoppingBasketRepository.findByShoppingBasketId(shoppingBasketId)
                .orElseThrow(() -> new GenericNotFoundException("Shopping basket not found for ID: " + shoppingBasketUuid));

        Optional<ShoppingBasketPart> part = shoppingBasketPartRepository.findByShoppingBasketAndProductId(shoppingBasket, productId);

        return part.map(ShoppingBasketPart::getQuantity);
    }
    private List<ShoppingBasketPart> validateAndGetShoppingBasketParts(ShoppingBasket shoppingBasket) {
        List<ShoppingBasketPart> shoppingBasketParts = shoppingBasketPartRepository
                .findByShoppingBasket(shoppingBasket);
        if(shoppingBasketParts==null || shoppingBasketParts.isEmpty()) {
            if (shoppingBasket.getStatus()==ShoppingBasketStatus.CHECKED_OUT) {
                throw new GenericConflictException("Shopping Basket is checked out");
            } else throw new GenericNotFoundException("ShoppingBasket is empty");
        }
        return shoppingBasketParts;

    }
    private List<ShoppingBasketPart> filterParts(List<ShoppingBasketPart> shoppingBasketParts,Set<ProductId> productIds,Map<ProductId,Integer> remainingShoppingBasketParts) {

        List<ShoppingBasketPart> partsForCurrentOrder = shoppingBasketParts.stream()
                .filter(shoppingBasketPart -> productIds.contains(shoppingBasketPart.getProductId()))
                .filter(shoppingBasketPart -> remainingShoppingBasketParts.containsKey(shoppingBasketPart.getProductId()))
                .toList();
        return partsForCurrentOrder;
    }
    private ShoppingBasket getShoppingBasket(String customerEmail) {
        ShoppingBasket shoppingBasket =getShoppingBasketForCustomer(customerEmail);
        if(shoppingBasket == null) {
            throw new GenericConflictException("Shopping Basket is Empty");
        }
        return shoppingBasket;

    }



}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.GenericId;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;


@Entity
@Setter
@Getter
public class ShoppingBasket extends GenericId {

    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private ShoppingBasketId shoppingBasketId;

    @Setter
    @Column(name = "customerId")
    private CustomerId customerId;

    @Enumerated(EnumType.STRING)
    private ShoppingBasketStatus status;




    public ShoppingBasket() {}
    public ShoppingBasket(ShoppingBasketId shoppingBasketId, CustomerId customerId, ShoppingBasketStatus status) {
        super(shoppingBasketId.getId());
        this.shoppingBasketId = shoppingBasketId;
        this.customerId = customerId;
        this.status = status;
    }

    public void setShoppingBasketId(ShoppingBasketId shoppingBasketId) {
        this.shoppingBasketId = shoppingBasketId;
    }

    public ShoppingBasketId getShoppingBasketId() {
        return shoppingBasketId;
    }

    public CustomerId getCustomerId() {
        return customerId;
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketId.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Getter
@Setter
@Embeddable
@NoArgsConstructor(access = AccessLevel.PUBLIC)
@AttributeOverride(name = "id", column = @Column(name = "ShoppingBasketId"))
public class ShoppingBasketId extends GenericId {
    public ShoppingBasketId(UUID id) {
        super(id);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ShoppingBasketIdConverter extends GenericIdConverter<ShoppingBasketId> {
    public ShoppingBasketIdConverter() {
        super(ShoppingBasketId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPart.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;


@Entity
@Getter
@Setter
public class ShoppingBasketPart {

    @Setter (AccessLevel.PRIVATE)
    @EmbeddedId
    private ShoppingBasketPartId shoppingBasketPartId;

    @ManyToOne
    @JoinColumn(name = "shoppingBasketId")
    private ShoppingBasket shoppingBasket;

    @Embedded
    private ProductId productId;

    @OneToOne (fetch = FetchType.EAGER)
    @JoinColumn(name="productId", insertable=false, updatable=false)
    private Product product;

    @Column
    private Integer quantity;


    public ShoppingBasketPart() {
        this.shoppingBasketPartId = new ShoppingBasketPartId();
    }
    public ShoppingBasketPart(ShoppingBasket shoppingBasket,Product product, ProductId productId, Integer quantity) {
        this.shoppingBasketPartId = new ShoppingBasketPartId();
        this.product =product;
        this.shoppingBasket = shoppingBasket;
        this.productId = productId;
        this.quantity = quantity;

    }

    public ShoppingBasketPartId getShoppingBasketPartId() {
        return shoppingBasketPartId;
    }
    public ProductId getProductId() {
        return productId;
    }
    public Product getProduct() {
        return product;
    }
    public void setProduct(Product product) {
        this.product = product;
    }
    public void setShoppingBasket(ShoppingBasket shoppingBasket) {
        this.shoppingBasket = shoppingBasket;
    }
    public Integer getQuantity() {
        return quantity;
    }
    public void setQuantity(Integer quantity) {
        this.quantity = quantity;
    }




}
/*    public static class ShoppingBasketPartId implements Serializable {
        private ProductId product;
        private ShoppingBasketId shoppingBasket;


        public ShoppingBasketPartId() {}
        public ShoppingBasketPartId(ProductId product, ShoppingBasketId shoppingBasket) {
            this.product = product;
            this.shoppingBasket = shoppingBasket;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            ShoppingBasketPartId that = (ShoppingBasketPartId) o;
            if(!product.equals(that.product)) return false;
            return shoppingBasket.equals(that.shoppingBasket);
        }
        @Override
        public int hashCode() {
            int result = product.hashCode();
            result = 31 * result + shoppingBasket.hashCode();
            return result;
        }
*/

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPartId.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "ShoppingBasketPartId"))
public class ShoppingBasketPartId extends GenericId {
    public ShoppingBasketPartId(UUID id) {
        super(id);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPartIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;


import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ShoppingBasketPartIdConverter extends GenericIdConverter<ShoppingBasketPartId> {
    public ShoppingBasketPartIdConverter() {
        super (ShoppingBasketPartId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPartRepository.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

import java.util.List;
import java.util.Optional;

@Repository
public interface ShoppingBasketPartRepository extends JpaRepository<ShoppingBasketPart, ShoppingBasketPartId> {
    boolean existsByProduct(Product product);
    List<ShoppingBasketPart> findByShoppingBasket(ShoppingBasket shoppingBasket);
    Optional<ShoppingBasketPart> findByShoppingBasketAndProductId(ShoppingBasket shoppingBasket, ProductId productId);


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketRepository.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;

import java.util.Optional;

@Repository
public interface ShoppingBasketRepository extends JpaRepository<ShoppingBasket, ShoppingBasketId> {
    Optional<ShoppingBasket> findByCustomerId(CustomerId customerId);
    Optional<ShoppingBasket> findByShoppingBasketId(ShoppingBasketId shoppingBasketId);



}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketStatus.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

public enum ShoppingBasketStatus {
    OPEN,
    CHECKED_OUT
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\StockLevelQueryService.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.product.application.ProductUsageInStockLevelChecker;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.product.dto.ReferencedStockLevel;
import thkoeln.archilab.ecommerce.solution.storageunit.dip.StockLevelQueryDip;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StockLevel;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StockLevelRepository;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
import thkoeln.archilab.ecommerce.solution.storageunit.dto.StockLevelDto;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class StockLevelQueryService implements ProductUsageInStockLevelChecker, StockLevelQueryDip {
    private final StockLevelRepository stockLevelRepository;

    public StockLevelQueryService(StockLevelRepository stockLevelRepository) {
        this.stockLevelRepository = stockLevelRepository;
    }
    @Override
    public boolean existsByProductAndQuantityGreaterThan(Product product, int quantity) {
        return stockLevelRepository.existsByProductAndQuantityGreaterThan(product, quantity);
    }

    @Override
    public List<ReferencedStockLevel> findStockLevelsByProduct(Product product) {
        return stockLevelRepository.findByProduct(product).stream()
                .map(stockLevel -> new ReferencedStockLevel(stockLevel.getProduct().getProductId()))
                .collect(Collectors.toList());

    }

    @Override
    public void deleteAllStockLevels(Iterable<ReferencedStockLevel> stockLevels) {
        List<StockLevel> stockLevelsToDelete = stockLevelRepository.findAll();
        if (!stockLevelsToDelete.isEmpty()) {
            stockLevelRepository.deleteAll(stockLevelsToDelete);
        }
    }


    @Override
    public List<StockLevelDto> getStockDataForFulfillment(StorageUnitId storageUnitId) {
        return stockLevelRepository.findByStorageUnitStorageUnitId(storageUnitId).stream()
                .map(stockLevel -> new StockLevelDto(
                        stockLevel.getProduct().getProductId(),
                        stockLevel.getStorageUnit().getStorageUnitId(),
                        stockLevel.getQuantity()
                ))
                .collect(Collectors.toList());    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\StorageUnitAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StockLevelRepository;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;

import java.util.UUID;

@Service
public class StorageUnitAdapterService implements StorageUnitUseCases {

    private final StorageUnitService storageUnitService;
    private final StockLevelRepository stockLevelRepository;

    public StorageUnitAdapterService(StorageUnitService storageUnitService, StockLevelRepository stockLevelRepository) {
        this.storageUnitService = storageUnitService;
        this.stockLevelRepository = stockLevelRepository;
    }



    /**
     * @param name
     * @param address
     * @return the id of the new storage unit
     * @throws ShopException if ...
     *                       - name is null or empty
     *                       - address is null
     */
    @Override
    public UUID addNewStorageUnit(String name, AddressType address) {
        if (name==null || address==null) {
            throw new ShopException("Invalid Parameters");
        }
        StorageUnitId storageUnitId=storageUnitService.addNewStorageUnit(name,address.getStreet(),address.getCity(),address.getZipCode());
        return storageUnitId.getId();
    }

    @Override
    public void deleteAllStorageUnits() {
        stockLevelRepository.deleteAll();
        storageUnitService.deleteAllStorageUnits();

    }



    @Override
    public void addToStock(UUID storageUnitId, UUID productId, int addedQuantFor) throws ShopException {
        if (storageUnitId==null || productId==null) {
            throw new ShopException("storageUnitId or ProductId cannot be null");
        }
        StorageUnitId storageToAddTo = new StorageUnitId(storageUnitId);
        ProductId stockToAdd = new ProductId(productId);
        storageUnitService.addToStock(storageToAddTo, stockToAdd, addedQuantFor);
    }

    @Override
    public void removeFromStock(UUID storageUnitId, UUID productId, int removedQuantFor) throws ShopException {
        if (storageUnitId==null || productId==null) {
            throw new ShopException("storageUnitId or ProductId cannot be null");
        }
        StorageUnitId storageToRemoveFrom = new StorageUnitId(storageUnitId);
        ProductId stockToRemove = new ProductId(productId);
        storageUnitService.removeFromStock(storageToRemoveFrom, stockToRemove, removedQuantFor);

    }

    @Override
    public void changeStockTo(UUID storageUnitId, UUID productId, int newTotalQuantFor) throws ShopException {
        if (storageUnitId==null || productId==null) {
            throw new ShopException("storageUnitId or ProductId cannot be null");
        }
        StorageUnitId storageToChangeTo = new StorageUnitId(storageUnitId);
        ProductId stockToChange = new ProductId(productId);
        storageUnitService.changeStockTo(storageToChangeTo, stockToChange, newTotalQuantFor);

    }

    @Override
    public int getAvailableStock(UUID storageUnitId, UUID productId) throws ShopException {
        if (storageUnitId==null || productId==null) {
            throw new ShopException("storageUnitId or ProductId cannot be null");
        }
        StorageUnitId storageUnitIdToCheck = new StorageUnitId(storageUnitId);
        ProductId stockToCheck = new ProductId(productId);
        return storageUnitService.getAvailableStock(storageUnitIdToCheck, stockToCheck);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\StorageUnitService.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.application;

import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
import thkoeln.archilab.ecommerce.solution.storageunit.Tuple3;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
public class StorageUnitService {

    private final ProductRepository productRepository;
    private final StockLevelRepository stockLevelRepository;
    private final StorageUnitRepository storageUnitRepository;
    @Autowired
    public StorageUnitService(StorageUnitRepository storageUnitRepository, ProductRepository productRepository, StockLevelRepository stockLevelRepository) {
        this.storageUnitRepository = storageUnitRepository;
        this.productRepository = productRepository;
        this.stockLevelRepository = stockLevelRepository;
    }
    @Transactional
    public StorageUnitId addNewStorageUnit(String name, String street, String city, ZipCodeType zipCode) {
        if(!areFieldsValid(name,street,city)) {
            throw new ShopException("Invalid name or street or city");
        }
        if(zipCode == null || isInvalidZipCode(zipCode.toString())) {
            throw new ShopException("Invalid zip code");
        }
        StorageUnit storageUnit = new StorageUnit();
        StorageUnitId storageUnitId = new StorageUnitId(UUID.randomUUID());

        storageUnit.setStorageUnitId(storageUnitId);
        storageUnit.setName(name);
        Address address = (Address) Address.of(city,street,zipCode);
        storageUnit.setAddress(address);


        StorageUnit savedStorageUnit = storageUnitRepository.save(storageUnit);
        return savedStorageUnit.getStorageUnitId();
    }
    @Transactional
    public void deleteAllStorageUnits() {
        stockLevelRepository.deleteAll();
        storageUnitRepository.deleteAll();
    }




    @Transactional
    public void addToStock(StorageUnitId storageUnitId, ProductId productId, int addedQuantFor) {
        Tuple3<Product,StorageUnit,Optional<StockLevel>>details= checkParameters(storageUnitId, productId, addedQuantFor);
        Product product = details.a;
        StorageUnit storageUnit = details.b;
        Optional<StockLevel> existingStockLevel=details.c;
        if (existingStockLevel.isPresent()) {
            StockLevel stockLevel = existingStockLevel.get();
            stockLevel.setQuantity(stockLevel.getQuantity() + addedQuantFor);
            stockLevelRepository.save(stockLevel);
        } else {
            createNewStock(product, storageUnit, addedQuantFor);
        }
    }

    @Transactional
    public void removeFromStock(StorageUnitId storageUnitId, ProductId productId, int removedQuantFor) {
        Tuple3<Product,StorageUnit,Optional<StockLevel>>details= checkParameters(storageUnitId, productId, removedQuantFor);
        //System.out.println("PRINTING DETAILS:"+details);
        Optional<StockLevel> existingStockLevel=details.c;


        if (existingStockLevel.isPresent()) {
            StockLevel stockLevel = existingStockLevel.get();
            int newQuantity = stockLevel.getQuantity() - removedQuantFor;

            if (newQuantity>=0) {
                stockLevel.setQuantity(newQuantity);
                stockLevelRepository.save(stockLevel);
                return;

            } else {
                throw new ShopException("Insufficient stock for product" + productId + " to remove " + removedQuantFor + " from " + storageUnitId);
            }
        } else if (removedQuantFor==0) {
            Product product = details.a;
            StorageUnit storageUnit = details.b;
            createNewStock(product, storageUnit, removedQuantFor);

        } else {
            throw new ShopException("Cannot remove negative negative quantity from Stock");
        }
    }

    @Transactional
    public void changeStockTo(StorageUnitId storageUnitId, ProductId productId, int newTotalQuantFor) {
        Tuple3<Product,StorageUnit,Optional<StockLevel>>details= checkParameters(storageUnitId, productId, newTotalQuantFor);
        Product product = details.a;
        StorageUnit storageUnit = details.b;
        Optional<StockLevel> existingStockLevel=details.c;
        if (existingStockLevel.isPresent()) {
            StockLevel stockLevel = existingStockLevel.get();
            stockLevel.setQuantity(newTotalQuantFor);
            stockLevelRepository.save(stockLevel);
        } else {
            createNewStock(product,storageUnit,newTotalQuantFor);
        }
    }

    public int getAvailableStock(StorageUnitId storageUnitId, ProductId productId) {
        if (storageUnitId == null) { throw new ShopException("Storage unit id is null"); }
        if (productId == null) { throw new ShopException("Product id is null"); }
        StorageUnit storageUnit = storageUnitRepository.findById(storageUnitId)
                .orElseThrow(() -> new ShopException("Storage unit not found"));

        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new ShopException("Product not found"));

        Optional<StockLevel> existingStockLevel = stockLevelRepository.findByProductAndStorageUnit(product, storageUnit);
        return existingStockLevel.map(StockLevel::getQuantity).orElse(0);

    }



    public boolean areFieldsValid(String... fields) {
        for (String field : fields) {
            if (field == null || field.isEmpty()) {
                return false;
            }
        }
        return true;
    }
    public boolean isInvalidZipCode(String zipCode) {
        return !zipCode.matches("\\d{5}");
    }

    public Tuple3<Product,StorageUnit,Optional<StockLevel>>
    checkParameters (StorageUnitId storageUnitId, ProductId productId, int quant) {

        if (storageUnitId == null) { throw new ShopException("Storage unit id is null"); }
        if (productId == null) { throw new ShopException("Product id is null"); }
        if (quant < 0) { throw new ShopException("Quant is less than zero"); }
        StorageUnit storageUnit = storageUnitRepository.findById(storageUnitId)
                .orElseThrow(() -> new ShopException("Storage unit not found"));

        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new ShopException("Product not found"));

        Optional<StockLevel> existingStockLevel = stockLevelRepository.findByProductAndStorageUnit(product, storageUnit);
        return Tuple3.of(product, storageUnit, existingStockLevel);
    }
    @Transactional
    public void createNewStock(Product product, StorageUnit storageUnit, int quantity) {
        StockLevel newStockLevel = new StockLevel();
        StockLevelId newStockLevelId = new StockLevelId(UUID.randomUUID());

        newStockLevel.setStockLevelId(newStockLevelId);
        newStockLevel.setProduct(product);
        newStockLevel.setStorageUnit(storageUnit);
        newStockLevel.setQuantity(quantity);
        stockLevelRepository.save(newStockLevel);
    }
    public List<StorageUnit> getAllStorageUnits () {
        //DEBUG
       /* List<StorageUnit> storageUnits = storageUnitRepository.findAll();
        int i =0;
        for (StorageUnit storageUnit : storageUnits) {
            i++;
            //System.out.println("StorageUnit"+i+storageUnit);
        }*/
        return storageUnitRepository.findAll();

    }
    public Optional<StorageUnit> findStorageUnitById(StorageUnitId storageUnitId) {
        return storageUnitRepository.findById(storageUnitId);
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\dip\StockLevelQueryDip.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.dip;

import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
import thkoeln.archilab.ecommerce.solution.storageunit.dto.StockLevelDto;

import java.util.List;

public interface StockLevelQueryDip {
    List<StockLevelDto> getStockDataForFulfillment(StorageUnitId storageUnitId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StockLevel.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;

import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import lombok.AccessLevel;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;


@Entity
public class StockLevel {

    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private StockLevelId stockLevelId;

    @ManyToOne
    @JoinColumn(name = "productId")
    private Product product;

    @ManyToOne
    @JoinColumn(name="storageUnitId")
    private StorageUnit storageUnit;

    private int quantity;

    public StockLevel() {}
    public StockLevel(StockLevelId stockLevelId, Product product, StorageUnit storageUnit, int quantity) {
        this.stockLevelId = stockLevelId;
        this.product = product;
        this.storageUnit = storageUnit;
        this.quantity = quantity;

    }


    public StockLevelId getStockLevelId() { return this.stockLevelId; }
    public Product getProduct() { return this.product; }
    public int getQuantity() { return this.quantity; }
    public StorageUnit getStorageUnit() { return this.storageUnit; }


    public void setStockLevelId(StockLevelId stockLevelId) { this.stockLevelId = stockLevelId; }
    public void setProduct(Product product) { this.product = product; }
    public void setQuantity(int quantity) { this.quantity = quantity; }
    public void setStorageUnit(StorageUnit storageUnit) { this.storageUnit = storageUnit; }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StockLevelId.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "StockLevelId"))
public class StockLevelId extends GenericId {
    public StockLevelId(UUID id) {
        super(id);
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StockLevelIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class StockLevelIdConverter extends GenericIdConverter<StockLevelId> {
    public StockLevelIdConverter() {
        super(StockLevelId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StockLevelRepository.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;

import java.util.List;
import java.util.Optional;

@Repository
public interface StockLevelRepository extends JpaRepository<StockLevel, StockLevelId> {
    boolean existsByProductAndQuantityGreaterThan(Product product, int quantity);
    List<StockLevel> findByProduct(Product product);
    List<StockLevel> findByStorageUnitStorageUnitId(StorageUnitId storageUnitId);
    Optional<StockLevel> findByProductAndStorageUnit(Product product, StorageUnit storageUnit);

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnit.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;

import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import lombok.AccessLevel;
import lombok.Setter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.storageunit.dip.StockLevelQueryDip;
import thkoeln.archilab.ecommerce.solution.storageunit.dto.StockLevelDto;

import java.util.*;


@Entity
@Component
public class StorageUnit {

    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private StorageUnitId storageUnitId;

    private String name;
    private Address address;


    public StorageUnit() {}
    public StorageUnit(StorageUnitId storageUnitId,String name, Address address) {
        this.storageUnitId = storageUnitId;
        this.name = name;
        this.address = address;
    }
    public StorageUnitId getStorageUnitId() { return storageUnitId; }
    public String getName() { return name; }
    public Address getAddress() { return address; }


    public void setStorageUnitId(StorageUnitId storageUnitId) { this.storageUnitId = storageUnitId; }
    public void setName(String name) { this.name = name; }
    public void setAddress(Address address) { this.address = address; }



    public Set<ProductId> fulfillableShoppingBasketParts(Map<ProductId, Integer> productQuantityMap,
                                                         StockLevelQueryDip stockLevelQueryDip) {


        List<StockLevelDto> currentStockData= stockLevelQueryDip.getStockDataForFulfillment(this.getStorageUnitId());
        StorageUnitId x =this.storageUnitId;
        Set<ProductId> fulfillableShoppingBasketProducts = new HashSet<>();
        for (Map.Entry<ProductId, Integer> entry : productQuantityMap.entrySet()) {
            ProductId productId = entry.getKey();
            Integer quantity = entry.getValue();
            Optional<StockLevelDto> optionalStockLevelDto = currentStockData.stream()
                    .filter(stockData -> stockData.getProductId().equals(productId))
                    .findFirst();
            if (optionalStockLevelDto.isPresent()) {
                StockLevelDto stockLevel = optionalStockLevelDto.get();
                if(stockLevel.getQuantity() >= quantity) {
                    fulfillableShoppingBasketProducts.add(productId);
                }
            }
        }
        return fulfillableShoppingBasketProducts;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitComparator.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;

import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.storageunit.dip.StockLevelQueryDip;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import java.util.Comparator;
import java.util.Map;

public class StorageUnitComparator implements Comparator<StorageUnit> {

    private final Map<ProductId,Integer> productQuantityMap;
    private final ZipCodeType customerZipCode;
    private final StockLevelQueryDip stockLevelQueryDip;

    public StorageUnitComparator(Map<ProductId,Integer> productQuantityMap, ZipCodeType customerZipCode,
                                 StockLevelQueryDip stockLevelQueryDip) {
        this.productQuantityMap = productQuantityMap;
        this.customerZipCode = customerZipCode;
        this.stockLevelQueryDip = stockLevelQueryDip;
    }

    @Override
    public int compare(StorageUnit unitA, StorageUnit unitB) {
        int fulfillableCount1 = unitA.fulfillableShoppingBasketParts(productQuantityMap,stockLevelQueryDip).size();
        int fulfillableCount2 = unitB.fulfillableShoppingBasketParts(productQuantityMap,stockLevelQueryDip).size();

        int fulfillableComparison = Integer.compare(fulfillableCount1, fulfillableCount2);
        if (fulfillableComparison != 0) {
           // System.out.println(fulfillableCount1 +"\n"+ fulfillableCount2);
            return fulfillableComparison;
        }
        int distance1 = customerZipCode.difference(unitA.getAddress().getZipCode());
        int distance2 = customerZipCode.difference(unitB.getAddress().getZipCode());

        //System.out.println(Integer.compare(distance2, distance1));
        return Integer.compare(distance2, distance1);

    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitId.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "StorageUnitId"))
public class StorageUnitId extends GenericId {
    public StorageUnitId(UUID id) {
        super(id);
    }

}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class StorageUnitIdConverter extends GenericIdConverter<StorageUnitId> {
    public StorageUnitIdConverter() {
        super(StorageUnitId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnitRepository.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.domain;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;


@Repository
public interface StorageUnitRepository extends JpaRepository<StorageUnit, StorageUnitId> {

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\dto\StockLevelDto.java ---
package thkoeln.archilab.ecommerce.solution.storageunit.dto;

import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;

@Getter
@Setter
public class StockLevelDto {
    private ProductId productId;
    private StorageUnitId storageUnitId;
    private int quantity;
    public StockLevelDto(ProductId productId, StorageUnitId storageUnitId, int quantity) {
        this.productId = productId;
        this.storageUnitId = storageUnitId;
        this.quantity = quantity;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\Tuple3.java ---
package thkoeln.archilab.ecommerce.solution.storageunit;

import java.util.Objects;

public class Tuple3<A, B, C> {
    public final A a;
    public final B b;
    public final C c;

    public Tuple3(A item1, B item2, C item3) {
        this.a = item1;
        this.b = item2;
        this.c = item3;
    }

    public static <A, B, C> Tuple3<A, B, C> of(A a, B b, C c) {
        return new Tuple3<>(a, b, c);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Tuple3<?, ?, ?> other = (Tuple3<?, ?, ?>) obj;
        return Objects.equals(a, other.a) && Objects.equals(b, other.b) && Objects.equals(c, other.c);
    }

    @Override
    public int hashCode() {
        return Objects.hash(a, b, c);
    }

    @Override
    public String toString() {
        return "(" + a + ", " + b + ", " + c + ")";
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\CustomerRegistrationUseCases.java ---
/*
 * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;

/**
 * This interface contains methods needed in the context of use cases concerning the registration of a customer.
 * The interface is probably incomplete, and will grow over time ...
 */
public interface CustomerRegistrationUseCases {
    /**
     * Registers a new customer
     *
     * @param name
     * @param emailAddress
     * @param address
     * @throws ShopException if ...
     *      - the customer with the given email address already exists
     *      - address is null
     */
    public void register( String name, EmailAddressType emailAddress, AddressType address );


    /**
     * Changes the address of a customer
     *
     * @param customerEmailAddress
     * @param customerEmailAddress
     * @param address
     * @throws ShopException if ...
     *      - the customer with the given email address does not exist,
     *      - address is null
     */
    public void changeAddress( EmailAddressType customerEmailAddress,
                               AddressType address );


    /**
     * Returns the data of a customer as an array of strings (name, emailAddress, street, city, zipCode)
     * @param customerEmailAddress
     * @return the customer data
     * @throws ShopException the customer with the given email address does not exist,
     */
    public CustomerType getCustomerData( EmailAddressType customerEmailAddress );



    /**
     * Clears all customers, including all orders and shopping baskets
     */
    public void deleteAllCustomers();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\CustomerType.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;

/**
 * This interface expresses the essence of a shop customer
 */
public interface CustomerType {
    String getName();
    EmailAddressType getEmailAddress();
    AddressType getAddress();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\AddressType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface AddressType {
    /**
     * @return the street as a string
     */
    public String getStreet();

    /**
     * @return the city as a string
     */
    public String getCity();

    /**
     * @return the zip code
     */
    public ZipCodeType getZipCode();

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an zip code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param street the street as a string
     * @param city the city as a string
     * @param zipCode the zip code
     * @return the address object matching the parameters
     * @throws ShopException if ...
     *      - street is null or empty
     *      - city is null or empty
     *      - zipCode is null
     */
     // public static AddressType of( String street, String city, ZipCodeType zipCode );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\EmailAddressType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface EmailAddressType {
    /**
     * @return the email address as a string
     */
    public String toString();


    /**
     * A special kind of "copy constructor": Returns a new email address object with
     * the same identifyer (the substring left of the "@" sign) as the current one, but
     * with a new domain substring (right of the "@" sign).
     * @param domainString - the new domain for the copied email address
     * @return the new email address
     * @throws ShopException if ...
     *     - domainString is null
     *     - the new email address would not be valid (see `of(...)` method)
     */
    public EmailAddressType sameIdentifyerDifferentDomain( String domainString );

    /**
     * Another special kind of "copy constructor": Returns a new email address object
     * with the same domain (the substring right of the "@" sign) as the current one, but
     * with a new identifyer substring (left of the "@" sign).
     * @param identifyerString - the new identifyer for the copied email address
     * @return the new email address
     * @throws ShopException if ...
     *     - identifyerString is null
     *     - the new email address would not be valid (see `of(...)` method)
     */
    public EmailAddressType sameDomainDifferentIdentifyer( String identifyerString );


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an email address, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param emailAddressAsString - the email address as a string.
     *      We will use a much simplified validation method to check if the email address is valid:
     *      - it must contain exactly one '@' character.
     *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
     *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
     *      - the substrings before and after the '@' may contain one or several '.' as separators
     *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
     *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
     *        (for simplicity we do not allow any other domains)
     * @return a new EmailAddressType object matching the given email address
     * @throws ShopException if ...
     *      - emailAddressAsString is null
     *      - emailAddressAsString is not a valid email address (see above)
     */
     // public static EmailAddressType of( String emailAddressAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MoneyType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface MoneyType {
    /**
     * @return the amount of money
     */
    public Float getAmount();


    /**
     * @return the currency unit of the money
     */
    public String getCurrencyUnit();


    /**
     * @param otherMoney
     * @return this + otherMoney, as a new object
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currencyUnit != this.currencyUnit
     */
    public MoneyType add( MoneyType otherMoney );


    /**
     * @param otherMoney
     * @return this - otherMoney, as a new object
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currencyUnit != this.currencyUnit
     *      - otherMoney > this
     */
    public MoneyType subtract( MoneyType otherMoney );


    /**
     * @param factor
     * @return this * factor, as a new object
     * @throws ShopException if ...
     *     - factor < 0
     */
    public MoneyType multiplyBy( int factor );

    /**
     * @param otherMoney
     * @return true, if this > otherMoney
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currencyUnit != this.currencyUnit
     */
    public boolean largerThan( MoneyType otherMoney );


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates a money object from an amount and a currency unit (as string).
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param amount the amount of money (must be >= 0)
     * @param currencyUnit the currency unit of the money (allowed values: "EUR", "CHF")
     * @return a new Money object with the given amount and currency unit
     * @throws ShopException if ...
     *   - amount is null
     *   - amount < 0
     *   - currency unit is null
     *   - currency unit is not one of the allowed values
     */
     // public static MoneyType of( Float amount, String currencyUnit );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\ZipCodeType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import com.fasterxml.jackson.annotation.JsonIgnore;
import thkoeln.archilab.ecommerce.ShopException;

public interface ZipCodeType {
    /**
     * @return the zip code as a string
     */
    public String toString();

    /**
     * You will need some idea of "imprecise difference" between two zip codes for properly
     * implementing storage units in your shopping platform. This method calculates such a
     * difference. You can decide for yourself what values you return, unless you comply
     * with the following rules.
     * - The return value is 0 if both zip codes are the same
     * - If not:
     *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
     *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
     *        So, 56733 and 56734 have the same difference as 56733 and 56739.
     *      - The difference grows if more digits (counted from the right side) differ.
     *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
     *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
     *        53876 and 54876 have the same difference as 53876 and 57261.
     *      - However, the difference between 5abcd and 6rstu must be smaller than the one
     *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
     *        one between 5abcd and 9rstu.
     *      - This last condition reflects the fact the first digits of a zip code marks a region
     *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
     *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
     *        other.
     * @param otherZipCode
     * @return the calculated difference
     * @throws ShopException if otherZipCode is null
     */
    public int difference( ZipCodeType otherZipCode );


    /**
     * For the currently used way of deciding on the best fitting storage unit for a order,
     * we need to know the first digit of the zip code.
     */
    @JsonIgnore
    public Integer getFirstDigitZipCode();


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an zip code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param zipCodeAsString - the zip code as a string.
     *      We will use a much simplified validation method to check if the zip code is valid:
     *      - It must contain exactly 5 digits.
     *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid zip code, but 20001 is valid)
     * @return a new zip code object matching the given string
     * @throws ShopException if ...
     *      - zipCodeAsString is null
     *      - zipCodeAsString is not a valid zip code (see above)
     */
     // public static ZipCodeType of( String zipCodeAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\CustomerTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;


import thkoeln.archilab.ecommerce.usecases.CustomerType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;

/**
 * This is a test helper interface provides access to predefined test data for
 * customers.
 */
public interface CustomerTestHelper {
    /**
     * This method calls the use case implementation to register all customers specified in the
     * test data set.
     * If you use the debugger and want to identify _which_ test customer you currently look at:
     * The indices are coded into the house number (in the customer's address) and in the first
     * cipher of the zip code. This is the list of customers:
     *
     * +-------+-------------------+--------+---------------------
     * | Index | Name              | PLZ    | EmailAddress
     * +-------+-------------------+--------+---------------------
     * | 0     | Max Mueller       | 02314  | 99Z@example.com
     * | 1     | Sophie Schmitz    | 02368  | a@4.com
     * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
     * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
     * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
     * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
     * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
     * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
     * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
     * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
     * +-------+-------------------+--------+---------------------
     */
    void registerAllCustomers();


    /**
     * @return the number of test customers in the test data set.
     */
    int getNumberOfCustomers();


    /**
     * @param index the index of the customer in the test data set.
     * @return the name of the test customer with the given index.
     */
    String getCustomerName( int index );


    /**
     * @param index the index of the customer in the test data set.
     * @return the email address of the test customer with the given index.
     */
    EmailAddressType getCustomerEmailAddress( int index );


    /**
     * @param index the index of the customer in the test data set.
     * @return the address of the test customer with the given index.
     */
    AddressType getCustomerAddress( int index );


    /**
     * @param index the index of the customer in the test data set.
     * @return the test customer with the given index.
     */
    CustomerType getCustomer( int index );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.Enumeration;

import static org.junit.jupiter.api.Assertions.*;

public class FactoryMethodInvoker {

    public static EmailAddressType instantiateEmailAddress( String emailAddressAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for EmailAddressType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, emailAddressAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + emailAddressAsString + "'", e );
        }
        assertNotNull( instance );
        return (EmailAddressType) instance;
    }


    public static AddressType instantiateAddress(
            String street, String city, ZipCodeType zipCode ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of",
                    String.class, String.class, ZipCodeType.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for AddressType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, street, city, zipCode );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" +
                    street + "', '" + city + "', '" + zipCode + "'", e );
        }
        assertNotNull( instance );
        return (AddressType) instance;
    }


    public static ZipCodeType instantiateZipCode( String zipCodeAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for ZipCodeType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, zipCodeAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + zipCodeAsString + "'", e );
        }
        assertNotNull( instance );
        return (ZipCodeType) instance;
    }


    public static MoneyType instantiateMoney( Float amount, String currencyUnit ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for MoneyType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, amount, currencyUnit );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + amount + "', '" + currencyUnit + "'", e );
        }
        assertNotNull( instance );
        return (MoneyType) instance;
    }


    private static Class<?> findImplementation( Class<?> interfaceClass ) {
        Method factoryMethod = null;
        try {
            String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
            Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
            assertNotNull( implementingClass );
            return implementingClass;
        } catch (Exception e) {
            fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
            return null; // This line will never be reached, but it's necessary to satisfy the compiler
        }
    }


    private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
            throws ClassNotFoundException, IOException {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        String path = packageName.replace( '.', '/' );
        Enumeration<URL> resources = classLoader.getResources( path );
        int count = 0;
        Class<?> result = null;
        while (resources.hasMoreElements()) {
            URL resource = resources.nextElement();
            File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
            File[] files = directory.listFiles();
            for ( File file : files ) {
                if ( file.getName().endsWith( ".class" ) ) {
                    String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
                    Class<?> clazz = Class.forName( className );
                    if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
                        count++;
                        result = clazz;
                    }
                }
            }
        }
        assertEquals( 1, count, "There should be exactly one implementing class" );
        return result;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\CustomerTestHelperImpl.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.CustomerType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
import thkoeln.archilab.ecommerce.usecases.masterdata.MockCustomer;

import static org.junit.jupiter.api.Assertions.assertThrows;

/**
 * This is a test helper class that initializes and registers customers in the system,
 * using the given interface(s).
 */
@Component
@SuppressWarnings("PMD")
public class CustomerTestHelperImpl implements CustomerTestHelper {

    private CustomerRegistrationUseCases customerRegistrationUseCases;

    @Autowired
    public CustomerTestHelperImpl( CustomerRegistrationUseCases customerRegistrationUseCases ) {
        this.customerRegistrationUseCases = customerRegistrationUseCases;
    }

    private final static String[] CUSTOMER_NAME = new String[]{
            "Max Mueller",
            "Sophie Schmitz",
            "Irene Mihalic",
            "Emilia Fischer",
            "Filiz Polat",
            "Lina Wagner",
            "Leon Becker",
            "Agnieszka Kalterer",
            "Felix Bauer",
            "Lara Schulz"
    };

    private final static EmailAddressType[] CUSTOMER_EMAIL = new EmailAddressType[]{
            FactoryMethodInvoker.instantiateEmailAddress( "99Z@example.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "a@4.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "irene@wearefreedomnow.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "emilia.fischer@example.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "j877d3@example.this.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "lina.marie.wagner@example.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "agna@here.ch" ),
            FactoryMethodInvoker.instantiateEmailAddress( "felix.bauer@example.org" ),
            FactoryMethodInvoker.instantiateEmailAddress( "lara.schulz@example.at" )
    };

    // The following array is used to create a list of addresss for the customers.
    // The indices are coded into the house number.
    // - Persons 0 - 5 are used for proximity tests with one storage unit.
    private final static AddressType[] CUSTOMER_ADDRESS = new AddressType[]{
            FactoryMethodInvoker.instantiateAddress(
                    "Marktstraße 0", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02314" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Hauptstraße 1", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02368" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Kirchplatz 2", "Niemandstown",
                    FactoryMethodInvoker.instantiateZipCode( "12345" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Schulstraße 3", "Geisterhausen",
                    FactoryMethodInvoker.instantiateZipCode( "31463" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Rosenweg 4", "Kuhhausen",
                    FactoryMethodInvoker.instantiateZipCode( "72162" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Wiesenstraße 5", "Waldschenkensdorf",
                    FactoryMethodInvoker.instantiateZipCode( "82195" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Muehlenweg 6", "Koeln",
                    FactoryMethodInvoker.instantiateZipCode( "50667" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Goethestraße 7", "Frankfurt am Main",
                    FactoryMethodInvoker.instantiateZipCode( "60311" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Dorfstraße 8", "Stuttgart",
                    FactoryMethodInvoker.instantiateZipCode( "70173" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Bahnhofstraße 9", "Muenchen",
                    FactoryMethodInvoker.instantiateZipCode( "80331" ) )
    };

    private final static CustomerType[] mockCustomers;

    static {
        mockCustomers = new CustomerType[CUSTOMER_NAME.length];
        for ( int i = 0; i < CUSTOMER_NAME.length; i++ ) {
            mockCustomers[i] = new MockCustomer(
                    CUSTOMER_NAME[i], CUSTOMER_EMAIL[i], CUSTOMER_ADDRESS[i] );
        }
    }


    @Override
    public void registerAllCustomers() {
        for ( int i = 0; i < CUSTOMER_NAME.length; i++ ) {
            registerCustomer( CUSTOMER_NAME[i], CUSTOMER_EMAIL[i], CUSTOMER_ADDRESS[i] );
        }
    }


    private void registerCustomer( String name, EmailAddressType emailAddress, AddressType address ) {
        customerRegistrationUseCases.register( name, emailAddress, address );
    }


    @Override
    public int getNumberOfCustomers() {
        return CUSTOMER_NAME.length;
    }


    @Override
    public String getCustomerName( int index ) {
        if ( index < 0 || index >= CUSTOMER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return CUSTOMER_NAME[index];
    }


    @Override
    public EmailAddressType getCustomerEmailAddress( int index ) {
        if ( index < 0 || index >= CUSTOMER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return CUSTOMER_EMAIL[index];
    }


    @Override
    public AddressType getCustomerAddress( int index ) {
        if ( index < 0 || index >= CUSTOMER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return CUSTOMER_ADDRESS[index];
    }


    @Override
    public CustomerType getCustomer( int index ) {
        if ( index < 0 || index >= CUSTOMER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return mockCustomers[index];
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\StockTestHelperImpl.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;

import java.util.*;

/**
 * This is a test helper class that initializes and registers products (but without stock)
 * in the system, using the given interface(s).
 */
@Component
@SuppressWarnings("PMD")
public class StockTestHelperImpl
                        implements ProductTestHelper, StorageUnitTestHelper {
    private ProductCatalogUseCases productCatalogUseCases;
    private StorageUnitUseCases storageUnitUseCases;
    private static Random random = new Random();

    private static final String EUR = "EUR";
    private static final int PRODUCT_NUMOF = 15;
    private static final Object[][] PRODUCT_DATA = new Object[][]{
            {null, "0-TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
                    1.5f, FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 10.0f, EUR ),
                    "0"},
            {null, "1-EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
                    0.3f, FactoryMethodInvoker.instantiateMoney( 2.5f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 4.0f, EUR ),
                    "0"},
            {null, "2-MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
                    7.2f, FactoryMethodInvoker.instantiateMoney( 50.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
                    "0"},
            {null, "3-Gh-25", "Kompakter und leichter Akku für mobile Geräte",
                    null, FactoryMethodInvoker.instantiateMoney( 6.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 8.0f, EUR ),
                    "0"},
            {null, "4-MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
                    null, FactoryMethodInvoker.instantiateMoney( 0.6f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
                    "0"},
            {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
                    1.0f, FactoryMethodInvoker.instantiateMoney( 150.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 250.0f, EUR ),
                    "0"},
            {null, "6-Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
                    null, FactoryMethodInvoker.instantiateMoney( 0.3f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 0.5f, EUR ),
                    "0"},
            {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
                    6.0f, FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 120.0f, EUR ),
                    "123"},
            {null, "8-JKL-67", "Wasserdichtes Gehäuse",
                    3.0f, FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 1.2f, EUR ),
                    "467"},
            {null, "9-MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
                    5.5f, FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 45.0f, EUR ),
                    "578"},
            {null, "10-PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
                    4.0f, FactoryMethodInvoker.instantiateMoney( 20.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 35.0f, EUR ),
                    "567"},
            {null, "11-STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
                    null, FactoryMethodInvoker.instantiateMoney( 200.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 350.0f, EUR ),
                    "478"},
            {null, "12-VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
                    null, FactoryMethodInvoker.instantiateMoney( 15.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
                    "5"},
            {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
                    3.5f, FactoryMethodInvoker.instantiateMoney( 60.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 100.0f, EUR ),
                    "78"},
            {null, "14-Nosedive", "Klammer zum Verschließen der Nase beim Tauchen",
                    5.0f, FactoryMethodInvoker.instantiateMoney( 2.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
                    "457"}
    };
    

    // These addresss are used for the storage units. The storage unit name will equal
    // the zip code of the site. Their index number will be visible in the house number.
    // The storage units are used as such:
    // - storage unit 0 is holds all products 0 - 6, and is used for all tests where multiple
    //   deliveries are irrelevant.
    // - storage units 1 - 3 are used for the proximity tests, where you can deliver products 7 to
    //   to a customer from the closest storage unit.
    // - storage units 4 - 8 are used for the tests where you need to deliver products 8 - 14 in
    //   the most cost-efficient way, as multiple deliveries.
    // - storage unit 9 is empty.
    private final static int STORAGE_UNIT_NUMOF = 10;
    private final static AddressType[] STORAGE_UNIT_ADDRESS = new AddressType[]{
            FactoryMethodInvoker.instantiateAddress(
                    "Stapelallee 0", "Potsdam",
                    FactoryMethodInvoker.instantiateZipCode( "14476" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Lagerhausstr. 1", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02345" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Speicherplatz 2", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02313" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Ablageweg 3", "Reichswürgen",
                    FactoryMethodInvoker.instantiateZipCode( "44923" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Paketstellenallee 4", "Düsseldorf",
                    FactoryMethodInvoker.instantiateZipCode( "40588" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Kaputte-Sachen-Straße 5", "Düren",
                    FactoryMethodInvoker.instantiateZipCode( "52355" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Aufbewahrungsweg 6", "Viernheim",
                    FactoryMethodInvoker.instantiateZipCode( "68519" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Paketallee 7", "Baden-Baden",
                    FactoryMethodInvoker.instantiateZipCode( "76532" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Sendenstr. 8", "Senden",
                    FactoryMethodInvoker.instantiateZipCode( "89250" ) ),
            FactoryMethodInvoker.instantiateAddress(
                    "Schickweg 9", "Hohenroth",
                    FactoryMethodInvoker.instantiateZipCode( "97618" ) )
    };
    private final static UUID[] STORAGE_UNIT_ID = new UUID[STORAGE_UNIT_NUMOF];


    // These data structures contain the stock of the products in the storage units.
    // PRODUCT_STOCK is a map product name -> Integer[STORAGE_UNIT_NUMOF].
    // The Integer[STORAGE_UNIT_NUMOF] contains the stock of the product in each of
    // the storage units.
    //
    // The following rules apply:
    // - product 0 is out of stock
    // - product 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in storage unit 0
    // - product 4 / 5 / 6 have a random stock between 30 and 130, also all ONLY in storage unit 0
    //   (these are the products used for tests on how to add and remove stock)
    // - the others have a random stock between 30 and 130, distributed over several
    //   storage units. Here we follow this convention for simplicity:
    //   - Assume that the product is available in <n> storage units. Then the first <n-1> storage units
    //     in the list (in ascending sequence) contain 3, and all the remaining stock is in the
    //     last storage unit.

    private static final Map<String, Integer[]> PRODUCT_STOCK = new HashMap<>();

    static {
        // products 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
        PRODUCT_STOCK.put( (String) PRODUCT_DATA[0][1],
                getStockDistribution( 0, (String) PRODUCT_DATA[0][6] ) );
        PRODUCT_STOCK.put( (String) PRODUCT_DATA[1][1],
                getStockDistribution( 10, (String) PRODUCT_DATA[1][6] ) );
        PRODUCT_STOCK.put( (String) PRODUCT_DATA[2][1],
                getStockDistribution( 20, (String) PRODUCT_DATA[2][6] ) );
        PRODUCT_STOCK.put( (String) PRODUCT_DATA[3][1],
                getStockDistribution( 30, (String) PRODUCT_DATA[3][6] ) );

        // The other products have a random stock between 30 and 130,
        for ( int i = 4; i < PRODUCT_NUMOF; i++ ) {
            Integer totalNumber = random.nextInt( 100 ) + 30;
            Integer[] stockInStorageUnits =
                    getStockDistribution( totalNumber, (String) PRODUCT_DATA[i][6] );
            PRODUCT_STOCK.put( (String) PRODUCT_DATA[i][1], stockInStorageUnits );
        }
    }

    /**
     * This method creates a random stock distribution for the given product.
     *
     * @param totalQuantity - the total number of products in the storage units
     * @param zeroToNine  - a string with numbers between 0 and 9, representing the storage units
     * @return an Integer array with the stock distribution for the product, according to
     * the rules described above.
     */
    private static Integer[] getStockDistribution( Integer totalQuantity, String zeroToNine ) {
        Integer[] stockInStorageUnits = new Integer[STORAGE_UNIT_NUMOF];
        for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) stockInStorageUnits[i] = 0;
        TreeSet<Integer> storageUnitIndices = getStorageUnitIndices( zeroToNine );
        int numOfIndices = storageUnitIndices.size();
        int currentIndexNumber = 0;
        int currentQuantity = totalQuantity;
        for ( Integer storageUnitIndex : storageUnitIndices ) {
            currentIndexNumber++;
            if ( currentIndexNumber < numOfIndices ) {
                stockInStorageUnits[storageUnitIndex] = 3;
                currentQuantity -= 3;
            } else {
                stockInStorageUnits[storageUnitIndex] = currentQuantity;
            }
        }
        return stockInStorageUnits;
    }

    private static TreeSet<Integer> getStorageUnitIndices( String zeroToNine ) {
        TreeSet<Integer> storageUnitIndices = new TreeSet<>();
        for ( int i = 0; i < zeroToNine.length(); i++ ) {
            storageUnitIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
        }
        return storageUnitIndices;
    }


    @Autowired
    public StockTestHelperImpl( ProductCatalogUseCases productCatalogUseCases,
                                         StorageUnitUseCases storageUnitUseCases ) {
        this.productCatalogUseCases = productCatalogUseCases;
        this.storageUnitUseCases = storageUnitUseCases;
    }


    @Override
    public void addAllProducts() {
        int i = 0;
        for ( Object[] productData : PRODUCT_DATA ) {
            UUID newId = productCatalogUseCases.addProductToCatalog(
                    (String) productData[1], (String) productData[2],
                    (Float) productData[3], (MoneyType) productData[4],
                    (MoneyType) productData[5] );
            // The first element of the product data is the id, which was initialized with null before, but can now be set
            PRODUCT_DATA[i][0] = newId;
            i++;
        }
    }


    @Override
    public int numberOfProducts() {
        return PRODUCT_NUMOF;
    }


    @Override
    public UUID getProductId( int index ) {
        if ( index < 0 || index >= PRODUCT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (UUID) PRODUCT_DATA[index][0];
    }


    @Override
    public MoneyType getBuyingPrice( int index ) {
        if ( index < 0 || index >= PRODUCT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (MoneyType) PRODUCT_DATA[index][4];
    }


    @Override
    public MoneyType getSellingPrice( int index ) {
        if ( index < 0 || index >= PRODUCT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (MoneyType) PRODUCT_DATA[index][5];
    }


    @Override
    public void addAllStorageUnits( boolean withStock ) {
        for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) {
            STORAGE_UNIT_ID[i] = storageUnitUseCases.addNewStorageUnit(
                    STORAGE_UNIT_ADDRESS[i].getStreet(),
                    STORAGE_UNIT_ADDRESS[i] );
        }
        if ( withStock ) {
            addAllStock();
        }
    }


    private void addAllStock() {
        for ( Object[] productData : PRODUCT_DATA ) {
            Integer[] stockInStorageUnits =
                    PRODUCT_STOCK.get( productData[1] );
            for ( int iStorageUnit = 0; iStorageUnit < STORAGE_UNIT_NUMOF; iStorageUnit++ ) {
                if ( stockInStorageUnits[iStorageUnit] > 0 )
                    storageUnitUseCases.addToStock(
                            STORAGE_UNIT_ID[iStorageUnit], (UUID) productData[0],
                            stockInStorageUnits[iStorageUnit] );
            }
        }
    }


    @Override
    public int numberOfStorageUnits() {
        return STORAGE_UNIT_NUMOF;
    }


    @Override
    public UUID getStorageUnitId( int index ) {
        if ( index < 0 || index >= STORAGE_UNIT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return STORAGE_UNIT_ID[index];
    }


    @Override
    public Integer getStorageUnitStock( int storageUnitIndex, int productIndex ) {
        if ( storageUnitIndex < 0 || storageUnitIndex >= STORAGE_UNIT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + storageUnitIndex );
        }
        if ( productIndex < 0 || productIndex >= PRODUCT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + productIndex );
        }
        String productName = (String) PRODUCT_DATA[productIndex][1];
        Integer[] stockInStorageUnits = PRODUCT_STOCK.get( productName );
        Integer foundStock = stockInStorageUnits[storageUnitIndex];
        return foundStock == null ? 0 : foundStock;
    }


    @Override
    public int findStorageUnitIndex( UUID storageUnitId ) {
        for ( int i = 0; i < STORAGE_UNIT_NUMOF; i++ ) {
            if ( STORAGE_UNIT_ID[i].equals( storageUnitId ) ) {
                return i;
            }
        }
        throw new IllegalArgumentException( "No test storage unit with UUID id " + storageUnitId );
    }


    @Override
    public int findProductIndex( UUID productId ) {
        for ( int iProductData = 0; iProductData < STORAGE_UNIT_NUMOF; iProductData++ ) {
            Object[] productData = PRODUCT_DATA[iProductData];
            if ( productData[0].equals( productId ) ) {
                return iProductData;
            }
        }
        throw new IllegalArgumentException( "No test product with UUID id " + productId );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockCustomer.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import lombok.Setter;
import thkoeln.archilab.ecommerce.usecases.CustomerType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;


import java.util.Objects;

@Setter
public class MockCustomer implements CustomerType {
    private String name;
    private EmailAddressType emailAddressType;
    private AddressType addressType;


    public MockCustomer( String name, EmailAddressType emailAddressType, AddressType addressType) {
        this.name = name;
        this.emailAddressType = emailAddressType;
        this.addressType = addressType;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public EmailAddressType getEmailAddress() {
        return emailAddressType;
    }

    @Override
    public AddressType getAddress() {
        return addressType;
    }

    @Override
    public boolean equals( Object o ) {
        if ( this == o ) return true;
        if ( !( o instanceof MockCustomer ) ) return false;
        MockCustomer that = (MockCustomer) o;
        return Objects.equals( getName(), that.getName() ) &&
                Objects.equals( emailAddressType, that.emailAddressType ) &&
                Objects.equals( addressType, that.addressType );
    }

    @Override
    public int hashCode() {
        return Objects.hash( getName(), emailAddressType, addressType );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ProductTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;

public interface ProductTestHelper {
    /**
     * Adds all test products to the database.
     * If you use the debugger and want to identify _which_ test product you currently look at:
     * The indices are coded into the first number in the name string of the product, like e.g.
     * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
     */
    void addAllProducts();


    /**
     * @return the number of test products in the database
     */
    int numberOfProducts();


    /**
     * @param index
     * @return the id of the test product at the given index
     */
    UUID getProductId( int index );


    /**
     * @param productId - the id of the product in the test data
     * @return the index of the test product with that id
     */
    int findProductIndex( UUID productId );


    /**
     * @param index
     * @return the buying price of test product at the given index
     */
    MoneyType getBuyingPrice( int index );


    /**
     * @param index
     * @return the selling price of test product at the given index
     */
    MoneyType getSellingPrice( int index );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.usecases.*;

/**
 * Removes everything :-)
 */
@Service
public class Purgatory {
    @Autowired
    private CustomerRegistrationUseCases customerRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private OrderUseCases orderUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private StorageUnitUseCases storageUnitUseCases;

    public void deleteEverything() {
        orderUseCases.deleteAllOrders();
        shoppingBasketUseCases.emptyAllShoppingBaskets();
        storageUnitUseCases.deleteAllStorageUnits();
        customerRegistrationUseCases.deleteAllCustomers();
        productCatalogUseCases.deleteProductCatalog();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;

@Component
@Slf4j
@Profile("!test")
@SuppressWarnings("PMD")
public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
    private Purgatory purgatory;
    private CustomerTestHelper customerTestHelper;
    private ProductTestHelper productTestHelper;
    private StorageUnitTestHelper storageUnitTestHelper;


    @Autowired
    public StartupListener( Purgatory purgatory,
                            CustomerTestHelper customerTestHelper,
                            ProductTestHelper productTestHelper,
                            StorageUnitTestHelper storageUnitTestHelper ) {
        this.purgatory = purgatory;
        this.customerTestHelper = customerTestHelper;
        this.productTestHelper = productTestHelper;
        this.storageUnitTestHelper = storageUnitTestHelper;
    }

    @Override
    public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
        log.info( "StartupListener initializing master data ..." );
        purgatory.deleteEverything();
        customerTestHelper.registerAllCustomers();
        productTestHelper.addAllProducts();
        storageUnitTestHelper.addAllStorageUnits( true );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StorageUnitTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import java.util.UUID;

public interface StorageUnitTestHelper {
    /**
     * Adds the test storage units to the system.
     * If you want to use the storage units, or want to know which index the storage unit has that you see
     * in the debugger, the following rules apply:
     * - The storage unit name will equal the street name of the address of the storage unit.
     * - The index number is visible in the house number. Example: storage unit 3 is located at
     *   "Ablageweg 3", and that is also its name.
     *
     *  The storage units are used in the tests as follows:
     *  - storage unit 0 holds all products 0 - 6, and is used for all tests where it is not relevant
     *    to split one shopping basket into several orders.
     *  - storage units 1 - 3 are used for the proximity tests, where you can deliver product 7 to
     *    to a customer from the closest storage unit.
     *  - storage units 4 - 8 are used for the tests where you need to deliver products 8 - 14 in
     *    the most cost-efficient way, as multiple deliveries.
     *  - storage unit 9 is empty.
     *
     *  If withStock is true, then the storage units are filled with products. This happens
     *  according to the following rules:
     *  - products 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
     *    ONLY available in storage unit 0. (This means that product 0 out of stock everywhere.)
     *  - products 4, 5, 6 have a random stock between 30 and 130, also all ONLY in storage unit 0
          (these are the products used for tests on how to add and remove stock)
     *  - product 7 has a random stock between 30 and 130, distributed over
     *    storage units 1, 2, and 3. You can use this to test if the appropriate storage unit is found
     *    for a shopping basket with only product 7 in it, but with different quantities (<= 3, or > 3).
     *  - The other products (8 - 14) have also a random stock between 30 and 130, all distributed
     *    over several storage units. The distribution is done as follows:
     *    Assume that the product is available in <n> storage units. Then the first <n-1> storage units
     *    in the list (in ascending sequence) contain 3, and all the remaining stock is in the
     *    last storage unit.
     *
     *    This is how the stock of products could be distributed
     *    (Wx = storage unit x with its zip code, Px = product x,
     *    numbers marked with (*) are random large numbers):
     *
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
     *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *    | P0   |      |     |     |      |     |      |     |       |      |     |
     *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
     *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
     *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
     *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
     *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
     *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
     *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
     *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
     *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
     *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
     *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
     *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
     *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
     *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *
     * @param withStock if true, the stock of the products is added to the storage unit. Otherwise, the
     *                           the stock is not added and the storage unit is empty.
     */
    public void addAllStorageUnits( boolean withStock );


    /**
     * @return the number of test storage units in the database
     */
    int numberOfStorageUnits();


    /**
     * @param index
     * @return the id of the test storage unit at the given index
     */
    UUID getStorageUnitId( int index );


    /**
     * @param storageUnitId - the id of the storage unit in the test data
     * @return the index of the test storage unit with that id
     */
    int findStorageUnitIndex( UUID storageUnitId );


    /**
     * @param productIndex - the index of the product in the test data
     * @param storageUnitIndex - the index of the storage unit in the test data
     * @return the number of products (stock) available in the storage unit at the given index
     */
    Integer getStorageUnitStock( int storageUnitIndex, int productIndex );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\OrderUseCases.java ---
/*
 * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
 */
package thkoeln.archilab.ecommerce.usecases;


import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Map;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of the order history of a customer.
 */
public interface OrderUseCases {

    /**
     * Returns a map showing which products have been ordered by a customer and how many of each product
     *
     * @param customerEmailAddress
     * @return the order history of the customer (map is empty if the customer has not ordered anything yet)
     * @throws ShopException if
     *      - customerEmailAddress is null
     *      - the customer with the given email address does not exist
     */
    public Map<UUID, Integer> getOrderHistory( EmailAddressType customerEmailAddress );



    /**
     * @return the number of products in a given order. If the product is not a part of the order, the method
     *         returns 0. No exception is thrown.
     * @param orderId - the id of the order to be checked
     * @param productId - the id of the product for which we want to know the quantity
     * @throws ShopException if
     *     - orderId is null, or doesn't exist in the system
     *     - productId is null, or doesn't exist in the system
     */
    public Integer getOrderQuantForProduct( UUID orderId, UUID productId );


    /**
     * @return the id of the storage unit that is responsible for the given order
     * @param orderId - the id of the order to be checked
     * @throws ShopException if
     *      - orderId is null, or doesn't exist in the system
     */
    public UUID getStorageUnitIdForOrder( UUID orderId );


    /**
     * Deletes all orders in the system
     */
    public void deleteAllOrders();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\ProductCatalogUseCases.java ---
/*
 * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;


/**
 * This interface contains methods needed in the context of use cases concerning the product catalog.
 * The interface is probably incomplete, and will grow over time ...
 */

public interface ProductCatalogUseCases {
    /**
     * Adds a new product to the shop catalog
     * @param name
     * @param descriptionOf
     * @param size
     * @param buyingPrice
     * @param sellingPrice
     * @return the id of the new product
     * @throws ShopException if ...
     *      - the product id already exists,
     *      - name or description are null or empty,
     *      - the size is <= 0 (but can be null!),
     *      - the buying price is null or <= 0,
     *      - the buyingPrice is null,
     *      - the selling price is null,
     *      - the selling price is lower than the buyingPrice
     */
    public UUID addProductToCatalog( String name, String descriptionOf, Float size,
                                           MoneyType buyingPrice, MoneyType sellingPrice );


    /**
     * Removes a product from the shop catalog
     * @param productId
     * @throws ShopException if
     *      - productId is null
     *      - the product id does not exist
     *      - the product is still in stock
     *      - the product is still in a shopping basket, or referenced by a completed order
     */
    public void removeProductFromCatalog( UUID productId );


    /**
     * Get the selling price of a given product
     * @param productId
     * @return the selling price
     * @throws ShopException if ...
     *      - productId is null,
     *      - the product with that id does not exist
     */
    public MoneyType getSellingPrice( UUID productId );


    /**
     * Clears the product catalog, i.e. removes all products from the catalog, including all the stock,
     * all the reservations and all the orders.
     */
    public void deleteProductCatalog();

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingBasketUseCases.java ---
/*
 * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Map;
import java.util.Set;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of use cases handling the shopping basket.
 * The interface is probably incomplete, and will grow over time ...
 */
public interface ShoppingBasketUseCases {
    /**
     * Adds a product to the cart of a customer
     *
     * @param customerEmailAddress
     * @param productId
     * @param quantFor
     * @throws ShopException if ...
     *          - customerEmailAddress is null,
     *          - the customer with the given email address does not exist,
     *          - productId is null,
     *          - the product with productId does not exist
     *          - the Quantity is negative,
     */
    public void addProductToShoppingBasket( EmailAddressType customerEmailAddress,
                                                 UUID productId, int quantFor );


    /**
     * Removes a product from the cart of a customer
     *
     * @param customerEmailAddress
     * @param productId
     * @param quantFor
     * @throws ShopException if ...
     *          - customerEmailAddress is null,
     *          - the customer with the given email address does not exist,
     *          - productId is null,
     *          - the product with productId does not exist
     *          - the Quantity is negative
     *          - the product is not in the shopping basket in the requested Quantity
     */
    public void removeProductFromShoppingBasket( EmailAddressType customerEmailAddress,
                                                      UUID productId, int quantFor );


    /**
     * Returns a map showing which products are in the cart of a customer and how many of each product
     *
     * @param customerEmailAddress
     * @return the cart of the customer (map is empty if the cart is empty)
     * @throws ShopException if
     *          - customerEmailAddress is null,
     *          - the customer with the given email address does not exist
     */
    public Map<UUID, Integer> getShoppingBasketAsMap( EmailAddressType customerEmailAddress );


    /**
     * Returns the current value of all products in the cart of a customer
     *
     * @param customerEmailAddress
     * @return the cart of the customer
     * @throws ShopException if
     *          - customerEmailAddress is null,
     *          - the customer with the given email address does not exist
     */
    public MoneyType getShoppingBasketAsMoneyValue( EmailAddressType customerEmailAddress );




    /**
     * Checks out the cart of a customer
     *
     * @param customerEmailAddress
     * @return A set of ids belonging to orders that were created during the checkout. If the shopping basket can
     *         only be served from more than one storage unit, each delivery from a storage unit gets a
     *         dedicated order. I.e. if there is just one delivery, then the set will contain just one order id.
     *         If there are multiple deliveries, the set will contain multiple order ids.
     * @throws ShopException if
     *      - customerEmailAddress is null or empty
     *      - the customer with the given email address does not exist, or if the cart is empty
     * @throws
     *      - ShopException if customerEmailAddress is null
     *      - InsufficientStockException if there is not enough stock level for to serve the order
     *        for all products in the shopping basket
     */
    public Set<UUID> checkout( EmailAddressType customerEmailAddress );


    /**
     * Empties all shopping baskets in the system
     */
    public void emptyAllShoppingBaskets();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\usecases\StorageUnitUseCases.java ---
/*
 * Copyright ArchiLab 2025, TH Köln, University of Applied Sciences
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;

import java.util.UUID;

/**
 * This interface contains methods needed in the context of handling the shop stock,
 * i.e. managing storage units, and adding / removing products in the storage unit.
 */
public interface StorageUnitUseCases {
    /**
     *
     * @param name
     * @param address
     * @return the id of the new storage unit
     * @throws ShopException if ...
     *      - name is null or empty
     *      - address is null
     */
    public UUID addNewStorageUnit( String name, AddressType address );


    /**
     * Deletes all storage units from the shop. Intended for testing purposes.
     */
    public void deleteAllStorageUnits();


    /**
     * Adds a certain Quantity of a given product to the stock
     * @param storageUnitId
     * @param productId
     * @param addedQuantFor
     * @throws ShopException if ...
     *      - storageUnitId is null
     *      - the storage unit with that id does not exist
     *      - productId is null
     *      - the product with that id does not exist
     *      - addedQuantFor < 0
     */
    public void addToStock( UUID storageUnitId, UUID productId, int addedQuantFor );


    /**
     * Removes a certain Quantity of a given product from the stock.
     * @param storageUnitId
     * @param productId
     * @param removedQuantFor
     * @throws ShopException if ...
     *      - storageUnitId is null
     *      - the storage unit with that id does not exist
     *      - productId is null
     *      - the product with that id does not exist
     *      - removedQuantFor < 0
     */
    public void removeFromStock( UUID storageUnitId, UUID productId, int removedQuantFor );


    /**
     * Changes the total Quantity of a given product in the stock.
     * @param storageUnitId
     * @param productId
     * @param newTotalQuantFor
     * @throws ShopException if ...
     *      - storageUnitId is null
     *      - the storage unit with that id does not exist
     *      - productId is null
     *      - the product with that id does not exist
     *      - newTotalQuantFor < 0
     */
    public void changeStockTo( UUID storageUnitId, UUID productId, int newTotalQuantFor );


    /**
     * Get the current stock of a given product in one specific storage unit.
     * @param storageUnitId
     * @param productId
     * @return the current total stock of the product
     * @throws ShopException if ...
     *      - storageUnitId is null
     *      - the storage unit with that id does not exist
     *      - productId is null
     *      - the product with that id does not exist
     */
    public int getAvailableStock( UUID storageUnitId, UUID productId );


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
package thkoeln.archilab.ecommerce.helpers.impl;

import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.test.web.servlet.MockMvc;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;


@TestConfiguration
public class RESTTestHelperConfiguration {

    @Bean
    public ShoppingBasketRESTHelper shoppingBasketRESTHelper(
            MockMvc mockMvc, ProductCatalogUseCases productCatalogUseCases ) {
        return new ShoppingBasketRESTHelperImpl( mockMvc, productCatalogUseCases );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingBasketRESTHelperImpl.java ---
package thkoeln.archilab.ecommerce.helpers.impl;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Map;
import java.util.UUID;

import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@Slf4j
public class ShoppingBasketRESTHelperImpl implements ShoppingBasketRESTHelper {
    private MockMvc mockMvc;
    private ProductCatalogUseCases productCatalogUseCases;

    private static final ResultMatcher CREATED = status().isCreated();
    private static final ResultMatcher OK = status().isOk();

    public ShoppingBasketRESTHelperImpl( MockMvc mockMvc, ProductCatalogUseCases productCatalogUseCases ) {
        this.mockMvc = mockMvc;
        this.productCatalogUseCases = productCatalogUseCases;
    }


    @Override
    public UUID getQueryShoppingBasket( EmailAddressType emailAddress, Map<UUID, Integer> quantityMap )
            throws Exception {
        // first query the customers API to get the proper customerId
        UUID customerId;
        String customerUri = "/customers?emailAddress=" + emailAddress.toString();
        MvcResult customerGetResult = mockMvc.perform( get( customerUri ) )
                .andExpect( status().isOk() )
                .andReturn();
        ObjectMapper objectMapper = new ObjectMapper();
        IdDTO idDTO = objectMapper.readValue( customerGetResult.getResponse().getContentAsString(), IdDTO.class );
        customerId = idDTO.getId();

        // then query the shopping basket API and extract the shopping basket id
        String shoppingBasketUri = "/shoppingBaskets?customerId=" + customerId.toString();
        ResultActions resultActions = mockMvc.perform( get( shoppingBasketUri ) )
                .andExpect( status().isOk() );
        idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
        UUID shoppingBasketId = idDTO.getId();

        // additional checks, if desired
        if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
        return shoppingBasketId;
    }


    private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
        if ( quantityMap == null ) return;
        int numOfProducts = quantityMap.size();
        resultActions.andExpect( jsonPath( "$.parts.length()" ).value( numOfProducts ) );
        float totalSellingPriceAsFloat = 0f;
        for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
            UUID productId = entry.getKey();
            Integer quantity = entry.getValue();
            resultActions.andExpect( jsonPath( "$.parts.[?(@.productId == '" + productId + "')].quantity" )
                    .value( quantity ) );
            MoneyType sellingPrice = productCatalogUseCases.getSellingPrice( productId );
            totalSellingPriceAsFloat += sellingPrice.getAmount() * quantity;
        }
        // last thing - check the total selling price
        String totalSellingPriceString = String.format( "%.2f €", totalSellingPriceAsFloat );
        resultActions
                .andExpect( jsonPath( "$.totalSellingPrice" ).value( totalSellingPriceString ) );
    }


    @Override
    public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity )
            throws Exception {
        addProductToShoppingBasket( shoppingBasketId, productId, quantity, null );
    }


    @Override
    public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity,
                                                  ResultMatcher expectedStatus ) throws Exception {
        ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
        ObjectMapper objectMapper = new ObjectMapper();
        QuantityDTO dto = new QuantityDTO( productId, quantity );
        String quantityJson = objectMapper.writeValueAsString( dto );
        mockMvc.perform( post( "/shoppingBaskets/" + shoppingBasketId + "/parts" )
                        .contentType( APPLICATION_JSON ).content( quantityJson ) )
                .andExpect( status );
    }



    @Override
    public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId )
            throws Exception {
        deleteProductFromShoppingBasket( shoppingBasketId, productId, null );
    }



    @Override
    public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId,
                                                      ResultMatcher expectedStatus ) throws Exception {
        ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
        String uri = "/shoppingBaskets/" + shoppingBasketId + "/parts/" + productId;
        mockMvc.perform( delete( uri ) ).andExpect( status );
    }


    @Override
    public void checkout( UUID shoppingBasketId, String expectedCustomerName,
                          ResultMatcher expectedStatus,
                          Map<UUID, Map<UUID, Integer>> expectedOrders ) throws Exception {
        ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
        String uri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
        MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
        ObjectMapper objectMapper = new ObjectMapper();

        // check the response content
        if ( expectedOrders != null || expectedCustomerName != null ) {
            String responseContent = result.getResponse().getContentAsString();
            log.info( "ShoppingBasketRESTHelperImpl - checkout: found response content " + responseContent );
            OrderDTO[] orders = objectMapper.readValue( responseContent, OrderDTO[].class );
            checkExpectedCustomerName( expectedCustomerName, orders );
            checkExpectedOrders( expectedOrders, orders );
        }
    }


    private void checkExpectedCustomerName( String expectedCustomerName, OrderDTO[] orders ) {
        if ( expectedCustomerName == null ) return;
        for ( OrderDTO order : orders ) {
            if ( !order.getCustomerName().equals( expectedCustomerName ) ) {
                throw new AssertionError( "Expected customerName '" + expectedCustomerName +
                        "' but got '" + order.getCustomerName() + "'" );
            }
        }
    }


    private void checkExpectedOrders( Map<UUID, Map<UUID, Integer>> expectedOrders,
                                            OrderDTO[] orders ) {
        if ( expectedOrders == null ) return;
        for ( OrderDTO order : orders ) {
            UUID storageUnitId = order.getStorageUnitId();
            Map<UUID, Integer> expectedQuantities = expectedOrders.get( storageUnitId );
            if ( expectedQuantities == null ) {
                throw new AssertionError( "No expected quantities for storage unit " + storageUnitId );
            }
            QuantityDTO[] parts = order.getParts();
            for ( QuantityDTO quantityDTO : parts ) {
                UUID productId = quantityDTO.getProductId();
                Integer expectedQuantity = expectedQuantities.get( productId );
                if ( expectedQuantity == null ) {
                    throw new AssertionError( "No expected quantity for product " + productId +
                            " in storage unit " + storageUnitId );
                }
                if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
                    throw new AssertionError( "Expected quantity " + expectedQuantity + " for product " +
                            productId + " in storage unit " + storageUnitId +
                            ", but got " + quantityDTO.getQuantity() );
                }
            }
        }
    }


    /**
     * A DTO containing just a quantity, used in testing.
     * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
     * Therefore, constructors and getters/setters are manually defined.
     */
    @NoArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class QuantityDTO {
        private UUID productId;
        private Integer quantity;

        public QuantityDTO( UUID productId, Integer quantity ) {
            this.productId = productId;
            this.quantity = quantity;
        }
        public UUID getProductId() {
            return productId;
        }
        public Integer getQuantity() {
            return quantity;
        }
        public void setProductId( UUID productId ) {
            this.productId = productId;
        }
        public void setQuantity( Integer quantity ) {
            this.quantity = quantity;
        }
    }


    /**
     * A DTO containing just the id of an entity, used in testing.
     */
    @AllArgsConstructor
    @NoArgsConstructor
    @Getter
    @Setter
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class IdDTO {
        private UUID id;
    }


    /**
     * A DTO containing the order data, used in testing.
     * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
     * Therefore, constructors and getters/setters are manually defined.
     */
    @NoArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class OrderDTO {
        private UUID id;
        private String customerName;
        private UUID storageUnitId;
        private QuantityDTO[] parts;

        public UUID getId() {
            return id;
        }
        public String getCustomerName() {
            return customerName;
        }
        public UUID getStorageUnitId() {
            return storageUnitId;
        }
        public QuantityDTO[] getParts() {
            return parts;
        }
        public void setId( UUID id ) {
            this.id = id;
        }
        public void setCustomerName( String customerName ) {
            this.customerName = customerName;
        }
        public void setStorageUnitId( UUID storageUnitId ) {
            this.storageUnitId = storageUnitId;
        }
        public void setParts( QuantityDTO[] parts ) {
            this.parts = parts;
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingBasketRESTHelper.java ---
package thkoeln.archilab.ecommerce.helpers;

import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Map;
import java.util.UUID;

/**
 * A REST helper for shopping basket-related operations.
 * This interface defines methods to interact with a shopping basket via REST calls, such as querying, adding,
 * deleting, and checking out.
 */
public interface ShoppingBasketRESTHelper {
    /**
     * Executes a REST GET query on a shopping basket and returns its id, with the customer's email address as a
     * starting point. The resulting shopping basket is checked against the given expected quantity map.
     * @param emailAddress The emailAddress of the customer whose shopping basket is queried.
     * @param expectedQuantityMap A map of products and their quantities in the shopping basket. (If null, then don't check.)
     * @return The id of the customer's shopping basket.
     * @throws Exception (whenever the REST call fails, or the shopping basket does not match the expected quantity map)
     */
    public UUID getQueryShoppingBasket( EmailAddressType emailAddress,
                                       Map<UUID, Integer> expectedQuantityMap ) throws Exception;


    /**
     * Adds a product to a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param productId Id of the product.
     * @param quantity Quantity of the product.
     * @throws Exception (whenever the REST call fails)
     */
    public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity )
            throws Exception;


    /**
     * Adds a product to a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param productId Id of the product.
     * @param quantity Quantity of the product.
     * @param expectedStatus expected status of the operation (null = CREATED)
     * @throws Exception (whenever the REST call fails or the status does not match)
     */
    public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity,
                                                  ResultMatcher expectedStatus ) throws Exception;


    /**
     * Deletes a product from a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param productId Id of the product.
     * @throws Exception (whenever the REST call fails)
     */
    public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId )
            throws Exception;


    /**
     * Deletes a product from a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param productId Id of the product.
     * @param expectedStatus expected status of the operation (null = OK)
     * @throws Exception (whenever the REST call fails or the status does not match)
     */
    public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId,
                                                      ResultMatcher expectedStatus ) throws Exception;


    /**
     * Checks out a shopping basket via REST call, and returns the id of the created order.
     * @param shoppingBasketId
     * @param expectedCustomerName expected name of the customer who owns the shopping basket (null = don't check)
     * @param expectedStatus expected status of the operation (null = don't check)
     * @param expectedOrders the expected orders to be created as a result of the checkout. This is
     *                            a map of the following form:
     *                            <pre>
     *                               storageUnitId -> Map<productId,Integer>
     *                            </pre>
     *                            where the inner map contains the products and their quantities
     * @return
     * @throws Exception
     */
    public void checkout( UUID shoppingBasketId, String expectedCustomerName,
                          ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedOrders )
           throws Exception;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\customer\CustomerRegistrationTest.java ---
package thkoeln.archilab.ecommerce.tests.customer;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.CustomerType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;


@SpringBootTest
public class CustomerRegistrationTest {
    @Autowired
    private CustomerRegistrationUseCases customerRegistrationUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private CustomerTestHelper customerTestHelper;

    private EmailAddressType nonExistingEmailAddress;
    private AddressType someAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        nonExistingEmailAddress = instantiateEmailAddress( "this@nononono.de" );
        someAddress = instantiateAddress( "Some Street", "Some City",
                instantiateZipCode( "90001" ) );
    }

    @Test
    public void testAllCustomersRegistered() {
        // given
        customerTestHelper.registerAllCustomers();
        EmailAddressType emailAddress3 =
                customerTestHelper.getCustomerEmailAddress( 3 );
        String name3 = customerTestHelper.getCustomerName( 3 );
        AddressType address3 = customerTestHelper.getCustomerAddress( 3 );

        // when
        CustomerType customer3 = customerRegistrationUseCases.getCustomerData(
                emailAddress3 );

        // then
        Assertions.assertEquals( name3, customer3.getName() );
        Assertions.assertEquals( emailAddress3, customer3.getEmailAddress() );
        Assertions.assertEquals( address3, customer3.getAddress() );
    }


    @Test
    public void testRegisterCustomerWithDuplicateEmailAddress() {
        // given
        customerTestHelper.registerAllCustomers();
        AddressType address5 = customerTestHelper.getCustomerAddress( 5 );
        EmailAddressType emailAddress5 =
                customerTestHelper.getCustomerEmailAddress( 5 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.register( "Gandalf The Grey",
                        emailAddress5, address5 ) );
    }


    @Test
    public void testRegisterCustomerWithDuplicateNameOrAddress() {
        // given
        customerTestHelper.registerAllCustomers();
        EmailAddressType newEmailAddress =
                instantiateEmailAddress( "some@this.de" );
        AddressType address2 = customerTestHelper.getCustomerAddress( 2 );
        String name2 = customerTestHelper.getCustomerName( 2 );

        // when
        // then
        assertDoesNotThrow( () ->
                customerRegistrationUseCases.register( name2, newEmailAddress, address2 ) );
    }


    @Test
    public void testRegisterCustomerWithInvalidData() {
        // given
        EmailAddressType emailAddress5 =
                customerTestHelper.getCustomerEmailAddress( 5 );
        AddressType address5 = customerTestHelper.getCustomerAddress( 5 );
        String name5 = customerTestHelper.getCustomerName( 5 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.register( null, emailAddress5, address5 ) );
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.register("", emailAddress5, address5 ) );
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.register( name5, null, address5 ) );
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.register( name5, emailAddress5, null ) );
    }


    @Test
    public void testChangeAddressWithInvalidData() {
        // given
        customerTestHelper.registerAllCustomers();
        AddressType address7 = customerTestHelper.getCustomerAddress( 7 );
        EmailAddressType emailAddress7 =
                customerTestHelper.getCustomerEmailAddress( 7 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.changeAddress( nonExistingEmailAddress, address7 ) );
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.changeAddress( null, address7 ) );
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.changeAddress( emailAddress7, null ) );
    }


    @Test
    public void testGetDataForNonexistingEmailAddress() {
        // given
        customerTestHelper.registerAllCustomers();

        // when
        // then
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.getCustomerData( nonExistingEmailAddress ) );
    }


    @Test
    public void testDeleteCustomersNoMoreCustomers() {
        // given
        customerTestHelper.registerAllCustomers();
        EmailAddressType emailAddress0 =
                customerTestHelper.getCustomerEmailAddress( 0 );


        // when
        customerRegistrationUseCases.deleteAllCustomers();

        // then
        assertThrows( ShopException.class, () -> customerRegistrationUseCases.getCustomerData(
                emailAddress0 ) );
    }


    @Test
    public void testChangeAddressSuccessful() {
        // given
        customerTestHelper.registerAllCustomers();
        EmailAddressType emailAddress6 =
                customerTestHelper.getCustomerEmailAddress( 6 );

        // when
        customerRegistrationUseCases.changeAddress( emailAddress6, someAddress );
        CustomerType newCustomer6 =
                customerRegistrationUseCases.getCustomerData( emailAddress6 );

        // then
        Assertions.assertEquals( emailAddress6, newCustomer6.getEmailAddress() );
        Assertions.assertEquals( someAddress, newCustomer6.getAddress() );
    }


    @Test
    public void testChangeAddressForNonexistingEmailAddress() {
        // given
        customerTestHelper.registerAllCustomers();

        // when
        // then
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.changeAddress( nonExistingEmailAddress, someAddress ) );
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\customer\CustomerRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.customer;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.web.servlet.MockMvc;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.CustomerType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.*;

import java.util.UUID;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class CustomerRESTTest {
    @Autowired
    private CustomerRegistrationUseCases customerRegistrationUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private CustomerTestHelper customerTestHelper;
    @Autowired
    private MockMvc mockMvc;

    private UUID randomId;
    private EmailAddressType nonExistingEmailAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        customerTestHelper.registerAllCustomers();

        nonExistingEmailAddress = FactoryMethodInvoker.instantiateEmailAddress(
                "harry@sally.de" );
        randomId = UUID.randomUUID();
    }


    @Test
    public void testInvalidCustomerUris() throws Exception {
        // given
        String allCustomersUri = "/customers";
        String randomIdUri = "/customers/" +  randomId;
        String nonExistingEmailAddressUri = "/customers?emailAddress=" + nonExistingEmailAddress;
        String randomParamUri = "/customers?randomParam=randomValue";

        // when
        // then
        mockMvc.perform( get( allCustomersUri ) ).andExpect( status().isMethodNotAllowed() );
        mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( nonExistingEmailAddressUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
    }


    @Test
    public void testRandomCustomerId() throws Exception {
        // given
        String invalidUri = "/customers/" +  randomId;

        // when
        // then
        mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testQueryCustomer() throws Exception {
        // given
        EmailAddressType emailAddress4 =
                customerTestHelper.getCustomerEmailAddress( 4 );
        String customerUri4 = "/customers?emailAddress=" + emailAddress4;

        // when
        CustomerType customer4 = customerRegistrationUseCases.getCustomerData( emailAddress4 );
        String name = customerTestHelper.getCustomerName( 4 );
        AddressType address4 = customerTestHelper.getCustomerAddress( 4 );

        // then (check using JSONPath)
        mockMvc.perform( get( customerUri4 ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.name" ).value( name ) )
                // id is position 0 (cannot be tested with current API structure), name is position 1,
                // email address is 2, address is 3)
                .andExpect( jsonPath( "$..emailAddressString" ).value( emailAddress4.toString() ) )
                .andExpect( jsonPath( "$..city" ).value( address4.getCity() ) )
                .andExpect( jsonPath( "$..zipCodeString" ).value(
                        address4.getZipCode().toString() ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class BasicNoOutsideSolutionRulesTest {

    @ArchTest
    static final ArchRule noClassesOnTopLevel =
            classes().should().resideInAPackage( "..solution.*.." )
                    .allowEmptyShould( true );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.library.Architectures.layeredArchitecture;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln")
@SuppressWarnings("PMD")
public class BasicProperDependenciesTest {

    @ArchTest
    static final ArchRule properDependencies =
            layeredArchitecture()
                    .consideringAllDependencies()
                    //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
                    .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
                    .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )

                    //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
                    .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
                    .allowEmptyShould( true );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import org.junit.jupiter.api.Test;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.MetadataReaderFactory;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertTrue;

public class BasicRequiredClassesTest {
    private static final String[] REQUIRED_CLASSES = {
            "Customer",
            "CustomerRepository",
            "Product",
            "ProductRepository",
            "Order",
            "OrderRepository",
            "StockLevel",
            "ShoppingBasket",
            "ShoppingBasketRepository",
            "StorageUnitRepository",
            "ShoppingBasketPart",
            "OrderPart",
            "StorageUnit",
    };

    @Test
    public void testRequiredClassesDeclared() throws IOException {
        String basePackage = "thkoeln.archilab.ecommerce";
        String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";

        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );

        Set<String> foundClasses = new HashSet<>();

        Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
            try {
                MetadataReader reader = readerFactory.getMetadataReader( resource );
                foundClasses.add( reader.getClassMetadata().getClassName() );
            } catch (IOException e) {
                e.printStackTrace();
            }
        } );

        Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
            boolean found = foundClasses.stream().anyMatch(className ->
                    className.startsWith(basePackage) && className.endsWith("." + requiredClass)
            );
            assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
        });
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.ApplicationContext;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
public class BasicUseCaseImplementationPackageTest {

    @Autowired
    private ApplicationContext applicationContext;

    private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
        put("CustomerRegistrationUseCases", Arrays.asList("customer"));
        put("StorageUnitUseCases", Arrays.asList("storageunit"));
        put("ProductCatalogUseCases", Arrays.asList("product"));
        put("ShoppingBasketUseCases", Arrays.asList("shoppingbasket"));
        put("OrderUseCases", Arrays.asList("order"));
    }};
    private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
    private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";

    @Test
    public void testRequiredClassesDeclared() {
        for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
            String interfaceName = USECASE_PATH + "." + entry.getKey();
            List<String> correctTopLevelPackages = entry.getValue();
            Class<?> useCaseInterfaceClass = null;
            try {
                useCaseInterfaceClass = Class.forName( interfaceName );
            } catch (ClassNotFoundException e) {
                fail( "Use case interface " + interfaceName + " not found.", e );
                continue;
            }
            String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
            assertEquals( 1, beans.length,
                    "There should be exactly 1 service implementation for the interface " +
                            entry.getKey() + ", but found " + beans.length );
            Object bean = applicationContext.getBean( beans[0] );
            boolean isValid = false;
            for ( String correctTopLevelPackage : correctTopLevelPackages ) {
                String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
                if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
                    isValid = true;
                    break;
                }
            }
            assertTrue( isValid,
                    "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
                            + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Service;

import jakarta.persistence.Entity;
import org.springframework.web.bind.annotation.RestController;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class DDDRulesTest {

    @ArchTest
    static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
            noClasses().that().resideInAPackage( "..domain.." )
                    .should().dependOnClassesThat().resideInAPackage( "..application.." )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule entitiesMustResideInADomainPackage =
            classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
                    .as( "Entities must reside in a package '..domain..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule entitiesMustNotAccessRepositories =
            noClasses().that().areAnnotatedWith( Entity.class )
                    .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule repositoriesMustResideInADomainPackage =
            classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
                    .as( "Repositories must reside in a package '..domain..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule repositoryNamesMustHaveProperSuffix =
            classes().that().areAssignableTo( CrudRepository.class )
                    .should().haveSimpleNameEndingWith( "Repository" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule servicesMustResideInAnApplicationPackage =
            classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
                    .as( "Application Services must reside in a package '..application..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule serviceNamesMustHaveProperSuffix =
            classes().that().areAnnotatedWith( Service.class )
                    .should().haveSimpleNameEndingWith( "Service" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule controllersMustResideInAnApplicationPackage =
            classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
                    .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );

    @ArchTest
    static final ArchRule controllersNamesMustHaveProperSuffix =
            classes().that().areAnnotatedWith( RestController.class )
                    .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );

    @ArchTest
    static final ArchRule controllersMustNotAccessRepositories =
            noClasses().that().areAnnotatedWith( RestController.class )
                    .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
                    .allowEmptyShould( false );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.library.dependencies.SliceAssignment;
import com.tngtech.archunit.library.dependencies.SliceIdentifier;
import org.junit.jupiter.api.Test;

import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;

public class NoCycleTest {
    private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");

    private SliceAssignment inAllClasses() {
        return new SliceAssignment() {
            @Override
            public String getDescription() {
                return "every class in it's own slice";
            }

            @Override
            public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
                return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
            }
        };
    }

    @Test
    public void testNoCyclicDependenciesBetweenClasses() {
        slices().assignedFrom(inAllClasses())
                .namingSlices("$1[$2.$3]")
                .should().beFreeOfCycles()
                .check(importedClasses);
    }

    @Test
    public void testNoCyclicDependenciesBetweenPackages() {
        ArchRule rule = slices().matching("..solution.(*)..")
                .should().beFreeOfCycles().allowEmptyShould( true );
        rule.check(importedClasses);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.base.DescribedPredicate;
import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaField;
import com.tngtech.archunit.core.domain.JavaParameterizedType;
import com.tngtech.archunit.core.domain.JavaType;
import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchCondition;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.lang.ConditionEvents;
import com.tngtech.archunit.lang.SimpleConditionEvent;
import jakarta.persistence.*;
import lombok.extern.slf4j.Slf4j;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.List;

import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
@Slf4j
public class OnlyReferenceViaIDTest { //STORAGE_UNIT
    private static final String SHOPPING_BASKET_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingbasket.domain";
    private static final String CUSTOMER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.customer.domain";
    private static final String PRODUCT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.product.domain";
    private static final String ORDER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.order.domain";
    private static final String STORAGE_UNIT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.storageunit.domain";

    @ArchTest
    static final ArchRule idFieldsMustUseGenericId =
            fields()
                    .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
                    .and().areAnnotatedWith( Id.class )
                    .should().haveRawType( assignableTo( GenericId.class ) )
                    .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
                    .allowEmptyShould( true );


    private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
            annotatedWith( ManyToOne.class )
                    .or( annotatedWith( OneToOne.class ) )
                    .or( annotatedWith( Embedded.class ) )
                    .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );

    private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
            annotatedWith( OneToMany.class )
                    .or( annotatedWith( ManyToMany.class ) )
                    .or( annotatedWith( ElementCollection.class ) )
                    .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );


    private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
        String description = "an entity or value object from same aggregate, or a domain primitive";
        return new DescribedPredicate<>( description ) {
            @Override
            public boolean test( JavaClass type ) {
                // check if the class is an entity or value object, and resides in the allowed package
                if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
                    return false;
                }
                // a GenericId is always allowed
                if ( type.isAssignableTo( GenericId.class ) ) {
                    return true;
                }
                // a domain primitive is also always allowed
                if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
                    return true;
                }
                return type.getPackageName().startsWith( allowedPackage );
            }
        };
    }


    @ArchTest
    static final ArchRule shoppingBasketToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule customerToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( CUSTOMER_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( CUSTOMER_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule productToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( PRODUCT_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( PRODUCT_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule orderToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule storageUnitToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( STORAGE_UNIT_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( STORAGE_UNIT_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );


    private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
        return new ArchCondition<JavaField>(
                "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
            @Override
            public void check( JavaField field, ConditionEvents events ) {
                JavaClass rawType = field.getRawType();
                String rawTypeName = rawType.getFullName();
                if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
                    return;
                }
                JavaType fieldType = field.getType();
                if ( !( fieldType instanceof JavaParameterizedType ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " is a raw List/Set without a type argument" ) );
                    return;
                }
                List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
                if ( typeArguments.isEmpty() ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " has no type arguments" ) );
                    return;
                }
                JavaType elementType = typeArguments.get( 0 );
                if ( !( elementType instanceof JavaClass ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " has an unknown element type" ) );
                    return;
                }
                JavaClass elementClass = (JavaClass) elementType;
                boolean hasAnnotation =
                        elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
                boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
                boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
                boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
                boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
                if ( !ok ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " refers to " + elementClass.getFullName()
                                    + " which is not a DP, or an entity/value object in " + allowedPackage ) );
                }
            }
        };
    }


    @ArchTest
    static final ArchRule shoppingBasketToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule customerToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( CUSTOMER_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( CUSTOMER_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule productToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( PRODUCT_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( PRODUCT_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule orderToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule storageUnitToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( STORAGE_UNIT_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( STORAGE_UNIT_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

/**
 * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
 */

public class OwnTestsTest {
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

public class PackageStructureTest {

    private static final String[] REQUIRED_PACKAGES = {"customer", "shoppingbasket", "product", "order", "storageunit"};
    private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
    private JavaClasses importedClasses;


    @BeforeEach
    public void setUp() {
        importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
    }

    @Test
    void testRequiredPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage;
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredDomainPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected domain sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredApplicationPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected application sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\AddressTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateAddress;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;

class AddressTest {

    @Test
    public void testGetterAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        AddressType instance = instantiateAddress( street, city, plz );

        // then
        assertEquals( street, instance.getStreet() );
        assertEquals( city, instance.getCity() );
        assertEquals( plz, instance.getZipCode() );
    }

    @Test
    public void testFactoryValidAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        // then
        assertDoesNotThrow( () -> instantiateAddress( street, city, plz ) );
    }

    @Test
    public void testFactoryInvalidAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        // then
        assertThrows( ShopException.class, () -> instantiateAddress( null, city, plz ) );
        assertThrows( ShopException.class, () -> instantiateAddress( "", city, plz ) );
        assertThrows( ShopException.class, () -> instantiateAddress( street, null, plz ) );
        assertThrows( ShopException.class, () -> instantiateAddress( street, "", plz ) );
        assertThrows( ShopException.class, () -> instantiateAddress( street, city, null ) );
    }

    @Test
    public void testEqualityAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        AddressType instance1 = instantiateAddress( street, city, plz );
        AddressType instance2 = instantiateAddress( street, city, plz );
        AddressType instance3 = instantiateAddress( "Anderestr. 12", city, plz );
        AddressType instance4 = instantiateAddress( street, "AndereStadt", plz );
        AddressType instance5 = instantiateAddress( street, city, instantiateZipCode( "54321" ) );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
        assertNotEquals( instance1, instance4 );
        assertNotEquals( instance1, instance5 );
    }

    @Test
    public void testImmutabilityAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        AddressType instance = instantiateAddress( street, city, plz );

        // then
        try {
            instance.getClass().getMethod( "setStreet", String.class );
            fail( "setStreet method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setCity", String.class );
            fail( "setCity method should not exist" );

        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setZipCode", ZipCodeType.class );
            fail( "setZipCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

@ArchTag("domainPrimitivesUsageRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class DomainPrimitivesUsageRulesTest {
    private static final String EMAIL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.EmailAddress";
    private static final String MONEY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Money";
    private static final String ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Address";

    @ArchTest
    static final ArchRule customerShouldReferenceEmailAddress =
            classes()
                    .that().haveSimpleName( "Customer" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( EMAIL_ADDRESS_CLASS )
                    .because( "Customer should use EmailAddress instead of String" );

    @ArchTest
    static final ArchRule customerShouldReferenceAddress =
            classes()
                    .that().haveSimpleName( "Customer" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( ADDRESS_CLASS )
                    .because( "Customer should use Address instead of whatever else" );

    @ArchTest
    static final ArchRule storageUnitShouldReferenceAddress =
            classes()
                    .that().haveSimpleName( "StorageUnit" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( ADDRESS_CLASS )
                    .because( "Customer should use Address instead of whatever else" );

    @ArchTest
    static final ArchRule productShouldReferenceMoney =
            classes()
                    .that().haveSimpleName( "Product" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( MONEY_CLASS )
                    .because( "Product should use Money instead of float or whatever else" );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\EmailAddressTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmailAddress;

class EmailAddressTest {

    @Test
    public void testToStringEmailAddress() {
        // given
        String input = "test@example.com";

        // when
        EmailAddressType instance = instantiateEmailAddress( input );

        // then
        assertEquals( input, instance.toString() );
    }

    @Test
    public void testEqualityEmailAddress() {
        // given
        // when
        EmailAddressType instance1 = instantiateEmailAddress( "test@example.com" );
        EmailAddressType instance2 = instantiateEmailAddress( "test@example.com" );
        EmailAddressType instance3 = instantiateEmailAddress( "different@example.com" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutabilityEmailAddress() {
        // given
        // when
        EmailAddressType instance = instantiateEmailAddress( "test@example.com" );

        // then
        try {
            instance.getClass().getMethod( "setEmailAddress", String.class );
            fail( "setEmailAddress method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }



    @Test
    public void smokeTestForCopyConstructors() {
        // given
        EmailAddressType emailAddress =
                instantiateEmailAddress( "peter.schmidt@web.de" );

        // when
        EmailAddressType emailAddressOtherIdentifyer =
                emailAddress.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
        assertThrows( ShopException.class, () ->
                emailAddress.sameDomainDifferentIdentifyer( "p...eter" ) );
        EmailAddressType emailAddressOtherDomain =
                emailAddress.sameIdentifyerDifferentDomain( "web.ch" );
        assertThrows( ShopException.class, () ->
                emailAddress.sameIdentifyerDifferentDomain( "web.edu" ) );

        // then
        assertEquals( "p.e.t.e.r@web.de", emailAddressOtherIdentifyer.toString() );
        assertEquals( "peter.schmidt@web.ch", emailAddressOtherDomain.toString() );
    }


    @Test
    public void testFactoryValidEmailAddress() {
        // given
        // when
        // then
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "99Z@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "GGGhh@s77.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "a@4.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "Max.Hammer@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "Max.Gideon.Hammer@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.this.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.de" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.at" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.ch" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.org" ) );
    }


    @Test
    public void testFactoryInvalidEmailAddress() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateEmailAddress( null ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "testexample.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "Max..Gideon.Hammer@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@examplecom" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example..com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test#example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.42" ) );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\MoneyTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMoney;

class MoneyTest {

    @Test
    public void testGetAmountMoney() {
        // given
        Float inputAmount = 10.0f;

        // when
        MoneyType instance = instantiateMoney( inputAmount, "EUR" );

        // then
        assertEquals( inputAmount, instance.getAmount() );
    }

    @Test
    public void testGetCurrencyUnitMoney() {
        // given
        String inputCurrencyUnit = "EUR";

        // when
        MoneyType instance = instantiateMoney( 10.0f, inputCurrencyUnit );

        // then
        assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
    }

    @Test
    public void testAddToMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );

        // when
        MoneyType result12 = instance1.add( instance2 );
        MoneyType result13 = instance1.add( instance3 );

        // then
        assertEquals( 30.0f, result12.getAmount() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
        assertEquals( 10.0f, result13.getAmount() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
    }

    @Test
    public void testInvalidAddToMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
    }

    @Test
    public void testSubtractFromMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 30.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
        MoneyType instance4 = instantiateMoney( 30.0f, "EUR" );

        // when
        MoneyType result12 = instance1.subtract( instance2 );
        MoneyType result13 = instance1.subtract( instance3 );
        MoneyType result14 = instance1.subtract( instance4 );

        // then
        assertEquals( 10.0f, result12.getAmount() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
        assertEquals( 30.0f, result13.getAmount() );
        assertEquals( "EUR", result13.getCurrencyUnit() );
        assertEquals( 0.0f, result14.getAmount() );
        assertEquals( "EUR", result14.getCurrencyUnit() );
    }

    @Test
    public void testInvalidSubtractFromMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 5.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
        assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
    }

    @Test
    public void testMultiplyByMoney() {
        // given
        MoneyType instance = instantiateMoney( 10.0f, "EUR" );

        // when
        MoneyType result = instance.multiplyBy( 3 );

        // then
        assertEquals( 30.0f, result.getAmount() );
        assertEquals( "EUR", result.getCurrencyUnit() );
    }

    @Test
    public void testFactoryValidCurrencyUnitMoney() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiateMoney( 10.0f, "EUR" ) );
    }

    @Test
    public void testFactoryInvalidCurrencyUnitMoney() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateMoney( -10.0f, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, "USD" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( null, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, null ) );
    }

    @Test
    public void testLargerThanCurrencyUnitMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance4 = instantiateMoney( 10.0f, "CHF" );

        // when
        // then
        assertTrue( instance2.largerThan( instance1 ) );
        assertFalse( instance1.largerThan( instance2 ) );
        assertFalse( instance1.largerThan( instance3 ) );
        assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
    }


    @Test
    public void testEqualityCurrencyUnitMoney() {
        // given
        // when
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 20.0f, "EUR" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutabilityCurrencyUnitMoney() {
        // given
        // when
        MoneyType instance = instantiateMoney( 10.0f, "EUR" );

        // then
        try {
            instance.getClass().getMethod( "setAmount", Float.class );
            fail( "setAmount method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }

        try {
            instance.getClass().getMethod( "setCurrencyUnit", String.class );
            fail( "setCurrencyUnit method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\ZipCodeTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;

class ZipCodeTest {

    private String input1, input4;
    private ZipCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
            _04233, _02544, _99123, _56323, _79332;


    @BeforeEach
    public void setUp() {
        input1 = "12345";
        input4 = "49188";
        _12345 = FactoryMethodInvoker.instantiateZipCode( "12345" );
        _12345b = FactoryMethodInvoker.instantiateZipCode( "12345" );
        _23455 = FactoryMethodInvoker.instantiateZipCode( "23455" );
        _01234 = FactoryMethodInvoker.instantiateZipCode( "01234" );
        _01235 = FactoryMethodInvoker.instantiateZipCode( "01235" );
        _01238 = FactoryMethodInvoker.instantiateZipCode( "01238" );
        _01263 = FactoryMethodInvoker.instantiateZipCode( "01263" );
        _01213 = FactoryMethodInvoker.instantiateZipCode( "01213" );
        _01823 = FactoryMethodInvoker.instantiateZipCode( "01823" );
        _01312 = FactoryMethodInvoker.instantiateZipCode( "01312" );
        _04233 = FactoryMethodInvoker.instantiateZipCode( "04233" );
        _02544 = FactoryMethodInvoker.instantiateZipCode( "02544" );
        _99123 = FactoryMethodInvoker.instantiateZipCode( "99123" );
        _56323 = FactoryMethodInvoker.instantiateZipCode( "56323" );
        _79332 = FactoryMethodInvoker.instantiateZipCode( "79332" );

    }


    @Test
    public void testToStringZipCode() {
        // given
        // when
        ZipCodeType instance = instantiateZipCode( input1 );

        // then
        assertEquals( input1, instance.toString() );
    }

    @Test
    public void testFactoryValidZipCode() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiateZipCode( input1 ) );
    }

    @Test
    public void testFactoryInvalidZipCode() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateZipCode( "123456" ) );
        assertThrows( ShopException.class, () -> instantiateZipCode( "1234" ) );
        assertThrows( ShopException.class, () -> instantiateZipCode( "20000" ) );
        assertThrows( ShopException.class, () -> instantiateZipCode( null ) );
    }

    @Test
    public void testEqualityZipCode() {
        // given
        // when
        ZipCodeType instance1a = instantiateZipCode( input1 );
        ZipCodeType instance1b = instantiateZipCode( input1 );
        ZipCodeType instance4 = instantiateZipCode( input4 );

        // then
        assertEquals( instance1a, instance1b );
        assertNotEquals( instance1a, instance4 );
    }

    @Test
    public void testImmutabilityZipCode() {
        // given
        // when
        ZipCodeType instance = instantiateZipCode( input1 );

        // then
        try {
            instance.getClass().getMethod( "setzipCode", String.class );
            fail( "setzipCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }


    @Test
    public void smokeTestForDifference() {
        // given
        ZipCodeType instance1a = instantiateZipCode( input1 );
        ZipCodeType instance1b = instantiateZipCode( input1 );
        ZipCodeType instance12479 = instantiateZipCode( "12479" );
        ZipCodeType instance21456 = instantiateZipCode( "21456" );

        // when
        int differenceAB = instance1a.difference( instance1b );
        int difference12 = instance1a.difference( instance12479 );
        int difference23 = instance12479.difference( instance21456 );

        // then
        assertEquals( 0, differenceAB );
        assertTrue( difference12 > 0 );
        assertTrue( difference23 > difference12 );
    }


    @Test
    public void testZipCodeFirstDigit() {
        // given
        ZipCodeType instance1 = instantiateZipCode( input1 );
        ZipCodeType instance4 = instantiateZipCode( input4 );

        // when
        // then
        assertEquals( 1, instance1.getFirstDigitZipCode() );
        assertEquals( 4, instance4.getFirstDigitZipCode() );
    }



    @Test
    public void testInvalidParameters() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () ->
                _12345.difference( null ) );
    }


    @Test
    public void testSameZipCode() {
        // given
        // when
        int diff = _12345.difference( _12345b );

        // then
        assertEquals( 0, diff );
    }


    /**
     *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
     *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
     *        So, 56733 and 56734 have the same difference as 56733 and 56739.
     *      - The difference grows if more digits (counted from the right side) differ.
     *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
     *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
     *        53876 and 54876 have the same difference as 53876 and 57261.
     */
    @Test
    public void testZipCodeDifferenceInAllButFirstDigit() {
        // given
        // when
        int diff5a = _01234.difference( _01235 );
        int diff5b = _01234.difference( _01238 );
        int diff4a = _01234.difference( _01263 );
        int diff4b = _01234.difference( _01213 );
        int diff3a = _01234.difference( _01823 );
        int diff3b = _01234.difference( _01312 );
        int diff2a = _01234.difference( _04233 );
        int diff2b = _01234.difference( _02544 );

        // then
        assertEquals( diff5a, diff5b, "difference 01234-01235 must be the same as difference 01234-01238" );
        assertEquals( diff4a, diff4b, "difference 01234-01263 must be the same as difference 01234-01213" );
        assertEquals( diff3a, diff3b, "difference 01234-01823 must be the same as difference 01234-01312" );
        assertEquals( diff2a, diff2b, "difference 01234-04233 must be the same as difference 01234-02544" );

        assertTrue( diff5a < diff4a,
                "difference 01234-01235 must be smaller than difference 01234-01263" );
        assertTrue( diff4a < diff3a,
                "difference 01234-01263 must be smaller than difference 01234-01823" );
        assertTrue( diff3a < diff2a,
                "difference 01234-01823 must be smaller than difference 01234-04233" );
    }


    /**
     *      - However, the difference between 5abcd and 6rstu must be smaller than the one
     *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
     *        one between 5abcd and 9rstu.
     *      - This last condition reflects the fact the first digits of a zip code marks a region
     *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
     *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
     *        other.
     */
    @Test
    public void testZipCodedifferenceInFirstDigit() {
        // given
        // when
        int diff1_1 = _01234.difference( _99123 );
        int diff1_2 = _01234.difference( _23455 );
        int diff1_5 = _01234.difference( _56323 );
        int diff1_3 = _01234.difference( _79332 );

        // then
        assertTrue( diff1_1 < diff1_2,
                "difference 01234-99123 must be smaller than difference 01234-23455"  );
        assertTrue( diff1_2 < diff1_3,
                "difference 01234-23455 must be smaller than difference 01234-79332" );
        assertTrue( diff1_3 < diff1_5,
                "difference 01234-79332 must be smaller than difference 01234-56323"  );
    }



}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
package thkoeln.archilab.ecommerce.tests.e1restcalls;

import org.junit.jupiter.api.Test;
import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;


public class E1RestCallTableTest {

    private GenericTableSpecificationTests genericTableSpecificationTests = null;


    public E1RestCallTableTest() {
        this.genericTableSpecificationTests = new GenericTableSpecificationTests();
    }

    @Test
    public void restTest() throws Exception {
        genericTableSpecificationTests.testTableSpecification("E1" );
    }
}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\order\OrderTest.java ---
package thkoeln.archilab.ecommerce.tests.order;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;


@SpringBootTest
public class OrderTest {
    @Autowired
    private CustomerRegistrationUseCases customerRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private StorageUnitUseCases storageUnitUseCases;
    @Autowired
    private OrderUseCases orderUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private CustomerTestHelper customerTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private StorageUnitTestHelper storageUnitTestHelper;

    private UUID nonExistingId1;
    private UUID nonExistingId2;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        customerTestHelper.registerAllCustomers();
        productTestHelper.addAllProducts();
        storageUnitTestHelper.addAllStorageUnits( true );
        nonExistingId1 = UUID.randomUUID();
        nonExistingId2 = UUID.randomUUID();
    }


    @Test
    public void testOrderHistory() {
        // given
        UUID productId1 = productTestHelper.getProductId( 1 );
        UUID productId2 = productTestHelper.getProductId( 2 );
        EmailAddressType customerEmailAddress7 =
                customerTestHelper.getCustomerEmailAddress( 7 );
        Map<UUID, Integer> orderHistoryBefore = orderUseCases.getOrderHistory( customerEmailAddress7 );

        // when
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress7, productId1, 3 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress7, productId2, 2 );
        shoppingBasketUseCases.checkout( customerEmailAddress7 );
        Map<UUID, Integer> orderHistory1 =
                orderUseCases.getOrderHistory( customerEmailAddress7 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress7, productId1, 6 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress7, productId2, 2 );
        shoppingBasketUseCases.checkout( customerEmailAddress7 );
        Map<UUID, Integer> orderHistory2 =
                orderUseCases.getOrderHistory( customerEmailAddress7 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress7, productId1, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress7, productId2, 6 );
        shoppingBasketUseCases.checkout( customerEmailAddress7 );
        Map<UUID, Integer> orderHistory3 =
                orderUseCases.getOrderHistory( customerEmailAddress7 );

        // then
        assertEquals( 0, orderHistoryBefore.size() );
        assertEquals( 2, orderHistory1.size() );
        assertEquals( 2, orderHistory2.size() );
        assertEquals( 2, orderHistory3.size() );
        assertEquals( 3, orderHistory1.get( productId1 ) );
        assertEquals( 2, orderHistory1.get( productId2 ) );
        assertEquals( 9, orderHistory2.get( productId1 ) );
        assertEquals( 4, orderHistory2.get( productId2 ) );
        assertEquals( 10, orderHistory3.get( productId1 ) );
        assertEquals( 10, orderHistory3.get( productId2 ) );
    }


    @Test
    public void testForEmptyOrderHistory() {
        // given
        EmailAddressType customerEmailAddress4 =
                customerTestHelper.getCustomerEmailAddress( 4 );
        // when
        Map<UUID, Integer> orderHistory =
                orderUseCases.getOrderHistory( customerEmailAddress4 );
        // then
        assertEquals( 0, orderHistory.size() );
    }


    @Test
    public void testInvalidParamsForGetOrderQuantForProduct() {
        // given
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );

        // when / then
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForProduct( null, null ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForProduct( nonExistingId1, null ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForProduct( null, nonExistingId2 ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForProduct( nonExistingId1, nonExistingId2 ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForProduct( storageUnitId0, null ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForProduct( storageUnitId0, nonExistingId2 ) );
    }


    @Test
    public void testInvalidParamsForGetStorageUnitIdForOrder() {
        // given / when / then
        assertThrows ( ShopException.class,
                () -> orderUseCases.getStorageUnitIdForOrder( null ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getStorageUnitIdForOrder( nonExistingId1 ) );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
package thkoeln.archilab.ecommerce.tests.owntests;

import lombok.extern.slf4j.Slf4j;
import org.assertj.core.api.Assert;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.jayway.jsonpath.JsonPath;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.fail;

@Slf4j
public class DomainPrimitiveJSONSerializationTest {

    @BeforeEach
    public void setUp() {
        // ... add own setup code here
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * EmailAddress.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_EmailAddress_Serialization() throws Exception {
        // TODO: implement this test
        // given
        EmailAddress email = (EmailAddress) EmailAddress.of("ZitronenKuchen@gmail.com");
        ObjectMapper mapper = new ObjectMapper();
        // when
        String json = mapper.writeValueAsString(email);
        // then
        log.info(json);
        String emailAddress = JsonPath.read(json,"$.emailAddressString");

    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * ZipCode.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_ZipCode_Serialization() throws Exception {
        // TODO: implement this test
        // given
        ZipCode zipCode = (ZipCode) ZipCode.of("12345");
        ObjectMapper mapper = new ObjectMapper();
        // when
        String json = mapper.writeValueAsString(zipCode);
        // then
        log.info(json);
        String expectedZipCode = JsonPath.read(json,"$.zipCodeString");
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * Address.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_Address_Serialization() throws Exception {
        // TODO: implement this test
        // given
        Address address = (Address) Address.of("Bundesstrasse","Berlin",ZipCode.of("10171"));
        ObjectMapper mapper= new ObjectMapper();
        // when
        String json = mapper.writeValueAsString(address);
        // then
        log.info(json);
        String expectedStreet = JsonPath.read(json,"$.street");
        String expectedCity = JsonPath.read(json,"$.city");
        String expectedZip = JsonPath.read(json,"$.zipCode.zipCodeString");
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * Money.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_Money_Serialization() throws Exception {
        // TODO: implement this test
        // given
        Money money = (Money) Money.of(100F,"EUR");
        ObjectMapper mapper = new ObjectMapper();
        // when
        String json = mapper.writeValueAsString(money);
        // then
        log.info(json);
        Double expectedAmount = JsonPath.read(json,"$.amount");
        String expectedCurrency = JsonPath.read(json,"$.currencyUnit");


    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingBasketRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.owntests;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import thkoeln.archilab.ecommerce.domainprimitives.GenericNotFoundException;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerRepository;
import thkoeln.archilab.ecommerce.solution.order.application.OrderService;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderPart;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.application.ShoppingBasketController;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.application.ShoppingBasketDto;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.application.ShoppingBasketService;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketId;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
import thkoeln.archilab.ecommerce.solution.storageunit.application.StorageUnitService;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnit;
import thkoeln.archilab.ecommerce.solution.storageunit.domain.StorageUnitId;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Assertions.fail;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;


@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class OwnShoppingBasketRESTTest {
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private CustomerTestHelper customerTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private StorageUnitTestHelper storageUnitTestHelper;
    @Autowired
    private ShoppingBasketService shoppingBasketService;
    @Autowired
    private ShoppingBasketController shoppingBasketController;
    @Autowired
    private CustomerRepository customerRepository;
    @Autowired
    private ShoppingBasketRESTHelper shoppingBasketRESTHelper;
    @Autowired
    private ShoppingBasketRepository shoppingBasketRepository;
    @Autowired
    private OrderService orderService;




    private EmailAddressType customerEmail;
    private Customer customer;
    private ShoppingBasket shoppingBasket;
    private ShoppingBasketId shoppingBasketId;
    private ProductId productId1;
    private ProductId productId2;
    private ProductId productId8;
    private StorageUnitId singleStorageUnitId1;
    private StorageUnitId otherStorageUnitId2;
    @Autowired
    private StorageUnitService storageUnitService;
    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        customerTestHelper.registerAllCustomers();
        productTestHelper.addAllProducts();
        storageUnitTestHelper.addAllStorageUnits( true );
        customerEmail = customerTestHelper.getCustomerEmailAddress(0);
        customer = customerRepository.findByEmail(customerEmail)
                .orElseThrow(() -> new IllegalStateException("Customer not found during setup"));



        UUID storageUnitUuid = storageUnitTestHelper.getStorageUnitId(0);
        singleStorageUnitId1 = new StorageUnitId(storageUnitUuid);


        storageUnitUuid = storageUnitTestHelper.getStorageUnitId(7);
        otherStorageUnitId2 = new StorageUnitId(storageUnitUuid);



        UUID productUuid =productTestHelper.getProductId(1);
        productId1 = new ProductId(productUuid);
        productUuid = productTestHelper.getProductId(2);
        productId2 = new ProductId(productUuid);
        productUuid = productTestHelper.getProductId(8);
        productId8 = new ProductId(productUuid);

        shoppingBasket = shoppingBasketService.createShoppingBasketForCustomer(customerEmail.toString());
        shoppingBasketId = shoppingBasket.getShoppingBasketId();

        shoppingBasketService.emptyShoppingBasket(shoppingBasketId);


    }


    /**
     * Provide a test that implements a simple call to the REST endpoint (3):
     * <pre>
     *     GET /shoppingBaskets?customerId=<customer id as uuid>
     * </pre>
     * - Use the {@link CustomerTestHelper} to obtain to obtain the email address
     *   of some example customer.
     * - Use your shopping basket service to add entries to the shopping basket of that person.
     * - then use the `ShoppingBasketRESTHelper` to create the GET call, and check the results.
     * - (or do it by directly calling your REST controller, if you prefer)
     * @throws Exception
     */
    @Test
    public void test_getQuery_ShoppingBasket() throws Exception {
        // given
        EmailAddressType email1= customerTestHelper.getCustomerEmailAddress(0);
        ProductId productId1 = new ProductId( productTestHelper.getProductId(1));
        ProductId productId2 = new ProductId( productTestHelper.getProductId(8));
        Customer customer = customerRepository.findByEmail(email1)
                .orElseThrow(() -> new IllegalStateException("Customer not found"));
        UUID customerId = customer.getCustomerId().getId();

        // when
        shoppingBasketService.addProductToShoppingBasket(email1.toString(),productId1,2);
        shoppingBasketService.addProductToShoppingBasket(email1.toString(),productId2,4);

        // then
        Map<UUID,Integer> expectedQuantityMap = new HashMap<>();
        expectedQuantityMap.put(productId1.getId(),2);
        expectedQuantityMap.put(productId2.getId(),4);

        UUID retrievedShoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket(
                email1,
                expectedQuantityMap
        );
        assertNotNull(retrievedShoppingBasketId,"The retrieved shopping basket should not be null");
        assertEquals(customer.getCustomerId().getId(),retrievedShoppingBasketId,"ShoppingBasketId from REST call should match customers ID");

        ResponseEntity<ShoppingBasketDto> response = shoppingBasketController.getShoppingBasket(customerId.toString());
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
        ShoppingBasketDto shoppingBasketDto = response.getBody();
        assertNotNull(shoppingBasketDto,"Shopping basket should not be null");
        assertEquals(customerId,shoppingBasketDto.getId(),"ID in DTO should match CustomerID");
        assertNotNull(shoppingBasketDto.getTotalSellingPrice(),"Total selling price should not be null");
        assertFalse(shoppingBasketDto.getParts().isEmpty(),"Shopping Basket should contain parts");
        assertEquals(2,shoppingBasketDto.getParts().size(),"Shopping Basket should contain 2 parts");

        boolean foundProduct1=shoppingBasketDto.getParts().stream()
                        .anyMatch(part -> part.getProductId().equals(productId1.getId()) && part.getQuantity()==2);
        assertTrue(foundProduct1,"Product 1 in Shopping Basket should contain 2 parts");

        boolean foundProduct2 = shoppingBasketDto.getParts().stream()
                .anyMatch(part -> part.getProductId().equals(productId2.getId()) && part.getQuantity()==4);
        assertTrue(foundProduct2,"Product 2 in Shopping Basket should contain 4 parts");
    }
    /**
     * Provide a test that implements the addition of one product to the shopping basket via
     * REST endpoint (6):
     * <pre>
     *     POST /shoppingBaskets/{shoppingBasket-Id}/parts
     * </pre>
     * You can test now "the other way around" as in test_getQuery_ShoppingBasket():
     * - Use `ShoppingBasketRESTHelper` to add products via REST, then use shopping basket service methods
     *   to check of the shopping basket contains the right stuff.
     * - (or do it by directly calling your REST controller, if you prefer)
     *
     * @throws Exception
     */
    @Test
    public void test_post_ShoppingBasketParts() throws Exception {

        // given
        EmailAddressType email1= customerTestHelper.getCustomerEmailAddress(0);
        ProductId productId1 = new ProductId( productTestHelper.getProductId(1));
        Integer quantity = 5;
        Customer customer = customerRepository.findByEmail(email1)
                .orElseThrow(() -> new IllegalStateException("Customer not found"));
        ShoppingBasket basket = shoppingBasketService.createShoppingBasketForCustomer(email1.toString());
        ShoppingBasketId shoppingBasketId = basket.getShoppingBasketId();
        // when
        shoppingBasketRESTHelper.addProductToShoppingBasket(shoppingBasketId.getId(),productId1.getId(),quantity);

        // then
        Optional<ShoppingBasket> shoppingBasketOptional = shoppingBasketRepository.findByCustomerId(customer.getCustomerId());
        assertTrue(shoppingBasketOptional.isPresent(),"Shopping basket shoudl exist for customer");

        Optional<Integer> actualQuantityOptional = shoppingBasketService.getProductQuantityInShoppingBasket(
                shoppingBasketId.getId(), productId1);

        assertTrue(actualQuantityOptional.isPresent(), "Product should be found in the shopping basket.");
        assertEquals(quantity, actualQuantityOptional.get(), "Quantity of product in shopping basket should match.");
    }
    /**
     * Provide a test that implements the deletion of one product in the shopping basket via
     * REST endpoint (10):
     * <pre>
     *     DELETE /shoppingBaskets/{shoppingBasket-Id}/parts/{product-Id}
     * </pre>
     * This should be just a slight variation of the test_post_ShoppingBasketParts()
     * method, but instead of adding an product to the shopping basket, you delete it.
     *
     * @throws Exception
     */
    @Test
    public void test_delete_ShoppingBasketParts() throws Exception {
        // given
        Integer quantity = 5;
        EmailAddressType email1= customerTestHelper.getCustomerEmailAddress(0);
        ProductId productId1 = new ProductId( productTestHelper.getProductId(1));
        Customer customer = customerRepository.findByEmail(email1)
                .orElseThrow(() -> new IllegalStateException("Customer not found"));
        ShoppingBasket basket = shoppingBasketService.createShoppingBasketForCustomer(email1.toString());
        ShoppingBasketId shoppingBasketId = basket.getShoppingBasketId();
        // when
        System.out.println(shoppingBasketId);
        System.out.println(shoppingBasketId.getId());
        System.out.println(email1);
        System.out.println(productId1);
        System.out.println(productId1.getId());
        shoppingBasketRESTHelper.addProductToShoppingBasket(shoppingBasketId.getId(),productId1.getId(),quantity);

        shoppingBasketRESTHelper.deleteProductFromShoppingBasket(shoppingBasketId.getId(),productId1.getId());

        // then
        Optional<ShoppingBasket> shoppingBasketOptional = shoppingBasketRepository.findByCustomerId(customer.getCustomerId());
        assertTrue(shoppingBasketOptional.isPresent(),"Shopping basket should exist for customer");

        Optional<Integer> actualQuantityOptional = shoppingBasketService.getProductQuantityInShoppingBasket(
                shoppingBasketId.getId(), productId1);

        assertFalse(actualQuantityOptional.isPresent(), "Product should not be found in the shopping basket.");
    }
    /**
     * Provide a test that implements the checkout of a shopping basket that can be served
     * by just 1 storage unit, using the REST endpoint (11):
     * <pre>
     *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
     * </pre>
     * - Use your shopping basket service to add entries to the shopping basket of some example customer,
     * - then use the `ShoppingBasketRESTHelper to post the checkout call, and to check the results.
     * - (or do it by directly calling your REST controller, if you prefer)
     *
     * @throws Exception
     */
    @Test
    public void test_checkout_1_storageUnit() throws Exception {
        // given
        shoppingBasketService.addProductToShoppingBasket(customer.getEmailAddress().toString(),productId1,1);
        shoppingBasketService.addProductToShoppingBasket(customer.getEmailAddress().toString(),productId2,2);
        // when
        Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>();
        Map<UUID, Integer> expectedProductsInOrder = new HashMap<>();
        expectedProductsInOrder.put(productId1.getId(), 1);
        expectedProductsInOrder.put(productId2.getId(), 2);
        expectedOrders.put(singleStorageUnitId1.getId(), expectedProductsInOrder);

        shoppingBasketRESTHelper.checkout(
                shoppingBasketId.getId(),
                customer.getName(),
                status().isCreated(),
                expectedOrders
        );
        // then
        Optional<ShoppingBasket> currentBasket = shoppingBasketService.getShoppingBasketForCustomerId(customer.getCustomerId().getId());

        assertEquals(9, storageUnitService.getAvailableStock(singleStorageUnitId1, productId1));
        assertEquals(18, storageUnitService.getAvailableStock(singleStorageUnitId1, productId2));

        List<Order> createdOrders = orderService.findOrdersByCustomerId(customer.getCustomerId());
        assertEquals(1, createdOrders.size(), "Exactly one order should have been created.");
        Order createdOrder = createdOrders.get(0);
        assertEquals(2, orderService.findOrderPartsByOrder(createdOrder).size(), "Order should have 2 parts.");
    }
    /**
     * Provide a test that implements the checkout of a shopping basket that can only be served
     * by using 2 storage units, using the REST endpoint (11):
     * <pre>
     *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
     * </pre>
     * This should be just a slight variation of thetest_checkout_1_storageUnit() test.
     *
     * @throws Exception
     */
    @Test
    public void test_checkout_2_storageUnits() throws Exception {
        // given
        int quantityProd1 = 1;
        int quantityProd8 = 1;

        shoppingBasketService.addProductToShoppingBasket(customer.getEmailAddress().toString(),productId1,quantityProd1);
        shoppingBasketService.addProductToShoppingBasket(customer.getEmailAddress().toString(),productId8,quantityProd8);

        // when
        Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>();


        Map<UUID, Integer> order1 = new HashMap<>();
        order1.put(productId1.getId(), quantityProd1);
        expectedOrders.put(singleStorageUnitId1.getId(), order1);

        Map<UUID, Integer> order2 = new HashMap<>();
        order2.put(productId8.getId(), quantityProd8);
        expectedOrders.put(otherStorageUnitId2.getId(), order2);


        shoppingBasketRESTHelper.checkout(
                shoppingBasketId.getId(),
                customer.getName(),
                status().isCreated(),
                expectedOrders
        );
        // then

        Optional<ShoppingBasket> currentBasket = shoppingBasketService.getShoppingBasketForCustomerId(customer.getCustomerId().getId());
        assertEquals(9, storageUnitService.getAvailableStock(singleStorageUnitId1, productId1));


        List<Order> createdOrders = orderService.findOrdersByCustomerId(customer.getCustomerId());
        assertEquals(2, createdOrders.size(), "Exactly one order should have been created.");
        thkoeln.archilab.ecommerce.solution.order.domain.Order createdOrder = createdOrders.get(0);
        assertEquals(singleStorageUnitId1.getId(), createdOrder.getStorageUnitId().getId(), "Order should be from the single storage unit.");

        }
    }





--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\product\ProductCatalogTest.java ---
package thkoeln.archilab.ecommerce.tests.product;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.*;

import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;


@SpringBootTest
public class ProductCatalogTest {
    @Autowired
    private CustomerRegistrationUseCases customerRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private StorageUnitUseCases storageUnitUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private CustomerTestHelper customerTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private StorageUnitTestHelper storageUnitTestHelper;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        customerTestHelper.registerAllCustomers();
        productTestHelper.addAllProducts();
    }


    @Test
    public void testAddProductToCatalog() {
        // given
        UUID productId4 = productTestHelper.getProductId( 4 );
        MoneyType sellingPrice4 = productTestHelper.getSellingPrice( 4 );

        // when
        MoneyType foundSellingPrice = productCatalogUseCases.getSellingPrice( productId4 );

        // then
        assertEquals( sellingPrice4, foundSellingPrice );
    }


    @Test
    public void testAddProductWithInvalidData() {
        // given
        String name = "SomeStuff";
        String description = "Some more explanation on the stuff";
        Float size = 5.0f;
        MoneyType buyingPrice =
                FactoryMethodInvoker.instantiateMoney( 5.0f, "EUR" );
        MoneyType sellingPrice =
                FactoryMethodInvoker.instantiateMoney( 10.0f, "EUR" );
        MoneyType tooLowSellingPrice =
                FactoryMethodInvoker.instantiateMoney( 4.0f, "EUR" );

        // when / then
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        null, description, size, buyingPrice, sellingPrice ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        "", description, size, buyingPrice, sellingPrice ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        name, null, size, buyingPrice, sellingPrice ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        name, "", size, buyingPrice, sellingPrice ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        name, description, size, null, sellingPrice ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        name, description, size, buyingPrice, null ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        name, description, size, buyingPrice, tooLowSellingPrice ) );
    }


    @Test
    public void testRemoveNonExistentProduct() {
        // given product 2 is not in stock anywhere - should be removable
        UUID nonExistentProductId = UUID.randomUUID();

        // when
        // then
        assertThrows( ShopException.class,
                () -> productCatalogUseCases.removeProductFromCatalog( nonExistentProductId ) );
    }


    @Test
    public void testRemoveProductWithNoStock() {
        // given product 0 is not in stock anywhere - should be removable
        UUID productId0 = productTestHelper.getProductId( 0 );
        storageUnitTestHelper.addAllStorageUnits( true );

        // when
        assertDoesNotThrow( () -> productCatalogUseCases.getSellingPrice( productId0 ) );
        productCatalogUseCases.removeProductFromCatalog( productId0 );

        // then
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.getSellingPrice( productId0 ) );
    }


    @Test
    public void testRemoveProductThatIsInStock() {
        // given
        storageUnitTestHelper.addAllStorageUnits( false );
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
        UUID productId3 = productTestHelper.getProductId( 3 );
        UUID productId4 = productTestHelper.getProductId( 4 );
        storageUnitUseCases.addToStock( storageUnitId0, productId3, 3 );

        // then product 3 must not be removable, but product 4 must be removable
        assertThrows( ShopException.class,
                () -> productCatalogUseCases.removeProductFromCatalog( productId3 ) );
        assertDoesNotThrow( () -> productCatalogUseCases.removeProductFromCatalog( productId4 ) );
    }


    @Test
    public void testRemoveProductThatIsInOrder() {
        // given
        storageUnitTestHelper.addAllStorageUnits( false );
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
        UUID productId4 = productTestHelper.getProductId( 4 );
        EmailAddressType customerEmailAddress4 =
                customerTestHelper.getCustomerEmailAddress( 4 );
        storageUnitUseCases.addToStock( storageUnitId0, productId4, 4 );

        // when customer 4 adds 4x product 4 to his shopping basket and checks out ...
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress4, productId4, 4 );
        shoppingBasketUseCases.checkout( customerEmailAddress4 );

        // then product 4 must not be removable
        assertThrows( ShopException.class,
                () -> productCatalogUseCases.removeProductFromCatalog( productId4 ) );
    }


    @Test
    public void testClearProductCatalog() {
        // given
        UUID productId4 = productTestHelper.getProductId( 4 );

        // when
        productCatalogUseCases.deleteProductCatalog();

        // then
        assertThrows( ShopException.class, () -> productCatalogUseCases.getSellingPrice( productId4 ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\CheckoutAcceptanceTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingbasket;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * This test checks the management of stock across storage units. It focuses on the
 * cases where more than one storage unit are needed to serve the shopping basket of a customer.
 */
@Slf4j
@SpringBootTest
public class CheckoutAcceptanceTest {
    @Autowired
    private CustomerRegistrationUseCases customerRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private OrderUseCases orderUseCases;
    @Autowired
    private StorageUnitUseCases storageUnitUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private CustomerTestHelper customerTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private StorageUnitTestHelper storageUnitTestHelper;

    private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
                                map8_11_14_quantity_3_3_4,
                                map10_12_quantity_1_1, 
                                map11_quantity_1, 
                                map12_quantity_10,
                                map8_9_10_11_quantity_2_1_4_2;
    private EmailAddressType customerEmailAddress3, customerEmailAddress6,
            customerEmailAddress2;
    private UUID productId8, productId9, productId10, productId11, productId12,
            productId14;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        customerTestHelper.registerAllCustomers();
        productTestHelper.addAllProducts();
        storageUnitTestHelper.addAllStorageUnits( true );

        customerEmailAddress3 = customerTestHelper.getCustomerEmailAddress( 3 );
        customerEmailAddress6 = customerTestHelper.getCustomerEmailAddress( 6 );
        customerEmailAddress2 = customerTestHelper.getCustomerEmailAddress( 2 );

        productId8 = productTestHelper.getProductId( 8 );
        productId9 = productTestHelper.getProductId( 9 );
        productId10 = productTestHelper.getProductId( 10 );
        productId11 = productTestHelper.getProductId( 11 );
        productId12 = productTestHelper.getProductId( 12 );
        productId14 = productTestHelper.getProductId( 14 );

        map8_11_14_quantity_2_2_2 = new HashMap<>() {{
            put( productId8, 2 );
            put( productId11, 2 );
            put( productId14, 2 );
        }};
        map8_11_14_quantity_3_3_4 = new HashMap<>() {{
            put( productId8, 3 );
            put( productId11, 3 );
            put( productId14, 4 );
        }};
        map10_12_quantity_1_1 = new HashMap<>() {{
            put( productId10, 1 );
            put( productId12, 1 );
        }};
        map11_quantity_1 = new HashMap<>() {{
            put( productId11, 1 );
        }};
        map12_quantity_10 = new HashMap<>() {{
            put( productId12, 10 );
        }};
        map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
            put( productId8, 2 );
            put( productId9, 1 );
            put( productId10, 4 );
            put( productId11, 2 );
        }};

    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across storage units, as specified in the StorageUnitTestHelper and in the README file.
     */
    @Test
    public void testClosestSingleStorageUnitWins() {
        log.info( "testClosestSingleStorageUnitWins" );

        // given
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress3, productId8, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress3, productId11, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress3, productId14, 2 );
        // that basket could have been served from storage unit 4 or 7, but 4 is closer to the customer
        UUID storageUnitId4 = storageUnitTestHelper.getStorageUnitId( 4 );

        // when
        Set<UUID> orderIds = shoppingBasketUseCases.checkout( customerEmailAddress3 );

        // then
        checkStorageUnitIds( orderIds, storageUnitId4 );
        checkProductNumbers( orderIds, storageUnitId4, map8_11_14_quantity_2_2_2 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across storage units, as specified in the StorageUnitTestHelper and in the README file.
     */
    @Test
    public void testStorageUnitWithEnoughCapacityWins() {
        log.info( "testStorageUnitWithEnoughCapacityWins" );

        // given
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress3, productId8, 3 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress3, productId11, 3 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress3, productId14, 4 );
        // that basket could have been served from storage unit 4 or 7, 4 is closer to the customer,
        // but only 7 has enough capacity
        UUID storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );

        // when
        Set<UUID> orderIds = shoppingBasketUseCases.checkout( customerEmailAddress3 );

        // then
        checkStorageUnitIds( orderIds, storageUnitId7 );
        checkProductNumbers( orderIds, storageUnitId7, map8_11_14_quantity_3_3_4 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across storage units, as specified in the StorageUnitTestHelper and in the README file.
     */
    @Test
    public void testTwoStorageUnits() {
        log.info( "testTwoStorageUnits" );

        // given
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress6, productId10, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress6, productId11, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress6, productId12, 1 );
        // that basket needs two deliveries (2 + 1 products) anyway, and there
        // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
        // closer. The smaller can then be served from 4 (closest), 7, or 8.
        UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
                // should cover map10_12_quantity_1_1
        UUID storageUnitId4 = storageUnitTestHelper.getStorageUnitId( 4 );
                // should cover map11_quantity_1

        // when
        Set<UUID> orderIds = shoppingBasketUseCases.checkout( customerEmailAddress6 );

        // then
        checkStorageUnitIds( orderIds, storageUnitId5, storageUnitId4 );
        checkProductNumbers( orderIds, storageUnitId5, map10_12_quantity_1_1 );
        checkProductNumbers( orderIds, storageUnitId4, map11_quantity_1 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across storage units, as specified in the StorageUnitTestHelper and in the README file.
     */
    @Test
    public void testTwoBigDeliverys() {
        log.info( "testTwoBigDeliverys" );

        // given
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress2, productId8, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress2, productId9, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress2, productId10, 4 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress2, productId11, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress2, productId12, 10 );
        // when
        Set<UUID> orderIds = shoppingBasketUseCases.checkout( customerEmailAddress2 );
        UUID storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );
                // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 products
        UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
                // should cover map12_quantity_10 - the only storage unit with enough capacity for 10 products

        // then
        checkStorageUnitIds( orderIds, storageUnitId7, storageUnitId5 );
        checkProductNumbers( orderIds, storageUnitId7, map8_9_10_11_quantity_2_1_4_2 );
        checkProductNumbers( orderIds, storageUnitId5, map12_quantity_10 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across storage units, as specified in the StorageUnitTestHelper and in the README file.
     */
    @Test
    public void testOnlyOneSolution() {
        log.info( "testOnlyOneSolution" );

        // given
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress6, productId12, 10 );
        // when
        Set<UUID> orderIds = shoppingBasketUseCases.checkout( customerEmailAddress6 );
        UUID storageUnitId5 = storageUnitTestHelper.getStorageUnitId( 5 );
        // should cover map12_quantity_10 - the only storage unit with enough capacity for 10 products

        // then
        checkStorageUnitIds( orderIds, storageUnitId5 );
        checkProductNumbers( orderIds, storageUnitId5, map12_quantity_10 );
    }



    private void checkProductNumbers( Set<UUID> orderIds, UUID storageUnitId, Map<UUID, Integer> expectedMap ) {
        UUID fittingOrderId = null;
        for ( UUID orderId : orderIds ) {
            UUID foundStorageUnitId = orderUseCases.getStorageUnitIdForOrder( orderId );
            if ( foundStorageUnitId.equals( storageUnitId ) ) {
                fittingOrderId = orderId;
                break;
            }
        }
        assertNotNull( fittingOrderId, "No fitting order found for storage unit " + storageUnitId );

        int totalExpected = 0;
        int totalActual = 0;
        for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
            totalExpected += entry.getValue();
        }
        log.info( "Check order numbers for product {} in storage unit {}", fittingOrderId, storageUnitId );
        for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
            UUID productId = entry.getKey();
            Integer foundNumber =
                    orderUseCases.getOrderQuantForProduct( fittingOrderId, productId );
            assertEquals( entry.getValue(), foundNumber );
            totalActual += foundNumber;
        }
        // last check - do the total sums match?
        assertEquals( totalExpected, totalActual );
    }


    private void checkStorageUnitIds( Set<UUID> orderIds, UUID... expectedStorageUnitIds ) {
        assertEquals( expectedStorageUnitIds.length, orderIds.size() );
        Set<UUID> foundStorageUnitIds = new HashSet<>();
        for ( UUID orderId : orderIds ) {
            UUID storageUnitId = orderUseCases.getStorageUnitIdForOrder( orderId );
            foundStorageUnitIds.add( storageUnitId );
        }
        for ( UUID expectedStorageUnitId : expectedStorageUnitIds ) {
            assertTrue( foundStorageUnitIds.contains( expectedStorageUnitId ) );
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingbasket;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmailAddress;


@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class ShoppingBasketRESTTest {
    @Autowired
    private StorageUnitUseCases storageUnitUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private CustomerTestHelper customerTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private StorageUnitTestHelper storageUnitTestHelper;
    @Autowired
    private MockMvc mockMvc;
    @Autowired
    private ShoppingBasketRESTHelper shoppingBasketRESTHelper;

    private EmailAddressType nonExistingEmailAddress;
    private final Map<UUID, Integer> emptyMap = new HashMap<>();

    private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
    private EmailAddressType
            customerEmailAddress0,
            customerEmailAddress3,
            customerEmailAddress6,
            customerEmailAddress8;
    private String customerName0, customerName8;
    private UUID productId0, productId1, productId2, productId3, productId5,
                 productId7, productId9, productId11, nonExistentProductId;
    private UUID storageUnitId0, storageUnitId3, storageUnitId7, storageUnitId8;


    private static final ResultMatcher NOT_FOUND = status().isNotFound();
    private static final ResultMatcher OK = status().isOk();
    private static final ResultMatcher CREATED = status().isCreated();
    private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
    private static final ResultMatcher CONFLICT = status().isConflict();

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        customerTestHelper.registerAllCustomers();
        productTestHelper.addAllProducts();
        storageUnitTestHelper.addAllStorageUnits( true );
        nonExistingEmailAddress = instantiateEmailAddress( "harry@sally.de" );

        customerEmailAddress0 = customerTestHelper.getCustomerEmailAddress( 0 );
        customerEmailAddress3 = customerTestHelper.getCustomerEmailAddress( 3 );
        customerEmailAddress6 = customerTestHelper.getCustomerEmailAddress( 6 );
        customerEmailAddress8 = customerTestHelper.getCustomerEmailAddress( 8 );
        customerName0 = customerTestHelper.getCustomerName( 0 );
        customerName8 = customerTestHelper.getCustomerName( 8 );

        productId0 = productTestHelper.getProductId( 0 );
        productId1 = productTestHelper.getProductId( 1 );
        productId2 = productTestHelper.getProductId( 2 );
        productId3 = productTestHelper.getProductId( 3 );
        productId5 = productTestHelper.getProductId( 5 );
        productId7 = productTestHelper.getProductId( 7 );
        productId9 = productTestHelper.getProductId( 9 );
        productId11 = productTestHelper.getProductId( 11 );
        nonExistentProductId = UUID.randomUUID();

        storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
        storageUnitId3 = storageUnitTestHelper.getStorageUnitId( 3 );
        storageUnitId7 = storageUnitTestHelper.getStorageUnitId( 7 );
        storageUnitId8 = storageUnitTestHelper.getStorageUnitId( 8 );

        map9_quantity_1 = new HashMap<>() {{
            put( productId9, 1 );
        }};
        map5_quantity_2 = new HashMap<>() {{
            put( productId5, 2 );
        }};
        map7_quantity_7 = new HashMap<>() {{
            put( productId7, 7 );
        }};
        map9_11_quantity_2_2 = new HashMap<>() {{
            put( productId9, 2 );
            put( productId11, 2 );
        }};
    }


    @Test
    public void testInvalidShoppingBasketBaseUris() throws Exception {
        // given
        String allShoppingBasketsUri = "/shoppingBaskets";
        String randomIdUri = "/shoppingBaskets/" + UUID.randomUUID();
        String randomCustomerUUID = "/shoppingBaskets?customerId=" + UUID.randomUUID();
        String invalidCustomerUUID = "/shoppingBaskets?customerId=invalidUUID";
        String randomParamUri = "/shoppingBaskets?randomParam=randomValue";

        // when
        // then
        mockMvc.perform( get( allShoppingBasketsUri ) ).andExpect( status().isMethodNotAllowed() );
        mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomCustomerUUID ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( invalidCustomerUUID ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
    }


    @Test
    public void testInvalidPartUris() throws Exception {
        // given
        UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress8, emptyMap );
        String randomPartUri = "/shoppingBaskets/" + shoppingBasketId8.toString() + "/random";
        String randomProductUri = "/shoppingBaskets/" + shoppingBasketId8.toString()
                + "/parts/" + UUID.randomUUID();

        // when
        // then
        mockMvc.perform( post( randomPartUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( delete( randomProductUri ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testInvalidAddToShoppingBasket() throws Exception {
        // given
        Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
        expectedStartQuantityMap.put( productId2, 19 );

        // when
        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress0, emptyMap );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId, productId2, 6 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId, productId2, 13 );

        // then
        shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress0, expectedStartQuantityMap );

        // ... and check a couple of invalid cases
        shoppingBasketRESTHelper.addProductToShoppingBasket(
                shoppingBasketId, nonExistentProductId, 12, NOT_FOUND );
        shoppingBasketRESTHelper.addProductToShoppingBasket(
                UUID.randomUUID(), productId5, 12, NOT_FOUND );
        shoppingBasketRESTHelper.addProductToShoppingBasket(
                shoppingBasketId, productId5, -1, UNPROCESSABLE_ENTITY );

        // check if the shopping basket is still the same
        shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress0, expectedStartQuantityMap );
    }


    @Test
    public void testInvalidCheckout_unavailableProduct() throws Exception {
        // given
        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress0, emptyMap );

        // when
        // productId0 is not available in the requested quantity (or rather, not at all)
        shoppingBasketRESTHelper.addProductToShoppingBasket(
                shoppingBasketId, productId0, 1, CREATED );

        // check if the shopping basket is still the same
        shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
    }


    @Test
    public void testInvalidCheckout_tooLittleStock() throws Exception {
        // given
        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress0, emptyMap );

        // when
        // There are only 10 pieces of productId1 available
        shoppingBasketRESTHelper.addProductToShoppingBasket(
                shoppingBasketId, productId1, 11, CREATED );

        // check if the shopping basket is still the same
        shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
    }



    @Test
    public void testDeleteProductFromShoppingBasket() throws Exception {
        // given
        UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress6, emptyMap );
        Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
        expectedQuantityMap1.put( productId1, 1 );
        expectedQuantityMap1.put( productId2, 2 );
        expectedQuantityMap1.put( productId3, 3 );
        Map<UUID, Integer> quantityMap2 = new HashMap<>();
        quantityMap2.put( productId1, 1 );
        quantityMap2.put( productId3, 3 );

        // when
        // then
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId1, 1 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId2, 2 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId3, 3 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress6, expectedQuantityMap1 );

        shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId2 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress6, quantityMap2 );
    }


    @Test
    public void testNoDoubleDelete() throws Exception {
        // given
        UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress6, emptyMap );

        // when
        // then
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId3, 3 );
        shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId3 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress6, new HashMap<>() );
        shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId3, NOT_FOUND );
    }


    @Test
    public void testAddRemoveProductsFromAndToShoppingBasket() throws Exception {
        // given
        UUID shoppingBasketId3 = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress3, emptyMap );
        UUID shoppingBasketId5 = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress6, emptyMap );

        // when
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId1, 2 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId2, 3 );
        shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId3, productId1 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId1, 1 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId2, 6 );

        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId1, 2 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId2, 8 );
        shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId5, productId1 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId1, 1 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId2, 2 );

        // then
        // customer3 has 1x productId1 and 9x productId2 expected in cart
        Map<UUID, Integer> expectedMap3 = new HashMap<>();
        expectedMap3.put( productId1, 1 );
        expectedMap3.put( productId2, 9 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress3, expectedMap3 );

        // customer6 has 1x productId1 and 10x productId2 in cart
        Map<UUID, Integer> expectedMap5 = new HashMap<>();
        expectedMap5.put( productId1, 1 );
        expectedMap5.put( productId2, 10 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress6, expectedMap5 );
    }


    @Test
    public void testNoDoubleCheckout() throws Exception {
        // given
        UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( customerEmailAddress8, emptyMap );

        // when
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId2, 3 );

        // then
        shoppingBasketRESTHelper.checkout( shoppingBasketId8, customerName8, CREATED, null );
        shoppingBasketRESTHelper.checkout( shoppingBasketId8, null, CONFLICT, null );
    }


    @Test
    public void testCheckout_1_Order() throws Exception {
        // given:
        // Customer 0 wants to buy 1x product 9. This is in storage unit 5, 7, and 8. Out of these,
        // storage unit 8 with zip code 89250 is closest to customer 0 with zip code 02314.
        Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
            put( storageUnitId8, map9_quantity_1 );
        }};
        UUID shoppingBasketId0 = shoppingBasketRESTHelper.getQueryShoppingBasket(
                customerEmailAddress0, null );
        int stock9before =
                storageUnitUseCases.getAvailableStock( storageUnitId8, productId9 );

        // when
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId0, productId9, 1 );
        shoppingBasketRESTHelper.checkout( shoppingBasketId0, customerName0, CREATED, expectedOrders );
        int stock9after =
                storageUnitUseCases.getAvailableStock( storageUnitId8, productId9 );

        // then
        assertEquals( 1, stock9before - stock9after );
    }


    @Test
    public void testCheckout_3_Order() throws Exception {
        // given:
        // Customer 8 (Felix Bauer) wants to buy 2x each of products 5, 9, 11; and 7x product 7.
        //       - products 9 and 11 can both be found in storage units 7 and 8. Storage units 7 (76532) is closer to
        //         the customer (70173)
        //       - product 7 is available in storage units 1, 2, and 3, but only storage unit 3 has enough stock.
        //       - product 5 is only available in storage unit 0.
        Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
            put( storageUnitId0, map5_quantity_2 );
            put( storageUnitId3, map7_quantity_7 );
            put( storageUnitId7, map9_11_quantity_2_2 );
        }};
        UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket(
                customerEmailAddress8, null );
        int stock5before =
                storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
        int stock7before =
                storageUnitUseCases.getAvailableStock( storageUnitId3, productId7 );
        int stock9before =
                storageUnitUseCases.getAvailableStock( storageUnitId7, productId9 );
        int stock11before =
                storageUnitUseCases.getAvailableStock( storageUnitId7, productId11 );

        // when
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId5, 2 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId7, 7 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId9, 2 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId11, 2 );
        shoppingBasketRESTHelper.checkout( shoppingBasketId8, customerName8, CREATED, expectedOrders );
        int stock5after =
                storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
        int stock7after =
                storageUnitUseCases.getAvailableStock( storageUnitId3, productId7 );
        int stock9after =
                storageUnitUseCases.getAvailableStock( storageUnitId7, productId9 );
        int stock11after =
                storageUnitUseCases.getAvailableStock( storageUnitId7, productId11 );

        // then
        assertEquals( 2, stock5before - stock5after );
        assertEquals( 7, stock7before - stock7after );
        assertEquals( 2, stock9before - stock9after );
        assertEquals( 2, stock11before - stock11after );
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingbasket;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.InsufficientStockException;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;


import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;

@SpringBootTest
public class ShoppingBasketTest {
    @Autowired
    private CustomerRegistrationUseCases customerRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private StorageUnitUseCases storageUnitUseCases;
    @Autowired
    private OrderUseCases orderUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private CustomerTestHelper customerTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private StorageUnitTestHelper storageUnitTestHelper;

    private EmailAddressType nonExistingEmailAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        customerTestHelper.registerAllCustomers();
        productTestHelper.addAllProducts();

        nonExistingEmailAddress = instantiateEmailAddress( "this@nononono.de" );
    }


    @Test
    public void testInvalidAddToShoppingBasket() {
        // given
        UUID nonExistentProductId = UUID.randomUUID();
        UUID productId5 = productTestHelper.getProductId( 5 );
        UUID productId0 = productTestHelper.getProductId( 0 );
        EmailAddressType customerEmailAddress0 =
                customerTestHelper.getCustomerEmailAddress( 0 );
        storageUnitTestHelper.addAllStorageUnits( true );

        // then
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addProductToShoppingBasket(
                        nonExistingEmailAddress, productId0, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addProductToShoppingBasket(
                        null, productId0, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addProductToShoppingBasket(
                        customerEmailAddress0, nonExistentProductId, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addProductToShoppingBasket(
                        customerEmailAddress0, null, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addProductToShoppingBasket(
                        customerEmailAddress0, productId5, -1 ) );
    }


    @Test
    public void testInvalidRemoveFromShoppingBasket() {
        // given
        UUID nonExistentProductId = UUID.randomUUID();
        UUID productId5 = productTestHelper.getProductId( 5 );
        UUID productId1 = productTestHelper.getProductId( 1 );
        UUID productId2 = productTestHelper.getProductId( 2 );
        storageUnitTestHelper.addAllStorageUnits( true );
        EmailAddressType customerEmailAddress0 =
                customerTestHelper.getCustomerEmailAddress( 0 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress0, productId1, 5 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress0, productId2, 15 );

        // when
        shoppingBasketUseCases.removeProductFromShoppingBasket(
                customerEmailAddress0, productId1, 2 );
        shoppingBasketUseCases.removeProductFromShoppingBasket(
                customerEmailAddress0, productId2, 4 );
        shoppingBasketUseCases.removeProductFromShoppingBasket(
                customerEmailAddress0, productId2, 7 );
        // now we should have 3x productId1 and 4x productId2 in the shopping basket

        // then
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
                        customerEmailAddress0, nonExistentProductId, 12 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
                        nonExistingEmailAddress, productId5, 12 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
                        customerEmailAddress0, productId5, -1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
                        customerEmailAddress0, productId1, 4 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
                        customerEmailAddress0, productId2, 5 ) );
    }


    @Test
    public void testAddRemoveProductsFromAndToShoppingBasket() {
        // given
        UUID productId1 = productTestHelper.getProductId( 1 );
        UUID productId2 = productTestHelper.getProductId( 2 );
        EmailAddressType customerEmailAddress3 =
                customerTestHelper.getCustomerEmailAddress( 3 );
        EmailAddressType customerEmailAddress5 =
                customerTestHelper.getCustomerEmailAddress( 5 );

        // when customer 3 ...
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress3, productId1, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress3, productId2, 3 );
        shoppingBasketUseCases.removeProductFromShoppingBasket(
                customerEmailAddress3, productId1, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress3, productId1, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress3, productId2, 6 );
        Map<UUID, Integer> cart3 = shoppingBasketUseCases.getShoppingBasketAsMap( customerEmailAddress3 );
        // customer3 has 1x productId1 and 9x productId2 in cart

        // ... and when customer 5 ...
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress5, productId1, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress5, productId2, 8 );
        shoppingBasketUseCases.removeProductFromShoppingBasket(
                customerEmailAddress5, productId1, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress5, productId2, 2 );
        Map<UUID, Integer> cart5 = shoppingBasketUseCases.getShoppingBasketAsMap( customerEmailAddress5 );
        // customer5 has 1x productId1 and 10x productId2 in cart

        // then
        assertEquals( 2, cart3.size() );
        assertEquals( 1, cart3.get( productId1 ) );
        assertEquals( 9, cart3.get( productId2 ) );

        assertEquals( 2, cart5.size() );
        assertEquals( 1, cart5.get( productId1 ) );
        assertEquals( 10, cart5.get( productId2 ) );
    }


    @Test
    public void testShoppingBasketValue() {
        // given
        UUID productId3 = productTestHelper.getProductId( 3 );
        UUID productId6 = productTestHelper.getProductId( 6 );
        UUID productId8 = productTestHelper.getProductId( 8 );
        MoneyType price3 = productTestHelper.getSellingPrice( 3 );
        MoneyType price6 = productTestHelper.getSellingPrice( 6 );
        MoneyType price8 = productTestHelper.getSellingPrice( 8 );
        EmailAddressType customerEmailAddress3 =
                customerTestHelper.getCustomerEmailAddress( 3 );

        // when
        shoppingBasketUseCases.addProductToShoppingBasket( customerEmailAddress3, productId3, 3 );
        shoppingBasketUseCases.addProductToShoppingBasket( customerEmailAddress3, productId6, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket( customerEmailAddress3, productId8, 5 );
        // customer3 has 3x productId3, 2x productId6 and 5x productId8 in cart
        MoneyType cartValue = shoppingBasketUseCases.getShoppingBasketAsMoneyValue( customerEmailAddress3 );

        // then
        assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
                cartValue );
    }


    @Test
    public void testShoppingBasketValueInvalid() {
        // given
        // when
        // then
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.getShoppingBasketAsMoneyValue( nonExistingEmailAddress ) );
    }


    @Test
    public void testUnsuccessfulCheckout() {
        // given customer buying product 0 (which is not in stock), and customer 1 buying product 1
        // in a bigger quantity (11) than available (10)
        storageUnitTestHelper.addAllStorageUnits( true );
        EmailAddressType customerEmailAddress0 =
                customerTestHelper.getCustomerEmailAddress( 0 );
        EmailAddressType customerEmailAddress1 =
                customerTestHelper.getCustomerEmailAddress( 1 );
        UUID productId0 = productTestHelper.getProductId( 0 );
        UUID productId1 = productTestHelper.getProductId( 1 );

        // when
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress0, productId0, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                customerEmailAddress1, productId1, 11 );

        // then
        assertThrows( InsufficientStockException.class,
                () -> shoppingBasketUseCases.checkout( customerEmailAddress0 ) );
        assertThrows( InsufficientStockException.class,
                () -> shoppingBasketUseCases.checkout( customerEmailAddress1 ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\storageunit\StorageUnitManagementTest.java ---
package thkoeln.archilab.ecommerce.tests.storageunit;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.StorageUnitTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.StorageUnitUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;

import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateAddress;


/**
 * This test checks the management and lifecycle of storage units.
 */
@SpringBootTest
public class StorageUnitManagementTest {
    @Autowired
    private StorageUnitUseCases storageUnitUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private StorageUnitTestHelper storageUnitTestHelper;

    private AddressType someAddress;
    private UUID nonExistingId1;
    private UUID nonExistingId2;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        productTestHelper.addAllProducts();

        someAddress = instantiateAddress( "Some Street", "Some City",
                instantiateZipCode( "90001" ) );
        nonExistingId1 = UUID.randomUUID();
        nonExistingId2 = UUID.randomUUID();
    }


    @Test
    public void testAddInvalidStorageUnit() {
        // given
        String name = "Lager1";

        // when
        // then
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.addNewStorageUnit(
                        null, someAddress ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.addNewStorageUnit(
                        "", someAddress ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.addNewStorageUnit(
                        name, null ) );
    }


    @Test
    public void testDeleteAllStorageUnitsWhenEmpty() {
        // given
        storageUnitTestHelper.addAllStorageUnits( false );
        UUID productId9 = productTestHelper.getProductId( 9 );
        UUID storageUnitId1 = storageUnitTestHelper.getStorageUnitId( 1 );
        UUID storageUnitId2 = storageUnitTestHelper.getStorageUnitId( 2 );

        // when
        int numOf1 = storageUnitUseCases.getAvailableStock( storageUnitId1, productId9 );
        int numOf2 = storageUnitUseCases.getAvailableStock( storageUnitId2, productId9 );

        // then
        assertEquals( 0, numOf1 );
        assertEquals( 0, numOf2 );
        storageUnitUseCases.deleteAllStorageUnits();
        // ... ids must be invalid now
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.getAvailableStock( storageUnitId1, productId9 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.getAvailableStock( storageUnitId2, productId9 ) );
    }


    @Test
    public void testDeleteAllStorageUnitsWhenFull() {
        // given
        storageUnitTestHelper.addAllStorageUnits( true );
        UUID productId7 = productTestHelper.getProductId( 7 );
        UUID storageUnitId1 = storageUnitTestHelper.getStorageUnitId( 1 );
        UUID storageUnitId2 = storageUnitTestHelper.getStorageUnitId( 2 );

        // when
        int numOf1 = storageUnitUseCases.getAvailableStock( storageUnitId1, productId7 );
        int numOf2 = storageUnitUseCases.getAvailableStock( storageUnitId2, productId7 );

        // then
        assertTrue( numOf1 == 3 );
        assertTrue( numOf2 == 3 );
        storageUnitUseCases.deleteAllStorageUnits();
        // ... ids must be invalid now
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.getAvailableStock( storageUnitId1, productId7 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.getAvailableStock( storageUnitId2, productId7 ) );
    }



    @Test
    public void testAddToStock() {
        // given
        storageUnitTestHelper.addAllStorageUnits( true );
        UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in storage unit 0
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
        int originalStock5 =
                storageUnitTestHelper.getStorageUnitStock( 0, 5 );

        // when
        int stock5before = storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
        storageUnitUseCases.addToStock( storageUnitId0, productId5, 23 );
        int stock5after = storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
        storageUnitUseCases.addToStock( storageUnitId0, productId5, 0 );
        int stock5after2 = storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );

        // then
        assertEquals( originalStock5, stock5before );
        assertEquals( stock5before + 23, stock5after );
        assertEquals( stock5after, stock5after2 );
    }


    @Test
    public void testInvalidAddToStock() {
        // given
        storageUnitTestHelper.addAllStorageUnits( true );
        UUID productId2 = productTestHelper.getProductId( 2 );
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );

        // when
        // then
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.addToStock( nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.addToStock(
                        storageUnitId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.addToStock(
                        nonExistingId1, productId2, 12 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.addToStock(
                        storageUnitId0, productId2, -1 ) );
    }


    @Test
    public void testRemoveFromStock() {
        // given
        storageUnitTestHelper.addAllStorageUnits( true );
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
        UUID productId0 = productTestHelper.getProductId( 0 ); // 0 in storage unit 0
        UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in storage unit 0
        UUID productId6 = productTestHelper.getProductId( 6 ); // random >30 in storage unit 0
        int stock0before =
                storageUnitTestHelper.getStorageUnitStock( 0, 0 );
        int stock5before =
                storageUnitTestHelper.getStorageUnitStock( 0, 5 );
        int stock6before =
                storageUnitTestHelper.getStorageUnitStock( 0, 6 );

        // when
        storageUnitUseCases.removeFromStock( storageUnitId0, productId5, 1 );
        int stock5after = storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );
        storageUnitUseCases.removeFromStock( storageUnitId0, productId0, 0 );
        int stock0after = storageUnitUseCases.getAvailableStock( storageUnitId0, productId0 );
        storageUnitUseCases.removeFromStock(
                storageUnitId0, productId6, stock6before );
        int stock6after = storageUnitUseCases.getAvailableStock( storageUnitId0, productId6 );

        // then
        assertEquals( stock5before - 1, stock5after );
        assertEquals( stock0before, stock0after );
        assertEquals( 0, stock6after );
    }


    @Test
    public void testInvalidRemoveFromStock() {
        // given
        storageUnitTestHelper.addAllStorageUnits( true );
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
        UUID productId0 = productTestHelper.getProductId( 0 ); // 0 in storage unit 0
        UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in storage unit 0
        int stock5before =
                storageUnitTestHelper.getStorageUnitStock( 0, 5 );

        // when
        // then
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.removeFromStock( nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.removeFromStock(
                        storageUnitId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.removeFromStock(
                        nonExistingId1, productId5, 12 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.removeFromStock(
                        storageUnitId0, productId5, -1 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.removeFromStock(
                        storageUnitId0, productId5, stock5before + 1 ) );
        assertThrows( ShopException.class,
                () -> storageUnitUseCases.removeFromStock(
                        storageUnitId0, productId0, 1 ) ); // already 0 in storage unit 0
    }


    @Test
    public void testChangeStock() {
        // given
        storageUnitTestHelper.addAllStorageUnits( true );
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
        UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in storage unit 0

        // when
        storageUnitUseCases.changeStockTo( storageUnitId0, productId5, 111 );
        int stock5after = storageUnitUseCases.getAvailableStock( storageUnitId0, productId5 );

        // then
        assertEquals( 111, stock5after );
    }


    @Test
    public void testInvalidChangeStock() {
        // given
        storageUnitTestHelper.addAllStorageUnits( true );
        UUID storageUnitId0 = storageUnitTestHelper.getStorageUnitId( 0 );
        UUID productId6 = productTestHelper.getProductId( 6 );

        // when
        // then
        assertThrows( ShopException.class, () -> storageUnitUseCases.changeStockTo(
                nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class, () -> storageUnitUseCases.changeStockTo(
                nonExistingId1, productId6, 12 ) );
        assertThrows( ShopException.class, () -> storageUnitUseCases.changeStockTo(
                storageUnitId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class, () -> storageUnitUseCases.changeStockTo(
                storageUnitId0, productId6, -1 ) );
    }


    @Test
    public void testEmptyStorageUnit() {
        // given
        storageUnitTestHelper.addAllStorageUnits( true );
        UUID storageUnitId9 = storageUnitTestHelper.getStorageUnitId( 9 ); // empty storage unit

        // when
        int totalStock = 0;
        for ( int iProduct = 0; iProduct < productTestHelper.numberOfProducts(); iProduct++ ) {
            UUID productId = productTestHelper.getProductId( iProduct );
            totalStock += storageUnitUseCases.getAvailableStock(
                    storageUnitId9, productId );
        }

        // then
        assertEquals( 0, totalStock );
    }



}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
package thkoeln.archilab.ecommerce.tests.testtests;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.domain.JavaMethod;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.web.bind.annotation.RestController;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingBasketRESTTest;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.AddressType;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static org.springframework.test.util.AssertionErrors.assertTrue;

/**
 * This test checks if there are the appropriate tests in the test class(es) for domain
 * primitives.
 */

public class RulesForOwnTests {
    private JavaClass dpTestClass, restTestClass;
    private JavaClasses dpTestClasses, restTestClasses;
    private static final String STORAGE_UNIT_DOMAIN_PACKAGE =
            "thkoeln.archilab.ecommerce.solution.storageunit.domain";
    private static final String STORAGE_UNIT_CLASS_NAME =
            STORAGE_UNIT_DOMAIN_PACKAGE + ".StorageUnit";


    @BeforeEach
    public void setUp() throws Exception {
        dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
        restTestClass = new ClassFileImporter().importClass( OwnShoppingBasketRESTTest.class );

        dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
        restTestClasses = new ClassFileImporter().importClasses( OwnShoppingBasketRESTTest.class );
    }


    @Test
    public void ensureMinimumNumberOfTestMethods() {
        // given
        // when
        int dpTestMethodCount = getTestMethodCount( dpTestClass );
        int restTestMethodCount = getTestMethodCount( restTestClass );

        // then
        assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
                        + dpTestMethodCount,dpTestMethodCount >= 2 );
        assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
                        + restTestMethodCount, restTestMethodCount >= 5 );
    }

    private int getTestMethodCount( JavaClass testClass ) {
        int testMethodCount = 0;
        for ( JavaMethod method : testClass.getMethods() ) {
            if ( isTestMethod( method ) ) {
                testMethodCount++;
            }
        }
        return testMethodCount;
    }

    private boolean isTestMethod( JavaMethod method ) {
        return method.isAnnotatedWith( Test.class );
    }


    @Test
    public void dpTestsShouldReferenceTheRightClasses() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAssignableTo( ZipCodeType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( MoneyType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( AddressType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( EmailAddressType.class )
                .because( "DomainPrimitiveJSONSerializationTest should reference ZipCode, " +
                        "Money, EmailAddress, and Address!" );
        rule.check( dpTestClasses );
    }


    @Test
    public void restTestsShouldReferenceEmailAddress() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAssignableTo( EmailAddressType.class )
                .because( "StorageUnitComparatorUnitTest should reference EmailAddressType!" );
        rule.check( restTestClasses );
    }


    @Test
    public void restTestsShouldReferenceRESTControllers() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAnnotatedWith( RestController.class )
                .orShould().dependOnClassesThat()
                .areAssignableTo( ShoppingBasketRESTHelper.class )
                .because( "StorageUnitComparatorUnitTest should call REST controllers! " +
                        "(either directly or via the ShoppingBasketRESTHelper REST helper)" );
        rule.check( restTestClasses );
    }

}


[RESPONSE]:
**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\EmailAddress.java**  
EmailAddress.java Zeile 55-58: Duplication (original Zeile 69-72) : Die Regex-Validierung ist in zwei Methoden dupliziert mit geringfügigen Unterschieden.  
EmailAddress.java Zeile 61: Negative conditional : Methode isInvalidEmailAddress ist negativ benannt.  
EmailAddress.java Zeile 64: Dead code : Auskommentierter System.out.println.  

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java**  
ZipCode.java Zeile 46-48: Dead code : Nicht verwendete Variable charArray.  

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerRegistrationService.java**  
CustomerRegistrationService.java Zeile 119-127: Duplication (original in StorageUnitService.java Zeile 216-224) : Methode areFieldsInvalid/areFieldsValid dupliziert Logik zur Prüfung auf null oder empty.  
CustomerRegistrationService.java Zeile 129-131: Duplication (original in StorageUnitService.java Zeile 226-228) : Methode isValidZipCode/isInvalidZipCode dupliziert Logik zur PLZ-Validierung.  

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\application\StorageUnitService.java**  
StorageUnitService.java Zeile 216-224: Duplication (original in CustomerRegistrationService.java Zeile 119-127) : Methode areFieldsValid dupliziert.  
StorageUnitService.java Zeile 226-228: Duplication (original in CustomerRegistrationService.java Zeile 129-131) : Methode isInvalidZipCode dupliziert und negativ benannt.  
StorageUnitService.java Zeile 226: Negative conditional : Methode isInvalidZipCode ist negativ benannt.  

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java**  
ShoppingBasketService.java Zeile 145-151: Dead code : Auskommentierter Debug-Code.  

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java**  
ShoppingBasketController.java Zeile 124-126: Dead code : Auskommentierte Zeilen.  

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StorageUnit.java**  
StorageUnit.java Zeile 14: Layer violation : @Component auf einer JPA Entity ist nicht angemessen und verletzt die Schichtenarchitektur.  

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\Customer.java**  
- Anemic Entity  

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\Product.java**  
- Anemic Entity  

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java**  
- Anemic Entity  

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java**  
- Anemic Entity  

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\storageunit\domain\StockLevel.java**  
- Anemic Entity  

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPart.java**  
- Anemic Entity  

**C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_6c9c960d-fa9f-4b80-9b1c-388e2b42312a\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPart.java**  
- Anemic Entity  

ENDE
Generated by deepseek-reasoner
-----------------------------------