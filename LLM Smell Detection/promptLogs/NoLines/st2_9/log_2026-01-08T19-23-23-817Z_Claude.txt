--- DATE: 8.1.2026, 20:23:23 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
    Architektur: 4-Layer (Eric Evans).
    Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
    Regeln:
    1. Begründe kurz jeden Fund.
    4. Gruppiere nach Datei (mit Pfad). 
    2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
    3. Keine Code-Wiederholung, nur Referenzen.
    5. Wenn fertig, schreibe "ENDE".



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Currency.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.Embeddable;
import lombok.*;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

import java.util.Locale;

@Getter
@Embeddable
@EqualsAndHashCode
@NoArgsConstructor(access = AccessLevel.PROTECTED) // für JPA
@AllArgsConstructor(access = AccessLevel.PRIVATE)
public class Currency implements CurrencyType {

    private enum AllowedCurrencyUnit {EUR, CHF}

    @JsonProperty("amount")
    private Float amount;

    @JsonProperty("unit")
    private String currencyUnit;

    public static Currency of(Float amount, String currencyUnit) {
        if (!isValidCurrency(amount, currencyUnit))
            throw new ShopException("Amount must not be null or negative.");

        try {
            AllowedCurrencyUnit.valueOf(currencyUnit);
        } catch (IllegalArgumentException e) {
            throw new ShopException("Invalid currency unit: " + currencyUnit);
        }

        return new Currency(amount, currencyUnit);
    }

    @Override
    public Float getQuantity() {
        return this.amount;
    }

    @Override
    public String getCurrencyUnit() {
        return this.currencyUnit;
    }

    @Override
    public CurrencyType add(CurrencyType otherCurrency) {
        validateOtherCurrency(otherCurrency);
        float result = this.amount + otherCurrency.getQuantity();
        return new Currency(result, this.currencyUnit);
    }

    @Override
    public CurrencyType subtract(CurrencyType otherCurrency) {
        validateOtherCurrency(otherCurrency);
        if (otherCurrency.getQuantity() > this.amount) {
            throw new ShopException("Subtracted amount must not be greater than current amount.");
        }
        float result = this.amount - otherCurrency.getQuantity();
        return new Currency(result, this.currencyUnit);
    }

    @Override
    public CurrencyType multiplyBy(int factor) {
        if (factor < 0) {
            throw new ShopException("Factor must not be negative.");
        }
        float result = this.amount * factor;
        return new Currency(result, this.currencyUnit);
    }

    @Override
    public boolean largerThan(CurrencyType otherCurrency) {
        validateOtherCurrency(otherCurrency);
        return this.amount > otherCurrency.getQuantity();
    }

    private void validateOtherCurrency(CurrencyType otherCurrency) {
        if (otherCurrency == null) {
            throw new ShopException("Other currency must not be null.");
        }
        if (!this.currencyUnit.equals(otherCurrency.getCurrencyUnit())) {
            throw new ShopException("Currency units must match.");
        }
    }

    @Override
    public String toString() {
        java.text.DecimalFormat df = new java.text.DecimalFormat("0.00");
        df.setDecimalFormatSymbols(java.text.DecimalFormatSymbols.getInstance(Locale.getDefault()));

        String symbol = currencyUnit.equals("EUR") ? "€" : currencyUnit;
        return df.format(this.amount) + " " + symbol;
    }

    public static boolean isValidCurrency(Float amount, String currencyUnit){
        if (amount == null || amount < 0)
            return false;
        if (currencyUnit == null)
            return false;
        return true;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\EmailAddress.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.Embeddable;
import lombok.*;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.ConflictException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

@Getter
@Embeddable
@EqualsAndHashCode
@NoArgsConstructor(access = AccessLevel.PROTECTED) // für JPA
@AllArgsConstructor(access = AccessLevel.PRIVATE)
public class EmailAddress implements EmailAddressType {

    @JsonProperty("emailAddressString")
    private String email;

    public static EmailAddress of(String emailStr) {
        if(!isValidEmail(emailStr))
            throw new ConflictException("Email address is not a valid email address");
        return new EmailAddress(emailStr);
    }

    @Override
    public EmailAddressType sameIdentifyerDifferentDomain(String newDomain) {
        if (newDomain == null) throw new ConflictException("Domain part must not be null.");
        String identifier = getIdentifierPart();
        return EmailAddress.of(identifier + "@" + newDomain);
    }

    @Override
    public EmailAddressType sameDomainDifferentIdentifyer(String newIdentifier) {
        if (newIdentifier == null) throw new ConflictException("Identifier part must not be null.");
        String domain = getDomainPart();
        return EmailAddress.of(newIdentifier + "@" + domain);
    }

    @Override
    public String toString() {
        return email;
    }

    private static boolean isValidEmail(String emailStr) {
        if(emailStr == null)
            throw new ConflictException("Email address is not a valid email address");

        String[] parts = emailStr.split("@");
        if (parts.length != 2) return false;

        String localPart = parts[0];
        String domainPart = parts[1];

        if (localPart.isEmpty() || domainPart.isEmpty()) return false;
        if (emailStr.matches(".*\\s.*")) return false;
        if (!localPart.matches("[A-Za-z0-9._-]+")) return false;
        if (!domainPart.matches("[A-Za-z0-9.-]+")) return false;
        if (emailStr.contains("..")) return false;
        if (!domainPart.matches(".*\\.(de|at|ch|com|org|fr)$")) return false;

        return true;
    }

    private String getIdentifierPart() {
        return email.split("@")[0];
    }

    private String getDomainPart() {
        return email.split("@")[1];
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\ConflictException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.CONFLICT, reason = "Violating a business rule")
public class ConflictException extends ShopException {
    public ConflictException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\MethodNotAllowedException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(HttpStatus.METHOD_NOT_ALLOWED)
public class MethodNotAllowedException extends ShopException {
    public MethodNotAllowedException(String message) {
        super(message);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\UnprocessableEntityException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY, reason = "Unprocessable Entity")
public class UnprocessableEntityException extends ShopException {
    public UnprocessableEntityException( String message ) {
        super( message );
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PhysicalAddress.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.Embeddable;
import jakarta.persistence.Embedded;
import lombok.*;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

@Getter
@Embeddable
@EqualsAndHashCode
@NoArgsConstructor(access = AccessLevel.PROTECTED) // für JPA
@AllArgsConstructor(access = AccessLevel.PRIVATE)
public class PhysicalAddress implements PhysicalAddressType {

    @JsonProperty("street")
    private String street;

    @JsonProperty("city")
    private String city;

    @Embedded
    @JsonProperty("postalCode")
    private PostalCode postalCode;

    public static PhysicalAddress of(String street, String city, PostalCodeType postalCode) {
        if (street == null || street.trim().isEmpty()) {
            throw new ShopException("Street must not be null or empty");
        }
        if (city == null || city.trim().isEmpty()) {
            throw new ShopException("City must not be null or empty");
        }
        if (!(postalCode instanceof PostalCode)) {
            throw new ShopException("Postal code must not be null and must be a PostalCode");
        }

        return new PhysicalAddress(street.trim(), city.trim(), (PostalCode) postalCode);
    }

    @Override
    public PostalCodeType getPostalCode() {
        return postalCode;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PostalCode.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.Embeddable;
import lombok.*;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

@Getter
@Embeddable
@EqualsAndHashCode
@NoArgsConstructor(access = AccessLevel.PROTECTED) // für JPA
@AllArgsConstructor(access = AccessLevel.PRIVATE)
public class PostalCode implements PostalCodeType {

    @JsonProperty("postalCodeString")
    private String postalCode;

    public static PostalCode of(String postalCodeStr) {
        if (postalCodeStr == null)
            throw new ShopException("Postal code must not be null.");
        if(!isValidPostalCode(postalCodeStr))
            throw new ShopException("Postal code not valid.");

        return new PostalCode(postalCodeStr);
    }

    public int distance(PostalCodeType otherPostalCode) throws ShopException {
        if (otherPostalCode == null)
            throw new ShopException("Postleitzahl darf nicht null sein");


        String plz1 = this.toString();
        String plz2 = otherPostalCode.toString();

        if (plz1.equals(plz2)) {
            return 0;
        }

        // 1. Schritt: Regionale Prüfung über erste Ziffer
        int region1 = plz1.charAt(0);
        int region2 = plz2.charAt(0);

        int regionDistance = Math.min(
                Math.abs(region1 - region2),
                10 - Math.abs(region1 - region2)
        );

        // 2. Schritt: Feiner Vergleich – finde erste unterschiedliche Ziffer ab Position 1 (zweite Stelle)
        int distance = 0;
        int plz1Length = postalCode.length();
        for (int i = 1; i < plz1Length; i++) {
            if (plz1.charAt(i) != plz2.charAt(i)) {
                distance = plz1Length - i;  // Je weiter links der Unterschied, desto größer die Zahl (max 4, min 1)
                break;
            }
        }

        int totalDistance = distance + regionDistance;
        return totalDistance;
    }

    private static boolean isValidPostalCode(String postalCodeStr) {
        if (!postalCodeStr.matches("\\d{5}"))
            return false;
        if (postalCodeStr.substring(1).equals("0000"))
            return false;
        return true;
    }

    @Override
    public Integer getFirstDigitPostalCode() {
        return Integer.parseInt(postalCode.substring(0, 1));
    }

    @Override
    public String toString() {
        return postalCode;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
/*
 * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
 */
package thkoeln.archilab.ecommerce;

import jakarta.persistence.Column;
import jakarta.persistence.MappedSuperclass;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

import java.io.Serializable;
import java.util.UUID;

@MappedSuperclass
@Getter
@EqualsAndHashCode(of = "id")
@ToString(of = "id")
public abstract class GenericId implements Serializable {
    @Column(nullable = false, updatable = false)
    private final UUID id;

    protected GenericId() {
        this( UUID.randomUUID() );
    }

    protected GenericId( UUID id ) {
        this.id = id;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
/*
 * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
 */
package thkoeln.archilab.ecommerce;

import jakarta.persistence.AttributeConverter;

import java.util.UUID;
import java.util.function.Function;


public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
    private final Function<UUID, T> factory;

    protected GenericIdConverter( Function<UUID, T> factory ) {
        this.factory = factory;
    }

    @Override
    public UUID convertToDatabaseColumn( T attribute ) {
        return attribute == null ? null : attribute.getId();
    }

    @Override
    public T convertToEntityAttribute( UUID dbData ) {
        return dbData == null ? null : factory.apply( dbData );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\InsufficientStockException.java ---
/*
 * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
 */
package thkoeln.archilab.ecommerce;

/**
 * Exception is thrown if the product's stock level is not sufficient to serve the purchase.
 */
public class InsufficientStockException extends ShopException {
    public InsufficientStockException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
/*
 * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
 */
package thkoeln.archilab.ecommerce;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class ProjectApplication {

	/**
	 * Entry method
	 * @param args
	 */
	public static void main(String[] args) {
		SpringApplication.run(ProjectApplication.class, args);
	}
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
/*
 * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
 */
package thkoeln.archilab.ecommerce;

public class ShopException extends RuntimeException {
    public ShopException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\application\DepotableService.java ---
package thkoeln.archilab.ecommerce.solution.depot.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.product.application.DepotableServiceInterface;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

@Service
public class DepotableService implements DepotableServiceInterface {
    private final DepotService depotService;

    public DepotableService(DepotService depotService) {
        this.depotService = depotService;
    }

    @Override
    public boolean existsProductInDepotByProductId(ProductId productId) {
        return depotService.existsProductInDepotByProductId(productId);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\application\DepotAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.depot.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.solution.depot.domain.DepotId;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.usecases.DepotUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.UUID;

@Service
public class DepotAdapterService implements DepotUseCases {

    private final DepotService depotService;

    public DepotAdapterService(
            DepotService depotService
    ) {
        this.depotService = depotService;
    }

    @Override
    public UUID addNewDepot(String name, PhysicalAddressType physicalAddress) {
        if (physicalAddress == null) throw new ShopException("Physical address must not be null");

        PhysicalAddress newPhysicalAddress = (PhysicalAddress) physicalAddress;
        DepotId depotId = depotService.addNewDepot(name, newPhysicalAddress);
        return depotId.getId();
    }

    @Override
    public void deleteAllDepots() {
        depotService.deleteAllDepots();
    }

    public UUID findSuitableDepot(String postalCode) {
        DepotId depotId = depotService.findSuitableDepot(postalCode);
        return depotId.getId();
    }

    @Override
    public void addToStock(UUID depotId, UUID productId, int addedQuantOf) {
        DepotId newDepotId = new DepotId(depotId);
        ProductId newProductId = new ProductId(productId);
        depotService.addToStock(newDepotId, newProductId, addedQuantOf);
    }

    @Override
    public void removeFromStock(UUID depotId, UUID productId, int removedQuantOf) {
        DepotId newDepotId = new DepotId(depotId);
        ProductId newProductId = new ProductId(productId);
        depotService.removeFromStock(newDepotId, newProductId, removedQuantOf);
    }

    @Override
    public void changeStockTo(UUID depotId, UUID productId, int newTotalQuantOf) {
        DepotId newDepotId = new DepotId(depotId);
        ProductId newProductId = new ProductId(productId);
        depotService.changeStockTo(newDepotId, newProductId, newTotalQuantOf);
    }

    @Override
    public int getAvailableStock(UUID depotId, UUID productId) {
        DepotId newDepotId = new DepotId(depotId);
        ProductId newProductId = new ProductId(productId);
        return depotService.getAvailableStock(newDepotId, newProductId);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\application\DepotService.java ---
package thkoeln.archilab.ecommerce.solution.depot.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.solution.depot.domain.Depot;
import thkoeln.archilab.ecommerce.solution.depot.domain.DepotId;
import thkoeln.archilab.ecommerce.solution.depot.domain.DepotRepository;
import thkoeln.archilab.ecommerce.solution.depot.domain.StockLevel;
import thkoeln.archilab.ecommerce.solution.product.application.ProductService;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

import java.util.ArrayList;
import java.util.List;

import static thkoeln.archilab.ecommerce.solution.depot.domain.Address.validatePostalCode;

@Service
public class DepotService {
    private final DepotRepository depotRepository;
    private final ProductService productService;

    public DepotService(
            DepotRepository depotRepository,
            ProductService productService
    ) {
        this.depotRepository = depotRepository;
        this.productService = productService;
    }

    public DepotId addNewDepot(String name, PhysicalAddress physicalAddress) {
        validateDepotName(name);

        Depot newDepot = new Depot(name, physicalAddress);

        depotRepository.save(newDepot);
        return newDepot.getId();
    }

    public void deleteAllDepots() {
        depotRepository.deleteAll();
    }

    public DepotId findSuitableDepot(String postalCode) {
        validatePostalCode(postalCode);

        Integer firstDigit = Integer.parseInt(postalCode.substring(0, 1));

        List<Depot> suitableDepots = depotRepository.findSuitableDepots(firstDigit);
        if(suitableDepots.isEmpty()) throw new ShopException("No suitable depot found");

        return suitableDepots.getFirst().getId();
    }

    public void addToStock(DepotId depotId, ProductId productId, int addedQuantOf) {
        if(addedQuantOf == 0) return;

        validateDepotId(depotId);
        productService.validateProductId(productId);
        validateQuantity(addedQuantOf);

        if(!productService.existsProductByProductId(productId)) throw new ShopException("Product does not exist");

        Depot depot = depotRepository.findDepotById(depotId)
                .orElseThrow(() -> new ShopException("No such depot"));

        StockLevel stockLevel = depot.findStockLevelByProductId(productId)
                .orElseGet(() -> null);

        if(stockLevel == null) {
            stockLevel = new StockLevel(productId, addedQuantOf);
            depot.getStockLevels().add(stockLevel);
        }
        else {
            int oldQuantOf = stockLevel.getQuantity();
            int newQuantOf = oldQuantOf + addedQuantOf;
            stockLevel.setQuantity(newQuantOf);
        }
        depotRepository.save(depot);
    }

    public void removeFromStock(DepotId depotId, ProductId productId, int removedQuantOf) {
        if(removedQuantOf == 0) return;
        validateDepotId(depotId);
        productService.validateProductId(productId);
        validateQuantity(removedQuantOf);

        if(!productService.existsProductByProductId(productId)) throw new ShopException("Product does not exist");

        Depot depot = depotRepository.findDepotById(depotId)
                .orElseThrow(() -> new ShopException("No such depot"));

        StockLevel stockLevel = depot.findStockLevelByProductId(productId)
                .orElseThrow(() -> new ShopException("No such stock level"));

        int oldQuantOf = stockLevel.getQuantity();

        if(oldQuantOf - removedQuantOf < 0) throw new ShopException("Quantity is too big");
        else if (oldQuantOf - removedQuantOf == 0) {
            depot.removeStockLevel(stockLevel);
        }
        else {
            stockLevel.setQuantity(oldQuantOf - removedQuantOf);
        }
        depotRepository.save(depot);
    }

    public void changeStockTo(DepotId depotId, ProductId productId, int newTotalQuantOf) {
        validateDepotId(depotId);
        productService.validateProductId(productId);
        if(newTotalQuantOf < 0) throw new ShopException("Quantity is too small");

        if(!productService.existsProductByProductId(productId)) throw new ShopException("Product does not exist");

        Depot depot = depotRepository.findDepotById(depotId)
                .orElseThrow(() -> new ShopException("No such depot"));

        StockLevel stockLevel = depot.findStockLevelByProductId(productId)
                .orElseGet(() -> null);

        if (stockLevel == null) {
            if(newTotalQuantOf > 0) {
                StockLevel newStockLevel = new StockLevel(productId, newTotalQuantOf);
                depot.getStockLevels().add(newStockLevel);
                depotRepository.save(depot);
                return;
            }
        }

        if(newTotalQuantOf == 0) {
            depot.removeStockLevel(stockLevel);
        }
        else {
            stockLevel.setQuantity(newTotalQuantOf);
        }
        depotRepository.save(depot);
    }

    public int getAvailableStock(DepotId depotId, ProductId productId) {
        validateDepotId(depotId);
        productService.validateProductId(productId);
        if(!productService.existsProductByProductId(productId)) throw new ShopException("Product does not exist");

        Depot depot = depotRepository.findDepotById(depotId)
                .orElseThrow(() -> new ShopException("No such depot"));

        StockLevel stockLevel = depot.findStockLevelByProductId(productId)
                .orElseGet(() -> null);

        if (stockLevel == null) return 0;
        else return stockLevel.getQuantity();
    }

    public boolean existsProductInDepotByProductId(ProductId productId) {
        for (Depot depot : depotRepository.findAll()) {
            if (depot.findStockLevelByProductId(productId).isPresent()) {
                return true;
            }
        }
        return false;
    }

    public List<Depot> getAllDepots() {
        List<Depot> depots = new ArrayList<>();
        for (Depot depot : depotRepository.findAll()) {
            depots.add(depot);
        }
        return depots;
    }


    // VALIDATE
    public void validateFromToDigitRange(Integer from, Integer to) {
        if(from > to) throw new ShopException("Depot FROM must be greater than or equal to TO");
    }
    public void validateDepotName(String depotName) {
        if(depotName == null || depotName.isEmpty()) {
            throw new ShopException("Depot name cannot be empty");
        }
    }
    public void validatePostalCodeDigit(Integer digit) {
        if(digit == null || digit > 9 || digit < 0) {
            throw new ShopException("Digit must be between 0 and 9");
        }
    }
    public void validateDepotId(DepotId depotId) {
        if(depotId == null) {
            throw new ShopException("DepotId cannot be null");
        }
    }
    public void validateQuantity(int quantity) {
        if(quantity < 0) {
            throw new ShopException("Quantity cannot be negative");
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\Address.java ---
package thkoeln.archilab.ecommerce.solution.depot.domain;

import jakarta.persistence.Embeddable;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;

@Embeddable
@Getter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class Address {
    private String street;
    private String city;
    private String postalCode;

    static public void validateAddress(String street, String city, String postalCode) {
        if(street == null || street.isEmpty()) {
            throw new ShopException("Street cannot be null or empty.");
        }
        if(city == null || city.isEmpty()) {
            throw new ShopException("City cannot be null or empty.");
        }
        validatePostalCode(postalCode);
    }
    static public void validatePostalCode(String postalCode) {
        if(postalCode == null || postalCode.isEmpty()) {
            throw new ShopException("PostalCode cannot be null or empty.");
        }
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\Depot.java ---
package thkoeln.archilab.ecommerce.solution.depot.domain;

import jakarta.persistence.*;
import lombok.*;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

import java.util.*;

@Entity
@Getter
@AllArgsConstructor
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Depot {

    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private DepotId id;

    @Setter
    private String name;

    @Setter
    private Integer fromPostalCodeFirstDigit;

    @Setter
    private Integer toPostalCodeFirstDigit;

    @Embedded
    private PhysicalAddress address;

    @Setter
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
    List<StockLevel> stockLevels = new ArrayList<>();

    public Depot(String name, PhysicalAddress physicalAddress) {
        this.id = new DepotId();
        this.name = name;
        this.address = physicalAddress;
    }

    public Optional<StockLevel> findStockLevelByProductId(ProductId productId) {
        for (StockLevel stockLevel : stockLevels) {
            if( stockLevel.getProductId().equals(productId)) {
                return Optional.of(stockLevel);
            }
        }
        return Optional.empty();
    }

    public void removeStockLevel(StockLevel stockLevel) {
        stockLevels.remove(stockLevel);
    }

    public Set<ProductId> fulfillableShoppingBasketPositions(Map<ProductId, Integer> productQuantityMap) {
        Set<ProductId> fulfillableProducts = new HashSet<>();

        for (Map.Entry<ProductId, Integer> entry : productQuantityMap.entrySet()) {
            ProductId productId = entry.getKey();
            Integer requiredQuantity = entry.getValue();

            Optional<StockLevel> optionalStockLevel = findStockLevelByProductId(productId);

            if (optionalStockLevel.isPresent() && optionalStockLevel.get().getQuantity() >= requiredQuantity) {
                fulfillableProducts.add(productId);
            }
        }

        return fulfillableProducts;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\DepotComparator.java ---
package thkoeln.archilab.ecommerce.solution.depot.domain;

import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

import java.util.Comparator;
import java.util.Map;
import java.util.Set;

public class DepotComparator implements Comparator<Depot> {

    private final Map<ProductId, Integer> shoppingBasket;
    private final PhysicalAddress customerAddress;

    public DepotComparator(
            Map<ProductId, Integer> shoppingBasket,
            PhysicalAddress customerAddress
    ) {
        this.shoppingBasket = shoppingBasket;
        this.customerAddress = customerAddress;
    }

    @Override
    public int compare(Depot depot1, Depot depot2) {
        Set<ProductId> fulfillable1 = depot1.fulfillableShoppingBasketPositions(shoppingBasket);
        Set<ProductId> fulfillable2 = depot2.fulfillableShoppingBasketPositions(shoppingBasket);

        int size1 = fulfillable1.size();
        int size2 = fulfillable2.size();

        if (size1 != size2) {
            return Integer.compare(size2, size1); // mehr erfüllbare Positionen = besser
        }

        // Falls gleich viele erfüllbare Positionen, vergleiche Entfernung
        double distance1 = depot1.getAddress().getPostalCode().distance(customerAddress.getPostalCode());
        double distance2 = depot2.getAddress().getPostalCode().distance(customerAddress.getPostalCode());

        return Double.compare(distance1, distance2); // kürzere Entfernung = besser
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\DepotId.java ---
package thkoeln.archilab.ecommerce.solution.depot.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "depot_id"))
public class DepotId extends GenericId {
    public DepotId( UUID id ) {
        super( id );
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\DepotIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.depot.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

@Converter(autoApply = true)
public class DepotIdConverter extends GenericIdConverter<DepotId> {
    public DepotIdConverter() {
        super(DepotId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\DepotRepository.java ---
package thkoeln.archilab.ecommerce.solution.depot.domain;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface DepotRepository extends CrudRepository<Depot, DepotId> {
    Optional<Depot> findDepotById(DepotId id);

    @Query("SELECT d FROM Depot d WHERE :postalCodeDigit BETWEEN d.fromPostalCodeFirstDigit AND d.toPostalCodeFirstDigit")
    List<Depot> findSuitableDepots(@Param("postalCodeDigit") Integer postalCodeDigit);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\StockLevel.java ---
package thkoeln.archilab.ecommerce.solution.depot.domain;

import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import lombok.*;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

@Getter
@Entity
@AllArgsConstructor
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class StockLevel {

    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private StockLevelId id;

    @Setter
    private Integer quantity;

    @Setter
    //@ManyToOne
    private ProductId productId;

    public StockLevel(ProductId productId, Integer quantity) {
        this.id = new StockLevelId();
        this.productId = productId;
        this.quantity = quantity;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\StockLevelId.java ---
package thkoeln.archilab.ecommerce.solution.depot.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "stock_level_id"))
public class StockLevelId extends GenericId {
    public StockLevelId( UUID id ) {
        super( id );
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\StockLevelIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.depot.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class StockLevelIdConverter extends GenericIdConverter<StockLevelId> {
    public StockLevelIdConverter() {
        super(StockLevelId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\DepotableServiceInterface.java ---
package thkoeln.archilab.ecommerce.solution.product.application;

import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

public interface DepotableServiceInterface {
    public boolean existsProductInDepotByProductId(ProductId productId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.product.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

import java.util.UUID;

@Service
public class ProductAdapterService implements ProductCatalogUseCases {
    private final ProductService productService;
    private final RemoveAdapterService removeAdapterService;

    @Autowired
    public ProductAdapterService(
            ProductService productService,
            RemoveAdapterService removeAdapterService) {
        this.productService = productService;
        this.removeAdapterService = removeAdapterService;
    }

    @Override
    public UUID addProductToCatalog(String name, String descriptFor, Float size, CurrencyType buyingPrice, CurrencyType salesPrice) {
        if(buyingPrice == null) throw new ShopException("buyingPrice is null");
        if(salesPrice == null) throw new ShopException("salesPrice is null");

        Currency newBuyingPrice = (Currency) buyingPrice;
        Currency newSalesPrice = (Currency) salesPrice;

        ProductId productId = productService.addProductToCatalog(
                name,
                descriptFor,
                size,
                newBuyingPrice,
                newSalesPrice
        );
        return productId.getId();
    }

    @Override
    public void removeProductFromCatalog(UUID productId) {
        ProductId newProductId = new ProductId(productId);
        removeAdapterService.removeProductFromCatalog(newProductId);
    }

    @Override
    public Currency getSalesPrice(UUID productId) {
        ProductId newProductId = new ProductId(productId);
        return productService.getSalesPrice(newProductId);
    }

    @Override
    public void deleteProductCatalog() {
        productService.deleteProductCatalog();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductService.java ---
package thkoeln.archilab.ecommerce.solution.product.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;

import java.util.Optional;

@Service
public class ProductService {
    private final ProductRepository productRepository;

    public ProductService(
            ProductRepository productRepository
    )
    {
        this.productRepository = productRepository;
    }

    public ProductId addProductToCatalog(String name, String descriptFor, Float size, Currency buyingPrice, Currency salesPrice) {
        validateProductName(name);
        validateProductDescription(descriptFor);
        validateProductSize(size);
        validateProductBuyingAndSalesPrice(buyingPrice, salesPrice);

        Product product = new Product(name, descriptFor, size, buyingPrice, salesPrice);

        productRepository.save(product);
        return product.getId();
    }

    public void removeProductFromCatalog(ProductId productId) {
        validateProductId(productId);
        productRepository.deleteById(productId);
    }


    public Currency getSalesPrice(ProductId productId) {
        validateProductId(productId);

        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new ShopException("Product with id " + productId + " does not exist"));

        return product.getSalesPrice();
    }

    public void deleteProductCatalog() {
        productRepository.deleteAll();
    }

    // EXISTS

    public boolean existsProductByProductId(ProductId productId) {
        return productRepository.existsById(productId);
    }

    // FIND

    public Optional<Product> findProductById(ProductId productId) {
        return productRepository.findById(productId);
    }

    // VALIDATE

    public void validateProductId(ProductId productId) {
        if(productId == null) {
            throw new ShopException("Product ID cannot be null or empty.");
        }
    }
    public void validateProductName(String productName) {
        if(productName == null || productName.isEmpty()) {
            throw new ShopException("Product name cannot be null or empty.");
        }
    }
    public void validateProductDescription(String productDescription) {
        if(productDescription == null || productDescription.isEmpty()) {
            throw new ShopException("Product description cannot be null or empty.");
        }
    }
    public void validateProductSize(Float productSize) {
        if (productSize != null && productSize <= 0) {
            throw new ShopException("Product size cannot be zero or negative.");
        }
    }
    public void validateProductBuyingAndSalesPrice(Currency buyingPrice, Currency salesPrice) {
        if(buyingPrice.largerThan(salesPrice)){
            throw new ShopException("Product sales price cannot be greater than salesPrice.");
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\PurchasableServiceInterface.java ---
package thkoeln.archilab.ecommerce.solution.product.application;


import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

public interface PurchasableServiceInterface {
    public boolean existsProductInPurchaseByProductId(ProductId productId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\RemoveAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.product.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

@Service
public class RemoveAdapterService {
    private final ProductService productService;
    private final DepotableServiceInterface depotableServiceInterface;
    private final PurchasableServiceInterface purchasableServiceInterface;

    @Autowired
    public RemoveAdapterService(
            ProductService productService,
            DepotableServiceInterface depotableServiceInterface,
            PurchasableServiceInterface purchasableServiceInterface
    ) {
        this.productService = productService;
        this.depotableServiceInterface = depotableServiceInterface;
        this.purchasableServiceInterface = purchasableServiceInterface;
    }

    public void removeProductFromCatalog(ProductId productId) {
        if(!productService.existsProductByProductId(productId)) throw new ShopException("Product with id " + productId + " does not exist");
        if(depotableServiceInterface.existsProductInDepotByProductId(productId)) throw new ShopException("Product with id " + productId + " exists in depot");
        if(purchasableServiceInterface.existsProductInPurchaseByProductId(productId)) throw new ShopException("Product with id " + productId + "exists in purchase");

        productService.removeProductFromCatalog(productId);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\exceptions\ProductNotFoundException.java ---
package thkoeln.archilab.ecommerce.solution.product.domain.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Product not found")
public class ProductNotFoundException extends ShopException {
    public ProductNotFoundException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\Product.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import jakarta.persistence.*;
import lombok.*;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;

@Getter
@Entity
@AllArgsConstructor
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Product {

    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private ProductId id;

    @Setter
    private String name;

    @Setter
    private String description;

    @Setter
    private Float size;

    @Setter
    @AttributeOverrides({
            @AttributeOverride(name = "amount", column = @Column(name = "buying_price_amount")),
            @AttributeOverride(name = "currencyUnit", column = @Column(name = "buying_price_currency"))
    })
    private Currency buyingPrice;

    @Setter
    @AttributeOverrides({
            @AttributeOverride(name = "amount", column = @Column(name = "sales_price_amount")),
            @AttributeOverride(name = "currencyUnit", column = @Column(name = "sales_price_currency"))
    })
    private Currency salesPrice;

    public Product(String name, String description, Float size, Currency buyingPrice, Currency salesPrice) {
        this.id = new ProductId();
        this.name = name;
        this.description = description;
        this.size = size;
        this.buyingPrice = buyingPrice;
        this.salesPrice = salesPrice;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductId.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "product_id"))
public class ProductId extends GenericId {
    public ProductId( UUID id ) {
        super( id );
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ProductIdConverter extends GenericIdConverter<ProductId> {
    public ProductIdConverter() {
        super(ProductId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductRepository.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ProductRepository extends CrudRepository<Product, ProductId> {
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchasableService.java ---
package thkoeln.archilab.ecommerce.solution.purchase.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.product.application.PurchasableServiceInterface;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

@Service
public class PurchasableService implements PurchasableServiceInterface {
    private final PurchaseService purchaseService;

    public PurchasableService(PurchaseService purchaseService) {
        this.purchaseService = purchaseService;
    }

    @Override
    public boolean existsProductInPurchaseByProductId(ProductId productId) {
        return purchaseService.existsProductInPurchaseByProductId(productId);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.purchase.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
import thkoeln.archilab.ecommerce.usecases.PurchaseUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Service
public class PurchaseAdapterService implements PurchaseUseCases {

    private final PurchaseService purchaseService;

    public PurchaseAdapterService(
            PurchaseService purchaseService
    ) {
        this.purchaseService = purchaseService;
    }

    @Override
    public Map<UUID, Integer> getPurchaseHistory(EmailAddressType userEmailAddress) {
        EmailAddress emailAddress = (EmailAddress) userEmailAddress;
        Map<ProductId, Integer> purchaseHistoryWithProductId = purchaseService.getPurchaseHistory(emailAddress);
        Map<UUID, Integer> purchaseHistoryWithUUID = new HashMap<>();

        for (Map.Entry<ProductId, Integer> entry : purchaseHistoryWithProductId.entrySet()) {
            UUID productUUID = entry.getKey().getId(); // Annahme: ProductId hat getId()
            Integer quantity = entry.getValue();
            purchaseHistoryWithUUID.put(productUUID, quantity);
        }

        return purchaseHistoryWithUUID;
    }

    @Override
    public Integer getPurchaseQuantOfProduct(UUID purchaseId, UUID productId) {
        PurchaseId newPurchaseId = new PurchaseId(purchaseId);
        ProductId newProductId = new ProductId(productId);
        return purchaseService.getPurchaseQuantOfProduct(newPurchaseId, newProductId);
    }

    @Override
    public UUID getDepotIdForPurchase(UUID purchaseId) {
        PurchaseId newPurchaseId = new PurchaseId(purchaseId);
        return purchaseService.getDepotIdForPurchase(newPurchaseId);
    }

    @Override
    public void deleteAllPurchases() {
        purchaseService.deleteAllPurchases();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseDTO.java ---
package thkoeln.archilab.ecommerce.solution.purchase.application;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.List;
import java.util.UUID;

@Setter
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class PurchaseDTO {
    private UUID id;
    private String userName;
    private UUID depotId;
    private List<PurchasePositionDTO> positions;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchasePositionDTO.java ---
package thkoeln.archilab.ecommerce.solution.purchase.application;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.UUID;

@Setter
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class PurchasePositionDTO {
    private UUID productId;
    private Integer quantity;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseService.java ---
package thkoeln.archilab.ecommerce.solution.purchase.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchasePosition;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;
import thkoeln.archilab.ecommerce.solution.user.application.UserService;
import thkoeln.archilab.ecommerce.solution.user.domain.User;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@Service
public class PurchaseService {
    private final PurchaseRepository purchaseRepository;
    private final UserService userService;

    public PurchaseService(PurchaseRepository purchaseRepository, UserService userService) {
        this.purchaseRepository = purchaseRepository;
        this.userService = userService;
    }

    public Map<ProductId, Integer> getPurchaseHistory(EmailAddress userEmailAddress) {
        if(userEmailAddress == null) throw new ShopException("User not found");

        User user = userService.findUserByEmailAddress(userEmailAddress)
                .orElseThrow(() -> new ShopException("User not found"));
        UserId userId = user.getId();

        List<Purchase> purchases = purchaseRepository.findByUserId(userId);

        Map<ProductId, Integer> purchaseHistory = new HashMap<>();
        for (Purchase purchase : purchases) {
            for (PurchasePosition position : purchase.getPurchasePositions()) {
                ProductId productId = position.getProductId();
                int quantity = position.getQuantity();

                purchaseHistory.put(
                        productId,
                        purchaseHistory.getOrDefault(productId, 0) + quantity
                );
            }
        }

        return purchaseHistory;
    }

    public void deleteAllPurchases() {
        purchaseRepository.deleteAll();
    }

    public boolean existsProductInPurchaseByProductId(ProductId productId) {
        for (Purchase purchase : purchaseRepository.findAll()) {
            if (purchase.findPurchasePositionByProductId(productId).isPresent()) {
                return true;
            }
        }
        return false;
    }

    public Integer getPurchaseQuantOfProduct(PurchaseId purchaseId, ProductId productId) {
        Purchase purchase = purchaseRepository.findById(purchaseId).orElseThrow(() -> new ShopException("Purchase not found"));
        PurchasePosition purchasePosition = purchase.findPurchasePositionByProductId(productId).orElseThrow(() -> new ShopException("Position not found"));
        return purchasePosition.getQuantity();
    }

    public UUID getDepotIdForPurchase(PurchaseId purchaseId) {
        Purchase purchase = purchaseRepository.findById(purchaseId).orElseThrow(() -> new ShopException("Purchase not found"));
        return purchase.getDepotId().getId();
    }

    public Purchase getPurchaseById(PurchaseId purchaseId){
        return purchaseRepository.findById(purchaseId)
                .orElseThrow(() -> new ShopException("Purchase not found"));
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\exceptions\PurchaseNotFoundException.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Product not found")
public class PurchaseNotFoundException extends ShopException {
    public PurchaseNotFoundException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\Purchase.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.*;
import lombok.*;
import thkoeln.archilab.ecommerce.solution.depot.domain.DepotId;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@Getter
@Entity
@AllArgsConstructor
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Purchase {

    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private PurchaseId id;

    @Setter
    private UserId userId;

    @Setter
    private DepotId depotId;

    @Setter
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
    List<PurchasePosition> purchasePositions = new ArrayList<>();

    public Purchase(UserId userId, DepotId depotId) {
        this.id = new PurchaseId();
        this.userId = userId;
        this.depotId = depotId;
    }

    public void addPurchasePosition(PurchasePosition purchasePosition) {
        purchasePositions.add(purchasePosition);
    }


    public Optional<PurchasePosition> findPurchasePositionByProductId(ProductId productId) {
        for (PurchasePosition purchasePosition : purchasePositions) {
            if (purchasePosition.getProductId().equals(productId)) {
                return Optional.of(purchasePosition);
            }
        }
        return Optional.empty();
    }

}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseId.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "purchase_id"))
public class PurchaseId extends GenericId {
    public PurchaseId( UUID id ) {
        super( id );
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class PurchaseIdConverter extends GenericIdConverter<PurchaseId> {
    public PurchaseIdConverter() {
        super(PurchaseId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePosition.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import lombok.*;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

@Entity
@Getter
@AllArgsConstructor
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class PurchasePosition {

    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private PurchasePositionId id;

    @Setter
    //@ManyToOne
    private ProductId productId;

    @Setter
    private Integer quantity;

    public PurchasePosition(ProductId productId, Integer quantity) {
        this.id = new PurchasePositionId();
        this.productId = productId;
        this.quantity = quantity;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePositionId.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "purchase_position_id"))
public class PurchasePositionId extends GenericId {
    public PurchasePositionId( UUID id ) {
        super( id );
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePositionIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class PurchasePositionIdConverter extends GenericIdConverter<PurchasePositionId> {
    public PurchasePositionIdConverter() {
        super(PurchasePositionId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseRepository.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.List;

@Repository
public interface PurchaseRepository extends CrudRepository<Purchase, PurchaseId> {
    List<Purchase> findByUserId(UserId userId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.*;

@Service
public class ShoppingAdapterService implements ShoppingBasketUseCases {

    private final ShoppingService shoppingService;

    public ShoppingAdapterService(
            ShoppingService shoppingService
    ) {
        this.shoppingService = shoppingService;
    }

    @Override
    public void addProductToShoppingBasket(EmailAddressType userEmailAddress, UUID productId, int quantOf) {
        if(userEmailAddress == null) throw new ShopException("Email address must not be null");

        ProductId newProductId = new ProductId(productId);
        shoppingService.addProductToShoppingBasket(userEmailAddress, newProductId, quantOf);
    }

    @Override
    public void removeProductFromShoppingBasket(EmailAddressType userEmailAddress, UUID productId, int quantOf) {
        if(userEmailAddress == null) throw new ShopException("Email address must not be null");

        ProductId newProductId = new ProductId(productId);
        shoppingService.removeProductFromShoppingBasket(userEmailAddress, newProductId, quantOf);
    }

    @Override
    public Map<UUID, Integer> getShoppingBasketAsMap(EmailAddressType userEmailAddress) {
        if(userEmailAddress == null) throw new ShopException("Email address must not be null");

        Map<ProductId, Integer> basketWithProductId = shoppingService.getShoppingBasketAsMap(userEmailAddress);
        Map<UUID, Integer> basketWithUUID = new HashMap<>();

        for (Map.Entry<ProductId, Integer> entry : basketWithProductId.entrySet()) {
            UUID productUUID = entry.getKey().getId(); // get UUID from ProductId
            Integer quantity = entry.getValue();
            basketWithUUID.put(productUUID, quantity);
        }

        return basketWithUUID;
    }


    @Override
    public CurrencyType getShoppingBasketAsCurrencyValue(EmailAddressType userEmailAddress) {
        if(userEmailAddress == null) throw new ShopException("Email address must not be null");
        EmailAddress newEmailAddress = (EmailAddress) userEmailAddress;
        return shoppingService.getShoppingBasketAsCurrencyValue(newEmailAddress);
    }

    @Override
    public Set<UUID> checkout(EmailAddressType userEmailAddress) {
        if (userEmailAddress == null) throw new ShopException("Email address must not be null");
        EmailAddress newEmailAddress = (EmailAddress) userEmailAddress;
        Set<UUID> newSet = shoppingService.checkout(newEmailAddress);
        return newSet;
    }


    @Override
    public void emptyAllShoppingBaskets() {
        shoppingService.emptyAllShoppingBaskets();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingApplicationService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.exceptions.ShoppingBasketNotFoundException;
import thkoeln.archilab.ecommerce.solution.product.application.ProductService;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketId;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
public class ShoppingApplicationService {

    private final ProductService productService;
    private ShoppingBasketRepository shoppingBasketRepository;

    @Autowired
    public ShoppingApplicationService(
            ShoppingBasketRepository shoppingBasketRepository,
            ProductService productService, ShoppingService shoppingService) {
        this.shoppingBasketRepository = shoppingBasketRepository;
        this.productService = productService;
    }

    public Optional<ShoppingBasket> findByUserId(UserId userId){
        return shoppingBasketRepository.findShoppingBasketByUserId(userId);
    }

    public Currency calculateTotalSalesPrice (List<ShoppingBasketPosition> positions){
        Float sumSalesPrice = 0.0f;
        String unit = "EUR";
        for(ShoppingBasketPosition position : positions){
            ProductId productId = position.getProductId();
            Currency salesPrice = productService.getSalesPrice(productId);
            sumSalesPrice += salesPrice.getAmount() * position.getQuantity();
            unit = salesPrice.getCurrencyUnit();
        }
        return Currency.of(sumSalesPrice, unit);
    }

    public void addPositionToBasket(
            UUID shoppingBasketId,
            ShoppingBasketPositionDTO shoppingBasketPositionDTO
    ){
        ProductId productId = new ProductId(shoppingBasketPositionDTO.getProductId());
        ShoppingBasketId newShoppingBasketId = new ShoppingBasketId(shoppingBasketId);

        ShoppingBasket shoppingBasket = shoppingBasketRepository.getShoppingBasketById(newShoppingBasketId)
                .orElseThrow(()-> new ShoppingBasketNotFoundException("Shopping Basket with id: " + shoppingBasketId+ "not found!"));

        ShoppingBasketPosition shoppingBasketPosition = new ShoppingBasketPosition(
                productId,
                shoppingBasketPositionDTO.getQuantity()
        );

        shoppingBasket.addPosition(shoppingBasketPosition);
        shoppingBasketRepository.save(shoppingBasket);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import jakarta.transaction.Transactional;
import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.*;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.product.domain.exceptions.ProductNotFoundException;
import thkoeln.archilab.ecommerce.solution.purchase.application.PurchaseDTO;
import thkoeln.archilab.ecommerce.solution.purchase.application.PurchasePositionDTO;
import thkoeln.archilab.ecommerce.solution.purchase.application.PurchaseService;
import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchasePosition;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketId;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.exceptions.ShoppingBasketNotFoundException;
import thkoeln.archilab.ecommerce.solution.user.application.UserService;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
import thkoeln.archilab.ecommerce.solution.user.domain.exceptions.UserNotFoundException;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.UUID;

@RestController
@Transactional
@RequestMapping("/shoppingBaskets")
public class ShoppingBasketController {

    private final ShoppingApplicationService shoppingBasketApplicationService;
    private final ModelMapper modelMapper = new ModelMapper();
    private final ShoppingService shoppingService;
    private final UserService userService;
    private final PurchaseService purchaseService;

    @Autowired
    public ShoppingBasketController(
            ShoppingApplicationService shoppingBasketApplicationService,
            ShoppingService shoppingService, UserService userService, PurchaseService purchaseService) {
        this.shoppingBasketApplicationService = shoppingBasketApplicationService;
        this.shoppingService = shoppingService;
        this.userService = userService;
        this.purchaseService = purchaseService;
    }

    /**
     * GET /shoppingBaskets — Zugriff auf alle ShoppingBaskets ist verboten
     */
    @GetMapping
    public ResponseEntity<Void> getAllShoppingBaskets() {
        throw new MethodNotAllowedException("Access to all users is forbidden. Use specific userId.");
    }

    @GetMapping("/{id}")
    public ResponseEntity<ShoppingBasketDTO> getOneShoppingBasketById(
            @PathVariable("id") String shoppingBasketIdStr
    ) {
        UUID shoppingBasketId;
        try {
            shoppingBasketId = UUID.fromString(shoppingBasketIdStr);
        } catch (IllegalArgumentException ex) {
            throw new ShoppingBasketNotFoundException("Invalid UUID format.");
        }
        ShoppingBasketId shoppingBasketId1 = new ShoppingBasketId(shoppingBasketId);
        ShoppingBasket shoppingBasket = shoppingService.findById(shoppingBasketId1)
                .orElseThrow(()->new ShoppingBasketNotFoundException("Shopping Basket with id: " +shoppingBasketId+ "not found!"));

        ShoppingBasketDTO dto = modelMapper.map(shoppingBasket, ShoppingBasketDTO.class);

        return ResponseEntity.ok(dto);
    }

    @GetMapping(params = "userId")
    public ResponseEntity<ShoppingBasketDTO> getShoppingBasketByUserId(
            @RequestParam("userId") String userIdStr
    ) {
        UUID userId;
        try {
            userId = UUID.fromString(userIdStr);
        } catch (IllegalArgumentException ex) {
            throw new ShoppingBasketNotFoundException("Invalid UUID format.");
        }
        UserId newUserId = new UserId(userId);
        if(!userService.existsUserById(newUserId)) throw new UserNotFoundException("User with id:" +userId+ "not found!");

        ShoppingBasket shoppingBasket = shoppingService.getShoppingBasketByUserId(newUserId);
        ShoppingBasketId shoppingBasketId = shoppingBasket.getId();

        List<ShoppingBasketPosition> positions = shoppingBasket.getShoppingBasketPositions();
        List<ShoppingBasketPositionDTO> positionsDtos = new ArrayList<>();
        for(ShoppingBasketPosition position : positions){
            positionsDtos.add(modelMapper.map(position, ShoppingBasketPositionDTO.class));
        }
        String totalSalesPrice = shoppingBasketApplicationService.calculateTotalSalesPrice(positions).toString();

        ShoppingBasketDTO dto = new ShoppingBasketDTO();
        dto.setId(shoppingBasketId.getId());
        dto.setUserId(newUserId.getId());
        dto.setTotalSalesPrice(totalSalesPrice);
        dto.setPositions(positionsDtos);

        return ResponseEntity.ok(dto);
    }

    @PostMapping("/{shoppingBasketId}/positions")
    public ResponseEntity postShoppingBasketPosition(
            @PathVariable UUID shoppingBasketId,
            @RequestBody ShoppingBasketPositionDTO shoppingBasketPositionDTO
    ) {
        shoppingService.addProductToShoppingBasket(shoppingBasketId, shoppingBasketPositionDTO);
        return new ResponseEntity( HttpStatus.CREATED );
    }

    @DeleteMapping("/{shoppingBasketIdStr}/positions/{productIdStr}")
    public ResponseEntity deleteOneUser(
            @PathVariable String shoppingBasketIdStr,
            @PathVariable String productIdStr
    ) {
        ShoppingBasketId shoppingBasketId;
        ProductId productId;
        try {
            shoppingBasketId = new ShoppingBasketId(UUID.fromString(shoppingBasketIdStr));
        } catch (IllegalArgumentException ex) {
            throw new ShoppingBasketNotFoundException("Invalid UUID format.");
        }
        try {
            productId = new ProductId(UUID.fromString(productIdStr));
        } catch (IllegalArgumentException ex) {
            throw new ProductNotFoundException("Invalid UUID format.");
        }

        shoppingService.removeProductFromShoppingBasket(shoppingBasketId, productId);
        return new ResponseEntity(HttpStatus.OK);
    }

    @PostMapping("/{shoppingBasketIdStr}/checkout")
    public ResponseEntity<List<PurchaseDTO>> postShoppingBasketPosition(
            @PathVariable String shoppingBasketIdStr
    ) {
        ShoppingBasketId shoppingBasketId;
        try {
            shoppingBasketId = new ShoppingBasketId(UUID.fromString(shoppingBasketIdStr));
        } catch (IllegalArgumentException ex) {
            throw new ShoppingBasketNotFoundException("Invalid UUID format.");
        }

        Set<UUID> purchases = shoppingService.checkout(shoppingBasketId);

        List<PurchaseDTO> purchaseDtos = new ArrayList<>();
        for(UUID purchaseId : purchases){
            PurchaseDTO dto = new PurchaseDTO();
            Purchase purchase = purchaseService.getPurchaseById(new PurchaseId(purchaseId));
            dto.setId(purchaseId);
            dto.setDepotId(purchase.getDepotId().getId());
            dto.setUserName(userService.getUserNameById(purchase.getUserId()));

            List<PurchasePositionDTO> purchasePositionDTOS = new ArrayList<>();
            for(PurchasePosition purchasePosition : purchase.getPurchasePositions()){
                purchasePositionDTOS.add(modelMapper.map(purchasePosition, PurchasePositionDTO.class));
            }
            dto.setPositions(purchasePositionDTOS);
        }

        return ResponseEntity.status(HttpStatus.CREATED).body(purchaseDtos);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;

import java.util.List;
import java.util.UUID;

@Setter
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class ShoppingBasketDTO {
    private UUID id;
    private String totalSalesPrice;
    private List<ShoppingBasketPositionDTO> positions;
    private UUID userId;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketPositionDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.UUID;

@Setter
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class ShoppingBasketPositionDTO {
    private UUID productId;
    private Integer quantity;

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.InsufficientStockException;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.*;
import thkoeln.archilab.ecommerce.solution.depot.application.DepotService;
import thkoeln.archilab.ecommerce.solution.depot.domain.Depot;
import thkoeln.archilab.ecommerce.solution.depot.domain.DepotComparator;
import thkoeln.archilab.ecommerce.solution.product.application.ProductService;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.product.domain.exceptions.ProductNotFoundException;
import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchasePosition;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketId;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.exceptions.ShoppingBasketNotFoundException;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.exceptions.ShoppingBasketPositionNotFoundException;
import thkoeln.archilab.ecommerce.solution.user.application.UserService;
import thkoeln.archilab.ecommerce.solution.user.domain.User;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
import thkoeln.archilab.ecommerce.solution.user.domain.exceptions.UserNotFoundException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.*;

@Service
public class ShoppingService {

    private final UserService userService;
    private final ProductService productService;
    private final ShoppingBasketRepository shoppingBasketRepository;
    private final DepotService depotService;
    private final PurchaseRepository purchaseRepository;

    public ShoppingService(
            UserService userService,
            ProductService productService,
            ShoppingBasketRepository shoppingBasketRepository,
            DepotService depotService,
            PurchaseRepository purchaseRepository
    ) {
        this.userService = userService;
        this.productService = productService;
        this.shoppingBasketRepository = shoppingBasketRepository;
        this.depotService = depotService;
        this.purchaseRepository = purchaseRepository;
    }

    public ShoppingBasket getShoppingBasketByUserId(UserId userId){
        if(userId == null) throw new UserNotFoundException("User Not Found");

        ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketByUserId(userId)
                .orElseGet(() -> new ShoppingBasket(userId));
        shoppingBasketRepository.save(shoppingBasket);

        return shoppingBasket;
    }

    public void addProductToShoppingBasket(EmailAddressType userEmailAddress, ProductId productId, int quantOf) {
        if(quantOf == 0) return;

        nullThrow(List.of(userEmailAddress));

        productService.validateProductId(productId);
        validateQuantity(quantOf);

        if(!productService.existsProductByProductId(productId)) throw new ShopException("Product does not exist");

        EmailAddress emailAddress = (EmailAddress) userEmailAddress;
        User user = userService.findUserByEmailAddress(emailAddress)
                .orElseThrow(() -> new ShopException("User not found"));
        UserId userId = user.getId();

        ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketByUserId(userId)
                .orElseGet(() -> new ShoppingBasket(userId));

        ShoppingBasketPosition shoppingBasketPosition = shoppingBasket.findShoppingBasketPositionsByProductId(productId)
                .orElseGet(() -> null);

        if(shoppingBasketPosition == null) {
            shoppingBasketPosition = new ShoppingBasketPosition(productId, quantOf);
            shoppingBasket.getShoppingBasketPositions().add(shoppingBasketPosition);
        }
        else {
            int oldQuantity = shoppingBasketPosition.getQuantity();
            int newQuantity = oldQuantity + quantOf;
            shoppingBasketPosition.setQuantity(newQuantity);
        }
        shoppingBasketRepository.save(shoppingBasket);
    }

    public void addProductToShoppingBasket(UUID shoppingBasketId1, ShoppingBasketPositionDTO shoppingBasketPositionDTO) {
        int quantOf = shoppingBasketPositionDTO.getQuantity();
        ProductId productId = new ProductId(shoppingBasketPositionDTO.getProductId());
        ShoppingBasketId shoppingBasketId = new ShoppingBasketId(shoppingBasketId1);

        if(quantOf == 0) return;

        productService.validateProductId(productId);
        validateQuantity(quantOf);

        if(!productService.existsProductByProductId(productId)) throw new ProductNotFoundException("Product does not exist");

        ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketById(shoppingBasketId)
                .orElseThrow(() -> new ShoppingBasketNotFoundException("Shopping Basket not found"));

        ShoppingBasketPosition shoppingBasketPosition = shoppingBasket.findShoppingBasketPositionsByProductId(productId)
                .orElseGet(() -> null);

        if(shoppingBasketPosition == null) {
            shoppingBasketPosition = new ShoppingBasketPosition(productId, quantOf);
            shoppingBasket.getShoppingBasketPositions().add(shoppingBasketPosition);
        }
        else {
            int oldQuantity = shoppingBasketPosition.getQuantity();
            int newQuantity = oldQuantity + quantOf;
            shoppingBasketPosition.setQuantity(newQuantity);
        }
        shoppingBasketRepository.save(shoppingBasket);
    }

    public void removeProductFromShoppingBasket(EmailAddressType userEmailAddress, ProductId productId, int quantOf) {
        productService.validateProductId(productId);
        validateQuantity(quantOf);

        if(!productService.existsProductByProductId(productId)) throw new ShopException("Product does not exist");

        EmailAddress emailAddress = (EmailAddress) userEmailAddress;
        User user = userService.findUserByEmailAddress(emailAddress)
                .orElseThrow(() -> new ShopException("User not found"));
        UserId userId = user.getId();

        ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketByUserId(userId)
                .orElseThrow(() -> new ShopException("Shopping basket not found"));

        ShoppingBasketPosition shoppingBasketPosition = shoppingBasket.findShoppingBasketPositionsByProductId(productId)
                .orElseThrow(() -> new ShopException("Shopping basket does not exist"));

        int oldQuantity = shoppingBasketPosition.getQuantity();

        if(oldQuantity - quantOf < 0) throw new ShopException("Quantity is too big");
        else if (oldQuantity - quantOf == 0) {
            shoppingBasket.removePosition(shoppingBasketPosition);
        }
        else {
            shoppingBasketPosition.setQuantity(oldQuantity - quantOf);
        }
        shoppingBasketRepository.save(shoppingBasket);
    }
    public void removeProductFromShoppingBasket(ShoppingBasketId shoppingBasketId, ProductId productId) {
        productService.validateProductId(productId);

        if(!productService.existsProductByProductId(productId)) throw new ProductNotFoundException("Product does not exist");

        ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketById(shoppingBasketId)
                .orElseThrow(() -> new ShoppingBasketNotFoundException("Shopping basket not found"));

        ShoppingBasketPosition shoppingBasketPosition = shoppingBasket.findShoppingBasketPositionsByProductId(productId)
                .orElseThrow(() -> new ShoppingBasketPositionNotFoundException("Shopping basket does not exist"));

        shoppingBasket.removePosition(shoppingBasketPosition);
        shoppingBasketRepository.save(shoppingBasket);
    }

    public Map<ProductId, Integer> getShoppingBasketAsMap(EmailAddressType userEmailAddress) {

        EmailAddress emailAddress = (EmailAddress) userEmailAddress;
        User user = userService.findUserByEmailAddress(emailAddress)
                .orElseThrow(() -> new ShopException("User not found"));
        UserId userId = user.getId();

        ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketByUserId(userId)
                .orElseThrow(() -> new ShopException("Shopping basket not found"));

        Map<ProductId, Integer> basketMap = new HashMap<>();
        for (ShoppingBasketPosition position : shoppingBasket.getShoppingBasketPositions()) {
            ProductId productId = position.getProductId();
            int quantity = position.getQuantity();
            basketMap.put(productId, basketMap.getOrDefault(productId, 0) + quantity);
        }

        return basketMap;
    }

    public CurrencyType getShoppingBasketAsCurrencyValue(EmailAddress userEmailAddress) {

        EmailAddress emailAddress = (EmailAddress) userEmailAddress;
        User user = userService.findUserByEmailAddress(emailAddress)
                .orElseThrow(() -> new ShopException("User not found"));
        UserId userId = user.getId();

        ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketByUserId(userId)
                .orElseGet(() -> null);
        if (shoppingBasket == null) return Currency.of(0.0f, "EUR");

        float sum = 0f;
        for(ShoppingBasketPosition position : shoppingBasket.getShoppingBasketPositions()) {
            int quantity = position.getQuantity();

            Product product = productService.findProductById(position.getProductId())
                    .orElseThrow(() -> new ShopException("Product not found"));

            sum += quantity * product.getSalesPrice().getAmount();
        }

        return Currency.of(sum, "EUR");
    }

    public Set<UUID> checkout(EmailAddress userEmailAddress) {
        nullThrow(List.of(userEmailAddress));

        EmailAddress emailAddress = (EmailAddress) userEmailAddress;

        User user = userService.findUserByEmailAddress(emailAddress).orElseThrow(() -> new ShopException("User not found"));
        UserId userId = user.getId();

        ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketByUserId(userId).orElseThrow(() -> new ShopException("Shopping basket not found"));
        if (shoppingBasket.getShoppingBasketPositions().isEmpty()) throw new ShopException("Shopping basket is empty");

        List<Depot> depots = depotService.getAllDepots();
        PhysicalAddress userAddress = user.getPhysicalAddress();

        Map<ProductId, Integer> shoppingBasketMap = new HashMap<>();
        for (ShoppingBasketPosition position : shoppingBasket.getShoppingBasketPositions()) {
            shoppingBasketMap.put(position.getProductId(), position.getQuantity());
        }

        Set<UUID> createdPurchaseIds = new HashSet<>();

        Set<ProductId> allFulfilledProductIds = new HashSet<>();

        while (!shoppingBasketMap.isEmpty()) {
            depots.sort(new DepotComparator(shoppingBasketMap, userAddress));
            Depot bestDepot = depots.get(0);
            Set<ProductId> fulfillableProducts = bestDepot.fulfillableShoppingBasketPositions(shoppingBasketMap);

            if (fulfillableProducts.isEmpty()) throw new InsufficientStockException("No depot can fulfill the remaining shopping basket items");

            Purchase purchase = createAndPersistPurchase(user.getId(), bestDepot, fulfillableProducts, shoppingBasketMap, createdPurchaseIds);
            allFulfilledProductIds.addAll(fulfillableProducts);
        }

        updateShoppingBasket(shoppingBasket, allFulfilledProductIds);

        return createdPurchaseIds;
    }
    public Set<UUID> checkout(ShoppingBasketId shoppingBasketId) {

        ShoppingBasket shoppingBasket = shoppingBasketRepository.findShoppingBasketById(shoppingBasketId)
                .orElseThrow(() -> new ShoppingBasketNotFoundException("Shopping basket not found"));
        if (shoppingBasket.getShoppingBasketPositions().isEmpty()) throw new ConflictException("Shopping basket is empty");

        List<Depot> depots = depotService.getAllDepots();
        User user = userService.findUserById(shoppingBasket.getUserId())
                .orElseThrow(()-> new UserNotFoundException("User not found!"));

        PhysicalAddress userAddress = user.getPhysicalAddress();

        Map<ProductId, Integer> shoppingBasketMap = new HashMap<>();
        for (ShoppingBasketPosition position : shoppingBasket.getShoppingBasketPositions()) {
            shoppingBasketMap.put(position.getProductId(), position.getQuantity());
        }

        Set<UUID> createdPurchaseIds = new HashSet<>();

        Set<ProductId> allFulfilledProductIds = new HashSet<>();

        while (!shoppingBasketMap.isEmpty()) {
            depots.sort(new DepotComparator(shoppingBasketMap, userAddress));
            Depot bestDepot = depots.get(0);
            Set<ProductId> fulfillableProducts = bestDepot.fulfillableShoppingBasketPositions(shoppingBasketMap);

            if (fulfillableProducts.isEmpty()) throw new ConflictException("No depot can fulfill the remaining shopping basket items");

            Purchase purchase = createAndPersistPurchase(user.getId(), bestDepot, fulfillableProducts, shoppingBasketMap, createdPurchaseIds);
            allFulfilledProductIds.addAll(fulfillableProducts);
        }

        updateShoppingBasket(shoppingBasket, allFulfilledProductIds);

        return createdPurchaseIds;
    }

    private Purchase createAndPersistPurchase(UserId userId, Depot depot, Set<ProductId> products,
                                              Map<ProductId, Integer> basketMap, Set<UUID> purchaseIds) {
        Purchase purchase = new Purchase(userId, depot.getId());

        for (ProductId productId : products) {
            int quantity = basketMap.get(productId);
            int availableStock = depotService.getAvailableStock(depot.getId(), productId);

            if (availableStock < quantity) {
                throw new ConflictException("Not enough stock in depot " + depot.getName());
            }

            depotService.removeFromStock(depot.getId(), productId, quantity);
            purchase.getPurchasePositions().add(new PurchasePosition(productId, quantity));
        }

        purchaseRepository.save(purchase);
        purchaseIds.add(purchase.getId().getId());

        for (ProductId productId : products) {
            basketMap.remove(productId);
        }

        return purchase;
    }

    private void updateShoppingBasket(ShoppingBasket shoppingBasket, Set<ProductId> fulfilledProductIds) {
        shoppingBasket.removePositions(fulfilledProductIds);
        shoppingBasketRepository.save(shoppingBasket);
    }


    public void emptyAllShoppingBaskets() {
        shoppingBasketRepository.deleteAll();
    }

    public Optional<ShoppingBasket> findById(ShoppingBasketId shoppingBasketId){
        return shoppingBasketRepository.findById(shoppingBasketId);
    }

    // VALIDATE
    public void validateQuantity(int quantity) {
        if(quantity < 0) {
            throw new UnprocessableEntityException("Quantity must be a positive number");
        }
    }

    // =====================================
    // INTERNAL VALIDATION
    // =====================================
    private void nullThrow(List<Object> values) {
        for (Object value : values) {
            if (value == null) {
                throw new ShopException("Ein übergebener Wert im UserService ist ungewollt null.");
            }
        }
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\exceptions\ShoppingBasketNotFoundException.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Shopping Basket not found")
public class ShoppingBasketNotFoundException extends ShopException {
    public ShoppingBasketNotFoundException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\exceptions\ShoppingBasketPositionNotFoundException.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Shopping Basket not found")
public class ShoppingBasketPositionNotFoundException extends ShopException {
    public ShoppingBasketPositionNotFoundException( String message ) {
        super( message );
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.*;
import lombok.*;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Set;

@Getter
@Entity
@AllArgsConstructor
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class ShoppingBasket {

    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private ShoppingBasketId id;

    @Setter
    private UserId userId;

    @Setter
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
    List<ShoppingBasketPosition> shoppingBasketPositions = new ArrayList<>();

    public ShoppingBasket(UserId userId) {
        this.id = new ShoppingBasketId();
        this.userId = userId;
    }

    public void removePosition(ShoppingBasketPosition position) {
        shoppingBasketPositions.remove(position);
    }

    public Optional<ShoppingBasketPosition> findShoppingBasketPositionsByProductId(ProductId productId) {
        for (ShoppingBasketPosition position : shoppingBasketPositions) {
            if (position.getProductId().equals(productId)) {
                return Optional.of(position);
            }
        }
        return Optional.empty();
    }

    public void removePositions(Set<ProductId> productIds) {
        shoppingBasketPositions.removeIf(position -> productIds.contains(position.getProductId()));
    }

    public void addPosition(ShoppingBasketPosition shoppingBasketPosition){
        shoppingBasketPositions.add(shoppingBasketPosition);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketId.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "shopping_basket_id"))
public class ShoppingBasketId extends GenericId {
    public ShoppingBasketId( UUID id ) {
        super( id );
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ShoppingBasketIdConverter extends GenericIdConverter<ShoppingBasketId> {
    public ShoppingBasketIdConverter() {
        super(ShoppingBasketId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import lombok.*;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

@Getter
@Entity
@AllArgsConstructor
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class ShoppingBasketPosition {

    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private ShoppingBasketPositionId id;

    @Setter
    private ProductId productId;

    @Setter
    private Integer quantity;

    public ShoppingBasketPosition(ProductId productId, Integer quantity) {
        this.id = new ShoppingBasketPositionId();
        this.productId = productId;
        this.quantity = quantity;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionId.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "shopping_basket_position_id"))
public class ShoppingBasketPositionId extends GenericId {
    public ShoppingBasketPositionId( UUID id ) {
        super( id );
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ShoppingBasketPositionIdConverter extends GenericIdConverter<ShoppingBasketPositionId> {
    public ShoppingBasketPositionIdConverter() {
        super(ShoppingBasketPositionId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketRepository.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.List;
import java.util.Optional;

@Repository
public interface ShoppingBasketRepository extends CrudRepository<ShoppingBasket, ShoppingBasketId> {
    Optional<ShoppingBasket> findShoppingBasketByUserId(UserId userId);
    Optional<ShoppingBasket> getShoppingBasketById(ShoppingBasketId id);

    Optional<ShoppingBasket> findShoppingBasketById(ShoppingBasketId shoppingBasketId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

@Service
public class UserAdapterService implements UserRegistrationUseCases {

    private final UserService userService;

    public UserAdapterService(UserService userService){
        this.userService = userService;
    }

    @Override
    public void register(String name, EmailAddressType emailAddress, PhysicalAddressType physicalAddress) {
        EmailAddress newEmailAddress = (EmailAddress) emailAddress;
        PhysicalAddress newPhysicalAddress = (PhysicalAddress) physicalAddress;
        userService.registerUser(name, newEmailAddress, newPhysicalAddress);
    }

    @Override
    public void changeAddress(EmailAddressType emailAddress, PhysicalAddressType physicalAddress ) {
        EmailAddress newEmailAddress = (EmailAddress) emailAddress;
        PhysicalAddress newPhysicalAddress = (PhysicalAddress) physicalAddress;
        userService.updateUserAddressByEmailAddress(newEmailAddress, newPhysicalAddress);
    }

    @Override
    public UserType getUserData(EmailAddressType userEmailAddress) {
        EmailAddress newEmailAddress = (EmailAddress) userEmailAddress;
        return userService.getUserByEmailAddress(newEmailAddress);
    }

    @Override
    public void deleteAllUsers() {
        userService.deleteAllUsers();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserController.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import jakarta.transaction.Transactional;
import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.ConflictException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.MethodNotAllowedException;
import thkoeln.archilab.ecommerce.solution.user.domain.User;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
import thkoeln.archilab.ecommerce.solution.user.domain.exceptions.UserNotFoundException;

import java.util.UUID;

@RestController
@Transactional
@RequestMapping("/users")
public class UserController {

    private final ModelMapper modelMapper = new ModelMapper();
    private final UserService userService;

    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }

    /**
     * GET /users — Zugriff auf alle Benutzer ist verboten
     */
    @GetMapping
    public ResponseEntity<Void> getAllUsers() {
        throw new MethodNotAllowedException("Access to all users is forbidden. Use specific emailAddress.");
    }

    /**
     * GET /users/{id} — Benutzer per ID abrufen
     */
    @GetMapping("/{idStr}")
    public ResponseEntity<UserDTO> getUserById(@PathVariable String idStr) {

        // ─── 1. Konvertiere und validiere Parameter ───────────────────────────────
        UserId userId;
        try {
            userId = new UserId(UUID.fromString(idStr));
        } catch (IllegalArgumentException ex) {
            throw new UserNotFoundException("Invalid UUID format.");
        }

        // ─── 2. Führe die Business-Logik aus ──────────────────────────────────────
        User user = userService.getUserById(userId);

        // ─── 3. Wandle in DTO um ──────────────────────────────────────────────────
        UserDTO dto = modelMapper.map(user, UserDTO.class);

        // ─── 4. Rückgabe ──────────────────────────────────────────────────────────
        return ResponseEntity.ok(dto);
    }

    /**
     * GET /users?emailAddress=... — Benutzer per E-Mail abrufen
     */
    @GetMapping(params = "emailAddress")
    public ResponseEntity<UserDTO> getUserByEmailAddress(@RequestParam("emailAddress") String emailAddressStr) {

        // ─── 1. Konvertiere und validiere Parameter ───────────────────────────────
        EmailAddress emailAddress;
        try {
            emailAddress = EmailAddress.of(emailAddressStr);
        } catch (IllegalArgumentException ex) {
            throw new UserNotFoundException("Invalid emailAddress format.");
        }

        // ─── 2. Führe die Business-Logik aus ──────────────────────────────────────
        User user = userService.getUserByEmailAddress(emailAddress);

        // ─── 3. Wandle in DTO um ──────────────────────────────────────────────────
        UserDTO dto = modelMapper.map(user, UserDTO.class);

        // ─── 4. Rückgabe ──────────────────────────────────────────────────────────
        return ResponseEntity.ok(dto);
    }

    /**
     * DELETE /users/{id} — Benutzer löschen
     */
    @DeleteMapping("/{idStr}")
    public ResponseEntity<Void> deleteUser(@PathVariable String idStr) {

        // ─── 1. Konvertiere und validiere Parameter ───────────────────────────────
        UserId userId;
        try {
            userId = new UserId(UUID.fromString(idStr));
        } catch (IllegalArgumentException ex) {
            throw new UserNotFoundException("Invalid UUID format.");
        }

        // ─── 2. Führe die Business-Logik aus ──────────────────────────────────────
        userService.deleteUserById(userId);

        // ─── 3. Wandle in DTO um ──────────────────────────────────────────────────
        // ─── 4. Rückgabe ──────────────────────────────────────────────────────────
        return ResponseEntity.noContent().build();
    }

    /**
     * POST /users — Neuen Benutzer erstellen
     */
    @PostMapping
    public ResponseEntity<Void> createUser(@RequestBody UserDTO userDTO) {

        // ─── 1. Konvertiere und validiere Parameter ───────────────────────────────
        User user = UserDTOMapperHelper.mapUserDTOToUser(userDTO);

        // ─── 2. Führe die Business-Logik aus ──────────────────────────────────────
        User registeredUser = userService.registerUser(
                user.getName(),
                user.getEmailAddress(),
                user.getPhysicalAddress()
        );

        // ─── 3. Wandle in DTO um ──────────────────────────────────────────────────
        UserDTO createdUserDTO = modelMapper.map(registeredUser, UserDTO.class);

        // ─── 4. Rückgabe mit Status 201 Created ───────────────────────────────────
        /*return ResponseEntity
                .created(URI.create("/users/" + registeredUser.getId().toString()))
                .body(createdUserDTO);*/
        return new ResponseEntity<>(HttpStatus.CREATED);
    }

    /**
     * PATCH /users — User updaten via id
     */
    @PatchMapping(path = "/{idStr}")
    public ResponseEntity<Void> createUser(
            @PathVariable String idStr,
            @RequestBody UserDTO userDTO
    ) {

        // ─── 1. Konvertiere und validiere Parameter ───────────────────────────────
        UserId userId;
        try {
            userId = new UserId(UUID.fromString(idStr));
        } catch (IllegalArgumentException ex) {
            throw new UserNotFoundException("Invalid UUID format.");
        }

        User user = UserDTOMapperHelper.mapUserDTOToUser(userDTO);

        // ─── 2. Führe die Business-Logik aus ──────────────────────────────────────
        userService.updateUserById(userId, user);

        // ─── 3. Wandle in DTO um ──────────────────────────────────────────────────
        // ─── 4. Rückgabe mit Status 201 Created ───────────────────────────────────
        return new ResponseEntity<>(HttpStatus.OK);
    }

    // =====================================
    // VALIDATION
    // =====================================
    private void nullThrow(Object... values) {
        for (Object value : values) {
            if (value == null) {
                throw new ConflictException("Ein übergebener Wert im UserService ist ungewollt null.");
            }
        }
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserDTO.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import lombok.*;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;

import java.util.UUID;

@Setter
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class UserDTO {
    private UUID id;
    private EmailAddress emailAddress;
    private String name;
    private PhysicalAddress physicalAddress;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserDTOMapperHelper.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import org.modelmapper.ModelMapper;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.ConflictException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.UnprocessableEntityException;
import thkoeln.archilab.ecommerce.solution.user.domain.User;

public class UserDTOMapperHelper {
    static ModelMapper modelMapper = new ModelMapper();

    public static User mapUserDTOToUser(UserDTO userDTO){
        UserDTO validateUserDTO = UserDTOMapperHelper.validateUserDTO(userDTO);

        try {
            return modelMapper.map(validateUserDTO, User.class);
        } catch (Exception ex) {
            throw new ConflictException("Fehler bei Erstellung eines Users: " + ex.getMessage()); //409
        }
    }

    public static UserDTO validateUserDTO(UserDTO userDTO) {
        try {
            UserDTO validUserDTO = new UserDTO();

            // Name setzen, wenn vorhanden
            validUserDTO.setName(
                    userDTO.getName()
            );

            // EmailAddress setzen, wenn vorhanden
            if (userDTO.getEmailAddress() != null && userDTO.getEmailAddress().getEmail() != null) {
                String emailAddressStr = userDTO.getEmailAddress().getEmail();

                validUserDTO.setEmailAddress(
                        EmailAddress.of(emailAddressStr)
                );
            }

            // PhysicalAddress setzen, wenn vorhanden
            if (userDTO.getPhysicalAddress() != null) {
                String street = userDTO.getPhysicalAddress().getStreet();
                String city = userDTO.getPhysicalAddress().getCity();

                String postalCodeStr = userDTO.getPhysicalAddress().getPostalCode().toString();
                PostalCode postalCode = PostalCode.of(postalCodeStr);

                validUserDTO.setPhysicalAddress(
                        PhysicalAddress.of(street, city, postalCode)
                );
            }

            return validUserDTO;

        } catch (Exception ex) {
            throw new UnprocessableEntityException("Ungültige Userdaten: " + ex.getMessage()); //422
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserService.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.ConflictException;
import thkoeln.archilab.ecommerce.solution.user.domain.exceptions.UserNotFoundException;
import thkoeln.archilab.ecommerce.solution.user.domain.User;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;

import java.util.Optional;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    // =====================================
    // USER REGISTRATION & CREATION
    // =====================================

    public User registerUser(String name, EmailAddress emailAddress, PhysicalAddress physicalAddress) {
        nullThrow(name, emailAddress, physicalAddress);
        if(name.isBlank())
            throw new ConflictException("Der Name: " +name+ " ist nicht valide.");
        if (existsUserByEmailAddress(emailAddress))
            throw new ConflictException("Diese E-Mail-Adresse: " +emailAddress.getEmail()+ " wird bereits verwendet.");

        User newUser = new User(name, emailAddress, physicalAddress);
        userRepository.save(newUser);
        return newUser;
    }

    // =====================================
    // UPDATE
    // =====================================

    public void updateUserById(UserId oldUserId, User newUser){
        nullThrow(oldUserId, newUser);
        User oldUser = this.getUserById(oldUserId);
        this.updateUser(oldUser, newUser);
    }

    public void updateUser(User oldUser, User newUser) {
        nullThrow(oldUser, newUser);

        if (newUser.getName() != null) {
            oldUser.setName(newUser.getName());
        }
        if (newUser.getEmailAddress() != null) {
            oldUser.setEmailAddress(newUser.getEmailAddress());
        }
        if (newUser.getPhysicalAddress() != null) {
            oldUser.setPhysicalAddress(newUser.getPhysicalAddress());
        }
    }

    public void updateUserNameById(UserId userId, String name){
        nullThrow(userId, name);
        User user = getUserById(userId);
        updateUserName(user, name);
    }

    public void updateUserAddressByEmailAddress(EmailAddress emailAddress, PhysicalAddress newPhysicalAddress) {
        nullThrow(emailAddress, newPhysicalAddress);
        User user = getUserByEmailAddress(emailAddress);
        updateUserAddress(user, newPhysicalAddress);
    }

    public void updateUserAddress(User user, PhysicalAddress newPhysicalAddress){
        nullThrow(user, newPhysicalAddress);
        user.setPhysicalAddress(newPhysicalAddress);
        userRepository.save(user);
    }

    public void updateUserName(User user, String name){
        nullThrow(user, name);
        user.setName(name);
        userRepository.save(user);
    }

    // =====================================
    // DELETE
    // =====================================

    public void deleteAllUsers() {
        userRepository.deleteAll();
    }

    public void deleteUserById(UserId userId){
        User user = getUserById(userId);
        deleteUser(user);
    }

    public void deleteUser(User user){
        userRepository.delete(user);
    }

    // =====================================
    // GET
    // =====================================

    public User getUserByEmailAddress(EmailAddress emailAddress) {
        nullThrow(emailAddress);
        User user = findUserByEmailAddress(emailAddress)
                .orElseThrow(() -> new UserNotFoundException("Benutzer mit der Email Address: " +emailAddress.getEmail()+ " wurde nicht gefunden."));
        return user;
    }

    public String getUserNameById(UserId userId) {
        nullThrow(userId);
        User user = getUserById(userId);
        return user.getName();
    }

    public User getUserById(UserId userId){
        nullThrow(userId);
        User user = findUserById(userId)
                .orElseThrow(() -> new UserNotFoundException("Benutzer mit der ID: " +userId.getId()+ " wurde nicht gefunden."));
        return user;
    }

    // =====================================
    // FIND
    // =====================================

    public Optional<User> findUserByEmailAddress(EmailAddress emailAddress) {
        nullThrow(emailAddress);
        return userRepository.findByEmailAddress(emailAddress);
    }

    public Optional<User> findUserById(UserId userId) {
        nullThrow(userId);
        return userRepository.findById(userId);
    }

    // =====================================
    // EXISTS
    // =====================================

    public boolean existsUserByEmailAddress(EmailAddress emailAddress){
        nullThrow(emailAddress);
        return userRepository.existsByEmailAddress(emailAddress);
    }

    public boolean existsUserById(UserId userId) {
        nullThrow(userId);
        return userRepository.existsById(userId);
    }

    // =====================================
    // VALIDATION
    // =====================================
    private void nullThrow(Object... values) {
        for (Object value : values) {
            if (value == null) {
                throw new ConflictException("Ein übergebener Wert im UserService ist ungewollt null.");
            }
        }
    }

    // =====================================
    // INTERNAL HELPER
    // =====================================
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\exceptions\UserNotFoundException.java ---
package thkoeln.archilab.ecommerce.solution.user.domain.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "User Not Found") //404
//@ResponseStatus(code = HttpStatus.METHOD_NOT_ALLOWED, reason = "DemoNotFoundException") //405
//@ResponseStatus(code = HttpStatus.CONFLICT, reason = "DemoNotFoundException") //409
//@ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY, reason = "DemoNotFoundException") //422
public class UserNotFoundException extends ShopException {
    public UserNotFoundException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\User.java ---
package thkoeln.archilab.ecommerce.solution.user.domain;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.Embedded;
import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.*;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.usecases.UserType;

@Getter
@Entity
@AllArgsConstructor
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Table(name = "\"user\"")
public class User implements UserType {

    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private UserId id;

    @Setter
    @Embedded
    @JsonProperty("emailAddress")
    private EmailAddress emailAddress;

    @Setter
    @JsonProperty("name")
    private String name;

    @Setter
    @Embedded
    @JsonProperty("physicalAddress")
    private PhysicalAddress physicalAddress;

    public User(String name, EmailAddress emailAddress, PhysicalAddress physicalAddress) {
        this.id = new UserId();
        this.emailAddress = emailAddress;
        this.name = name;
        this.physicalAddress = physicalAddress;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserId.java ---
package thkoeln.archilab.ecommerce.solution.user.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "customer_id"))
public class UserId extends GenericId {
    public UserId( UUID id ) {
        super( id );
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.user.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class UserIdConverter extends GenericIdConverter<UserId> {
    public UserIdConverter() {
        super(UserId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserRepository.java ---
package thkoeln.archilab.ecommerce.solution.user.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;

import java.util.Optional;

@Repository
public interface UserRepository extends CrudRepository<User, UserId> {
    boolean existsByEmailAddress(EmailAddress emailAddress);
    Optional<User> findByEmailAddress(EmailAddress emailAddress);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\DepotUseCases.java ---
/*
 * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.UUID;

/**
 * This interface contains methods needed in the context of handling the shop stock,
 * i.e. managing depots, and adding / removing products in the depot.
 */
public interface DepotUseCases {
    /**
     *
     * @param name
     * @param physicalAddress
     * @return the id of the new depot
     * @throws ShopException if ...
     *      - name is null or empty
     *      - physicalAddress is null
     */
    public UUID addNewDepot( String name, PhysicalAddressType physicalAddress );


    /**
     * Deletes all depots from the shop. Intended for testing purposes.
     */
    public void deleteAllDepots();


    /**
     * Adds a certain Quantity of a given product to the stock
     * @param depotId
     * @param productId
     * @param addedQuantOf
     * @throws ShopException if ...
     *      - depotId is null
     *      - the depot with that id does not exist
     *      - productId is null
     *      - the product with that id does not exist
     *      - addedQuantOf < 0
     */
    public void addToStock( UUID depotId, UUID productId, int addedQuantOf );


    /**
     * Removes a certain Quantity of a given product from the stock.
     * @param depotId
     * @param productId
     * @param removedQuantOf
     * @throws ShopException if ...
     *      - depotId is null
     *      - the depot with that id does not exist
     *      - productId is null
     *      - the product with that id does not exist
     *      - removedQuantOf < 0
     */
    public void removeFromStock( UUID depotId, UUID productId, int removedQuantOf );


    /**
     * Changes the total Quantity of a given product in the stock.
     * @param depotId
     * @param productId
     * @param newTotalQuantOf
     * @throws ShopException if ...
     *      - depotId is null
     *      - the depot with that id does not exist
     *      - productId is null
     *      - the product with that id does not exist
     *      - newTotalQuantOf < 0
     */
    public void changeStockTo( UUID depotId, UUID productId, int newTotalQuantOf );


    /**
     * Get the current stock of a given product in one specific depot.
     * @param depotId
     * @param productId
     * @return the current total stock of the product
     * @throws ShopException if ...
     *      - depotId is null
     *      - the depot with that id does not exist
     *      - productId is null
     *      - the product with that id does not exist
     */
    public int getAvailableStock( UUID depotId, UUID productId );


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\CurrencyType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface CurrencyType {
    /**
     * @return the quantity of currency
     */
    public Float getQuantity();


    /**
     * @return the currency unit of the currency
     */
    public String getCurrencyUnit();


    /**
     * @param otherCurrency
     * @return this + otherCurrency, as a new object
     * @throws ShopException if ...
     *      - otherCurrency is null
     *      - otherCurrency.currencyUnit != this.currencyUnit
     */
    public CurrencyType add( CurrencyType otherCurrency );


    /**
     * @param otherCurrency
     * @return this - otherCurrency, as a new object
     * @throws ShopException if ...
     *      - otherCurrency is null
     *      - otherCurrency.currencyUnit != this.currencyUnit
     *      - otherCurrency > this
     */
    public CurrencyType subtract( CurrencyType otherCurrency );


    /**
     * @param factor
     * @return this * factor, as a new object
     * @throws ShopException if ...
     *     - factor < 0
     */
    public CurrencyType multiplyBy( int factor );

    /**
     * @param otherCurrency
     * @return true, if this > otherCurrency
     * @throws ShopException if ...
     *      - otherCurrency is null
     *      - otherCurrency.currencyUnit != this.currencyUnit
     */
    public boolean largerThan( CurrencyType otherCurrency );


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates a currency object from an quantity and a currency unit (as string).
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param quantity the quantity of currency (must be >= 0)
     * @param currencyUnit the currency unit of the currency (allowed values: "EUR", "CHF")
     * @return a new Currency object with the given quantity and currency unit
     * @throws ShopException if ...
     *   - quantity is null
     *   - quantity < 0
     *   - currency unit is null
     *   - currency unit is not one of the allowed values
     */
     // public static CurrencyType of( Float quantity, String currencyUnit );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\EmailAddressType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface EmailAddressType {
    /**
     * @return the email address as a string
     */
    public String toString();


    /**
     * A special kind of "copy constructor": Returns a new email address object with
     * the same identifyer (the substring left of the "@" sign) as the current one, but
     * with a new domain substring (right of the "@" sign).
     * @param domainString - the new domain for the copied email address
     * @return the new email address
     * @throws ShopException if ...
     *     - domainString is null
     *     - the new email address would not be valid (see `of(...)` method)
     */
    public EmailAddressType sameIdentifyerDifferentDomain( String domainString );

    /**
     * Another special kind of "copy constructor": Returns a new email address object
     * with the same domain (the substring right of the "@" sign) as the current one, but
     * with a new identifyer substring (left of the "@" sign).
     * @param identifyerString - the new identifyer for the copied email address
     * @return the new email address
     * @throws ShopException if ...
     *     - identifyerString is null
     *     - the new email address would not be valid (see `of(...)` method)
     */
    public EmailAddressType sameDomainDifferentIdentifyer( String identifyerString );


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an email address, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param emailAddressAsString - the email address as a string.
     *      We will use a much simplified validation method to check if the email address is valid:
     *      - it must contain exactly one '@' character.
     *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
     *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
     *      - the substrings before and after the '@' may contain one or several '.' as separators
     *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
     *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
     *        (for simplicity we do not allow any other domains)
     * @return a new EmailAddressType object matching the given email address
     * @throws ShopException if ...
     *      - emailAddressAsString is null
     *      - emailAddressAsString is not a valid email address (see above)
     */
     // public static EmailAddressType of( String emailAddressAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PhysicalAddressType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface PhysicalAddressType {
    /**
     * @return the street as a string
     */
    public String getStreet();

    /**
     * @return the city as a string
     */
    public String getCity();

    /**
     * @return the postal code
     */
    public PostalCodeType getPostalCode();

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an postal code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param street the street as a string
     * @param city the city as a string
     * @param postalCode the postal code
     * @return the physical address object matching the parameters
     * @throws ShopException if ...
     *      - street is null or empty
     *      - city is null or empty
     *      - postalCode is null
     */
     // public static PhysicalAddressType of( String street, String city, PostalCodeType postalCode );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PostalCodeType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import com.fasterxml.jackson.annotation.JsonIgnore;
import thkoeln.archilab.ecommerce.ShopException;

public interface PostalCodeType {
    /**
     * @return the postal code as a string
     */
    public String toString();

    /**
     * You will need some idea of "imprecise distance" between two postal codes for properly
     * implementing depots in your shopping platform. This method calculates such a
     * distance. You can decide for yourself what values you return, unless you comply
     * with the following rules.
     * - The return value is 0 if both postal codes are the same
     * - If not:
     *      - The distance is > 0 if both postal codes differ in the last digit, like 5673x
     *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
     *        So, 56733 and 56734 have the same distance as 56733 and 56739.
     *      - The distance grows if more digits (counted from the right side) differ.
     *        So, 5abcd and 5rstu have a larger distance than 53bcd and 53stu (if abcd
     *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
     *        53876 and 54876 have the same distance as 53876 and 57261.
     *      - However, the distance between 5abcd and 6rstu must be smaller than the one
     *        between 5abcd and 7rstu, and this distance in turn must be smaller than the
     *        one between 5abcd and 9rstu.
     *      - This last condition reflects the fact the first digits of a postal code marks a region
     *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
     *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
     *        other.
     * @param otherPostalCode
     * @return the calculated distance
     * @throws ShopException if otherPostalCode is null
     */
    public int distance( PostalCodeType otherPostalCode );


    /**
     * For the currently used way of deciding on the best fitting depot for a purchase,
     * we need to know the first digit of the postal code.
     */
    @JsonIgnore
    public Integer getFirstDigitPostalCode();


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an postal code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param postalCodeAsString - the postal code as a string.
     *      We will use a much simplified validation method to check if the postal code is valid:
     *      - It must contain exactly 5 digits.
     *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid postal code, but 20001 is valid)
     * @return a new postal code object matching the given string
     * @throws ShopException if ...
     *      - postalCodeAsString is null
     *      - postalCodeAsString is not a valid postal code (see above)
     */
     // public static PostalCodeType of( String postalCodeAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\DepotTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import java.util.UUID;

public interface DepotTestHelper {
    /**
     * Adds the test depots to the system.
     * If you want to use the depots, or want to know which index the depot has that you see
     * in the debugger, the following rules apply:
     * - The depot name will equal the street name of the physical address of the depot.
     * - The index number is visible in the house number. Example: depot 3 is located at
     *   "Ablageweg 3", and that is also its name.
     *
     *  The depots are used in the tests as follows:
     *  - depot 0 holds all products 0 - 6, and is used for all tests where it is not relevant
     *    to split one shopping basket into several purchases.
     *  - depots 1 - 3 are used for the proximity tests, where you can deliver product 7 to
     *    to a user from the closest depot.
     *  - depots 4 - 8 are used for the tests where you need to deliver products 8 - 14 in
     *    the most cost-efficient way, as multiple deliveries.
     *  - depot 9 is empty.
     *
     *  If withStock is true, then the depots are filled with products. This happens
     *  according to the following rules:
     *  - products 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
     *    ONLY available in depot 0. (This means that product 0 out of stock everywhere.)
     *  - products 4, 5, 6 have a random stock between 30 and 130, also all ONLY in depot 0
          (these are the products used for tests on how to add and remove stock)
     *  - product 7 has a random stock between 30 and 130, distributed over
     *    depots 1, 2, and 3. You can use this to test if the appropriate depot is found
     *    for a shopping basket with only product 7 in it, but with different quantities (<= 3, or > 3).
     *  - The other products (8 - 14) have also a random stock between 30 and 130, all distributed
     *    over several depots. The distribution is done as follows:
     *    Assume that the product is available in <n> depots. Then the first <n-1> depots
     *    in the list (in ascending sequence) contain 3, and all the remaining stock is in the
     *    last depot.
     *
     *    This is how the stock of products could be distributed
     *    (Wx = depot x with its postal code, Px = product x,
     *    numbers marked with (*) are random large numbers):
     *
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
     *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *    | P0   |      |     |     |      |     |      |     |       |      |     |
     *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
     *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
     *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
     *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
     *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
     *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
     *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
     *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
     *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
     *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
     *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
     *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
     *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
     *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *
     * @param withStock if true, the stock of the products is added to the depot. Otherwise, the
     *                           the stock is not added and the depot is empty.
     */
    public void addAllDepots( boolean withStock );


    /**
     * @return the number of test depots in the database
     */
    int numberOfDepots();


    /**
     * @param index
     * @return the id of the test depot at the given index
     */
    UUID getDepotId( int index );


    /**
     * @param depotId - the id of the depot in the test data
     * @return the index of the test depot with that id
     */
    int findDepotIndex( UUID depotId );


    /**
     * @param productIndex - the index of the product in the test data
     * @param depotIndex - the index of the depot in the test data
     * @return the number of products (stock) available in the depot at the given index
     */
    Integer getDepotStock( int depotIndex, int productIndex );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.Enumeration;

import static org.junit.jupiter.api.Assertions.*;

public class FactoryMethodInvoker {

    public static EmailAddressType instantiateEmailAddress( String emailAddressAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for EmailAddressType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, emailAddressAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + emailAddressAsString + "'", e );
        }
        assertNotNull( instance );
        return (EmailAddressType) instance;
    }


    public static PhysicalAddressType instantiatePhysicalAddress(
            String street, String city, PostalCodeType postalCode ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of",
                    String.class, String.class, PostalCodeType.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for PhysicalAddressType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, street, city, postalCode );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" +
                    street + "', '" + city + "', '" + postalCode + "'", e );
        }
        assertNotNull( instance );
        return (PhysicalAddressType) instance;
    }


    public static PostalCodeType instantiatePostalCode( String postalCodeAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for PostalCodeType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, postalCodeAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + postalCodeAsString + "'", e );
        }
        assertNotNull( instance );
        return (PostalCodeType) instance;
    }


    public static CurrencyType instantiateCurrency( Float quantity, String currencyUnit ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for CurrencyType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, quantity, currencyUnit );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + quantity + "', '" + currencyUnit + "'", e );
        }
        assertNotNull( instance );
        return (CurrencyType) instance;
    }


    private static Class<?> findImplementation( Class<?> interfaceClass ) {
        Method factoryMethod = null;
        try {
            String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
            Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
            assertNotNull( implementingClass );
            return implementingClass;
        } catch (Exception e) {
            fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
            return null; // This line will never be reached, but it's necessary to satisfy the compiler
        }
    }


    private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
            throws ClassNotFoundException, IOException {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        String path = packageName.replace( '.', '/' );
        Enumeration<URL> resources = classLoader.getResources( path );
        int count = 0;
        Class<?> result = null;
        while (resources.hasMoreElements()) {
            URL resource = resources.nextElement();
            File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
            File[] files = directory.listFiles();
            for ( File file : files ) {
                if ( file.getName().endsWith( ".class" ) ) {
                    String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
                    Class<?> clazz = Class.forName( className );
                    if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
                        count++;
                        result = clazz;
                    }
                }
            }
        }
        assertEquals( 1, count, "There should be exactly one implementing class" );
        return result;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\StockTestHelperImpl.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.DepotTestHelper;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.DepotUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;

import java.util.*;

/**
 * This is a test helper class that initializes and registers products (but without stock)
 * in the system, using the given interface(s).
 */
@Component
@SuppressWarnings("PMD")
public class StockTestHelperImpl
                        implements ProductTestHelper, DepotTestHelper {
    private ProductCatalogUseCases productCatalogUseCases;
    private DepotUseCases depotUseCases;
    private static Random random = new Random();

    private static final String EUR = "EUR";
    private static final int PRODUCT_NUMOF = 15;
    private static final Object[][] PRODUCT_DATA = new Object[][]{
            {null, "0-TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
                    1.5f, FactoryMethodInvoker.instantiateCurrency( 5.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 10.0f, EUR ),
                    "0"},
            {null, "1-EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
                    0.3f, FactoryMethodInvoker.instantiateCurrency( 2.5f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 4.0f, EUR ),
                    "0"},
            {null, "2-MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
                    7.2f, FactoryMethodInvoker.instantiateCurrency( 50.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 80.0f, EUR ),
                    "0"},
            {null, "3-Gh-25", "Kompakter und leichter Akku für mobile Geräte",
                    null, FactoryMethodInvoker.instantiateCurrency( 6.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 8.0f, EUR ),
                    "0"},
            {null, "4-MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
                    null, FactoryMethodInvoker.instantiateCurrency( 0.6f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 1.0f, EUR ),
                    "0"},
            {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
                    1.0f, FactoryMethodInvoker.instantiateCurrency( 150.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 250.0f, EUR ),
                    "0"},
            {null, "6-Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
                    null, FactoryMethodInvoker.instantiateCurrency( 0.3f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 0.5f, EUR ),
                    "0"},
            {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
                    6.0f, FactoryMethodInvoker.instantiateCurrency( 80.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 120.0f, EUR ),
                    "123"},
            {null, "8-JKL-67", "Wasserdichtes Gehäuse",
                    3.0f, FactoryMethodInvoker.instantiateCurrency( 1.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 1.2f, EUR ),
                    "467"},
            {null, "9-MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
                    5.5f, FactoryMethodInvoker.instantiateCurrency( 25.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 45.0f, EUR ),
                    "578"},
            {null, "10-PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
                    4.0f, FactoryMethodInvoker.instantiateCurrency( 20.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 35.0f, EUR ),
                    "567"},
            {null, "11-STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
                    null, FactoryMethodInvoker.instantiateCurrency( 200.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 350.0f, EUR ),
                    "478"},
            {null, "12-VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
                    null, FactoryMethodInvoker.instantiateCurrency( 15.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 25.0f, EUR ),
                    "5"},
            {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
                    3.5f, FactoryMethodInvoker.instantiateCurrency( 60.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 100.0f, EUR ),
                    "78"},
            {null, "14-Nosedive", "Klammer zum Verschließen der Nase beim Tauchen",
                    5.0f, FactoryMethodInvoker.instantiateCurrency( 2.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 5.0f, EUR ),
                    "457"}
    };
    

    // These physical addresss are used for the depots. The depot name will equal
    // the postal code of the site. Their index number will be visible in the house number.
    // The depots are used as such:
    // - depot 0 is holds all products 0 - 6, and is used for all tests where multiple
    //   deliveries are irrelevant.
    // - depots 1 - 3 are used for the proximity tests, where you can deliver products 7 to
    //   to a user from the closest depot.
    // - depots 4 - 8 are used for the tests where you need to deliver products 8 - 14 in
    //   the most cost-efficient way, as multiple deliveries.
    // - depot 9 is empty.
    private final static int DEPOT_NUMOF = 10;
    private final static PhysicalAddressType[] DEPOT_PHYSICAL_ADDRESS = new PhysicalAddressType[]{
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Stapelallee 0", "Potsdam",
                    FactoryMethodInvoker.instantiatePostalCode( "14476" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Lagerhausstr. 1", "Viertelstadt",
                    FactoryMethodInvoker.instantiatePostalCode( "02345" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Speicherplatz 2", "Viertelstadt",
                    FactoryMethodInvoker.instantiatePostalCode( "02313" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Ablageweg 3", "Reichswürgen",
                    FactoryMethodInvoker.instantiatePostalCode( "44923" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Paketstellenallee 4", "Düsseldorf",
                    FactoryMethodInvoker.instantiatePostalCode( "40588" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Kaputte-Sachen-Straße 5", "Düren",
                    FactoryMethodInvoker.instantiatePostalCode( "52355" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Aufbewahrungsweg 6", "Viernheim",
                    FactoryMethodInvoker.instantiatePostalCode( "68519" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Paketallee 7", "Baden-Baden",
                    FactoryMethodInvoker.instantiatePostalCode( "76532" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Sendenstr. 8", "Senden",
                    FactoryMethodInvoker.instantiatePostalCode( "89250" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Schickweg 9", "Hohenroth",
                    FactoryMethodInvoker.instantiatePostalCode( "97618" ) )
    };
    private final static UUID[] DEPOT_ID = new UUID[DEPOT_NUMOF];


    // These data structures contain the stock of the products in the depots.
    // PRODUCT_STOCK is a map product name -> Integer[DEPOT_NUMOF].
    // The Integer[DEPOT_NUMOF] contains the stock of the product in each of
    // the depots.
    //
    // The following rules apply:
    // - product 0 is out of stock
    // - product 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in depot 0
    // - product 4 / 5 / 6 have a random stock between 30 and 130, also all ONLY in depot 0
    //   (these are the products used for tests on how to add and remove stock)
    // - the others have a random stock between 30 and 130, distributed over several
    //   depots. Here we follow this convention for simplicity:
    //   - Assume that the product is available in <n> depots. Then the first <n-1> depots
    //     in the list (in ascending sequence) contain 3, and all the remaining stock is in the
    //     last depot.

    private static final Map<String, Integer[]> PRODUCT_STOCK = new HashMap<>();

    static {
        // products 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
        PRODUCT_STOCK.put( (String) PRODUCT_DATA[0][1],
                getStockDistribution( 0, (String) PRODUCT_DATA[0][6] ) );
        PRODUCT_STOCK.put( (String) PRODUCT_DATA[1][1],
                getStockDistribution( 10, (String) PRODUCT_DATA[1][6] ) );
        PRODUCT_STOCK.put( (String) PRODUCT_DATA[2][1],
                getStockDistribution( 20, (String) PRODUCT_DATA[2][6] ) );
        PRODUCT_STOCK.put( (String) PRODUCT_DATA[3][1],
                getStockDistribution( 30, (String) PRODUCT_DATA[3][6] ) );

        // The other products have a random stock between 30 and 130,
        for ( int i = 4; i < PRODUCT_NUMOF; i++ ) {
            Integer totalNumber = random.nextInt( 100 ) + 30;
            Integer[] stockInDepots =
                    getStockDistribution( totalNumber, (String) PRODUCT_DATA[i][6] );
            PRODUCT_STOCK.put( (String) PRODUCT_DATA[i][1], stockInDepots );
        }
    }

    /**
     * This method creates a random stock distribution for the given product.
     *
     * @param totalQuantity - the total number of products in the depots
     * @param zeroToNine  - a string with numbers between 0 and 9, representing the depots
     * @return an Integer array with the stock distribution for the product, according to
     * the rules described above.
     */
    private static Integer[] getStockDistribution( Integer totalQuantity, String zeroToNine ) {
        Integer[] stockInDepots = new Integer[DEPOT_NUMOF];
        for ( int i = 0; i < DEPOT_NUMOF; i++ ) stockInDepots[i] = 0;
        TreeSet<Integer> depotIndices = getDepotIndices( zeroToNine );
        int numOfIndices = depotIndices.size();
        int currentIndexNumber = 0;
        int currentQuantity = totalQuantity;
        for ( Integer depotIndex : depotIndices ) {
            currentIndexNumber++;
            if ( currentIndexNumber < numOfIndices ) {
                stockInDepots[depotIndex] = 3;
                currentQuantity -= 3;
            } else {
                stockInDepots[depotIndex] = currentQuantity;
            }
        }
        return stockInDepots;
    }

    private static TreeSet<Integer> getDepotIndices( String zeroToNine ) {
        TreeSet<Integer> depotIndices = new TreeSet<>();
        for ( int i = 0; i < zeroToNine.length(); i++ ) {
            depotIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
        }
        return depotIndices;
    }


    @Autowired
    public StockTestHelperImpl( ProductCatalogUseCases productCatalogUseCases,
                                         DepotUseCases depotUseCases ) {
        this.productCatalogUseCases = productCatalogUseCases;
        this.depotUseCases = depotUseCases;
    }


    @Override
    public void addAllProducts() {
        int i = 0;
        for ( Object[] productData : PRODUCT_DATA ) {
            UUID newId = productCatalogUseCases.addProductToCatalog(
                    (String) productData[1], (String) productData[2],
                    (Float) productData[3], (CurrencyType) productData[4],
                    (CurrencyType) productData[5] );
            // The first element of the product data is the id, which was initialized with null before, but can now be set
            PRODUCT_DATA[i][0] = newId;
            i++;
        }
    }


    @Override
    public int numberOfProducts() {
        return PRODUCT_NUMOF;
    }


    @Override
    public UUID getProductId( int index ) {
        if ( index < 0 || index >= PRODUCT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (UUID) PRODUCT_DATA[index][0];
    }


    @Override
    public CurrencyType getBuyingPrice( int index ) {
        if ( index < 0 || index >= PRODUCT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (CurrencyType) PRODUCT_DATA[index][4];
    }


    @Override
    public CurrencyType getSalesPrice( int index ) {
        if ( index < 0 || index >= PRODUCT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (CurrencyType) PRODUCT_DATA[index][5];
    }


    @Override
    public void addAllDepots( boolean withStock ) {
        for ( int i = 0; i < DEPOT_NUMOF; i++ ) {
            DEPOT_ID[i] = depotUseCases.addNewDepot(
                    DEPOT_PHYSICAL_ADDRESS[i].getStreet(),
                    DEPOT_PHYSICAL_ADDRESS[i] );
        }
        if ( withStock ) {
            addAllStock();
        }
    }


    private void addAllStock() {
        for ( Object[] productData : PRODUCT_DATA ) {
            Integer[] stockInDepots =
                    PRODUCT_STOCK.get( productData[1] );
            for ( int iDepot = 0; iDepot < DEPOT_NUMOF; iDepot++ ) {
                if ( stockInDepots[iDepot] > 0 )
                    depotUseCases.addToStock(
                            DEPOT_ID[iDepot], (UUID) productData[0],
                            stockInDepots[iDepot] );
            }
        }
    }


    @Override
    public int numberOfDepots() {
        return DEPOT_NUMOF;
    }


    @Override
    public UUID getDepotId( int index ) {
        if ( index < 0 || index >= DEPOT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return DEPOT_ID[index];
    }


    @Override
    public Integer getDepotStock( int depotIndex, int productIndex ) {
        if ( depotIndex < 0 || depotIndex >= DEPOT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + depotIndex );
        }
        if ( productIndex < 0 || productIndex >= PRODUCT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + productIndex );
        }
        String productName = (String) PRODUCT_DATA[productIndex][1];
        Integer[] stockInDepots = PRODUCT_STOCK.get( productName );
        Integer foundStock = stockInDepots[depotIndex];
        return foundStock == null ? 0 : foundStock;
    }


    @Override
    public int findDepotIndex( UUID depotId ) {
        for ( int i = 0; i < DEPOT_NUMOF; i++ ) {
            if ( DEPOT_ID[i].equals( depotId ) ) {
                return i;
            }
        }
        throw new IllegalArgumentException( "No test depot with UUID id " + depotId );
    }


    @Override
    public int findProductIndex( UUID productId ) {
        for ( int iProductData = 0; iProductData < DEPOT_NUMOF; iProductData++ ) {
            Object[] productData = PRODUCT_DATA[iProductData];
            if ( productData[0].equals( productId ) ) {
                return iProductData;
            }
        }
        throw new IllegalArgumentException( "No test product with UUID id " + productId );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\UserTestHelperImpl.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
import thkoeln.archilab.ecommerce.usecases.masterdata.MockUser;

import static org.junit.jupiter.api.Assertions.assertThrows;

/**
 * This is a test helper class that initializes and registers users in the system,
 * using the given interface(s).
 */
@Component
@SuppressWarnings("PMD")
public class UserTestHelperImpl implements UserTestHelper {

    private UserRegistrationUseCases userRegistrationUseCases;

    @Autowired
    public UserTestHelperImpl( UserRegistrationUseCases userRegistrationUseCases ) {
        this.userRegistrationUseCases = userRegistrationUseCases;
    }

    private final static String[] USER_NAME = new String[]{
            "Max Mueller",
            "Sophie Schmitz",
            "Irene Mihalic",
            "Emilia Fischer",
            "Filiz Polat",
            "Lina Wagner",
            "Leon Becker",
            "Agnieszka Kalterer",
            "Felix Bauer",
            "Lara Schulz"
    };

    private final static EmailAddressType[] USER_EMAIL = new EmailAddressType[]{
            FactoryMethodInvoker.instantiateEmailAddress( "99Z@example.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "a@4.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "irene@wearefreedomnow.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "emilia.fischer@example.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "j877d3@example.this.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "lina.marie.wagner@example.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
            FactoryMethodInvoker.instantiateEmailAddress( "agna@here.ch" ),
            FactoryMethodInvoker.instantiateEmailAddress( "felix.bauer@example.org" ),
            FactoryMethodInvoker.instantiateEmailAddress( "lara.schulz@example.at" )
    };

    // The following array is used to create a list of physicalAddresss for the users.
    // The indices are coded into the house number.
    // - Persons 0 - 5 are used for proximity tests with one depot.
    private final static PhysicalAddressType[] USER_ADDRESS = new PhysicalAddressType[]{
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Marktstraße 0", "Viertelstadt",
                    FactoryMethodInvoker.instantiatePostalCode( "02314" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Hauptstraße 1", "Viertelstadt",
                    FactoryMethodInvoker.instantiatePostalCode( "02368" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Kirchplatz 2", "Niemandstown",
                    FactoryMethodInvoker.instantiatePostalCode( "12345" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Schulstraße 3", "Geisterhausen",
                    FactoryMethodInvoker.instantiatePostalCode( "31463" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Rosenweg 4", "Kuhhausen",
                    FactoryMethodInvoker.instantiatePostalCode( "72162" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Wiesenstraße 5", "Waldschenkensdorf",
                    FactoryMethodInvoker.instantiatePostalCode( "82195" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Muehlenweg 6", "Koeln",
                    FactoryMethodInvoker.instantiatePostalCode( "50667" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Goethestraße 7", "Frankfurt am Main",
                    FactoryMethodInvoker.instantiatePostalCode( "60311" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Dorfstraße 8", "Stuttgart",
                    FactoryMethodInvoker.instantiatePostalCode( "70173" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Bahnhofstraße 9", "Muenchen",
                    FactoryMethodInvoker.instantiatePostalCode( "80331" ) )
    };

    private final static UserType[] mockUsers;

    static {
        mockUsers = new UserType[USER_NAME.length];
        for ( int i = 0; i < USER_NAME.length; i++ ) {
            mockUsers[i] = new MockUser(
                    USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
        }
    }


    @Override
    public void registerAllUsers() {
        for ( int i = 0; i < USER_NAME.length; i++ ) {
            registerUser( USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
        }
    }


    private void registerUser( String name, EmailAddressType emailAddress, PhysicalAddressType physicalAddress ) {
        userRegistrationUseCases.register( name, emailAddress, physicalAddress );
    }


    @Override
    public int getNumberOfUsers() {
        return USER_NAME.length;
    }


    @Override
    public String getUserName( int index ) {
        if ( index < 0 || index >= USER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return USER_NAME[index];
    }


    @Override
    public EmailAddressType getUserEmailAddress( int index ) {
        if ( index < 0 || index >= USER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return USER_EMAIL[index];
    }


    @Override
    public PhysicalAddressType getUserPhysicalAddress( int index ) {
        if ( index < 0 || index >= USER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return USER_ADDRESS[index];
    }


    @Override
    public UserType getUser( int index ) {
        if ( index < 0 || index >= USER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return mockUsers[index];
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockUser.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import lombok.Setter;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;


import java.util.Objects;

@Setter
public class MockUser implements UserType {
    private String name;
    private EmailAddressType emailAddressType;
    private PhysicalAddressType physicalAddressType;


    public MockUser( String name, EmailAddressType emailAddressType, PhysicalAddressType physicalAddressType) {
        this.name = name;
        this.emailAddressType = emailAddressType;
        this.physicalAddressType = physicalAddressType;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public EmailAddressType getEmailAddress() {
        return emailAddressType;
    }

    @Override
    public PhysicalAddressType getPhysicalAddress() {
        return physicalAddressType;
    }

    @Override
    public boolean equals( Object o ) {
        if ( this == o ) return true;
        if ( !( o instanceof MockUser ) ) return false;
        MockUser that = (MockUser) o;
        return Objects.equals( getName(), that.getName() ) &&
                Objects.equals( emailAddressType, that.emailAddressType ) &&
                Objects.equals( physicalAddressType, that.physicalAddressType );
    }

    @Override
    public int hashCode() {
        return Objects.hash( getName(), emailAddressType, physicalAddressType );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ProductTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

import java.util.UUID;

public interface ProductTestHelper {
    /**
     * Adds all test products to the database.
     * If you use the debugger and want to identify _which_ test product you currently look at:
     * The indices are coded into the first number in the name string of the product, like e.g.
     * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
     */
    void addAllProducts();


    /**
     * @return the number of test products in the database
     */
    int numberOfProducts();


    /**
     * @param index
     * @return the id of the test product at the given index
     */
    UUID getProductId( int index );


    /**
     * @param productId - the id of the product in the test data
     * @return the index of the test product with that id
     */
    int findProductIndex( UUID productId );


    /**
     * @param index
     * @return the buying price of test product at the given index
     */
    CurrencyType getBuyingPrice( int index );


    /**
     * @param index
     * @return the sales price of test product at the given index
     */
    CurrencyType getSalesPrice( int index );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.usecases.*;

/**
 * Removes everything :-)
 */
@Service
public class Purgatory {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private PurchaseUseCases purchaseUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private DepotUseCases depotUseCases;

    public void deleteEverything() {
        purchaseUseCases.deleteAllPurchases();
        shoppingBasketUseCases.emptyAllShoppingBaskets();
        depotUseCases.deleteAllDepots();
        userRegistrationUseCases.deleteAllUsers();
        productCatalogUseCases.deleteProductCatalog();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.DepotUseCases;

@Component
@Slf4j
@Profile("!test")
@SuppressWarnings("PMD")
public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
    private Purgatory purgatory;
    private UserTestHelper userTestHelper;
    private ProductTestHelper productTestHelper;
    private DepotTestHelper depotTestHelper;


    @Autowired
    public StartupListener( Purgatory purgatory,
                            UserTestHelper userTestHelper,
                            ProductTestHelper productTestHelper,
                            DepotTestHelper depotTestHelper ) {
        this.purgatory = purgatory;
        this.userTestHelper = userTestHelper;
        this.productTestHelper = productTestHelper;
        this.depotTestHelper = depotTestHelper;
    }

    @Override
    public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
        log.info( "StartupListener initializing master data ..." );
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        productTestHelper.addAllProducts();
        depotTestHelper.addAllDepots( true );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\UserTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;


import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

/**
 * This is a test helper interface provides access to predefined test data for
 * users.
 */
public interface UserTestHelper {
    /**
     * This method calls the use case implementation to register all users specified in the
     * test data set.
     * If you use the debugger and want to identify _which_ test user you currently look at:
     * The indices are coded into the house number (in the user's physical address) and in the first
     * cipher of the postal code. This is the list of users:
     *
     * +-------+-------------------+--------+---------------------
     * | Index | Name              | PLZ    | EmailAddress
     * +-------+-------------------+--------+---------------------
     * | 0     | Max Mueller       | 02314  | 99Z@example.com
     * | 1     | Sophie Schmitz    | 02368  | a@4.com
     * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
     * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
     * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
     * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
     * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
     * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
     * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
     * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
     * +-------+-------------------+--------+---------------------
     */
    void registerAllUsers();


    /**
     * @return the number of test users in the test data set.
     */
    int getNumberOfUsers();


    /**
     * @param index the index of the user in the test data set.
     * @return the name of the test user with the given index.
     */
    String getUserName( int index );


    /**
     * @param index the index of the user in the test data set.
     * @return the email address of the test user with the given index.
     */
    EmailAddressType getUserEmailAddress( int index );


    /**
     * @param index the index of the user in the test data set.
     * @return the physical address of the test user with the given index.
     */
    PhysicalAddressType getUserPhysicalAddress( int index );


    /**
     * @param index the index of the user in the test data set.
     * @return the test user with the given index.
     */
    UserType getUser( int index );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\ProductCatalogUseCases.java ---
/*
 * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

import java.util.UUID;


/**
 * This interface contains methods needed in the context of use cases concerning the product catalog.
 * The interface is probably incomplete, and will grow over time ...
 */

public interface ProductCatalogUseCases {
    /**
     * Adds a new product to the shop catalog
     * @param name
     * @param descriptFor
     * @param size
     * @param buyingPrice
     * @param salesPrice
     * @return the id of the new product
     * @throws ShopException if ...
     *      - the product id already exists,
     *      - name or description are null or empty,
     *      - the size is <= 0 (but can be null!),
     *      - the buying price is null or <= 0,
     *      - the buyingPrice is null,
     *      - the sales price is null,
     *      - the sales price is lower than the buyingPrice
     */
    public UUID addProductToCatalog( String name, String descriptFor, Float size,
                                           CurrencyType buyingPrice, CurrencyType salesPrice );


    /**
     * Removes a product from the shop catalog
     * @param productId
     * @throws ShopException if
     *      - productId is null
     *      - the product id does not exist
     *      - the product is still in stock
     *      - the product is still in a shopping basket, or referenced by a completed purchase
     */
    public void removeProductFromCatalog( UUID productId );


    /**
     * Get the sales price of a given product
     * @param productId
     * @return the sales price
     * @throws ShopException if ...
     *      - productId is null,
     *      - the product with that id does not exist
     */
    public CurrencyType getSalesPrice( UUID productId );


    /**
     * Clears the product catalog, i.e. removes all products from the catalog, including all the stock,
     * all the reservations and all the purchases.
     */
    public void deleteProductCatalog();

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\PurchaseUseCases.java ---
/*
 * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
 */
package thkoeln.archilab.ecommerce.usecases;


import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Map;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of the purchase history of a user.
 */
public interface PurchaseUseCases {

    /**
     * Returns a map showing which products have been purchased by a user and how many of each product
     *
     * @param userEmailAddress
     * @return the purchase history of the user (map is empty if the user has not purchased anything yet)
     * @throws ShopException if
     *      - userEmailAddress is null
     *      - the user with the given email address does not exist
     */
    public Map<UUID, Integer> getPurchaseHistory( EmailAddressType userEmailAddress );



    /**
     * @return the number of products in a given purchase. If the product is not a position of the purchase, the method
     *         returns 0. No exception is thrown.
     * @param purchaseId - the id of the purchase to be checked
     * @param productId - the id of the product for which we want to know the quantity
     * @throws ShopException if
     *     - purchaseId is null, or doesn't exist in the system
     *     - productId is null, or doesn't exist in the system
     */
    public Integer getPurchaseQuantOfProduct( UUID purchaseId, UUID productId );


    /**
     * @return the id of the depot that is responsible for the given purchase
     * @param purchaseId - the id of the purchase to be checked
     * @throws ShopException if
     *      - purchaseId is null, or doesn't exist in the system
     */
    public UUID getDepotIdForPurchase( UUID purchaseId );


    /**
     * Deletes all purchases in the system
     */
    public void deleteAllPurchases();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingBasketUseCases.java ---
/*
 * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Map;
import java.util.Set;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of use cases handling the shopping basket.
 * The interface is probably incomplete, and will grow over time ...
 */
public interface ShoppingBasketUseCases {
    /**
     * Adds a product to the cart of a user
     *
     * @param userEmailAddress
     * @param productId
     * @param quantOf
     * @throws ShopException if ...
     *          - userEmailAddress is null,
     *          - the user with the given email address does not exist,
     *          - productId is null,
     *          - the product with productId does not exist
     *          - the Quantity is negative,
     */
    public void addProductToShoppingBasket( EmailAddressType userEmailAddress,
                                                 UUID productId, int quantOf );


    /**
     * Removes a product from the cart of a user
     *
     * @param userEmailAddress
     * @param productId
     * @param quantOf
     * @throws ShopException if ...
     *          - userEmailAddress is null,
     *          - the user with the given email address does not exist,
     *          - productId is null,
     *          - the product with productId does not exist
     *          - the Quantity is negative
     *          - the product is not in the shopping basket in the requested Quantity
     */
    public void removeProductFromShoppingBasket( EmailAddressType userEmailAddress,
                                                      UUID productId, int quantOf );


    /**
     * Returns a map showing which products are in the cart of a user and how many of each product
     *
     * @param userEmailAddress
     * @return the cart of the user (map is empty if the cart is empty)
     * @throws ShopException if
     *          - userEmailAddress is null,
     *          - the user with the given email address does not exist
     */
    public Map<UUID, Integer> getShoppingBasketAsMap( EmailAddressType userEmailAddress );


    /**
     * Returns the current value of all products in the cart of a user
     *
     * @param userEmailAddress
     * @return the cart of the user
     * @throws ShopException if
     *          - userEmailAddress is null,
     *          - the user with the given email address does not exist
     */
    public CurrencyType getShoppingBasketAsCurrencyValue( EmailAddressType userEmailAddress );




    /**
     * Checks out the cart of a user
     *
     * @param userEmailAddress
     * @return A set of ids belonging to purchases that were created during the checkout. If the shopping basket can
     *         only be served from more than one depot, each delivery from a depot gets a
     *         dedicated purchase. I.e. if there is just one delivery, then the set will contain just one purchase id.
     *         If there are multiple deliveries, the set will contain multiple purchase ids.
     * @throws ShopException if
     *      - userEmailAddress is null or empty
     *      - the user with the given email address does not exist, or if the cart is empty
     * @throws
     *      - ShopException if userEmailAddress is null
     *      - InsufficientStockException if there is not enough stock level for to serve the purchase
     *        for all products in the shopping basket
     */
    public Set<UUID> checkout( EmailAddressType userEmailAddress );


    /**
     * Empties all shopping baskets in the system
     */
    public void emptyAllShoppingBaskets();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\UserRegistrationUseCases.java ---
/*
 * Copyright ArchiLab 2025, Cologne University of Applied Sciences, Faculty 10
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

/**
 * This interface contains methods needed in the context of use cases concerning the registration of a user.
 * The interface is probably incomplete, and will grow over time ...
 */
public interface UserRegistrationUseCases {
    /**
     * Registers a new user
     *
     * @param name
     * @param emailAddress
     * @param physicalAddress
     * @throws ShopException if ...
     *      - the user with the given email address already exists
     *      - physicalAddress is null
     */
    public void register( String name, EmailAddressType emailAddress, PhysicalAddressType physicalAddress );


    /**
     * Changes the address of a user
     *
     * @param userEmailAddress
     * @param userEmailAddress
     * @param physicalAddress
     * @throws ShopException if ...
     *      - the user with the given email address does not exist,
     *      - physicalAddress is null
     */
    public void changeAddress( EmailAddressType userEmailAddress,
                               PhysicalAddressType physicalAddress );


    /**
     * Returns the data of a user as an array of strings (name, emailAddress, street, city, postalCode)
     * @param userEmailAddress
     * @return the user data
     * @throws ShopException the user with the given email address does not exist,
     */
    public UserType getUserData( EmailAddressType userEmailAddress );



    /**
     * Clears all users, including all purchases and shopping baskets
     */
    public void deleteAllUsers();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\usecases\UserType.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

/**
 * This interface expresses the essence of a shop user
 */
public interface UserType {
    String getName();
    EmailAddressType getEmailAddress();
    PhysicalAddressType getPhysicalAddress();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
package thkoeln.archilab.ecommerce.helpers.impl;

import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.test.web.servlet.MockMvc;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;


@TestConfiguration
public class RESTTestHelperConfiguration {

    @Bean
    public ShoppingBasketRESTHelper shoppingBasketRESTHelper(
            MockMvc mockMvc, ProductCatalogUseCases productCatalogUseCases ) {
        return new ShoppingBasketRESTHelperImpl( mockMvc, productCatalogUseCases );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingBasketRESTHelperImpl.java ---
package thkoeln.archilab.ecommerce.helpers.impl;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Map;
import java.util.UUID;

import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@Slf4j
public class ShoppingBasketRESTHelperImpl implements ShoppingBasketRESTHelper {
    private MockMvc mockMvc;
    private ProductCatalogUseCases productCatalogUseCases;

    private static final ResultMatcher CREATED = status().isCreated();
    private static final ResultMatcher OK = status().isOk();

    public ShoppingBasketRESTHelperImpl( MockMvc mockMvc, ProductCatalogUseCases productCatalogUseCases ) {
        this.mockMvc = mockMvc;
        this.productCatalogUseCases = productCatalogUseCases;
    }


    @Override
    public UUID getQueryShoppingBasket( EmailAddressType emailAddress, Map<UUID, Integer> quantityMap )
            throws Exception {
        // first query the users API to get the proper userId
        UUID userId;
        String userUri = "/users?emailAddress=" + emailAddress.toString();
        MvcResult userGetResult = mockMvc.perform( get( userUri ) )
                .andExpect( status().isOk() )
                .andReturn();
        ObjectMapper objectMapper = new ObjectMapper();
        IdDTO idDTO = objectMapper.readValue( userGetResult.getResponse().getContentAsString(), IdDTO.class );
        userId = idDTO.getId();

        // then query the shopping basket API and extract the shopping basket id
        String shoppingBasketUri = "/shoppingBaskets?userId=" + userId.toString();
        ResultActions resultActions = mockMvc.perform( get( shoppingBasketUri ) )
                .andExpect( status().isOk() );
        idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
        UUID shoppingBasketId = idDTO.getId();

        // additional checks, if desired
        if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
        return shoppingBasketId;
    }


    private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
        if ( quantityMap == null ) return;
        int numOfProducts = quantityMap.size();
        resultActions.andExpect( jsonPath( "$.positions.length()" ).value( numOfProducts ) );
        float totalSalesPriceAsFloat = 0f;
        for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
            UUID productId = entry.getKey();
            Integer quantity = entry.getValue();
            resultActions.andExpect( jsonPath( "$.positions.[?(@.productId == '" + productId + "')].quantity" )
                    .value( quantity ) );
            CurrencyType salesPrice = productCatalogUseCases.getSalesPrice( productId );
            totalSalesPriceAsFloat += salesPrice.getQuantity() * quantity;
        }
        // last thing - check the total sales price
        String totalSalesPriceString = String.format( "%.2f €", totalSalesPriceAsFloat );
        resultActions
                .andExpect( jsonPath( "$.totalSalesPrice" ).value( totalSalesPriceString ) );
    }


    @Override
    public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity )
            throws Exception {
        addProductToShoppingBasket( shoppingBasketId, productId, quantity, null );
    }


    @Override
    public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity,
                                                  ResultMatcher expectedStatus ) throws Exception {
        ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
        ObjectMapper objectMapper = new ObjectMapper();
        QuantityDTO dto = new QuantityDTO( productId, quantity );
        String quantityJson = objectMapper.writeValueAsString( dto );
        mockMvc.perform( post( "/shoppingBaskets/" + shoppingBasketId + "/positions" )
                        .contentType( APPLICATION_JSON ).content( quantityJson ) )
                .andExpect( status );
    }



    @Override
    public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId )
            throws Exception {
        deleteProductFromShoppingBasket( shoppingBasketId, productId, null );
    }



    @Override
    public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId,
                                                      ResultMatcher expectedStatus ) throws Exception {
        ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
        String uri = "/shoppingBaskets/" + shoppingBasketId + "/positions/" + productId;
        mockMvc.perform( delete( uri ) ).andExpect( status );
    }


    @Override
    public void checkout( UUID shoppingBasketId, String expectedUserName,
                          ResultMatcher expectedStatus,
                          Map<UUID, Map<UUID, Integer>> expectedPurchases ) throws Exception {
        ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
        String uri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
        MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
        ObjectMapper objectMapper = new ObjectMapper();

        // check the response content
        if ( expectedPurchases != null || expectedUserName != null ) {
            String responseContent = result.getResponse().getContentAsString();
            log.info( "ShoppingBasketRESTHelperImpl - checkout: found response content " + responseContent );
            PurchaseDTO[] purchases = objectMapper.readValue( responseContent, PurchaseDTO[].class );
            checkExpectedUserName( expectedUserName, purchases );
            checkExpectedPurchases( expectedPurchases, purchases );
        }
    }


    private void checkExpectedUserName( String expectedUserName, PurchaseDTO[] purchases ) {
        if ( expectedUserName == null ) return;
        for ( PurchaseDTO purchase : purchases ) {
            if ( !purchase.getUserName().equals( expectedUserName ) ) {
                throw new AssertionError( "Expected userName '" + expectedUserName +
                        "' but got '" + purchase.getUserName() + "'" );
            }
        }
    }


    private void checkExpectedPurchases( Map<UUID, Map<UUID, Integer>> expectedPurchases,
                                            PurchaseDTO[] purchases ) {
        if ( expectedPurchases == null ) return;
        for ( PurchaseDTO purchase : purchases ) {
            UUID depotId = purchase.getDepotId();
            Map<UUID, Integer> expectedQuantities = expectedPurchases.get( depotId );
            if ( expectedQuantities == null ) {
                throw new AssertionError( "No expected quantities for depot " + depotId );
            }
            QuantityDTO[] positions = purchase.getPositions();
            for ( QuantityDTO quantityDTO : positions ) {
                UUID productId = quantityDTO.getProductId();
                Integer expectedQuantity = expectedQuantities.get( productId );
                if ( expectedQuantity == null ) {
                    throw new AssertionError( "No expected quantity for product " + productId +
                            " in depot " + depotId );
                }
                if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
                    throw new AssertionError( "Expected quantity " + expectedQuantity + " for product " +
                            productId + " in depot " + depotId +
                            ", but got " + quantityDTO.getQuantity() );
                }
            }
        }
    }


    /**
     * A DTO containing just a quantity, used in testing.
     * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
     * Therefore, constructors and getters/setters are manually defined.
     */
    @NoArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class QuantityDTO {
        private UUID productId;
        private Integer quantity;

        public QuantityDTO( UUID productId, Integer quantity ) {
            this.productId = productId;
            this.quantity = quantity;
        }
        public UUID getProductId() {
            return productId;
        }
        public Integer getQuantity() {
            return quantity;
        }
        public void setProductId( UUID productId ) {
            this.productId = productId;
        }
        public void setQuantity( Integer quantity ) {
            this.quantity = quantity;
        }
    }


    /**
     * A DTO containing just the id of an entity, used in testing.
     */
    @AllArgsConstructor
    @NoArgsConstructor
    @Getter
    @Setter
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class IdDTO {
        private UUID id;
    }


    /**
     * A DTO containing the purchase data, used in testing.
     * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
     * Therefore, constructors and getters/setters are manually defined.
     */
    @NoArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class PurchaseDTO {
        private UUID id;
        private String userName;
        private UUID depotId;
        private QuantityDTO[] positions;

        public UUID getId() {
            return id;
        }
        public String getUserName() {
            return userName;
        }
        public UUID getDepotId() {
            return depotId;
        }
        public QuantityDTO[] getPositions() {
            return positions;
        }
        public void setId( UUID id ) {
            this.id = id;
        }
        public void setUserName( String userName ) {
            this.userName = userName;
        }
        public void setDepotId( UUID depotId ) {
            this.depotId = depotId;
        }
        public void setPositions( QuantityDTO[] positions ) {
            this.positions = positions;
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingBasketRESTHelper.java ---
package thkoeln.archilab.ecommerce.helpers;

import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Map;
import java.util.UUID;

/**
 * A REST helper for shopping basket-related operations.
 * This interface defines methods to interact with a shopping basket via REST calls, such as querying, adding,
 * deleting, and checking out.
 */
public interface ShoppingBasketRESTHelper {
    /**
     * Executes a REST GET query on a shopping basket and returns its id, with the user's email address as a
     * starting point. The resulting shopping basket is checked against the given expected quantity map.
     * @param emailAddress The emailAddress of the user whose shopping basket is queried.
     * @param expectedQuantityMap A map of products and their quantities in the shopping basket. (If null, then don't check.)
     * @return The id of the user's shopping basket.
     * @throws Exception (whenever the REST call fails, or the shopping basket does not match the expected quantity map)
     */
    public UUID getQueryShoppingBasket( EmailAddressType emailAddress,
                                       Map<UUID, Integer> expectedQuantityMap ) throws Exception;


    /**
     * Adds a product to a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param productId Id of the product.
     * @param quantity Quantity of the product.
     * @throws Exception (whenever the REST call fails)
     */
    public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity )
            throws Exception;


    /**
     * Adds a product to a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param productId Id of the product.
     * @param quantity Quantity of the product.
     * @param expectedStatus expected status of the operation (null = CREATED)
     * @throws Exception (whenever the REST call fails or the status does not match)
     */
    public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity,
                                                  ResultMatcher expectedStatus ) throws Exception;


    /**
     * Deletes a product from a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param productId Id of the product.
     * @throws Exception (whenever the REST call fails)
     */
    public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId )
            throws Exception;


    /**
     * Deletes a product from a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param productId Id of the product.
     * @param expectedStatus expected status of the operation (null = OK)
     * @throws Exception (whenever the REST call fails or the status does not match)
     */
    public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId,
                                                      ResultMatcher expectedStatus ) throws Exception;


    /**
     * Checks out a shopping basket via REST call, and returns the id of the created purchase.
     * @param shoppingBasketId
     * @param expectedUserName expected name of the user who owns the shopping basket (null = don't check)
     * @param expectedStatus expected status of the operation (null = don't check)
     * @param expectedPurchases the expected purchases to be created as a result of the checkout. This is
     *                            a map of the following form:
     *                            <pre>
     *                               depotId -> Map<productId,Integer>
     *                            </pre>
     *                            where the inner map contains the products and their quantities
     * @return
     * @throws Exception
     */
    public void checkout( UUID shoppingBasketId, String expectedUserName,
                          ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedPurchases )
           throws Exception;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class BasicNoOutsideSolutionRulesTest {

    @ArchTest
    static final ArchRule noClassesOnTopLevel =
            classes().should().resideInAPackage( "..solution.*.." )
                    .allowEmptyShould( true );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.library.Architectures.layeredArchitecture;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln")
@SuppressWarnings("PMD")
public class BasicProperDependenciesTest {

    @ArchTest
    static final ArchRule properDependencies =
            layeredArchitecture()
                    .consideringAllDependencies()
                    //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
                    .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
                    .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )

                    //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
                    .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
                    .allowEmptyShould( true );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import org.junit.jupiter.api.Test;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.MetadataReaderFactory;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertTrue;

public class BasicRequiredClassesTest {
    private static final String[] REQUIRED_CLASSES = {
            "User",
            "UserRepository",
            "Product",
            "ProductRepository",
            "Purchase",
            "PurchaseRepository",
            "StockLevel",
            "ShoppingBasket",
            "ShoppingBasketRepository",
            "DepotRepository",
            "ShoppingBasketPosition",
            "PurchasePosition",
            "Depot",
    };

    @Test
    public void testRequiredClassesDeclared() throws IOException {
        String basePackage = "thkoeln.archilab.ecommerce";
        String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";

        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );

        Set<String> foundClasses = new HashSet<>();

        Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
            try {
                MetadataReader reader = readerFactory.getMetadataReader( resource );
                foundClasses.add( reader.getClassMetadata().getClassName() );
            } catch (IOException e) {
                e.printStackTrace();
            }
        } );

        Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
            boolean found = foundClasses.stream().anyMatch(className ->
                    className.startsWith(basePackage) && className.endsWith("." + requiredClass)
            );
            assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
        });
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.ApplicationContext;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
public class BasicUseCaseImplementationPackageTest {

    @Autowired
    private ApplicationContext applicationContext;

    private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
        put("UserRegistrationUseCases", Arrays.asList("user"));
        put("DepotUseCases", Arrays.asList("depot"));
        put("ProductCatalogUseCases", Arrays.asList("product"));
        put("ShoppingBasketUseCases", Arrays.asList("shoppingbasket"));
        put("PurchaseUseCases", Arrays.asList("purchase"));
    }};
    private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
    private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";

    @Test
    public void testRequiredClassesDeclared() {
        for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
            String interfaceName = USECASE_PATH + "." + entry.getKey();
            List<String> correctTopLevelPackages = entry.getValue();
            Class<?> useCaseInterfaceClass = null;
            try {
                useCaseInterfaceClass = Class.forName( interfaceName );
            } catch (ClassNotFoundException e) {
                fail( "Use case interface " + interfaceName + " not found.", e );
                continue;
            }
            String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
            assertEquals( 1, beans.length,
                    "There should be exactly 1 service implementation for the interface " +
                            entry.getKey() + ", but found " + beans.length );
            Object bean = applicationContext.getBean( beans[0] );
            boolean isValid = false;
            for ( String correctTopLevelPackage : correctTopLevelPackages ) {
                String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
                if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
                    isValid = true;
                    break;
                }
            }
            assertTrue( isValid,
                    "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
                            + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Service;

import jakarta.persistence.Entity;
import org.springframework.web.bind.annotation.RestController;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class DDDRulesTest {

    @ArchTest
    static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
            noClasses().that().resideInAPackage( "..domain.." )
                    .should().dependOnClassesThat().resideInAPackage( "..application.." )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule entitiesMustResideInADomainPackage =
            classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
                    .as( "Entities must reside in a package '..domain..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule entitiesMustNotAccessRepositories =
            noClasses().that().areAnnotatedWith( Entity.class )
                    .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule repositoriesMustResideInADomainPackage =
            classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
                    .as( "Repositories must reside in a package '..domain..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule repositoryNamesMustHaveProperSuffix =
            classes().that().areAssignableTo( CrudRepository.class )
                    .should().haveSimpleNameEndingWith( "Repository" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule servicesMustResideInAnApplicationPackage =
            classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
                    .as( "Application Services must reside in a package '..application..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule serviceNamesMustHaveProperSuffix =
            classes().that().areAnnotatedWith( Service.class )
                    .should().haveSimpleNameEndingWith( "Service" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule controllersMustResideInAnApplicationPackage =
            classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
                    .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );

    @ArchTest
    static final ArchRule controllersNamesMustHaveProperSuffix =
            classes().that().areAnnotatedWith( RestController.class )
                    .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );

    @ArchTest
    static final ArchRule controllersMustNotAccessRepositories =
            noClasses().that().areAnnotatedWith( RestController.class )
                    .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
                    .allowEmptyShould( false );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.library.dependencies.SliceAssignment;
import com.tngtech.archunit.library.dependencies.SliceIdentifier;
import org.junit.jupiter.api.Test;

import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;

public class NoCycleTest {
    private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");

    private SliceAssignment inAllClasses() {
        return new SliceAssignment() {
            @Override
            public String getDescription() {
                return "every class in it's own slice";
            }

            @Override
            public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
                return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
            }
        };
    }

    @Test
    public void testNoCyclicDependenciesBetweenClasses() {
        slices().assignedFrom(inAllClasses())
                .namingSlices("$1[$2.$3]")
                .should().beFreeOfCycles()
                .check(importedClasses);
    }

    @Test
    public void testNoCyclicDependenciesBetweenPackages() {
        ArchRule rule = slices().matching("..solution.(*)..")
                .should().beFreeOfCycles().allowEmptyShould( true );
        rule.check(importedClasses);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.base.DescribedPredicate;
import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaField;
import com.tngtech.archunit.core.domain.JavaParameterizedType;
import com.tngtech.archunit.core.domain.JavaType;
import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchCondition;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.lang.ConditionEvents;
import com.tngtech.archunit.lang.SimpleConditionEvent;
import jakarta.persistence.*;
import lombok.extern.slf4j.Slf4j;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.List;

import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
@Slf4j
public class OnlyReferenceViaIDTest { //DEPOT
    private static final String SHOPPING_BASKET_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingbasket.domain";
    private static final String USER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.user.domain";
    private static final String PRODUCT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.product.domain";
    private static final String PURCHASE_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.purchase.domain";
    private static final String DEPOT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.depot.domain";

    @ArchTest
    static final ArchRule idFieldsMustUseGenericId =
            fields()
                    .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
                    .and().areAnnotatedWith( Id.class )
                    .should().haveRawType( assignableTo( GenericId.class ) )
                    .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
                    .allowEmptyShould( true );


    private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
            annotatedWith( ManyToOne.class )
                    .or( annotatedWith( OneToOne.class ) )
                    .or( annotatedWith( Embedded.class ) )
                    .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );

    private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
            annotatedWith( OneToMany.class )
                    .or( annotatedWith( ManyToMany.class ) )
                    .or( annotatedWith( ElementCollection.class ) )
                    .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );


    private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
        String description = "an entity or value object from same aggregate, or a domain primitive";
        return new DescribedPredicate<>( description ) {
            @Override
            public boolean test( JavaClass type ) {
                // check if the class is an entity or value object, and resides in the allowed package
                if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
                    return false;
                }
                // a GenericId is always allowed
                if ( type.isAssignableTo( GenericId.class ) ) {
                    return true;
                }
                // a domain primitive is also always allowed
                if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
                    return true;
                }
                return type.getPackageName().startsWith( allowedPackage );
            }
        };
    }


    @ArchTest
    static final ArchRule shoppingBasketToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule userToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( USER_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( USER_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule productToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( PRODUCT_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( PRODUCT_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule purchaseToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( PURCHASE_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( PURCHASE_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule depotToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( DEPOT_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( DEPOT_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );


    private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
        return new ArchCondition<JavaField>(
                "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
            @Override
            public void check( JavaField field, ConditionEvents events ) {
                JavaClass rawType = field.getRawType();
                String rawTypeName = rawType.getFullName();
                if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
                    return;
                }
                JavaType fieldType = field.getType();
                if ( !( fieldType instanceof JavaParameterizedType ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " is a raw List/Set without a type argument" ) );
                    return;
                }
                List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
                if ( typeArguments.isEmpty() ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " has no type arguments" ) );
                    return;
                }
                JavaType elementType = typeArguments.get( 0 );
                if ( !( elementType instanceof JavaClass ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " has an unknown element type" ) );
                    return;
                }
                JavaClass elementClass = (JavaClass) elementType;
                boolean hasAnnotation =
                        elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
                boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
                boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
                boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
                boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
                if ( !ok ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " refers to " + elementClass.getFullName()
                                    + " which is not a DP, or an entity/value object in " + allowedPackage ) );
                }
            }
        };
    }


    @ArchTest
    static final ArchRule shoppingBasketToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule userToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( USER_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( USER_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule productToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( PRODUCT_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( PRODUCT_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule purchaseToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( PURCHASE_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( PURCHASE_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule depotToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( DEPOT_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( DEPOT_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

/**
 * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
 */

public class OwnTestsTest {
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

public class PackageStructureTest {

    private static final String[] REQUIRED_PACKAGES = {"user", "shoppingbasket", "product", "purchase", "depot"};
    private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
    private JavaClasses importedClasses;


    @BeforeEach
    public void setUp() {
        importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
    }

    @Test
    void testRequiredPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage;
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredDomainPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected domain sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredApplicationPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected application sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\depot\DepotManagementTest.java ---
package thkoeln.archilab.ecommerce.tests.depot;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.DepotTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.DepotUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePostalCode;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;


/**
 * This test checks the management and lifecycle of depots.
 */
@SpringBootTest
public class DepotManagementTest {
    @Autowired
    private DepotUseCases depotUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private DepotTestHelper depotTestHelper;

    private PhysicalAddressType somePhysicalAddress;
    private UUID nonExistingId1;
    private UUID nonExistingId2;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        productTestHelper.addAllProducts();

        somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
                instantiatePostalCode( "90001" ) );
        nonExistingId1 = UUID.randomUUID();
        nonExistingId2 = UUID.randomUUID();
    }


    @Test
    public void testAddInvalidDepot() {
        // given
        String name = "Lager1";

        // when
        // then
        assertThrows( ShopException.class,
                () -> depotUseCases.addNewDepot(
                        null, somePhysicalAddress ) );
        assertThrows( ShopException.class,
                () -> depotUseCases.addNewDepot(
                        "", somePhysicalAddress ) );
        assertThrows( ShopException.class,
                () -> depotUseCases.addNewDepot(
                        name, null ) );
    }


    @Test
    public void testDeleteAllDepotsWhenEmpty() {
        // given
        depotTestHelper.addAllDepots( false );
        UUID productId9 = productTestHelper.getProductId( 9 );
        UUID depotId1 = depotTestHelper.getDepotId( 1 );
        UUID depotId2 = depotTestHelper.getDepotId( 2 );

        // when
        int numOf1 = depotUseCases.getAvailableStock( depotId1, productId9 );
        int numOf2 = depotUseCases.getAvailableStock( depotId2, productId9 );

        // then
        assertEquals( 0, numOf1 );
        assertEquals( 0, numOf2 );
        depotUseCases.deleteAllDepots();
        // ... ids must be invalid now
        assertThrows( ShopException.class,
                () -> depotUseCases.getAvailableStock( depotId1, productId9 ) );
        assertThrows( ShopException.class,
                () -> depotUseCases.getAvailableStock( depotId2, productId9 ) );
    }


    @Test
    public void testDeleteAllDepotsWhenFull() {
        // given
        depotTestHelper.addAllDepots( true );
        UUID productId7 = productTestHelper.getProductId( 7 );
        UUID depotId1 = depotTestHelper.getDepotId( 1 );
        UUID depotId2 = depotTestHelper.getDepotId( 2 );

        // when
        int numOf1 = depotUseCases.getAvailableStock( depotId1, productId7 );
        int numOf2 = depotUseCases.getAvailableStock( depotId2, productId7 );

        // then
        assertTrue( numOf1 == 3 );
        assertTrue( numOf2 == 3 );
        depotUseCases.deleteAllDepots();
        // ... ids must be invalid now
        assertThrows( ShopException.class,
                () -> depotUseCases.getAvailableStock( depotId1, productId7 ) );
        assertThrows( ShopException.class,
                () -> depotUseCases.getAvailableStock( depotId2, productId7 ) );
    }



    @Test
    public void testAddToStock() {
        // given
        depotTestHelper.addAllDepots( true );
        UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in depot 0
        UUID depotId0 = depotTestHelper.getDepotId( 0 );
        int originalStock5 =
                depotTestHelper.getDepotStock( 0, 5 );

        // when
        int stock5before = depotUseCases.getAvailableStock( depotId0, productId5 );
        depotUseCases.addToStock( depotId0, productId5, 23 );
        int stock5after = depotUseCases.getAvailableStock( depotId0, productId5 );
        depotUseCases.addToStock( depotId0, productId5, 0 );
        int stock5after2 = depotUseCases.getAvailableStock( depotId0, productId5 );

        // then
        assertEquals( originalStock5, stock5before );
        assertEquals( stock5before + 23, stock5after );
        assertEquals( stock5after, stock5after2 );
    }


    @Test
    public void testInvalidAddToStock() {
        // given
        depotTestHelper.addAllDepots( true );
        UUID productId2 = productTestHelper.getProductId( 2 );
        UUID depotId0 = depotTestHelper.getDepotId( 0 );

        // when
        // then
        assertThrows( ShopException.class,
                () -> depotUseCases.addToStock( nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> depotUseCases.addToStock(
                        depotId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> depotUseCases.addToStock(
                        nonExistingId1, productId2, 12 ) );
        assertThrows( ShopException.class,
                () -> depotUseCases.addToStock(
                        depotId0, productId2, -1 ) );
    }


    @Test
    public void testRemoveFromStock() {
        // given
        depotTestHelper.addAllDepots( true );
        UUID depotId0 = depotTestHelper.getDepotId( 0 );
        UUID productId0 = productTestHelper.getProductId( 0 ); // 0 in depot 0
        UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in depot 0
        UUID productId6 = productTestHelper.getProductId( 6 ); // random >30 in depot 0
        int stock0before =
                depotTestHelper.getDepotStock( 0, 0 );
        int stock5before =
                depotTestHelper.getDepotStock( 0, 5 );
        int stock6before =
                depotTestHelper.getDepotStock( 0, 6 );

        // when
        depotUseCases.removeFromStock( depotId0, productId5, 1 );
        int stock5after = depotUseCases.getAvailableStock( depotId0, productId5 );
        depotUseCases.removeFromStock( depotId0, productId0, 0 );
        int stock0after = depotUseCases.getAvailableStock( depotId0, productId0 );
        depotUseCases.removeFromStock(
                depotId0, productId6, stock6before );
        int stock6after = depotUseCases.getAvailableStock( depotId0, productId6 );

        // then
        assertEquals( stock5before - 1, stock5after );
        assertEquals( stock0before, stock0after );
        assertEquals( 0, stock6after );
    }


    @Test
    public void testInvalidRemoveFromStock() {
        // given
        depotTestHelper.addAllDepots( true );
        UUID depotId0 = depotTestHelper.getDepotId( 0 );
        UUID productId0 = productTestHelper.getProductId( 0 ); // 0 in depot 0
        UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in depot 0
        int stock5before =
                depotTestHelper.getDepotStock( 0, 5 );

        // when
        // then
        assertThrows( ShopException.class,
                () -> depotUseCases.removeFromStock( nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> depotUseCases.removeFromStock(
                        depotId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> depotUseCases.removeFromStock(
                        nonExistingId1, productId5, 12 ) );
        assertThrows( ShopException.class,
                () -> depotUseCases.removeFromStock(
                        depotId0, productId5, -1 ) );
        assertThrows( ShopException.class,
                () -> depotUseCases.removeFromStock(
                        depotId0, productId5, stock5before + 1 ) );
        assertThrows( ShopException.class,
                () -> depotUseCases.removeFromStock(
                        depotId0, productId0, 1 ) ); // already 0 in depot 0
    }


    @Test
    public void testChangeStock() {
        // given
        depotTestHelper.addAllDepots( true );
        UUID depotId0 = depotTestHelper.getDepotId( 0 );
        UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in depot 0

        // when
        depotUseCases.changeStockTo( depotId0, productId5, 111 );
        int stock5after = depotUseCases.getAvailableStock( depotId0, productId5 );

        // then
        assertEquals( 111, stock5after );
    }


    @Test
    public void testInvalidChangeStock() {
        // given
        depotTestHelper.addAllDepots( true );
        UUID depotId0 = depotTestHelper.getDepotId( 0 );
        UUID productId6 = productTestHelper.getProductId( 6 );

        // when
        // then
        assertThrows( ShopException.class, () -> depotUseCases.changeStockTo(
                nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class, () -> depotUseCases.changeStockTo(
                nonExistingId1, productId6, 12 ) );
        assertThrows( ShopException.class, () -> depotUseCases.changeStockTo(
                depotId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class, () -> depotUseCases.changeStockTo(
                depotId0, productId6, -1 ) );
    }


    @Test
    public void testEmptyDepot() {
        // given
        depotTestHelper.addAllDepots( true );
        UUID depotId9 = depotTestHelper.getDepotId( 9 ); // empty depot

        // when
        int totalStock = 0;
        for ( int iProduct = 0; iProduct < productTestHelper.numberOfProducts(); iProduct++ ) {
            UUID productId = productTestHelper.getProductId( iProduct );
            totalStock += depotUseCases.getAvailableStock(
                    depotId9, productId );
        }

        // then
        assertEquals( 0, totalStock );
    }



}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\CurrencyTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateCurrency;

class CurrencyTest {

    @Test
    public void testGetQuantityCurrency() {
        // given
        Float inputQuantity = 10.0f;

        // when
        CurrencyType instance = instantiateCurrency( inputQuantity, "EUR" );

        // then
        assertEquals( inputQuantity, instance.getQuantity() );
    }

    @Test
    public void testGetCurrencyUnitCurrency() {
        // given
        String inputCurrencyUnit = "EUR";

        // when
        CurrencyType instance = instantiateCurrency( 10.0f, inputCurrencyUnit );

        // then
        assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
    }

    @Test
    public void testAddToCurrency() {
        // given
        CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
        CurrencyType instance3 = instantiateCurrency( 0.0f, "EUR" );

        // when
        CurrencyType result12 = instance1.add( instance2 );
        CurrencyType result13 = instance1.add( instance3 );

        // then
        assertEquals( 30.0f, result12.getQuantity() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
        assertEquals( 10.0f, result13.getQuantity() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
    }

    @Test
    public void testInvalidAddToCurrency() {
        // given
        CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 20.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
    }

    @Test
    public void testSubtractFromCurrency() {
        // given
        CurrencyType instance1 = instantiateCurrency( 30.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
        CurrencyType instance3 = instantiateCurrency( 0.0f, "EUR" );
        CurrencyType instance4 = instantiateCurrency( 30.0f, "EUR" );

        // when
        CurrencyType result12 = instance1.subtract( instance2 );
        CurrencyType result13 = instance1.subtract( instance3 );
        CurrencyType result14 = instance1.subtract( instance4 );

        // then
        assertEquals( 10.0f, result12.getQuantity() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
        assertEquals( 30.0f, result13.getQuantity() );
        assertEquals( "EUR", result13.getCurrencyUnit() );
        assertEquals( 0.0f, result14.getQuantity() );
        assertEquals( "EUR", result14.getCurrencyUnit() );
    }

    @Test
    public void testInvalidSubtractFromCurrency() {
        // given
        CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
        CurrencyType instance3 = instantiateCurrency( 5.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
        assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
    }

    @Test
    public void testMultiplyByCurrency() {
        // given
        CurrencyType instance = instantiateCurrency( 10.0f, "EUR" );

        // when
        CurrencyType result = instance.multiplyBy( 3 );

        // then
        assertEquals( 30.0f, result.getQuantity() );
        assertEquals( "EUR", result.getCurrencyUnit() );
    }

    @Test
    public void testFactoryValidCurrencyUnitCurrency() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiateCurrency( 10.0f, "EUR" ) );
    }

    @Test
    public void testFactoryInvalidCurrencyUnitCurrency() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateCurrency( -10.0f, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateCurrency( 10.0f, "USD" ) );
        assertThrows( ShopException.class, () -> instantiateCurrency( null, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateCurrency( 10.0f, null ) );
    }

    @Test
    public void testLargerThanCurrencyUnitCurrency() {
        // given
        CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
        CurrencyType instance3 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance4 = instantiateCurrency( 10.0f, "CHF" );

        // when
        // then
        assertTrue( instance2.largerThan( instance1 ) );
        assertFalse( instance1.largerThan( instance2 ) );
        assertFalse( instance1.largerThan( instance3 ) );
        assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
    }


    @Test
    public void testEqualityCurrencyUnitCurrency() {
        // given
        // when
        CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance3 = instantiateCurrency( 20.0f, "EUR" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutabilityCurrencyUnitCurrency() {
        // given
        // when
        CurrencyType instance = instantiateCurrency( 10.0f, "EUR" );

        // then
        try {
            instance.getClass().getMethod( "setQuantity", Float.class );
            fail( "setQuantity method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }

        try {
            instance.getClass().getMethod( "setCurrencyUnit", String.class );
            fail( "setCurrencyUnit method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

@ArchTag("domainPrimitivesUsageRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class DomainPrimitivesUsageRulesTest {
    private static final String EMAIL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.EmailAddress";
    private static final String CURRENCY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Currency";
    private static final String PHYSICAL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress";

    @ArchTest
    static final ArchRule userShouldReferenceEmailAddress =
            classes()
                    .that().haveSimpleName( "User" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( EMAIL_ADDRESS_CLASS )
                    .because( "User should use EmailAddress instead of String" );

    @ArchTest
    static final ArchRule userShouldReferencePhysicalAddress =
            classes()
                    .that().haveSimpleName( "User" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
                    .because( "User should use PhysicalAddress instead of whatever else" );

    @ArchTest
    static final ArchRule depotShouldReferencePhysicalAddress =
            classes()
                    .that().haveSimpleName( "Depot" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
                    .because( "User should use PhysicalAddress instead of whatever else" );

    @ArchTest
    static final ArchRule productShouldReferenceCurrency =
            classes()
                    .that().haveSimpleName( "Product" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( CURRENCY_CLASS )
                    .because( "Product should use Currency instead of float or whatever else" );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\EmailAddressTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmailAddress;

class EmailAddressTest {

    @Test
    public void testToStringEmailAddress() {
        // given
        String input = "test@example.com";

        // when
        EmailAddressType instance = instantiateEmailAddress( input );

        // then
        assertEquals( input, instance.toString() );
    }

    @Test
    public void testEqualityEmailAddress() {
        // given
        // when
        EmailAddressType instance1 = instantiateEmailAddress( "test@example.com" );
        EmailAddressType instance2 = instantiateEmailAddress( "test@example.com" );
        EmailAddressType instance3 = instantiateEmailAddress( "different@example.com" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutabilityEmailAddress() {
        // given
        // when
        EmailAddressType instance = instantiateEmailAddress( "test@example.com" );

        // then
        try {
            instance.getClass().getMethod( "setEmailAddress", String.class );
            fail( "setEmailAddress method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }



    @Test
    public void smokeTestForCopyConstructors() {
        // given
        EmailAddressType emailAddress =
                instantiateEmailAddress( "peter.schmidt@web.de" );

        // when
        EmailAddressType emailAddressOtherIdentifyer =
                emailAddress.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
        assertThrows( ShopException.class, () ->
                emailAddress.sameDomainDifferentIdentifyer( "p...eter" ) );
        EmailAddressType emailAddressOtherDomain =
                emailAddress.sameIdentifyerDifferentDomain( "web.ch" );
        assertThrows( ShopException.class, () ->
                emailAddress.sameIdentifyerDifferentDomain( "web.edu" ) );

        // then
        assertEquals( "p.e.t.e.r@web.de", emailAddressOtherIdentifyer.toString() );
        assertEquals( "peter.schmidt@web.ch", emailAddressOtherDomain.toString() );
    }


    @Test
    public void testFactoryValidEmailAddress() {
        // given
        // when
        // then
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "99Z@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "GGGhh@s77.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "a@4.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "Max.Hammer@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "Max.Gideon.Hammer@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.this.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.de" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.at" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.ch" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmailAddress( "test@example.org" ) );
    }


    @Test
    public void testFactoryInvalidEmailAddress() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateEmailAddress( null ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "testexample.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "Max..Gideon.Hammer@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@examplecom" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example..com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test#example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateEmailAddress( "test@example.42" ) );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\PhysicalAddressTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePostalCode;

class PhysicalAddressTest {

    @Test
    public void testGetterPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );

        // then
        assertEquals( street, instance.getStreet() );
        assertEquals( city, instance.getCity() );
        assertEquals( plz, instance.getPostalCode() );
    }

    @Test
    public void testFactoryValidPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        // then
        assertDoesNotThrow( () -> instantiatePhysicalAddress( street, city, plz ) );
    }

    @Test
    public void testFactoryInvalidPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        // then
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( null, city, plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( "", city, plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, null, plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, "", plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, city, null ) );
    }

    @Test
    public void testEqualityPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        PhysicalAddressType instance1 = instantiatePhysicalAddress( street, city, plz );
        PhysicalAddressType instance2 = instantiatePhysicalAddress( street, city, plz );
        PhysicalAddressType instance3 = instantiatePhysicalAddress( "Anderestr. 12", city, plz );
        PhysicalAddressType instance4 = instantiatePhysicalAddress( street, "AndereStadt", plz );
        PhysicalAddressType instance5 = instantiatePhysicalAddress( street, city, instantiatePostalCode( "54321" ) );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
        assertNotEquals( instance1, instance4 );
        assertNotEquals( instance1, instance5 );
    }

    @Test
    public void testImmutabilityPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );

        // then
        try {
            instance.getClass().getMethod( "setStreet", String.class );
            fail( "setStreet method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setCity", String.class );
            fail( "setCity method should not exist" );

        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setPostalCode", PostalCodeType.class );
            fail( "setPostalCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\PostalCodeTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePostalCode;

class PostalCodeTest {

    private String input1, input4;
    private PostalCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
            _04233, _02544, _99123, _56323, _79332;


    @BeforeEach
    public void setUp() {
        input1 = "12345";
        input4 = "49188";
        _12345 = FactoryMethodInvoker.instantiatePostalCode( "12345" );
        _12345b = FactoryMethodInvoker.instantiatePostalCode( "12345" );
        _23455 = FactoryMethodInvoker.instantiatePostalCode( "23455" );
        _01234 = FactoryMethodInvoker.instantiatePostalCode( "01234" );
        _01235 = FactoryMethodInvoker.instantiatePostalCode( "01235" );
        _01238 = FactoryMethodInvoker.instantiatePostalCode( "01238" );
        _01263 = FactoryMethodInvoker.instantiatePostalCode( "01263" );
        _01213 = FactoryMethodInvoker.instantiatePostalCode( "01213" );
        _01823 = FactoryMethodInvoker.instantiatePostalCode( "01823" );
        _01312 = FactoryMethodInvoker.instantiatePostalCode( "01312" );
        _04233 = FactoryMethodInvoker.instantiatePostalCode( "04233" );
        _02544 = FactoryMethodInvoker.instantiatePostalCode( "02544" );
        _99123 = FactoryMethodInvoker.instantiatePostalCode( "99123" );
        _56323 = FactoryMethodInvoker.instantiatePostalCode( "56323" );
        _79332 = FactoryMethodInvoker.instantiatePostalCode( "79332" );

    }


    @Test
    public void testToStringPostalCode() {
        // given
        // when
        PostalCodeType instance = instantiatePostalCode( input1 );

        // then
        assertEquals( input1, instance.toString() );
    }

    @Test
    public void testFactoryValidPostalCode() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiatePostalCode( input1 ) );
    }

    @Test
    public void testFactoryInvalidPostalCode() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiatePostalCode( "123456" ) );
        assertThrows( ShopException.class, () -> instantiatePostalCode( "1234" ) );
        assertThrows( ShopException.class, () -> instantiatePostalCode( "20000" ) );
        assertThrows( ShopException.class, () -> instantiatePostalCode( null ) );
    }

    @Test
    public void testEqualityPostalCode() {
        // given
        // when
        PostalCodeType instance1a = instantiatePostalCode( input1 );
        PostalCodeType instance1b = instantiatePostalCode( input1 );
        PostalCodeType instance4 = instantiatePostalCode( input4 );

        // then
        assertEquals( instance1a, instance1b );
        assertNotEquals( instance1a, instance4 );
    }

    @Test
    public void testImmutabilityPostalCode() {
        // given
        // when
        PostalCodeType instance = instantiatePostalCode( input1 );

        // then
        try {
            instance.getClass().getMethod( "setpostalCode", String.class );
            fail( "setpostalCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }


    @Test
    public void smokeTestForDistance() {
        // given
        PostalCodeType instance1a = instantiatePostalCode( input1 );
        PostalCodeType instance1b = instantiatePostalCode( input1 );
        PostalCodeType instance12479 = instantiatePostalCode( "12479" );
        PostalCodeType instance21456 = instantiatePostalCode( "21456" );

        // when
        int distanceAB = instance1a.distance( instance1b );
        int distance12 = instance1a.distance( instance12479 );
        int distance23 = instance12479.distance( instance21456 );

        // then
        assertEquals( 0, distanceAB );
        assertTrue( distance12 > 0 );
        assertTrue( distance23 > distance12 );
    }


    @Test
    public void testPostalCodeFirstDigit() {
        // given
        PostalCodeType instance1 = instantiatePostalCode( input1 );
        PostalCodeType instance4 = instantiatePostalCode( input4 );

        // when
        // then
        assertEquals( 1, instance1.getFirstDigitPostalCode() );
        assertEquals( 4, instance4.getFirstDigitPostalCode() );
    }



    @Test
    public void testInvalidParameters() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () ->
                _12345.distance( null ) );
    }


    @Test
    public void testSamePostalCode() {
        // given
        // when
        int diff = _12345.distance( _12345b );

        // then
        assertEquals( 0, diff );
    }


    /**
     *      - The distance is > 0 if both postal codes differ in the last digit, like 5673x
     *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
     *        So, 56733 and 56734 have the same distance as 56733 and 56739.
     *      - The distance grows if more digits (counted from the right side) differ.
     *        So, 5abcd and 5rstu have a larger distance than 53bcd and 53stu (if abcd
     *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
     *        53876 and 54876 have the same distance as 53876 and 57261.
     */
    @Test
    public void testPostalCodeDistanceInAllButFirstDigit() {
        // given
        // when
        int diff5a = _01234.distance( _01235 );
        int diff5b = _01234.distance( _01238 );
        int diff4a = _01234.distance( _01263 );
        int diff4b = _01234.distance( _01213 );
        int diff3a = _01234.distance( _01823 );
        int diff3b = _01234.distance( _01312 );
        int diff2a = _01234.distance( _04233 );
        int diff2b = _01234.distance( _02544 );

        // then
        assertEquals( diff5a, diff5b, "distance 01234-01235 must be the same as distance 01234-01238" );
        assertEquals( diff4a, diff4b, "distance 01234-01263 must be the same as distance 01234-01213" );
        assertEquals( diff3a, diff3b, "distance 01234-01823 must be the same as distance 01234-01312" );
        assertEquals( diff2a, diff2b, "distance 01234-04233 must be the same as distance 01234-02544" );

        assertTrue( diff5a < diff4a,
                "distance 01234-01235 must be smaller than distance 01234-01263" );
        assertTrue( diff4a < diff3a,
                "distance 01234-01263 must be smaller than distance 01234-01823" );
        assertTrue( diff3a < diff2a,
                "distance 01234-01823 must be smaller than distance 01234-04233" );
    }


    /**
     *      - However, the distance between 5abcd and 6rstu must be smaller than the one
     *        between 5abcd and 7rstu, and this distance in turn must be smaller than the
     *        one between 5abcd and 9rstu.
     *      - This last condition reflects the fact the first digits of a postal code marks a region
     *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
     *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
     *        other.
     */
    @Test
    public void testPostalCodedistanceInFirstDigit() {
        // given
        // when
        int diff1_1 = _01234.distance( _99123 );
        int diff1_2 = _01234.distance( _23455 );
        int diff1_5 = _01234.distance( _56323 );
        int diff1_3 = _01234.distance( _79332 );

        // then
        assertTrue( diff1_1 < diff1_2,
                "distance 01234-99123 must be smaller than distance 01234-23455"  );
        assertTrue( diff1_2 < diff1_3,
                "distance 01234-23455 must be smaller than distance 01234-79332" );
        assertTrue( diff1_3 < diff1_5,
                "distance 01234-79332 must be smaller than distance 01234-56323"  );
    }



}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
package thkoeln.archilab.ecommerce.tests.e1restcalls;

import org.junit.jupiter.api.Test;
import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;


public class E1RestCallTableTest {

    private GenericTableSpecificationTests genericTableSpecificationTests = null;


    public E1RestCallTableTest() {
        this.genericTableSpecificationTests = new GenericTableSpecificationTests();
    }

    @Test
    public void restTest() throws Exception {
        genericTableSpecificationTests.testTableSpecification("E1" );
    }
}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
package thkoeln.archilab.ecommerce.tests.owntests;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.jayway.jsonpath.JsonPath;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.domainprimitives.EmailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;

import static org.junit.jupiter.api.Assertions.assertEquals;


public class DomainPrimitiveJSONSerializationTest {

    @BeforeEach
    public void setUp() {
        // ... add own setup code here
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * EmailAddress.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_EmailAddress_Serialization() throws Exception {
        // given
        EmailAddress emailAddress = EmailAddress.of("max.mustermann@email.com");
        ObjectMapper mapper = new ObjectMapper();

        // when
        String json = mapper.writeValueAsString(emailAddress);

        // then
        String emailAddressString = JsonPath.read( json, "$.emailAddressString" );
        assertEquals( "max.mustermann@email.com", emailAddressString);
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * PostalCode.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_PostalCode_Serialization() throws Exception {
        // given
        PostalCode postalCode = PostalCode.of("40789");
        ObjectMapper mapper = new ObjectMapper();

        // when
        String json = mapper.writeValueAsString(postalCode);

        // then
        String postalCodeString = JsonPath.read( json, "$.postalCodeString" );
        assertEquals( "40789", postalCodeString);
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * PhysicalAddress.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_PhysicalAddress_Serialization() throws Exception {
        // given
        PostalCode newPostalCode = PostalCode.of("40789");
        PhysicalAddress physicalAddress = PhysicalAddress.of(
            "Musterstraße",
                "Monheim am Rhein",
                newPostalCode
        );
        ObjectMapper mapper = new ObjectMapper();

        // when
        String json = mapper.writeValueAsString(physicalAddress);

        // then
        String postalCodeString = JsonPath.read( json, "$.postalCode.postalCodeString" );
        String city = JsonPath.read( json, "$.city" );
        String street = JsonPath.read( json, "$.street" );

        assertEquals( "40789", postalCodeString);
        assertEquals( "Monheim am Rhein", city);
        assertEquals( "Musterstraße", street);
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * Currency.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_Currency_Serialization() throws Exception {
        // given
        Currency currency1 = Currency.of(19.99f, "EUR");
        Currency currency2 = Currency.of(0f, "CHF");
        ObjectMapper mapper = new ObjectMapper();

        // when
        String json1 = mapper.writeValueAsString(currency1);
        String json2 = mapper.writeValueAsString(currency2);

        // then
        Double amount1 = JsonPath.read( json1, "$.amount" );
        String unit1 = JsonPath.read( json1, "$.unit" );
        Double amount2 = JsonPath.read( json2, "$.amount" );
        String unit2 = JsonPath.read( json2, "$.unit" );

        assertEquals( 19.99f, amount1, 0.001f, "amount mismatch with delta 0.001f" );
        assertEquals( "EUR", unit1);
        assertEquals( 0f, amount2, 0.001f, "amount mismatch with delta 0.001f" );
        assertEquals( "CHF", unit2);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingBasketRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.owntests;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.application.ShoppingAdapterService;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.DepotTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertNotNull;


@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class OwnShoppingBasketRESTTest {
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private DepotTestHelper depotTestHelper;
    @Autowired
    private ShoppingAdapterService shoppingAdapterService;
    @Autowired
    private ShoppingBasketRESTHelper shoppingBasketRESTHelper;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        productTestHelper.addAllProducts();
        depotTestHelper.addAllDepots( true );

        // ... add own setup code here
    }


    /**
     * Provide a test that implements a simple call to the REST endpoint (3):
     * <pre>
     *     GET /shoppingBaskets?userId=<user id as uuid>
     * </pre>
     * - Use the {@link UserTestHelper} to obtain the email address
     *   of some example user.
     * - Use your shopping basket service to add entries to the shopping basket of that person.
     * - then use the `ShoppingBasketRESTHelper` to create the GET call, and check the results.
     * - (or do it by directly calling your REST controller, if you prefer)
     * @throws Exception
     */
    @Test
    public void test_getQuery_ShoppingBasket() throws Exception {
        // given
        EmailAddressType emailAddress9 = userTestHelper.getUserEmailAddress(9);

        // Direkte Nutzung – das ist wichtig für ArchUnit!
        String emailAsString = emailAddress9.toString();
        assertNotNull(emailAsString);

        UUID productId1 = productTestHelper.getProductId(1);
        int quantity1 = 1;
        UUID productId2 = productTestHelper.getProductId(2);
        int quantity2 = 1;
        UUID productId3 = productTestHelper.getProductId(3);
        int quantity3 = 1;

        Map<UUID, Integer> expectedQuantityMap = new HashMap<>();
        shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId1, quantity1);
        expectedQuantityMap.put(productId1, quantity1);
        shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId2, quantity2);
        expectedQuantityMap.put(productId2, quantity2);
        shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId3, quantity3);
        expectedQuantityMap.put(productId3, quantity3);

        // when
        // then
        assertDoesNotThrow(
                () -> shoppingBasketRESTHelper.getQueryShoppingBasket(
                        emailAddress9,
                        expectedQuantityMap
                )
        );
    }

    /**
     * Provide a test that implements the addition of one product to the shopping basket via
     * REST endpoint (6):
     * <pre>
     *     POST /shoppingBaskets/{shoppingBasket-Id}/positions
     * </pre>
     * You can test now "the other way around" as in test_getQuery_ShoppingBasket():
     * - Use `ShoppingBasketRESTHelper` to add products via REST, then use shopping basket service methods
     *   to check of the shopping basket contains the right stuff.
     * - (or do it by directly calling your REST controller, if you prefer)
     *
     * @throws Exception
     */
    @Test
    public void test_post_ShoppingBasketPositions() throws Exception {
        // given
        EmailAddressType emailAddress9 = userTestHelper.getUserEmailAddress(9);

        UUID productId1 = productTestHelper.getProductId(1);
        int quantity1 = 1;
        UUID productId2 = productTestHelper.getProductId(2);
        int quantity2 = 1;
        UUID productId3 = productTestHelper.getProductId(3);
        int quantity3 = 1;

        Map<UUID, Integer> expectedQuantityMap = new HashMap<>();

        shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId1, quantity1);
        expectedQuantityMap.put(productId1, quantity1);

        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket(emailAddress9, null);

        shoppingBasketRESTHelper.addProductToShoppingBasket(shoppingBasketId, productId2, quantity2);
        expectedQuantityMap.put(productId2, quantity2);
        shoppingBasketRESTHelper.addProductToShoppingBasket(shoppingBasketId, productId3, quantity3);
        expectedQuantityMap.put(productId3, quantity3);

        // when
        // then
        assertDoesNotThrow(
                () -> shoppingBasketRESTHelper.getQueryShoppingBasket(
                        emailAddress9,
                        expectedQuantityMap
                )
        );
    }



    /**
     * Provide a test that implements the deletion of one product in the shopping basket via
     * REST endpoint (10):
     * <pre>
     *     DELETE /shoppingBaskets/{shoppingBasket-Id}/positions/{product-Id}
     * </pre>
     * This should be just a slight variation of the test_post_ShoppingBasketPositions()
     * method, but instead of adding an product to the shopping basket, you delete it.
     *
     * @throws Exception
     */
    @Test
    public void test_delete_ShoppingBasketPositions() throws Exception {
        // given
        EmailAddressType emailAddress9 = userTestHelper.getUserEmailAddress(9);

        UUID productId1 = productTestHelper.getProductId(1);
        int quantity1 = 1;
        UUID productId2 = productTestHelper.getProductId(2);
        int quantity2 = 2;
        UUID productId3 = productTestHelper.getProductId(3);
        int quantity3 = 5;

        Map<UUID, Integer> expectedQuantityMap = new HashMap<>();
        shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId1, quantity1);
        expectedQuantityMap.put(productId1, quantity1);
        shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId2, quantity2);
        expectedQuantityMap.put(productId2, quantity2);
        shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId3, quantity3);
        expectedQuantityMap.put(productId3, quantity3);

        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket(emailAddress9, null);

        shoppingBasketRESTHelper.deleteProductFromShoppingBasket(shoppingBasketId, productId3);
        expectedQuantityMap.remove(productId3);
        shoppingBasketRESTHelper.deleteProductFromShoppingBasket(shoppingBasketId, productId1);
        expectedQuantityMap.remove(productId1);

        // when
        // then
        assertDoesNotThrow(
                () -> shoppingBasketRESTHelper.getQueryShoppingBasket(
                        emailAddress9,
                        expectedQuantityMap
                )
        );
    }



    /**
     * Provide a test that implements the checkout of a shopping basket that can be served
     * by just 1 depot, using the REST endpoint (11):
     * <pre>
     *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
     * </pre>
     * - Use your shopping basket service to add entries to the shopping basket of some example user,
     * - then use the `ShoppingBasketRESTHelper to post the checkout call, and to check the results.
     * - (or do it by directly calling your REST controller, if you prefer)
     *
     * @throws Exception
     */
    @Test
    public void test_checkout_1_depot() throws Exception {
        // given
        int userIndex = 9;
        EmailAddressType emailAddress9 = userTestHelper.getUserEmailAddress(userIndex);
        String userName9 = userTestHelper.getUserName(userIndex);

        UUID productId1 = productTestHelper.getProductId(1);
        int quantity1 = 10;
        int depotIndex = 0;
        UUID depotId = depotTestHelper.getDepotId(depotIndex);

        Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>();

        shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId1, quantity1);
        Map<UUID, Integer> products = new HashMap<>();
        products.put(productId1, quantity1);
        expectedPurchases.put(depotId, products);

        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket(emailAddress9, null);

        // when
        // then
        assertDoesNotThrow(
                () -> shoppingBasketRESTHelper.checkout(
                        shoppingBasketId,
                        userName9,
                        null,
                        expectedPurchases
                )
        );
    }



    /**
     * Provide a test that implements the checkout of a shopping basket that can only be served
     * by using 2 depots, using the REST endpoint (11):
     * <pre>
     *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
     * </pre>
     * This should be just a slight variation of thetest_checkout_1_depot() test.
     *
     * @throws Exception
     */
    @Test
    public void test_checkout_2_depots() throws Exception {
        // given
        int userIndex = 9;
        EmailAddressType emailAddress9 = userTestHelper.getUserEmailAddress(userIndex);
        String userName9 = userTestHelper.getUserName(userIndex);

        UUID productId1 = productTestHelper.getProductId(1);
        int quantity1 = 10;
        int depotIndex1 = 0;
        UUID depotId1 = depotTestHelper.getDepotId(depotIndex1);

        UUID productId12 = productTestHelper.getProductId(12);
        int quantity12 = 10;
        int depotIndex12 = 0;
        UUID depotId12 = depotTestHelper.getDepotId(depotIndex12);

        Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>();

        shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId1, quantity1);
        Map<UUID, Integer> products1 = new HashMap<>();
        products1.put(productId1, quantity1);
        expectedPurchases.put(depotId1, products1);

        shoppingAdapterService.addProductToShoppingBasket(emailAddress9, productId12, quantity12);
        Map<UUID, Integer> products12 = new HashMap<>();
        products12.put(productId12, quantity12);
        expectedPurchases.put(depotId12, products12);

        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket(emailAddress9, null);

        // when
        // then
        assertDoesNotThrow(
                () -> shoppingBasketRESTHelper.checkout(
                        shoppingBasketId,
                        userName9,
                        null,
                        expectedPurchases
                )
        );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\product\ProductCatalogTest.java ---
package thkoeln.archilab.ecommerce.tests.product;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.DepotUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.*;

import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;


@SpringBootTest
public class ProductCatalogTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private DepotUseCases depotUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private DepotTestHelper depotTestHelper;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        productTestHelper.addAllProducts();
    }


    @Test
    public void testAddProductToCatalog() {
        // given
        UUID productId4 = productTestHelper.getProductId( 4 );
        CurrencyType salesPrice4 = productTestHelper.getSalesPrice( 4 );

        // when
        CurrencyType foundSalesPrice = productCatalogUseCases.getSalesPrice( productId4 );

        // then
        assertEquals( salesPrice4, foundSalesPrice );
    }


    @Test
    public void testAddProductWithInvalidData() {
        // given
        String name = "SomeStuff";
        String description = "Some more explanation on the stuff";
        Float size = 5.0f;
        CurrencyType buyingPrice =
                FactoryMethodInvoker.instantiateCurrency( 5.0f, "EUR" );
        CurrencyType salesPrice =
                FactoryMethodInvoker.instantiateCurrency( 10.0f, "EUR" );
        CurrencyType tooLowSalesPrice =
                FactoryMethodInvoker.instantiateCurrency( 4.0f, "EUR" );

        // when / then
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        null, description, size, buyingPrice, salesPrice ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        "", description, size, buyingPrice, salesPrice ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        name, null, size, buyingPrice, salesPrice ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        name, "", size, buyingPrice, salesPrice ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        name, description, size, null, salesPrice ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        name, description, size, buyingPrice, null ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        name, description, size, buyingPrice, tooLowSalesPrice ) );
    }


    @Test
    public void testRemoveNonExistentProduct() {
        // given product 2 is not in stock anywhere - should be removable
        UUID nonExistentProductId = UUID.randomUUID();

        // when
        // then
        assertThrows( ShopException.class,
                () -> productCatalogUseCases.removeProductFromCatalog( nonExistentProductId ) );
    }


    @Test
    public void testRemoveProductWithNoStock() {
        // given product 0 is not in stock anywhere - should be removable
        UUID productId0 = productTestHelper.getProductId( 0 );
        depotTestHelper.addAllDepots( true );

        // when
        assertDoesNotThrow( () -> productCatalogUseCases.getSalesPrice( productId0 ) );
        productCatalogUseCases.removeProductFromCatalog( productId0 );

        // then
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.getSalesPrice( productId0 ) );
    }


    @Test
    public void testRemoveProductThatIsInStock() {
        // given
        depotTestHelper.addAllDepots( false );
        UUID depotId0 = depotTestHelper.getDepotId( 0 );
        UUID productId3 = productTestHelper.getProductId( 3 );
        UUID productId4 = productTestHelper.getProductId( 4 );
        depotUseCases.addToStock( depotId0, productId3, 3 );

        // then product 3 must not be removable, but product 4 must be removable
        assertThrows( ShopException.class,
                () -> productCatalogUseCases.removeProductFromCatalog( productId3 ) );
        assertDoesNotThrow( () -> productCatalogUseCases.removeProductFromCatalog( productId4 ) );
    }


    @Test
    public void testRemoveProductThatIsInPurchase() {
        // given
        depotTestHelper.addAllDepots( false );
        UUID depotId0 = depotTestHelper.getDepotId( 0 );
        UUID productId4 = productTestHelper.getProductId( 4 );
        EmailAddressType userEmailAddress4 =
                userTestHelper.getUserEmailAddress( 4 );
        depotUseCases.addToStock( depotId0, productId4, 4 );

        // when user 4 adds 4x product 4 to his shopping basket and checks out ...
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress4, productId4, 4 );
        shoppingBasketUseCases.checkout( userEmailAddress4 );

        // then product 4 must not be removable
        assertThrows( ShopException.class,
                () -> productCatalogUseCases.removeProductFromCatalog( productId4 ) );
    }


    @Test
    public void testClearProductCatalog() {
        // given
        UUID productId4 = productTestHelper.getProductId( 4 );

        // when
        productCatalogUseCases.deleteProductCatalog();

        // then
        assertThrows( ShopException.class, () -> productCatalogUseCases.getSalesPrice( productId4 ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\purchase\PurchaseTest.java ---
package thkoeln.archilab.ecommerce.tests.purchase;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.DepotTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;


@SpringBootTest
public class PurchaseTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private DepotUseCases depotUseCases;
    @Autowired
    private PurchaseUseCases purchaseUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private DepotTestHelper depotTestHelper;

    private UUID nonExistingId1;
    private UUID nonExistingId2;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        productTestHelper.addAllProducts();
        depotTestHelper.addAllDepots( true );
        nonExistingId1 = UUID.randomUUID();
        nonExistingId2 = UUID.randomUUID();
    }


    @Test
    public void testPurchaseHistory() {
        // given
        UUID productId1 = productTestHelper.getProductId( 1 );
        UUID productId2 = productTestHelper.getProductId( 2 );
        EmailAddressType userEmailAddress7 =
                userTestHelper.getUserEmailAddress( 7 );
        Map<UUID, Integer> purchaseHistoryBefore = purchaseUseCases.getPurchaseHistory( userEmailAddress7 );

        // when
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress7, productId1, 3 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress7, productId2, 2 );
        shoppingBasketUseCases.checkout( userEmailAddress7 );
        Map<UUID, Integer> purchaseHistory1 =
                purchaseUseCases.getPurchaseHistory( userEmailAddress7 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress7, productId1, 6 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress7, productId2, 2 );
        shoppingBasketUseCases.checkout( userEmailAddress7 );
        Map<UUID, Integer> purchaseHistory2 =
                purchaseUseCases.getPurchaseHistory( userEmailAddress7 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress7, productId1, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress7, productId2, 6 );
        shoppingBasketUseCases.checkout( userEmailAddress7 );
        Map<UUID, Integer> purchaseHistory3 =
                purchaseUseCases.getPurchaseHistory( userEmailAddress7 );

        // then
        assertEquals( 0, purchaseHistoryBefore.size() );
        assertEquals( 2, purchaseHistory1.size() );
        assertEquals( 2, purchaseHistory2.size() );
        assertEquals( 2, purchaseHistory3.size() );
        assertEquals( 3, purchaseHistory1.get( productId1 ) );
        assertEquals( 2, purchaseHistory1.get( productId2 ) );
        assertEquals( 9, purchaseHistory2.get( productId1 ) );
        assertEquals( 4, purchaseHistory2.get( productId2 ) );
        assertEquals( 10, purchaseHistory3.get( productId1 ) );
        assertEquals( 10, purchaseHistory3.get( productId2 ) );
    }


    @Test
    public void testForEmptyPurchaseHistory() {
        // given
        EmailAddressType userEmailAddress4 =
                userTestHelper.getUserEmailAddress( 4 );
        // when
        Map<UUID, Integer> purchaseHistory =
                purchaseUseCases.getPurchaseHistory( userEmailAddress4 );
        // then
        assertEquals( 0, purchaseHistory.size() );
    }


    @Test
    public void testInvalidParamsForGetPurchaseQuantOfProduct() {
        // given
        UUID depotId0 = depotTestHelper.getDepotId( 0 );

        // when / then
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantOfProduct( null, null ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantOfProduct( nonExistingId1, null ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantOfProduct( null, nonExistingId2 ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantOfProduct( nonExistingId1, nonExistingId2 ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantOfProduct( depotId0, null ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantOfProduct( depotId0, nonExistingId2 ) );
    }


    @Test
    public void testInvalidParamsForGetDepotIdForPurchase() {
        // given / when / then
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getDepotIdForPurchase( null ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getDepotIdForPurchase( nonExistingId1 ) );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\CheckoutAcceptanceTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingbasket;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.DepotTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * This test checks the management of stock across depots. It focuses on the
 * cases where more than one depot are needed to serve the shopping basket of a user.
 */
@Slf4j
@SpringBootTest
public class CheckoutAcceptanceTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private PurchaseUseCases purchaseUseCases;
    @Autowired
    private DepotUseCases depotUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private DepotTestHelper depotTestHelper;

    private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
                                map8_11_14_quantity_3_3_4,
                                map10_12_quantity_1_1, 
                                map11_quantity_1, 
                                map12_quantity_10,
                                map8_9_10_11_quantity_2_1_4_2;
    private EmailAddressType userEmailAddress3, userEmailAddress6,
            userEmailAddress2;
    private UUID productId8, productId9, productId10, productId11, productId12,
            productId14;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        productTestHelper.addAllProducts();
        depotTestHelper.addAllDepots( true );

        userEmailAddress3 = userTestHelper.getUserEmailAddress( 3 );
        userEmailAddress6 = userTestHelper.getUserEmailAddress( 6 );
        userEmailAddress2 = userTestHelper.getUserEmailAddress( 2 );

        productId8 = productTestHelper.getProductId( 8 );
        productId9 = productTestHelper.getProductId( 9 );
        productId10 = productTestHelper.getProductId( 10 );
        productId11 = productTestHelper.getProductId( 11 );
        productId12 = productTestHelper.getProductId( 12 );
        productId14 = productTestHelper.getProductId( 14 );

        map8_11_14_quantity_2_2_2 = new HashMap<>() {{
            put( productId8, 2 );
            put( productId11, 2 );
            put( productId14, 2 );
        }};
        map8_11_14_quantity_3_3_4 = new HashMap<>() {{
            put( productId8, 3 );
            put( productId11, 3 );
            put( productId14, 4 );
        }};
        map10_12_quantity_1_1 = new HashMap<>() {{
            put( productId10, 1 );
            put( productId12, 1 );
        }};
        map11_quantity_1 = new HashMap<>() {{
            put( productId11, 1 );
        }};
        map12_quantity_10 = new HashMap<>() {{
            put( productId12, 10 );
        }};
        map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
            put( productId8, 2 );
            put( productId9, 1 );
            put( productId10, 4 );
            put( productId11, 2 );
        }};

    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across depots, as specified in the DepotTestHelper and in the README file.
     */
    @Test
    public void testClosestSingleDepotWins() {
        log.info( "testClosestSingleDepotWins" );

        // given
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress3, productId8, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress3, productId11, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress3, productId14, 2 );
        // that basket could have been served from depot 4 or 7, but 4 is closer to the user
        UUID depotId4 = depotTestHelper.getDepotId( 4 );

        // when
        Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userEmailAddress3 );

        // then
        checkDepotIds( purchaseIds, depotId4 );
        checkProductNumbers( purchaseIds, depotId4, map8_11_14_quantity_2_2_2 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across depots, as specified in the DepotTestHelper and in the README file.
     */
    @Test
    public void testDepotWithEnoughCapacityWins() {
        log.info( "testDepotWithEnoughCapacityWins" );

        // given
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress3, productId8, 3 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress3, productId11, 3 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress3, productId14, 4 );
        // that basket could have been served from depot 4 or 7, 4 is closer to the user,
        // but only 7 has enough capacity
        UUID depotId7 = depotTestHelper.getDepotId( 7 );

        // when
        Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userEmailAddress3 );

        // then
        checkDepotIds( purchaseIds, depotId7 );
        checkProductNumbers( purchaseIds, depotId7, map8_11_14_quantity_3_3_4 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across depots, as specified in the DepotTestHelper and in the README file.
     */
    @Test
    public void testTwoDepots() {
        log.info( "testTwoDepots" );

        // given
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress6, productId10, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress6, productId11, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress6, productId12, 1 );
        // that basket needs two deliveries (2 + 1 products) anyway, and there
        // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
        // closer. The smaller can then be served from 4 (closest), 7, or 8.
        UUID depotId5 = depotTestHelper.getDepotId( 5 );
                // should cover map10_12_quantity_1_1
        UUID depotId4 = depotTestHelper.getDepotId( 4 );
                // should cover map11_quantity_1

        // when
        Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userEmailAddress6 );

        // then
        checkDepotIds( purchaseIds, depotId5, depotId4 );
        checkProductNumbers( purchaseIds, depotId5, map10_12_quantity_1_1 );
        checkProductNumbers( purchaseIds, depotId4, map11_quantity_1 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across depots, as specified in the DepotTestHelper and in the README file.
     */
    @Test
    public void testTwoBigDeliverys() {
        log.info( "testTwoBigDeliverys" );

        // given
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress2, productId8, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress2, productId9, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress2, productId10, 4 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress2, productId11, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress2, productId12, 10 );
        // when
        Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userEmailAddress2 );
        UUID depotId7 = depotTestHelper.getDepotId( 7 );
                // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 products
        UUID depotId5 = depotTestHelper.getDepotId( 5 );
                // should cover map12_quantity_10 - the only depot with enough capacity for 10 products

        // then
        checkDepotIds( purchaseIds, depotId7, depotId5 );
        checkProductNumbers( purchaseIds, depotId7, map8_9_10_11_quantity_2_1_4_2 );
        checkProductNumbers( purchaseIds, depotId5, map12_quantity_10 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across depots, as specified in the DepotTestHelper and in the README file.
     */
    @Test
    public void testOnlyOneSolution() {
        log.info( "testOnlyOneSolution" );

        // given
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress6, productId12, 10 );
        // when
        Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userEmailAddress6 );
        UUID depotId5 = depotTestHelper.getDepotId( 5 );
        // should cover map12_quantity_10 - the only depot with enough capacity for 10 products

        // then
        checkDepotIds( purchaseIds, depotId5 );
        checkProductNumbers( purchaseIds, depotId5, map12_quantity_10 );
    }



    private void checkProductNumbers( Set<UUID> purchaseIds, UUID depotId, Map<UUID, Integer> expectedMap ) {
        UUID fittingPurchaseId = null;
        for ( UUID purchaseId : purchaseIds ) {
            UUID foundDepotId = purchaseUseCases.getDepotIdForPurchase( purchaseId );
            if ( foundDepotId.equals( depotId ) ) {
                fittingPurchaseId = purchaseId;
                break;
            }
        }
        assertNotNull( fittingPurchaseId, "No fitting purchase found for depot " + depotId );

        int totalExpected = 0;
        int totalActual = 0;
        for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
            totalExpected += entry.getValue();
        }
        log.info( "Check purchase numbers for product {} in depot {}", fittingPurchaseId, depotId );
        for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
            UUID productId = entry.getKey();
            Integer foundNumber =
                    purchaseUseCases.getPurchaseQuantOfProduct( fittingPurchaseId, productId );
            assertEquals( entry.getValue(), foundNumber );
            totalActual += foundNumber;
        }
        // last check - do the total sums match?
        assertEquals( totalExpected, totalActual );
    }


    private void checkDepotIds( Set<UUID> purchaseIds, UUID... expectedDepotIds ) {
        assertEquals( expectedDepotIds.length, purchaseIds.size() );
        Set<UUID> foundDepotIds = new HashSet<>();
        for ( UUID purchaseId : purchaseIds ) {
            UUID depotId = purchaseUseCases.getDepotIdForPurchase( purchaseId );
            foundDepotIds.add( depotId );
        }
        for ( UUID expectedDepotId : expectedDepotIds ) {
            assertTrue( foundDepotIds.contains( expectedDepotId ) );
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingbasket;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.DepotUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.DepotTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmailAddress;


@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class ShoppingBasketRESTTest {
    @Autowired
    private DepotUseCases depotUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private DepotTestHelper depotTestHelper;
    @Autowired
    private MockMvc mockMvc;
    @Autowired
    private ShoppingBasketRESTHelper shoppingBasketRESTHelper;

    private EmailAddressType nonExistingEmailAddress;
    private final Map<UUID, Integer> emptyMap = new HashMap<>();

    private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
    private EmailAddressType
            userEmailAddress0,
            userEmailAddress3,
            userEmailAddress6,
            userEmailAddress8;
    private String userName0, userName8;
    private UUID productId0, productId1, productId2, productId3, productId5,
                 productId7, productId9, productId11, nonExistentProductId;
    private UUID depotId0, depotId3, depotId7, depotId8;


    private static final ResultMatcher NOT_FOUND = status().isNotFound();
    private static final ResultMatcher OK = status().isOk();
    private static final ResultMatcher CREATED = status().isCreated();
    private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
    private static final ResultMatcher CONFLICT = status().isConflict();

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        productTestHelper.addAllProducts();
        depotTestHelper.addAllDepots( true );
        nonExistingEmailAddress = instantiateEmailAddress( "harry@sally.de" );

        userEmailAddress0 = userTestHelper.getUserEmailAddress( 0 );
        userEmailAddress3 = userTestHelper.getUserEmailAddress( 3 );
        userEmailAddress6 = userTestHelper.getUserEmailAddress( 6 );
        userEmailAddress8 = userTestHelper.getUserEmailAddress( 8 );
        userName0 = userTestHelper.getUserName( 0 );
        userName8 = userTestHelper.getUserName( 8 );

        productId0 = productTestHelper.getProductId( 0 );
        productId1 = productTestHelper.getProductId( 1 );
        productId2 = productTestHelper.getProductId( 2 );
        productId3 = productTestHelper.getProductId( 3 );
        productId5 = productTestHelper.getProductId( 5 );
        productId7 = productTestHelper.getProductId( 7 );
        productId9 = productTestHelper.getProductId( 9 );
        productId11 = productTestHelper.getProductId( 11 );
        nonExistentProductId = UUID.randomUUID();

        depotId0 = depotTestHelper.getDepotId( 0 );
        depotId3 = depotTestHelper.getDepotId( 3 );
        depotId7 = depotTestHelper.getDepotId( 7 );
        depotId8 = depotTestHelper.getDepotId( 8 );

        map9_quantity_1 = new HashMap<>() {{
            put( productId9, 1 );
        }};
        map5_quantity_2 = new HashMap<>() {{
            put( productId5, 2 );
        }};
        map7_quantity_7 = new HashMap<>() {{
            put( productId7, 7 );
        }};
        map9_11_quantity_2_2 = new HashMap<>() {{
            put( productId9, 2 );
            put( productId11, 2 );
        }};
    }


    @Test
    public void testInvalidShoppingBasketBaseUris() throws Exception {
        // given
        String allShoppingBasketsUri = "/shoppingBaskets";
        String randomIdUri = "/shoppingBaskets/" + UUID.randomUUID();
        String randomUserUUID = "/shoppingBaskets?userId=" + UUID.randomUUID();
        String invalidUserUUID = "/shoppingBaskets?userId=invalidUUID";
        String randomParamUri = "/shoppingBaskets?randomParam=randomValue";

        // when
        // then
        mockMvc.perform( get( allShoppingBasketsUri ) ).andExpect( status().isMethodNotAllowed() );
        mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomUserUUID ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( invalidUserUUID ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
    }


    @Test
    public void testInvalidPositionUris() throws Exception {
        // given
        UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress8, emptyMap );
        String randomPositionUri = "/shoppingBaskets/" + shoppingBasketId8.toString() + "/random";
        String randomProductUri = "/shoppingBaskets/" + shoppingBasketId8.toString()
                + "/positions/" + UUID.randomUUID();

        // when
        // then
        mockMvc.perform( post( randomPositionUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( delete( randomProductUri ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testInvalidAddToShoppingBasket() throws Exception {
        // given
        Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
        expectedStartQuantityMap.put( productId2, 19 );

        // when
        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress0, emptyMap );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId, productId2, 6 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId, productId2, 13 );

        // then
        shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress0, expectedStartQuantityMap );

        // ... and check a couple of invalid cases
        shoppingBasketRESTHelper.addProductToShoppingBasket(
                shoppingBasketId, nonExistentProductId, 12, NOT_FOUND );
        shoppingBasketRESTHelper.addProductToShoppingBasket(
                UUID.randomUUID(), productId5, 12, NOT_FOUND );
        shoppingBasketRESTHelper.addProductToShoppingBasket(
                shoppingBasketId, productId5, -1, UNPROCESSABLE_ENTITY );

        // check if the shopping basket is still the same
        shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress0, expectedStartQuantityMap );
    }


    @Test
    public void testInvalidCheckout_unavailableProduct() throws Exception {
        // given
        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress0, emptyMap );

        // when
        // productId0 is not available in the requested quantity (or rather, not at all)
        shoppingBasketRESTHelper.addProductToShoppingBasket(
                shoppingBasketId, productId0, 1, CREATED );

        // check if the shopping basket is still the same
        shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
    }


    @Test
    public void testInvalidCheckout_tooLittleStock() throws Exception {
        // given
        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress0, emptyMap );

        // when
        // There are only 10 pieces of productId1 available
        shoppingBasketRESTHelper.addProductToShoppingBasket(
                shoppingBasketId, productId1, 11, CREATED );

        // check if the shopping basket is still the same
        shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
    }



    @Test
    public void testDeleteProductFromShoppingBasket() throws Exception {
        // given
        UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress6, emptyMap );
        Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
        expectedQuantityMap1.put( productId1, 1 );
        expectedQuantityMap1.put( productId2, 2 );
        expectedQuantityMap1.put( productId3, 3 );
        Map<UUID, Integer> quantityMap2 = new HashMap<>();
        quantityMap2.put( productId1, 1 );
        quantityMap2.put( productId3, 3 );

        // when
        // then
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId1, 1 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId2, 2 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId3, 3 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress6, expectedQuantityMap1 );

        shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId2 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress6, quantityMap2 );
    }


    @Test
    public void testNoDoubleDelete() throws Exception {
        // given
        UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress6, emptyMap );

        // when
        // then
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId3, 3 );
        shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId3 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress6, new HashMap<>() );
        shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId3, NOT_FOUND );
    }


    @Test
    public void testAddRemoveProductsFromAndToShoppingBasket() throws Exception {
        // given
        UUID shoppingBasketId3 = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress3, emptyMap );
        UUID shoppingBasketId5 = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress6, emptyMap );

        // when
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId1, 2 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId2, 3 );
        shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId3, productId1 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId1, 1 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId2, 6 );

        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId1, 2 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId2, 8 );
        shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId5, productId1 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId1, 1 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId2, 2 );

        // then
        // user3 has 1x productId1 and 9x productId2 expected in cart
        Map<UUID, Integer> expectedMap3 = new HashMap<>();
        expectedMap3.put( productId1, 1 );
        expectedMap3.put( productId2, 9 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress3, expectedMap3 );

        // user6 has 1x productId1 and 10x productId2 in cart
        Map<UUID, Integer> expectedMap5 = new HashMap<>();
        expectedMap5.put( productId1, 1 );
        expectedMap5.put( productId2, 10 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress6, expectedMap5 );
    }


    @Test
    public void testNoDoubleCheckout() throws Exception {
        // given
        UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( userEmailAddress8, emptyMap );

        // when
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId2, 3 );

        // then
        shoppingBasketRESTHelper.checkout( shoppingBasketId8, userName8, CREATED, null );
        shoppingBasketRESTHelper.checkout( shoppingBasketId8, null, CONFLICT, null );
    }


    @Test
    public void testCheckout_1_Purchase() throws Exception {
        // given:
        // User 0 wants to buy 1x product 9. This is in depot 5, 7, and 8. Out of these,
        // depot 8 with postal code 89250 is closest to user 0 with postal code 02314.
        Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>() {{
            put( depotId8, map9_quantity_1 );
        }};
        UUID shoppingBasketId0 = shoppingBasketRESTHelper.getQueryShoppingBasket(
                userEmailAddress0, null );
        int stock9before =
                depotUseCases.getAvailableStock( depotId8, productId9 );

        // when
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId0, productId9, 1 );
        shoppingBasketRESTHelper.checkout( shoppingBasketId0, userName0, CREATED, expectedPurchases );
        int stock9after =
                depotUseCases.getAvailableStock( depotId8, productId9 );

        // then
        assertEquals( 1, stock9before - stock9after );
    }


    @Test
    public void testCheckout_3_Purchase() throws Exception {
        // given:
        // User 8 (Felix Bauer) wants to buy 2x each of products 5, 9, 11; and 7x product 7.
        //       - products 9 and 11 can both be found in depots 7 and 8. Depots 7 (76532) is closer to
        //         the user (70173)
        //       - product 7 is available in depots 1, 2, and 3, but only depot 3 has enough stock.
        //       - product 5 is only available in depot 0.
        Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>() {{
            put( depotId0, map5_quantity_2 );
            put( depotId3, map7_quantity_7 );
            put( depotId7, map9_11_quantity_2_2 );
        }};
        UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket(
                userEmailAddress8, null );
        int stock5before =
                depotUseCases.getAvailableStock( depotId0, productId5 );
        int stock7before =
                depotUseCases.getAvailableStock( depotId3, productId7 );
        int stock9before =
                depotUseCases.getAvailableStock( depotId7, productId9 );
        int stock11before =
                depotUseCases.getAvailableStock( depotId7, productId11 );

        // when
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId5, 2 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId7, 7 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId9, 2 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId11, 2 );
        shoppingBasketRESTHelper.checkout( shoppingBasketId8, userName8, CREATED, expectedPurchases );
        int stock5after =
                depotUseCases.getAvailableStock( depotId0, productId5 );
        int stock7after =
                depotUseCases.getAvailableStock( depotId3, productId7 );
        int stock9after =
                depotUseCases.getAvailableStock( depotId7, productId9 );
        int stock11after =
                depotUseCases.getAvailableStock( depotId7, productId11 );

        // then
        assertEquals( 2, stock5before - stock5after );
        assertEquals( 7, stock7before - stock7after );
        assertEquals( 2, stock9before - stock9after );
        assertEquals( 2, stock11before - stock11after );
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingbasket;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.InsufficientStockException;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.DepotTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;


import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;

@SpringBootTest
public class ShoppingBasketTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private DepotUseCases depotUseCases;
    @Autowired
    private PurchaseUseCases purchaseUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private DepotTestHelper depotTestHelper;

    private EmailAddressType nonExistingEmailAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        productTestHelper.addAllProducts();

        nonExistingEmailAddress = instantiateEmailAddress( "this@nononono.de" );
    }


    @Test
    public void testInvalidAddToShoppingBasket() {
        // given
        UUID nonExistentProductId = UUID.randomUUID();
        UUID productId5 = productTestHelper.getProductId( 5 );
        UUID productId0 = productTestHelper.getProductId( 0 );
        EmailAddressType userEmailAddress0 =
                userTestHelper.getUserEmailAddress( 0 );
        depotTestHelper.addAllDepots( true );

        // then
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addProductToShoppingBasket(
                        nonExistingEmailAddress, productId0, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addProductToShoppingBasket(
                        null, productId0, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addProductToShoppingBasket(
                        userEmailAddress0, nonExistentProductId, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addProductToShoppingBasket(
                        userEmailAddress0, null, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addProductToShoppingBasket(
                        userEmailAddress0, productId5, -1 ) );
    }


    @Test
    public void testInvalidRemoveFromShoppingBasket() {
        // given
        UUID nonExistentProductId = UUID.randomUUID();
        UUID productId5 = productTestHelper.getProductId( 5 );
        UUID productId1 = productTestHelper.getProductId( 1 );
        UUID productId2 = productTestHelper.getProductId( 2 );
        depotTestHelper.addAllDepots( true );
        EmailAddressType userEmailAddress0 =
                userTestHelper.getUserEmailAddress( 0 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress0, productId1, 5 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress0, productId2, 15 );

        // when
        shoppingBasketUseCases.removeProductFromShoppingBasket(
                userEmailAddress0, productId1, 2 );
        shoppingBasketUseCases.removeProductFromShoppingBasket(
                userEmailAddress0, productId2, 4 );
        shoppingBasketUseCases.removeProductFromShoppingBasket(
                userEmailAddress0, productId2, 7 );
        // now we should have 3x productId1 and 4x productId2 in the shopping basket

        // then
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
                        userEmailAddress0, nonExistentProductId, 12 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
                        nonExistingEmailAddress, productId5, 12 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
                        userEmailAddress0, productId5, -1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
                        userEmailAddress0, productId1, 4 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
                        userEmailAddress0, productId2, 5 ) );
    }


    @Test
    public void testAddRemoveProductsFromAndToShoppingBasket() {
        // given
        UUID productId1 = productTestHelper.getProductId( 1 );
        UUID productId2 = productTestHelper.getProductId( 2 );
        EmailAddressType userEmailAddress3 =
                userTestHelper.getUserEmailAddress( 3 );
        EmailAddressType userEmailAddress5 =
                userTestHelper.getUserEmailAddress( 5 );

        // when user 3 ...
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress3, productId1, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress3, productId2, 3 );
        shoppingBasketUseCases.removeProductFromShoppingBasket(
                userEmailAddress3, productId1, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress3, productId1, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress3, productId2, 6 );
        Map<UUID, Integer> cart3 = shoppingBasketUseCases.getShoppingBasketAsMap( userEmailAddress3 );
        // user3 has 1x productId1 and 9x productId2 in cart

        // ... and when user 5 ...
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress5, productId1, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress5, productId2, 8 );
        shoppingBasketUseCases.removeProductFromShoppingBasket(
                userEmailAddress5, productId1, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress5, productId2, 2 );
        Map<UUID, Integer> cart5 = shoppingBasketUseCases.getShoppingBasketAsMap( userEmailAddress5 );
        // user5 has 1x productId1 and 10x productId2 in cart

        // then
        assertEquals( 2, cart3.size() );
        assertEquals( 1, cart3.get( productId1 ) );
        assertEquals( 9, cart3.get( productId2 ) );

        assertEquals( 2, cart5.size() );
        assertEquals( 1, cart5.get( productId1 ) );
        assertEquals( 10, cart5.get( productId2 ) );
    }


    @Test
    public void testShoppingBasketValue() {
        // given
        UUID productId3 = productTestHelper.getProductId( 3 );
        UUID productId6 = productTestHelper.getProductId( 6 );
        UUID productId8 = productTestHelper.getProductId( 8 );
        CurrencyType price3 = productTestHelper.getSalesPrice( 3 );
        CurrencyType price6 = productTestHelper.getSalesPrice( 6 );
        CurrencyType price8 = productTestHelper.getSalesPrice( 8 );
        EmailAddressType userEmailAddress3 =
                userTestHelper.getUserEmailAddress( 3 );

        // when
        shoppingBasketUseCases.addProductToShoppingBasket( userEmailAddress3, productId3, 3 );
        shoppingBasketUseCases.addProductToShoppingBasket( userEmailAddress3, productId6, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket( userEmailAddress3, productId8, 5 );
        // user3 has 3x productId3, 2x productId6 and 5x productId8 in cart
        CurrencyType cartValue = shoppingBasketUseCases.getShoppingBasketAsCurrencyValue( userEmailAddress3 );

        // then
        assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
                cartValue );
    }


    @Test
    public void testShoppingBasketValueInvalid() {
        // given
        // when
        // then
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.getShoppingBasketAsCurrencyValue( nonExistingEmailAddress ) );
    }


    @Test
    public void testUnsuccessfulCheckout() {
        // given user buying product 0 (which is not in stock), and user 1 buying product 1
        // in a bigger quantity (11) than available (10)
        depotTestHelper.addAllDepots( true );
        EmailAddressType userEmailAddress0 =
                userTestHelper.getUserEmailAddress( 0 );
        EmailAddressType userEmailAddress1 =
                userTestHelper.getUserEmailAddress( 1 );
        UUID productId0 = productTestHelper.getProductId( 0 );
        UUID productId1 = productTestHelper.getProductId( 1 );

        // when
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress0, productId0, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userEmailAddress1, productId1, 11 );

        // then
        assertThrows( InsufficientStockException.class,
                () -> shoppingBasketUseCases.checkout( userEmailAddress0 ) );
        assertThrows( InsufficientStockException.class,
                () -> shoppingBasketUseCases.checkout( userEmailAddress1 ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
package thkoeln.archilab.ecommerce.tests.testtests;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.domain.JavaMethod;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.web.bind.annotation.RestController;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingBasketRESTTest;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static org.springframework.test.util.AssertionErrors.assertTrue;

/**
 * This test checks if there are the appropriate tests in the test class(es) for domain
 * primitives.
 */

public class RulesForOwnTests {
    private JavaClass dpTestClass, restTestClass;
    private JavaClasses dpTestClasses, restTestClasses;
    private static final String DEPOT_DOMAIN_PACKAGE =
            "thkoeln.archilab.ecommerce.solution.depot.domain";
    private static final String DEPOT_CLASS_NAME =
            DEPOT_DOMAIN_PACKAGE + ".Depot";


    @BeforeEach
    public void setUp() throws Exception {
        dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
        restTestClass = new ClassFileImporter().importClass( OwnShoppingBasketRESTTest.class );

        dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
        restTestClasses = new ClassFileImporter().importClasses( OwnShoppingBasketRESTTest.class );
    }


    @Test
    public void ensureMinimumNumberOfTestMethods() {
        // given
        // when
        int dpTestMethodCount = getTestMethodCount( dpTestClass );
        int restTestMethodCount = getTestMethodCount( restTestClass );

        // then
        assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
                        + dpTestMethodCount,dpTestMethodCount >= 2 );
        assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
                        + restTestMethodCount, restTestMethodCount >= 5 );
    }

    private int getTestMethodCount( JavaClass testClass ) {
        int testMethodCount = 0;
        for ( JavaMethod method : testClass.getMethods() ) {
            if ( isTestMethod( method ) ) {
                testMethodCount++;
            }
        }
        return testMethodCount;
    }

    private boolean isTestMethod( JavaMethod method ) {
        return method.isAnnotatedWith( Test.class );
    }


    @Test
    public void dpTestsShouldReferenceTheRightClasses() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAssignableTo( PostalCodeType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( CurrencyType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( PhysicalAddressType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( EmailAddressType.class )
                .because( "DomainPrimitiveJSONSerializationTest should reference PostalCode, " +
                        "Currency, EmailAddress, and PhysicalAddress!" );
        rule.check( dpTestClasses );
    }


    @Test
    public void restTestsShouldReferenceEmailAddress() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAssignableTo( EmailAddressType.class )
                .because( "DepotComparatorUnitTest should reference EmailAddressType!" );
        rule.check( restTestClasses );
    }


    @Test
    public void restTestsShouldReferenceRESTControllers() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAnnotatedWith( RestController.class )
                .orShould().dependOnClassesThat()
                .areAssignableTo( ShoppingBasketRESTHelper.class )
                .because( "DepotComparatorUnitTest should call REST controllers! " +
                        "(either directly or via the ShoppingBasketRESTHelper REST helper)" );
        rule.check( restTestClasses );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\user\UserRegistrationTest.java ---
package thkoeln.archilab.ecommerce.tests.user;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;


@SpringBootTest
public class UserRegistrationTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;

    private EmailAddressType nonExistingEmailAddress;
    private PhysicalAddressType somePhysicalAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        nonExistingEmailAddress = instantiateEmailAddress( "this@nononono.de" );
        somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
                instantiatePostalCode( "90001" ) );
    }

    @Test
    public void testAllUsersRegistered() {
        // given
        userTestHelper.registerAllUsers();
        EmailAddressType emailAddress3 =
                userTestHelper.getUserEmailAddress( 3 );
        String name3 = userTestHelper.getUserName( 3 );
        PhysicalAddressType physicalAddress3 = userTestHelper.getUserPhysicalAddress( 3 );

        // when
        UserType user3 = userRegistrationUseCases.getUserData(
                emailAddress3 );

        // then
        Assertions.assertEquals( name3, user3.getName() );
        Assertions.assertEquals( emailAddress3, user3.getEmailAddress() );
        Assertions.assertEquals( physicalAddress3, user3.getPhysicalAddress() );
    }


    @Test
    public void testRegisterUserWithDuplicateEmailAddress() {
        // given
        userTestHelper.registerAllUsers();
        PhysicalAddressType physicalAddress5 = userTestHelper.getUserPhysicalAddress( 5 );
        EmailAddressType emailAddress5 =
                userTestHelper.getUserEmailAddress( 5 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.register( "Gandalf The Grey",
                        emailAddress5, physicalAddress5 ) );
    }


    @Test
    public void testRegisterUserWithDuplicateNameOrPhysicalAddress() {
        // given
        userTestHelper.registerAllUsers();
        EmailAddressType newEmailAddress =
                instantiateEmailAddress( "some@this.de" );
        PhysicalAddressType physicalAddress2 = userTestHelper.getUserPhysicalAddress( 2 );
        String name2 = userTestHelper.getUserName( 2 );

        // when
        // then
        assertDoesNotThrow( () ->
                userRegistrationUseCases.register( name2, newEmailAddress, physicalAddress2 ) );
    }


    @Test
    public void testRegisterUserWithInvalidData() {
        // given
        EmailAddressType emailAddress5 =
                userTestHelper.getUserEmailAddress( 5 );
        PhysicalAddressType physicalAddress5 = userTestHelper.getUserPhysicalAddress( 5 );
        String name5 = userTestHelper.getUserName( 5 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.register( null, emailAddress5, physicalAddress5 ) );
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.register("", emailAddress5, physicalAddress5 ) );
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.register( name5, null, physicalAddress5 ) );
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.register( name5, emailAddress5, null ) );
    }


    @Test
    public void testChangeAddressWithInvalidData() {
        // given
        userTestHelper.registerAllUsers();
        PhysicalAddressType physicalAddress7 = userTestHelper.getUserPhysicalAddress( 7 );
        EmailAddressType emailAddress7 =
                userTestHelper.getUserEmailAddress( 7 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.changeAddress( nonExistingEmailAddress, physicalAddress7 ) );
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.changeAddress( null, physicalAddress7 ) );
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.changeAddress( emailAddress7, null ) );
    }


    @Test
    public void testGetDataForNonexistingEmailAddress() {
        // given
        userTestHelper.registerAllUsers();

        // when
        // then
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.getUserData( nonExistingEmailAddress ) );
    }


    @Test
    public void testDeleteUsersNoMoreUsers() {
        // given
        userTestHelper.registerAllUsers();
        EmailAddressType emailAddress0 =
                userTestHelper.getUserEmailAddress( 0 );


        // when
        userRegistrationUseCases.deleteAllUsers();

        // then
        assertThrows( ShopException.class, () -> userRegistrationUseCases.getUserData(
                emailAddress0 ) );
    }


    @Test
    public void testChangeAddressSuccessful() {
        // given
        userTestHelper.registerAllUsers();
        EmailAddressType emailAddress6 =
                userTestHelper.getUserEmailAddress( 6 );

        // when
        userRegistrationUseCases.changeAddress( emailAddress6, somePhysicalAddress );
        UserType newUser6 =
                userRegistrationUseCases.getUserData( emailAddress6 );

        // then
        Assertions.assertEquals( emailAddress6, newUser6.getEmailAddress() );
        Assertions.assertEquals( somePhysicalAddress, newUser6.getPhysicalAddress() );
    }


    @Test
    public void testChangeAddressForNonexistingEmailAddress() {
        // given
        userTestHelper.registerAllUsers();

        // when
        // then
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.changeAddress( nonExistingEmailAddress, somePhysicalAddress ) );
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\test\java\thkoeln\archilab\ecommerce\tests\user\UserRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.user;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.web.servlet.MockMvc;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.*;

import java.util.UUID;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class UserRESTTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private MockMvc mockMvc;

    private UUID randomId;
    private EmailAddressType nonExistingEmailAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();

        nonExistingEmailAddress = FactoryMethodInvoker.instantiateEmailAddress(
                "harry@sally.de" );
        randomId = UUID.randomUUID();
    }


    @Test
    public void testInvalidUserUris() throws Exception {
        // given
        String allUsersUri = "/users";
        String randomIdUri = "/users/" +  randomId;
        String nonExistingEmailAddressUri = "/users?emailAddress=" + nonExistingEmailAddress;
        String randomParamUri = "/users?randomParam=randomValue";

        // when
        // then
        mockMvc.perform( get( allUsersUri ) ).andExpect( status().isMethodNotAllowed() );
        mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( nonExistingEmailAddressUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
    }


    @Test
    public void testRandomUserId() throws Exception {
        // given
        String invalidUri = "/users/" +  randomId;

        // when
        // then
        mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testQueryUser() throws Exception {
        // given
        EmailAddressType emailAddress4 =
                userTestHelper.getUserEmailAddress( 4 );
        String userUri4 = "/users?emailAddress=" + emailAddress4;

        // when
        UserType user4 = userRegistrationUseCases.getUserData( emailAddress4 );
        String name = userTestHelper.getUserName( 4 );
        PhysicalAddressType physicalAddress4 = userTestHelper.getUserPhysicalAddress( 4 );

        // then (check using JSONPath)
        mockMvc.perform( get( userUri4 ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.name" ).value( name ) )
                // id is position 0 (cannot be tested with current API structure), name is position 1,
                // email address is 2, physical address is 3)
                .andExpect( jsonPath( "$..emailAddressString" ).value( emailAddress4.toString() ) )
                .andExpect( jsonPath( "$..city" ).value( physicalAddress4.getCity() ) )
                .andExpect( jsonPath( "$..postalCodeString" ).value(
                        physicalAddress4.getPostalCode().toString() ) );
    }

}


[RESPONSE]:
# Code Review Ergebnisse

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Currency.java

[Currency] [Zeile 89-92]: **dead code** : Die Methode `isValidCurrency` ist `public static`, wird aber nur intern in der `of`-Methode verwendet. Sie könnte `private` sein oder entfernt werden, falls sie nicht extern benötigt wird.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\Address.java

[Address] [Zeilen 11-24]: **dead code** : Die Klasse `Address` wird nirgendwo im Code verwendet. `Depot` nutzt stattdessen `PhysicalAddress`.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\DepotIdConverter.java

[DepotIdConverter] [Zeile 7]: **dead code** : Import von `UserId` ist ungenutzt.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\application\DepotService.java

[DepotService] [Zeilen 146-156]: **dead code** : Die Methoden `validateFromToDigitRange` und `validatePostalCodeDigit` werden nie aufgerufen.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingService.java

[ShoppingService] [Zeilen 79-105 und 107-135]: **Duplication** [Original: Zeilen 79-105] : Die Methoden `addProductToShoppingBasket(EmailAddressType, ProductId, int)` und `addProductToShoppingBasket(UUID, ShoppingBasketPositionDTO)` enthalten nahezu identische Logik für das Hinzufügen von Produkten zum Warenkorb.

[ShoppingService] [Zeilen 137-173 und 174-189]: **Duplication** [Original: Zeilen 137-173] : Die Methoden `removeProductFromShoppingBasket(EmailAddressType, ProductId, int)` und `removeProductFromShoppingBasket(ShoppingBasketId, ProductId)` enthalten duplizierte Logik.

[ShoppingService] [Zeilen 223-270 und 271-306]: **Duplication** [Original: Zeilen 223-270] : Die beiden `checkout`-Methoden (`checkout(EmailAddress)` und `checkout(ShoppingBasketId)`) haben nahezu identische Implementierungen mit nur unterschiedlicher Initialisierung.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingApplicationService.java

[ShoppingApplicationService] [Zeile 24]: **dead code** : Der Parameter `ShoppingService shoppingService` im Konstruktor wird nicht verwendet.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java

[ShoppingBasketPosition] [Zeile 6]: **dead code** : Import von `Currency` ist ungenutzt.

[ShoppingBasketPosition] [Zeile 8]: **dead code** : Import von `CurrencyType` ist ungenutzt.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketRepository.java

[ShoppingBasketRepository] [Zeile 16]: **dead code** : Die Methode `getShoppingBasketById` ist redundant zu `findShoppingBasketById` (gleiche Funktionalität).

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserService.java

[UserService] [Zeilen 45-56]: **dead code** : Die Methode `updateUserById` ruft `updateUser` auf, aber `updateUser` speichert nicht via Repository – damit gehen Änderungen verloren. Zudem wird `updateUserById` nicht aufgerufen.

[UserService] [Zeilen 58-65]: **dead code** : Die Methode `updateUserNameById` wird nie aufgerufen.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserController.java

[UserController] [Zeilen 120-123]: **dead code** : Die private Methode `nullThrow` wird nie aufgerufen.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseAdapterService.java

[PurchaseAdapterService] [Zeile 7]: **dead code** : Import von `ShopException` ist ungenutzt.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java

[ShoppingBasketController] [Zeile 122]: **layer violation** : Der Controller greift direkt auf `PurchaseService` zu, der zur `purchase`-Domäne gehört. Dies sollte über einen eigenen Application Service im `shoppingbasket`-Paket abstrahiert werden.

[ShoppingBasketController] [Zeile 123]: **layer violation** : Der Controller greift direkt auf `UserService` zu, der zur `user`-Domäne gehört.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingService.java

[ShoppingService] [Zeilen 14-18]: **layer violation** : `ShoppingService` importiert und verwendet direkt `PurchaseRepository` aus dem `purchase`-Paket. Dies ist ein Zugriff auf die Domänenschicht eines anderen Pakets.

[ShoppingService] [Zeile 49]: **shared persistency** : Direkter Zugriff auf `PurchaseRepository` aus der `purchase`-Domäne. Die Persistenz sollte über einen Service im `purchase`-Paket erfolgen.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseService.java

[PurchaseService] [Zeilen 5-8]: **layer violation** : `PurchaseService` importiert und verwendet `UserService` aus dem `user`-Paket direkt. Die Kopplung sollte über ein Interface erfolgen.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\application\DepotService.java

[DepotService] [Zeile 6]: **layer violation** : `DepotService` importiert und verwendet `ProductService` aus dem `product`-Paket direkt. Die Kopplung sollte über ein Interface analog zu `DepotableServiceInterface` erfolgen.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\Product.java

- **Anemic Entity** : Die Klasse `Product` enthält nur Getter/Setter und keine Geschäftslogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\depot\domain\StockLevel.java

- **Anemic Entity** : Die Klasse `StockLevel` enthält nur Getter/Setter und keine Geschäftslogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePosition.java

- **Anemic Entity** : Die Klasse `PurchasePosition` enthält nur Getter/Setter und keine Geschäftslogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java

- **Anemic Entity** : Die Klasse `ShoppingBasketPosition` enthält nur Getter/Setter und keine Geschäftslogik.

---

## C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_459e83ee-ce50-47b6-8983-fe1c7a14524e\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\User.java

- **Anemic Entity** : Die Klasse `User` enthält nur Getter/Setter und keine Geschäftslogik.

ENDE
Generated by claude-opus-4-5-20251101
-----------------------------------