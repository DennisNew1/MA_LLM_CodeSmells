--- DATE: 8.1.2026, 21:11:03 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
    Architektur: 4-Layer (Eric Evans).
    Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
    Regeln:
    1. Begründe kurz jeden Fund.
    4. Gruppiere nach Datei (mit Pfad). 
    2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
    3. Keine Code-Wiederholung, nur Referenzen.
    5. Wenn fertig, schreibe "ENDE".



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Email.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.Embeddable;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.ShopException;

@Embeddable
public class Email implements EmailType {
    @JsonProperty
    private final String email;

    // Parameterloser Konstruktor für JPA
    protected Email() {
        this.email = null; // Platzhalter-Wert, wird durch JPA/Hibernate überschrieben
    }

    private Email(String email) {
        this.email = email;
    }

    @JsonCreator
    public static Email of(@JsonProperty("email") String emailAsString) {
        validateEmail(emailAsString);
        return new Email(emailAsString);
    }

    private static void validateEmail(String email) throws ShopException {
        if (email == null) {
            throw new ShopException("Email cannot be null");
        }
        String[] parts = email.split("@");
        if (parts.length != 2) {
            throw new ShopException("Email must contain exactly one '@' character");
        }

        String identifier = parts[0];
        String domain = parts[1];

        if (!isValidIdentifier(identifier)) {
            throw new ShopException("Invalid identifier");
        }

        if (!isValidDomain(domain)) {
            throw new ShopException("Invalid domain");
        }
    }

    private static boolean isValidDomain(String domain) {
        if (domain.isEmpty() || domain.contains("..")) {
            return false;
        }
        String[] domainParts = domain.split("\\.");
        if (domainParts.length < 2) {
            return false;
        }
        String topLevelDomain = domainParts[domainParts.length - 1];
        if (!(topLevelDomain.equals("de") || topLevelDomain.equals("at") || topLevelDomain.equals("ch")
                || topLevelDomain.equals("com") || topLevelDomain.equals("org"))) {
            return false;
        }
        for (String part : domainParts) {
            if (!part.matches("[A-Za-z0-9]+")) {
                return false;
            }
        }
        return true;
    }

    private static boolean isValidIdentifier(String identifier) {
        if (identifier.isEmpty() || identifier.contains("..") || identifier.contains(" ")) {
            return false;
        }
        String[] identifierParts = identifier.split("\\.");
        for (String part : identifierParts) {
            if (!part.matches("[A-Za-z0-9]+")) {
                return false;
            }
        }
        return true;
    }

    @Override
    public String toString() {
        return email;
    }

    @Override
    public EmailType sameIdentifyerDifferentDomain(String domainString) throws ShopException {
        if (domainString == null || !isValidDomain(domainString)) {
            throw new ShopException("Invalid domain");
        }
        String[] parts = email.split("@");
        String newEmail = parts[0] + "@" + domainString;
        return Email.of(newEmail);
    }

    @Override
    public EmailType sameDomainDifferentIdentifyer(String identifyerString) throws ShopException {
        if (identifyerString == null || !isValidIdentifier(identifyerString)) {
            throw new ShopException("Invalid identifier");
        }
        String[] parts = email.split("@");
        String newEmail = identifyerString + "@" + parts[1];
        return Email.of(newEmail);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Email email1 = (Email) obj;
        return email.equals(email1.email);
    }

    @Override
    public int hashCode() {
        return email.hashCode();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\EmailDTO.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

public class EmailDTO {
    private String emailString;

    public EmailDTO(String emailString) {
        this.emailString = emailString;
    }

    // Getter method
    public String getEmailString() { return emailString; }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.ShopException;

@Embeddable
public class Money implements MoneyType {
    private final Float amount;

    @Column(insertable = false, updatable = false)
    private final String currencyUnit;

    // Parameterloser Konstruktor für JPA/Hibernate
    protected Money() {
        // Default-Werte setzen; keine Initialisierung finaler Felder erlauben.
        this.amount = null;
        this.currencyUnit = null;
    }

    private Money(Float amount, String currencyUnit) {
        this.amount = amount;
        this.currencyUnit = currencyUnit;
    }

    public static Money of(Float amount, String currencyUnit) throws ShopException {
        if (amount == null || amount < 0) {
            throw new ShopException("Invalid amount");
        }
        if (currencyUnit == null || !(currencyUnit.equals("EUR") || currencyUnit.equals("CHF"))) {
            throw new ShopException("Invalid currency unit");
        }
        return new Money(amount, currencyUnit);
    }

    @Override
    public Float getAmount() {
        return amount;
    }

    @Override
    public String getCurrencyUnit() {
        return currencyUnit;
    }

    @Override
    public MoneyType add(MoneyType otherMoney) throws ShopException {
        String thisCurrency = (currencyUnit != null) ? currencyUnit : "EUR"; // Standardwährung
        String otherCurrency = (otherMoney.getCurrencyUnit() != null) ? otherMoney.getCurrencyUnit() : "EUR"; // Standardwährung

        if (otherMoney == null || !thisCurrency.equals(otherCurrency)) {
            throw new ShopException("Invalid add operation");
        }
        return new Money(amount + otherMoney.getAmount(), thisCurrency);
    }

    @Override
    public MoneyType subtract(MoneyType otherMoney) throws ShopException {
        if (otherMoney == null || !currencyUnit.equals(otherMoney.getCurrencyUnit()) || otherMoney.getAmount() > amount) {
            throw new ShopException("Invalid subtract operation");
        }
        return new Money(amount - otherMoney.getAmount(), currencyUnit);
    }

    @Override
    public MoneyType multiplyBy(int factor) throws ShopException {
        if (factor < 0) {
            throw new ShopException("Invalid multiply operation");
        }
        return new Money(amount * factor, currencyUnit);
    }

    @Override
    public boolean largerThan(MoneyType otherMoney) throws ShopException {
        if (otherMoney == null || !currencyUnit.equals(otherMoney.getCurrencyUnit())) {
            throw new ShopException("Invalid comparison");
        }
        return amount > otherMoney.getAmount();
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Money money = (Money) obj;

        // Debug-Ausgaben
        System.out.println("Comparing Money objects: ");
        System.out.println("This Money - amount: " + this.amount + ", currencyUnit: " + this.currencyUnit);
        System.out.println("Other Money - amount: " + money.amount + ", currencyUnit: " + money.currencyUnit);

        return (amount != null ? amount.equals(money.amount) : money.amount == null) &&
                (currencyUnit != null ? currencyUnit.equals(money.currencyUnit) : money.currencyUnit == null);
    }

    @Override
    public int hashCode() {
        int result = (amount != null) ? amount.hashCode() : 0;
        result = 31 * result + ((currencyUnit != null) ? currencyUnit.hashCode() : 0);
        return result;
    }

    public String toFormattedString() {
        if (currencyUnit.equals("EUR")) {
            return String.format("%.2f €", amount);
        } else if (currencyUnit.equals("CHF")) {
            return String.format("%.2f CHF", amount);
        }
        return String.format("%.2f %s", amount, currencyUnit);
    }

}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PhysicalAddress.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.Embeddable;
import jakarta.persistence.Embedded;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

@Embeddable
public class PhysicalAddress implements PhysicalAddressType {
    @JsonProperty
    private String street;

    @JsonProperty
    private String city;

    @Embedded
    @JsonProperty
    private ZipCode zipCode; // Änderung hier, um sicherzustellen, dass ZipCode korrekt angemerkt ist

    private PhysicalAddress(String street, String city, ZipCodeType zipCode) {
        this.street = street;
        this.city = city;
        this.zipCode = (ZipCode) zipCode;
    }

    public static PhysicalAddress of(String street, String city, ZipCodeType zipCode) throws ShopException {
        if (street == null || street.isEmpty()) {
            throw new ShopException("Invalid street");
        }
        if (city == null || city.isEmpty()) {
            throw new ShopException("Invalid city");
        }
        if (zipCode == null) {
            throw new ShopException("Invalid zip code");
        }
        return new PhysicalAddress(street, city, zipCode);
    }

    @Override
    public String getStreet() {
        return street;
    }

    @Override
    public String getCity() {
        return city;
    }

    @Override
    public ZipCodeType getZipCode() {
        return zipCode;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        PhysicalAddress that = (PhysicalAddress) o;

        if (!street.equals(that.street)) return false;
        if (!city.equals(that.city)) return false;
        return zipCode.equals(that.zipCode);
    }

    @Override
    public int hashCode() {
        int result = street.hashCode();
        result = 31 * result + city.hashCode();
        result = 31 * result + zipCode.hashCode();
        return result;
    }

    // Default constructor for JPA and Jackson
    protected PhysicalAddress() {
        this.street = null;
        this.city = null;
        this.zipCode = null;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PhysicalAddressDTO.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

public class PhysicalAddressDTO {
    private String street;
    private String city;
    private ZipCodeDTO zipCode;

    public PhysicalAddressDTO(PhysicalAddressType physicalAddress) {
        this.street = physicalAddress.getStreet();
        this.city = physicalAddress.getCity();
        this.zipCode = new ZipCodeDTO(physicalAddress.getZipCode().toString());
    }

    // Getter methods
    public String getStreet() { return street; }
    public String getCity() { return city; }
    public ZipCodeDTO getZipCode() { return zipCode; }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.Embeddable;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
import thkoeln.archilab.ecommerce.ShopException;

@Embeddable
public class ZipCode implements ZipCodeType {
    @JsonProperty
    private String zipCode;

    protected ZipCode() {
        this.zipCode = null; // Placeholder, overwritten by JPA/Hibernate
    }

    private ZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    public static ZipCode of(String zipCodeAsString) throws ShopException {
        if (!isValidZipCode(zipCodeAsString)) {
            throw new ShopException("Invalid zip code");
        }
        return new ZipCode(zipCodeAsString);
    }

    private static boolean isValidZipCode(String zipCode) {
        return zipCode != null && zipCode.matches("\\d{5}") && !zipCode.endsWith("0000");
    }

    @Override
    public String toString() {
        return zipCode;
    }

    @Override
    public int difference(ZipCodeType otherZipCode) {
        if (otherZipCode == null) {
            throw new ShopException("Zip code must not be null");
        }

        String zip1 = this.zipCode;
        String zip2 = otherZipCode.toString();

        if (zip1.equals(zip2)) {
            return 0;
        }

        int maxDiffPos = 0;
        for (int i = 4; i >= 1; i--) {
            if (zip1.charAt(i) != zip2.charAt(i)) {
                maxDiffPos = Math.max(maxDiffPos, 5 - i);
            }
        }

        int d1 = Character.getNumericValue(zip1.charAt(0));
        int d2 = Character.getNumericValue(zip2.charAt(0));
        int regionDiff = Math.min(Math.abs(d1 - d2), 10 - Math.abs(d1 - d2));

        return regionDiff * 10 + maxDiffPos;
    }

    private int calculateDifference(String zip1, String zip2) {
        int difference = 0;
        int weight = 1;

        for (int i = zip1.length() - 1; i >= 0; i--) {
            if (zip1.charAt(i) != zip2.charAt(i)) {
                difference += weight;
            }
            weight *= 10;
        }

        // Zusätzliche Bearbeitung der ersten Ziffern als benachbarte Bereiche
        if (areAdjacent(zip1.charAt(0), zip2.charAt(0))) {
            difference -= (weight / 100);  // Korrigiere die Differenz für benachbarte Regionen
        }

        return difference;
    }

    private boolean areAdjacent(char a, char b) {
        // Benachbarte Ziffern in einem numerischen Kreis
        int diff = Math.abs(Character.getNumericValue(a) - Character.getNumericValue(b));
        return diff == 1 || diff == 9; // Ziffern 0 und 9 sind auch benachbart
    }

    @Override
    public Integer getFirstDigitZipCode() {
        return Character.getNumericValue(zipCode.charAt(0));
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        ZipCode zipCode1 = (ZipCode) obj;
        return zipCode != null && zipCode.equals(zipCode1.zipCode);
    }

    @Override
    public int hashCode() {
        return zipCode != null ? zipCode.hashCode() : 0;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCodeDTO.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

public class ZipCodeDTO {
    private String zipCodeString;

    public ZipCodeDTO(String zipCodeString) {
        this.zipCodeString = zipCodeString;
    }

    // Getter method
    public String getZipCodeString() { return zipCodeString; }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
 */
package thkoeln.archilab.ecommerce;

import jakarta.persistence.Column;
import jakarta.persistence.MappedSuperclass;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

import java.io.Serializable;
import java.util.UUID;

@MappedSuperclass
@Getter
@EqualsAndHashCode(of = "id")
@ToString(of = "id")
public abstract class GenericId implements Serializable {
    @Column(nullable = false, updatable = false)
    private final UUID id;

    protected GenericId() {
        this( UUID.randomUUID() );
    }

    protected GenericId( UUID id ) {
        this.id = id;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
 */
package thkoeln.archilab.ecommerce;

import jakarta.persistence.AttributeConverter;

import java.util.UUID;
import java.util.function.Function;


public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
    private final Function<UUID, T> factory;

    protected GenericIdConverter( Function<UUID, T> factory ) {
        this.factory = factory;
    }

    @Override
    public UUID convertToDatabaseColumn( T attribute ) {
        return attribute == null ? null : attribute.getId();
    }

    @Override
    public T convertToEntityAttribute( UUID dbData ) {
        return dbData == null ? null : factory.apply( dbData );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\InsufficientStockException.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
 */
package thkoeln.archilab.ecommerce;

/**
 * Exception is thrown if the item's stock level is not sufficient to serve the order.
 */
public class InsufficientStockException extends ShopException {
    public InsufficientStockException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
 */
package thkoeln.archilab.ecommerce;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class ProjectApplication {

	/**
	 * Entry method
	 * @param args
	 */
	public static void main(String[] args) {
		SpringApplication.run(ProjectApplication.class, args);
	}
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
 */
package thkoeln.archilab.ecommerce;

public class ShopException extends RuntimeException {
    public ShopException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientAdapterHelper.java ---
package thkoeln.archilab.ecommerce.solution.client.application;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

public class ClientAdapterHelper {
    public static Email convertToEmail(EmailType emailType) throws ShopException {
        if (emailType instanceof Email) {
            return (Email) emailType;
        }
        throw new ShopException("Invalid EmailType");
    }

    public static PhysicalAddress convertToPhysicalAddress(PhysicalAddressType addressType) throws ShopException {
        if (addressType instanceof PhysicalAddress) {
            return (PhysicalAddress) addressType;
        }
        throw new ShopException("Invalid PhysicalAddressType");
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientController.java ---
package thkoeln.archilab.ecommerce.solution.client.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.EmailDTO;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddressDTO;
import thkoeln.archilab.ecommerce.domainprimitives.ZipCodeDTO;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientResponseDTO;
import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.UUID;

@RestController
@RequestMapping("/clients")
public class ClientController {

    @Autowired
    private ClientRegistrationUseCases clientRegistrationService;

    @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<ClientResponseDTO> getClientByEmail(@RequestParam(name = "email", required = false) String emailString) {
        if (emailString == null || emailString.isEmpty()) {
            return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).build();
        }

        try {
            Email email = Email.of(emailString);
            ClientType clientData = clientRegistrationService.getClientData(email);
            ClientResponseDTO response = mapToClientResponseDTO(clientData);
            return ResponseEntity.ok(response);
        } catch (ShopException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }

    private ClientResponseDTO mapToClientResponseDTO(ClientType client) {
        UUID clientId = ((Client) client).getId().getId();
        Email email = (Email) client.getEmail();
        PhysicalAddressDTO addressDTO = new PhysicalAddressDTO(client.getPhysicalAddress());

        return new ClientResponseDTO(
                clientId,
                client.getName(),
                email.toString(),
                addressDTO
        );
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientRegistrationService.java ---
package thkoeln.archilab.ecommerce.solution.client.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.Optional;
import java.util.UUID;

@Service
public class ClientRegistrationService implements ClientRegistrationUseCases {

    @Autowired
    private ClientRepository clientRepository;

    @Autowired
    private ClientSBServiceInterface clientSBServiceInterface;

    @Override
    public void register(String name, EmailType email, PhysicalAddressType physicalAddress) {
        if (name == null || name.isEmpty()) {
            throw new ShopException("Error: Name cannot be null or empty");
        }

        Email emailEntity = ClientAdapterHelper.convertToEmail(email);
        PhysicalAddress addressEntity = ClientAdapterHelper.convertToPhysicalAddress(physicalAddress);

        ClientId clientId = ClientId.fromEmail(emailEntity.toString());

        if (clientRepository.existsById(clientId)) {
            throw new ShopException("Error: A client with the given email already exists");
        }

        UUID basketId = clientSBServiceInterface.createShoppingBasketForClient();

        Client client = new Client(name, emailEntity, addressEntity, basketId);
        clientRepository.save(client);
    }

    @Override
    public void changeAddress(EmailType clientEmail, PhysicalAddressType physicalAddress) {
        Email emailEntity = ClientAdapterHelper.convertToEmail(clientEmail);
        PhysicalAddress addressEntity = ClientAdapterHelper.convertToPhysicalAddress(physicalAddress);

        ClientId clientId = ClientId.fromEmail(emailEntity.toString());

        Client client = clientRepository.findById(clientId)
                .orElseThrow(() -> new ShopException("The client with the given email does not exist"));

        client.setPhysicalAddress(addressEntity);
        clientRepository.save(client);
    }

    @Override
    public ClientType getClientData(EmailType clientEmail) {
        Email emailEntity = ClientAdapterHelper.convertToEmail(clientEmail);
        ClientId clientId = ClientId.fromEmail(emailEntity.toString());

        return clientRepository.findById(clientId)
                .orElseThrow(() -> new ShopException("Error: Client not found"));
    }

    @Override
    public void deleteAllClients() {
        clientRepository.deleteAll();
    }

    public EmailType getEmailByClientId(UUID clientId) {
        Client client = clientRepository.findById(new ClientId(clientId))
                .orElseThrow(() -> new ShopException("Client not found"));
        return client.getEmail();
    }

    public Optional<Client> findById(ClientId clientId) {
        return clientRepository.findById(clientId);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientSBServiceInterface.java ---
package thkoeln.archilab.ecommerce.solution.client.application;

import java.util.UUID;

public interface  ClientSBServiceInterface {
    UUID createShoppingBasketForClient();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\Client.java ---
package thkoeln.archilab.ecommerce.solution.client.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.usecases.ClientType;


import java.util.UUID;

@Entity
@Getter
@Setter
@NoArgsConstructor
public class Client implements ClientType {

    @EmbeddedId
    private ClientId id;

    private String name;

    @Embedded
    private Email email;

    @Embedded
    private PhysicalAddress physicalAddress;

    @Column(name = "shopping_basket_id")
    private UUID shoppingBasketId;

    // Konstruktor mit Initialisierung
    public Client(String name, Email email, PhysicalAddress physicalAddress, UUID shoppingBasketId) {
        this.id = ClientId.fromEmail(email.toString());
        this.name = name;
        this.email = email;
        this.physicalAddress = physicalAddress;
        this.shoppingBasketId = shoppingBasketId;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ClientId.java ---
package thkoeln.archilab.ecommerce.solution.client.domain;

import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class ClientId extends GenericId {
    public ClientId(UUID id) {
        super(id);
    }

    public static ClientId fromEmail(String email) {
        return new ClientId(UUID.nameUUIDFromBytes(email.getBytes()));
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ClientIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.client.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ClientIdConverter extends GenericIdConverter<ClientId> {
    public ClientIdConverter() {
        super(ClientId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ClientRepository.java ---
package thkoeln.archilab.ecommerce.solution.client.domain;

import org.springframework.data.repository.CrudRepository;
import thkoeln.archilab.ecommerce.domainprimitives.Email;

import java.util.Optional;
import java.util.UUID;

public interface ClientRepository extends CrudRepository<Client, ClientId> {

    Optional<Client> findByShoppingBasketId(UUID shoppingBasketId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ClientResponseDTO.java ---
package thkoeln.archilab.ecommerce.solution.client.domain;

import thkoeln.archilab.ecommerce.domainprimitives.EmailDTO;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddressDTO;

import java.util.UUID;

public class ClientResponseDTO {
    private UUID id;
    private String name;
    private EmailDTO email;
    private PhysicalAddressDTO physicalAddress;

    public ClientResponseDTO(UUID id, String name, String email, PhysicalAddressDTO physicalAddress) {
        this.id = id;
        this.name = name;
        this.email = new EmailDTO(email);
        this.physicalAddress = physicalAddress;
    }

    public UUID getId() { return id; }
    public String getName() { return name; }
    public EmailDTO getEmail() { return email; }
    public PhysicalAddressDTO getPhysicalAddress() { return physicalAddress; }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\Shoppable.java ---
package thkoeln.archilab.ecommerce.solution.client.domain;

import jakarta.persistence.*;


import java.util.HashMap;
import java.util.UUID;

@Entity
public abstract class Shoppable {

    @EmbeddedId
    private ShoppableId id;

    @Lob
    public HashMap<UUID, Integer> shoppingbasketInventory = new HashMap<UUID, Integer>();

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ShoppableId.java ---
package thkoeln.archilab.ecommerce.solution.client.domain;

import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class ShoppableId extends GenericId {
    public ShoppableId(UUID id) {
        super(id);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ShoppableIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.client.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ShoppableIdConverter extends GenericIdConverter<ShoppableId> {
    public ShoppableIdConverter() {
        super(ShoppableId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\application\DistributionCenterService.java ---
package thkoeln.archilab.ecommerce.solution.distributioncenter.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.*;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.usecases.DistributionCenterUseCases;
import thkoeln.archilab.ecommerce.solution.item.domain.Item;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemRepository;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

@Service
public class DistributionCenterService implements DistributionCenterUseCases {

    @Autowired
    private DistributionCenterRepository distributionCenterRepository;

    @Autowired
    private StockLevelRepository stockLevelRepository;

    @Autowired
    private ItemRepository itemRepository;

    @Override
    public UUID addNewDistributionCenter(String name, PhysicalAddressType physicalAddress) {
        if (name == null || name.isEmpty()) {
            throw new ShopException("Name cannot be null or empty");
        }
        if (physicalAddress == null ||
                physicalAddress.getStreet() == null || physicalAddress.getStreet().isEmpty() ||
                physicalAddress.getCity() == null || physicalAddress.getCity().isEmpty() ||
                physicalAddress.getZipCode() == null || physicalAddress.getZipCode().toString().isEmpty()) {
            throw new ShopException("Invalid address");
        }

        DistributionCenter distributionCenter = new DistributionCenter(name, (PhysicalAddress) physicalAddress, null);
        distributionCenterRepository.save(distributionCenter);
        return distributionCenter.getId().getId();
    }

    @Override
    public void deleteAllDistributionCenters() {
        // Zuerst alle StockLevels löschen, um referentielle Integrität zu gewährleisten
        stockLevelRepository.deleteAll();

        // Dann die DistributionCenters löschen
        distributionCenterRepository.deleteAll();
    }

    public UUID findSuitableDistributionCenter(String zipCode) {
        if (zipCode == null || zipCode.isEmpty()) {
            throw new ShopException("Invalid zip code");
        }

        // Logik zur Auswahl des Verteilzentrums basierend auf ZipCode
        for (DistributionCenter center : distributionCenterRepository.findAll()) {
            String zipCodeRange = center.getZipCodeRange();
            if (zipCodeRange == null) {
                throw new ShopException("Zip code range not set for distribution center");
            }

            String[] range = zipCodeRange.split("-");
            if (range.length < 2) {
                throw new ShopException("Zip code range format invalid");
            }

            int rangeStart = Integer.parseInt(range[0]);
            int rangeEnd = Integer.parseInt(range[1]);

            int firstDigitZip = Character.getNumericValue(zipCode.charAt(0));
            if (firstDigitZip >= rangeStart && firstDigitZip <= rangeEnd) {
                return center.getId().getId();
            }
        }

        throw new ShopException("No suitable distribution center found for the given zip code");
    }

    private DistributionCenter findDistributionCenterById(UUID distributionCenterUuid) {
        if (distributionCenterUuid == null) {
            throw new ShopException("distributionCenterId is null");
        }

        // Konvertiere UUID in DistributionCenterId
        DistributionCenterId distributionCenterId = new DistributionCenterId(distributionCenterUuid);

        return distributionCenterRepository.findById(distributionCenterId)
                .orElseThrow(() -> new ShopException("Distribution center does not exist"));
    }

    private Item findItemById(UUID itemIdUuid) {
        if (itemIdUuid == null) {
            throw new ShopException("itemId is null");
        }

        // Konvertiere die UUID in eine ItemId
        ItemId itemId = new ItemId(itemIdUuid);

        return itemRepository.findById(itemId)
                .orElseThrow(() -> new ShopException("Item does not exist"));
    }

    @Override
    public void addToStock(UUID distributionCenterId, UUID itemId, int addedQuantFor) {
        if (addedQuantFor < 0) {
            throw new ShopException("addedQuantFor cannot be negative");
        }

        DistributionCenter distributionCenter = findDistributionCenterById(distributionCenterId);
        Item item = findItemById(itemId);

        StockLevel stockLevel = stockLevelRepository
                .findByDistributionCenterAndItemId(distributionCenter, itemId)
                .orElseGet(() -> {
                    StockLevel newStockLevel = new StockLevel(distributionCenter, itemId, 0);
                    newStockLevel.setId(new StockLevelId(UUID.randomUUID()));  // Zuweisung der ID
                    return stockLevelRepository.save(newStockLevel);
                });

        stockLevel.setQuantity(stockLevel.getQuantity() + addedQuantFor);
        stockLevelRepository.save(stockLevel);
    }


    @Override
    public void removeFromStock(UUID distributionCenterId, UUID itemId, int removedQuantFor) {
        if (distributionCenterId == null) {
            throw new ShopException("distributionCenterId cannot be null");
        }
        if (itemId == null) {
            throw new ShopException("itemId cannot be null");
        }
        if (removedQuantFor < 0) {
            throw new ShopException("removedQuantFor cannot be negative");
        }
        if (removedQuantFor == 0) {
            // Verlassen der Methode, da keine Menge zu entfernen ist
            return;
        }

        DistributionCenter distributionCenter = findDistributionCenterById(distributionCenterId);
        if (distributionCenter == null) {
            throw new ShopException("Distribution center not found");
        }

        Item item = findItemById(itemId);
        if (item == null) {
            throw new ShopException("Item not found");
        }

        StockLevel stockLevel = stockLevelRepository
                .findByDistributionCenterAndItemId(distributionCenter, itemId)
                .orElseThrow(() -> new ShopException("Stock level not found"));

        if (stockLevel.getQuantity() < removedQuantFor) {
            throw new ShopException("Insufficient stock to remove");
        }

        stockLevel.setQuantity(stockLevel.getQuantity() - removedQuantFor);
        stockLevelRepository.save(stockLevel);
    }


    @Override
    public void changeStockTo(UUID distributionCenterId, UUID itemId, int newTotalQuantFor) {
        if (newTotalQuantFor < 0) {
            throw new ShopException("newTotalQuantFor cannot be negative");
        }

        DistributionCenter distributionCenter = findDistributionCenterById(distributionCenterId);
        Item item = findItemById(itemId);

        StockLevel stockLevel = stockLevelRepository
                .findByDistributionCenterAndItemId(distributionCenter, itemId)
                .orElseGet(() -> {
                    StockLevel newStockLevel = new StockLevel(distributionCenter, itemId, newTotalQuantFor);
                    return stockLevelRepository.save(newStockLevel);
                });

        stockLevel.setQuantity(newTotalQuantFor);
        stockLevelRepository.save(stockLevel);
    }

    @Override
    public int getAvailableStock(UUID distributionCenterId, UUID itemId) {
// Überprüfen, ob Verteilzentrum existiert
        DistributionCenter distributionCenter = findDistributionCenterById(distributionCenterId);
        // Überprüfen, ob das Item existiert
        Item item = findItemById(itemId);

        // Direkt im Repository suchen oder mit 0 fallbacken
        StockLevel stockLevel = stockLevelRepository.findByDistributionCenterAndItemId(distributionCenter, itemId)
                .orElse(null);

        // Rückgabe der Menge oder 0, falls nicht vorhanden
        if (stockLevel == null) {
            System.out.println("Kein Lagerbestand für dieses DistributionCenter und Item gefunden.");
            return 0;  // Oder ein indikativer Fehlerwert, falls Storage bei Nichtverfügbarkeit eine 0 als Bestand verwendet
        }

        return stockLevel.getQuantity();
    }

    public Iterable<DistributionCenter> findAll() {
        return distributionCenterRepository.findAll();
    }

}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\application\StockService.java ---
package thkoeln.archilab.ecommerce.solution.distributioncenter.application;

import lombok.Getter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.DistributionCenter;
import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.DistributionCenterRepository;
import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.StockLevel;
import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.StockLevelRepository;
import thkoeln.archilab.ecommerce.solution.item.application.StockServiceInterface;

import java.util.Optional;
import java.util.UUID;

@Service
public class StockService implements StockServiceInterface {

    @Getter
    private final StockLevelRepository stockLevelRepository;


    @Autowired
    public StockService(StockLevelRepository stockLevelRepository) {
        this.stockLevelRepository = stockLevelRepository;
    }

    @Override
    public boolean isItemInStock(UUID itemId) {
        return stockLevelRepository.existsByItemId(itemId);
    }

    @Override
    public void deleteAllStock() {
        stockLevelRepository.deleteAll();
    }

    @Override
    public boolean isItemReferenced(UUID itemId) {
        return stockLevelRepository.existsByItemId(itemId);
    }

    public Optional<StockLevel> findByDistributionCenterAndItemId(DistributionCenter center, UUID id) {
        return stockLevelRepository.findByDistributionCenterAndItemId(center, id);
    }

}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\DistributionCenter.java ---
package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;

import jakarta.persistence.Embedded;
import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;

import java.util.*;


@Entity
@Getter
@Setter
@NoArgsConstructor
public class DistributionCenter {

    @EmbeddedId
    private DistributionCenterId id;

    private String name;

    @Embedded
    private PhysicalAddress physicalAddress;

    private String zipCodeRange;

    // Diese Map ist nicht persistiert in der DB, sondern dient der Laufzeitlogik:
    private transient Map<ItemId, Integer> stock = new HashMap<>();

    public DistributionCenter(String name, PhysicalAddress physicalAddress, String zipCodeRange) {
        this.id = new DistributionCenterId(UUID.randomUUID());
        this.name = name;
        this.physicalAddress = physicalAddress;
        this.zipCodeRange = zipCodeRange;
    }

    public Set<ItemId> fulfillableShoppingBasketPositions(Map<ItemId, Integer> itemQuantityMap) {
        Set<ItemId> fulfillableItems = new HashSet<>();
        for (Map.Entry<ItemId, Integer> entry : itemQuantityMap.entrySet()) {
            ItemId itemId = entry.getKey();
            int requiredQuantity = entry.getValue();

            Integer availableQuantity = stock.get(itemId);
            if (availableQuantity != null && availableQuantity >= requiredQuantity) {
                fulfillableItems.add(itemId);
            }
            System.out.println("DC " + this.id + " has " + availableQuantity + " of item " + itemId + " (needed: " + requiredQuantity + ")");
        }
        return fulfillableItems;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\DistributionCenterComparator.java ---
package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;

import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;

import java.util.Comparator;
import java.util.Map;
import java.util.Set;

public class DistributionCenterComparator implements Comparator<DistributionCenter> {
    private Map<ItemId, Integer> shoppingBasketMap;
    private String clientZipCode;
    private StockLevelRepository stockLevelRepository;

    public DistributionCenterComparator(Map<ItemId, Integer> shoppingBasketMap, String clientZipCode, StockLevelRepository stockLevelRepository) {
        this.shoppingBasketMap = shoppingBasketMap;
        this.clientZipCode = clientZipCode;
        this.stockLevelRepository = stockLevelRepository;
    }

    @Override
    public int compare(DistributionCenter dc1, DistributionCenter dc2) {
        boolean canDc1Fulfill = canFulfillAllItems(dc1);
        boolean canDc2Fulfill = canFulfillAllItems(dc2);

        System.out.println("Comparing Distribution Centers:");
        System.out.println("dc1 ID: " + dc1.getId().getId() + ", can fulfill: " + canDc1Fulfill);
        System.out.println("dc2 ID: " + dc2.getId().getId() + ", can fulfill: " + canDc2Fulfill);

        if (canDc1Fulfill && !canDc2Fulfill) {
            System.out.println("Choosing dc1 because it can fulfill all items");
            return -1;
        }
        if (!canDc1Fulfill && canDc2Fulfill) {
            System.out.println("Choosing dc2 because it can fulfill all items");
            return 1;
        }

        int distance1 = dc1.getPhysicalAddress().getZipCode().difference(ZipCode.of(clientZipCode));
        int distance2 = dc2.getPhysicalAddress().getZipCode().difference(ZipCode.of(clientZipCode));
        System.out.println("Distance to client - dc1: " + distance1 + ", dc2: " + distance2);

        return Integer.compare(distance1, distance2);
    }

    private boolean canFulfillAllItems(DistributionCenter dc) {
        for (Map.Entry<ItemId, Integer> entry : shoppingBasketMap.entrySet()) {
            ItemId itemId = entry.getKey();
            int requiredQuantity = entry.getValue();
            int availableQuantity = stockLevelRepository.findByDistributionCenterAndItemId(dc, itemId.getId())
                    .map(StockLevel::getQuantity)
                    .orElse(0);

            if (availableQuantity < requiredQuantity) {
                return false;
            }
        }
        return true;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\DistributionCenterId.java ---
package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;

import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class DistributionCenterId extends GenericId {
    public DistributionCenterId(UUID id) {
        super(id);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\DistributionCenterIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class DistributionCenterIdConverter extends GenericIdConverter<DistributionCenterId> {
    public DistributionCenterIdConverter() {
        super(DistributionCenterId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\DistributionCenterRepository.java ---
package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;

import org.springframework.data.repository.CrudRepository;

import java.util.Optional;
import java.util.UUID;

public interface DistributionCenterRepository extends CrudRepository<DistributionCenter, DistributionCenterId> {
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\StockLevel.java ---
package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.item.domain.Item;

import java.util.UUID;

@Entity
@Getter
@Setter
@NoArgsConstructor
public class StockLevel {

    @EmbeddedId
    private StockLevelId id;

    private int quantity;

    private UUID itemId;  // Hier speichern wir die UUID statt der direkten Item-Referenz

    @ManyToOne
    private DistributionCenter distributionCenter;

    public StockLevel(DistributionCenter distributionCenter, UUID itemId, int quantity) {
        this.id = new StockLevelId(UUID.randomUUID());
        this.distributionCenter = distributionCenter;
        this.itemId = itemId;
        this.quantity = quantity;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\StockLevelId.java ---
package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;

import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class StockLevelId extends GenericId {
    public StockLevelId(UUID id) {
        super(id);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\StockLevelIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class StockLevelIdConverter extends GenericIdConverter<StockLevelId> {
    public StockLevelIdConverter() {
        super(StockLevelId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\StockLevelRepository.java ---
package thkoeln.archilab.ecommerce.solution.distributioncenter.domain;

import org.springframework.data.repository.CrudRepository;

import java.util.Optional;
import java.util.UUID;

public interface StockLevelRepository extends CrudRepository<StockLevel, StockLevelId> {

    Optional<StockLevel> findByDistributionCenterAndItemId(DistributionCenter distributionCenter, UUID itemId);

    boolean existsByItemId(UUID itemId);

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\AddItemDTO.java ---
package thkoeln.archilab.ecommerce.solution.item.application;

import java.util.UUID;

public class AddItemDTO {
    private UUID itemId;
    private int quantity;

    public AddItemDTO() {}

    public AddItemDTO(UUID itemId, int quantity) {
        this.itemId = itemId;
        this.quantity = quantity;
    }

    public UUID getItemId() {
        return itemId;
    }

    public void setItemId(UUID itemId) {
        this.itemId = itemId;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ItemCatalogService.java ---
package thkoeln.archilab.ecommerce.solution.item.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.item.domain.Item;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemRepository;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;

@Service
public class ItemCatalogService implements ItemCatalogUseCases {

    @Autowired
    private ItemRepository itemRepository;

    @Autowired
    private OrderItemServiceInterface orderService;

    @Autowired
    private ItemSBServiceInterface itemSBService; // Verwendet das Interface

    @Autowired
    private StockServiceInterface stockService;

    @Override
    public UUID addItemToCatalog(String name, String descriptOf, Float size, MoneyType buyingPrice, MoneyType salesPrice) {

        if (name == null || name.isEmpty() || descriptOf == null || descriptOf.isEmpty()) {
            throw new ShopException("Name and description cannot be null or empty");
        }
        if (size != null && size <= 0) {
            throw new ShopException("Size must be greater than 0 if provided");
        }
        if (buyingPrice == null || buyingPrice.getAmount() <= 0) {
            throw new ShopException("Buying price must be greater than 0");
        }
        if (salesPrice == null || salesPrice.getAmount() <= 0) {
            throw new ShopException("Sales price must be greater than 0");
        }
        if (salesPrice.getAmount() < buyingPrice.getAmount()) {
            throw new ShopException("Sales price cannot be lower than buying price");
        }

        Item item = new Item();
        item.setId(new ItemId(UUID.randomUUID()));
        item.setName(name);
        item.setDescription(descriptOf);
        item.setSize(size);
        item.setBuyingPrice((Money) buyingPrice);
        item.setSalesPrice((Money) salesPrice);

        itemRepository.save(item);

        return item.getId().getId();
    }

    @Override
    public void removeItemFromCatalog(UUID itemIdUuid) {
        if (itemIdUuid == null) {
            throw new ShopException("The item ID is null");
        }

        ItemId itemId = new ItemId(itemIdUuid);

        // Überprüfungen
        if (!itemRepository.existsById(itemId)) { throw new ShopException("The item id does not exist"); }
        if (stockService.isItemInStock(itemIdUuid)) { throw new ShopException("The item is still in stock"); }
        if (itemSBService.isItemInAnyShoppingBasket(itemIdUuid)) { throw new ShopException("The item is still present in a shopping basket"); }
        if (orderService.isItemInAnyOrder(itemIdUuid)) { throw new ShopException("The item is still referenced by a completed order"); }

        // Löschen, falls alle Tests bestanden
        itemRepository.deleteById(itemId);
    }

    @Override
    public MoneyType getSalesPrice(UUID itemId) {
        if (itemId == null) {
            throw new ShopException("The item ID is null");
        }

        // Konvertiere UUID in ItemId
        ItemId itemId1d = new ItemId(itemId);

        // Suche das Item mit der konvertierten ItemId
        Item item = itemRepository.findById(itemId1d)
                .orElseThrow(() -> new ShopException("The item id does not exist"));
        return item.getSalesPrice();
    }

    @Override
    public void deleteItemCatalog() {
        itemSBService.deleteAllShoppingBaskets();
        stockService.deleteAllStock();
        orderService.deleteAllOrders();
        itemRepository.deleteAll();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\ItemSBServiceInterface.java ---
package thkoeln.archilab.ecommerce.solution.item.application;

import java.util.UUID;

public interface ItemSBServiceInterface {
    boolean isItemInAnyShoppingBasket(UUID itemId);
    void deleteAllShoppingBaskets();
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\OrderItemServiceInterface.java ---
package thkoeln.archilab.ecommerce.solution.item.application;

import java.util.UUID;

public interface OrderItemServiceInterface {
    boolean isItemInAnyOrder(UUID itemId);

    void deleteAllOrders();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\StockServiceInterface.java ---
package thkoeln.archilab.ecommerce.solution.item.application;

import java.util.UUID;

public interface StockServiceInterface {
    boolean isItemInStock(UUID itemId);
    void deleteAllStock();
    boolean isItemReferenced(UUID itemId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\Item.java ---
package thkoeln.archilab.ecommerce.solution.item.domain;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.Money;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Item {

    @EmbeddedId
    private ItemId id;

    private String name;
    private String description;
    private Float size;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "amount", column = @Column(name = "buyingpriceamount")),
            @AttributeOverride(name = "currencyUnit", column = @Column(name = "buyingpricecurrency"))
    })
    private Money buyingPrice;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "amount", column = @Column(name = "salespriceamount")),
            @AttributeOverride(name = "currencyUnit", column = @Column(name = "salespricecurrency"))
    })
    private Money salesPrice;
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemId.java ---
package thkoeln.archilab.ecommerce.solution.item.domain;

import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class ItemId extends GenericId {
    public ItemId(UUID id) {
        super(id);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.item.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ItemIdConverter extends GenericIdConverter<ItemId> {
    public ItemIdConverter() {
        super(ItemId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\ItemRepository.java ---
package thkoeln.archilab.ecommerce.solution.item.domain;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.repository.CrudRepository;

import java.util.UUID;

public interface ItemRepository extends CrudRepository<Item, ItemId> {}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderItemService.java ---
package thkoeln.archilab.ecommerce.solution.order.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.item.application.OrderItemServiceInterface;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderpositionRepository;

import java.util.UUID;

@Service
public class OrderItemService implements OrderItemServiceInterface {

    @Autowired
    private OrderpositionRepository orderPositionRepository;

    @Override
    public boolean isItemInAnyOrder(UUID itemId) {
        Iterable<OrderPosition> orderPositions = orderPositionRepository.findAll();
        for (OrderPosition orderPosition : orderPositions) {
            if (orderPosition.getItemId().equals(itemId)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public void deleteAllOrders() {
        orderPositionRepository.deleteAll();
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderService.java ---
package thkoeln.archilab.ecommerce.solution.order.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.DistributionCenter;
import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.DistributionCenterRepository;
import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.StockLevel;
import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.StockLevelRepository;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderId;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
import thkoeln.archilab.ecommerce.usecases.OrderUseCases;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

@Service
public class OrderService implements OrderUseCases {

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private ClientRepository clientRepository;

    @Autowired
    private DistributionCenterRepository distributionCenterRepository;

    @Autowired
    private StockLevelRepository stockLevelRepository;

    @Override
    public Map<UUID, Integer> getOrderHistory(EmailType clientEmail) {
        if (clientEmail == null) {
            throw new ShopException("Client email cannot be null");
        }

        ClientId clientId = ClientId.fromEmail(String.valueOf(clientEmail));

        Client client = clientRepository.findById(clientId)
                .orElseThrow(() -> new ShopException("Client not found"));

        // Verwende die Methode 'findByClientId'
        List<Order> orders = orderRepository.findByClientId(client.getId());
        Map<UUID, Integer> orderHistory = new HashMap<>();

        // Initialisierung der OrderPositions
        for (Order order : orders) {
            order.getOrderPositions().size();
            for (OrderPosition op : order.getOrderPositions()) {
                orderHistory.merge(op.getItemId(), op.getQuantity(), Integer::sum);
            }
        }

        return orderHistory;
    }

    @Override
    public Integer getOrderQuantForItem(UUID orderId, UUID itemId) {
        if (orderId == null) {
            throw new ShopException("Order ID cannot be null");
        }
        if (itemId == null) {
            throw new ShopException("Item ID cannot be null");
        }

        Order order = orderRepository.findById(new OrderId(orderId))
                .orElseThrow(() -> new ShopException("Order does not exist"));

        return order.getOrderPositions().stream()
                .filter(position -> position.getItemId().equals(itemId))
                .map(OrderPosition::getQuantity)
                .findFirst()
                .orElse(0); // Wenn das Item nicht gefunden wird, 0 zurückgeben
    }

    @Override
    public UUID getDistributionCenterIdForOrder(UUID orderId) {
        Order order = orderRepository.findById(new OrderId(orderId))
                .orElseThrow(() -> new ShopException("Order does not exist"));

        System.out.println("Retrieving Distribution Center ID for Order ID: " + orderId);

        if (order.getDistributionCenterId() != null) {
            System.out.println("Order ID " + orderId + " directly assigned to Distribution Center ID " + order.getDistributionCenterId());
            return order.getDistributionCenterId();
        }

        List<DistributionCenter> distributionCenters = StreamSupport
                .stream(distributionCenterRepository.findAll().spliterator(), false)
                .collect(Collectors.toList());

        for (DistributionCenter center : distributionCenters) {
            boolean allItemsAvailable = true;

            for (OrderPosition position : order.getOrderPositions()) {
                StockLevel stockLevel = stockLevelRepository.findByDistributionCenterAndItemId(center, position.getItemId()).orElse(null);

                if (stockLevel == null || stockLevel.getQuantity() < position.getQuantity()) {
                    allItemsAvailable = false;
                    break;
                }
            }

            if (allItemsAvailable) {
                System.out.println("Order ID " + orderId + " is fully assignable to Distribution Center ID " + center.getId().getId());
                order.setDistributionCenterId(center.getId().getId());
                orderRepository.save(order);
                return center.getId().getId();
            }
        }

        throw new ShopException("No suitable distribution center can fulfill the entire order");
    }


    @Override
    public void deleteAllOrders() {
        orderRepository.deleteAll();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Getter
@Setter
@NoArgsConstructor
@Table(name = "client_orders")
public class Order extends Orderable {

    @EmbeddedId
    @AttributeOverride(name = "id", column = @Column(name = "order_id"))
    private OrderId id;

    @Column(name = "client_id", nullable = false)
    private ClientId clientId;

    @Column(name = "distribution_center_id", nullable = false)
    private UUID distributionCenterId;  // Neues Feld hinzugefügt

    @OneToMany(mappedBy = "id.orderId", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
    private List<OrderPosition> orderPositions = new ArrayList<>();

    @Override
    public UUID getOrderId() {
        return id.getId();
    }

    @Override
    public ClientId getClientId() {
        return clientId;
    }

    @Override
    public List<OrderPosition> getOrderPositions() {
        return orderPositions;
    }

    public void setDistributionCenterId(UUID distributionCenterId) {
        this.distributionCenterId = distributionCenterId;
    }

    public UUID getDistributionCenterId() {
        return distributionCenterId;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Orderable.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.Id;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;

import java.util.List;
import java.util.UUID;

public abstract class Orderable {
    @Id
    private UUID id;


    public abstract UUID getOrderId();

    public abstract ClientId getClientId();

    public abstract List<OrderPosition> getOrderPositions();
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderDTO.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import java.util.List;
import java.util.UUID;

public class OrderDTO {
    private UUID id;
    private String clientName;
    private UUID distributionCenterId;
    private List<OrderPositionDTO> positions;

    public OrderDTO(UUID id, String clientName, UUID distributionCenterId, List<OrderPositionDTO> positions) {
        this.id = id;
        this.clientName = clientName;
        this.distributionCenterId = distributionCenterId;
        this.positions = positions;
    }

    // Getter und Setter
    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public String getClientName() {
        return clientName;
    }

    public void setClientName(String clientName) {
        this.clientName = clientName;
    }

    public UUID getDistributionCenterId() {
        return distributionCenterId;
    }

    public void setDistributionCenterId(UUID distributionCenterId) {
        this.distributionCenterId = distributionCenterId;
    }

    public List<OrderPositionDTO> getPositions() {
        return positions;
    }

    public void setPositions(List<OrderPositionDTO> positions) {
        this.positions = positions;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderId.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class OrderId extends GenericId {
    public OrderId(UUID id) {
        super(id);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class OrderIdConverter extends GenericIdConverter<OrderId> {
    public OrderIdConverter() {
        super(OrderId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPosition.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.UUID;

@Entity
@Getter
@Setter
@NoArgsConstructor
public class OrderPosition {

    @EmbeddedId
    private OrderPositionId id; // OrderPositionId enthält itemId

    private int quantity;

    // Getter und Setter für itemId über OrderPositionId
    public UUID getItemId() {
        return id != null ? id.getItemId() : null;
    }

    public void setItemId(UUID itemId) {
        if (id == null) {
            id = new OrderPositionId();
        }
        id.setItemId(itemId);
    }

    // Getter und Setter für andere Felder
    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionDTO.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import java.util.UUID;

public class OrderPositionDTO {
    private UUID itemId;
    private int quantity;

    public OrderPositionDTO() {}

    public OrderPositionDTO(UUID itemId, int quantity) {
        this.itemId = itemId;
        this.quantity = quantity;
    }

    // Getter und Setter
    public UUID getItemId() {
        return itemId;
    }

    public void setItemId(UUID itemId) {
        this.itemId = itemId;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionId.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;


@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class OrderPositionId extends GenericId {
    @Column(name = "item_id")
    private UUID itemId;

    @Column(name = "order_id")
    private UUID orderId;

    public OrderPositionId(UUID orderId, UUID itemId) {
        super(UUID.randomUUID()); // Aufruf des Konstruktors der Superklasse
        this.orderId = orderId;
        this.itemId = itemId;
    }

    // Getter und Setter für itemId und orderId
    public UUID getItemId() {
        return itemId;
    }

    public void setItemId(UUID itemId) {
        this.itemId = itemId;
    }

    public UUID getOrderId() {
        return orderId;
    }

    public void setOrderId(UUID orderId) {
        this.orderId = orderId;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

import java.util.UUID;


@Converter(autoApply = true)
public class OrderPositionIdConverter extends GenericIdConverter<OrderPositionId> {

    public OrderPositionIdConverter() {
        super(OrderPositionIdConverter::createOrderPositionId); // Verwende die statische Methode zur Erzeugung von OrderPositionId
    }

    // Statische Methode, die den Konstruktor von OrderPositionId mit zwei UUIDs aufruft
    private static OrderPositionId createOrderPositionId(UUID combinedId) {
        // Zerlege den kombinierten UUID in zwei Teile
        UUID orderId = UUID.fromString(combinedId.toString().substring(0, 36));  // Nehme die ersten 36 Zeichen für orderId
        UUID itemId = UUID.fromString(combinedId.toString().substring(36));      // Nehme die restlichen 36 Zeichen für itemId
        return new OrderPositionId(orderId, itemId);
    }

    @Override
    public UUID convertToDatabaseColumn(OrderPositionId attribute) {
        if (attribute == null) {
            return null;
        }
        // Kombiniere die beiden UUIDs in einen einzigen UUID-Wert (hier: String + dann zurück zu UUID)
        String combined = attribute.getOrderId().toString() + attribute.getItemId().toString();
        return UUID.fromString(combined);  // Rückgabe als kombinierte UUID
    }

    @Override
    public OrderPositionId convertToEntityAttribute(UUID dbData) {
        if (dbData == null) {
            return null;
        }
        return createOrderPositionId(dbData);  // Rufe die Methode zur Umwandlung in OrderPositionId auf
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderpositionRepository.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import org.springframework.data.repository.CrudRepository;

import java.util.UUID;

public interface OrderpositionRepository extends CrudRepository<OrderPosition, OrderPositionId> {
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderRepository.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import org.springframework.data.repository.CrudRepository;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;

import java.util.List;
import java.util.UUID;

public interface OrderRepository extends CrudRepository<Order, OrderId> {
    // Suche nach Orders anhand der ClientId
    List<Order> findByClientId(ClientId clientId);
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ClientSBService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.client.application.ClientSBServiceInterface;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;

import java.util.UUID;

@Service
public class ClientSBService implements ClientSBServiceInterface {
    @Autowired
    private ShoppingBasketRepository shoppingBasketRepository;

    public UUID createShoppingBasketForClient() {
        ShoppingBasket newBasket = new ShoppingBasket();
        shoppingBasketRepository.save(newBasket);
        return newBasket.getId().getId();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ItemSBService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.item.application.ItemSBServiceInterface;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;

import java.util.UUID;

@Service
public class ItemSBService implements ItemSBServiceInterface {

    private final ShoppingBasketRepository shoppingBasketRepository;

    @Autowired
    public ItemSBService(ShoppingBasketRepository shoppingBasketRepository) {
        this.shoppingBasketRepository = shoppingBasketRepository;
    }

    @Override
    public boolean isItemInAnyShoppingBasket(UUID itemId) {
        Iterable<ShoppingBasket> shoppingBaskets = shoppingBasketRepository.findAll();
        for (ShoppingBasket shoppingBasket : shoppingBaskets) {
            for (ShoppingBasketPosition position : shoppingBasket.getShoppingBasketPositions()) {
                if (position.getItemId().equals(itemId)) {
                    return true;
                }
            }
        }
        return false;
    }

    @Override
    public void deleteAllShoppingBaskets() {
        shoppingBasketRepository.deleteAll();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.client.application.ClientRegistrationService;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
import thkoeln.archilab.ecommerce.solution.distributioncenter.application.DistributionCenterService;
import thkoeln.archilab.ecommerce.solution.distributioncenter.application.StockService;
import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.*;
import thkoeln.archilab.ecommerce.solution.item.application.AddItemDTO;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderDTO;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.*;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.*;

@RestController
@RequestMapping("/shoppingBaskets")
public class ShoppingBasketController {

    @Autowired
    private ShoppingBasketService shoppingBasketService;  // Verwenden Sie ShoppingBasketService direkt

    @Autowired
    private DistributionCenterService distributionCenterService;

    @Autowired
    private StockService stockService;

    @Autowired
    private ClientRegistrationService clientRegistrationService;


    @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<?> getShoppingBasket(@RequestParam(name = "clientId", required = false) String clientId) {
        if (clientId == null) {
            return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).body("Client ID is required");
        }

        UUID clientUuid;
        try {
            clientUuid = UUID.fromString(clientId);
        } catch (IllegalArgumentException ex) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Invalid client ID format");
        }

        Optional<Client> optionalClient = clientRegistrationService.findById(new ClientId(clientUuid));
        if (optionalClient.isEmpty()) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Client not found");
        }

        Client client = optionalClient.get();
        ShoppingBasket shoppingBasket = shoppingBasketService.getShoppingBasketByEmail(client.getEmail().toString());
        if (shoppingBasket == null) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Shopping basket not found");
        }

        Map<UUID, Integer> basketMap = shoppingBasketService.getShoppingBasketAsMap(client.getEmail());
        ShoppingBasketResponseDTO shoppingBasketDTO = mapToDTO(shoppingBasket, basketMap, shoppingBasketService, client.getEmail());

        return ResponseEntity.ok(shoppingBasketDTO);
    }

    @PostMapping("/{shoppingBasketId}/positions")
    public ResponseEntity<?> addItemToShoppingBasket(@PathVariable("shoppingBasketId") UUID shoppingBasketId,
                                                     @RequestBody AddItemDTO addItemDTO) {
        if (addItemDTO.getQuantity() <= 0) {
            return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body("Quantity must be greater than 0");
        }

        try {
            Client client = shoppingBasketService.getClientByShoppingBasketId(shoppingBasketId);

            shoppingBasketService.addItemToShoppingBasket(client.getEmail(), addItemDTO.getItemId(), addItemDTO.getQuantity());
            return ResponseEntity.status(HttpStatus.CREATED).build();
        } catch (ShopException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @DeleteMapping("/{shoppingBasketId}/positions/{itemId}")
    public ResponseEntity<?> deleteItemFromShoppingBasket(@PathVariable("shoppingBasketId") UUID shoppingBasketId,
                                                          @PathVariable("itemId") UUID itemId) {
        try {
            // Client über die ShoppingBasketId finden
            Client client = shoppingBasketService.getClientByShoppingBasketId(shoppingBasketId);

            // Ermitteln der aktuellen Menge des Artikels im Einkaufswagen
            Map<UUID, Integer> basketContents = shoppingBasketService.getShoppingBasketAsMap(client.getEmail());
            int currentQuantity = basketContents.getOrDefault(itemId, 0);

            if (currentQuantity > 0) {
                // Entfernt nur die Menge, die tatsächlich vorhanden ist
                shoppingBasketService.removeItemFromShoppingBasket(client.getEmail(), itemId, currentQuantity);
                return ResponseEntity.ok().build();
            } else {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Item not found in basket");
            }
        } catch (ShopException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }

    @PostMapping("/{shoppingBasketId}/checkout")
    public ResponseEntity<?> checkout(@PathVariable("shoppingBasketId") UUID shoppingBasketId) {
        Optional<ShoppingBasket> optionalBasket = shoppingBasketService.findById(new ShoppingBasketId(shoppingBasketId));
        if (optionalBasket.isEmpty()) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Shopping basket not found");
        }

        ShoppingBasket shoppingBasket = optionalBasket.get();

        // Prüfen, ob der Einkaufswagen leer ist oder bereits ausgecheckt wurde
        if (isShoppingBasketEmptyOrCheckedOut(shoppingBasket)) {
            return ResponseEntity.status(HttpStatus.CONFLICT).body("Shopping basket is already empty or checked out");
        }

        Client client = shoppingBasketService.getClientByShoppingBasketId(shoppingBasketId);
        if (client == null) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Client not found");
        }

        try {
            // Sammeln der Artikel und deren Mengen
            Map<ItemId, Integer> itemQuantities = gatherItemQuantities(shoppingBasket);

            // Verteilzentren auswählen
            Map<UUID, Map<ItemId, Integer>> ordersByDistributionCenter = selectDistributionCenters(itemQuantities, client);

            // Bestände entfernen und Einkaufswagen leeren
            processOrdersAndClearBasket(ordersByDistributionCenter, shoppingBasket);

            // Bestellungen erstellen
            List<OrderDTO> orders = createOrders(ordersByDistributionCenter, client);

            return ResponseEntity.status(HttpStatus.CREATED).body(orders);
        } catch (ShopException e) {
            return ResponseEntity.status(HttpStatus.CONFLICT).body(e.getMessage());
        }
    }

    private boolean isShoppingBasketEmptyOrCheckedOut(ShoppingBasket shoppingBasket) {
        return shoppingBasket.getShoppingBasketPositions().isEmpty();
    }

    private Map<ItemId, Integer> gatherItemQuantities(ShoppingBasket shoppingBasket) {
        Map<ItemId, Integer> itemQuantities = new HashMap<>();
        for (ShoppingBasketPosition position : shoppingBasket.getShoppingBasketPositions()) {
            itemQuantities.put(new ItemId(position.getItemId()), position.getQuantity());
        }
        return itemQuantities;
    }

    private Map<UUID, Map<ItemId, Integer>> selectDistributionCenters(Map<ItemId, Integer> itemQuantities, Client client) throws ShopException {
        Iterable<DistributionCenter> dcIterable = distributionCenterService.findAll();
        Map<UUID, Map<ItemId, Integer>> ordersByDistributionCenter = new HashMap<>();

        for (Map.Entry<ItemId, Integer> entry : itemQuantities.entrySet()) {
            ItemId itemId = entry.getKey();
            int quantityNeeded = entry.getValue();

            // Übergabe von itemQuantities an die findBestDistributionCenter-Methode
            DistributionCenter selectedCenter = findBestDistributionCenter(itemQuantities, itemId, quantityNeeded, dcIterable, client);

            if (selectedCenter == null) {
                throw new ShopException("No suitable distribution center found for item: " + itemId);
            }

            ordersByDistributionCenter.computeIfAbsent(selectedCenter.getId().getId(), k -> new HashMap<>())
                    .put(itemId, quantityNeeded);
        }

        return ordersByDistributionCenter;
    }

    private DistributionCenter findBestDistributionCenter(Map<ItemId, Integer> itemQuantities, ItemId itemId, int quantityNeeded, Iterable<DistributionCenter> dcIterable, Client client) {
        DistributionCenter selectedCenter = null;

        for (DistributionCenter center : dcIterable) {
            StockLevel stockLevel = stockService.findByDistributionCenterAndItemId(center, itemId.getId()).orElse(null);

            if (stockLevel != null && stockLevel.getQuantity() >= quantityNeeded) {
                if (selectedCenter == null ||
                        new DistributionCenterComparator(itemQuantities, client.getPhysicalAddress().getZipCode().toString(), stockService.getStockLevelRepository())
                                .compare(center, selectedCenter) < 0) {
                    selectedCenter = center;
                }
            }
        }
        return selectedCenter;
    }

    private void processOrdersAndClearBasket(Map<UUID, Map<ItemId, Integer>> ordersByDistributionCenter, ShoppingBasket shoppingBasket) throws ShopException {
        // Artikel aus dem Lager entfernen
        for (Map.Entry<UUID, Map<ItemId, Integer>> order : ordersByDistributionCenter.entrySet()) {
            UUID dcId = order.getKey();
            for (Map.Entry<ItemId, Integer> itemEntry : order.getValue().entrySet()) {
                distributionCenterService.removeFromStock(dcId, itemEntry.getKey().getId(), itemEntry.getValue());
            }
        }

        // Leeren des Einkaufswagens
        shoppingBasket.getShoppingBasketPositions().clear();
        shoppingBasketService.save(shoppingBasket);
    }

    private List<OrderDTO> createOrders(Map<UUID, Map<ItemId, Integer>> ordersByDistributionCenter, Client client) {
        List<OrderDTO> orders = new ArrayList<>();
        for (UUID dcId : ordersByDistributionCenter.keySet()) {
            orders.add(new OrderDTO(UUID.randomUUID(), client.getName(), dcId, Collections.emptyList()));
        }
        return orders;
    }

    private ShoppingBasketResponseDTO mapToDTO(ShoppingBasket shoppingBasket, Map<UUID, Integer> basketMap,
                                               ShoppingBasketUseCases shoppingBasketService, EmailType clientEmail) {
        List<ShoppingBasketItemResponseDTO> positions = new ArrayList<>();
        basketMap.forEach((itemId, quantity) -> positions.add(new ShoppingBasketItemResponseDTO(itemId, quantity)));

        String totalSalesPrice = ((Money) shoppingBasketService.getShoppingBasketAsMoneyValue(clientEmail)).toFormattedString();
        return new ShoppingBasketResponseDTO(shoppingBasket.getId().getId(), totalSalesPrice, positions);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketItemResponseDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import java.io.Serializable;
import java.util.UUID;

public class ShoppingBasketItemResponseDTO implements Serializable {
    private UUID itemId;
    private int quantity;

    public ShoppingBasketItemResponseDTO(UUID itemId, int quantity) {
        this.itemId = itemId;
        this.quantity = quantity;
    }

    public UUID getItemId() {
        return itemId;
    }

    public void setItemId(UUID itemId) {
        this.itemId = itemId;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketResponseDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import java.util.List;
import java.util.UUID;

public class ShoppingBasketResponseDTO {
    private UUID id;
    private String totalSalesPrice;
    private List<ShoppingBasketItemResponseDTO> positions;

    public ShoppingBasketResponseDTO(UUID id, String totalSalesPrice, List<ShoppingBasketItemResponseDTO> positions) {
        this.id = id;
        this.totalSalesPrice = totalSalesPrice;
        this.positions = positions;
    }

    // Getter und Setter
    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public String getTotalSalesPrice() {
        return totalSalesPrice;
    }

    public void setTotalSalesPrice(String totalSalesPrice) {
        this.totalSalesPrice = totalSalesPrice;
    }

    public List<ShoppingBasketItemResponseDTO> getPositions() {
        return positions;
    }

    public void setPositions(List<ShoppingBasketItemResponseDTO> positions) {
        this.positions = positions;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.InsufficientStockException;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientId;
import thkoeln.archilab.ecommerce.solution.distributioncenter.application.DistributionCenterService;
import thkoeln.archilab.ecommerce.solution.distributioncenter.domain.*;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemId;
import thkoeln.archilab.ecommerce.solution.order.domain.*;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketId;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.solution.item.domain.Item;
import thkoeln.archilab.ecommerce.solution.item.domain.ItemRepository;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

@Service
public class ShoppingBasketService implements ShoppingBasketUseCases {

    @Autowired
    private ClientRepository clientRepository;

    @Autowired
    private ItemRepository itemRepository;

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private StockLevelRepository stockLevelRepository;

    @Autowired
    private ShoppingBasketRepository shoppingBasketRepository;

    @Autowired
    private DistributionCenterService distributionCenterService;

    @Autowired
    private DistributionCenterRepository distributionCenterRepository;

    @Override
    public void addItemToShoppingBasket(EmailType clientEmail, UUID itemId, int quantFor) {
        // Validierung führt bei den erwarteten Fehlerbedingungen zu einer Exception
        validateInputs(String.valueOf(clientEmail), itemId, quantFor);

        // Wenn keine Exception geworfen wird, fortfahren:
        ShoppingBasket shoppingBasket = getShoppingBasketByEmail(String.valueOf(clientEmail));

        ShoppingBasketPosition position = shoppingBasket.getShoppingBasketPositions().stream()
                .filter(pos -> pos.getItemId().equals(itemId))
                .findFirst()
                .orElse(null);

        if (position == null) {
            // Erstelle eine neue Position und füge sie dem ShoppingBasket hinzu
            position = new ShoppingBasketPosition(itemId, quantFor); // Jetzt nur itemId und quantFor übergeben
            shoppingBasket.getShoppingBasketPositions().add(position);
        } else {
            // Wenn die Position bereits existiert, die Menge aktualisieren
            position.setQuantity(position.getQuantity() + quantFor);
        }

        // Speichere das ShoppingBasket mit der neuen oder aktualisierten Position
        shoppingBasketRepository.save(shoppingBasket);
    }

    @Override
    public void removeItemFromShoppingBasket(EmailType clientEmail, UUID itemId, int quantFor) {
        validateInputs(String.valueOf(clientEmail), itemId, quantFor);
        ShoppingBasket shoppingBasket = getShoppingBasketByEmail(String.valueOf(clientEmail));

        ShoppingBasketPosition position = shoppingBasket.getShoppingBasketPositions().stream()
                .filter(pos -> pos.getItemId().equals(itemId))
                .findFirst()
                .orElseThrow(() -> new ShopException("Item not found in shopping basket"));

        if (position.getQuantity() < quantFor) {
            throw new ShopException("Not enough quantity to remove");
        }

        position.setQuantity(position.getQuantity() - quantFor);
        if (position.getQuantity() == 0) {
            shoppingBasket.getShoppingBasketPositions().remove(position);
        }

        shoppingBasketRepository.save(shoppingBasket);
    }

    @Override
    public Map<UUID, Integer> getShoppingBasketAsMap(EmailType clientEmail) {
        ClientId clientId = ClientId.fromEmail(clientEmail.toString());

        Client client = clientRepository.findById(clientId)
                .orElseThrow(() -> new IllegalArgumentException("Invalid client email"));

        ShoppingBasket shoppingBasket = shoppingBasketRepository.findById(new ShoppingBasketId(client.getShoppingBasketId()))
                .orElseThrow(() -> new IllegalArgumentException("Shopping basket not found for client"));

        Map<UUID, Integer> basketContents = new HashMap<>();
        shoppingBasket.getShoppingBasketPositions().forEach(position ->
                basketContents.put(new ItemId(position.getItemId()).getId(), position.getQuantity()));

        return basketContents;
    }

    @Override
    public MoneyType getShoppingBasketAsMoneyValue(EmailType clientEmail) {
        ShoppingBasket shoppingBasket = getShoppingBasketByEmail(String.valueOf(clientEmail));
        Money totalValue = Money.of(0.0f, "EUR");  // Verwendung der statischen Fabrikmethode
        for (ShoppingBasketPosition position : shoppingBasket.getShoppingBasketPositions()) {
            Item item = itemRepository.findById(new ItemId(position.getItemId()))
                    .orElseThrow(() -> new ShopException("Item not found"));
            MoneyType itemTotal = item.getSalesPrice().multiplyBy(position.getQuantity());
            totalValue = (Money) totalValue.add(itemTotal);
        }
        return totalValue;
    }

    @Override
    public Set<UUID> checkout(EmailType clientEmail) {
        Set<UUID> orderIds = new HashSet<>();
        ShoppingBasket shoppingBasket = validateAndPrepareBasket(clientEmail);
        Client client = getClient(clientEmail);
        Map<ItemId, Integer> itemQuantities = mapBasketToItemQuantities(shoppingBasket);

        List<DistributionCenter> distributionCenters = prepareDistributionCenters(itemQuantities, client);

        Map<UUID, Map<ItemId, Integer>> ordersByDistributionCenter = processOrders(itemQuantities, distributionCenters);

        // Hier sicherstellen, dass Verteilzentrum-IDs zu den erwarteten IDs passen
        System.out.println("Orders processed with distribution centers: " + ordersByDistributionCenter);

        createAndPersistOrders(client, ordersByDistributionCenter, orderIds);

        // Einkaufswagen bei erfolgreichem Checkout leeren
        clearShoppingBasket(shoppingBasket);

        return orderIds;
    }

    private ShoppingBasket validateAndPrepareBasket(EmailType clientEmail) {
        ShoppingBasket shoppingBasket = getShoppingBasketByEmail(clientEmail.toString());
        if (shoppingBasket.getShoppingBasketPositions().isEmpty()) {
            throw new ShopException("The shopping basket is empty");
        }
        return shoppingBasket;
    }

    private Client getClient(EmailType clientEmail) {
        return clientRepository.findById(ClientId.fromEmail(clientEmail.toString()))
                .orElseThrow(() -> new ShopException("Client not found"));
    }

    private Map<ItemId, Integer> mapBasketToItemQuantities(ShoppingBasket shoppingBasket) {
        return shoppingBasket.getShoppingBasketPositions().stream()
                .collect(Collectors.toMap(
                        pos -> new ItemId(pos.getItemId()),
                        ShoppingBasketPosition::getQuantity
                ));
    }

    private List<DistributionCenter> prepareDistributionCenters(Map<ItemId, Integer> itemQuantities, Client client) {
        // Debug-Ausgabe zur Überprüfung der Vorbereitung der Verteilzentren
        System.out.println("Preparing distribution centers for client: " + client.getId());
        for (Map.Entry<ItemId, Integer> entry : itemQuantities.entrySet()) {
            System.out.println("Item ID: " + entry.getKey() + ", Quantity Needed: " + entry.getValue());
        }

        return StreamSupport.stream(distributionCenterRepository.findAll().spliterator(), false)
                .sorted(new DistributionCenterComparator(itemQuantities, client.getPhysicalAddress().getZipCode().toString(), stockLevelRepository))
                .collect(Collectors.toList());
    }

    private Map<UUID, Map<ItemId, Integer>> processOrders(Map<ItemId, Integer> itemQuantities, List<DistributionCenter> distributionCenters) {
        Map<UUID, Map<ItemId, Integer>> ordersByDistributionCenter = new HashMap<>();

        // Verfolgung der verbleibenden und erfüllten Artikel
        Map<ItemId, Integer> remainingItems = new HashMap<>(itemQuantities);

        while (!remainingItems.isEmpty()) {
            DistributionCenter bestCenter = null;
            Map<ItemId, Integer> bestCenterOrder = new HashMap<>();
            int maxItemsFulfilled = 0;

            // Durchlaufe jedes Distribution Center, um das Beste zu finden
            for (DistributionCenter dc : distributionCenters) {
                Map<ItemId, Integer> currentCenterOrder = new HashMap<>();
                int itemsFulfilled = 0;

                for (Map.Entry<ItemId, Integer> entry : remainingItems.entrySet()) {
                    ItemId itemId = entry.getKey();
                    int quantityNeeded = entry.getValue();

                    StockLevel stockLevel = stockLevelRepository.findByDistributionCenterAndItemId(dc, itemId.getId()).orElse(null);
                    int availableQuantity = (stockLevel != null) ? stockLevel.getQuantity() : 0;

                    if (availableQuantity >= quantityNeeded) {
                        currentCenterOrder.put(itemId, quantityNeeded);
                        itemsFulfilled++;
                    }
                }

                if (itemsFulfilled > maxItemsFulfilled) {
                    bestCenter = dc;
                    bestCenterOrder = currentCenterOrder;
                    maxItemsFulfilled = itemsFulfilled;
                }
            }

            if (bestCenter == null) {
                throw new InsufficientStockException("Nicht genügend Bestand um alle Artikel zu erfüllen");
            }

            // Aktualisiere Bestände und verbleibende Artikel
            UUID centerId = bestCenter.getId().getId();
            for (Map.Entry<ItemId, Integer> entry : bestCenterOrder.entrySet()) {
                ItemId itemId = entry.getKey();
                int quantity = entry.getValue();

                StockLevel stockLevel = stockLevelRepository.findByDistributionCenterAndItemId(bestCenter, itemId.getId()).orElse(null);
                if (stockLevel != null) {
                    stockLevel.setQuantity(stockLevel.getQuantity() - quantity);
                    stockLevelRepository.save(stockLevel);
                }

                remainingItems.remove(itemId);
            }

            ordersByDistributionCenter.put(centerId, bestCenterOrder);

            // Überprüfung, ob die spezifischen Zuweisungen (wie itemId12) im Code sichergestellt werden können.
        }

        return ordersByDistributionCenter;
    }

    private void createAndPersistOrders(Client client, Map<UUID, Map<ItemId, Integer>> ordersByDistributionCenter, Set<UUID> orderIds) {
        for (Map.Entry<UUID, Map<ItemId, Integer>> entry : ordersByDistributionCenter.entrySet()) {
            Order order = new Order();
            order.setId(new OrderId(UUID.randomUUID()));
            order.setClientId(client.getId());
            order.setDistributionCenterId(entry.getKey());  // DistributionCenterId hier setzen

            for (Map.Entry<ItemId, Integer> itemEntry : entry.getValue().entrySet()) {
                OrderPosition orderPosition = new OrderPosition();
                orderPosition.setId(new OrderPositionId(order.getOrderId(), itemEntry.getKey().getId()));
                orderPosition.setQuantity(itemEntry.getValue());

                order.getOrderPositions().add(orderPosition);
            }

            orderRepository.save(order);
            orderIds.add(order.getId().getId());
        }
    }

    @Override
    public void emptyAllShoppingBaskets() {
        Iterable<ShoppingBasket> shoppingBaskets = shoppingBasketRepository.findAll();
        for (ShoppingBasket shoppingBasket : shoppingBaskets) {
            shoppingBasket.getShoppingBasketPositions().clear();
            shoppingBasketRepository.save(shoppingBasket);
        }
    }

    private void validateInputs(String clientEmail, UUID itemId, int quantFor) {
        if (clientEmail == null || clientEmail.isEmpty()) {
            throw new ShopException("Client email cannot be null or empty");
        }
        if (itemId == null) {
            throw new ShopException("Item ID cannot be null");
        }
        if (quantFor < 0) {
            throw new ShopException("Quantity cannot be negative");
        }

        // Prüfen, ob der Client existiert
        if (!clientRepository.existsById(ClientId.fromEmail(clientEmail))) {
            throw new ShopException("Client does not exist.");
        }

        // Prüfen, ob das Item existiert
        if (!itemRepository.existsById(new ItemId(itemId))) {
            throw new ShopException("Item does not exist.");
        }
    }

    public ShoppingBasket getShoppingBasketByEmail(String clientEmail) {
        Client client = clientRepository.findById(ClientId.fromEmail(clientEmail))
                .orElseThrow(() -> new ShopException("Client not found"));

        UUID shoppingBasketId = client.getShoppingBasketId();
        return shoppingBasketRepository.findById(new ShoppingBasketId(shoppingBasketId))
                .orElseThrow(() -> new ShopException("Shopping basket does not exist"));
    }


    private void clearShoppingBasket(ShoppingBasket shoppingBasket) {
        shoppingBasket.getShoppingBasketPositions().clear();
        shoppingBasketRepository.save(shoppingBasket);

    }

    public Client getClientByShoppingBasketId(UUID shoppingBasketId) {
        // Sicherstellen, dass Debugging-Informationen für die Diagnose hinzugefügt werden
        System.out.println("Attempting to find client for Shopping Basket ID: " + shoppingBasketId);

        return clientRepository.findByShoppingBasketId(shoppingBasketId)
                .orElseThrow(() -> new ShopException("Client not found for provided shopping basket ID"));
    }

    public Optional<ShoppingBasket> findById(ShoppingBasketId shoppingBasketId) {
        return shoppingBasketRepository.findById(shoppingBasketId);
    }

    public void save(ShoppingBasket shoppingBasket) {
        shoppingBasketRepository.save(shoppingBasket);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppableInterface.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import java.util.List;
import java.util.UUID;

public interface ShoppableInterface {
    UUID getShoppingBasketId();
    List<ShoppingBasketPosition> getShoppingBasketPositions();
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.client.domain.Shoppable;

import java.util.*;

@Entity
@Getter
@Setter
public class ShoppingBasket {

    @EmbeddedId
    private ShoppingBasketId id;

    // Verknüpft die Positionen über JoinColumn, aber ohne redundante Spaltenbenennung
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
    @JoinColumn(name = "shopping_basket_id")
    private List<ShoppingBasketPosition> shoppingBasketPositions = new ArrayList<>();

    // Default-Konstruktor
    public ShoppingBasket() {
        this.id = new ShoppingBasketId(UUID.randomUUID());
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketId.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
public class ShoppingBasketId extends GenericId {
    // No-Argument-Konstruktor benötigt von Hibernate
    protected ShoppingBasketId() {
        super();
    }

    public ShoppingBasketId(UUID id) {
        super(id);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ShoppingBasketIdConverter extends GenericIdConverter<ShoppingBasketId> {
    public ShoppingBasketIdConverter() {
        super(ShoppingBasketId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.UUID;


@Entity
@Getter
@Setter
@NoArgsConstructor
public class ShoppingBasketPosition {

    @EmbeddedId
    private ShoppingBasketPositionId id;

    private int quantity;

    private UUID itemId;

    // Konstruktor ohne die shoppingBasketId
    public ShoppingBasketPosition(UUID itemId, int quantity) {
        this.id = new ShoppingBasketPositionId(UUID.randomUUID());
        this.itemId = itemId;
        this.quantity = quantity;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import java.util.UUID;

public class ShoppingBasketPositionDTO {
    private UUID itemId;
    private int quantity;

    public ShoppingBasketPositionDTO(UUID itemId, int quantity) {
        this.itemId = itemId;
        this.quantity = quantity;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionId.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED) // Sicherstellen, dass ein geschützter No-Args-Konstruktor existiert
public class ShoppingBasketPositionId extends GenericId {

    public ShoppingBasketPositionId(UUID id) {
        super(id);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ShoppingBasketPositionIdConverter extends GenericIdConverter<ShoppingBasketPositionId> {
    public ShoppingBasketPositionIdConverter() {
        super(ShoppingBasketPositionId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketRepository.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import org.springframework.data.repository.CrudRepository;

public interface ShoppingBasketRepository extends CrudRepository<ShoppingBasket, ShoppingBasketId> {}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\ClientRegistrationUseCases.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

/**
 * This interface contains methods needed in the context of use cases concerning the registration of a client.
 * The interface is probably incomplete, and will grow over time ...
 */
public interface ClientRegistrationUseCases {
    /**
     * Registers a new client
     *
     * @param name
     * @param email
     * @param physicalAddress
     * @throws ShopException if ...
     *      - the client with the given email already exists
     *      - physicalAddress is null
     */
    public void register( String name, EmailType email, PhysicalAddressType physicalAddress );


    /**
     * Changes the address of a client
     *
     * @param clientEmail
     * @param clientEmail
     * @param physicalAddress
     * @throws ShopException if ...
     *      - the client with the given email does not exist,
     *      - physicalAddress is null
     */
    public void changeAddress( EmailType clientEmail,
                               PhysicalAddressType physicalAddress );


    /**
     * Returns the data of a client as an array of strings (name, email, street, city, zipCode)
     * @param clientEmail
     * @return the client data
     * @throws ShopException the client with the given email does not exist,
     */
    public ClientType getClientData( EmailType clientEmail );



    /**
     * Clears all clients, including all orders and shopping baskets
     */
    public void deleteAllClients();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\ClientType.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

/**
 * This interface expresses the essence of a shop client
 */
public interface ClientType {
    String getName();
    EmailType getEmail();
    PhysicalAddressType getPhysicalAddress();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\DistributionCenterUseCases.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.UUID;

/**
 * This interface contains methods needed in the context of handling the shop stock,
 * i.e. managing distribution centers, and adding / removing items in the distribution center.
 */
public interface DistributionCenterUseCases {
    /**
     *
     * @param name
     * @param physicalAddress
     * @return the id of the new distribution center
     * @throws ShopException if ...
     *      - name is null or empty
     *      - physicalAddress is null
     */
    public UUID addNewDistributionCenter( String name, PhysicalAddressType physicalAddress );


    /**
     * Deletes all distribution centers from the shop. Intended for testing purposes.
     */
    public void deleteAllDistributionCenters();


    /**
     * Adds a certain Quantity of a given item to the stock
     * @param distributionCenterId
     * @param itemId
     * @param addedQuantFor
     * @throws ShopException if ...
     *      - distributionCenterId is null
     *      - the distribution center with that id does not exist
     *      - itemId is null
     *      - the item with that id does not exist
     *      - addedQuantFor < 0
     */
    public void addToStock( UUID distributionCenterId, UUID itemId, int addedQuantFor );


    /**
     * Removes a certain Quantity of a given item from the stock.
     * @param distributionCenterId
     * @param itemId
     * @param removedQuantFor
     * @throws ShopException if ...
     *      - distributionCenterId is null
     *      - the distribution center with that id does not exist
     *      - itemId is null
     *      - the item with that id does not exist
     *      - removedQuantFor < 0
     */
    public void removeFromStock( UUID distributionCenterId, UUID itemId, int removedQuantFor );


    /**
     * Changes the total Quantity of a given item in the stock.
     * @param distributionCenterId
     * @param itemId
     * @param newTotalQuantFor
     * @throws ShopException if ...
     *      - distributionCenterId is null
     *      - the distribution center with that id does not exist
     *      - itemId is null
     *      - the item with that id does not exist
     *      - newTotalQuantFor < 0
     */
    public void changeStockTo( UUID distributionCenterId, UUID itemId, int newTotalQuantFor );


    /**
     * Get the current stock of a given item in one specific distribution center.
     * @param distributionCenterId
     * @param itemId
     * @return the current total stock of the item
     * @throws ShopException if ...
     *      - distributionCenterId is null
     *      - the distribution center with that id does not exist
     *      - itemId is null
     *      - the item with that id does not exist
     */
    public int getAvailableStock( UUID distributionCenterId, UUID itemId );


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\EmailType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface EmailType {
    /**
     * @return the email as a string
     */
    public String toString();


    /**
     * A special kind of "copy constructor": Returns a new email object with
     * the same identifyer (the substring left of the "@" sign) as the current one, but
     * with a new domain substring (right of the "@" sign).
     * @param domainString - the new domain for the copied email
     * @return the new email
     * @throws ShopException if ...
     *     - domainString is null
     *     - the new email would not be valid (see `of(...)` method)
     */
    public EmailType sameIdentifyerDifferentDomain( String domainString );

    /**
     * Another special kind of "copy constructor": Returns a new email object
     * with the same domain (the substring right of the "@" sign) as the current one, but
     * with a new identifyer substring (left of the "@" sign).
     * @param identifyerString - the new identifyer for the copied email
     * @return the new email
     * @throws ShopException if ...
     *     - identifyerString is null
     *     - the new email would not be valid (see `of(...)` method)
     */
    public EmailType sameDomainDifferentIdentifyer( String identifyerString );


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an email, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param emailAsString - the email as a string.
     *      We will use a much simplified validation method to check if the email is valid:
     *      - it must contain exactly one '@' character.
     *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
     *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
     *      - the substrings before and after the '@' may contain one or several '.' as separators
     *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
     *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
     *        (for simplicity we do not allow any other domains)
     * @return a new EmailType object matching the given email
     * @throws ShopException if ...
     *      - emailAsString is null
     *      - emailAsString is not a valid email (see above)
     */
     // public static EmailType of( String emailAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MoneyType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface MoneyType {
    /**
     * @return the amount of money
     */
    public Float getAmount();


    /**
     * @return the currency unit of the money
     */
    public String getCurrencyUnit();


    /**
     * @param otherMoney
     * @return this + otherMoney, as a new object
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currencyUnit != this.currencyUnit
     */
    public MoneyType add( MoneyType otherMoney );


    /**
     * @param otherMoney
     * @return this - otherMoney, as a new object
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currencyUnit != this.currencyUnit
     *      - otherMoney > this
     */
    public MoneyType subtract( MoneyType otherMoney );


    /**
     * @param factor
     * @return this * factor, as a new object
     * @throws ShopException if ...
     *     - factor < 0
     */
    public MoneyType multiplyBy( int factor );

    /**
     * @param otherMoney
     * @return true, if this > otherMoney
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currencyUnit != this.currencyUnit
     */
    public boolean largerThan( MoneyType otherMoney );


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates a money object from an amount and a currency unit (as string).
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param amount the amount of money (must be >= 0)
     * @param currencyUnit the currency unit of the money (allowed values: "EUR", "CHF")
     * @return a new Money object with the given amount and currency unit
     * @throws ShopException if ...
     *   - amount is null
     *   - amount < 0
     *   - currency unit is null
     *   - currency unit is not one of the allowed values
     */
     // public static MoneyType of( Float amount, String currencyUnit );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PhysicalAddressType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface PhysicalAddressType {
    /**
     * @return the street as a string
     */
    public String getStreet();

    /**
     * @return the city as a string
     */
    public String getCity();

    /**
     * @return the zip code
     */
    public ZipCodeType getZipCode();

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an zip code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param street the street as a string
     * @param city the city as a string
     * @param zipCode the zip code
     * @return the physical address object matching the parameters
     * @throws ShopException if ...
     *      - street is null or empty
     *      - city is null or empty
     *      - zipCode is null
     */
     // public static PhysicalAddressType of( String street, String city, ZipCodeType zipCode );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\ZipCodeType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import com.fasterxml.jackson.annotation.JsonIgnore;
import thkoeln.archilab.ecommerce.ShopException;

public interface ZipCodeType {
    /**
     * @return the zip code as a string
     */
    public String toString();

    /**
     * You will need some idea of "imprecise difference" between two zip codes for properly
     * implementing distribution centers in your shopping platform. This method calculates such a
     * difference. You can decide for yourself what values you return, unless you comply
     * with the following rules.
     * - The return value is 0 if both zip codes are the same
     * - If not:
     *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
     *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
     *        So, 56733 and 56734 have the same difference as 56733 and 56739.
     *      - The difference grows if more digits (counted from the right side) differ.
     *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
     *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
     *        53876 and 54876 have the same difference as 53876 and 57261.
     *      - However, the difference between 5abcd and 6rstu must be smaller than the one
     *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
     *        one between 5abcd and 9rstu.
     *      - This last condition reflects the fact the first digits of a zip code marks a region
     *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
     *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
     *        other.
     * @param otherZipCode
     * @return the calculated difference
     * @throws ShopException if otherZipCode is null
     */
    public int difference( ZipCodeType otherZipCode );


    /**
     * For the currently used way of deciding on the best fitting distribution center for a order,
     * we need to know the first digit of the zip code.
     */
    @JsonIgnore
    public Integer getFirstDigitZipCode();


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an zip code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param zipCodeAsString - the zip code as a string.
     *      We will use a much simplified validation method to check if the zip code is valid:
     *      - It must contain exactly 5 digits.
     *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid zip code, but 20001 is valid)
     * @return a new zip code object matching the given string
     * @throws ShopException if ...
     *      - zipCodeAsString is null
     *      - zipCodeAsString is not a valid zip code (see above)
     */
     // public static ZipCodeType of( String zipCodeAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\ItemCatalogUseCases.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;


/**
 * This interface contains methods needed in the context of use cases concerning the item catalog.
 * The interface is probably incomplete, and will grow over time ...
 */

public interface ItemCatalogUseCases {
    /**
     * Adds a new item to the shop catalog
     * @param name
     * @param descriptOf
     * @param size
     * @param buyingPrice
     * @param salesPrice
     * @return the id of the new item
     * @throws ShopException if ...
     *      - the item id already exists,
     *      - name or description are null or empty,
     *      - the size is <= 0 (but can be null!),
     *      - the buying price is null or <= 0,
     *      - the buyingPrice is null,
     *      - the sales price is null,
     *      - the sales price is lower than the buyingPrice
     */
    public UUID addItemToCatalog( String name, String descriptOf, Float size,
                                           MoneyType buyingPrice, MoneyType salesPrice );


    /**
     * Removes a item from the shop catalog
     * @param itemId
     * @throws ShopException if
     *      - itemId is null
     *      - the item id does not exist
     *      - the item is still in stock
     *      - the item is still in a shopping basket, or referenced by a completed order
     */
    public void removeItemFromCatalog( UUID itemId );


    /**
     * Get the sales price of a given item
     * @param itemId
     * @return the sales price
     * @throws ShopException if ...
     *      - itemId is null,
     *      - the item with that id does not exist
     */
    public MoneyType getSalesPrice( UUID itemId );


    /**
     * Clears the item catalog, i.e. removes all items from the catalog, including all the stock,
     * all the reservations and all the orders.
     */
    public void deleteItemCatalog();

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ClientTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;


import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

/**
 * This is a test helper interface provides access to predefined test data for
 * clients.
 */
public interface ClientTestHelper {
    /**
     * This method calls the use case implementation to register all clients specified in the
     * test data set.
     * If you use the debugger and want to identify _which_ test client you currently look at:
     * The indices are coded into the house number (in the client's physical address) and in the first
     * cipher of the zip code. This is the list of clients:
     *
     * +-------+-------------------+--------+---------------------
     * | Index | Name              | PLZ    | Email
     * +-------+-------------------+--------+---------------------
     * | 0     | Max Mueller       | 02314  | 99Z@example.com
     * | 1     | Sophie Schmitz    | 02368  | a@4.com
     * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
     * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
     * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
     * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
     * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
     * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
     * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
     * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
     * +-------+-------------------+--------+---------------------
     */
    void registerAllClients();


    /**
     * @return the number of test clients in the test data set.
     */
    int getNumberOfClients();


    /**
     * @param index the index of the client in the test data set.
     * @return the name of the test client with the given index.
     */
    String getClientName( int index );


    /**
     * @param index the index of the client in the test data set.
     * @return the email of the test client with the given index.
     */
    EmailType getClientEmail( int index );


    /**
     * @param index the index of the client in the test data set.
     * @return the physical address of the test client with the given index.
     */
    PhysicalAddressType getClientPhysicalAddress( int index );


    /**
     * @param index the index of the client in the test data set.
     * @return the test client with the given index.
     */
    ClientType getClient( int index );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\DistributionCenterTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import java.util.UUID;

public interface DistributionCenterTestHelper {
    /**
     * Adds the test distribution centers to the system.
     * If you want to use the distribution centers, or want to know which index the distribution center has that you see
     * in the debugger, the following rules apply:
     * - The distribution center name will equal the street name of the physical address of the distribution center.
     * - The index number is visible in the house number. Example: distribution center 3 is located at
     *   "Ablageweg 3", and that is also its name.
     *
     *  The distribution centers are used in the tests as follows:
     *  - distribution center 0 holds all items 0 - 6, and is used for all tests where it is not relevant
     *    to split one shopping basket into several orders.
     *  - distribution centers 1 - 3 are used for the proximity tests, where you can deliver item 7 to
     *    to a client from the closest distribution center.
     *  - distribution centers 4 - 8 are used for the tests where you need to deliver items 8 - 14 in
     *    the most cost-efficient way, as multiple shipments.
     *  - distribution center 9 is empty.
     *
     *  If withStock is true, then the distribution centers are filled with items. This happens
     *  according to the following rules:
     *  - items 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
     *    ONLY available in distribution center 0. (This means that item 0 out of stock everywhere.)
     *  - items 4, 5, 6 have a random stock between 30 and 130, also all ONLY in distribution center 0
          (these are the items used for tests on how to add and remove stock)
     *  - item 7 has a random stock between 30 and 130, distributed over
     *    distribution centers 1, 2, and 3. You can use this to test if the appropriate distribution center is found
     *    for a shopping basket with only item 7 in it, but with different quantities (<= 3, or > 3).
     *  - The other items (8 - 14) have also a random stock between 30 and 130, all distributed
     *    over several distribution centers. The distribution is done as follows:
     *    Assume that the item is available in <n> distribution centers. Then the first <n-1> distribution centers
     *    in the list (in ascending sequence) contain 3, and all the remaining stock is in the
     *    last distribution center.
     *
     *    This is how the stock of items could be distributed
     *    (Wx = distribution center x with its zip code, Px = item x,
     *    numbers marked with (*) are random large numbers):
     *
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
     *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *    | P0   |      |     |     |      |     |      |     |       |      |     |
     *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
     *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
     *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
     *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
     *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
     *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
     *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
     *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
     *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
     *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
     *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
     *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
     *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
     *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *
     * @param withStock if true, the stock of the items is added to the distribution center. Otherwise, the
     *                           the stock is not added and the distribution center is empty.
     */
    public void addAllDistributionCenters( boolean withStock );


    /**
     * @return the number of test distribution centers in the database
     */
    int numberOfDistributionCenters();


    /**
     * @param index
     * @return the id of the test distribution center at the given index
     */
    UUID getDistributionCenterId( int index );


    /**
     * @param distributionCenterId - the id of the distribution center in the test data
     * @return the index of the test distribution center with that id
     */
    int findDistributionCenterIndex( UUID distributionCenterId );


    /**
     * @param itemIndex - the index of the item in the test data
     * @param distributionCenterIndex - the index of the distribution center in the test data
     * @return the number of items (stock) available in the distribution center at the given index
     */
    Integer getDistributionCenterStock( int distributionCenterIndex, int itemIndex );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.Enumeration;

import static org.junit.jupiter.api.Assertions.*;

public class FactoryMethodInvoker {

    public static EmailType instantiateEmail( String emailAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for EmailType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, emailAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + emailAsString + "'", e );
        }
        assertNotNull( instance );
        return (EmailType) instance;
    }


    public static PhysicalAddressType instantiatePhysicalAddress(
            String street, String city, ZipCodeType zipCode ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of",
                    String.class, String.class, ZipCodeType.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for PhysicalAddressType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, street, city, zipCode );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" +
                    street + "', '" + city + "', '" + zipCode + "'", e );
        }
        assertNotNull( instance );
        return (PhysicalAddressType) instance;
    }


    public static ZipCodeType instantiateZipCode( String zipCodeAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for ZipCodeType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, zipCodeAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + zipCodeAsString + "'", e );
        }
        assertNotNull( instance );
        return (ZipCodeType) instance;
    }


    public static MoneyType instantiateMoney( Float amount, String currencyUnit ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for MoneyType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, amount, currencyUnit );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + amount + "', '" + currencyUnit + "'", e );
        }
        assertNotNull( instance );
        return (MoneyType) instance;
    }


    private static Class<?> findImplementation( Class<?> interfaceClass ) {
        Method factoryMethod = null;
        try {
            String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
            Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
            assertNotNull( implementingClass );
            return implementingClass;
        } catch (Exception e) {
            fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
            return null; // This line will never be reached, but it's necessary to satisfy the compiler
        }
    }


    private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
            throws ClassNotFoundException, IOException {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        String path = packageName.replace( '.', '/' );
        Enumeration<URL> resources = classLoader.getResources( path );
        int count = 0;
        Class<?> result = null;
        while (resources.hasMoreElements()) {
            URL resource = resources.nextElement();
            File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
            File[] files = directory.listFiles();
            for ( File file : files ) {
                if ( file.getName().endsWith( ".class" ) ) {
                    String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
                    Class<?> clazz = Class.forName( className );
                    if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
                        count++;
                        result = clazz;
                    }
                }
            }
        }
        assertEquals( 1, count, "There should be exactly one implementing class" );
        return result;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\ClientTestHelperImpl.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
import thkoeln.archilab.ecommerce.usecases.masterdata.MockClient;

import static org.junit.jupiter.api.Assertions.assertThrows;

/**
 * This is a test helper class that initializes and registers clients in the system,
 * using the given interface(s).
 */
@Component
@SuppressWarnings("PMD")
public class ClientTestHelperImpl implements ClientTestHelper {

    private ClientRegistrationUseCases clientRegistrationUseCases;

    @Autowired
    public ClientTestHelperImpl( ClientRegistrationUseCases clientRegistrationUseCases ) {
        this.clientRegistrationUseCases = clientRegistrationUseCases;
    }

    private final static String[] CLIENT_NAME = new String[]{
            "Max Mueller",
            "Sophie Schmitz",
            "Irene Mihalic",
            "Emilia Fischer",
            "Filiz Polat",
            "Lina Wagner",
            "Leon Becker",
            "Agnieszka Kalterer",
            "Felix Bauer",
            "Lara Schulz"
    };

    private final static EmailType[] CLIENT_EMAIL = new EmailType[]{
            FactoryMethodInvoker.instantiateEmail( "99Z@example.com" ),
            FactoryMethodInvoker.instantiateEmail( "a@4.com" ),
            FactoryMethodInvoker.instantiateEmail( "irene@wearefreedomnow.com" ),
            FactoryMethodInvoker.instantiateEmail( "emilia.fischer@example.com" ),
            FactoryMethodInvoker.instantiateEmail( "j877d3@example.this.com" ),
            FactoryMethodInvoker.instantiateEmail( "lina.marie.wagner@example.com" ),
            FactoryMethodInvoker.instantiateEmail( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
            FactoryMethodInvoker.instantiateEmail( "agna@here.ch" ),
            FactoryMethodInvoker.instantiateEmail( "felix.bauer@example.org" ),
            FactoryMethodInvoker.instantiateEmail( "lara.schulz@example.at" )
    };

    // The following array is used to create a list of physicalAddresss for the clients.
    // The indices are coded into the house number.
    // - Persons 0 - 5 are used for proximity tests with one distribution center.
    private final static PhysicalAddressType[] CLIENT_ADDRESS = new PhysicalAddressType[]{
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Marktstraße 0", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02314" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Hauptstraße 1", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02368" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Kirchplatz 2", "Niemandstown",
                    FactoryMethodInvoker.instantiateZipCode( "12345" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Schulstraße 3", "Geisterhausen",
                    FactoryMethodInvoker.instantiateZipCode( "31463" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Rosenweg 4", "Kuhhausen",
                    FactoryMethodInvoker.instantiateZipCode( "72162" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Wiesenstraße 5", "Waldschenkensdorf",
                    FactoryMethodInvoker.instantiateZipCode( "82195" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Muehlenweg 6", "Koeln",
                    FactoryMethodInvoker.instantiateZipCode( "50667" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Goethestraße 7", "Frankfurt am Main",
                    FactoryMethodInvoker.instantiateZipCode( "60311" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Dorfstraße 8", "Stuttgart",
                    FactoryMethodInvoker.instantiateZipCode( "70173" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Bahnhofstraße 9", "Muenchen",
                    FactoryMethodInvoker.instantiateZipCode( "80331" ) )
    };

    private final static ClientType[] mockClients;

    static {
        mockClients = new ClientType[CLIENT_NAME.length];
        for ( int i = 0; i < CLIENT_NAME.length; i++ ) {
            mockClients[i] = new MockClient(
                    CLIENT_NAME[i], CLIENT_EMAIL[i], CLIENT_ADDRESS[i] );
        }
    }


    @Override
    public void registerAllClients() {
        for ( int i = 0; i < CLIENT_NAME.length; i++ ) {
            registerClient( CLIENT_NAME[i], CLIENT_EMAIL[i], CLIENT_ADDRESS[i] );
        }
    }


    private void registerClient( String name, EmailType email, PhysicalAddressType physicalAddress ) {
        clientRegistrationUseCases.register( name, email, physicalAddress );
    }


    @Override
    public int getNumberOfClients() {
        return CLIENT_NAME.length;
    }


    @Override
    public String getClientName( int index ) {
        if ( index < 0 || index >= CLIENT_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return CLIENT_NAME[index];
    }


    @Override
    public EmailType getClientEmail( int index ) {
        if ( index < 0 || index >= CLIENT_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return CLIENT_EMAIL[index];
    }


    @Override
    public PhysicalAddressType getClientPhysicalAddress( int index ) {
        if ( index < 0 || index >= CLIENT_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return CLIENT_ADDRESS[index];
    }


    @Override
    public ClientType getClient( int index ) {
        if ( index < 0 || index >= CLIENT_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return mockClients[index];
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\StockTestHelperImpl.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.DistributionCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.DistributionCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;

import java.util.*;

/**
 * This is a test helper class that initializes and registers items (but without stock)
 * in the system, using the given interface(s).
 */
@Component
@SuppressWarnings("PMD")
public class StockTestHelperImpl
                        implements ItemTestHelper, DistributionCenterTestHelper {
    private ItemCatalogUseCases itemCatalogUseCases;
    private DistributionCenterUseCases distributionCenterUseCases;
    private static Random random = new Random();

    private static final String EUR = "EUR";
    private static final int ITEM_NUMOF = 15;
    private static final Object[][] ITEM_DATA = new Object[][]{
            {null, "0-TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
                    1.5f, FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 10.0f, EUR ),
                    "0"},
            {null, "1-EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
                    0.3f, FactoryMethodInvoker.instantiateMoney( 2.5f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 4.0f, EUR ),
                    "0"},
            {null, "2-MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
                    7.2f, FactoryMethodInvoker.instantiateMoney( 50.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
                    "0"},
            {null, "3-Gh-25", "Kompakter und leichter Akku für mobile Geräte",
                    null, FactoryMethodInvoker.instantiateMoney( 6.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 8.0f, EUR ),
                    "0"},
            {null, "4-MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
                    null, FactoryMethodInvoker.instantiateMoney( 0.6f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
                    "0"},
            {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
                    1.0f, FactoryMethodInvoker.instantiateMoney( 150.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 250.0f, EUR ),
                    "0"},
            {null, "6-Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
                    null, FactoryMethodInvoker.instantiateMoney( 0.3f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 0.5f, EUR ),
                    "0"},
            {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
                    6.0f, FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 120.0f, EUR ),
                    "123"},
            {null, "8-JKL-67", "Wasserdichtes Gehäuse",
                    3.0f, FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 1.2f, EUR ),
                    "467"},
            {null, "9-MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
                    5.5f, FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 45.0f, EUR ),
                    "578"},
            {null, "10-PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
                    4.0f, FactoryMethodInvoker.instantiateMoney( 20.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 35.0f, EUR ),
                    "567"},
            {null, "11-STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
                    null, FactoryMethodInvoker.instantiateMoney( 200.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 350.0f, EUR ),
                    "478"},
            {null, "12-VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
                    null, FactoryMethodInvoker.instantiateMoney( 15.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
                    "5"},
            {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
                    3.5f, FactoryMethodInvoker.instantiateMoney( 60.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 100.0f, EUR ),
                    "78"},
            {null, "14-Nosedive", "Klammer zum Verschließen der Nase beim Tauchen",
                    5.0f, FactoryMethodInvoker.instantiateMoney( 2.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
                    "457"}
    };
    

    // These physical addresss are used for the distribution centers. The distribution center name will equal
    // the zip code of the site. Their index number will be visible in the house number.
    // The distribution centers are used as such:
    // - distribution center 0 is holds all items 0 - 6, and is used for all tests where multiple
    //   shipments are irrelevant.
    // - distribution centers 1 - 3 are used for the proximity tests, where you can deliver items 7 to
    //   to a client from the closest distribution center.
    // - distribution centers 4 - 8 are used for the tests where you need to deliver items 8 - 14 in
    //   the most cost-efficient way, as multiple shipments.
    // - distribution center 9 is empty.
    private final static int DISTRIBUTION_CENTER_NUMOF = 10;
    private final static PhysicalAddressType[] DISTRIBUTION_CENTER_PHYSICAL_ADDRESS = new PhysicalAddressType[]{
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Stapelallee 0", "Potsdam",
                    FactoryMethodInvoker.instantiateZipCode( "14476" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Lagerhausstr. 1", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02345" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Speicherplatz 2", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02313" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Ablageweg 3", "Reichswürgen",
                    FactoryMethodInvoker.instantiateZipCode( "44923" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Paketstellenallee 4", "Düsseldorf",
                    FactoryMethodInvoker.instantiateZipCode( "40588" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Kaputte-Sachen-Straße 5", "Düren",
                    FactoryMethodInvoker.instantiateZipCode( "52355" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Aufbewahrungsweg 6", "Viernheim",
                    FactoryMethodInvoker.instantiateZipCode( "68519" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Paketallee 7", "Baden-Baden",
                    FactoryMethodInvoker.instantiateZipCode( "76532" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Sendenstr. 8", "Senden",
                    FactoryMethodInvoker.instantiateZipCode( "89250" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Schickweg 9", "Hohenroth",
                    FactoryMethodInvoker.instantiateZipCode( "97618" ) )
    };
    private final static UUID[] DISTRIBUTION_CENTER_ID = new UUID[DISTRIBUTION_CENTER_NUMOF];


    // These data structures contain the stock of the items in the distribution centers.
    // ITEM_STOCK is a map item name -> Integer[DISTRIBUTION_CENTER_NUMOF].
    // The Integer[DISTRIBUTION_CENTER_NUMOF] contains the stock of the item in each of
    // the distribution centers.
    //
    // The following rules apply:
    // - item 0 is out of stock
    // - item 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in distribution center 0
    // - item 4 / 5 / 6 have a random stock between 30 and 130, also all ONLY in distribution center 0
    //   (these are the items used for tests on how to add and remove stock)
    // - the others have a random stock between 30 and 130, distributed over several
    //   distribution centers. Here we follow this convention for simplicity:
    //   - Assume that the item is available in <n> distribution centers. Then the first <n-1> distribution centers
    //     in the list (in ascending sequence) contain 3, and all the remaining stock is in the
    //     last distribution center.

    private static final Map<String, Integer[]> ITEM_STOCK = new HashMap<>();

    static {
        // items 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
        ITEM_STOCK.put( (String) ITEM_DATA[0][1],
                getStockDistribution( 0, (String) ITEM_DATA[0][6] ) );
        ITEM_STOCK.put( (String) ITEM_DATA[1][1],
                getStockDistribution( 10, (String) ITEM_DATA[1][6] ) );
        ITEM_STOCK.put( (String) ITEM_DATA[2][1],
                getStockDistribution( 20, (String) ITEM_DATA[2][6] ) );
        ITEM_STOCK.put( (String) ITEM_DATA[3][1],
                getStockDistribution( 30, (String) ITEM_DATA[3][6] ) );

        // The other items have a random stock between 30 and 130,
        for ( int i = 4; i < ITEM_NUMOF; i++ ) {
            Integer totalNumber = random.nextInt( 100 ) + 30;
            Integer[] stockInDistributionCenters =
                    getStockDistribution( totalNumber, (String) ITEM_DATA[i][6] );
            ITEM_STOCK.put( (String) ITEM_DATA[i][1], stockInDistributionCenters );
        }
    }

    /**
     * This method creates a random stock distribution for the given item.
     *
     * @param totalQuantity - the total number of items in the distribution centers
     * @param zeroToNine  - a string with numbers between 0 and 9, representing the distribution centers
     * @return an Integer array with the stock distribution for the item, according to
     * the rules described above.
     */
    private static Integer[] getStockDistribution( Integer totalQuantity, String zeroToNine ) {
        Integer[] stockInDistributionCenters = new Integer[DISTRIBUTION_CENTER_NUMOF];
        for ( int i = 0; i < DISTRIBUTION_CENTER_NUMOF; i++ ) stockInDistributionCenters[i] = 0;
        TreeSet<Integer> distributionCenterIndices = getDistributionCenterIndices( zeroToNine );
        int numOfIndices = distributionCenterIndices.size();
        int currentIndexNumber = 0;
        int currentQuantity = totalQuantity;
        for ( Integer distributionCenterIndex : distributionCenterIndices ) {
            currentIndexNumber++;
            if ( currentIndexNumber < numOfIndices ) {
                stockInDistributionCenters[distributionCenterIndex] = 3;
                currentQuantity -= 3;
            } else {
                stockInDistributionCenters[distributionCenterIndex] = currentQuantity;
            }
        }
        return stockInDistributionCenters;
    }

    private static TreeSet<Integer> getDistributionCenterIndices( String zeroToNine ) {
        TreeSet<Integer> distributionCenterIndices = new TreeSet<>();
        for ( int i = 0; i < zeroToNine.length(); i++ ) {
            distributionCenterIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
        }
        return distributionCenterIndices;
    }


    @Autowired
    public StockTestHelperImpl( ItemCatalogUseCases itemCatalogUseCases,
                                         DistributionCenterUseCases distributionCenterUseCases ) {
        this.itemCatalogUseCases = itemCatalogUseCases;
        this.distributionCenterUseCases = distributionCenterUseCases;
    }


    @Override
    public void addAllItems() {
        int i = 0;
        for ( Object[] itemData : ITEM_DATA ) {
            UUID newId = itemCatalogUseCases.addItemToCatalog(
                    (String) itemData[1], (String) itemData[2],
                    (Float) itemData[3], (MoneyType) itemData[4],
                    (MoneyType) itemData[5] );
            // The first element of the item data is the id, which was initialized with null before, but can now be set
            ITEM_DATA[i][0] = newId;
            i++;
        }
    }


    @Override
    public int numberOfItems() {
        return ITEM_NUMOF;
    }


    @Override
    public UUID getItemId( int index ) {
        if ( index < 0 || index >= ITEM_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (UUID) ITEM_DATA[index][0];
    }


    @Override
    public MoneyType getBuyingPrice( int index ) {
        if ( index < 0 || index >= ITEM_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (MoneyType) ITEM_DATA[index][4];
    }


    @Override
    public MoneyType getSalesPrice( int index ) {
        if ( index < 0 || index >= ITEM_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (MoneyType) ITEM_DATA[index][5];
    }


    @Override
    public void addAllDistributionCenters( boolean withStock ) {
        for ( int i = 0; i < DISTRIBUTION_CENTER_NUMOF; i++ ) {
            DISTRIBUTION_CENTER_ID[i] = distributionCenterUseCases.addNewDistributionCenter(
                    DISTRIBUTION_CENTER_PHYSICAL_ADDRESS[i].getStreet(),
                    DISTRIBUTION_CENTER_PHYSICAL_ADDRESS[i] );
        }
        if ( withStock ) {
            addAllStock();
        }
    }


    private void addAllStock() {
        for ( Object[] itemData : ITEM_DATA ) {
            Integer[] stockInDistributionCenters =
                    ITEM_STOCK.get( itemData[1] );
            for ( int iDistributionCenter = 0; iDistributionCenter < DISTRIBUTION_CENTER_NUMOF; iDistributionCenter++ ) {
                if ( stockInDistributionCenters[iDistributionCenter] > 0 )
                    distributionCenterUseCases.addToStock(
                            DISTRIBUTION_CENTER_ID[iDistributionCenter], (UUID) itemData[0],
                            stockInDistributionCenters[iDistributionCenter] );
            }
        }
    }


    @Override
    public int numberOfDistributionCenters() {
        return DISTRIBUTION_CENTER_NUMOF;
    }


    @Override
    public UUID getDistributionCenterId( int index ) {
        if ( index < 0 || index >= DISTRIBUTION_CENTER_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return DISTRIBUTION_CENTER_ID[index];
    }


    @Override
    public Integer getDistributionCenterStock( int distributionCenterIndex, int itemIndex ) {
        if ( distributionCenterIndex < 0 || distributionCenterIndex >= DISTRIBUTION_CENTER_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + distributionCenterIndex );
        }
        if ( itemIndex < 0 || itemIndex >= ITEM_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + itemIndex );
        }
        String itemName = (String) ITEM_DATA[itemIndex][1];
        Integer[] stockInDistributionCenters = ITEM_STOCK.get( itemName );
        Integer foundStock = stockInDistributionCenters[distributionCenterIndex];
        return foundStock == null ? 0 : foundStock;
    }


    @Override
    public int findDistributionCenterIndex( UUID distributionCenterId ) {
        for ( int i = 0; i < DISTRIBUTION_CENTER_NUMOF; i++ ) {
            if ( DISTRIBUTION_CENTER_ID[i].equals( distributionCenterId ) ) {
                return i;
            }
        }
        throw new IllegalArgumentException( "No test distribution center with UUID id " + distributionCenterId );
    }


    @Override
    public int findItemIndex( UUID itemId ) {
        for ( int iItemData = 0; iItemData < DISTRIBUTION_CENTER_NUMOF; iItemData++ ) {
            Object[] itemData = ITEM_DATA[iItemData];
            if ( itemData[0].equals( itemId ) ) {
                return iItemData;
            }
        }
        throw new IllegalArgumentException( "No test item with UUID id " + itemId );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ItemTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;

public interface ItemTestHelper {
    /**
     * Adds all test items to the database.
     * If you use the debugger and want to identify _which_ test item you currently look at:
     * The indices are coded into the first number in the name string of the item, like e.g.
     * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
     */
    void addAllItems();


    /**
     * @return the number of test items in the database
     */
    int numberOfItems();


    /**
     * @param index
     * @return the id of the test item at the given index
     */
    UUID getItemId( int index );


    /**
     * @param itemId - the id of the item in the test data
     * @return the index of the test item with that id
     */
    int findItemIndex( UUID itemId );


    /**
     * @param index
     * @return the buying price of test item at the given index
     */
    MoneyType getBuyingPrice( int index );


    /**
     * @param index
     * @return the sales price of test item at the given index
     */
    MoneyType getSalesPrice( int index );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockClient.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import lombok.Setter;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;


import java.util.Objects;

@Setter
public class MockClient implements ClientType {
    private String name;
    private EmailType emailType;
    private PhysicalAddressType physicalAddressType;


    public MockClient( String name, EmailType emailType, PhysicalAddressType physicalAddressType) {
        this.name = name;
        this.emailType = emailType;
        this.physicalAddressType = physicalAddressType;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public EmailType getEmail() {
        return emailType;
    }

    @Override
    public PhysicalAddressType getPhysicalAddress() {
        return physicalAddressType;
    }

    @Override
    public boolean equals( Object o ) {
        if ( this == o ) return true;
        if ( !( o instanceof MockClient ) ) return false;
        MockClient that = (MockClient) o;
        return Objects.equals( getName(), that.getName() ) &&
                Objects.equals( emailType, that.emailType ) &&
                Objects.equals( physicalAddressType, that.physicalAddressType );
    }

    @Override
    public int hashCode() {
        return Objects.hash( getName(), emailType, physicalAddressType );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.usecases.*;

/**
 * Removes everything :-)
 */
@Service
public class Purgatory {
    @Autowired
    private ClientRegistrationUseCases clientRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private OrderUseCases orderUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private DistributionCenterUseCases distributionCenterUseCases;

    public void deleteEverything() {
        orderUseCases.deleteAllOrders();
        shoppingBasketUseCases.emptyAllShoppingBaskets();
        distributionCenterUseCases.deleteAllDistributionCenters();
        clientRegistrationUseCases.deleteAllClients();
        itemCatalogUseCases.deleteItemCatalog();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.DistributionCenterUseCases;

@Component
@Slf4j
@Profile("!test")
@SuppressWarnings("PMD")
public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
    private Purgatory purgatory;
    private ClientTestHelper clientTestHelper;
    private ItemTestHelper itemTestHelper;
    private DistributionCenterTestHelper distributionCenterTestHelper;


    @Autowired
    public StartupListener( Purgatory purgatory,
                            ClientTestHelper clientTestHelper,
                            ItemTestHelper itemTestHelper,
                            DistributionCenterTestHelper distributionCenterTestHelper ) {
        this.purgatory = purgatory;
        this.clientTestHelper = clientTestHelper;
        this.itemTestHelper = itemTestHelper;
        this.distributionCenterTestHelper = distributionCenterTestHelper;
    }

    @Override
    public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
        log.info( "StartupListener initializing master data ..." );
        purgatory.deleteEverything();
        clientTestHelper.registerAllClients();
        itemTestHelper.addAllItems();
        distributionCenterTestHelper.addAllDistributionCenters( true );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\OrderUseCases.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
 */
package thkoeln.archilab.ecommerce.usecases;


import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.Map;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of the order history of a client.
 */
public interface OrderUseCases {

    /**
     * Returns a map showing which items have been ordered by a client and how many of each item
     *
     * @param clientEmail
     * @return the order history of the client (map is empty if the client has not ordered anything yet)
     * @throws ShopException if
     *      - clientEmail is null
     *      - the client with the given email does not exist
     */
    public Map<UUID, Integer> getOrderHistory( EmailType clientEmail );



    /**
     * @return the number of items in a given order. If the item is not a position of the order, the method
     *         returns 0. No exception is thrown.
     * @param orderId - the id of the order to be checked
     * @param itemId - the id of the item for which we want to know the quantity
     * @throws ShopException if
     *     - orderId is null, or doesn't exist in the system
     *     - itemId is null, or doesn't exist in the system
     */
    public Integer getOrderQuantForItem( UUID orderId, UUID itemId );


    /**
     * @return the id of the distribution center that is responsible for the given order
     * @param orderId - the id of the order to be checked
     * @throws ShopException if
     *      - orderId is null, or doesn't exist in the system
     */
    public UUID getDistributionCenterIdForOrder( UUID orderId );


    /**
     * Deletes all orders in the system
     */
    public void deleteAllOrders();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingBasketUseCases.java ---
/*
 * Copyright ArchiLab 2025, Prof. Bente & Team, TH Köln
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.Map;
import java.util.Set;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of use cases handling the shopping basket.
 * The interface is probably incomplete, and will grow over time ...
 */
public interface ShoppingBasketUseCases {
    /**
     * Adds a item to the cart of a client
     *
     * @param clientEmail
     * @param itemId
     * @param quantFor
     * @throws ShopException if ...
     *          - clientEmail is null,
     *          - the client with the given email does not exist,
     *          - itemId is null,
     *          - the item with itemId does not exist
     *          - the Quantity is negative,
     */
    public void addItemToShoppingBasket( EmailType clientEmail,
                                                 UUID itemId, int quantFor );


    /**
     * Removes a item from the cart of a client
     *
     * @param clientEmail
     * @param itemId
     * @param quantFor
     * @throws ShopException if ...
     *          - clientEmail is null,
     *          - the client with the given email does not exist,
     *          - itemId is null,
     *          - the item with itemId does not exist
     *          - the Quantity is negative
     *          - the item is not in the shopping basket in the requested Quantity
     */
    public void removeItemFromShoppingBasket( EmailType clientEmail,
                                                      UUID itemId, int quantFor );


    /**
     * Returns a map showing which items are in the cart of a client and how many of each item
     *
     * @param clientEmail
     * @return the cart of the client (map is empty if the cart is empty)
     * @throws ShopException if
     *          - clientEmail is null,
     *          - the client with the given email does not exist
     */
    public Map<UUID, Integer> getShoppingBasketAsMap( EmailType clientEmail );


    /**
     * Returns the current value of all items in the cart of a client
     *
     * @param clientEmail
     * @return the cart of the client
     * @throws ShopException if
     *          - clientEmail is null,
     *          - the client with the given email does not exist
     */
    public MoneyType getShoppingBasketAsMoneyValue( EmailType clientEmail );




    /**
     * Checks out the cart of a client
     *
     * @param clientEmail
     * @return A set of ids belonging to orders that were created during the checkout. If the shopping basket can
     *         only be served from more than one distribution center, each shipment from a distribution center gets a
     *         dedicated order. I.e. if there is just one shipment, then the set will contain just one order id.
     *         If there are multiple shipments, the set will contain multiple order ids.
     * @throws ShopException if
     *      - clientEmail is null or empty
     *      - the client with the given email does not exist, or if the cart is empty
     * @throws
     *      - ShopException if clientEmail is null
     *      - InsufficientStockException if there is not enough stock level for to serve the order
     *        for all items in the shopping basket
     */
    public Set<UUID> checkout( EmailType clientEmail );


    /**
     * Empties all shopping baskets in the system
     */
    public void emptyAllShoppingBaskets();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
package thkoeln.archilab.ecommerce.helpers.impl;

import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.test.web.servlet.MockMvc;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;


@TestConfiguration
public class RESTTestHelperConfiguration {

    @Bean
    public ShoppingBasketRESTHelper shoppingBasketRESTHelper(
            MockMvc mockMvc, ItemCatalogUseCases itemCatalogUseCases ) {
        return new ShoppingBasketRESTHelperImpl( mockMvc, itemCatalogUseCases );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingBasketRESTHelperImpl.java ---
package thkoeln.archilab.ecommerce.helpers.impl;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.Map;
import java.util.UUID;

import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@Slf4j
public class ShoppingBasketRESTHelperImpl implements ShoppingBasketRESTHelper {
    private MockMvc mockMvc;
    private ItemCatalogUseCases itemCatalogUseCases;

    private static final ResultMatcher CREATED = status().isCreated();
    private static final ResultMatcher OK = status().isOk();

    public ShoppingBasketRESTHelperImpl( MockMvc mockMvc, ItemCatalogUseCases itemCatalogUseCases ) {
        this.mockMvc = mockMvc;
        this.itemCatalogUseCases = itemCatalogUseCases;
    }


    @Override
    public UUID getQueryShoppingBasket( EmailType email, Map<UUID, Integer> quantityMap )
            throws Exception {
        // first query the clients API to get the proper clientId
        UUID clientId;
        String clientUri = "/clients?email=" + email.toString();
        MvcResult clientGetResult = mockMvc.perform( get( clientUri ) )
                .andExpect( status().isOk() )
                .andReturn();
        ObjectMapper objectMapper = new ObjectMapper();
        IdDTO idDTO = objectMapper.readValue( clientGetResult.getResponse().getContentAsString(), IdDTO.class );
        clientId = idDTO.getId();

        // then query the shopping basket API and extract the shopping basket id
        String shoppingBasketUri = "/shoppingBaskets?clientId=" + clientId.toString();
        ResultActions resultActions = mockMvc.perform( get( shoppingBasketUri ) )
                .andExpect( status().isOk() );
        idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
        UUID shoppingBasketId = idDTO.getId();

        // additional checks, if desired
        if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
        return shoppingBasketId;
    }


    private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
        if ( quantityMap == null ) return;
        int numOfItems = quantityMap.size();
        resultActions.andExpect( jsonPath( "$.positions.length()" ).value( numOfItems ) );
        float totalSalesPriceAsFloat = 0f;
        for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
            UUID itemId = entry.getKey();
            Integer quantity = entry.getValue();
            resultActions.andExpect( jsonPath( "$.positions.[?(@.itemId == '" + itemId + "')].quantity" )
                    .value( quantity ) );
            MoneyType salesPrice = itemCatalogUseCases.getSalesPrice( itemId );
            totalSalesPriceAsFloat += salesPrice.getAmount() * quantity;
        }
        // last thing - check the total sales price
        String totalSalesPriceString = String.format( "%.2f €", totalSalesPriceAsFloat );
        resultActions
                .andExpect( jsonPath( "$.totalSalesPrice" ).value( totalSalesPriceString ) );
    }


    @Override
    public void addItemToShoppingBasket( UUID shoppingBasketId, UUID itemId, Integer quantity )
            throws Exception {
        addItemToShoppingBasket( shoppingBasketId, itemId, quantity, null );
    }


    @Override
    public void addItemToShoppingBasket( UUID shoppingBasketId, UUID itemId, Integer quantity,
                                                  ResultMatcher expectedStatus ) throws Exception {
        ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
        ObjectMapper objectMapper = new ObjectMapper();
        QuantityDTO dto = new QuantityDTO( itemId, quantity );
        String quantityJson = objectMapper.writeValueAsString( dto );
        mockMvc.perform( post( "/shoppingBaskets/" + shoppingBasketId + "/positions" )
                        .contentType( APPLICATION_JSON ).content( quantityJson ) )
                .andExpect( status );
    }



    @Override
    public void deleteItemFromShoppingBasket( UUID shoppingBasketId, UUID itemId )
            throws Exception {
        deleteItemFromShoppingBasket( shoppingBasketId, itemId, null );
    }



    @Override
    public void deleteItemFromShoppingBasket( UUID shoppingBasketId, UUID itemId,
                                                      ResultMatcher expectedStatus ) throws Exception {
        ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
        String uri = "/shoppingBaskets/" + shoppingBasketId + "/positions/" + itemId;
        mockMvc.perform( delete( uri ) ).andExpect( status );
    }


    @Override
    public void checkout( UUID shoppingBasketId, String expectedClientName,
                          ResultMatcher expectedStatus,
                          Map<UUID, Map<UUID, Integer>> expectedOrders ) throws Exception {
        ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
        String uri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
        MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
        ObjectMapper objectMapper = new ObjectMapper();

        // check the response content
        if ( expectedOrders != null || expectedClientName != null ) {
            String responseContent = result.getResponse().getContentAsString();
            log.info( "ShoppingBasketRESTHelperImpl - checkout: found response content " + responseContent );
            OrderDTO[] orders = objectMapper.readValue( responseContent, OrderDTO[].class );
            checkExpectedClientName( expectedClientName, orders );
            checkExpectedOrders( expectedOrders, orders );
        }
    }


    private void checkExpectedClientName( String expectedClientName, OrderDTO[] orders ) {
        if ( expectedClientName == null ) return;
        for ( OrderDTO order : orders ) {
            if ( !order.getClientName().equals( expectedClientName ) ) {
                throw new AssertionError( "Expected clientName '" + expectedClientName +
                        "' but got '" + order.getClientName() + "'" );
            }
        }
    }


    private void checkExpectedOrders( Map<UUID, Map<UUID, Integer>> expectedOrders,
                                            OrderDTO[] orders ) {
        if ( expectedOrders == null ) return;
        for ( OrderDTO order : orders ) {
            UUID distributionCenterId = order.getDistributionCenterId();
            Map<UUID, Integer> expectedQuantities = expectedOrders.get( distributionCenterId );
            if ( expectedQuantities == null ) {
                throw new AssertionError( "No expected quantities for distribution center " + distributionCenterId );
            }
            QuantityDTO[] positions = order.getPositions();
            for ( QuantityDTO quantityDTO : positions ) {
                UUID itemId = quantityDTO.getItemId();
                Integer expectedQuantity = expectedQuantities.get( itemId );
                if ( expectedQuantity == null ) {
                    throw new AssertionError( "No expected quantity for item " + itemId +
                            " in distribution center " + distributionCenterId );
                }
                if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
                    throw new AssertionError( "Expected quantity " + expectedQuantity + " for item " +
                            itemId + " in distribution center " + distributionCenterId +
                            ", but got " + quantityDTO.getQuantity() );
                }
            }
        }
    }


    /**
     * A DTO containing just a quantity, used in testing.
     * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
     * Therefore, constructors and getters/setters are manually defined.
     */
    @NoArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class QuantityDTO {
        private UUID itemId;
        private Integer quantity;

        public QuantityDTO( UUID itemId, Integer quantity ) {
            this.itemId = itemId;
            this.quantity = quantity;
        }
        public UUID getItemId() {
            return itemId;
        }
        public Integer getQuantity() {
            return quantity;
        }
        public void setItemId( UUID itemId ) {
            this.itemId = itemId;
        }
        public void setQuantity( Integer quantity ) {
            this.quantity = quantity;
        }
    }


    /**
     * A DTO containing just the id of an entity, used in testing.
     */
    @AllArgsConstructor
    @NoArgsConstructor
    @Getter
    @Setter
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class IdDTO {
        private UUID id;
    }


    /**
     * A DTO containing the order data, used in testing.
     * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
     * Therefore, constructors and getters/setters are manually defined.
     */
    @NoArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class OrderDTO {
        private UUID id;
        private String clientName;
        private UUID distributionCenterId;
        private QuantityDTO[] positions;

        public UUID getId() {
            return id;
        }
        public String getClientName() {
            return clientName;
        }
        public UUID getDistributionCenterId() {
            return distributionCenterId;
        }
        public QuantityDTO[] getPositions() {
            return positions;
        }
        public void setId( UUID id ) {
            this.id = id;
        }
        public void setClientName( String clientName ) {
            this.clientName = clientName;
        }
        public void setDistributionCenterId( UUID distributionCenterId ) {
            this.distributionCenterId = distributionCenterId;
        }
        public void setPositions( QuantityDTO[] positions ) {
            this.positions = positions;
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingBasketRESTHelper.java ---
package thkoeln.archilab.ecommerce.helpers;

import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.Map;
import java.util.UUID;

/**
 * A REST helper for shopping basket-related operations.
 * This interface defines methods to interact with a shopping basket via REST calls, such as querying, adding,
 * deleting, and checking out.
 */
public interface ShoppingBasketRESTHelper {
    /**
     * Executes a REST GET query on a shopping basket and returns its id, with the client's email as a
     * starting point. The resulting shopping basket is checked against the given expected quantity map.
     * @param email The email of the client whose shopping basket is queried.
     * @param expectedQuantityMap A map of items and their quantities in the shopping basket. (If null, then don't check.)
     * @return The id of the client's shopping basket.
     * @throws Exception (whenever the REST call fails, or the shopping basket does not match the expected quantity map)
     */
    public UUID getQueryShoppingBasket( EmailType email,
                                       Map<UUID, Integer> expectedQuantityMap ) throws Exception;


    /**
     * Adds a item to a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param itemId Id of the item.
     * @param quantity Quantity of the item.
     * @throws Exception (whenever the REST call fails)
     */
    public void addItemToShoppingBasket( UUID shoppingBasketId, UUID itemId, Integer quantity )
            throws Exception;


    /**
     * Adds a item to a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param itemId Id of the item.
     * @param quantity Quantity of the item.
     * @param expectedStatus expected status of the operation (null = CREATED)
     * @throws Exception (whenever the REST call fails or the status does not match)
     */
    public void addItemToShoppingBasket( UUID shoppingBasketId, UUID itemId, Integer quantity,
                                                  ResultMatcher expectedStatus ) throws Exception;


    /**
     * Deletes a item from a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param itemId Id of the item.
     * @throws Exception (whenever the REST call fails)
     */
    public void deleteItemFromShoppingBasket( UUID shoppingBasketId, UUID itemId )
            throws Exception;


    /**
     * Deletes a item from a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param itemId Id of the item.
     * @param expectedStatus expected status of the operation (null = OK)
     * @throws Exception (whenever the REST call fails or the status does not match)
     */
    public void deleteItemFromShoppingBasket( UUID shoppingBasketId, UUID itemId,
                                                      ResultMatcher expectedStatus ) throws Exception;


    /**
     * Checks out a shopping basket via REST call, and returns the id of the created order.
     * @param shoppingBasketId
     * @param expectedClientName expected name of the client who owns the shopping basket (null = don't check)
     * @param expectedStatus expected status of the operation (null = don't check)
     * @param expectedOrders the expected orders to be created as a result of the checkout. This is
     *                            a map of the following form:
     *                            <pre>
     *                               distributionCenterId -> Map<itemId,Integer>
     *                            </pre>
     *                            where the inner map contains the items and their quantities
     * @return
     * @throws Exception
     */
    public void checkout( UUID shoppingBasketId, String expectedClientName,
                          ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedOrders )
           throws Exception;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\client\ClientRegistrationTest.java ---
package thkoeln.archilab.ecommerce.tests.client;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;


@SpringBootTest
public class ClientRegistrationTest {
    @Autowired
    private ClientRegistrationUseCases clientRegistrationUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ClientTestHelper clientTestHelper;

    private EmailType nonExistingEmail;
    private PhysicalAddressType somePhysicalAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        nonExistingEmail = instantiateEmail( "this@nononono.de" );
        somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
                instantiateZipCode( "90001" ) );
    }

    @Test
    public void testAllClientsRegistered() {
        // given
        clientTestHelper.registerAllClients();
        EmailType email3 =
                clientTestHelper.getClientEmail( 3 );
        String name3 = clientTestHelper.getClientName( 3 );
        PhysicalAddressType physicalAddress3 = clientTestHelper.getClientPhysicalAddress( 3 );

        // when
        ClientType client3 = clientRegistrationUseCases.getClientData(
                email3 );

        // then
        Assertions.assertEquals( name3, client3.getName() );
        Assertions.assertEquals( email3, client3.getEmail() );
        Assertions.assertEquals( physicalAddress3, client3.getPhysicalAddress() );
    }


    @Test
    public void testRegisterClientWithDuplicateEmail() {
        // given
        clientTestHelper.registerAllClients();
        PhysicalAddressType physicalAddress5 = clientTestHelper.getClientPhysicalAddress( 5 );
        EmailType email5 =
                clientTestHelper.getClientEmail( 5 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.register( "Gandalf The Grey",
                        email5, physicalAddress5 ) );
    }


    @Test
    public void testRegisterClientWithDuplicateNameOrPhysicalAddress() {
        // given
        clientTestHelper.registerAllClients();
        EmailType newEmail =
                instantiateEmail( "some@this.de" );
        PhysicalAddressType physicalAddress2 = clientTestHelper.getClientPhysicalAddress( 2 );
        String name2 = clientTestHelper.getClientName( 2 );

        // when
        // then
        assertDoesNotThrow( () ->
                clientRegistrationUseCases.register( name2, newEmail, physicalAddress2 ) );
    }


    @Test
    public void testRegisterClientWithInvalidData() {
        // given
        EmailType email5 =
                clientTestHelper.getClientEmail( 5 );
        PhysicalAddressType physicalAddress5 = clientTestHelper.getClientPhysicalAddress( 5 );
        String name5 = clientTestHelper.getClientName( 5 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.register( null, email5, physicalAddress5 ) );
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.register("", email5, physicalAddress5 ) );
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.register( name5, null, physicalAddress5 ) );
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.register( name5, email5, null ) );
    }


    @Test
    public void testChangeAddressWithInvalidData() {
        // given
        clientTestHelper.registerAllClients();
        PhysicalAddressType physicalAddress7 = clientTestHelper.getClientPhysicalAddress( 7 );
        EmailType email7 =
                clientTestHelper.getClientEmail( 7 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.changeAddress( nonExistingEmail, physicalAddress7 ) );
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.changeAddress( null, physicalAddress7 ) );
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.changeAddress( email7, null ) );
    }


    @Test
    public void testGetDataForNonexistingEmail() {
        // given
        clientTestHelper.registerAllClients();

        // when
        // then
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.getClientData( nonExistingEmail ) );
    }


    @Test
    public void testDeleteClientsNoMoreClients() {
        // given
        clientTestHelper.registerAllClients();
        EmailType email0 =
                clientTestHelper.getClientEmail( 0 );


        // when
        clientRegistrationUseCases.deleteAllClients();

        // then
        assertThrows( ShopException.class, () -> clientRegistrationUseCases.getClientData(
                email0 ) );
    }


    @Test
    public void testChangeAddressSuccessful() {
        // given
        clientTestHelper.registerAllClients();
        EmailType email6 =
                clientTestHelper.getClientEmail( 6 );

        // when
        clientRegistrationUseCases.changeAddress( email6, somePhysicalAddress );
        ClientType newClient6 =
                clientRegistrationUseCases.getClientData( email6 );

        // then
        Assertions.assertEquals( email6, newClient6.getEmail() );
        Assertions.assertEquals( somePhysicalAddress, newClient6.getPhysicalAddress() );
    }


    @Test
    public void testChangeAddressForNonexistingEmail() {
        // given
        clientTestHelper.registerAllClients();

        // when
        // then
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.changeAddress( nonExistingEmail, somePhysicalAddress ) );
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\client\ClientRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.client;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.web.servlet.MockMvc;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.*;

import java.util.UUID;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class ClientRESTTest {
    @Autowired
    private ClientRegistrationUseCases clientRegistrationUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ClientTestHelper clientTestHelper;
    @Autowired
    private MockMvc mockMvc;

    private UUID randomId;
    private EmailType nonExistingEmail;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        clientTestHelper.registerAllClients();

        nonExistingEmail = FactoryMethodInvoker.instantiateEmail(
                "harry@sally.de" );
        randomId = UUID.randomUUID();
    }


    @Test
    public void testInvalidClientUris() throws Exception {
        // given
        String allClientsUri = "/clients";
        String randomIdUri = "/clients/" +  randomId;
        String nonExistingEmailUri = "/clients?email=" + nonExistingEmail;
        String randomParamUri = "/clients?randomParam=randomValue";

        // when
        // then
        mockMvc.perform( get( allClientsUri ) ).andExpect( status().isMethodNotAllowed() );
        mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( nonExistingEmailUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
    }


    @Test
    public void testRandomClientId() throws Exception {
        // given
        String invalidUri = "/clients/" +  randomId;

        // when
        // then
        mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testQueryClient() throws Exception {
        // given
        EmailType email4 =
                clientTestHelper.getClientEmail( 4 );
        String clientUri4 = "/clients?email=" + email4;

        // when
        ClientType client4 = clientRegistrationUseCases.getClientData( email4 );
        String name = clientTestHelper.getClientName( 4 );
        PhysicalAddressType physicalAddress4 = clientTestHelper.getClientPhysicalAddress( 4 );

        // then (check using JSONPath)
        mockMvc.perform( get( clientUri4 ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.name" ).value( name ) )
                // id is position 0 (cannot be tested with current API structure), name is position 1,
                // email is 2, physical address is 3)
                .andExpect( jsonPath( "$..emailString" ).value( email4.toString() ) )
                .andExpect( jsonPath( "$..city" ).value( physicalAddress4.getCity() ) )
                .andExpect( jsonPath( "$..zipCodeString" ).value(
                        physicalAddress4.getZipCode().toString() ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class BasicNoOutsideSolutionRulesTest {

    @ArchTest
    static final ArchRule noClassesOnTopLevel =
            classes().should().resideInAPackage( "..solution.*.." )
                    .allowEmptyShould( true );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.library.Architectures.layeredArchitecture;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln")
@SuppressWarnings("PMD")
public class BasicProperDependenciesTest {

    @ArchTest
    static final ArchRule properDependencies =
            layeredArchitecture()
                    .consideringAllDependencies()
                    //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
                    .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
                    .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )

                    //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
                    .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
                    .allowEmptyShould( true );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import org.junit.jupiter.api.Test;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.MetadataReaderFactory;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertTrue;

public class BasicRequiredClassesTest {
    private static final String[] REQUIRED_CLASSES = {
            "Client",
            "ClientRepository",
            "Item",
            "ItemRepository",
            "Order",
            "OrderRepository",
            "StockLevel",
            "ShoppingBasket",
            "ShoppingBasketRepository",
            "DistributionCenterRepository",
            "ShoppingBasketPosition",
            "OrderPosition",
            "DistributionCenter",
    };

    @Test
    public void testRequiredClassesDeclared() throws IOException {
        String basePackage = "thkoeln.archilab.ecommerce";
        String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";

        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );

        Set<String> foundClasses = new HashSet<>();

        Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
            try {
                MetadataReader reader = readerFactory.getMetadataReader( resource );
                foundClasses.add( reader.getClassMetadata().getClassName() );
            } catch (IOException e) {
                e.printStackTrace();
            }
        } );

        Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
            boolean found = foundClasses.stream().anyMatch(className ->
                    className.startsWith(basePackage) && className.endsWith("." + requiredClass)
            );
            assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
        });
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.ApplicationContext;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
public class BasicUseCaseImplementationPackageTest {

    @Autowired
    private ApplicationContext applicationContext;

    private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
        put("ClientRegistrationUseCases", Arrays.asList("client"));
        put("DistributionCenterUseCases", Arrays.asList("distributioncenter"));
        put("ItemCatalogUseCases", Arrays.asList("item"));
        put("ShoppingBasketUseCases", Arrays.asList("shoppingbasket"));
        put("OrderUseCases", Arrays.asList("order"));
    }};
    private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
    private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";

    @Test
    public void testRequiredClassesDeclared() {
        for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
            String interfaceName = USECASE_PATH + "." + entry.getKey();
            List<String> correctTopLevelPackages = entry.getValue();
            Class<?> useCaseInterfaceClass = null;
            try {
                useCaseInterfaceClass = Class.forName( interfaceName );
            } catch (ClassNotFoundException e) {
                fail( "Use case interface " + interfaceName + " not found.", e );
                continue;
            }
            String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
            assertEquals( 1, beans.length,
                    "There should be exactly 1 service implementation for the interface " +
                            entry.getKey() + ", but found " + beans.length );
            Object bean = applicationContext.getBean( beans[0] );
            boolean isValid = false;
            for ( String correctTopLevelPackage : correctTopLevelPackages ) {
                String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
                if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
                    isValid = true;
                    break;
                }
            }
            assertTrue( isValid,
                    "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
                            + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Service;

import jakarta.persistence.Entity;
import org.springframework.web.bind.annotation.RestController;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class DDDRulesTest {

    @ArchTest
    static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
            noClasses().that().resideInAPackage( "..domain.." )
                    .should().dependOnClassesThat().resideInAPackage( "..application.." )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule entitiesMustResideInADomainPackage =
            classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
                    .as( "Entities must reside in a package '..domain..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule entitiesMustNotAccessRepositories =
            noClasses().that().areAnnotatedWith( Entity.class )
                    .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule repositoriesMustResideInADomainPackage =
            classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
                    .as( "Repositories must reside in a package '..domain..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule repositoryNamesMustHaveProperSuffix =
            classes().that().areAssignableTo( CrudRepository.class )
                    .should().haveSimpleNameEndingWith( "Repository" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule servicesMustResideInAnApplicationPackage =
            classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
                    .as( "Application Services must reside in a package '..application..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule serviceNamesMustHaveProperSuffix =
            classes().that().areAnnotatedWith( Service.class )
                    .should().haveSimpleNameEndingWith( "Service" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule controllersMustResideInAnApplicationPackage =
            classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
                    .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );

    @ArchTest
    static final ArchRule controllersNamesMustHaveProperSuffix =
            classes().that().areAnnotatedWith( RestController.class )
                    .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );

    @ArchTest
    static final ArchRule controllersMustNotAccessRepositories =
            noClasses().that().areAnnotatedWith( RestController.class )
                    .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
                    .allowEmptyShould( false );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.library.dependencies.SliceAssignment;
import com.tngtech.archunit.library.dependencies.SliceIdentifier;
import org.junit.jupiter.api.Test;

import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;

public class NoCycleTest {
    private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");

    private SliceAssignment inAllClasses() {
        return new SliceAssignment() {
            @Override
            public String getDescription() {
                return "every class in it's own slice";
            }

            @Override
            public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
                return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
            }
        };
    }

    @Test
    public void testNoCyclicDependenciesBetweenClasses() {
        slices().assignedFrom(inAllClasses())
                .namingSlices("$1[$2.$3]")
                .should().beFreeOfCycles()
                .check(importedClasses);
    }

    @Test
    public void testNoCyclicDependenciesBetweenPackages() {
        ArchRule rule = slices().matching("..solution.(*)..")
                .should().beFreeOfCycles().allowEmptyShould( true );
        rule.check(importedClasses);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.base.DescribedPredicate;
import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaField;
import com.tngtech.archunit.core.domain.JavaParameterizedType;
import com.tngtech.archunit.core.domain.JavaType;
import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchCondition;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.lang.ConditionEvents;
import com.tngtech.archunit.lang.SimpleConditionEvent;
import jakarta.persistence.*;
import lombok.extern.slf4j.Slf4j;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.List;

import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
@Slf4j
public class OnlyReferenceViaIDTest { //DISTRIBUTION_CENTER
    private static final String SHOPPING_BASKET_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingbasket.domain";
    private static final String CLIENT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.client.domain";
    private static final String ITEM_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.item.domain";
    private static final String ORDER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.order.domain";
    private static final String DISTRIBUTION_CENTER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.distributioncenter.domain";

    @ArchTest
    static final ArchRule idFieldsMustUseGenericId =
            fields()
                    .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
                    .and().areAnnotatedWith( Id.class )
                    .should().haveRawType( assignableTo( GenericId.class ) )
                    .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
                    .allowEmptyShould( true );


    private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
            annotatedWith( ManyToOne.class )
                    .or( annotatedWith( OneToOne.class ) )
                    .or( annotatedWith( Embedded.class ) )
                    .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );

    private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
            annotatedWith( OneToMany.class )
                    .or( annotatedWith( ManyToMany.class ) )
                    .or( annotatedWith( ElementCollection.class ) )
                    .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );


    private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
        String description = "an entity or value object from same aggregate, or a domain primitive";
        return new DescribedPredicate<>( description ) {
            @Override
            public boolean test( JavaClass type ) {
                // check if the class is an entity or value object, and resides in the allowed package
                if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
                    return false;
                }
                // a GenericId is always allowed
                if ( type.isAssignableTo( GenericId.class ) ) {
                    return true;
                }
                // a domain primitive is also always allowed
                if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
                    return true;
                }
                return type.getPackageName().startsWith( allowedPackage );
            }
        };
    }


    @ArchTest
    static final ArchRule shoppingBasketToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule clientToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( CLIENT_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( CLIENT_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule itemToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( ITEM_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( ITEM_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule orderToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule distributionCenterToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( DISTRIBUTION_CENTER_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( DISTRIBUTION_CENTER_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );


    private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
        return new ArchCondition<JavaField>(
                "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
            @Override
            public void check( JavaField field, ConditionEvents events ) {
                JavaClass rawType = field.getRawType();
                String rawTypeName = rawType.getFullName();
                if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
                    return;
                }
                JavaType fieldType = field.getType();
                if ( !( fieldType instanceof JavaParameterizedType ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " is a raw List/Set without a type argument" ) );
                    return;
                }
                List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
                if ( typeArguments.isEmpty() ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " has no type arguments" ) );
                    return;
                }
                JavaType elementType = typeArguments.get( 0 );
                if ( !( elementType instanceof JavaClass ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " has an unknown element type" ) );
                    return;
                }
                JavaClass elementClass = (JavaClass) elementType;
                boolean hasAnnotation =
                        elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
                boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
                boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
                boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
                boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
                if ( !ok ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " refers to " + elementClass.getFullName()
                                    + " which is not a DP, or an entity/value object in " + allowedPackage ) );
                }
            }
        };
    }


    @ArchTest
    static final ArchRule shoppingBasketToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule clientToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( CLIENT_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( CLIENT_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule itemToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( ITEM_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( ITEM_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule orderToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( ORDER_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( ORDER_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule distributionCenterToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( DISTRIBUTION_CENTER_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( DISTRIBUTION_CENTER_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

/**
 * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
 */

public class OwnTestsTest {
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

public class PackageStructureTest {

    private static final String[] REQUIRED_PACKAGES = {"client", "shoppingbasket", "item", "order", "distributioncenter"};
    private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
    private JavaClasses importedClasses;


    @BeforeEach
    public void setUp() {
        importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
    }

    @Test
    void testRequiredPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage;
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredDomainPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected domain sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredApplicationPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected application sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\distributioncenter\DistributionCenterManagementTest.java ---
package thkoeln.archilab.ecommerce.tests.distributioncenter;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.DistributionCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.DistributionCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;


/**
 * This test checks the management and lifecycle of distribution centers.
 */
@SpringBootTest
public class DistributionCenterManagementTest {
    @Autowired
    private DistributionCenterUseCases distributionCenterUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private DistributionCenterTestHelper distributionCenterTestHelper;

    private PhysicalAddressType somePhysicalAddress;
    private UUID nonExistingId1;
    private UUID nonExistingId2;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        itemTestHelper.addAllItems();

        somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
                instantiateZipCode( "90001" ) );
        nonExistingId1 = UUID.randomUUID();
        nonExistingId2 = UUID.randomUUID();
    }


    @Test
    public void testAddInvalidDistributionCenter() {
        // given
        String name = "Lager1";

        // when
        // then
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.addNewDistributionCenter(
                        null, somePhysicalAddress ) );
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.addNewDistributionCenter(
                        "", somePhysicalAddress ) );
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.addNewDistributionCenter(
                        name, null ) );
    }


    @Test
    public void testDeleteAllDistributionCentersWhenEmpty() {
        // given
        distributionCenterTestHelper.addAllDistributionCenters( false );
        UUID itemId9 = itemTestHelper.getItemId( 9 );
        UUID distributionCenterId1 = distributionCenterTestHelper.getDistributionCenterId( 1 );
        UUID distributionCenterId2 = distributionCenterTestHelper.getDistributionCenterId( 2 );

        // when
        int numOf1 = distributionCenterUseCases.getAvailableStock( distributionCenterId1, itemId9 );
        int numOf2 = distributionCenterUseCases.getAvailableStock( distributionCenterId2, itemId9 );

        // then
        assertEquals( 0, numOf1 );
        assertEquals( 0, numOf2 );
        distributionCenterUseCases.deleteAllDistributionCenters();
        // ... ids must be invalid now
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.getAvailableStock( distributionCenterId1, itemId9 ) );
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.getAvailableStock( distributionCenterId2, itemId9 ) );
    }


    @Test
    public void testDeleteAllDistributionCentersWhenFull() {
        // given
        distributionCenterTestHelper.addAllDistributionCenters( true );
        UUID itemId7 = itemTestHelper.getItemId( 7 );
        UUID distributionCenterId1 = distributionCenterTestHelper.getDistributionCenterId( 1 );
        UUID distributionCenterId2 = distributionCenterTestHelper.getDistributionCenterId( 2 );

        // when
        int numOf1 = distributionCenterUseCases.getAvailableStock( distributionCenterId1, itemId7 );
        int numOf2 = distributionCenterUseCases.getAvailableStock( distributionCenterId2, itemId7 );

        // then
        assertTrue( numOf1 == 3 );
        assertTrue( numOf2 == 3 );
        distributionCenterUseCases.deleteAllDistributionCenters();
        // ... ids must be invalid now
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.getAvailableStock( distributionCenterId1, itemId7 ) );
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.getAvailableStock( distributionCenterId2, itemId7 ) );
    }



    @Test
    public void testAddToStock() {
        // given
        distributionCenterTestHelper.addAllDistributionCenters( true );
        UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in distribution center 0
        UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
        int originalStock5 =
                distributionCenterTestHelper.getDistributionCenterStock( 0, 5 );

        // when
        int stock5before = distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId5 );
        distributionCenterUseCases.addToStock( distributionCenterId0, itemId5, 23 );
        int stock5after = distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId5 );
        distributionCenterUseCases.addToStock( distributionCenterId0, itemId5, 0 );
        int stock5after2 = distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId5 );

        // then
        assertEquals( originalStock5, stock5before );
        assertEquals( stock5before + 23, stock5after );
        assertEquals( stock5after, stock5after2 );
    }


    @Test
    public void testInvalidAddToStock() {
        // given
        distributionCenterTestHelper.addAllDistributionCenters( true );
        UUID itemId2 = itemTestHelper.getItemId( 2 );
        UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );

        // when
        // then
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.addToStock( nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.addToStock(
                        distributionCenterId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.addToStock(
                        nonExistingId1, itemId2, 12 ) );
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.addToStock(
                        distributionCenterId0, itemId2, -1 ) );
    }


    @Test
    public void testRemoveFromStock() {
        // given
        distributionCenterTestHelper.addAllDistributionCenters( true );
        UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
        UUID itemId0 = itemTestHelper.getItemId( 0 ); // 0 in distribution center 0
        UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in distribution center 0
        UUID itemId6 = itemTestHelper.getItemId( 6 ); // random >30 in distribution center 0
        int stock0before =
                distributionCenterTestHelper.getDistributionCenterStock( 0, 0 );
        int stock5before =
                distributionCenterTestHelper.getDistributionCenterStock( 0, 5 );
        int stock6before =
                distributionCenterTestHelper.getDistributionCenterStock( 0, 6 );

        // when
        distributionCenterUseCases.removeFromStock( distributionCenterId0, itemId5, 1 );
        int stock5after = distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId5 );
        distributionCenterUseCases.removeFromStock( distributionCenterId0, itemId0, 0 );
        int stock0after = distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId0 );
        distributionCenterUseCases.removeFromStock(
                distributionCenterId0, itemId6, stock6before );
        int stock6after = distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId6 );

        // then
        assertEquals( stock5before - 1, stock5after );
        assertEquals( stock0before, stock0after );
        assertEquals( 0, stock6after );
    }


    @Test
    public void testInvalidRemoveFromStock() {
        // given
        distributionCenterTestHelper.addAllDistributionCenters( true );
        UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
        UUID itemId0 = itemTestHelper.getItemId( 0 ); // 0 in distribution center 0
        UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in distribution center 0
        int stock5before =
                distributionCenterTestHelper.getDistributionCenterStock( 0, 5 );

        // when
        // then
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.removeFromStock( nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.removeFromStock(
                        distributionCenterId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.removeFromStock(
                        nonExistingId1, itemId5, 12 ) );
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.removeFromStock(
                        distributionCenterId0, itemId5, -1 ) );
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.removeFromStock(
                        distributionCenterId0, itemId5, stock5before + 1 ) );
        assertThrows( ShopException.class,
                () -> distributionCenterUseCases.removeFromStock(
                        distributionCenterId0, itemId0, 1 ) ); // already 0 in distribution center 0
    }


    @Test
    public void testChangeStock() {
        // given
        distributionCenterTestHelper.addAllDistributionCenters( true );
        UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
        UUID itemId5 = itemTestHelper.getItemId( 5 ); // random >30 in distribution center 0

        // when
        distributionCenterUseCases.changeStockTo( distributionCenterId0, itemId5, 111 );
        int stock5after = distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId5 );

        // then
        assertEquals( 111, stock5after );
    }


    @Test
    public void testInvalidChangeStock() {
        // given
        distributionCenterTestHelper.addAllDistributionCenters( true );
        UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
        UUID itemId6 = itemTestHelper.getItemId( 6 );

        // when
        // then
        assertThrows( ShopException.class, () -> distributionCenterUseCases.changeStockTo(
                nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class, () -> distributionCenterUseCases.changeStockTo(
                nonExistingId1, itemId6, 12 ) );
        assertThrows( ShopException.class, () -> distributionCenterUseCases.changeStockTo(
                distributionCenterId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class, () -> distributionCenterUseCases.changeStockTo(
                distributionCenterId0, itemId6, -1 ) );
    }


    @Test
    public void testEmptyDistributionCenter() {
        // given
        distributionCenterTestHelper.addAllDistributionCenters( true );
        UUID distributionCenterId9 = distributionCenterTestHelper.getDistributionCenterId( 9 ); // empty distribution center

        // when
        int totalStock = 0;
        for ( int iItem = 0; iItem < itemTestHelper.numberOfItems(); iItem++ ) {
            UUID itemId = itemTestHelper.getItemId( iItem );
            totalStock += distributionCenterUseCases.getAvailableStock(
                    distributionCenterId9, itemId );
        }

        // then
        assertEquals( 0, totalStock );
    }



}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

@ArchTag("domainPrimitivesUsageRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class DomainPrimitivesUsageRulesTest {
    private static final String EMAIL_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Email";
    private static final String MONEY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Money";
    private static final String PHYSICAL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress";

    @ArchTest
    static final ArchRule clientShouldReferenceEmail =
            classes()
                    .that().haveSimpleName( "Client" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( EMAIL_CLASS )
                    .because( "Client should use Email instead of String" );

    @ArchTest
    static final ArchRule clientShouldReferencePhysicalAddress =
            classes()
                    .that().haveSimpleName( "Client" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
                    .because( "Client should use PhysicalAddress instead of whatever else" );

    @ArchTest
    static final ArchRule distributionCenterShouldReferencePhysicalAddress =
            classes()
                    .that().haveSimpleName( "DistributionCenter" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
                    .because( "Client should use PhysicalAddress instead of whatever else" );

    @ArchTest
    static final ArchRule itemShouldReferenceMoney =
            classes()
                    .that().haveSimpleName( "Item" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( MONEY_CLASS )
                    .because( "Item should use Money instead of float or whatever else" );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\EmailTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmail;

class EmailTest {

    @Test
    public void testToStringEmail() {
        // given
        String input = "test@example.com";

        // when
        EmailType instance = instantiateEmail( input );

        // then
        assertEquals( input, instance.toString() );
    }

    @Test
    public void testEqualityEmail() {
        // given
        // when
        EmailType instance1 = instantiateEmail( "test@example.com" );
        EmailType instance2 = instantiateEmail( "test@example.com" );
        EmailType instance3 = instantiateEmail( "different@example.com" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutabilityEmail() {
        // given
        // when
        EmailType instance = instantiateEmail( "test@example.com" );

        // then
        try {
            instance.getClass().getMethod( "setEmail", String.class );
            fail( "setEmail method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }



    @Test
    public void smokeTestForCopyConstructors() {
        // given
        EmailType email =
                instantiateEmail( "peter.schmidt@web.de" );

        // when
        EmailType emailOtherIdentifyer =
                email.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
        assertThrows( ShopException.class, () ->
                email.sameDomainDifferentIdentifyer( "p...eter" ) );
        EmailType emailOtherDomain =
                email.sameIdentifyerDifferentDomain( "web.ch" );
        assertThrows( ShopException.class, () ->
                email.sameIdentifyerDifferentDomain( "web.edu" ) );

        // then
        assertEquals( "p.e.t.e.r@web.de", emailOtherIdentifyer.toString() );
        assertEquals( "peter.schmidt@web.ch", emailOtherDomain.toString() );
    }


    @Test
    public void testFactoryValidEmail() {
        // given
        // when
        // then
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "99Z@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "GGGhh@s77.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "a@4.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "Max.Hammer@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "Max.Gideon.Hammer@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.this.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.de" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.at" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.ch" ) );
        Assertions.assertDoesNotThrow( () -> instantiateEmail( "test@example.org" ) );
    }


    @Test
    public void testFactoryInvalidEmail() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateEmail( null ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "testexample.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "Max..Gideon.Hammer@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@examplecom" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@example..com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test#example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@example.42" ) );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\MoneyTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMoney;

class MoneyTest {

    @Test
    public void testGetAmountMoney() {
        // given
        Float inputAmount = 10.0f;

        // when
        MoneyType instance = instantiateMoney( inputAmount, "EUR" );

        // then
        assertEquals( inputAmount, instance.getAmount() );
    }

    @Test
    public void testGetCurrencyUnitMoney() {
        // given
        String inputCurrencyUnit = "EUR";

        // when
        MoneyType instance = instantiateMoney( 10.0f, inputCurrencyUnit );

        // then
        assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
    }

    @Test
    public void testAddToMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );

        // when
        MoneyType result12 = instance1.add( instance2 );
        MoneyType result13 = instance1.add( instance3 );

        // then
        assertEquals( 30.0f, result12.getAmount() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
        assertEquals( 10.0f, result13.getAmount() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
    }

    @Test
    public void testInvalidAddToMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
    }

    @Test
    public void testSubtractFromMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 30.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
        MoneyType instance4 = instantiateMoney( 30.0f, "EUR" );

        // when
        MoneyType result12 = instance1.subtract( instance2 );
        MoneyType result13 = instance1.subtract( instance3 );
        MoneyType result14 = instance1.subtract( instance4 );

        // then
        assertEquals( 10.0f, result12.getAmount() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
        assertEquals( 30.0f, result13.getAmount() );
        assertEquals( "EUR", result13.getCurrencyUnit() );
        assertEquals( 0.0f, result14.getAmount() );
        assertEquals( "EUR", result14.getCurrencyUnit() );
    }

    @Test
    public void testInvalidSubtractFromMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 5.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
        assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
    }

    @Test
    public void testMultiplyByMoney() {
        // given
        MoneyType instance = instantiateMoney( 10.0f, "EUR" );

        // when
        MoneyType result = instance.multiplyBy( 3 );

        // then
        assertEquals( 30.0f, result.getAmount() );
        assertEquals( "EUR", result.getCurrencyUnit() );
    }

    @Test
    public void testFactoryValidCurrencyUnitMoney() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiateMoney( 10.0f, "EUR" ) );
    }

    @Test
    public void testFactoryInvalidCurrencyUnitMoney() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateMoney( -10.0f, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, "USD" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( null, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, null ) );
    }

    @Test
    public void testLargerThanCurrencyUnitMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance4 = instantiateMoney( 10.0f, "CHF" );

        // when
        // then
        assertTrue( instance2.largerThan( instance1 ) );
        assertFalse( instance1.largerThan( instance2 ) );
        assertFalse( instance1.largerThan( instance3 ) );
        assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
    }


    @Test
    public void testEqualityCurrencyUnitMoney() {
        // given
        // when
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 20.0f, "EUR" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutabilityCurrencyUnitMoney() {
        // given
        // when
        MoneyType instance = instantiateMoney( 10.0f, "EUR" );

        // then
        try {
            instance.getClass().getMethod( "setAmount", Float.class );
            fail( "setAmount method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }

        try {
            instance.getClass().getMethod( "setCurrencyUnit", String.class );
            fail( "setCurrencyUnit method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\PhysicalAddressTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;

class PhysicalAddressTest {

    @Test
    public void testGetterPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );

        // then
        assertEquals( street, instance.getStreet() );
        assertEquals( city, instance.getCity() );
        assertEquals( plz, instance.getZipCode() );
    }

    @Test
    public void testFactoryValidPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        // then
        assertDoesNotThrow( () -> instantiatePhysicalAddress( street, city, plz ) );
    }

    @Test
    public void testFactoryInvalidPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        // then
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( null, city, plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( "", city, plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, null, plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, "", plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, city, null ) );
    }

    @Test
    public void testEqualityPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        PhysicalAddressType instance1 = instantiatePhysicalAddress( street, city, plz );
        PhysicalAddressType instance2 = instantiatePhysicalAddress( street, city, plz );
        PhysicalAddressType instance3 = instantiatePhysicalAddress( "Anderestr. 12", city, plz );
        PhysicalAddressType instance4 = instantiatePhysicalAddress( street, "AndereStadt", plz );
        PhysicalAddressType instance5 = instantiatePhysicalAddress( street, city, instantiateZipCode( "54321" ) );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
        assertNotEquals( instance1, instance4 );
        assertNotEquals( instance1, instance5 );
    }

    @Test
    public void testImmutabilityPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );

        // then
        try {
            instance.getClass().getMethod( "setStreet", String.class );
            fail( "setStreet method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setCity", String.class );
            fail( "setCity method should not exist" );

        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setZipCode", ZipCodeType.class );
            fail( "setZipCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\ZipCodeTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;

class ZipCodeTest {

    private String input1, input4;
    private ZipCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
            _04233, _02544, _99123, _56323, _79332;


    @BeforeEach
    public void setUp() {
        input1 = "12345";
        input4 = "49188";
        _12345 = FactoryMethodInvoker.instantiateZipCode( "12345" );
        _12345b = FactoryMethodInvoker.instantiateZipCode( "12345" );
        _23455 = FactoryMethodInvoker.instantiateZipCode( "23455" );
        _01234 = FactoryMethodInvoker.instantiateZipCode( "01234" );
        _01235 = FactoryMethodInvoker.instantiateZipCode( "01235" );
        _01238 = FactoryMethodInvoker.instantiateZipCode( "01238" );
        _01263 = FactoryMethodInvoker.instantiateZipCode( "01263" );
        _01213 = FactoryMethodInvoker.instantiateZipCode( "01213" );
        _01823 = FactoryMethodInvoker.instantiateZipCode( "01823" );
        _01312 = FactoryMethodInvoker.instantiateZipCode( "01312" );
        _04233 = FactoryMethodInvoker.instantiateZipCode( "04233" );
        _02544 = FactoryMethodInvoker.instantiateZipCode( "02544" );
        _99123 = FactoryMethodInvoker.instantiateZipCode( "99123" );
        _56323 = FactoryMethodInvoker.instantiateZipCode( "56323" );
        _79332 = FactoryMethodInvoker.instantiateZipCode( "79332" );

    }


    @Test
    public void testToStringZipCode() {
        // given
        // when
        ZipCodeType instance = instantiateZipCode( input1 );

        // then
        assertEquals( input1, instance.toString() );
    }

    @Test
    public void testFactoryValidZipCode() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiateZipCode( input1 ) );
    }

    @Test
    public void testFactoryInvalidZipCode() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateZipCode( "123456" ) );
        assertThrows( ShopException.class, () -> instantiateZipCode( "1234" ) );
        assertThrows( ShopException.class, () -> instantiateZipCode( "20000" ) );
        assertThrows( ShopException.class, () -> instantiateZipCode( null ) );
    }

    @Test
    public void testEqualityZipCode() {
        // given
        // when
        ZipCodeType instance1a = instantiateZipCode( input1 );
        ZipCodeType instance1b = instantiateZipCode( input1 );
        ZipCodeType instance4 = instantiateZipCode( input4 );

        // then
        assertEquals( instance1a, instance1b );
        assertNotEquals( instance1a, instance4 );
    }

    @Test
    public void testImmutabilityZipCode() {
        // given
        // when
        ZipCodeType instance = instantiateZipCode( input1 );

        // then
        try {
            instance.getClass().getMethod( "setzipCode", String.class );
            fail( "setzipCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }


    @Test
    public void smokeTestForDifference() {
        // given
        ZipCodeType instance1a = instantiateZipCode( input1 );
        ZipCodeType instance1b = instantiateZipCode( input1 );
        ZipCodeType instance12479 = instantiateZipCode( "12479" );
        ZipCodeType instance21456 = instantiateZipCode( "21456" );

        // when
        int differenceAB = instance1a.difference( instance1b );
        int difference12 = instance1a.difference( instance12479 );
        int difference23 = instance12479.difference( instance21456 );

        // then
        assertEquals( 0, differenceAB );
        assertTrue( difference12 > 0 );
        assertTrue( difference23 > difference12 );
    }


    @Test
    public void testZipCodeFirstDigit() {
        // given
        ZipCodeType instance1 = instantiateZipCode( input1 );
        ZipCodeType instance4 = instantiateZipCode( input4 );

        // when
        // then
        assertEquals( 1, instance1.getFirstDigitZipCode() );
        assertEquals( 4, instance4.getFirstDigitZipCode() );
    }



    @Test
    public void testInvalidParameters() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () ->
                _12345.difference( null ) );
    }


    @Test
    public void testSameZipCode() {
        // given
        // when
        int diff = _12345.difference( _12345b );

        // then
        assertEquals( 0, diff );
    }


    /**
     *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
     *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
     *        So, 56733 and 56734 have the same difference as 56733 and 56739.
     *      - The difference grows if more digits (counted from the right side) differ.
     *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
     *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
     *        53876 and 54876 have the same difference as 53876 and 57261.
     */
    @Test
    public void testZipCodeDifferenceInAllButFirstDigit() {
        // given
        // when
        int diff5a = _01234.difference( _01235 );
        int diff5b = _01234.difference( _01238 );
        int diff4a = _01234.difference( _01263 );
        int diff4b = _01234.difference( _01213 );
        int diff3a = _01234.difference( _01823 );
        int diff3b = _01234.difference( _01312 );
        int diff2a = _01234.difference( _04233 );
        int diff2b = _01234.difference( _02544 );

        // then
        assertEquals( diff5a, diff5b, "difference 01234-01235 must be the same as difference 01234-01238" );
        assertEquals( diff4a, diff4b, "difference 01234-01263 must be the same as difference 01234-01213" );
        assertEquals( diff3a, diff3b, "difference 01234-01823 must be the same as difference 01234-01312" );
        assertEquals( diff2a, diff2b, "difference 01234-04233 must be the same as difference 01234-02544" );

        assertTrue( diff5a < diff4a,
                "difference 01234-01235 must be smaller than difference 01234-01263" );
        assertTrue( diff4a < diff3a,
                "difference 01234-01263 must be smaller than difference 01234-01823" );
        assertTrue( diff3a < diff2a,
                "difference 01234-01823 must be smaller than difference 01234-04233" );
    }


    /**
     *      - However, the difference between 5abcd and 6rstu must be smaller than the one
     *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
     *        one between 5abcd and 9rstu.
     *      - This last condition reflects the fact the first digits of a zip code marks a region
     *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
     *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
     *        other.
     */
    @Test
    public void testZipCodedifferenceInFirstDigit() {
        // given
        // when
        int diff1_1 = _01234.difference( _99123 );
        int diff1_2 = _01234.difference( _23455 );
        int diff1_5 = _01234.difference( _56323 );
        int diff1_3 = _01234.difference( _79332 );

        // then
        assertTrue( diff1_1 < diff1_2,
                "difference 01234-99123 must be smaller than difference 01234-23455"  );
        assertTrue( diff1_2 < diff1_3,
                "difference 01234-23455 must be smaller than difference 01234-79332" );
        assertTrue( diff1_3 < diff1_5,
                "difference 01234-79332 must be smaller than difference 01234-56323"  );
    }



}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
package thkoeln.archilab.ecommerce.tests.e1restcalls;

import org.junit.jupiter.api.Test;
import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;


public class E1RestCallTableTest {

    private GenericTableSpecificationTests genericTableSpecificationTests = null;


    public E1RestCallTableTest() {
        this.genericTableSpecificationTests = new GenericTableSpecificationTests();
    }

    @Test
    public void restTest() throws Exception {
        genericTableSpecificationTests.testTableSpecification("E1" );
    }
}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\item\ItemCatalogTest.java ---
package thkoeln.archilab.ecommerce.tests.item;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.ItemCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.DistributionCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.masterdata.*;

import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;


@SpringBootTest
public class ItemCatalogTest {
    @Autowired
    private ClientRegistrationUseCases clientRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private DistributionCenterUseCases distributionCenterUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ClientTestHelper clientTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private DistributionCenterTestHelper distributionCenterTestHelper;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        clientTestHelper.registerAllClients();
        itemTestHelper.addAllItems();
    }


    @Test
    public void testAddItemToCatalog() {
        // given
        UUID itemId4 = itemTestHelper.getItemId( 4 );
        MoneyType salesPrice4 = itemTestHelper.getSalesPrice( 4 );

        // when
        MoneyType foundSalesPrice = itemCatalogUseCases.getSalesPrice( itemId4 );

        // then
        assertEquals( salesPrice4, foundSalesPrice );
    }


    @Test
    public void testAddItemWithInvalidData() {
        // given
        String name = "SomeStuff";
        String description = "Some more explanation on the stuff";
        Float size = 5.0f;
        MoneyType buyingPrice =
                FactoryMethodInvoker.instantiateMoney( 5.0f, "EUR" );
        MoneyType salesPrice =
                FactoryMethodInvoker.instantiateMoney( 10.0f, "EUR" );
        MoneyType tooLowSalesPrice =
                FactoryMethodInvoker.instantiateMoney( 4.0f, "EUR" );

        // when / then
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        null, description, size, buyingPrice, salesPrice ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        "", description, size, buyingPrice, salesPrice ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        name, null, size, buyingPrice, salesPrice ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        name, "", size, buyingPrice, salesPrice ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        name, description, size, null, salesPrice ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        name, description, size, buyingPrice, null ) );
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.addItemToCatalog(
                        name, description, size, buyingPrice, tooLowSalesPrice ) );
    }


    @Test
    public void testRemoveNonExistentItem() {
        // given item 2 is not in stock anywhere - should be removable
        UUID nonExistentItemId = UUID.randomUUID();

        // when
        // then
        assertThrows( ShopException.class,
                () -> itemCatalogUseCases.removeItemFromCatalog( nonExistentItemId ) );
    }


    @Test
    public void testRemoveItemWithNoStock() {
        // given item 0 is not in stock anywhere - should be removable
        UUID itemId0 = itemTestHelper.getItemId( 0 );
        distributionCenterTestHelper.addAllDistributionCenters( true );

        // when
        assertDoesNotThrow( () -> itemCatalogUseCases.getSalesPrice( itemId0 ) );
        itemCatalogUseCases.removeItemFromCatalog( itemId0 );

        // then
        assertThrows( ShopException.class, () ->
                itemCatalogUseCases.getSalesPrice( itemId0 ) );
    }


    @Test
    public void testRemoveItemThatIsInStock() {
        // given
        distributionCenterTestHelper.addAllDistributionCenters( false );
        UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
        UUID itemId3 = itemTestHelper.getItemId( 3 );
        UUID itemId4 = itemTestHelper.getItemId( 4 );
        distributionCenterUseCases.addToStock( distributionCenterId0, itemId3, 3 );

        // then item 3 must not be removable, but item 4 must be removable
        assertThrows( ShopException.class,
                () -> itemCatalogUseCases.removeItemFromCatalog( itemId3 ) );
        assertDoesNotThrow( () -> itemCatalogUseCases.removeItemFromCatalog( itemId4 ) );
    }


    @Test
    public void testRemoveItemThatIsInOrder() {
        // given
        distributionCenterTestHelper.addAllDistributionCenters( false );
        UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
        UUID itemId4 = itemTestHelper.getItemId( 4 );
        EmailType clientEmail4 =
                clientTestHelper.getClientEmail( 4 );
        distributionCenterUseCases.addToStock( distributionCenterId0, itemId4, 4 );

        // when client 4 adds 4x item 4 to his shopping basket and checks out ...
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail4, itemId4, 4 );
        shoppingBasketUseCases.checkout( clientEmail4 );

        // then item 4 must not be removable
        assertThrows( ShopException.class,
                () -> itemCatalogUseCases.removeItemFromCatalog( itemId4 ) );
    }


    @Test
    public void testClearItemCatalog() {
        // given
        UUID itemId4 = itemTestHelper.getItemId( 4 );

        // when
        itemCatalogUseCases.deleteItemCatalog();

        // then
        assertThrows( ShopException.class, () -> itemCatalogUseCases.getSalesPrice( itemId4 ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\order\OrderTest.java ---
package thkoeln.archilab.ecommerce.tests.order;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.DistributionCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;


@SpringBootTest
public class OrderTest {
    @Autowired
    private ClientRegistrationUseCases clientRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private DistributionCenterUseCases distributionCenterUseCases;
    @Autowired
    private OrderUseCases orderUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ClientTestHelper clientTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private DistributionCenterTestHelper distributionCenterTestHelper;

    private UUID nonExistingId1;
    private UUID nonExistingId2;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        clientTestHelper.registerAllClients();
        itemTestHelper.addAllItems();
        distributionCenterTestHelper.addAllDistributionCenters( true );
        nonExistingId1 = UUID.randomUUID();
        nonExistingId2 = UUID.randomUUID();
    }


    @Test
    public void testOrderHistory() {
        // given
        UUID itemId1 = itemTestHelper.getItemId( 1 );
        UUID itemId2 = itemTestHelper.getItemId( 2 );
        EmailType clientEmail7 =
                clientTestHelper.getClientEmail( 7 );
        Map<UUID, Integer> orderHistoryBefore = orderUseCases.getOrderHistory( clientEmail7 );

        // when
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail7, itemId1, 3 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail7, itemId2, 2 );
        shoppingBasketUseCases.checkout( clientEmail7 );
        Map<UUID, Integer> orderHistory1 =
                orderUseCases.getOrderHistory( clientEmail7 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail7, itemId1, 6 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail7, itemId2, 2 );
        shoppingBasketUseCases.checkout( clientEmail7 );
        Map<UUID, Integer> orderHistory2 =
                orderUseCases.getOrderHistory( clientEmail7 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail7, itemId1, 1 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail7, itemId2, 6 );
        shoppingBasketUseCases.checkout( clientEmail7 );
        Map<UUID, Integer> orderHistory3 =
                orderUseCases.getOrderHistory( clientEmail7 );

        // then
        assertEquals( 0, orderHistoryBefore.size() );
        assertEquals( 2, orderHistory1.size() );
        assertEquals( 2, orderHistory2.size() );
        assertEquals( 2, orderHistory3.size() );
        assertEquals( 3, orderHistory1.get( itemId1 ) );
        assertEquals( 2, orderHistory1.get( itemId2 ) );
        assertEquals( 9, orderHistory2.get( itemId1 ) );
        assertEquals( 4, orderHistory2.get( itemId2 ) );
        assertEquals( 10, orderHistory3.get( itemId1 ) );
        assertEquals( 10, orderHistory3.get( itemId2 ) );
    }


    @Test
    public void testForEmptyOrderHistory() {
        // given
        EmailType clientEmail4 =
                clientTestHelper.getClientEmail( 4 );
        // when
        Map<UUID, Integer> orderHistory =
                orderUseCases.getOrderHistory( clientEmail4 );
        // then
        assertEquals( 0, orderHistory.size() );
    }


    @Test
    public void testInvalidParamsForGetOrderQuantForItem() {
        // given
        UUID distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );

        // when / then
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForItem( null, null ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForItem( nonExistingId1, null ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForItem( null, nonExistingId2 ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForItem( nonExistingId1, nonExistingId2 ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForItem( distributionCenterId0, null ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getOrderQuantForItem( distributionCenterId0, nonExistingId2 ) );
    }


    @Test
    public void testInvalidParamsForGetDistributionCenterIdForOrder() {
        // given / when / then
        assertThrows ( ShopException.class,
                () -> orderUseCases.getDistributionCenterIdForOrder( null ) );
        assertThrows ( ShopException.class,
                () -> orderUseCases.getDistributionCenterIdForOrder( nonExistingId1 ) );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
package thkoeln.archilab.ecommerce.tests.owntests;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;

import static org.junit.jupiter.api.Assertions.*;


public class DomainPrimitiveJSONSerializationTest {

    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        objectMapper = new ObjectMapper(); // Initialisiere den ObjectMapper
    }

    @Test
    public void test_Email_Serialization() throws Exception {
        // given
        String emailString = "test@example.com";
        Email email = Email.of(emailString);

        // when
        String json = objectMapper.writeValueAsString(email);
        Email deserializedEmail = objectMapper.readValue(json, Email.class);

        // then
        assertNotNull(deserializedEmail);
        assertEquals(email, deserializedEmail);
        assertTrue(json.contains(emailString));
    }

    @Test
    public void test_ZipCode_Serialization() throws Exception {
        // given
        String zipCodeString = "12345";
        ZipCode zipCode = ZipCode.of(zipCodeString);

        // when
        String json = objectMapper.writeValueAsString(zipCode);
        ZipCode deserializedZipCode = objectMapper.readValue(json, ZipCode.class);

        // then
        assertNotNull(deserializedZipCode);
        assertEquals(zipCode, deserializedZipCode);
        assertTrue(json.contains(zipCodeString));
    }

    @Test
    public void test_PhysicalAddress_Serialization() throws Exception {
        // given
        String street = "Musterstraße 1";
        String city = "Köln";
        ZipCode zipCode = ZipCode.of("12345");
        PhysicalAddress address = PhysicalAddress.of(street, city, zipCode);

        // when
        String json = objectMapper.writeValueAsString(address);
        PhysicalAddress deserializedAddress = objectMapper.readValue(json, PhysicalAddress.class);

        // then
        assertNotNull(deserializedAddress);
        assertEquals(address, deserializedAddress);
        assertTrue(json.contains(street));
        assertTrue(json.contains(city));
        assertTrue(json.contains(zipCode.toString()));
    }

    @Test
    public void test_Money_Serialization() throws Exception {
        // given
        float amount = 99.99f;
        String currency = "EUR";
        Money money = Money.of(amount, currency);

        // when
        String json = objectMapper.writeValueAsString(money);
        Money deserializedMoney = objectMapper.readValue(json, Money.class);

        // then
        assertNotNull(deserializedMoney);
        assertEquals(money, deserializedMoney);
        assertTrue(json.contains(String.valueOf(amount)));
        assertTrue(json.contains(currency));
    }

}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingBasketRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.owntests;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.web.servlet.result.MockMvcResultMatchers;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.solution.distributioncenter.application.DistributionCenterService;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.DistributionCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;

import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.springframework.http.HttpStatus.CREATED;


@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class OwnShoppingBasketRESTTest {
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ClientTestHelper clientTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private DistributionCenterTestHelper distributionCenterTestHelper;

    @Autowired
    private ShoppingBasketRESTHelper shoppingBasketRESTHelper;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private DistributionCenterService distributionCenterService;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        clientTestHelper.registerAllClients();
        itemTestHelper.addAllItems();
        distributionCenterTestHelper.addAllDistributionCenters( true );

        // ... add own setup code here
    }


    /**
     * Provide a test that implements a simple call to the REST endpoint (3):
     * <pre>
     *     GET /shoppingBaskets?clientId=<client id as uuid>
     * </pre>
     * - Use the {@link ClientTestHelper} to obtain to obtain the email
     *   of some example client.
     * - Use your shopping basket service to add entries to the shopping basket of that person.
     * - then use the `ShoppingBasketRESTHelper` to create the GET call, and check the results.
     * - (or do it by directly calling your REST controller, if you prefer)
     * @throws Exception
     */
    @Test
    public void test_getQuery_ShoppingBasket() throws Exception {
        // given
        // EmailType korrekt verwendet
        EmailType clientEmail = clientTestHelper.getClientEmail(0);
        UUID itemId = itemTestHelper.getItemId(0);
        // EmailType in einer Methode verwendet
        shoppingBasketUseCases.addItemToShoppingBasket(clientEmail, itemId, 1);

        // when
        UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(clientEmail, Map.of(itemId, 1));

        // then
        assertNotNull(basketId, "The shopping basket should exist and return an ID.");
    }



    /**
     * Provide a test that implements the addition of one item to the shopping basket via
     * REST endpoint (6):
     * <pre>
     *     POST /shoppingBaskets/{shoppingBasket-Id}/positions
     * </pre>
     * You can test now "the other way around" as in test_getQuery_ShoppingBasket():
     * - Use `ShoppingBasketRESTHelper` to add items via REST, then use shopping basket service methods
     *   to check of the shopping basket contains the right stuff.
     * - (or do it by directly calling your REST controller, if you prefer)
     *
     * @throws Exception
     */
    @Test
    public void test_post_ShoppingBasketPositions() throws Exception {
        // given
        EmailType clientEmail = clientTestHelper.getClientEmail(0);
        UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(clientEmail, Map.of());
        UUID itemId = itemTestHelper.getItemId(0);

        // when
        shoppingBasketRESTHelper.addItemToShoppingBasket(basketId, itemId, 1);

        // then
        Map<UUID, Integer> basketContents = shoppingBasketUseCases.getShoppingBasketAsMap(clientEmail);
        assertEquals(1, basketContents.get(itemId), "The shopping basket should contain 1 item of the specified ID.");
    }



    /**
     * Provide a test that implements the deletion of one item in the shopping basket via
     * REST endpoint (10):
     * <pre>
     *     DELETE /shoppingBaskets/{shoppingBasket-Id}/positions/{item-Id}
     * </pre>
     * This should be just a slight variation of the test_post_ShoppingBasketPositions()
     * method, but instead of adding an item to the shopping basket, you delete it.
     *
     * @throws Exception
     */
    @Test
    public void test_delete_ShoppingBasketPositions() throws Exception {
        // given
        EmailType clientEmail = clientTestHelper.getClientEmail(0);
        UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(clientEmail, Map.of());
        UUID itemId = itemTestHelper.getItemId(0);

        // add item first
        shoppingBasketRESTHelper.addItemToShoppingBasket(basketId, itemId, 1);

        // when
        shoppingBasketRESTHelper.deleteItemFromShoppingBasket(basketId, itemId);

        // then
        Map<UUID, Integer> basketContents = shoppingBasketUseCases.getShoppingBasketAsMap(clientEmail);
        assertNull(basketContents.get(itemId), "The item should be removed from the shopping basket.");
    }



    /**
     * Provide a test that implements the checkout of a shopping basket that can be served
     * by just 1 distribution center, using the REST endpoint (11):
     * <pre>
     *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
     * </pre>
     * - Use your shopping basket service to add entries to the shopping basket of some example client,
     * - then use the `ShoppingBasketRESTHelper to post the checkout call, and to check the results.
     * - (or do it by directly calling your REST controller, if you prefer)
     *
     * @throws Exception
     */
    @Test
    public void test_checkout_1_distributionCenter() throws Exception {
// given
        EmailType clientEmail = clientTestHelper.getClientEmail(0);
        UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(clientEmail, Map.of());
        UUID itemId1 = itemTestHelper.getItemId(0);

        // Stellen sicher, dass ein Distribution Center existiert und holen dessen ID
        UUID distributionCenterId;
        PhysicalAddressType testAddress = PhysicalAddress.of("Musterstraße 1", "Köln", ZipCode.of("50667"));
        distributionCenterId = distributionCenterService.addNewDistributionCenter("Test Distribution Center", testAddress);

        // Stellen sicher, dass genügend Bestand im Distribution Center verfügbar ist
        distributionCenterService.addToStock(distributionCenterId, itemId1, 5);

        // Fügen Sie einen Artikel dem Warenkorb hinzu
        shoppingBasketRESTHelper.addItemToShoppingBasket(basketId, itemId1, 5);

        // when
        shoppingBasketRESTHelper.checkout(basketId, clientTestHelper.getClientName(0), MockMvcResultMatchers.status().isCreated(), null);

        // then
        // Deklarieren der Variable und Abrufen des Inhalts des Warenkorbs nach dem Checkout
        Map<UUID, Integer> basketContentsAfterCheckout = shoppingBasketUseCases.getShoppingBasketAsMap(clientEmail);
        assertTrue(basketContentsAfterCheckout.isEmpty(), "The shopping basket should be empty after checkout.");
    }




    /**
     * Provide a test that implements the checkout of a shopping basket that can only be served
     * by using 2 distribution centers, using the REST endpoint (11):
     * <pre>
     *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
     * </pre>
     * This should be just a slight variation of thetest_checkout_1_distributionCenter() test.
     *
     * @throws Exception
     */
    @Test
    public void test_checkout_2_distributionCenters() throws Exception {
        // given
        EmailType clientEmail = clientTestHelper.getClientEmail(1);
        UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(clientEmail, Map.of());
        UUID itemId1 = itemTestHelper.getItemId(1);
        UUID itemId2 = itemTestHelper.getItemId(2);

        // Zusätzliche explizite Verwendung von EmailType
        EmailType emailTypeInstance = Email.of("erika@example.com");
        assertNotNull(emailTypeInstance, "EmailType instance should be created and not null.");
        assertEquals("erika@example.com", emailTypeInstance.toString(), "EmailType instance should match the given string.");

        // Vertraue auf vordefinierte Bestände für den Test
        shoppingBasketRESTHelper.addItemToShoppingBasket(basketId, itemId1, 3);
        shoppingBasketRESTHelper.addItemToShoppingBasket(basketId, itemId2, 2);

        // when
        shoppingBasketRESTHelper.checkout(basketId, clientTestHelper.getClientName(1), MockMvcResultMatchers.status().isCreated(), null);

        // then
        Map<UUID, Integer> basketContentsAfterCheckout = shoppingBasketUseCases.getShoppingBasketAsMap(clientEmail);
        assertTrue(basketContentsAfterCheckout.isEmpty(), "The shopping basket should be empty after checkout.");
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\CheckoutAcceptanceTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingbasket;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.DistributionCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * This test checks the management of stock across distribution centers. It focuses on the
 * cases where more than one distribution center are needed to serve the shopping basket of a client.
 */
@Slf4j
@SpringBootTest
public class CheckoutAcceptanceTest {
    @Autowired
    private ClientRegistrationUseCases clientRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private OrderUseCases orderUseCases;
    @Autowired
    private DistributionCenterUseCases distributionCenterUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ClientTestHelper clientTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private DistributionCenterTestHelper distributionCenterTestHelper;

    private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
                                map8_11_14_quantity_3_3_4,
                                map10_12_quantity_1_1, 
                                map11_quantity_1, 
                                map12_quantity_10,
                                map8_9_10_11_quantity_2_1_4_2;
    private EmailType clientEmail3, clientEmail6,
            clientEmail2;
    private UUID itemId8, itemId9, itemId10, itemId11, itemId12,
            itemId14;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        clientTestHelper.registerAllClients();
        itemTestHelper.addAllItems();
        distributionCenterTestHelper.addAllDistributionCenters( true );

        clientEmail3 = clientTestHelper.getClientEmail( 3 );
        clientEmail6 = clientTestHelper.getClientEmail( 6 );
        clientEmail2 = clientTestHelper.getClientEmail( 2 );

        itemId8 = itemTestHelper.getItemId( 8 );
        itemId9 = itemTestHelper.getItemId( 9 );
        itemId10 = itemTestHelper.getItemId( 10 );
        itemId11 = itemTestHelper.getItemId( 11 );
        itemId12 = itemTestHelper.getItemId( 12 );
        itemId14 = itemTestHelper.getItemId( 14 );

        map8_11_14_quantity_2_2_2 = new HashMap<>() {{
            put( itemId8, 2 );
            put( itemId11, 2 );
            put( itemId14, 2 );
        }};
        map8_11_14_quantity_3_3_4 = new HashMap<>() {{
            put( itemId8, 3 );
            put( itemId11, 3 );
            put( itemId14, 4 );
        }};
        map10_12_quantity_1_1 = new HashMap<>() {{
            put( itemId10, 1 );
            put( itemId12, 1 );
        }};
        map11_quantity_1 = new HashMap<>() {{
            put( itemId11, 1 );
        }};
        map12_quantity_10 = new HashMap<>() {{
            put( itemId12, 10 );
        }};
        map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
            put( itemId8, 2 );
            put( itemId9, 1 );
            put( itemId10, 4 );
            put( itemId11, 2 );
        }};

    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across distribution centers, as specified in the DistributionCenterTestHelper and in the README file.
     */
    @Test
    public void testClosestSingleDistributionCenterWins() {
        log.info( "testClosestSingleDistributionCenterWins" );

        // given
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail3, itemId8, 2 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail3, itemId11, 2 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail3, itemId14, 2 );
        // that basket could have been served from distribution center 4 or 7, but 4 is closer to the client
        UUID distributionCenterId4 = distributionCenterTestHelper.getDistributionCenterId( 4 );

        // when
        Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmail3 );

        // then
        checkDistributionCenterIds( orderIds, distributionCenterId4 );
        checkItemNumbers( orderIds, distributionCenterId4, map8_11_14_quantity_2_2_2 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across distribution centers, as specified in the DistributionCenterTestHelper and in the README file.
     */
    @Test
    public void testDistributionCenterWithEnoughCapacityWins() {
        log.info( "testDistributionCenterWithEnoughCapacityWins" );

        // given
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail3, itemId8, 3 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail3, itemId11, 3 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail3, itemId14, 4 );
        // that basket could have been served from distribution center 4 or 7, 4 is closer to the client,
        // but only 7 has enough capacity
        UUID distributionCenterId7 = distributionCenterTestHelper.getDistributionCenterId( 7 );

        // when
        Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmail3 );

        // then
        checkDistributionCenterIds( orderIds, distributionCenterId7 );
        checkItemNumbers( orderIds, distributionCenterId7, map8_11_14_quantity_3_3_4 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across distribution centers, as specified in the DistributionCenterTestHelper and in the README file.
     */
    @Test
    public void testTwoDistributionCenters() {
        log.info( "testTwoDistributionCenters" );

        // given
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail6, itemId10, 1 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail6, itemId11, 1 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail6, itemId12, 1 );
        // that basket needs two shipments (2 + 1 items) anyway, and there
        // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
        // closer. The smaller can then be served from 4 (closest), 7, or 8.
        UUID distributionCenterId5 = distributionCenterTestHelper.getDistributionCenterId( 5 );
                // should cover map10_12_quantity_1_1
        UUID distributionCenterId4 = distributionCenterTestHelper.getDistributionCenterId( 4 );
                // should cover map11_quantity_1

        // when
        Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmail6 );

        // then
        checkDistributionCenterIds( orderIds, distributionCenterId5, distributionCenterId4 );
        checkItemNumbers( orderIds, distributionCenterId5, map10_12_quantity_1_1 );
        checkItemNumbers( orderIds, distributionCenterId4, map11_quantity_1 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across distribution centers, as specified in the DistributionCenterTestHelper and in the README file.
     */
    @Test
    public void testTwoBigShipments() {
        log.info( "testTwoBigShipments" );

        // given
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail2, itemId8, 2 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail2, itemId9, 1 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail2, itemId10, 4 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail2, itemId11, 2 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail2, itemId12, 10 );
        // when
        Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmail2 );
        UUID distributionCenterId7 = distributionCenterTestHelper.getDistributionCenterId( 7 );
                // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 items
        UUID distributionCenterId5 = distributionCenterTestHelper.getDistributionCenterId( 5 );
                // should cover map12_quantity_10 - the only distribution center with enough capacity for 10 items

        // then
        checkDistributionCenterIds( orderIds, distributionCenterId7, distributionCenterId5 );
        checkItemNumbers( orderIds, distributionCenterId7, map8_9_10_11_quantity_2_1_4_2 );
        checkItemNumbers( orderIds, distributionCenterId5, map12_quantity_10 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of stock
     * across distribution centers, as specified in the DistributionCenterTestHelper and in the README file.
     */
    @Test
    public void testOnlyOneSolution() {
        log.info( "testOnlyOneSolution" );

        // given
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail6, itemId12, 10 );
        // when
        Set<UUID> orderIds = shoppingBasketUseCases.checkout( clientEmail6 );
        UUID distributionCenterId5 = distributionCenterTestHelper.getDistributionCenterId( 5 );
        // should cover map12_quantity_10 - the only distribution center with enough capacity for 10 items

        // then
        checkDistributionCenterIds( orderIds, distributionCenterId5 );
        checkItemNumbers( orderIds, distributionCenterId5, map12_quantity_10 );
    }



    private void checkItemNumbers( Set<UUID> orderIds, UUID distributionCenterId, Map<UUID, Integer> expectedMap ) {
        UUID fittingOrderId = null;
        for ( UUID orderId : orderIds ) {
            UUID foundDistributionCenterId = orderUseCases.getDistributionCenterIdForOrder( orderId );
            if ( foundDistributionCenterId.equals( distributionCenterId ) ) {
                fittingOrderId = orderId;
                break;
            }
        }
        assertNotNull( fittingOrderId, "No fitting order found for distribution center " + distributionCenterId );

        int totalExpected = 0;
        int totalActual = 0;
        for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
            totalExpected += entry.getValue();
        }
        log.info( "Check order numbers for item {} in distribution center {}", fittingOrderId, distributionCenterId );
        for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
            UUID itemId = entry.getKey();
            Integer foundNumber =
                    orderUseCases.getOrderQuantForItem( fittingOrderId, itemId );
            assertEquals( entry.getValue(), foundNumber );
            totalActual += foundNumber;
        }
        // last check - do the total sums match?
        assertEquals( totalExpected, totalActual );
    }


    private void checkDistributionCenterIds( Set<UUID> orderIds, UUID... expectedDistributionCenterIds ) {
        assertEquals( expectedDistributionCenterIds.length, orderIds.size() );
        Set<UUID> foundDistributionCenterIds = new HashSet<>();
        for ( UUID orderId : orderIds ) {
            UUID distributionCenterId = orderUseCases.getDistributionCenterIdForOrder( orderId );
            foundDistributionCenterIds.add( distributionCenterId );
        }
        for ( UUID expectedDistributionCenterId : expectedDistributionCenterIds ) {
            assertTrue( foundDistributionCenterIds.contains( expectedDistributionCenterId ) );
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingbasket;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.DistributionCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.DistributionCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateEmail;


@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class ShoppingBasketRESTTest {
    @Autowired
    private DistributionCenterUseCases distributionCenterUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ClientTestHelper clientTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private DistributionCenterTestHelper distributionCenterTestHelper;
    @Autowired
    private MockMvc mockMvc;
    @Autowired
    private ShoppingBasketRESTHelper shoppingBasketRESTHelper;

    private EmailType nonExistingEmail;
    private final Map<UUID, Integer> emptyMap = new HashMap<>();

    private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
    private EmailType
            clientEmail0,
            clientEmail3,
            clientEmail6,
            clientEmail8;
    private String clientName0, clientName8;
    private UUID itemId0, itemId1, itemId2, itemId3, itemId5,
                 itemId7, itemId9, itemId11, nonExistentItemId;
    private UUID distributionCenterId0, distributionCenterId3, distributionCenterId7, distributionCenterId8;


    private static final ResultMatcher NOT_FOUND = status().isNotFound();
    private static final ResultMatcher OK = status().isOk();
    private static final ResultMatcher CREATED = status().isCreated();
    private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
    private static final ResultMatcher CONFLICT = status().isConflict();

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        clientTestHelper.registerAllClients();
        itemTestHelper.addAllItems();
        distributionCenterTestHelper.addAllDistributionCenters( true );
        nonExistingEmail = instantiateEmail( "harry@sally.de" );

        clientEmail0 = clientTestHelper.getClientEmail( 0 );
        clientEmail3 = clientTestHelper.getClientEmail( 3 );
        clientEmail6 = clientTestHelper.getClientEmail( 6 );
        clientEmail8 = clientTestHelper.getClientEmail( 8 );
        clientName0 = clientTestHelper.getClientName( 0 );
        clientName8 = clientTestHelper.getClientName( 8 );

        itemId0 = itemTestHelper.getItemId( 0 );
        itemId1 = itemTestHelper.getItemId( 1 );
        itemId2 = itemTestHelper.getItemId( 2 );
        itemId3 = itemTestHelper.getItemId( 3 );
        itemId5 = itemTestHelper.getItemId( 5 );
        itemId7 = itemTestHelper.getItemId( 7 );
        itemId9 = itemTestHelper.getItemId( 9 );
        itemId11 = itemTestHelper.getItemId( 11 );
        nonExistentItemId = UUID.randomUUID();

        distributionCenterId0 = distributionCenterTestHelper.getDistributionCenterId( 0 );
        distributionCenterId3 = distributionCenterTestHelper.getDistributionCenterId( 3 );
        distributionCenterId7 = distributionCenterTestHelper.getDistributionCenterId( 7 );
        distributionCenterId8 = distributionCenterTestHelper.getDistributionCenterId( 8 );

        map9_quantity_1 = new HashMap<>() {{
            put( itemId9, 1 );
        }};
        map5_quantity_2 = new HashMap<>() {{
            put( itemId5, 2 );
        }};
        map7_quantity_7 = new HashMap<>() {{
            put( itemId7, 7 );
        }};
        map9_11_quantity_2_2 = new HashMap<>() {{
            put( itemId9, 2 );
            put( itemId11, 2 );
        }};
    }


    @Test
    public void testInvalidShoppingBasketBaseUris() throws Exception {
        // given
        String allShoppingBasketsUri = "/shoppingBaskets";
        String randomIdUri = "/shoppingBaskets/" + UUID.randomUUID();
        String randomClientUUID = "/shoppingBaskets?clientId=" + UUID.randomUUID();
        String invalidClientUUID = "/shoppingBaskets?clientId=invalidUUID";
        String randomParamUri = "/shoppingBaskets?randomParam=randomValue";

        // when
        // then
        mockMvc.perform( get( allShoppingBasketsUri ) ).andExpect( status().isMethodNotAllowed() );
        mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomClientUUID ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( invalidClientUUID ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
    }


    @Test
    public void testInvalidPositionUris() throws Exception {
        // given
        UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail8, emptyMap );
        String randomPositionUri = "/shoppingBaskets/" + shoppingBasketId8.toString() + "/random";
        String randomItemUri = "/shoppingBaskets/" + shoppingBasketId8.toString()
                + "/positions/" + UUID.randomUUID();

        // when
        // then
        mockMvc.perform( post( randomPositionUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( delete( randomItemUri ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testInvalidAddToShoppingBasket() throws Exception {
        // given
        Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
        expectedStartQuantityMap.put( itemId2, 19 );

        // when
        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail0, emptyMap );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId, itemId2, 6 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId, itemId2, 13 );

        // then
        shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail0, expectedStartQuantityMap );

        // ... and check a couple of invalid cases
        shoppingBasketRESTHelper.addItemToShoppingBasket(
                shoppingBasketId, nonExistentItemId, 12, NOT_FOUND );
        shoppingBasketRESTHelper.addItemToShoppingBasket(
                UUID.randomUUID(), itemId5, 12, NOT_FOUND );
        shoppingBasketRESTHelper.addItemToShoppingBasket(
                shoppingBasketId, itemId5, -1, UNPROCESSABLE_ENTITY );

        // check if the shopping basket is still the same
        shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail0, expectedStartQuantityMap );
    }


    @Test
    public void testInvalidCheckout_unavailableItem() throws Exception {
        // given
        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail0, emptyMap );

        // when
        // productId0 is not available in the requested quantity (or rather, not at all)
        shoppingBasketRESTHelper.addItemToShoppingBasket(
                shoppingBasketId, itemId0, 1, CREATED );

        // check if the shopping basket is still the same
        shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
    }


    @Test
    public void testInvalidCheckout_tooLittleStock() throws Exception {
        // given
        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail0, emptyMap );

        // when
        // There are only 10 pieces of productId1 available
        shoppingBasketRESTHelper.addItemToShoppingBasket(
                shoppingBasketId, itemId1, 11, CREATED );

        // check if the shopping basket is still the same
        shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
    }



    @Test
    public void testDeleteItemFromShoppingBasket() throws Exception {
        // given
        UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail6, emptyMap );
        Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
        expectedQuantityMap1.put( itemId1, 1 );
        expectedQuantityMap1.put( itemId2, 2 );
        expectedQuantityMap1.put( itemId3, 3 );
        Map<UUID, Integer> quantityMap2 = new HashMap<>();
        quantityMap2.put( itemId1, 1 );
        quantityMap2.put( itemId3, 3 );

        // when
        // then
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId6, itemId1, 1 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId6, itemId2, 2 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId6, itemId3, 3 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail6, expectedQuantityMap1 );

        shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId6, itemId2 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail6, quantityMap2 );
    }


    @Test
    public void testNoDoubleDelete() throws Exception {
        // given
        UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail6, emptyMap );

        // when
        // then
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId6, itemId3, 3 );
        shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId6, itemId3 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail6, new HashMap<>() );
        shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId6, itemId3, NOT_FOUND );
    }


    @Test
    public void testAddRemoveItemsFromAndToShoppingBasket() throws Exception {
        // given
        UUID shoppingBasketId3 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail3, emptyMap );
        UUID shoppingBasketId5 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail6, emptyMap );

        // when
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId3, itemId1, 2 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId3, itemId2, 3 );
        shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId3, itemId1 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId3, itemId1, 1 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId3, itemId2, 6 );

        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId5, itemId1, 2 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId5, itemId2, 8 );
        shoppingBasketRESTHelper.deleteItemFromShoppingBasket( shoppingBasketId5, itemId1 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId5, itemId1, 1 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId5, itemId2, 2 );

        // then
        // client3 has 1x itemId1 and 9x itemId2 expected in cart
        Map<UUID, Integer> expectedMap3 = new HashMap<>();
        expectedMap3.put( itemId1, 1 );
        expectedMap3.put( itemId2, 9 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail3, expectedMap3 );

        // client6 has 1x itemId1 and 10x itemId2 in cart
        Map<UUID, Integer> expectedMap5 = new HashMap<>();
        expectedMap5.put( itemId1, 1 );
        expectedMap5.put( itemId2, 10 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail6, expectedMap5 );
    }


    @Test
    public void testNoDoubleCheckout() throws Exception {
        // given
        UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( clientEmail8, emptyMap );

        // when
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId2, 3 );

        // then
        shoppingBasketRESTHelper.checkout( shoppingBasketId8, clientName8, CREATED, null );
        shoppingBasketRESTHelper.checkout( shoppingBasketId8, null, CONFLICT, null );
    }


    @Test
    public void testCheckout_1_Order() throws Exception {
        // given:
        // Client 0 wants to buy 1x item 9. This is in distribution center 5, 7, and 8. Out of these,
        // distribution center 8 with zip code 89250 is closest to client 0 with zip code 02314.
        Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
            put( distributionCenterId8, map9_quantity_1 );
        }};
        UUID shoppingBasketId0 = shoppingBasketRESTHelper.getQueryShoppingBasket(
                clientEmail0, null );
        int stock9before =
                distributionCenterUseCases.getAvailableStock( distributionCenterId8, itemId9 );

        // when
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId0, itemId9, 1 );
        shoppingBasketRESTHelper.checkout( shoppingBasketId0, clientName0, CREATED, expectedOrders );
        int stock9after =
                distributionCenterUseCases.getAvailableStock( distributionCenterId8, itemId9 );

        // then
        assertEquals( 1, stock9before - stock9after );
    }


    @Test
    public void testCheckout_3_Order() throws Exception {
        // given:
        // Client 8 (Felix Bauer) wants to buy 2x each of items 5, 9, 11; and 7x item 7.
        //       - items 9 and 11 can both be found in distribution centers 7 and 8. Distribution centers 7 (76532) is closer to
        //         the client (70173)
        //       - item 7 is available in distribution centers 1, 2, and 3, but only distribution center 3 has enough stock.
        //       - item 5 is only available in distribution center 0.
        Map<UUID, Map<UUID, Integer>> expectedOrders = new HashMap<>() {{
            put( distributionCenterId0, map5_quantity_2 );
            put( distributionCenterId3, map7_quantity_7 );
            put( distributionCenterId7, map9_11_quantity_2_2 );
        }};
        UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket(
                clientEmail8, null );
        int stock5before =
                distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId5 );
        int stock7before =
                distributionCenterUseCases.getAvailableStock( distributionCenterId3, itemId7 );
        int stock9before =
                distributionCenterUseCases.getAvailableStock( distributionCenterId7, itemId9 );
        int stock11before =
                distributionCenterUseCases.getAvailableStock( distributionCenterId7, itemId11 );

        // when
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId5, 2 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId7, 7 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId9, 2 );
        shoppingBasketRESTHelper.addItemToShoppingBasket( shoppingBasketId8, itemId11, 2 );
        shoppingBasketRESTHelper.checkout( shoppingBasketId8, clientName8, CREATED, expectedOrders );
        int stock5after =
                distributionCenterUseCases.getAvailableStock( distributionCenterId0, itemId5 );
        int stock7after =
                distributionCenterUseCases.getAvailableStock( distributionCenterId3, itemId7 );
        int stock9after =
                distributionCenterUseCases.getAvailableStock( distributionCenterId7, itemId9 );
        int stock11after =
                distributionCenterUseCases.getAvailableStock( distributionCenterId7, itemId11 );

        // then
        assertEquals( 2, stock5before - stock5after );
        assertEquals( 7, stock7before - stock7after );
        assertEquals( 2, stock9before - stock9after );
        assertEquals( 2, stock11before - stock11after );
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingbasket;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.InsufficientStockException;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ItemTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.ClientTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.DistributionCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;


import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;

@SpringBootTest
public class ShoppingBasketTest {
    @Autowired
    private ClientRegistrationUseCases clientRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ItemCatalogUseCases itemCatalogUseCases;
    @Autowired
    private DistributionCenterUseCases distributionCenterUseCases;
    @Autowired
    private OrderUseCases orderUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ClientTestHelper clientTestHelper;
    @Autowired
    private ItemTestHelper itemTestHelper;
    @Autowired
    private DistributionCenterTestHelper distributionCenterTestHelper;

    private EmailType nonExistingEmail;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        clientTestHelper.registerAllClients();
        itemTestHelper.addAllItems();

        nonExistingEmail = instantiateEmail( "this@nononono.de" );
    }


    @Test
    public void testInvalidAddToShoppingBasket() {
        // given
        UUID nonExistentItemId = UUID.randomUUID();
        UUID itemId5 = itemTestHelper.getItemId( 5 );
        UUID itemId0 = itemTestHelper.getItemId( 0 );
        EmailType clientEmail0 =
                clientTestHelper.getClientEmail( 0 );
        distributionCenterTestHelper.addAllDistributionCenters( true );

        // then
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addItemToShoppingBasket(
                        nonExistingEmail, itemId0, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addItemToShoppingBasket(
                        null, itemId0, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addItemToShoppingBasket(
                        clientEmail0, nonExistentItemId, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addItemToShoppingBasket(
                        clientEmail0, null, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addItemToShoppingBasket(
                        clientEmail0, itemId5, -1 ) );
    }


    @Test
    public void testInvalidRemoveFromShoppingBasket() {
        // given
        UUID nonExistentItemId = UUID.randomUUID();
        UUID itemId5 = itemTestHelper.getItemId( 5 );
        UUID itemId1 = itemTestHelper.getItemId( 1 );
        UUID itemId2 = itemTestHelper.getItemId( 2 );
        distributionCenterTestHelper.addAllDistributionCenters( true );
        EmailType clientEmail0 =
                clientTestHelper.getClientEmail( 0 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail0, itemId1, 5 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail0, itemId2, 15 );

        // when
        shoppingBasketUseCases.removeItemFromShoppingBasket(
                clientEmail0, itemId1, 2 );
        shoppingBasketUseCases.removeItemFromShoppingBasket(
                clientEmail0, itemId2, 4 );
        shoppingBasketUseCases.removeItemFromShoppingBasket(
                clientEmail0, itemId2, 7 );
        // now we should have 3x itemId1 and 4x itemId2 in the shopping basket

        // then
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
                        clientEmail0, nonExistentItemId, 12 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
                        nonExistingEmail, itemId5, 12 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
                        clientEmail0, itemId5, -1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
                        clientEmail0, itemId1, 4 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeItemFromShoppingBasket(
                        clientEmail0, itemId2, 5 ) );
    }


    @Test
    public void testAddRemoveItemsFromAndToShoppingBasket() {
        // given
        UUID itemId1 = itemTestHelper.getItemId( 1 );
        UUID itemId2 = itemTestHelper.getItemId( 2 );
        EmailType clientEmail3 =
                clientTestHelper.getClientEmail( 3 );
        EmailType clientEmail5 =
                clientTestHelper.getClientEmail( 5 );

        // when client 3 ...
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail3, itemId1, 2 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail3, itemId2, 3 );
        shoppingBasketUseCases.removeItemFromShoppingBasket(
                clientEmail3, itemId1, 2 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail3, itemId1, 1 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail3, itemId2, 6 );
        Map<UUID, Integer> cart3 = shoppingBasketUseCases.getShoppingBasketAsMap( clientEmail3 );
        // client3 has 1x itemId1 and 9x itemId2 in cart

        // ... and when client 5 ...
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail5, itemId1, 2 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail5, itemId2, 8 );
        shoppingBasketUseCases.removeItemFromShoppingBasket(
                clientEmail5, itemId1, 1 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail5, itemId2, 2 );
        Map<UUID, Integer> cart5 = shoppingBasketUseCases.getShoppingBasketAsMap( clientEmail5 );
        // client5 has 1x itemId1 and 10x itemId2 in cart

        // then
        assertEquals( 2, cart3.size() );
        assertEquals( 1, cart3.get( itemId1 ) );
        assertEquals( 9, cart3.get( itemId2 ) );

        assertEquals( 2, cart5.size() );
        assertEquals( 1, cart5.get( itemId1 ) );
        assertEquals( 10, cart5.get( itemId2 ) );
    }


    @Test
    public void testShoppingBasketValue() {
        // given
        UUID itemId3 = itemTestHelper.getItemId( 3 );
        UUID itemId6 = itemTestHelper.getItemId( 6 );
        UUID itemId8 = itemTestHelper.getItemId( 8 );
        MoneyType price3 = itemTestHelper.getSalesPrice( 3 );
        MoneyType price6 = itemTestHelper.getSalesPrice( 6 );
        MoneyType price8 = itemTestHelper.getSalesPrice( 8 );
        EmailType clientEmail3 =
                clientTestHelper.getClientEmail( 3 );

        // when
        shoppingBasketUseCases.addItemToShoppingBasket( clientEmail3, itemId3, 3 );
        shoppingBasketUseCases.addItemToShoppingBasket( clientEmail3, itemId6, 2 );
        shoppingBasketUseCases.addItemToShoppingBasket( clientEmail3, itemId8, 5 );
        // client3 has 3x itemId3, 2x itemId6 and 5x itemId8 in cart
        MoneyType cartValue = shoppingBasketUseCases.getShoppingBasketAsMoneyValue( clientEmail3 );

        // then
        assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
                cartValue );
    }


    @Test
    public void testShoppingBasketValueInvalid() {
        // given
        // when
        // then
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.getShoppingBasketAsMoneyValue( nonExistingEmail ) );
    }


    @Test
    public void testUnsuccessfulCheckout() {
        // given client buying item 0 (which is not in stock), and client 1 buying item 1
        // in a bigger quantity (11) than available (10)
        distributionCenterTestHelper.addAllDistributionCenters( true );
        EmailType clientEmail0 =
                clientTestHelper.getClientEmail( 0 );
        EmailType clientEmail1 =
                clientTestHelper.getClientEmail( 1 );
        UUID itemId0 = itemTestHelper.getItemId( 0 );
        UUID itemId1 = itemTestHelper.getItemId( 1 );

        // when
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail0, itemId0, 1 );
        shoppingBasketUseCases.addItemToShoppingBasket(
                clientEmail1, itemId1, 11 );

        // then
        assertThrows( InsufficientStockException.class,
                () -> shoppingBasketUseCases.checkout( clientEmail0 ) );
        assertThrows( InsufficientStockException.class,
                () -> shoppingBasketUseCases.checkout( clientEmail1 ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
package thkoeln.archilab.ecommerce.tests.testtests;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.domain.JavaMethod;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.web.bind.annotation.RestController;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingBasketRESTTest;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static org.springframework.test.util.AssertionErrors.assertTrue;

/**
 * This test checks if there are the appropriate tests in the test class(es) for domain
 * primitives.
 */

public class RulesForOwnTests {
    private JavaClass dpTestClass, restTestClass;
    private JavaClasses dpTestClasses, restTestClasses;
    private static final String DISTRIBUTION_CENTER_DOMAIN_PACKAGE =
            "thkoeln.archilab.ecommerce.solution.distributioncenter.domain";
    private static final String DISTRIBUTION_CENTER_CLASS_NAME =
            DISTRIBUTION_CENTER_DOMAIN_PACKAGE + ".DistributionCenter";


    @BeforeEach
    public void setUp() throws Exception {
        dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
        restTestClass = new ClassFileImporter().importClass( OwnShoppingBasketRESTTest.class );

        dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
        restTestClasses = new ClassFileImporter().importClasses( OwnShoppingBasketRESTTest.class );
    }


    @Test
    public void ensureMinimumNumberOfTestMethods() {
        // given
        // when
        int dpTestMethodCount = getTestMethodCount( dpTestClass );
        int restTestMethodCount = getTestMethodCount( restTestClass );

        // then
        assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
                        + dpTestMethodCount,dpTestMethodCount >= 2 );
        assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
                        + restTestMethodCount, restTestMethodCount >= 5 );
    }

    private int getTestMethodCount( JavaClass testClass ) {
        int testMethodCount = 0;
        for ( JavaMethod method : testClass.getMethods() ) {
            if ( isTestMethod( method ) ) {
                testMethodCount++;
            }
        }
        return testMethodCount;
    }

    private boolean isTestMethod( JavaMethod method ) {
        return method.isAnnotatedWith( Test.class );
    }


    @Test
    public void dpTestsShouldReferenceTheRightClasses() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAssignableTo( ZipCodeType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( MoneyType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( PhysicalAddressType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( EmailType.class )
                .because( "DomainPrimitiveJSONSerializationTest should reference ZipCode, " +
                        "Money, Email, and PhysicalAddress!" );
        rule.check( dpTestClasses );
    }


    @Test
    public void restTestsShouldReferenceEmail() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAssignableTo( EmailType.class )
                .because( "DistributionCenterComparatorUnitTest should reference EmailType!" );
        rule.check( restTestClasses );
    }


    @Test
    public void restTestsShouldReferenceRESTControllers() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAnnotatedWith( RestController.class )
                .orShould().dependOnClassesThat()
                .areAssignableTo( ShoppingBasketRESTHelper.class )
                .because( "DistributionCenterComparatorUnitTest should call REST controllers! " +
                        "(either directly or via the ShoppingBasketRESTHelper REST helper)" );
        rule.check( restTestClasses );
    }

}


[RESPONSE]:
Hier sind die gefundenen Code Smells basierend auf den Regeln und dem 4-Layer-Architekturmodell (DDD):

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Email.java ---
[Email.java] [59-60]: [negative conditionals] : Doppelte Negierung durch `!` vor einer Klammer mit mehreren `||` Bedingungen ist schwer lesbar.
[Email.java] [16]: [Duplication] [ZipCode.java] [14] : Identischer Kommentar und Zuweisung für JPA-Platzhalter.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
[Money.java] [29]: [negative conditionals] : Doppelte Negierung durch `!` vor einer Klammer mit ODER-Verknüpfungen.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java ---
[ZipCode.java] [64-85]: [dead code] : Die Methoden `calculateDifference` und `areAdjacent` sind `private` und werden innerhalb der Klasse nicht aufgerufen (die Methode `difference` nutzt eine eigene Logik).

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCodeDTO.java ---
[ZipCodeDTO.java] [3-12]: [Duplication] [EmailDTO.java] [3-12] : Strukturell identische DTO-Klasse (String Wrapper), nur der Variablenname unterscheidet sich minimal.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\Client.java ---
-Anemic Entity-

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\Shoppable.java ---
[Shoppable.java] [10-18]: [dead code] : Abstrakte Klasse, die weder von `Client` noch von `ShoppingBasket` erweitert wird und ungenutzt erscheint.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ShoppableId.java ---
[ShoppableId.java] [11-16]: [dead code] : Id-Klasse für die ungenutzte `Shoppable` Klasse.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ShoppableIdConverter.java ---
[ShoppableIdConverter.java] [7-11]: [dead code] : Converter für die ungenutzte `ShoppableId`.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\application\DistributionCenterService.java ---
[DistributionCenterService.java] [28]: [Shared persistency] : Zugriff auf `ItemRepository` aus dem Package `item`.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\DistributionCenterComparator.java ---
[DistributionCenterComparator.java] [13]: [layer violation] : Domain-Klasse (Comparator) hält Referenz auf ein Repository (`StockLevelRepository`).
[DistributionCenterComparator.java] [13]: [missplaced resonsibility] : Ein Comparator sollte Objekte vergleichen, nicht Datenbankzugriffe über Repositories durchführen. Die Daten sollten vorher geladen werden.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\distributioncenter\domain\StockLevel.java ---
-Anemic Entity-

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\application\AddItemDTO.java ---
[AddItemDTO.java] [5-29]: [Duplication] [ShoppingBasketPositionDTO.java] [5-13] : Strukturell identische DTOs (ItemId und Quantity), `AddItemDTO` hat zusätzlich Setter.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\item\domain\Item.java ---
-Anemic Entity-

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderService.java ---
[OrderService.java] [29]: [Shared persistency] : Zugriff auf `ClientRepository` aus dem Package `client`.
[OrderService.java] [32]: [Shared persistency] : Zugriff auf `DistributionCenterRepository` aus dem Package `distributioncenter`.
[OrderService.java] [35]: [Shared persistency] : Zugriff auf `StockLevelRepository` aus dem Package `distributioncenter`.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java ---
-Anemic Entity-

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPosition.java ---
-Anemic Entity-

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionDTO.java ---
[OrderPositionDTO.java] [5-29]: [Duplication] [ShoppingBasketPositionDTO.java] [5-13] : Strukturell identische DTOs (ItemId und Quantity).

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java ---
[ShoppingBasketController.java] [133-222]: [missplaced resonsibility] : Der Controller enthält massive Geschäftslogik (`checkout`, `findBestDistributionCenter`, `processOrdersAndClearBasket`), die in den Application Service gehört.
[ShoppingBasketController.java] [60]: [layer violation] : Controller greift direkt auf Domain Entities (`Client`, `ShoppingBasket`, `StockLevel`) zu, statt DTOs zu verwenden oder die Logik im Service zu kapseln.
[ShoppingBasketController.java] [187]: [layer violation] : Instanziierung eines Domain-Comparators (`DistributionCenterComparator`) mit Repository-Referenz direkt im Controller.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java ---
[ShoppingBasketService.java] [31]: [Shared persistency] : Zugriff auf `ClientRepository` aus dem Package `client`.
[ShoppingBasketService.java] [34]: [Shared persistency] : Zugriff auf `ItemRepository` aus dem Package `item`.
[ShoppingBasketService.java] [37]: [Shared persistency] : Zugriff auf `OrderRepository` aus dem Package `order`.
[ShoppingBasketService.java] [40]: [Shared persistency] : Zugriff auf `StockLevelRepository` aus dem Package `distributioncenter`.
[ShoppingBasketService.java] [46]: [Shared persistency] : Zugriff auf `DistributionCenterRepository` aus dem Package `distributioncenter`.

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java ---
-Anemic Entity-

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_e163beb1-e3a9-4eec-a8ea-76caefebe948\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java ---
-Anemic Entity-

ENDE
Generated by gemini-3-pro-preview
-----------------------------------