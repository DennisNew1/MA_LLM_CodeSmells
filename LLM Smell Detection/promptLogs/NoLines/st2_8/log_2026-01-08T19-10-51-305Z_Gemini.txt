--- DATE: 8.1.2026, 20:10:51 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
    Architektur: 4-Layer (Eric Evans).
    Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
    Regeln:
    1. Begründe kurz jeden Fund.
    4. Gruppiere nach Datei (mit Pfad). 
    2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
    3. Keine Code-Wiederholung, nur Referenzen.
    5. Wenn fertig, schreibe "ENDE".



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\MailAddress.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.springframework.util.StringUtils;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import javax.persistence.Embeddable;
import java.util.regex.Pattern;
@Getter
@Embeddable
@NoArgsConstructor
public class MailAddress implements MailAddressType {
    public String mailAddressString;

    private MailAddress(String value) {
        this.mailAddressString = value;
    }

    /**
     * @return the mail address as a string
     */
    public String toString() {
        return mailAddressString;
    }

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an mail address, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param mailAddressAsString - the mail address as a string.
     *      We will use a much simplified validation method to check if the mail address is valid:
     *      - it must contain exactly one '@' character.
     *      - the part before the '@' and the part after the '@' must not be empty, contain of
     *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
     *      - the parts before and after the '@' may contain one or several '.' as separators
     *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
     *      - the part after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
     *        (for simplicity we do not allow any other domains)
     * @return a new MailAddressType object matching the given mail address
     * @throws ShopException if ...
     *      - mailAddressAsString is null
     *      - mailAddressAsString is not a valid mail address (see above)
     */
    public static MailAddress of(String mailAddressAsString) {
        if(mailAddressAsString == null || mailAddressAsString == "") throw new ShopException("Invalid!");
        if(!mailAddressAsString.contains("@") || StringUtils.countOccurrencesOf(mailAddressAsString, "@") > 1) throw new ShopException("Invalid!");
        String[] mailAddressSplitByDelimiter = StringUtils.split(mailAddressAsString, "@");
        if(mailAddressSplitByDelimiter.length != 2) throw new ShopException("Invalid!");
        if(mailAddressSplitByDelimiter[0] == null || mailAddressSplitByDelimiter[0] == "") throw new ShopException("Invalid!");
        if(mailAddressSplitByDelimiter[1] == null || mailAddressSplitByDelimiter[1] == "") throw new ShopException("Invalid!");

        // RegEx Validation
        if(!Pattern.compile("^[A-Za-z0-9\\.]+$").matcher(mailAddressSplitByDelimiter[0]).find()) throw new ShopException("Invalid!");
        if(!Pattern.compile("^[A-Za-z0-9\\.]+$").matcher(mailAddressSplitByDelimiter[1]).find()) throw new ShopException("Invalid!");
        if(Pattern.compile("\\s").matcher(mailAddressSplitByDelimiter[0]).find()) throw new ShopException("Invalid!");
        if(Pattern.compile("\\s").matcher(mailAddressSplitByDelimiter[1]).find()) throw new ShopException("Invalid!");
        if(Pattern.compile("(\\.\\.)+").matcher(mailAddressSplitByDelimiter[0]).find()) throw new ShopException("Invalid!");
        if(Pattern.compile("(\\.\\.)+").matcher(mailAddressSplitByDelimiter[1]).find()) throw new ShopException("Invalid!");
        if(!Pattern.compile("(.)+(\\.de|\\.com|\\.at|\\.ch|\\.org)$").matcher(mailAddressSplitByDelimiter[1]).find()) throw new ShopException("Invalid!");

        MailAddress mailAddress = new MailAddress(mailAddressAsString);
        return mailAddress;
    }


    @Override
    public boolean equals(final Object obj) {
        MailAddress otherObj = (MailAddress) obj;
        if(!mailAddressString.equals(otherObj.mailAddressString)) return false;
        return true;
    }
}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
package thkoeln.archilab.ecommerce.domainprimitives;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import javax.persistence.Embeddable;

@Embeddable
@NoArgsConstructor
public class Money implements MoneyType {
    private String currency;
    private Float amount;

    private Money(Float amount, String currency) {
        this.amount = amount;
        this.currency = currency;
    }

    @Override
    public boolean equals(final Object obj) {
        Money otherObj = (Money) obj;
        if(currency.equals(otherObj.getCurrency()) && amount.equals(otherObj.getAmount())) return true;
        return false;
    }

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates a money object from an amount and a currency (as string).
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param amount the amount of money (must be >= 0)
     * @param currency the currency of the money (allowed values: "EUR", "CHF")
     * @return a new Money object with the given amount and currency
     * @throws ShopException if ...
     *   - amount is null
     *   - amount < 0
     *   - currency is null
     *   - currency is not one of the allowed values
     */
    public static MoneyType of(Float amount, String currency) {
        if(amount == null || amount < 0) throw new ShopException("Invalid!");
        if(currency == null) throw new ShopException("Invalid!");
        if(currency != "EUR" && currency != "CHF") throw new ShopException("Invalid!");

        Money money = new Money(amount, currency);
        return money;
    }

    @Override
    public Float getAmount() {
        return amount;
    }

    @Override
    public String getCurrency() {
        return currency;
    }

    /**
     * @param otherMoney
     * @return this + otherMoney, as a new object
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currency != this.currency
     */
    @Override
    public MoneyType add(MoneyType otherMoney) {
        if(otherMoney == null) throw new ShopException("Invalid!");
        if(otherMoney.getCurrency() != this.currency) throw new ShopException("Invalid!");

        MoneyType newObject = Money.of(getAmount() + otherMoney.getAmount(), getCurrency());
        return newObject;
    }

    /**
     * @param otherMoney
     * @return this - otherMoney, as a new object
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currency != this.currency
     *      - otherMoney > this
     */
    @Override
    public MoneyType subtract(MoneyType otherMoney) {
        if(otherMoney == null) throw new ShopException("Invalid!");
        if(otherMoney.getCurrency() != this.currency) throw new ShopException("Invalid!");
        if(otherMoney.getAmount() > getAmount()) throw new ShopException("Invalid!");

        MoneyType newObject = Money.of(getAmount() - otherMoney.getAmount(), getCurrency());
        return newObject;
    }

    /**
     * @param factor
     * @return this * factor, as a new object
     * @throws ShopException if ...
     *     - factor < 0
     */
    @Override
    public MoneyType multiplyBy(int factor) {
        if(factor < 0) throw new ShopException("Invalid!");

        MoneyType newObject = Money.of(getAmount() * factor, getCurrency());
        return newObject;
    }

    /**
     * @param otherMoney
     * @return true, if this > otherMoney
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currency != this.currency
     */
    @Override
    public boolean largerThan(MoneyType otherMoney) {
        if(otherMoney == null || otherMoney.getCurrency() != this.getCurrency()) throw new ShopException("Invalid!");
        boolean result = this.getAmount() > otherMoney.getAmount();
        return result;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PersonalAddress.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

public class PersonalAddress implements PersonalAddressType {
    private String street;
    private String city;
    private PostalCodeType postalCode;

    private PersonalAddress(String street, String city, PostalCodeType postalCode) {
        this.street = street;
        this.city = city;
        this.postalCode = postalCode;
    }

    @Override
    public String getStreet() {
        return this.street;
    }

    @Override
    public String getCity() {
        return this.city;
    }

    @Override
    public PostalCodeType getPostalCode() {
        return this.postalCode;
    }

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an postal code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param street the street as a string
     * @param city the city as a string
     * @param postalCode the postal code
     * @return the personalAddress object matching the parameters
     * @throws ShopException if ...
     *      - street is null or empty
     *      - city is null or empty
     *      - postalCode is null
     */
    public static PersonalAddress of(String street, String city, PostalCodeType postalCode) {
        if(street == null || street == "") throw new ShopException("Invalid!");
        if(city == null || city == "") throw new ShopException("Invalid!");
        if(postalCode == null) throw new ShopException("Invalid!");

        PersonalAddress personalAddress = new PersonalAddress(street, city, postalCode);
        return personalAddress;
    }

    @Override
    public boolean equals(final Object obj) {
        PersonalAddress otherObj = (PersonalAddress) obj;
        if(!street.equals(otherObj.street)) return false;
        if(!city.equals(otherObj.city)) return false;
        if(!postalCode.equals(otherObj.postalCode)) return false;
        return true;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PostalCode.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

import java.util.regex.Pattern;

public class PostalCode implements PostalCodeType {
    private String value;

    private PostalCode(String value)
    {
        this.value = value;
    }

    /**
     * @return the postal code as a string
     */
    public String toString() {
        return this.value;
    }

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an postal code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param postalCodeAsString - the postal code as a string.
     *      We will use a much simplified validation method to check if the postal code is valid:
     *      - It must contain exactly 5 digits.
     *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid postal code, but 20001 is valid)
     * @return a new postal code object matching the given string
     * @throws ShopException if ...
     *      - postalCodeAsString is null
     *      - postalCodeAsString is not a valid postal code (see above)
     */
    public static PostalCodeType of(String postalCodeAsString) {
        if(postalCodeAsString == null) throw new ShopException("Invalid!");
        if(!Pattern.compile("^\\d{5}$").matcher(postalCodeAsString).find()) throw new ShopException("Invalid!");
        if(postalCodeAsString.endsWith("0000")) throw new ShopException("Invalid!");
        PostalCode postalCode = new PostalCode(postalCodeAsString);
        return postalCode;
    }

    @Override
    public boolean equals(final Object obj) {
        PostalCode otherObj = (PostalCode) obj;
        if(!value.equals(otherObj.value)) return false;
        return true;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\UserTypeImplementation.java ---
package thkoeln.archilab.ecommerce.domainprimitives;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;

public class UserTypeImplementation implements UserType {
    private String name;
    private MailAddressType mail;
    private PersonalAddressType address;

    private UserTypeImplementation(String name, MailAddressType mail, PersonalAddressType address) {
        this.name = name;
        this.mail = mail;
        this.address = address;
    }

    public static UserType of(String name, MailAddressType mail, PersonalAddressType address) {
        return new UserTypeImplementation(name, mail, address);
    }

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public MailAddressType getMailAddress() {
        return this.mail;
    }

    @Override
    public PersonalAddressType getPersonalAddress() {
        return this.address;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\masterdata\FactoryMethodInvoker.java ---
package thkoeln.archilab.ecommerce.masterdata;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.Enumeration;

import static org.junit.jupiter.api.Assertions.*;

public class FactoryMethodInvoker {

    public static MailAddressType instantiateMailAddress( String mailAddressAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for MailAddressType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, mailAddressAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + mailAddressAsString + "'", e );
        }
        assertNotNull( instance );
        return (MailAddressType) instance;
    }


    public static PersonalAddressType instantiatePersonalAddress(
            String street, String city, PostalCodeType postalCode ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of",
                    String.class, String.class, PostalCodeType.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for PersonalAddressType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, street, city, postalCode );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" +
                    street + "', '" + city + "', '" + postalCode + "'", e );
        }
        assertNotNull( instance );
        return (PersonalAddressType) instance;
    }


    public static PostalCodeType instantiatePostalCode( String postalCodeAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for PostalCodeType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, postalCodeAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + postalCodeAsString + "'", e );
        }
        assertNotNull( instance );
        return (PostalCodeType) instance;
    }


    public static MoneyType instantiateMoney( Float amount, String currency ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for MoneyType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, amount, currency );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + amount + "', '" + currency + "'", e );
        }
        assertNotNull( instance );
        return (MoneyType) instance;
    }


    private static Class<?> findImplementation( Class<?> interfaceClass ) {
        Method factoryMethod = null;
        try {
            String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
            Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
            assertNotNull( implementingClass );
            return implementingClass;
        } catch (Exception e) {
            fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
            return null; // This line will never be reached, but it's necessary to satisfy the compiler
        }
    }


    private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
            throws ClassNotFoundException, IOException {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        String path = packageName.replace( '.', '/' );
        Enumeration<URL> resources = classLoader.getResources( path );
        int count = 0;
        Class<?> result = null;
        while (resources.hasMoreElements()) {
            URL resource = resources.nextElement();
            File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
            File[] files = directory.listFiles();
            for ( File file : files ) {
                if ( file.getName().endsWith( ".class" ) ) {
                    String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
                    Class<?> clazz = Class.forName( className );
                    if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
                        count++;
                        result = clazz;
                    }
                }
            }
        }
        assertEquals( 1, count, "There should be exactly one implementing class" );
        return result;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\masterdata\InitialMasterDataCreator.java ---
package thkoeln.archilab.ecommerce.masterdata;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.UUID;


/**
 * This class is used to create the initial master data for the application. This includes
 * users and products. It is executed on application startup, and is used for testing purposes.
 */
@Component
@SuppressWarnings("PMD")
public class InitialMasterDataCreator {

    public final static String[] USER_NAME = new String[]{
            "Max Müller",
            "Sophie Schmitz",
            "Irene Mihalic",
            "Emilia Fischer",
            "Filiz Polat",
            "Lina Wagner",
            "Leon Becker",
            "Agnieszka Kalterer",
            "Felix Bauer",
            "Lara Schulz"
    };
    public final static MailAddressType[] USER_EMAIL = new MailAddressType[] {
            FactoryMethodInvoker.instantiateMailAddress( "max.mueller@example.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "sophie.schmitz@example.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "irene@wearefreedomnow.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "emilia.fischer@example.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "j877d3@gmail.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "lina.wagner@example.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "leon.becker@example.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "agna@here.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "felix.bauer@example.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "lara.schulz@example.com" )
    };

    public final static PersonalAddressType[] USER_ADDRESS = new PersonalAddressType[] {
            FactoryMethodInvoker.instantiatePersonalAddress(
                    "Hauptstraße 1", "Berlin",
                    FactoryMethodInvoker.instantiatePostalCode( "10115" ) ),
            FactoryMethodInvoker.instantiatePersonalAddress(
                    "Bahnhofstraße 12", "München",
                    FactoryMethodInvoker.instantiatePostalCode( "80331" ) ),
            FactoryMethodInvoker.instantiatePersonalAddress(
                    "Kirchplatz 3", "Hamburg",
                    FactoryMethodInvoker.instantiatePostalCode( "20095" ) ),
            FactoryMethodInvoker.instantiatePersonalAddress(
                    "Goethestraße 7", "Frankfurt am Main",
                    FactoryMethodInvoker.instantiatePostalCode( "60311" ) ),
            FactoryMethodInvoker.instantiatePersonalAddress(
                    "Mühlenweg 15", "Köln",
                    FactoryMethodInvoker.instantiatePostalCode( "50667" ) ),
            FactoryMethodInvoker.instantiatePersonalAddress(
                    "Schulstraße 9", "Düsseldorf",
                    FactoryMethodInvoker.instantiatePostalCode( "40213" ) ),
            FactoryMethodInvoker.instantiatePersonalAddress(
                    "Dorfstraße 21", "Stuttgart",
                    FactoryMethodInvoker.instantiatePostalCode( "70173" ) ),
            FactoryMethodInvoker.instantiatePersonalAddress(
                    "Marktstraße 5", "Leipzig",
                    FactoryMethodInvoker.instantiatePostalCode( "04109" ) ),
            FactoryMethodInvoker.instantiatePersonalAddress(
                    "Rosenweg 14", "Dortmund",
                    FactoryMethodInvoker.instantiatePostalCode( "44135" ) ),
            FactoryMethodInvoker.instantiatePersonalAddress(
                    "Wiesenstraße 6", "Essen",
                    FactoryMethodInvoker.instantiatePostalCode( "45127" ) )
    };

    public final static UserType[] mockUsers;

    public static final String EUR = "EUR";

    public static final Object[][] PRODUCT_DATA = new Object[][]{
            {UUID.randomUUID(), "TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
                    1.5f, FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 10.0f, EUR )},
            {UUID.randomUUID(), "EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
                    0.3f, FactoryMethodInvoker.instantiateMoney( 2.5f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 4.0f, EUR )},
            {UUID.randomUUID(), "MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
                    7.2f, FactoryMethodInvoker.instantiateMoney( 50.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 80.0f, EUR )},
            {UUID.randomUUID(), "Gh-25", "Kompakter und leichter Akku für mobile Geräte",
                    null, FactoryMethodInvoker.instantiateMoney( 6.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 8.0f, EUR )},
            {UUID.randomUUID(), "MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
                    null, FactoryMethodInvoker.instantiateMoney( 0.6f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 1.0f, EUR )},
            {UUID.randomUUID(), "ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
                    1.0f, FactoryMethodInvoker.instantiateMoney( 150.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 250.0f, EUR )},
            {UUID.randomUUID(), "Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
                    null, FactoryMethodInvoker.instantiateMoney( 0.3f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 0.5f, EUR )},
            {UUID.randomUUID(), "Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
                    6.0f, FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 120.0f, EUR )},
            {UUID.randomUUID(), "JKL-67", "Wasserdichtes Gehäuse",
                    3.0f, FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 1.2f, EUR )},
            {UUID.randomUUID(), "MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
                    5.5f, FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 45.0f, EUR )},
            {UUID.randomUUID(), "PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
                    4.0f, FactoryMethodInvoker.instantiateMoney( 20.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 35.0f, EUR )},
            {UUID.randomUUID(), "STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
                    null, FactoryMethodInvoker.instantiateMoney( 200.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 350.0f, EUR )},
            {UUID.randomUUID(), "VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
                    null, FactoryMethodInvoker.instantiateMoney( 15.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 25.0f, EUR )},
            {UUID.randomUUID(), "YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
                    3.5f, FactoryMethodInvoker.instantiateMoney( 60.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 100.0f, EUR )}
    };

    private UserRegistrationUseCases userRegistrationUseCases;
    private ProductCatalogUseCases productCatalogUseCases;
    private InventoryManagementUseCases inventoryManagementUseCases;
    private ShoppingBasketUseCases shoppingBasketUseCases;


    // product 0 is out of inventory, product 1 and 2 have fixed quantities of 10 and 20, respectively, and the
    // others have a random inventory between 5 and 100
    public static final Map<UUID, Integer> PRODUCT_INVENTORY = new HashMap<>();

    static {
        mockUsers = new UserType[USER_NAME.length];
        for ( int i = 0; i < USER_NAME.length; i++ ) {
            mockUsers[i] = new MockUser(
                    USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i]);
        }
        Random random = new Random();
        for ( Object[] productData : PRODUCT_DATA ) {
            PRODUCT_INVENTORY.put( (UUID) productData[0], random.nextInt( 100 ) + 20 );
        }
        PRODUCT_INVENTORY.put( (UUID) PRODUCT_DATA[0][0], 0 );
        PRODUCT_INVENTORY.put( (UUID) PRODUCT_DATA[1][0], 10 );
        PRODUCT_INVENTORY.put( (UUID) PRODUCT_DATA[2][0], 20 );
        PRODUCT_INVENTORY.put( (UUID) PRODUCT_DATA[3][0], 30 );

    }


    public enum InvalidReason {
        NULL, EMPTY;

        public Object getInvalidValue( Object originalValue ) {
            switch (this) {
                case NULL:
                    return null;
                case EMPTY:
                    return "";
                default:
                    return null;
            }
        }
    }


    @Autowired
    public InitialMasterDataCreator(
            UserRegistrationUseCases userRegistrationUseCases,
            ProductCatalogUseCases productCatalogUseCases,
            InventoryManagementUseCases inventoryManagementUseCases,
            ShoppingBasketUseCases shoppingBasketUseCases ) {
        this.userRegistrationUseCases = userRegistrationUseCases;
        this.productCatalogUseCases = productCatalogUseCases;
        this.inventoryManagementUseCases = inventoryManagementUseCases;
        this.shoppingBasketUseCases = shoppingBasketUseCases;
    }


    public void deleteAll() {
        shoppingBasketUseCases.deleteAllOrders();
        productCatalogUseCases.deleteProductCatalog();
        userRegistrationUseCases.deleteAllUsers();
    }


    public void registerAllUsers() {
        for ( int i = 0; i < InitialMasterDataCreator.USER_NAME.length; i++ ) {
            registerUser( InitialMasterDataCreator.USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
        }
    }


    public void registerUser( String name, MailAddressType mailAddress, PersonalAddressType personalAddress ) {
        userRegistrationUseCases.register( name, mailAddress, personalAddress );
    }

    public void addAllProducts() {
        for ( Object[] productData : PRODUCT_DATA ) {
            addProductDataToCatalog( productData );
        }
    }

    public void addProductDataToCatalog( Object[] productData ) {
        productCatalogUseCases.addProductToCatalog( (UUID) productData[0], (String) productData[1], (String) productData[2],
                (Float) productData[3], (MoneyType) productData[4], (MoneyType) productData[5] );
    }


    public Object[] getProductDataInvalidAtIndex( int index, InvalidReason reason ) {
        Object[] productData = PRODUCT_DATA[1];
        Object[] productDataInvalid = new Object[productData.length];
        System.arraycopy( productData, 0, productDataInvalid, 0, productData.length );
        productDataInvalid[index] = productData[index].getClass().cast(
                reason.getInvalidValue( productData[index] ) );
        return productDataInvalid;
    }


    public void inventoryUpAllProducts() {
        for ( Object[] productData : PRODUCT_DATA ) {
            if ( PRODUCT_INVENTORY.get( productData[0] ) > 0 )
                inventoryManagementUseCases.addToInventory( (UUID) productData[0], PRODUCT_INVENTORY.get( productData[0] ) );
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\masterdata\MockUser.java ---
package thkoeln.archilab.ecommerce.masterdata;

import lombok.Setter;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;

import java.util.Objects;

@Setter
public class MockUser implements UserType {
    private String name;
    private MailAddressType mailAddress;
    private PersonalAddressType personalAddress;


    public MockUser( String name, MailAddressType mailAddress, PersonalAddressType personalAddress) {
        this.name = name;
        this.mailAddress = mailAddress;
        this.personalAddress = personalAddress;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public MailAddressType getMailAddress() {
        return mailAddress;
    }

    @Override
    public PersonalAddressType getPersonalAddress() {
        return personalAddress;
    }

    @Override
    public boolean equals( Object o ) {
        if ( this == o ) return true;
        if ( !( o instanceof MockUser ) ) return false;
        MockUser that = (MockUser) o;
        return Objects.equals( getName(), that.getName() ) && Objects.equals( mailAddress, that.mailAddress ) && Objects.equals( personalAddress, that.personalAddress );
    }

    @Override
    public int hashCode() {
        return Objects.hash( getName(), mailAddress, personalAddress );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\masterdata\StartupListener.java ---
package thkoeln.archilab.ecommerce.masterdata;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;

@Component
@Profile("!test")
public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
    private Logger logger = LoggerFactory.getLogger( StartupListener.class );

    private InitialMasterDataCreator initialMasterDataCreator;

    @Autowired
    public StartupListener( InitialMasterDataCreator initialMasterDataCreator ) {
        this.initialMasterDataCreator = initialMasterDataCreator;
    }

    @Override
    public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
        logger.info( "Initializing master data..." );
        initialMasterDataCreator.registerAllUsers();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
package thkoeln.archilab.ecommerce;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class ProjectApplication {

	/**
	 * Entry method
	 * @param args
	 */
	public static void main(String[] args) {
		SpringApplication.run(ProjectApplication.class, args);
	}
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
package thkoeln.archilab.ecommerce;

public class ShopException extends RuntimeException {
    public ShopException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\address\domain\Address.java ---
package thkoeln.archilab.ecommerce.solution.address.domain;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import javax.persistence.Entity;
import javax.persistence.Id;
import java.util.UUID;

@Getter
@Setter
@Entity
@NoArgsConstructor
public class Address {
    @Id
    private final UUID id = UUID.randomUUID();
    private String street;
    private String city;
    private String postalCode;

    public Address(String street, String city, String postalCode) {
        this.street = street;
        this.city = city;
        this.postalCode = postalCode;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\application\DeliveryService.java ---
package thkoeln.archilab.ecommerce.solution.delivery.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.delivery.domain.Delivery;
import thkoeln.archilab.ecommerce.solution.delivery.domain.DeliveryPosition;
import thkoeln.archilab.ecommerce.solution.delivery.domain.DeliveryRepository;
import thkoeln.archilab.ecommerce.solution.product.application.ProductUserService;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
import thkoeln.archilab.ecommerce.usecases.DeliveryUseCases;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Service
public class DeliveryService implements DeliveryUseCases {

    @Autowired
    public DeliveryRepository deliveries;
    @Autowired
    public ProductRepository products;
    @Autowired
    public ProductUserService users;

    /**
     * Delivers a product to a user. The product is identified by its id, and the user by
     * his/her name, street, city and postal code.
     * @param deliveryRecipient
     * @param deliveryContent - a map of product ids and quantities
     * @return the id of the delivery, if successfully triggered
     * @throws ShopException if ...
     *      - deliveryRecipient is null
     *      - any of the properties in deliveryRecipient (the getXxx(...) methods) return null or empty strings
     *      - deliveryContent is null or empty
     *      - the total number of products in the delivery is > 20
     */
    @Override
    public UUID triggerDelivery(UserType deliveryRecipient, Map<UUID, Integer> deliveryContent) {
        if(deliveryRecipient == null) throw new ShopException("Delivery Recipient is null");
        if(deliveryRecipient.getPersonalAddress().getCity() == null || deliveryRecipient.getPersonalAddress().getCity()== "") throw new ShopException("City is null or empty!");
        if(deliveryRecipient.getMailAddress() == null || deliveryRecipient.getMailAddress().toString() == "") throw new ShopException("Mail Address is null or empty!");
        if(deliveryRecipient.getName() == null || deliveryRecipient.getName() == "") throw new ShopException("Name is null or empty!");
        if(deliveryRecipient.getPersonalAddress().getStreet() == null || deliveryRecipient.getPersonalAddress().getStreet() == "") throw new ShopException("Street is null or empty!");
        if(deliveryRecipient.getPersonalAddress().getPostalCode() == null || deliveryRecipient.getPersonalAddress().getPostalCode().toString() == "") throw new ShopException("Postal Code is null or empty!");
        if(deliveryContent == null || deliveryContent.isEmpty()) throw new ShopException("Delivery Content is null or empty!");

        int deliverySum = 0;
        for (int d: deliveryContent.values()) {
            deliverySum += d;
        }

        if(deliverySum > 20) throw new ShopException("Delivery Content is > 20!");

        ArrayList<DeliveryPosition> deliveryPositions = new ArrayList<DeliveryPosition>();
        for (UUID productId: deliveryContent.keySet()) {
            deliveryPositions.add(new DeliveryPosition(products.findById(productId).get(), deliveryContent.get(productId)));
        }

        Delivery delivery = new Delivery(deliveryRecipient.getMailAddress(), deliveryRecipient.getPersonalAddress().getStreet(),
                deliveryRecipient.getPersonalAddress().getCity(), deliveryRecipient.getPersonalAddress().getPostalCode().toString(), deliveryRecipient.getName(), deliveryPositions);

        deliveries.save(delivery);
        return delivery.getId();
    }

    /**
     * Returns a map showing which products have been delivered to a user, and how many of each product
     *
     * @param userMailAddress
     * @return the delivery history of the user (map is empty if the user has not had any deliveries yet)
     * @throws ShopException if
     *      - the mail address is null or empty
     *      - the user with the given mail address does not exist
     */
    @Override
    public Map<UUID, Integer> getDeliveryHistory(MailAddressType userMailAddress) {
        if(userMailAddress == null || userMailAddress.toString() == "") throw new ShopException("Mail is null or empty!");
        if(!users.existsByMailAddress(userMailAddress)) throw new ShopException("User does not exist!");

        HashMap<UUID, Integer> result = new HashMap();
        for (Delivery delivery: deliveries.findAll()) {
            if(delivery.getMailAddress().toString() == userMailAddress.toString()) {
                for (DeliveryPosition position: delivery.getData()) {
                    if(!result.containsKey(position.getUuid())) result.put(position.getUuid(), 0);
                    result.put(position.getUuid(), result.get(position.getUuid()) + position.getQuantity());
                }
            }
        }
        return result;
    }

    /**
     *  Deletes all delivery history.
     */
    @Override
    public void deleteDeliveryHistory() {
        deliveries.deleteAll();
        products.deleteAll();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\Delivery.java ---
package thkoeln.archilab.ecommerce.solution.delivery.domain;

import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import javax.persistence.Embedded;
import javax.persistence.Entity;
import javax.persistence.Id;
import java.util.*;

@Getter @Setter
@Entity
public class Delivery {
    @Id
    private final UUID id = UUID.randomUUID();
    @Embedded
    private final MailAddress mailAddress;
    private String street;
    private String city;
    private String postalCode;
    private String name;

    private ArrayList<DeliveryPosition> data = new ArrayList();

    private Delivery() { this.mailAddress = null; }

    public Delivery(MailAddressType mailAddress, String street, String city, String postalCode, String name, ArrayList<DeliveryPosition> data) {
        this.mailAddress = MailAddress.of(mailAddress.toString());
        this.street = street;
        this.city = city;
        this.postalCode = postalCode;
        this.name = name;
        this.data = data;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\DeliveryPosition.java ---
package thkoeln.archilab.ecommerce.solution.delivery.domain;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import java.util.UUID;

@Getter @Setter
@NoArgsConstructor
@Entity
public class DeliveryPosition {
    @Id
    private final UUID uuid = UUID.randomUUID();
    @ManyToOne
    private Product product;
    private int quantity;

    public DeliveryPosition(Product product, int quantity) {
        this.product = product;
        this.quantity = quantity;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\DeliveryRepository.java ---
package thkoeln.archilab.ecommerce.solution.delivery.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Optional;
import java.util.UUID;

@Repository
public class DeliveryRepository implements CrudRepository<Delivery, UUID> {

    public HashMap<UUID, Delivery> deliveries = new HashMap();

    @Override
    public <S extends Delivery> S save(S s) {
        deliveries.put(s.getId(), s);
        return s;
    }

    @Override
    public <S extends Delivery> Iterable<S> saveAll(Iterable<S> iterable) {
        for (S delivery: iterable) {
            deliveries.put(delivery.getId(), delivery);
        }
        return iterable;
    }

    @Override
    public Optional<Delivery> findById(UUID s) {
        return Optional.ofNullable(deliveries.get(s));
    }

    @Override
    public boolean existsById(UUID s) {
        return deliveries.containsKey(s);
    }

    @Override
    public Iterable<Delivery> findAll() {
        return deliveries.values();
    }

    @Override
    public Iterable<Delivery> findAllById(Iterable<UUID> iterable) {
        ArrayList<Delivery> data = new ArrayList<Delivery>();
        for (UUID mail: iterable) {
            if(existsById(mail)) data.add(deliveries.get(mail));
        }
        return data;
    }

    @Override
    public long count() {
        return deliveries.size();
    }

    @Override
    public void deleteById(UUID s) {
        if(existsById(s)) deliveries.remove(s);
    }

    @Override
    public void delete(Delivery delivery) {
        deleteById(delivery.getId());
    }

    @Override
    public void deleteAll(Iterable<? extends Delivery> iterable) {
        for (Delivery delivery: iterable) {
            deleteById(delivery.getId());
        }
    }

    @Override
    public void deleteAll() {
        deliveries.clear();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\dtos\OrderDto.java ---
package thkoeln.archilab.ecommerce.solution.dtos;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Getter;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.Money;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.UUID;

@Getter
public class OrderDto {
    @JsonProperty
    private UUID id;
    @JsonProperty
    private MailAddress mailAddress;
    @JsonProperty
    private Money price;
    @JsonProperty
    private OrderPositionDto[] orderPositions;
    @JsonProperty
    private LocalDateTime submissionDate;

    public OrderDto(UUID id, MailAddress mailAddress, Money price, ArrayList<OrderPositionDto> positions, LocalDateTime submissionDate) {
        this.id  = id;
        this.mailAddress = mailAddress;
        this.price = price;

        this.orderPositions = new OrderPositionDto[positions.size()];
        this.orderPositions = positions.toArray(this.orderPositions);
        this.submissionDate = submissionDate;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\dtos\OrderPositionDto.java ---
package thkoeln.archilab.ecommerce.solution.dtos;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Getter;

import java.util.Locale;
import java.util.UUID;

@Getter
public class OrderPositionDto {
    @JsonProperty
    private String productId;
    @JsonProperty
    private int quantity;
    @JsonProperty
    private String comment;

    public OrderPositionDto(UUID productId, int quantity, String comment) {
        this.productId = productId.toString().toLowerCase(Locale.ROOT);
        this.quantity = quantity;
        this.comment = comment;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\dtos\ShoppingBasketDto.java ---
package thkoeln.archilab.ecommerce.solution.dtos;

import lombok.Getter;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;

import java.util.UUID;

@Getter
public class ShoppingBasketDto {
    private UUID id;
    private MailAddress mailAddress;
    private int totalQuantity;

    public ShoppingBasketDto(UUID id, MailAddress mailAddress, int totalQuantity) {
        this.id  = id;
        this.mailAddress = mailAddress;
        this.totalQuantity = totalQuantity;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\dtos\ShoppingBasketPositionDto.java ---
package thkoeln.archilab.ecommerce.solution.dtos;

import lombok.Getter;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;

import java.util.UUID;

@Getter
public class ShoppingBasketPositionDto {
    private UUID productId;
    private int quantity;
    private String comment;

    public ShoppingBasketPositionDto(UUID productId, int quantity, String comment) {
        this.productId  = productId;
        this.quantity = quantity;
        this.comment = comment;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderController.java ---
package thkoeln.archilab.ecommerce.solution.order.application;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import thkoeln.archilab.ecommerce.solution.dtos.OrderDto;
import thkoeln.archilab.ecommerce.solution.dtos.OrderPositionDto;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderPositionRepository;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.stream.StreamSupport;

@RestController
public class OrderController {

    private final OrderRepository orders;
    private final OrderPositionRepository orderPositions;
    private final UserRepository users;

    public OrderController(OrderRepository orders, OrderPositionRepository orderPositions, UserRepository users) {
        this.orders = orders;
        this.orderPositions = orderPositions;
        this.users = users;
    }


    //Find all orders for user with mailAddressId, ordered by time
    @GetMapping("/orders")
    OrderDto[] findOrdersByMailAddress(@RequestParam(required = false) String mailAddress,
                                           @RequestParam(required = false) String filter) {

        ArrayList<OrderDto> result = new ArrayList();
        if(!users.existsById(mailAddress)) return (OrderDto[]) new OrderDto[0];

        StreamSupport.stream(orders.findAll().spliterator(), false)
        .filter(e -> e.getMailAddress().toString().equals(mailAddress))
        .forEach(order -> {
                ArrayList<OrderPositionDto> positions = new ArrayList();
                StreamSupport.stream(orderPositions.findAll().spliterator(), false)
                    .filter(e -> e.getOrder().getId().equals(order.getId()))
                    .sorted(Comparator.comparing(OrderPosition::getCreatedDate))
                    .forEach(pos -> {
                        positions.add(new OrderPositionDto(pos.getProduct().getId(), pos.getQuantity(), pos.getComment()));
                    });
            result.add(new OrderDto(order.getId(), order.getMailAddress(), order.getPrice(), positions, order.getSubmissionDate()));
        });

        Comparator<OrderDto> c = Comparator.comparing(OrderDto::getSubmissionDate);
        result.sort(c);

        if(filter != null && filter.equals("latest")) {
            result.sort(Comparator.comparing(OrderDto::getSubmissionDate, Comparator.reverseOrder()));
            var latestOrder = result.stream().findFirst().get();
            result.clear();
            result.add(latestOrder);
        }

        OrderDto[] arr = new OrderDto[result.size()];
        arr = result.toArray(arr);
        return arr;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import javax.persistence.Embedded;
import javax.persistence.Entity;
import javax.persistence.Id;
import java.time.LocalDateTime;
import java.util.UUID;

@Getter @Setter
@Entity
public class Order {
    @Id
    private final UUID id = UUID.randomUUID();
    @Embedded
    private final MailAddress mailAddress;
    @Embedded
    private Money price;
    private LocalDateTime submissionDate;

    private Order() { this.mailAddress = null; }

    public Order(MailAddressType mailAddress, MoneyType price) {
        this.mailAddress = MailAddress.of(mailAddress.toString());
        this.submissionDate = LocalDateTime.now();
        this.price = (Money)Money.of(price.getAmount(), price.getCurrency());
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPosition.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import java.time.LocalDateTime;
import java.util.UUID;

@Getter @Setter
@NoArgsConstructor
@Entity
public class OrderPosition {
    @Id
    private final UUID uuid = UUID.randomUUID();
    @ManyToOne
    private Product product;
    @ManyToOne
    private Order order;
    private String comment;
    private int quantity;
    private final LocalDateTime createdDate = LocalDateTime.now();

    public OrderPosition(Order order, Product product, int quantity, String comment) {
        this.order = order;
        this.product = product;
        this.quantity = quantity;
        this.comment = comment;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPositionRepository.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Optional;
import java.util.UUID;

@Repository
public class OrderPositionRepository implements CrudRepository<OrderPosition, UUID> {

    public HashMap<UUID, OrderPosition> orderPositions = new HashMap();

    @Override
    public <S extends OrderPosition> S save(S s) {
        orderPositions.put(s.getUuid(), s);
        return s;
    }

    @Override
    public <S extends OrderPosition> Iterable<S> saveAll(Iterable<S> iterable) {
        for (S orderPosition: iterable) {
            orderPositions.put(orderPosition.getUuid(), orderPosition);
        }
        return iterable;
    }

    @Override
    public Optional<OrderPosition> findById(UUID s) {
        return Optional.ofNullable(orderPositions.get(s));
    }

    @Override
    public boolean existsById(UUID s) {
        return orderPositions.containsKey(s);
    }

    @Override
    public Iterable<OrderPosition> findAll() {
        return orderPositions.values();
    }

    @Override
    public Iterable<OrderPosition> findAllById(Iterable<UUID> iterable) {
        ArrayList<OrderPosition> data = new ArrayList<OrderPosition>();
        for (UUID mail: iterable) {
            if(existsById(mail)) data.add(orderPositions.get(mail));
        }
        return data;
    }

    @Override
    public long count() {
        return orderPositions.size();
    }

    @Override
    public void deleteById(UUID s) {
        if(existsById(s)) orderPositions.remove(s);
    }

    @Override
    public void delete(OrderPosition orderPosition) {
        deleteById(orderPosition.getUuid());
    }

    @Override
    public void deleteAll(Iterable<? extends OrderPosition> iterable) {
        for (OrderPosition orderPosition: iterable) {
            deleteById(orderPosition.getUuid());
        }
    }

    @Override
    public void deleteAll() {
        orderPositions.clear();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderRepository.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Optional;
import java.util.UUID;

@Repository
public class OrderRepository implements CrudRepository<Order, UUID> {

    public HashMap<UUID, Order> orders = new HashMap();

    @Override
    public <S extends Order> S save(S s) {
        orders.put(s.getId(), s);
        return s;
    }

    @Override
    public <S extends Order> Iterable<S> saveAll(Iterable<S> iterable) {
        for (S order: iterable) {
            orders.put(order.getId(), order);
        }
        return iterable;
    }

    @Override
    public Optional<Order> findById(UUID s) {
        return Optional.ofNullable(orders.get(s));
    }

    @Override
    public boolean existsById(UUID s) {
        return orders.containsKey(s);
    }

    @Override
    public Iterable<Order> findAll() {
        return orders.values();
    }

    @Override
    public Iterable<Order> findAllById(Iterable<UUID> iterable) {
        ArrayList<Order> data = new ArrayList<Order>();
        for (UUID mail: iterable) {
            if(existsById(mail)) data.add(orders.get(mail));
        }
        return data;
    }

    @Override
    public long count() {
        return orders.size();
    }

    @Override
    public void deleteById(UUID s) {
        if(existsById(s)) orders.remove(s);
    }

    @Override
    public void delete(Order order) {
        deleteById(order.getId());
    }

    @Override
    public void deleteAll(Iterable<? extends Order> iterable) {
        for (Order order: iterable) {
            deleteById(order.getId());
        }
    }

    @Override
    public void deleteAll() {
        orders.clear();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\payment\application\PaymentService.java ---
package thkoeln.archilab.ecommerce.solution.payment.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.product.application.ProductUserService;
import thkoeln.archilab.ecommerce.solution.payment.domain.Payment;
import thkoeln.archilab.ecommerce.solution.payment.domain.PaymentRepository;
import thkoeln.archilab.ecommerce.usecases.PaymentUseCases;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;

@Service
public class PaymentService implements PaymentUseCases {

    @Autowired
    private ProductUserService users;
    @Autowired
    private PaymentRepository payments;

    /**
     * Authorizes a payment for a user (identified by his/her mail address) for a given amount
     * @param userMailAddress
     * @param amount
     * @return the id of the payment, if successfully authorized
     * @throws ShopException if ...
     *      - userMailAddress is null or empty
     *      - the user with the given mail address does not exist
     *      - the amount is <= 0.00 EUR
     *      - the payment cannot be processed, because it is over the limit of 500.00 EUR
     */
    @Override
    public UUID authorizePayment( MailAddressType userMailAddress, MoneyType amount ) {
        if(userMailAddress == null || userMailAddress.toString() == "") throw new ShopException("User Mail Address is null or empty!");
        if(!users.existsByMailAddress(userMailAddress)) throw new ShopException("User does not exist!");
        if(amount == null || amount.getAmount() <= 0) throw new ShopException("Amount cannot be <= 0!");
        if(amount.getAmount() > 500) throw new ShopException("Amount cannot be > 500!");

        // Save payment in repo
        Payment payment = new Payment(userMailAddress.toString(), amount.getAmount());
        payments.save(payment);
        return payment.getId();
    }

    /**
     * Returns the total amount of payments (over the complete history) for a user
     * (identified by his/her mail address)
     * @param userMailAddress
     * @return the total amount of payments for the user with the given mailAddress,
     *         or 0.00 EUR if the user has not made any payments yet.
     * @throws ShopException if ...
     *      - userMailAddress is null or empty
     *      - the user with the given mailAddress does not exist
     */
    @Override
    public MoneyType getPaymentTotal(MailAddressType userMailAddress) {
        if(userMailAddress == null || userMailAddress.toString() == "") throw new ShopException("User Mail Address is null or empty!");
        if(!users.existsByMailAddress(userMailAddress)) throw new ShopException("User does not exist!");

        Float sum = 0f;
        for (Payment payment: payments.findAll()) {
            if(payment.getMailAddress() == userMailAddress.toString()) sum += payment.getAmount();
        }
        return Money.of(sum, "EUR");
    }

    /**
     * Deletes all payment history, for all users.
     */
    @Override
    public void deletePaymentHistory() {
        payments.deleteAll();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\payment\domain\Payment.java ---
package thkoeln.archilab.ecommerce.solution.payment.domain;

import lombok.Getter;
import lombok.Setter;

import javax.persistence.Id;
import java.util.UUID;

@Getter @Setter
public class Payment {
    @Id
    private final UUID id = UUID.randomUUID();
    private String mailAddress;
    private Float amount;

    public Payment(String mailAddress, Float amount) {
        this.mailAddress = mailAddress;
        this.amount = amount;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\payment\domain\PaymentRepository.java ---
package thkoeln.archilab.ecommerce.solution.payment.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Optional;
import java.util.UUID;

@Repository
public class PaymentRepository implements CrudRepository<Payment, UUID> {

    public HashMap<UUID, Payment> payments = new HashMap();

    @Override
    public <S extends Payment> S save(S s) {
        payments.put(s.getId(), s);
        return s;
    }

    @Override
    public <S extends Payment> Iterable<S> saveAll(Iterable<S> iterable) {
        for (S payment: iterable) {
            payments.put(payment.getId(), payment);
        }
        return iterable;
    }

    @Override
    public Optional<Payment> findById(UUID s) {
        return Optional.ofNullable(payments.get(s));
    }

    @Override
    public boolean existsById(UUID s) {
        return payments.containsKey(s);
    }

    @Override
    public Iterable<Payment> findAll() {
        return payments.values();
    }

    @Override
    public Iterable<Payment> findAllById(Iterable<UUID> iterable) {
        ArrayList<Payment> data = new ArrayList<Payment>();
        for (UUID mail: iterable) {
            if(existsById(mail)) data.add(payments.get(mail));
        }
        return data;
    }

    @Override
    public long count() {
        return payments.size();
    }

    @Override
    public void deleteById(UUID s) {
        if(existsById(s)) payments.remove(s);
    }

    @Override
    public void delete(Payment payment) {
        deleteById(payment.getId());
    }

    @Override
    public void deleteAll(Iterable<? extends Payment> iterable) {
        for (Payment payment: iterable) {
            deleteById(payment.getId());
        }
    }

    @Override
    public void deleteAll() {
        payments.clear();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\InventoryService.java ---
package thkoeln.archilab.ecommerce.solution.product.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
import thkoeln.archilab.ecommerce.usecases.InventoryManagementUseCases;
import thkoeln.archilab.ecommerce.ShopException;

import java.util.Hashtable;
import java.util.UUID;

@Service
public class InventoryService implements InventoryManagementUseCases {

    public Hashtable<UUID, Integer> inventory = new Hashtable();

    @Autowired
    private ProductRepository products;
    @Autowired
    private ProductConsumerService consumer;

    @Override
    public void addToInventory(UUID productId, int addedQuantity) {
        if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
        if(addedQuantity <= 0) throw new ShopException("Quantity can't be null or negative!");

        if(inventory.get(productId) == null) {
            inventory.put(productId, addedQuantity);
        }
        else {
            inventory.put(productId, inventory.get(productId) + addedQuantity);
        }
    }

    @Override
    public void removeFromInventory(UUID productId, int removedQuantity) {
        if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
        if(removedQuantity <= 0)  throw new ShopException("The removed quantity is null or negative!");

        int reservedInventory = consumer.getReservedProductAmount(productId);
        int inventoryQuantity = (inventory.get(productId) == null ? 0 : inventory.get(productId));
        int reservedQuantity = reservedInventory;

        if(removedQuantity > (inventoryQuantity + reservedQuantity))  throw new ShopException("The removed quantity is too big!");

        int newQuantity = inventoryQuantity - removedQuantity;

        int diffQuantity = reservedInventory - newQuantity;
        if(newQuantity < reservedInventory) {
            // Correct the reserved quantities
            while(diffQuantity > 0) {
                for (UUID id: consumer.getAllIds()) {
                    if(diffQuantity == 0) return;
                    if(consumer.existsById(id)) {
                        if(consumer.getProductQuantity(id, productId) > 0) {
                            consumer.addProduct(id, productId, -1);
                            diffQuantity--;
                        }
                    }
                }
            }
        }
        inventory.put(productId, newQuantity);
    }
 /**
     * Changes the total quantity of a given product in the inventory.
     * If the new total quantity is lower than the currently reserved products, some of currently reserved products
     * (in the users' shopping baskets) are removed. This means that some of the reserved products are lost for
     * the user. (This is necessary because there probably was a mistake in the inventory management, a mis-counting,
     * or some of the products were stolen from the warehouse, are broken, etc.)
     * @param productId
     * @param newTotalQuantity
     * @throws ShopException if ...
     *      - the product id does not exist
     *      - if the new total quantity is negative
     */
    @Override
    public void changeInventoryTo(UUID productId, int newTotalQuantity) {
        if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
        if(newTotalQuantity < 0)  throw new ShopException("The new total quantity is negative!");

        // If the new total quantity is lower than the currently reserved products, some of currently reserved products
        //     * (in the users' shopping baskets) are removed
        if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
        int reservedInventory = consumer.getReservedProductAmount(productId);
        int diffQuantity = reservedInventory - newTotalQuantity;
        if(newTotalQuantity < reservedInventory) {
            // Correct the reserved quantities
            while(diffQuantity > 0) {
                for (UUID id: consumer.getAllIds()) {
                    if(diffQuantity == 0) return;
                    if(consumer.existsById(id)) {
                        if(consumer.getProductQuantity(id, productId) > 0) {
                            consumer.addProduct(id, productId, -1);
                            diffQuantity--;
                        }
                    }
                }
            }
        }
        // Changes the total quantity of a given product in the inventory.
        inventory.put(productId, newTotalQuantity);
    }

    @Override
    public int getAvailableInventory(UUID productId) {
        if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
        if(inventory.get(productId) == null) return 0;
        int reservedInventory = consumer.getReservedProductAmount(productId);
        return inventory.get(productId) - reservedInventory;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductCatalogService.java ---
package thkoeln.archilab.ecommerce.solution.product.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.Hashtable;
import java.util.UUID;

@Service
public class ProductCatalogService implements ProductCatalogUseCases {

    @Autowired
    private ProductRepository products;
    @Autowired
    private InventoryService inventory;
    @Autowired
    private ProductConsumerService consumer;

    @Override
    public void addProductToCatalog(UUID productId, String name, String description, Float size, MoneyType purchasePrice, MoneyType sellPrice) {
        // Validierungen
        if(productId == null) throw new ShopException("ProductId is null!");
        if(products.existsById(productId)) throw new ShopException("This product already exists!");
        if(name == null || name == "") throw new ShopException("Name is null or empty!");
        if(description == null || description == "") throw new ShopException("Description is null or empty!");
        if(size != null && size <= 0) throw new ShopException("Size can't be negative!");
        if(purchasePrice == null || purchasePrice.getAmount() <= 0) throw new ShopException("Purchase Price can't be negative or null!");
        if(sellPrice == null || sellPrice.getAmount() <= 0) throw new ShopException("Sell Price can't be negative or null!");
        if(sellPrice.getAmount() < purchasePrice.getAmount()) throw new ShopException("Sell Price can't be lower than Purchase Price!");

        // Add product
        Product newProduct = new Product(productId, name, description, size, purchasePrice, sellPrice);
        products.save(newProduct);
    }

    @Override
    public void removeProductFromCatalog(UUID productId) {
        if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
        if((inventory.inventory.get(productId) == null ? 0 : inventory.inventory.get(productId)) > 0) throw new ShopException("This product is still in inventory!");
        if(consumer.getReservedProductAmount(productId) > 0) throw new ShopException("This product is still reserved in a shopping basket!");
        products.deleteById(productId);
    }

    @Override
    public MoneyType getSellPrice(UUID productId) {
        if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
        return products.findById(productId).get().getSellPrice();
    }

    @Override
    public void deleteProductCatalog() {
        consumer.deleteAll();
        inventory.inventory = new Hashtable();
        products.deleteAll();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductConsumerService.java ---
package thkoeln.archilab.ecommerce.solution.product.application;
import org.springframework.stereotype.Service;

import java.util.Set;
import java.util.UUID;

@Service
public abstract class ProductConsumerService {
    public abstract int getProductQuantity(UUID consumerId, UUID productId);
    public abstract void addProduct(UUID consumerId, UUID productId, int amount);
    public abstract boolean existsById(UUID s);
    public abstract long count();
    public abstract void deleteById(UUID s);
    public abstract Set<UUID> getAllIds();
    public abstract void deleteAll();
    public abstract int getReservedProductAmount(UUID productId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductUserService.java ---
package thkoeln.archilab.ecommerce.solution.product.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

@Service
public abstract class ProductUserService {
    public abstract boolean existsByMailAddress(MailAddressType mailAddress);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\Product.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import javax.persistence.*;
import java.util.UUID;

@Getter
@Setter
@Entity
public class Product {
    @Id
    private final UUID id;
    private String name;
    private String description;
    private Float size;
    @Embedded
    private MoneyType purchasePrice;
    @Embedded
    private MoneyType sellPrice;

    private Product() {
        this.id = UUID.randomUUID();
    }

    public Product(UUID productId, String name, String description, Float size,
                   MoneyType purchasePrice, MoneyType sellPrice) {
        this.id = productId;
        this.name = name;
        this.description = description;
        this.size = size;
        this.purchasePrice = purchasePrice;
        this.sellPrice = sellPrice;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductRepository.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Optional;
import java.util.UUID;

@Repository
public class ProductRepository implements CrudRepository<Product, UUID> {

    public HashMap<UUID, Product> products = new HashMap();

    @Override
    public <S extends Product> S save(S s) {
        products.put(s.getId(), s);
        return s;
    }

    @Override
    public <S extends Product> Iterable<S> saveAll(Iterable<S> iterable) {
        for (S product: iterable) {
            products.put(product.getId(), product);
        }
        return iterable;
    }

    @Override
    public Optional<Product> findById(UUID s) {
        return Optional.ofNullable(products.get(s));
    }

    @Override
    public boolean existsById(UUID s) {
        return products.containsKey(s);
    }

    @Override
    public Iterable<Product> findAll() {
        return products.values();
    }

    @Override
    public Iterable<Product> findAllById(Iterable<UUID> iterable) {
        ArrayList<Product> data = new ArrayList<Product>();
        for (UUID mail: iterable) {
            if(existsById(mail)) data.add(products.get(mail));
        }
        return data;
    }

    @Override
    public long count() {
        return products.size();
    }

    @Override
    public void deleteById(UUID s) {
        if(existsById(s)) products.remove(s);
    }

    @Override
    public void delete(Product product) {
        deleteById(product.getId());
    }

    @Override
    public void deleteAll(Iterable<? extends Product> iterable) {
        for (Product product: iterable) {
            deleteById(product.getId());
        }
    }

    @Override
    public void deleteAll() {
        products.clear();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketConsumerService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.product.application.ProductConsumerService;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

@Service
public class ShoppingBasketConsumerService extends ProductConsumerService {

    @Autowired
    private ShoppingBasketRepository shoppingBaskets;
    @Autowired
    private ProductRepository products;

    @Override
    public int getProductQuantity(UUID consumerId, UUID productId) {
        if(!shoppingBaskets.existsById(consumerId)) {
            return 0;
        }
        else {
            return shoppingBaskets.findById(consumerId).get().getProductQuantity(productId);
        }
    }

    @Override
    public void addProduct(UUID consumerId, UUID productId, int amount) {
        if(shoppingBaskets.existsById(consumerId)) {
            ShoppingBasket basket = shoppingBaskets.findById((consumerId)).get();
            if(basket.getProductQuantity(productId) > 0) {
                basket.addProduct(products.findById(productId).get(), amount);
                shoppingBaskets.save(basket);
            }
        }
    }

    @Override
    public boolean existsById(UUID s) {
        return shoppingBaskets.existsById(s);
    }

    @Override
    public long count() {
        return shoppingBaskets.count();
    }

    @Override
    public void deleteById(UUID s) {
        shoppingBaskets.deleteById(s);
    }

    @Override
    public Set<UUID> getAllIds() {
        HashSet<UUID> keys = new HashSet();
        for (ShoppingBasket shoppingBasket : shoppingBaskets.findAll()) {
            keys.add(shoppingBasket.getShoppingBasketId());
        }
        return keys;
    }

    @Override
    public void deleteAll() {
        shoppingBaskets.deleteAll();
    }

    @Override
    public int getReservedProductAmount(UUID productId) {
        return shoppingBaskets.getReservedProductAmount(productId);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.solution.dtos.ShoppingBasketDto;
import thkoeln.archilab.ecommerce.solution.dtos.ShoppingBasketPositionDto;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderPositionRepository;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
import thkoeln.archilab.ecommerce.solution.product.application.InventoryService;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;

import java.util.UUID;
import java.util.stream.StreamSupport;

@RestController
public class ShoppingBasketController {

    @Autowired
    public ShoppingBasketRepository shoppingBaskets;
    @Autowired
    public ProductRepository products;
    @Autowired
    public InventoryService inventory;
    @Autowired
    public ShoppingBasketService shoppingBasketService;
    @Autowired
    public OrderRepository orders;


    //Return the shopping basket for a specific user with mailAddress
    @GetMapping("/shoppingBaskets")
    ResponseEntity<ShoppingBasketDto> findShoppingBasketByMailAddress(@RequestParam(required = false) String mailAddress) {
        if(!StreamSupport.stream(shoppingBaskets.findAll().spliterator(), false)
                .anyMatch(e -> e.getMailAddress().toString().equals(mailAddress))) {
            return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
        }

        var shoppingBasket = StreamSupport.stream(shoppingBaskets.findAll().spliterator(), false)
                .filter(e -> e.getMailAddress().toString().equals(mailAddress)).findFirst().get();

        if(shoppingBasket == null) return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);

        int totalQuantity = shoppingBasket.getPositions().stream().mapToInt(ShoppingBasketPosition::getQuantity).sum();
        ShoppingBasketDto result = new ShoppingBasketDto(shoppingBasket.getShoppingBasketId(), shoppingBasket.getMailAddress(), totalQuantity);
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    //For a specific shopping basket, add/remove a certain quantity of products
    @PostMapping("/shoppingBaskets/{shoppingBasket-id}/shoppingBasketPositions")
    ResponseEntity<ShoppingBasketDto> modifyShoppingBasket(@PathVariable("shoppingBasket-id") UUID shoppingBasketId,
                                                           @RequestBody ShoppingBasketPositionDto newPos) {
        if(!shoppingBaskets.existsById(shoppingBasketId)) return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
        if(!products.existsById(newPos.getProductId())) return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);

        var shoppingBasket = shoppingBaskets.findById(shoppingBasketId).get();
        if(newPos.getQuantity() > 0) {
            if(inventory.getAvailableInventory(newPos.getProductId()) < newPos.getQuantity())
                return new ResponseEntity<>(null, HttpStatus.CONFLICT);

            var positions = shoppingBasket.getPositions();
            // Produkt liegt noch nicht im Warenkorb
            if(!positions.stream().anyMatch(e -> e.getProduct().getId().equals(newPos.getProductId()))) {
                shoppingBasket.addProduct(products.findById(newPos.getProductId()).get(), newPos.getQuantity(), newPos.getComment());
                shoppingBaskets.save(shoppingBasket);
                return new ResponseEntity<>(null, HttpStatus.CREATED);
            }
            // Produkt liegt bereits im Warenkorb
            else {
                var pos = positions.stream().filter(e -> e.getProduct().getId().equals(newPos.getProductId())).findFirst().get();
                pos.setQuantity(pos.getQuantity() + newPos.getQuantity());
                pos.setComment(newPos.getComment());
                positions.removeIf(e -> e.getProduct().getId().equals(pos.getProduct().getId()));
                positions.add(pos);
                shoppingBasket.setPositions(positions);
            }
        }
        else {
            // Produkt existiert nicht im Warenkorb, kann nicht entfernt werden => Conflict
            if(!shoppingBasket.getPositions().stream().anyMatch(e -> e.getProduct().getId().equals(newPos.getProductId()))) {
                return new ResponseEntity<>(null, HttpStatus.CONFLICT);
            }
            // Produktmenge wird reduziert
            else {
                var pos = shoppingBasket.getPositions().stream().filter(e -> e.getProduct().getId().equals(newPos.getProductId())).findFirst().get();
                pos.setQuantity(pos.getQuantity() + newPos.getQuantity());
                pos.setComment(newPos.getComment());

                if(pos.getQuantity() < 0) return new ResponseEntity<>(null, HttpStatus.CONFLICT);
                if(pos.getQuantity() == 0) shoppingBasket.getPositions().removeIf(e -> e.getProduct().getId().equals(newPos.getProductId()));
            }
        }
        shoppingBaskets.save(shoppingBasket);
        return new ResponseEntity<>(null, HttpStatus.CREATED);
    }

    //For a specific shopping basket, delete the shopping basket position for this product
    @DeleteMapping("/shoppingBaskets/{shoppingBasket-id}/shoppingBasketPositions/{product-id}")
    ResponseEntity<ShoppingBasketDto> deletePosition(@PathVariable("shoppingBasket-id") UUID shoppingBasketId,
                                                     @PathVariable("product-id") UUID productId) {
        if(shoppingBasketId == null || productId == null) return new ResponseEntity<>(null, HttpStatus.UNPROCESSABLE_ENTITY);
        if(!shoppingBaskets.existsById(shoppingBasketId)) return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
        if(!products.existsById(productId)) return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);

        var shoppingBasket = shoppingBaskets.findById(shoppingBasketId).get();
        if(!shoppingBasket.getPositions().stream().anyMatch(e -> e.getProduct().getId().equals(productId)))
            return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);

        shoppingBasket.getPositions().removeIf(e -> e.getProduct().getId().equals(productId));
        shoppingBaskets.save(shoppingBasket);
        return new ResponseEntity<>(null, HttpStatus.OK);
    }

    //For a specific shopping basket and product, get quantity and comment
    @GetMapping("/shoppingBaskets/{shoppingBasket-id}/shoppingBasketPositions/{product-id}")
    ResponseEntity<ShoppingBasketPositionDto> getPosition(@PathVariable("shoppingBasket-id") UUID shoppingBasketId,
                                                     @PathVariable("product-id") UUID productId) {
        if(shoppingBasketId == null || productId == null) return new ResponseEntity<>(null, HttpStatus.UNPROCESSABLE_ENTITY);
        if(!shoppingBaskets.existsById(shoppingBasketId)) return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
        if(!products.existsById(productId)) return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);

        var shoppingBasket = shoppingBaskets.findById(shoppingBasketId).get();
        if(!shoppingBasket.getPositions().stream().anyMatch(e -> e.getProduct().getId().equals(productId)))
            return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);

        var pos = shoppingBasket.getPositions().stream().filter(e -> e.getProduct().getId().equals(productId)).findFirst().get();
        return new ResponseEntity<>(new ShoppingBasketPositionDto(pos.getProduct().getId(), pos.getQuantity(), pos.getComment()), HttpStatus.OK);
    }

    //For a specific shopping basket and product, get quantity and comment
    @PutMapping("/shoppingBaskets/{shoppingBasket-id}/checkout")
    ResponseEntity checkout(@PathVariable("shoppingBasket-id") UUID shoppingBasketId)
    {
        if(shoppingBasketId == null) return new ResponseEntity<>(null, HttpStatus.UNPROCESSABLE_ENTITY);
        if(!shoppingBaskets.existsById(shoppingBasketId)) return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);

        var shoppingBasket = shoppingBaskets.findById(shoppingBasketId).get();
        if(shoppingBasket.getPositions().stream().mapToInt(e -> e.getQuantity()).sum() > 20)
            return new ResponseEntity<>(null, HttpStatus.CONFLICT);
        if(shoppingBasket.getPositions().stream().mapToDouble(e -> e.getProduct().getSellPrice().getAmount() * e.getQuantity()).sum() > 500)
            return new ResponseEntity<>(null, HttpStatus.CONFLICT);
        if(shoppingBasket.getPositions().stream().count() == 0)
            return new ResponseEntity<>(null, HttpStatus.CONFLICT);

        try {
            shoppingBasketService.checkout(shoppingBasket.getMailAddress());
        }
        catch (ShopException ex) {
            return new ResponseEntity<>(null, HttpStatus.UNPROCESSABLE_ENTITY);
        }
        return new ResponseEntity<>(null , HttpStatus.OK);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.delivery.application.DeliveryService;
import thkoeln.archilab.ecommerce.solution.payment.application.PaymentService;
import thkoeln.archilab.ecommerce.solution.order.domain.*;
import thkoeln.archilab.ecommerce.solution.product.application.InventoryService;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductRepository;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketState;
import thkoeln.archilab.ecommerce.solution.user.domain.User;
import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Service
public class ShoppingBasketService implements ShoppingBasketUseCases {

    // Repositories
    @Autowired
    private ProductRepository products;
    @Autowired
    private UserRepository users;
    @Autowired
    private OrderRepository orders;
    @Autowired
    private OrderPositionRepository orderPositions;
    @Autowired
    private ShoppingBasketRepository shoppingBaskets;

    // Services
    @Autowired
    private InventoryService inventory;
    @Autowired
    private DeliveryService deliveryService;
    @Autowired
    private PaymentService paymentService;

    @Override
    public void addProductToShoppingBasket(MailAddressType userMailAddress, UUID productId, int quantity) {
        if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
        if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
        if(quantity < 0) throw new ShopException("Quantity can't be negative!");
        if(inventory.getAvailableInventory(productId) < quantity) throw new ShopException("product is not available in the requested quantity");

        if(!shoppingBaskets.existsByMailAddress(userMailAddress)) {
            ShoppingBasket basket = new ShoppingBasket(userMailAddress);
            shoppingBaskets.save(basket);
        }
        ShoppingBasket basket = shoppingBaskets.findByMailAddress(userMailAddress).get();
        basket.addProduct(products.findById(productId).get(), quantity);
        shoppingBaskets.save(basket);
    }

    @Override
    public void removeProductFromShoppingBasket(MailAddressType userMailAddress, UUID productId, int quantity) {
        if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
        if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
        if(quantity < 0) throw new ShopException("Quantity can't be negative!");

        if(!shoppingBaskets.existsByMailAddress(userMailAddress)) {
            ShoppingBasket basket = new ShoppingBasket(userMailAddress);
            shoppingBaskets.save(basket);
        }
        ShoppingBasket basket = shoppingBaskets.findByMailAddress(userMailAddress).get();
        if(basket.getProductQuantity(productId) < quantity) throw new ShopException("Product is not in the cart in the requested quantity");
        basket.addProduct(products.findById(productId).get(), -quantity);
        shoppingBaskets.save(basket);
    }

    @Override
    public Map<UUID, Integer> getShoppingBasketAsMap(MailAddressType userMailAddress) {
        if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
        if(!shoppingBaskets.existsByMailAddress(userMailAddress)) {
            ShoppingBasket basket = new ShoppingBasket(userMailAddress);
            shoppingBaskets.save(basket);
        }
        ShoppingBasket basket = shoppingBaskets.findByMailAddress(userMailAddress).get();

        HashMap<UUID, Integer> result = new HashMap();
        for (var pos: basket.getPositions()) {
            result.put(pos.getProduct().getId(), pos.getQuantity());
        }
        return result;
    }

    @Override
    public MoneyType getShoppingBasketAsMoneyValue(MailAddressType userMailAddress) {
        if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
        Map<UUID, Integer> productsInCart = getShoppingBasketAsMap(userMailAddress);
        MoneyType cartValue = null;
        for (UUID productId: productsInCart.keySet()) {
            Product product = products.findById(productId).get();
            MoneyType price = Money.of(product.getSellPrice().getAmount() * productsInCart.get(productId), product.getSellPrice().getCurrency());
            if(cartValue == null)
            {
                cartValue = Money.of(price.getAmount(), price.getCurrency());
            }
            else {
                cartValue = cartValue.add(price);
            }
        }
        return cartValue;
    }

    @Override
    public int getReservedInventoryInShoppingBaskets(UUID productId) {
        if(!products.existsById(productId)) throw new ShopException("This product does not exist!");
        return shoppingBaskets.getReservedProductAmount(productId);
    }

    /**
     * Checks if the shopping basket of a user is empty
     *
     * @param userMailAddress
     * @return true if the shopping basket is empty, false otherwise
     * @throws ShopException if ...
     *    - the mail address is null or empty
     *    - the user with the given mail address does not exist
     */
    @Override
    public boolean isEmpty(MailAddressType userMailAddress) {
        if(userMailAddress == null || userMailAddress.toString() == "") throw new ShopException("User Mail Address is null or empty!");
        if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");

        if(!shoppingBaskets.existsByMailAddress(userMailAddress)) return true;
        if(shoppingBaskets.findByMailAddress(userMailAddress).get().isEmpty()) return true;
        return false;
    }

    /**
     * Checks if the payment for a specific shopping basket of a user has been authorized to be paid,
     * i.e. the shopping basket is not empty, the user has given his/her payment details, and the payment
     * has been authorized (under the limits of the user's credit card). However, the order
     * has not yet been placed yet, and the logistics details (delivery address) have not yet been given.
     *
     * @param userMailAddress
     * @return true if the payment has been authorized, false otherwise
     * @throws ShopException if ...
     *   - the mail address is null or empty
     *   - the user with the given mail address does not exist
     */
    @Override
    public boolean isPaymentAuthorized(MailAddressType userMailAddress) {
        if(userMailAddress == null || userMailAddress.toString() == "") throw new ShopException("User Mail Address is null or empty!");
        if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");

            if (!shoppingBaskets.existsByMailAddress(userMailAddress)) return false;
            ShoppingBasket shoppingBasket = shoppingBaskets.findByMailAddress(userMailAddress).get();

            if(shoppingBasket.getState() == ShoppingBasketState.AUTHORIZED) return true;

            return false;
    }
    private User validateCheckoutUser(MailAddressType userMailAddress) {
        if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
        User user = users.findById(userMailAddress.toString()).get();
        return user;
    }
    private ShoppingBasket validateCheckoutBasket(MailAddressType mail) {
        if(!shoppingBaskets.existsByMailAddress(mail)) {
            ShoppingBasket basket = new ShoppingBasket(mail);
            shoppingBaskets.save(basket);
        }
        ShoppingBasket basket = shoppingBaskets.findByMailAddress(mail).get();
        if(basket.isEmpty()) throw new ShopException("This Basket is Empty");
        return basket;
    }

    @Override
    public void checkout(MailAddressType userMailAddress) {
        validateCheckoutUser(userMailAddress);
        ShoppingBasket basket = validateCheckoutBasket(userMailAddress);

        MoneyType totalPrice = null;
        for (var position: basket.getPositions()) {
            MoneyType price = Money.of(position.getProduct().getSellPrice().getAmount() * position.getQuantity(), position.getProduct().getSellPrice().getCurrency());
            if(totalPrice == null) totalPrice = Money.of(price.getAmount(), price.getCurrency());
            else  totalPrice = totalPrice.add(price);
        }

        if(!isPaymentAuthorized(userMailAddress)) {
            basket.setState(ShoppingBasketState.AUTHORIZED);
            shoppingBaskets.save(basket);
        }
        basket.setState(ShoppingBasketState.DELIVERED);
        shoppingBaskets.save(basket);

        Order newOrder = new Order(userMailAddress, totalPrice); // Create new Order
        orders.save(newOrder);
        for (var position: basket.getPositions()) { // Create Order positions
            if(position.getQuantity() > 0) {
                OrderPosition newPos = new OrderPosition(newOrder, position.getProduct(), position.getQuantity(), position.getComment()); // Add position to order
                orderPositions.save(newPos);
                inventory.removeFromInventory(newPos.getProduct().getId(), newPos.getQuantity()); // Remove from inventory
            }
        }
        shoppingBaskets.deleteByMailAddress(userMailAddress);
        shoppingBaskets.save(new ShoppingBasket(userMailAddress));
    }

    @Override
    /**
     * Returns a map showing which products have been ordered by a user and how many of each product
     *
     * @param userMailAddress
     * @return the order history of the user (map is empty if the user has not ordered anything yet)
     * @throws ShopException if the user with the given mailAddress does not exist
     */
    public Map<UUID, Integer> getOrderHistory(MailAddressType userMailAddress) {
        if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
        HashMap<UUID, Integer> result = new HashMap();

        // Get all orders
        for (Order order: orders.findAll()) {
            // check if order is from this user
            if(order.getMailAddress() == userMailAddress) {
                // check all positions
                for (OrderPosition pos : orderPositions.findAll()) {
                    // Check if position matches order
                    if(pos.getOrder().getId() != order.getId()) continue;
                    // if product is in result, then summarize
                    if(result.containsKey(pos.getProduct().getId())) {
                        result.put(pos.getProduct().getId(), result.get(pos.getProduct().getId()) + pos.getQuantity());
                    }
                    // else if product is not in result, then add
                    else {
                        result.put(pos.getProduct().getId(), pos.getQuantity());
                    }
                }
            }
        }

        return result;
    }

    @Override
    /**
     * Deletes all orders and shopping baskets in the system
     */
    public void deleteAllOrders() {
        orders.deleteAll();
        shoppingBaskets.deleteAll();

    }


    @Override
    /**
     * Sets a comment in the shopping basket position containing a product
     *
     * @param userMailAddress
     * @param productId
     * @param comment (can be null)
     * @throws ShopException if ...
     *      - userMailAddress is null,
     *      - the user with the given mailAddress does not exist,
     *      - the product does not exist
     *      - the product is not in the shopping basket
     */
    public void setCommentForShoppingBasketPosition( MailAddressType userMailAddress, UUID productId, String comment ) {
        if(userMailAddress == null || userMailAddress.toString() == "") throw new ShopException("Mail Address is null or empty!");
        if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
        if(!products.existsById(productId)) throw new ShopException("This product does not exist!");

        var shoppingBasket = shoppingBaskets.findByMailAddress(userMailAddress).get();

        var position = shoppingBasket.getPositions().stream().filter(e -> e.getProduct().getId() == productId).findFirst().get();
        if(position == null || position.getQuantity() == 0)
            throw new ShopException("Product is not in the shopping basket!");

        var posIndex = shoppingBasket.getPositions().indexOf(position);
        shoppingBasket.getPositions().get(posIndex).setComment(comment);
        shoppingBaskets.save(shoppingBasket);
    }

    @Override
    /**
     * Returns the comment in the shopping basket position containing a product
     *
     * @param userMailAddress
     * @param productId
     * @return the comment (can be null)
     * @throws ShopException if ...
     *      - userMailAddress is null,
     *      - the user with the given mailAddress does not exist,
     *      - the product does not exist
     *      - the product is not in the shopping basket
     */
    public String getCommentForShoppingBasketPosition( MailAddressType userMailAddress, UUID productId ) {
        if(userMailAddress == null || userMailAddress.toString() == "") throw new ShopException("Mail Address is null or empty!");
        if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist!");
        if(!products.existsById(productId)) throw new ShopException("This product does not exist!");

        var shoppingBasket = shoppingBaskets.findByMailAddress(userMailAddress).get();

        var position = shoppingBasket.getPositions().stream().filter(e -> e.getProduct().getId() == productId).findFirst().get();
        if(position == null || position.getQuantity() == 0)
            throw new ShopException("Product is not in the shopping basket!");

        return position.getComment();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\UserShoppingBasketService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
import thkoeln.archilab.ecommerce.solution.user.application.UserShoppingBasketBase;

@Service
public class UserShoppingBasketService extends UserShoppingBasketBase {

    @Autowired
    private ShoppingBasketRepository shoppingBaskets;

    @Override
    public void createBasketByMail(MailAddress mailAddress) {
        shoppingBaskets.save(new ShoppingBasket(mailAddress));
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import javax.persistence.Embedded;
import javax.persistence.Entity;
import javax.persistence.Id;
import java.util.ArrayList;
import java.util.UUID;

@Getter
@Setter
@Entity
public class ShoppingBasket {
    @Id
    private final UUID shoppingBasketId = UUID.randomUUID();
    private ArrayList<ShoppingBasketPosition> positions = new ArrayList();
    private ShoppingBasketState state = ShoppingBasketState.EMPTY;
    @Embedded
    private final MailAddress mailAddress;

    private ShoppingBasket() {
        mailAddress = null;
    }

    public ShoppingBasket(MailAddressType mailAddress) {
        this.mailAddress = MailAddress.of(mailAddress.toString());
    }

    public void addProduct(Product product, int quantity) {
        addProduct(product, quantity, null);
    }
    public void addProduct(Product product, int quantity, String comment) {
        if(!positions.stream().anyMatch(e -> e.getProduct().getId() == product.getId())) {
            positions.add(new ShoppingBasketPosition(product, quantity, comment));
        }
        else {
            var position = positions.stream().filter(e -> e.getProduct().getId() == product.getId()).findFirst().get();
            var posIndex = positions.indexOf(position);
            positions.get(posIndex).setQuantity(positions.get(posIndex).getQuantity() + quantity);
        }

        if(isEmpty()) state = ShoppingBasketState.EMPTY;
        else state = ShoppingBasketState.FILLED;
    }

    public boolean isEmpty() {
        for (ShoppingBasketPosition pos : getPositions()) {
            if(pos.getQuantity() > 0) return false;
        }
        return true;
    }

    public Integer getProductQuantity(UUID productId) {
        if(!positions.stream().anyMatch(e -> e.getProduct().getId().equals(productId))) return 0;
        var position = positions.stream().filter(e -> e.getProduct().getId().equals(productId)).findFirst().get();
        return position == null ? 0 : position.getQuantity();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.product.domain.Product;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import java.time.LocalDateTime;
import java.util.UUID;

@Getter @Setter
@NoArgsConstructor
@Entity
public class ShoppingBasketPosition {
    @Id
    private final UUID uuid = UUID.randomUUID();
    @ManyToOne
    private Product product;
    private int quantity;
    private String comment;

    public ShoppingBasketPosition(Product product, int quantity, String comment) {
        this.product = product;
        this.quantity = quantity;
        this.comment = comment;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketRepository.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.*;

@Repository
public class ShoppingBasketRepository implements CrudRepository<ShoppingBasket, UUID> {

    public HashMap<UUID, ShoppingBasket> shoppingBaskets = new HashMap();

    @Override
    public <S extends ShoppingBasket> S save(S s) {
        shoppingBaskets.put(s.getShoppingBasketId(), s);
        return s;
    }

    @Override
    public <S extends ShoppingBasket> Iterable<S> saveAll(Iterable<S> iterable) {
        for (S shoppingBasket: iterable) {
            shoppingBaskets.put(shoppingBasket.getShoppingBasketId(), shoppingBasket);
        }
        return iterable;
    }

    @Override
    public Optional<ShoppingBasket> findById(UUID s) {
        return Optional.ofNullable(shoppingBaskets.get(s));
    }

    @Override
    public boolean existsById(UUID s) {
        return shoppingBaskets.containsKey(s);
    }

    public boolean existsByMailAddress(MailAddressType mail) {
        return shoppingBaskets.values().stream().anyMatch(sb -> Objects.equals(sb.getMailAddress().toString(), mail.toString()));
    }

    public Optional<ShoppingBasket> findByMailAddress(MailAddressType mail) {
        return shoppingBaskets.values().stream().filter(sb -> Objects.equals(sb.getMailAddress().toString(), mail.toString())).findFirst();
    }

    @Override
    public Iterable<ShoppingBasket> findAll() {
        return shoppingBaskets.values();
    }

    @Override
    public Iterable<ShoppingBasket> findAllById(Iterable<UUID> iterable) {
        ArrayList<ShoppingBasket> data = new ArrayList<ShoppingBasket>();
        for (UUID mail: iterable) {
            if(existsById(mail)) data.add(shoppingBaskets.get(mail));
        }
        return data;
    }

    @Override
    public long count() {
        return shoppingBaskets.size();
    }

    @Override
    public void deleteById(UUID s) {
        if(existsById(s)) shoppingBaskets.remove(s);
    }

    public void deleteByMailAddress(MailAddressType mail) {
        if(existsByMailAddress(mail)) shoppingBaskets.remove(findByMailAddress(mail).get().getShoppingBasketId());
    }

    @Override
    public void delete(ShoppingBasket shoppingBasket) {
        deleteById(shoppingBasket.getShoppingBasketId());
    }

    @Override
    public void deleteAll(Iterable<? extends ShoppingBasket> iterable) {
        for (ShoppingBasket shoppingBasket: iterable) {
            deleteById(shoppingBasket.getShoppingBasketId());
        }
    }

    @Override
    public void deleteAll() {
        shoppingBaskets.clear();
    }

    public int getReservedProductAmount(UUID productId) {
        int reservedInventory = 0;
        for (ShoppingBasket basket: findAll()) {
            if(!basket.getPositions().stream().anyMatch(e -> e != null
                    && e.getProduct() != null
                    && e.getProduct().getId() != null
                    && e.getProduct().getId().equals(productId))) continue;
            var position = basket.getPositions().stream().filter(e -> e != null
                    && e.getProduct() != null
                    && e.getProduct().getId() != null
                    && e.getProduct().getId().equals(productId)).findFirst().get();
            if(position != null) {
                reservedInventory += position.getQuantity();
            }
        }
        return reservedInventory;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketState.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

public enum ShoppingBasketState {
    EMPTY,
    FILLED,
    AUTHORIZED,
    DELIVERED
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserProductService.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.product.application.ProductUserService;
import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

@Service
public class UserProductService extends ProductUserService {

    @Autowired
    private UserRepository users;

    @Override
    public boolean existsByMailAddress(MailAddressType mailAddress) {
       return users.existsById(mailAddress.toString());
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserService.java ---
package thkoeln.archilab.ecommerce.solution.user.application;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.PersonalAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;
import thkoeln.archilab.ecommerce.domainprimitives.UserTypeImplementation;
import thkoeln.archilab.ecommerce.solution.address.domain.Address;
import thkoeln.archilab.ecommerce.solution.user.domain.User;
import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;

@Service
public class UserService implements UserRegistrationUseCases {

    @Autowired
    private UserRepository users;
    @Autowired
    private UserShoppingBasketBase shoppingBasketService;

    @Override
    public void register(String name, MailAddressType mailAddress, PersonalAddressType address) {
        // check if user exists
        if(mailAddress == null) throw new ShopException("Mail Address is null.");
        if(address == null) throw new ShopException("Address is null.");
        if(users.existsById(mailAddress.toString())) throw new ShopException("This user is already registered.");

        // register new user
        if(name == "" || name == null
                || mailAddress.toString() == "" || mailAddress == null
                || address.getStreet() == "" || address.getStreet() == null
                || address.getCity() == "" || address.getCity() == null
                || address.getPostalCode().toString() == "" || address.getPostalCode() == null)
        {
            throw new ShopException("Invalid values.");
        }

        User newUser = new User(name, mailAddress, address.getStreet(), address.getCity(), address.getPostalCode().toString());
        users.save(newUser);
        shoppingBasketService.createBasketByMail(newUser.getMailAddress());
    }

    @Override
    public void changeAddress(MailAddressType userMailAddress, PersonalAddressType personalAddress) {
        if(users == null) throw new ShopException("Users is null.");
        if(userMailAddress == null) throw new ShopException("Mail Address is null.");
        if(personalAddress == null) throw new ShopException("Address is null.");

        // Check if user exists.
        if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist.");

        // Check if data is valid.
        if(personalAddress.getStreet() == "" || personalAddress.getStreet() == null
                || personalAddress.getCity() == "" || personalAddress.getCity() == null
                || personalAddress.getPostalCode().toString() == "" || personalAddress.getPostalCode().toString() == null)
        {
            throw new ShopException("Invalid values.");
        }

        // Change address.
        User user = users.findById(userMailAddress.toString()).get();
        user.setAddress(new Address(personalAddress.getStreet(), personalAddress.getCity(), personalAddress.getPostalCode().toString()));
        users.save(user);
    }

    @Override
    public UserType getUserData(MailAddressType userMailAddress) {
        // Check if user exists.
        if(!users.existsById(userMailAddress.toString())) throw new ShopException("This user does not exist.");

        // Get User
        User user = users.findById(userMailAddress.toString()).get();

        // Read data
        return UserTypeImplementation.of(user.getName(),
                user.getMailAddress(),
                PersonalAddress.of(user.getAddress().getStreet(), user.getAddress().getCity(), PostalCode.of(user.getAddress().getPostalCode())));
    }

    @Override
    public void deleteAllUsers() {
        users.deleteAll();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserShoppingBasketBase.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;

public abstract class UserShoppingBasketBase {
    public abstract void createBasketByMail(MailAddress mailAddress);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\User.java ---
package thkoeln.archilab.ecommerce.solution.user.domain;

import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.solution.address.domain.Address;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import javax.persistence.*;
import java.util.UUID;

@Getter
@Setter
@Entity
public class User {
    @Id
    private final UUID id = UUID.randomUUID();
    private String name;
    @Embedded
    private final MailAddress mailAddress;
    @OneToOne
    private Address address;

    private User() {
        this.mailAddress = null;
    }

    public User(String name, MailAddressType mailAddress, String street, String city, String postalCode) {
        this.name = name;
        this.mailAddress = MailAddress.of(mailAddress.toString());
        this.address = new Address(street, city, postalCode);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserRepository.java ---
package thkoeln.archilab.ecommerce.solution.user.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Optional;

@Repository
public class UserRepository implements CrudRepository<User, String> {

    public HashMap<String, User> users = new HashMap();

    @Override
    public <S extends User> S save(S s) {
        users.put(s.getMailAddress().toString(), s);
        return s;
    }

    @Override
    public <S extends User> Iterable<S> saveAll(Iterable<S> iterable) {
        for (S user: iterable) {
            users.put(user.getMailAddress().toString(), user);
        }
        return iterable;
    }

    @Override
    public Optional<User> findById(String s) {
        return Optional.ofNullable(users.get(s));
    }

    @Override
    public boolean existsById(String s) {
        return users.containsKey(s);
    }

    @Override
    public Iterable<User> findAll() {
        return users.values();
    }

    @Override
    public Iterable<User> findAllById(Iterable<String> iterable) {
        ArrayList<User> data = new ArrayList<User>();
        for (String mail: iterable) {
            if(existsById(mail)) data.add(users.get(mail));
        }
        return data;
    }

    @Override
    public long count() {
        return users.size();
    }

    @Override
    public void deleteById(String s) {
        if(existsById(s)) users.remove(s);
    }

    @Override
    public void delete(User user) {
        deleteById(user.getMailAddress().toString());
    }

    @Override
    public void deleteAll(Iterable<? extends User> iterable) {
        for (User user: iterable) {
            deleteById(user.getMailAddress().toString());
        }
    }

    @Override
    public void deleteAll() {
        users.clear();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\DeliveryUseCases.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.Map;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of use cases dealing with logistics,
 * i.e. the delivery of products to a user. It is probably incomplete, and will grow over time.
 */
public interface DeliveryUseCases {
    /**
     * Delivers a product to a user. The product is identified by its id, and the user by
     * his/her name, street, city and postal code.
     * @param deliveryRecipient
     * @param deliveryContent - a map of product ids and quantities
     * @return the id of the delivery, if successfully triggered
     * @throws ShopException if ...
     *      - deliveryRecipient is null
     *      - any of the properties in deliveryRecipient (the getXxx(...) methods) return null or empty strings
     *      - deliveryContent is null or empty
     *      - the total number of products in the delivery is > 20
     */
    public UUID triggerDelivery( UserType deliveryRecipient, Map<UUID, Integer> deliveryContent );


    /**
     * Returns a map showing which products have been delivered to a user, and how many of each product
     *
     * @param userMailAddress
     * @return the delivery history of the user (map is empty if the user has not had any deliveries yet)
     * @throws ShopException if
     *      - mailAddress is null
     *      - the user with the given mail address does not exist
     */
    public Map<UUID, Integer> getDeliveryHistory( MailAddressType userMailAddress );



    /**
     *  Deletes all delivery history.
     */
    public void deleteDeliveryHistory();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MailAddressType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface MailAddressType {
    /**
     * @return the mail address as a string
     */
    public String toString();

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an mail address, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param mailAddressAsString - the mail address as a string.
     *      We will use a much simplified validation method to check if the mail address is valid:
     *      - it must contain exactly one '@' character.
     *      - the part before the '@' and the part after the '@' must not be empty, contain of
     *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
     *      - the parts before and after the '@' may contain one or several '.' as separators
     *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
     *      - the part after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
     *        (for simplicity we do not allow any other domains)
     * @return a new MailAddressType object matching the given mail address
     * @throws ShopException if ...
     *      - mailAddressAsString is null
     *      - mailAddressAsString is not a valid mail address (see above)
     */
     // public static MailAddressType of( String mailAddressAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MoneyType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface MoneyType {
    /**
     * @return the amount of money
     */
    public Float getAmount();


    /**
     * @return the currency of the money
     */
    public String getCurrency();


    /**
     * @param otherMoney
     * @return this + otherMoney, as a new object
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currency != this.currency
     */
    public MoneyType add( MoneyType otherMoney );


    /**
     * @param otherMoney
     * @return this - otherMoney, as a new object
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currency != this.currency
     *      - otherMoney > this
     */
    public MoneyType subtract( MoneyType otherMoney );


    /**
     * @param factor
     * @return this * factor, as a new object
     * @throws ShopException if ...
     *     - factor < 0
     */
    public MoneyType multiplyBy( int factor );

    /**
     * @param otherMoney
     * @return true, if this > otherMoney
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currency != this.currency
     */
    public boolean largerThan( MoneyType otherMoney );


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates a money object from an amount and a currency (as string).
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param amount the amount of money (must be >= 0)
     * @param currency the currency of the money (allowed values: "EUR", "CHF")
     * @return a new Money object with the given amount and currency
     * @throws ShopException if ...
     *   - amount is null
     *   - amount < 0
     *   - currency is null
     *   - currency is not one of the allowed values
     */
     // public static MoneyType of( Float amount, String currency );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PersonalAddressType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface PersonalAddressType {
    /**
     * @return the street as a string
     */
    public String getStreet();

    /**
     * @return the city as a string
     */
    public String getCity();

    /**
     * @return the postal code
     */
    public PostalCodeType getPostalCode();

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an postal code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param street the street as a string
     * @param city the city as a string
     * @param postalCode the postal code
     * @return the personalAddress object matching the parameters
     * @throws ShopException if ...
     *      - street is null or empty
     *      - city is null or empty
     *      - postalCode is null
     */
     // public static PersonalAddressType of( String street, String city, PostalCodeType postalCode );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PostalCodeType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface PostalCodeType {
    /**
     * @return the postal code as a string
     */
    public String toString();

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an postal code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param postalCodeAsString - the postal code as a string.
     *      We will use a much simplified validation method to check if the postal code is valid:
     *      - It must contain exactly 5 digits.
     *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid postal code, but 20001 is valid)
     * @return a new postal code object matching the given string
     * @throws ShopException if ...
     *      - postalCodeAsString is null
     *      - postalCodeAsString is not a valid postal code (see above)
     */
     // public static PostalCodeType of( String postalCodeAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\InventoryManagementUseCases.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;

import java.util.UUID;


/**
 * This interface contains methods needed in the context of use cases dealing with managing the shop inventory,
 * i.e. adding and removing products in the warehouse. The interface is probably incomplete, and
 * will grow over time.
 */
public interface InventoryManagementUseCases {
    /**
     * Adds a certain quantity of a given product to the inventory
     * @param productId
     * @param addedQuantity
     * @throws ShopException if ...
     *      - productId is null
     *      - the product with that id does not exist
     *      - addedQuantity <= 0
     */
    public void addToInventory( UUID productId, int addedQuantity );


    /**
     * Removes a certain quantity of a given product from the inventory.
     * If the new total quantity is lower than the currently reserved products, some of currently reserved products
     * (in the users' shopping baskets) are removed. This means that some of the reserved products are lost for
     * the user. (This is necessary because there probably was a mistake in the inventory management, a mis-counting,
     * or some of the products were stolen from the warehouse, are broken, etc.)
     * @param productId
     * @param removedQuantity
     * @throws ShopException if ...
     *      - productId is null
     *      - the product with that id does not exist
     *      - removedQuantity <= 0
     *      - the removed quantity is greater than the current inventory and the currently reserved products together
     */
    public void removeFromInventory( UUID productId, int removedQuantity );


    /**
     * Changes the total quantity of a given product in the inventory.
     * If the new total quantity is lower than the currently reserved products, some of currently reserved products
     * (in the users' shopping baskets) are removed. This means that some of the reserved products are lost for
     * the user. (This is necessary because there probably was a mistake in the inventory management, a mis-counting,
     * or some of the products were stolen from the warehouse, are broken, etc.)
     * @param productId
     * @param newTotalQuantity
     * @throws ShopException if ...
     *      - productId is null
     *      - the product with that id does not exist
     *      - newTotalQuantity < 0
     */
    public void changeInventoryTo( UUID productId, int newTotalQuantity );


    /**
     * Get the current total inventory of a given product, including the currently reserved products
     * @param productId
     * @return the current total inventory of the product
     * @throws ShopException if ...
     *      - productId is null
     *      - the product with that id does not exist
     */
    public int getAvailableInventory( UUID productId );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\PaymentUseCases.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;

/**
 * This interface contains methods needed in the context of use cases dealing with payments.
 */
public interface PaymentUseCases {

    /**
     * Authorizes a payment from a bank card for a given amount
     *
     * @param userMailAddress
     * @param moneyAmount
     * @return the id of the payment, if successfully authorized
     * @throws ShopException if ...
     *      - userMailAddress is null
     *      - the amount is null
     *      - the amount is 0.00 EUR
     *      - the payment cannot be processed, because it is over the limit of 500.00 EUR
     */
    public UUID authorizePayment( MailAddressType userMailAddress, MoneyType moneyAmount );


    /**
     * Returns the total amount of payments (over the complete history) for a user
     * (identified by his/her mail address)
     *
     * @param userMailAddress
     * @return the total amount of payments made using this bank card, or 0.00 EUR if there
     *         weren't any payments yet.
     * @throws ShopException if ...
     *      - userMailAddress is null
     */
    public MoneyType getPaymentTotal( MailAddressType userMailAddress );


    /**
     * Deletes all payment history, for all users.
     */
    public void deletePaymentHistory();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\ProductCatalogUseCases.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;


/**
 * This interface contains methods needed in the context of use cases dealing with managing the product catalog.
 * The interface is probably incomplete, and will grow over time.
 */

public interface ProductCatalogUseCases {
    /**
     * Adds a new product to the shop catalog
     * @param productId
     * @param name
     * @param description
     * @param size
     * @param purchasePrice
     * @param sellPrice
     * @throws ShopException if ...
     *      - productId is null,
     *      - the product with that id already exists,
     *      - name or description are null or empty,
     *      - the size is <= 0 (but can be null!),
     *      - the purchase price is null,
     *      - the sell price is null,
     *      - the sell price is lower than the purchase price
     */
    public void addProductToCatalog( UUID productId, String name, String description, Float size,
                                           MoneyType purchasePrice, MoneyType sellPrice );


    /**
     * Removes a product from the shop catalog
     * @param productId
     * @throws ShopException if
     *      - productId is null,
     *      - the product with that id does not exist
     *      - the product is still in inventory
     *      - the product is still reserved in a shopping basket, or part of a completed order
     */
    public void removeProductFromCatalog( UUID productId );


    /**
     * Get the sell price of a given product
     * @param productId
     * @return the sell price
     * @throws ShopException if ...
     *      - productId is null,
     *      - the product with that id does not exist
     */
    public MoneyType getSellPrice( UUID productId );


    /**
     * Clears the product catalog, i.e. removes all products from the catalog, including all the inventory,
     * all the reservations and all the orders.
     */
    public void deleteProductCatalog();

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingBasketUseCases.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.Map;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of use cases dealing with the shopping basket.
 * The interface is probably incomplete, and will grow over time.
 */
public interface ShoppingBasketUseCases {
    /**
     * Adds a product to the shopping basket of a user
     *
     * @param userMailAddress
     * @param productId
     * @param quantity
     * @throws ShopException if ...
     *      - the user with the given mailAddress does not exist,
     *      - the product does not exist,
     *      - the quantity <= 0,
     *      - the product is not available in the requested quantity
     */
    public void addProductToShoppingBasket( MailAddressType userMailAddress, UUID productId, int quantity );


    /**
     * Removes a product from the shopping basket of a user
     *
     * @param userMailAddress
     * @param productId
     * @param quantity
     * @throws ShopException if ...
     *      - userMailAddress is null,
     *      - the user with the given mailAddress does not exist,
     *      - the product does not exist
     *      - the quantity <= 0,
     *      - the product is not in the shopping basket in the requested quantity
     */
    public void removeProductFromShoppingBasket( MailAddressType userMailAddress, UUID productId, int quantity );


    /**
     * Sets a comment in the shopping basket position containing a product
     *
     * @param userMailAddress
     * @param productId
     * @param comment (can be null)
     * @throws ShopException if ...
     *      - userMailAddress is null,
     *      - the user with the given mailAddress does not exist,
     *      - the product does not exist
     *      - the product is not in the shopping basket
     */
    public void setCommentForShoppingBasketPosition( MailAddressType userMailAddress, UUID productId, String comment );


    /**
     * Returns the comment in the shopping basket position containing a product
     *
     * @param userMailAddress
     * @param productId
     * @return the comment (can be null)
     * @throws ShopException if ...
     *      - userMailAddress is null,
     *      - the user with the given mailAddress does not exist,
     *      - the product does not exist
     *      - the product is not in the shopping basket
     */
    public String getCommentForShoppingBasketPosition( MailAddressType userMailAddress, UUID productId );


    /**
     * Returns a map showing which products are in the shopping basket of a user and how many of each product
     *
     * @param userMailAddress
     * @return the shopping basket of the user (map is empty if the shopping basket is empty)
     * @throws ShopException if ...
     *      - userMailAddress is null,
     *      - the user with the given mailAddress does not exist
     */
    public Map<UUID, Integer> getShoppingBasketAsMap( MailAddressType userMailAddress );


    /**
     * Returns the current value of all products in the shopping basket of a user
     *
     * @param userMailAddress
     * @return the value of shopping basket of the user
     * @throws ShopException if ...
     *      - userMailAddress is null,
     *      - the user with the given mailAddress does not exist
     */
    public MoneyType getShoppingBasketAsMoneyValue( MailAddressType userMailAddress );



    /**
     * Get the number units of a specific product that are currently reserved in the shopping baskets of all users
     * @param productId
     * @return the number of reserved products of that type in all shopping baskets
     * @throws ShopException
     *      - productId is null
     *      - if the product id does not exist
     */
    public int getReservedInventoryInShoppingBaskets( UUID productId );


    /**
     * Checks if the shopping basket of a user is empty
     *
     * @param userMailAddress
     * @return true if the shopping basket is empty, false otherwise
     * @throws ShopException if ...
     *    - userMailAddress is null
     *    - the user with the given mail address does not exist
     */
    public boolean isEmpty( MailAddressType userMailAddress );


    /**
     * Checks if the payment for a specific shopping basket of a user has been authorized to be paid,
     * i.e. the shopping basket is not empty, the user has given his/her payment details, and the payment
     * has been authorized (under the limits of the user's credit card). However, the order
     * has not yet been placed yet, and the logistics details have not yet been given.
     *
     * @param userMailAddress
     * @return true if the payment has been authorized, false otherwise
     * @throws ShopException if ...
     *      - userMailAddress is null
     *      - the user with the given mail address does not exist
     */
    public boolean isPaymentAuthorized( MailAddressType userMailAddress );


    /**
     * Checks out the shopping basket of a user
     *
     * @param userMailAddress
     * @throws ShopException if ... 
     * @throws ShopException if ...
     *      - userMailAddress is null
     *      - the user with the given mail address does not exist
     *      - the shopping basket is empty
     */
    public void checkout( MailAddressType userMailAddress );




    /**
     * Returns a map showing which products have been ordered by a user, and how many of each product
     *
     * @param userMailAddress
     * @return the order history of the user (map is empty if the user has not ordered anything yet)
     * @Deprecated Might be split into a dedicated OrderUseCases interface later (but still valid in this milestone)
     * @throws ShopException if
     *      - the mail address is null
     *      - the user with the given mail address does not exist
     */
    public Map<UUID, Integer> getOrderHistory( MailAddressType userMailAddress );



    /**
     * Deletes all orders and shopping baskets in the system
     * @Deprecated Might be split into two methods later (delete orders and delete shopping baskets), with
     *             the order deletion moved to a dedicated OrderUseCases interface later
     *             (but still valid in this milestone)
     */
    public void deleteAllOrders();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\UserRegistrationUseCases.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;

/**
 * This interface contains methods needed in the context of use cases dealing with registering a user.
 * The interface is probably incomplete, and will grow over time.
 */
public interface UserRegistrationUseCases {
    /**
     * Registers a new user
     *
     * @param name
     * @param mailAddress
     * @param personalAddress
     * @throws ShopException if ...
     *      - name is null or empty
     *      - mailAddress is null
     *      - user with the given mail address already exists
     *      - personalAddress is null
     */
    public void register( String name, MailAddressType mailAddress, PersonalAddressType personalAddress );


    /**
     * Changes the personalAddress of a user
     *
     * @param userMailAddress
     * @param personalAddress
     * @throws ShopException if ...
     *      - mailAddress is null
     *      - user with the given mail address already exists
     *      - personalAddress is null
     */
    public void changeAddress( MailAddressType userMailAddress, PersonalAddressType personalAddress );


    /**
     * Returns the data of a user
     * @param userMailAddress
     * @return the user data
     * @throws ShopException if ...
     *      - mailAddress is null
     *      - the user with the given mail address does not exist
     */
    public UserType getUserData( MailAddressType userMailAddress );



    /**
     * Deletes all users, including all orders and shopping baskets
     */
    public void deleteAllUsers();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\main\java\thkoeln\archilab\ecommerce\usecases\UserType.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;

/**
 * This interface expresses the essence of a shop user
 */
public interface UserType {
    public String getName();
    public MailAddressType getMailAddress();
    public PersonalAddressType getPersonalAddress();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\codereview\E3DDDOutsideSolutionRulesTest.java ---
package thkoeln.archilab.ecommerce.codereview;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.library.Architectures.layeredArchitecture;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln")
@SuppressWarnings("PMD")
public class E3DDDOutsideSolutionRulesTest {

    @ArchTest
    static final ArchRule noClassesOutsideSolutionAndDomainprimitives =
            layeredArchitecture()
                    .consideringAllDependencies()
                    .layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
                    .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
                    .layer( "Test1" ).definedBy( "thkoeln.archilab.ecommerce.codereview.." )
                    .layer( "Test2" ).definedBy( "thkoeln.archilab.ecommerce.e1e2resttests.." )
                    .layer( "Test3" ).definedBy( "thkoeln.archilab.ecommerce.regression.." )

                    .whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers( "SolutionClasses", "Test1", "Test2", "Test3" )
                    .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Test1", "Test2", "Test3" );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\codereview\E3DDDRulesTest.java ---
package thkoeln.archilab.ecommerce.codereview;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Service;

import javax.persistence.Entity;
import javax.persistence.Id;

import java.util.UUID;

import static com.tngtech.archunit.core.domain.JavaMember.Predicates.declaredIn;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.*;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class E3DDDRulesTest {

    @ArchTest
    static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
            noClasses().that().resideInAPackage("..domain..")
                    .should().dependOnClassesThat().resideInAPackage("..application..");

    @ArchTest
    static final ArchRule entitiesMustResideInADomainPackage =
            classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage("..domain..")
                    .as("Entities must reside in a package '..domain..'");

    @ArchTest
    static final ArchRule entitiesMustNotAccessRepositories =
            noClasses().that().areAnnotatedWith( Entity.class )
                    .should().dependOnClassesThat().areAssignableTo( CrudRepository.class );

    @ArchTest
    static final ArchRule repositoriesMustResideInADomainPackage =
            classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage("..domain..")
                    .as("Repositories must reside in a package '..domain..'");

    @ArchTest
    static final ArchRule repositoryNamesMustHaveProperSuffix =
            classes().that().areAssignableTo( CrudRepository.class )
                    .should().haveSimpleNameEndingWith("Repository");

    @ArchTest
    static final ArchRule servicesMustResideInAnApplicationPackage =
            classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage("..application..")
                    .as("Application Services must reside in a package '..application..'");

    @ArchTest
    static final ArchRule serviceNamesMustHaveProperSuffix =
            classes().that().areAnnotatedWith( Service.class )
                    .should().haveSimpleNameEndingWith("Service");

    @ArchTest
    static final ArchRule noClassesOnTopLevel =
            classes().should().resideInAPackage( "..solution.*.." );

    @ArchTest
    static final ArchRule noNonIdFieldsOfTypeIUUID =
            fields()
                    .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
                    .and().areNotAnnotatedWith( Id.class )
                    .and().areDeclaredInClassesThat().doNotHaveSimpleName( "Product" )
                    .should().notHaveRawType( UUID.class );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\codereview\E3NoCycleTest.java ---
package thkoeln.archilab.ecommerce.codereview;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.library.dependencies.SliceAssignment;
import com.tngtech.archunit.library.dependencies.SliceIdentifier;
import org.junit.jupiter.api.Test;

import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;

public class E3NoCycleTest {
    private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");

    private SliceAssignment inAllClasses() {
        return new SliceAssignment() {
            @Override
            public String getDescription() {
                return "every class in it's own slice";
            }

            @Override
            public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
                return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
            }
        };
    }

    @Test
    public void testNoCyclicDependenciesBetweenClasses() {
        slices().assignedFrom(inAllClasses())
                .namingSlices("$1[$2.$3]")
                .should().beFreeOfCycles()
                .check(importedClasses);
    }

    @Test
    public void testNoCyclicDependenciesBetweenPackages() {
        ArchRule rule = slices().matching("..solution.(*)..").should().beFreeOfCycles();
        rule.check(importedClasses);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\codereview\E3PackageStructureTest.java ---
package thkoeln.archilab.ecommerce.codereview;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class E3PackageStructureTest {

    private static final String[] REQUIRED_PACKAGES = {"user", "shoppingbasket", "product", "order"};
    private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
    private JavaClasses importedClasses;


    @BeforeEach
    public void setUp() {
        importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
    }

    @Test
    void testRequiredPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage;
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredDomainPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected domain sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredApplicationPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected application sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\codereview\E3RequiredClassesTest.java ---
package thkoeln.archilab.ecommerce.codereview;

import org.junit.jupiter.api.Test;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.MetadataReaderFactory;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertTrue;

public class E3RequiredClassesTest {


    private static final String[] REQUIRED_CLASSES = {
            "User",
            "UserRepository",
            "Order",
            "OrderRepository",
            "ShoppingBasket",
            "ShoppingBasketRepository",
            "Product",
            "ProductRepository"
    };

    @Test
    public void testRequiredClassesDeclared() throws IOException {
        String basePackage = "thkoeln.archilab.ecommerce";
        String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";

        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );

        Set<String> foundClasses = new HashSet<>();

        Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
            try {
                MetadataReader reader = readerFactory.getMetadataReader( resource );
                foundClasses.add( reader.getClassMetadata().getClassName() );
            } catch (IOException e) {
                e.printStackTrace();
            }
        } );

        Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
            boolean found = foundClasses.stream().anyMatch(className ->
                    className.startsWith(basePackage) && className.endsWith("." + requiredClass)
            );
            assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
        });
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\E1OrdertRESTTest.java ---
package thkoeln.archilab.ecommerce.e1e2resttests;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import javax.transaction.Transactional;
import java.util.UUID;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.instantiateMailAddress;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.PRODUCT_DATA;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.USER_EMAIL;

@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@ActiveProfiles("test")
public class E1OrdertRESTTest {

    @Autowired
    private InitialMasterDataCreator initialMasterDataCreator;
    @Autowired
    private MockMvc mockMvc;

    private RESTHelper restHelper;
    private MailAddressType nonExistingMailAddress;


    @BeforeEach
    public void setUp() {
        initialMasterDataCreator.deleteAll();

        initialMasterDataCreator.addAllProducts();
        initialMasterDataCreator.inventoryUpAllProducts();
        initialMasterDataCreator.registerAllUsers();

        restHelper = new RESTHelper( mockMvc );
        nonExistingMailAddress = instantiateMailAddress( "harry@sally.de" );
    }


    @Test
    public void testGetNoOrders() throws Exception {
        // given
        // when
        // then
        mockMvc.perform( get( "/orders" ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.length()" ).value( 0 ) );
        mockMvc.perform( get( "/orders?mailAddress=" + nonExistingMailAddress ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.length()" ).value( 0 ) );
        mockMvc.perform( get( "/orders?mailAddress=invalidEmailString" ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.length()" ).value( 0 ) );
        mockMvc.perform( get( "/orders?mailAddress=" + USER_EMAIL[3].toString() ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.length()" ).value( 0 ) );
    }


    @Test void testMakeThreeOrders() throws Exception {
        // given
        String mailAddressString = USER_EMAIL[6].toString();

        UUID productId2 = (UUID) PRODUCT_DATA[2][0];
        UUID productId4 = (UUID) PRODUCT_DATA[4][0];
        UUID productId6 = (UUID) PRODUCT_DATA[6][0];
        Float productMoneyAmount2 = ((MoneyType) PRODUCT_DATA[2][5]).getAmount() * 2;
        Float productMoneyAmount4 = ((MoneyType) PRODUCT_DATA[4][5]).getAmount() * 4;
        Float productMoneyAmount6 = ((MoneyType) PRODUCT_DATA[6][5]).getAmount() * 6;

        String uriAllOrders = "/orders?mailAddress=" + mailAddressString;
        String uriLatestOrder = uriAllOrders + "&filter=latest";

        // when
        restHelper.makeOrderForUser( mailAddressString, productId2, 2 );
        restHelper.makeOrderForUser( mailAddressString, productId4, 4 );
        restHelper.makeOrderForUser( mailAddressString, productId6, 6 );

        // then get all orders ...
        mockMvc.perform( get( uriAllOrders ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.length()" ).value( 3 ) )

                .andExpect( jsonPath( "$[0].mailAddress.mailAddressString" ).value( mailAddressString ) )
                .andExpect( jsonPath( "$[0].price.amount" ).value( productMoneyAmount2 ) )

                .andExpect( jsonPath( "$[1].mailAddress.mailAddressString" ).value( mailAddressString ) )
                .andExpect( jsonPath( "$[1].price.amount" ).value( productMoneyAmount4 ) )

                .andExpect( jsonPath( "$[2].mailAddress.mailAddressString" ).value( mailAddressString ) )
                .andExpect( jsonPath( "$[2].price.amount" ).value( productMoneyAmount6 ) );

        // ... and the latest order
        mockMvc.perform( get( uriLatestOrder ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.length()" ).value( 1 ) )
                .andExpect( jsonPath( "$[0].price.amount" ).value( productMoneyAmount6 ) );
    }


    @Test
    public void testIfMoneySumInOrderIsCorrect() throws Exception {
        // given
        String mailAddressString = USER_EMAIL[3].toString();
        UUID productId3 = (UUID) PRODUCT_DATA[3][0];
        UUID productId4 = (UUID) PRODUCT_DATA[4][0];
        Integer quantity3 = 14;
        Integer quantity4 = 5;
        Float productMoneyAmount =
                ((MoneyType) PRODUCT_DATA[3][5]).getAmount() * quantity3 +
                ((MoneyType) PRODUCT_DATA[4][5]).getAmount() * quantity4;

        // when
        UUID shoppingBasketId = restHelper.getShoppingBasketId( mailAddressString );
        restHelper.addProductToShoppingBasket( shoppingBasketId, productId3, quantity3 );
        restHelper.addProductToShoppingBasket( shoppingBasketId, productId4, quantity4 );
        mockMvc.perform( put( "/shoppingBaskets/" + shoppingBasketId.toString() + "/checkout" ) )
                .andExpect( status().isOk() );

        // then
        mockMvc.perform( get(
                "/orders?mailAddress=" + mailAddressString + "&filter=latest") )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.length()" ).value( 1 ) )
                .andExpect( jsonPath( "$[0].price.amount" ).value( productMoneyAmount ) );
    }



}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\E2ShoppingBasketRESTTest.java ---
package thkoeln.archilab.ecommerce.e1e2resttests;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import javax.transaction.Transactional;
import java.util.UUID;

import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static thkoeln.archilab.ecommerce.e1e2resttests.RESTHelper.CONFLICT;
import static thkoeln.archilab.ecommerce.e1e2resttests.RESTHelper.CREATED;
import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.instantiateMailAddress;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.PRODUCT_DATA;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.USER_EMAIL;

@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@ActiveProfiles("test")
public class E2ShoppingBasketRESTTest {

    @Autowired
    private InitialMasterDataCreator initialMasterDataCreator;
    @Autowired
    private MockMvc mockMvc;

    private RESTHelper restHelper;
    private MailAddressType nonExistingMailAddress;


    @BeforeEach
    public void setUp() {
        initialMasterDataCreator.deleteAll();

        initialMasterDataCreator.addAllProducts();
        initialMasterDataCreator.inventoryUpAllProducts();
        initialMasterDataCreator.registerAllUsers();

        restHelper = new RESTHelper( mockMvc );
        nonExistingMailAddress = instantiateMailAddress( "harry@sally.de" );
    }


    @Test
    public void testEmptyShoppingBasket() throws Exception {
        // given
        String validUri = "/shoppingBaskets?mailAddress=" + USER_EMAIL[4].toString();
        String invalidUri1 = "/shoppingBaskets?mailAddress=" + nonExistingMailAddress.toString();
        String invalidUri2 = "/shoppingBaskets?mailAddress=justaninvalidemailaddress";

        // when
        // then
        mockMvc.perform( get( validUri ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.totalQuantity" ).value( 0 ) );
        mockMvc.perform( get( invalidUri1 ) )
                .andExpect( status().isNotFound() );
        mockMvc.perform( get( invalidUri2 ) )
                .andExpect( status().isNotFound() );
    }


    @Test
    public void testInvalidUris() throws Exception {
        // given
        UUID productId = (UUID) PRODUCT_DATA[3][0];
        String userEmailString = USER_EMAIL[4].toString();
        UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );

        String invalidPostUri = "/shoppingBaskets/" + UUID.randomUUID() + "/shoppingBasketPositions";
        String invalidPatchGetDeleteUri1 =
                "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions/" + UUID.randomUUID();
        String invalidPatchGetDeleteUri2 =
                "/shoppingBaskets/" + UUID.randomUUID().toString() + "/shoppingBasketPositions/" + productId;
        String invalidCheckoutUri1 = "/shoppingBaskets/" + shoppingBasketId + "/chekkout";
        String invalidCheckoutUri2 = "/shoppingBaskets/" + UUID.randomUUID() + "/checkout";

        // when
        // then
        mockMvc.perform( post( invalidPostUri )
                .contentType( APPLICATION_JSON ).content( "[]" ) ).andExpect( status().is4xxClientError() );

        mockMvc.perform( delete( invalidPatchGetDeleteUri1 ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( invalidPatchGetDeleteUri1 ) ).andExpect( status().isNotFound() );

        mockMvc.perform( delete( invalidPatchGetDeleteUri2 ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( invalidPatchGetDeleteUri2 ) ).andExpect( status().isNotFound() );

        mockMvc.perform( put( invalidCheckoutUri1 ) ).andExpect( status().isNotFound() );
        mockMvc.perform( put( invalidCheckoutUri2 ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testQueryNonExistingProduct() throws Exception {
        // given
        UUID productId = (UUID) PRODUCT_DATA[3][0];
        String userEmailString = USER_EMAIL[7].toString();
        UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
        String invalidUri = "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions/" + productId;

        // when
        // then
        mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testDeleteFromShoppingBasket() throws Exception {
        // given
        UUID productId1 = (UUID) PRODUCT_DATA[1][0];
        String userEmailString9 = USER_EMAIL[9].toString();
        String userEmailString7 = USER_EMAIL[7].toString();

        UUID shoppingBasketId9 = restHelper.getShoppingBasketId( userEmailString9 );
        UUID shoppingBasketId7 = restHelper.getShoppingBasketId( userEmailString7 );

        String baseUri9 = "/shoppingBaskets/" + shoppingBasketId9 + "/shoppingBasketPositions/";
        String checkoutUri9 = "/shoppingBaskets/" + shoppingBasketId9 + "/checkout";
        String checkoutUri7 = "/shoppingBaskets/" + shoppingBasketId7 + "/checkout";

        // when
        restHelper.addMultipleProductsToShoppingBasket( userEmailString9,
                new Integer[]{1, 4, 6}, new Integer[]{1, 4, 6}, new String[]{"c1", "c4", "c6"} );
        restHelper.checkMultipleShoppingBasketPositions(
                userEmailString9, new Integer[]{1, 4, 6}, new Integer[]{1, 4, 6},
                new String[]{"c1", "c4", "c6"} );
        mockMvc.perform( delete( baseUri9 + productId1 ) )
                .andExpect( status().isOk() );
        restHelper.checkMultipleShoppingBasketPositions(
                userEmailString9, new Integer[]{1, 4, 6}, new Integer[]{null, 4, 6},
                new String[]{null, "c4", "c6"}, new Boolean[]{false, true, true} );
        // ... and another customer can still buy 10 of the "Nr. 1" product
        restHelper.addProductToShoppingBasket( shoppingBasketId7, productId1, 10,
                "still10", null );

        // then
        mockMvc.perform( put( checkoutUri9 ) ).andExpect( status().isOk() );
        restHelper.checkMultipleOrderPositionsInLatestOrder( userEmailString9,
                new Integer[]{4, 6}, new Integer[]{4, 6}, new String[]{"c4", "c6"} );
        mockMvc.perform( put( checkoutUri7 ) ).andExpect( status().isOk() );
        restHelper.checkMultipleOrderPositionsInLatestOrder( userEmailString7,
                new Integer[]{1}, new Integer[]{10}, new String[]{"still10"} );
    }


    @Test
    public void testAddToAndRemoveFromShoppingBasket() throws Exception {
        // given
        String userEmailString = USER_EMAIL[2].toString();
        UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
        String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";

        // when
        restHelper.addMultipleProductsToShoppingBasket( userEmailString,
                new Integer[]{2, 4, 2, 4, 6, 2}, new Integer[]{2, 3, 4, -1, 3, -6},
                new String[]{null, "c4a", "c2a", "c4b", "c6", null} );
        restHelper.checkMultipleShoppingBasketPositions(
                userEmailString, new Integer[]{2, 4, 6}, new Integer[]{null, 2, 3},
                new String[]{null, "c4b", "c6"}, new Boolean[]{false, true, true} );

        // then
        mockMvc.perform( put( checkoutUri ) ).andExpect( status().isOk() );
        restHelper.checkMultipleOrderPositionsInLatestOrder( userEmailString,
                new Integer[]{4, 6}, new Integer[]{2, 3}, new String[]{"c4b", "c6"} );
    }


    @Test
    public void testRemoveMoreThanThereIsInShoppingBasket() throws Exception {
        // given
        String userEmailString = USER_EMAIL[2].toString();

        // when
        // then
        restHelper.addMultipleProductsToShoppingBasket( userEmailString,
                new Integer[]{2, 4, 2}, new Integer[]{2, 3, -3}, new String[]{null, null, null},
                new ResultMatcher[]{CREATED, CREATED, CONFLICT} );
    }


    @Test
    public void testAddMoreThanIsInInventory() throws Exception {
        // given
        String userEmailString = USER_EMAIL[7].toString();

        // when
        // then
        restHelper.addMultipleProductsToShoppingBasket( userEmailString,
                new Integer[]{1, 1, 1, 1}, new Integer[]{2, 3, 4, 2}, new String[]{null, null, null, null},
                new ResultMatcher[]{CREATED, CREATED, CREATED, CONFLICT} );
    }


    @Test
    public void testSuccessfulCheckoutJustWithinPaymentLimit() throws Exception {
        // given
        String userEmailString = USER_EMAIL[5].toString();
        UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
        String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";

        // when
        restHelper.addMultipleProductsToShoppingBasket( userEmailString,
                new Integer[]{11, 13, 10, 6}, new Integer[]{1, 1, 1, 17}, new String[]{"350€", "100€", "35€", "8.50€"} );

        // then
        mockMvc.perform( put( checkoutUri ) ).andExpect( status().isOk() );
        restHelper.checkMultipleOrderPositionsInLatestOrder( userEmailString,
                new Integer[]{11, 13, 10, 6}, new Integer[]{1, 1, 1, 17}, new String[]{"350€", "100€", "35€", "8.50€"} );
    }



    @Test
    public void testUnsuccessfulCheckoutAbovePaymentLimit() throws Exception {
        // given
        String userEmailString = USER_EMAIL[1].toString();
        UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
        String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";

        // when
        restHelper.addMultipleProductsToShoppingBasket( userEmailString,
                new Integer[]{13, 10}, new Integer[]{4, 3}, new String[]{"400€", "105€"} );

        // then
        mockMvc.perform( put( checkoutUri ) ).andExpect( status().isConflict() );
    }


    @Test
    public void testUnsuccessfulCheckoutAboveDeliveryLimit() throws Exception {
        // given
        String userEmailString = USER_EMAIL[8].toString();
        UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
        String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";

        // when
        restHelper.addMultipleProductsToShoppingBasket( userEmailString,
                new Integer[]{13, 6}, new Integer[]{3, 18}, new String[]{"300€", "9€"} );

        // then
        mockMvc.perform( put( checkoutUri ) ).andExpect( status().isConflict() );
    }


    @Test
    public void testNoCheckoutForEmptyShoppingBasket() throws Exception {
        // given
        String userEmailString = USER_EMAIL[9].toString();
        UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
        String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";

        // when
        // then
        mockMvc.perform( put( checkoutUri ) ).andExpect( status().isConflict() );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\RESTHelper.java ---
package thkoeln.archilab.ecommerce.e1e2resttests;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.e1e2resttests.testdtos.IdDTO;
import thkoeln.archilab.ecommerce.e1e2resttests.testdtos.QuantityAndCommentDTO;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.PRODUCT_DATA;

public class RESTHelper {
    private MockMvc mockMvc;

    public static final ResultMatcher NOT_FOUND = status().isNotFound();
    public static final ResultMatcher OK = status().isOk();
    public static final ResultMatcher CREATED = status().isCreated();
    public static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
    public static final ResultMatcher CONFLICT = status().isConflict();

    public RESTHelper( MockMvc mockMvc ) {
        this.mockMvc = mockMvc;
    }

    public void makeOrderForUser( String mailAddressString, UUID productId, Integer quantity ) throws Exception {
        UUID shoppingBasketId = getShoppingBasketId( mailAddressString );
        addProductToShoppingBasket( shoppingBasketId, productId, quantity );
        mockMvc.perform( put( "/shoppingBaskets/" + shoppingBasketId.toString() + "/checkout" ) )
                .andExpect( OK );
    }

    public UUID getShoppingBasketId( String mailAddressString ) throws Exception {
        // get the shopping basket and extract its id ...
        MvcResult shoppingBasket = mockMvc.perform( get( "/shoppingBaskets?mailAddress=" + mailAddressString ) )
                .andExpect( OK )
                .andExpect( jsonPath( "$.id" ).isNotEmpty() )
                .andReturn();
        ObjectMapper objectMapper = new ObjectMapper();
        IdDTO idDTO = objectMapper.readValue( shoppingBasket.getResponse().getContentAsString(), IdDTO.class );
        return idDTO.getId();
    }

    public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity,
                                                 String comment, ResultMatcher expectedStatus )
                                                throws Exception {
        ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
        ObjectMapper objectMapper = new ObjectMapper();
        QuantityAndCommentDTO dto = new QuantityAndCommentDTO( productId, quantity, comment );
        String quantityJson = objectMapper.writeValueAsString( dto );
        mockMvc.perform( post( "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions" )
                .contentType( APPLICATION_JSON ).content( quantityJson ) )
                .andExpect( status );
    }


    public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity )
            throws Exception {
        addProductToShoppingBasket( shoppingBasketId, productId, quantity, null, null );
    }



    public void addMultipleProductsToShoppingBasket(
            String userEmailString, Integer[] productIndices, Integer[] quantities, String[] comments,
            ResultMatcher[] expectedAddStatuses ) throws Exception {
        UUID shoppingBasketId = getShoppingBasketId( userEmailString );
        String shoppingBasketUri = "shoppingBaskets?mailAddress=" + userEmailString;
        String baseUri = "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions/";

        // add all the products to the shopping basket ...
        Map<Integer, Integer> quantityMap = new HashMap<>();
        Map<Integer, String> commentMap = new HashMap<>();
        for ( int i = 0; i < productIndices.length; i++ ) {
            UUID productId = (UUID) PRODUCT_DATA[productIndices[i]][0];
            addProductToShoppingBasket( shoppingBasketId, productId, quantities[i], comments[i], expectedAddStatuses[i] );
            if ( expectedAddStatuses[i] != null || expectedAddStatuses[i] == CREATED || expectedAddStatuses[i] == OK ) {
                quantityMap.put( productIndices[i],
                        quantities[i] + quantityMap.getOrDefault( productIndices[i], 0 ) );
                commentMap.put( productIndices[i], comments[i] );
            }
        }
    }


    public void addMultipleProductsToShoppingBasket(
            String userEmailString, Integer[] productIndices, Integer[] quantities,
            String[] comments ) throws Exception {
        ResultMatcher[] expectedAddStatuses = new ResultMatcher[productIndices.length];
        for ( int i = 0; i < productIndices.length; i++ ) {
            expectedAddStatuses[i] = CREATED;
        }
        addMultipleProductsToShoppingBasket( userEmailString, productIndices, quantities,
                comments, expectedAddStatuses );
    }


    public void checkMultipleShoppingBasketPositions( String userEmailString,
                                                         Integer[] productIndices, Integer[] expectedQuantities,
                                                         String[] expectedComments, Boolean[] expectedToBeFound ) throws Exception {
        UUID shoppingBasketId = getShoppingBasketId( userEmailString );
        String shoppingBasketUri = "/shoppingBaskets?mailAddress=" + userEmailString;
        String baseUri = "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions/";

        // check that the shopping basket contains all the products ...
        int totalQuantity = 0;
        for ( int i = 0; i < productIndices.length; i++ ) {
            if ( expectedQuantities[i] != null ) {
                totalQuantity += expectedQuantities[i];
            }
        }
        mockMvc.perform( get( shoppingBasketUri ) )
                .andExpect( OK )
                .andExpect( jsonPath( "$.totalQuantity" ).value( totalQuantity ) );

        // check that each product has the correct quantity and comment ...
        for ( int i = 0; i < productIndices.length; i++ ) {
            UUID productId = (UUID) PRODUCT_DATA[productIndices[i]][0];
            if ( expectedToBeFound[i] ) {
                mockMvc.perform( get( baseUri + productId ) )
                        .andExpect( OK )
                        .andExpect( jsonPath( "$.quantity" ).value( expectedQuantities[i] ) )
                        .andExpect( jsonPath( "$.comment" ).value( expectedComments[i] ) );
            } else {
                mockMvc.perform( get( baseUri + productId ) )
                        .andExpect( NOT_FOUND );
            }
        }
    }


    public void checkMultipleShoppingBasketPositions( String userEmailString,
                                                         Integer[] productIndices, Integer[] expectedQuantities,
                                                         String[] expectedComments ) throws Exception {
        Boolean[] expectedToBeFound = new Boolean[productIndices.length];
        for ( int i = 0; i < productIndices.length; i++ ) {
            expectedToBeFound[i] = true;
        }
        checkMultipleShoppingBasketPositions( userEmailString, productIndices, expectedQuantities,
                expectedComments, expectedToBeFound );
    }



    public void checkMultipleOrderPositionsInLatestOrder(
            String userEmailString, Integer[] productIndices, Integer[] expectedQuantities,
            String[] expectedComments ) throws Exception {
        String latestOrderUri = "/orders?mailAddress=" + userEmailString + "&filter=latest";

        // Calculate the total price of the order ...
        float totalPrice = 0f;
        for ( int i = 0; i < productIndices.length; i++ ) {
            totalPrice += expectedQuantities[i] * ((MoneyType) PRODUCT_DATA[productIndices[i]][5]).getAmount();
        }

        // ... and check that the order has the correct total price (and other data)
        ResultActions resultActions = mockMvc.perform( get( latestOrderUri ) ).andExpect( OK )
                .andExpect( jsonPath( "$.length()" ).value( 1 ) )
                .andExpect( jsonPath( "$[0].price.amount" ).value( totalPrice ) )
                .andExpect( jsonPath( "$[0].mailAddress.mailAddressString" ).value( userEmailString ) );

        // Now check that all the expected parts are there
        for ( int i = 0; i < productIndices.length; i++ ) {
            UUID productId = (UUID) PRODUCT_DATA[productIndices[i]][0];
            resultActions.andExpect(
                    jsonPath( "$[0].orderPositions.length()" ).value( productIndices.length ) );
            resultActions.andExpect(
                    jsonPath( "$[0].orderPositions[?(@.productId == '" + productId + "')].quantity" )
                            .value( expectedQuantities[i] ) );
            if ( expectedComments[i] != null ) {
                resultActions.andExpect(
                        jsonPath( "$[0].orderPositions[?(@.productId == '" + productId + "')].comment" )
                                .value( expectedComments[i] ) );
            }
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\testdtos\CommentDTO.java ---
package thkoeln.archilab.ecommerce.e1e2resttests.testdtos;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.*;

import java.util.UUID;

/**
 * A DTO containing just a comment, used in testing.
 */

@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
@ToString
@JsonIgnoreProperties(ignoreUnknown = true)
public class CommentDTO {
    private UUID productId;
    private String comment;
}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\testdtos\IdDTO.java ---
package thkoeln.archilab.ecommerce.e1e2resttests.testdtos;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.*;

import java.util.UUID;

/**
 * A DTO containing just the id of an entity, used in testing.
 */

@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
@ToString
@JsonIgnoreProperties(ignoreUnknown = true)
public class IdDTO {
    private UUID id;
}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\testdtos\QuantityAndCommentDTO.java ---
package thkoeln.archilab.ecommerce.e1e2resttests.testdtos;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.*;

import java.util.UUID;

/**
 * A DTO containing just a quantity, used in testing.
 */


@NoArgsConstructor
@Setter
@Getter
@ToString
@JsonIgnoreProperties(ignoreUnknown = true)
public class QuantityAndCommentDTO {
    private UUID productId;
    private Integer quantity;
    private String comment;

    public QuantityAndCommentDTO( UUID productId, Integer quantity, String comment ) {
        this.productId = productId;
        this.quantity = quantity;
        this.comment = comment;
    }
}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionMailAddressTest.java ---
package thkoeln.archilab.ecommerce.regression.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;

class RegressionMailAddressTest {

    @Test
    public void testToString() {
        // given
        String input = "test@example.com";

        // when
        MailAddressType instance = instantiateMailAddress( input );

        // then
        assertEquals( input, instance.toString() );
    }

    @Test
    public void testFactoryMethodValid() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiateMailAddress( "test@example.com" ) );
        assertDoesNotThrow( () -> instantiateMailAddress( "99Z@example.com" ) );
        assertDoesNotThrow( () -> instantiateMailAddress( "GGGhh@s77.com" ) );
        assertDoesNotThrow( () -> instantiateMailAddress( "a@4.com" ) );
        assertDoesNotThrow( () -> instantiateMailAddress( "Max.Hammer@example.com" ) );
        assertDoesNotThrow( () -> instantiateMailAddress( "Max.Gideon.Hammer@example.com" ) );
        assertDoesNotThrow( () -> instantiateMailAddress( "test@example.this.com" ) );
        assertDoesNotThrow( () -> instantiateMailAddress( "test@example.de" ) );
        assertDoesNotThrow( () -> instantiateMailAddress( "test@example.at" ) );
        assertDoesNotThrow( () -> instantiateMailAddress( "test@example.ch" ) );
        assertDoesNotThrow( () -> instantiateMailAddress( "test@example.org" ) );
    }

    @Test
    public void testFactoryMethodInvalid() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateMailAddress( null ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "testexample.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "Max..Gideon.Hammer@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@examplecom" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example..com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test#example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.42" ) );
    }

    @Test
    public void testValueObjectEquality() {
        // given
        // when
        MailAddressType instance1 = instantiateMailAddress( "test@example.com" );
        MailAddressType instance2 = instantiateMailAddress( "test@example.com" );
        MailAddressType instance3 = instantiateMailAddress( "different@example.com" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutability() {
        // given
        // when
        MailAddressType instance = instantiateMailAddress( "test@example.com" );

        // then
        try {
            instance.getClass().getMethod( "setMailAddress", String.class );
            fail( "setMailAddress method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionMoneyTest.java ---
package thkoeln.archilab.ecommerce.regression.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;

class RegressionMoneyTest {

    @Test
    public void testGetAmount() {
        // given
        Float inputAmount = 10.0f;

        // when
        MoneyType instance = instantiateMoney( inputAmount, "EUR" );

        // then
        assertEquals( inputAmount, instance.getAmount() );
    }

    @Test
    public void testGetCurrency() {
        // given
        String inputCurrency = "EUR";

        // when
        MoneyType instance = instantiateMoney( 10.0f, inputCurrency );

        // then
        assertEquals( inputCurrency, instance.getCurrency() );
    }

    @Test
    public void testAddTo() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );

        // when
        MoneyType result12 = instance1.add( instance2 );
        MoneyType result13 = instance1.add( instance3 );

        // then
        assertEquals( 30.0f, result12.getAmount() );
        assertEquals( "EUR", result12.getCurrency() );
        assertEquals( 10.0f, result13.getAmount() );
        assertEquals( "EUR", result12.getCurrency() );
    }

    @Test
    public void testInvalidAddTo() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
    }

    @Test
    public void testSubtractFrom() {
        // given
        MoneyType instance1 = instantiateMoney( 30.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
        MoneyType instance4 = instantiateMoney( 30.0f, "EUR" );

        // when
        MoneyType result12 = instance1.subtract( instance2 );
        MoneyType result13 = instance1.subtract( instance3 );
        MoneyType result14 = instance1.subtract( instance4 );

        // then
        assertEquals( 10.0f, result12.getAmount() );
        assertEquals( "EUR", result12.getCurrency() );
        assertEquals( 30.0f, result13.getAmount() );
        assertEquals( "EUR", result13.getCurrency() );
        assertEquals( 0.0f, result14.getAmount() );
        assertEquals( "EUR", result14.getCurrency() );
    }

    @Test
    public void testInvalidSubtractFrom() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 5.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
        assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
    }

    @Test
    public void testMultiplyBy() {
        // given
        MoneyType instance = instantiateMoney( 10.0f, "EUR" );

        // when
        MoneyType result = instance.multiplyBy( 3 );

        // then
        assertEquals( 30.0f, result.getAmount() );
        assertEquals( "EUR", result.getCurrency() );
    }

    @Test
    public void testFactoryMethodValid() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiateMoney( 10.0f, "EUR" ) );
    }

    @Test
    public void testFactoryMethodInvalid() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateMoney( -10.0f, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, "USD" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( null, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, null ) );
    }

    @Test
    public void testLargerThan() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance4 = instantiateMoney( 10.0f, "CHF" );

        // when
        // then
        assertTrue( instance2.largerThan( instance1 ) );
        assertFalse( instance1.largerThan( instance2 ) );
        assertFalse( instance1.largerThan( instance3 ) );
        assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
    }


    @Test
    public void testValueObjectEquality() {
        // given
        // when
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 20.0f, "EUR" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutability() {
        // given
        // when
        MoneyType instance = instantiateMoney( 10.0f, "EUR" );

        // then
        try {
            instance.getClass().getMethod( "setAmount", Float.class );
            fail( "setAmount method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }

        try {
            instance.getClass().getMethod( "setCurrency", String.class );
            fail( "setCurrency method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionPersonalAddressTest.java ---
package thkoeln.archilab.ecommerce.regression.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;

class RegressionPersonalAddressTest {

    @Test
    public void testGetterMethods() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        PersonalAddressType instance = instantiatePersonalAddress( street, city, plz );

        // then
        assertEquals( street, instance.getStreet() );
        assertEquals( city, instance.getCity() );
        assertEquals( plz, instance.getPostalCode() );
    }

    @Test
    public void testFactoryMethodValid() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        // then
        assertDoesNotThrow( () -> instantiatePersonalAddress( street, city, plz ) );
    }

    @Test
    public void testFactoryMethodInvalid() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        // then
        assertThrows( ShopException.class, () -> instantiatePersonalAddress( null, city, plz ) );
        assertThrows( ShopException.class, () -> instantiatePersonalAddress( "", city, plz ) );
        assertThrows( ShopException.class, () -> instantiatePersonalAddress( street, null, plz ) );
        assertThrows( ShopException.class, () -> instantiatePersonalAddress( street, "", plz ) );
        assertThrows( ShopException.class, () -> instantiatePersonalAddress( street, city, null ) );
    }

    @Test
    public void testValueObjectEquality() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        PersonalAddressType instance1 = instantiatePersonalAddress( street, city, plz );
        PersonalAddressType instance2 = instantiatePersonalAddress( street, city, plz );
        PersonalAddressType instance3 = instantiatePersonalAddress( "Anderestr. 12", city, plz );
        PersonalAddressType instance4 = instantiatePersonalAddress( street, "AndereStadt", plz );
        PersonalAddressType instance5 = instantiatePersonalAddress( street, city, instantiatePostalCode( "54321" ) );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
        assertNotEquals( instance1, instance4 );
        assertNotEquals( instance1, instance5 );
    }

    @Test
    public void testImmutability() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        PersonalAddressType instance = instantiatePersonalAddress( street, city, plz );

        // then
        try {
            instance.getClass().getMethod( "setStreet", String.class );
            fail( "setStreet method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setCity", String.class );
            fail( "setCity method should not exist" );

        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setPostalCode", PostalCodeType.class );
            fail( "setPostalCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionPostalCodeTest.java ---
package thkoeln.archilab.ecommerce.regression.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;

class RegressionPostalCodeTest {

    @Test
    public void testToString() {
        // given
        String input = "12345";

        // when
        PostalCodeType instance = instantiatePostalCode( input );

        // then
        assertEquals( input, instance.toString() );
    }

    @Test
    public void testFactoryMethodValid() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiatePostalCode( "12345" ) );
    }

    @Test
    public void testFactoryMethodInvalid() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiatePostalCode( "123456" ) );
        assertThrows( ShopException.class, () -> instantiatePostalCode( "1234" ) );
        assertThrows( ShopException.class, () -> instantiatePostalCode( "20000" ) );
        assertThrows( ShopException.class, () -> instantiatePostalCode( null ) );
    }

    @Test
    public void testValueObjectEquality() {
        // given
        // when
        PostalCodeType instance1 = instantiatePostalCode( "12345" );
        PostalCodeType instance2 = instantiatePostalCode( "12345" );
        PostalCodeType instance3 = instantiatePostalCode( "54321" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutability() {
        // given
        // when
        PostalCodeType instance = instantiatePostalCode( "12345" );

        // then
        try {
            instance.getClass().getMethod( "setpostalCode", String.class );
            fail( "setpostalCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\regression\RegressionInventoryManagementTest.java ---
package thkoeln.archilab.ecommerce.regression;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
import thkoeln.archilab.ecommerce.usecases.InventoryManagementUseCases;

import javax.transaction.Transactional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.PRODUCT_INVENTORY;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.PRODUCT_DATA;

@SpringBootTest
@Transactional
public class RegressionInventoryManagementTest {

    @Autowired
    private InventoryManagementUseCases inventoryManagementUseCases;
    @Autowired
    private InitialMasterDataCreator initialMasterDataCreator;


    @BeforeEach
    public void setUp() {
        initialMasterDataCreator.deleteAll();
        initialMasterDataCreator.addAllProducts();
    }



    @Test
    public void testAddToInventory() {
        // given
        initialMasterDataCreator.inventoryUpAllProducts();
        UUID productId8 = (UUID) PRODUCT_DATA[8][0];

        // when
        int inventory8before = inventoryManagementUseCases.getAvailableInventory( productId8 );
        assertEquals( PRODUCT_INVENTORY.get( productId8 ), inventory8before );
        inventoryManagementUseCases.addToInventory( productId8, 22 );
        int inventory8after = inventoryManagementUseCases.getAvailableInventory( productId8 );
        inventoryManagementUseCases.addToInventory( productId8, 1 );
        int inventory8after2 = inventoryManagementUseCases.getAvailableInventory( productId8 );

        // then
        assertEquals( inventory8before + 22, inventory8after );
        assertEquals( inventory8after + 1, inventory8after2 );
    }


    @Test
    public void testRemoveFromInventory() {
        // given
        initialMasterDataCreator.inventoryUpAllProducts();
        UUID productId6 = (UUID) PRODUCT_DATA[6][0];
        int inventory6before = PRODUCT_INVENTORY.get( productId6 );
        UUID productId9 = (UUID) PRODUCT_DATA[9][0];
        int inventory9before = PRODUCT_INVENTORY.get( productId9 );
        UUID productId1 = (UUID) PRODUCT_DATA[1][0];
        int inventory1before = PRODUCT_INVENTORY.get( productId1 );

        // when
        inventoryManagementUseCases.removeFromInventory( productId6, 1 );
        int inventory6after = inventoryManagementUseCases.getAvailableInventory( productId6 );
        inventoryManagementUseCases.removeFromInventory( productId1, 3 );
        int inventory1after = inventoryManagementUseCases.getAvailableInventory( productId1 );
        inventoryManagementUseCases.removeFromInventory( productId9, inventory9before );
        int inventory9after = inventoryManagementUseCases.getAvailableInventory( productId9 );

        // then
        assertEquals( inventory6before - 1, inventory6after );
        assertEquals( inventory1before - 3, inventory1after );
        assertEquals( 0, inventory9after );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\regression\RegressionProductCatalogTest.java ---
package thkoeln.archilab.ecommerce.regression;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
import thkoeln.archilab.ecommerce.usecases.InventoryManagementUseCases;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import javax.transaction.Transactional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.PRODUCT_DATA;

@SpringBootTest
@Transactional
public class RegressionProductCatalogTest {

    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private InventoryManagementUseCases inventoryManagementUseCases;
    @Autowired
    private InitialMasterDataCreator initialMasterDataCreator;

    @BeforeEach
    public void setUp() {
        initialMasterDataCreator.deleteAll();
    }



    @Test
    public void testAddProductToCatalog() {
        // given
        initialMasterDataCreator.addAllProducts();

        // when
        MoneyType sellPrice = productCatalogUseCases.getSellPrice( (UUID) PRODUCT_DATA[4][0] );

        // then
        assertEquals( PRODUCT_DATA[4][5], sellPrice );
    }

    @Test
    public void testRemoveProductFromCatalog() {
        // given
        initialMasterDataCreator.addAllProducts();
        UUID productId = (UUID) PRODUCT_DATA[4][0];

        // when
        assertDoesNotThrow( () -> productCatalogUseCases.getSellPrice( productId ) );
        productCatalogUseCases.removeProductFromCatalog( productId );

        // then
        assertThrows( ShopException.class, () -> productCatalogUseCases.getSellPrice( productId ) );
    }




    @Test
    public void testRemoveProductThatIsInInventory() {
        // given
        initialMasterDataCreator.addAllProducts();
        UUID productId = (UUID) PRODUCT_DATA[4][0];
        inventoryManagementUseCases.addToInventory( productId, 3 );

        // when
        // then
        assertThrows( ShopException.class, () -> productCatalogUseCases.removeProductFromCatalog( productId ) );
    }


    @Test
    public void testClearProductCatalog() {
        // given
        initialMasterDataCreator.addAllProducts();

        // when
        productCatalogUseCases.deleteProductCatalog();

        // then
        assertThrows( ShopException.class, () -> productCatalogUseCases.getSellPrice( (UUID) PRODUCT_DATA[4][0] ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_443f9afe-ac24-4aa3-8040-fea4e3c736ed\src\test\java\thkoeln\archilab\ecommerce\regression\RegressionUserRegistrationTest.java ---
package thkoeln.archilab.ecommerce.regression;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import javax.transaction.Transactional;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.instantiateMailAddress;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.USER_ADDRESS;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.USER_EMAIL;

@SpringBootTest
@Transactional
public class RegressionUserRegistrationTest {

    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private InitialMasterDataCreator initialMasterDataCreator;

    private MailAddressType nonExistingMailAddress;

    @BeforeEach
    public void setUp() {
        initialMasterDataCreator.deleteAll();
        nonExistingMailAddress = instantiateMailAddress( "this@nononono.de" );
    }


    @Test
    public void testAllUsersRegistered() {
        // given
        initialMasterDataCreator.registerAllUsers();

        // when
        UserType user3 = userRegistrationUseCases.getUserData( USER_EMAIL[3] );

        // then
        Assertions.assertEquals( initialMasterDataCreator.USER_NAME[3], user3.getName() );
        Assertions.assertEquals( USER_EMAIL[3], user3.getMailAddress() );
        Assertions.assertEquals( USER_ADDRESS[3], user3.getPersonalAddress() );
    }


    @Test
    public void testRegisterUserWithDuplicateMailAddress() {
        // given
        initialMasterDataCreator.registerAllUsers();

        // when
        // then
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.register( "Gandalf The Grey", USER_EMAIL[5],
                        USER_ADDRESS[5] ) );
    }

    @Test
    public void testRegisterUserWithDuplicateNameOrPersonalAddress() {
        // given
        initialMasterDataCreator.registerAllUsers();
        MailAddressType newMailAddress = instantiateMailAddress( "some@this.de" );

        // when
        // then
        assertDoesNotThrow(() ->
                userRegistrationUseCases.register( initialMasterDataCreator.USER_NAME[2], newMailAddress,
                        USER_ADDRESS[2] ) );
    }


    @Test
    public void testDeleteUsersNoMoreUsers() {
        // given
        initialMasterDataCreator.registerAllUsers();

        // when
        userRegistrationUseCases.deleteAllUsers();

        // then
        assertThrows( ShopException.class, () -> userRegistrationUseCases.getUserData( USER_EMAIL[0] ) );
    }

}


[RESPONSE]:
Hier ist das Review basierend auf den bereitgestellten Dateien und den Regeln der 4-Layer-Architektur (DDD).

---

### src/main/java/thkoeln/archilab/ecommerce/domainprimitives/MailAddress.java
[Zeile 51]: [negative conditionals] : Negierte Bedingung `!mailAddressAsString.contains("@")` in Kombination mit `||` erschwert die Lesbarkeit.
[Zeile 58-59]: [Duplication] [Zeile 58]: `Pattern.compile("^[A-Za-z0-9\\.]+$").matcher(mailAddressSplitByDelimiter[1]).find()` : Gleiche Regex-Prüfung für den Teil vor und nach dem `@`.
[Zeile 60-61]: [Duplication] [Zeile 60]: `Pattern.compile("\\s").matcher(mailAddressSplitByDelimiter[1]).find()` : Gleiche Whitespace-Prüfung für beide Teile.
[Zeile 62-63]: [Duplication] [Zeile 62]: `Pattern.compile("(\\.\\.)+").matcher(mailAddressSplitByDelimiter[1]).find()` : Gleiche Prüfung auf doppelte Punkte.

### src/main/java/thkoeln/archilab/ecommerce/domainprimitives/Money.java
[Zeile 45]: [negative conditionals] : Doppelte Negation in der Logik (`!= "EUR" && != "CHF"`). Besser wäre eine positive Prüfung gegen eine Liste erlaubter Währungen.

### src/main/java/thkoeln/archilab/ecommerce/domainprimitives/PostalCode.java
[Zeile 41]: [negative conditionals] : `!Pattern.compile...`.

### src/main/java/thkoeln/archilab/ecommerce/masterdata/FactoryMethodInvoker.java
[Zeile 50-78]: [Duplication] [Zeile 22-47] : Die Methode `instantiatePersonalAddress` ist strukturell fast identisch mit `instantiateMailAddress` (Reflection-Aufrufe), nur die Klassennamen und Parameter unterscheiden sich.
[Zeile 81-106]: [Duplication] [Zeile 22-47] : Die Methode `instantiatePostalCode` ist strukturell identisch mit `instantiateMailAddress`.
[Zeile 109-134]: [Duplication] [Zeile 22-47] : Die Methode `instantiateMoney` ist strukturell identisch mit `instantiateMailAddress`.

### src/main/java/thkoeln/archilab/ecommerce/masterdata/InitialMasterDataCreator.java
[Zeile 219-225]: [dead code] : Die Methode `getProductDataInvalidAtIndex` wird innerhalb der Klasse oder des bereitgestellten Codes nicht aufgerufen (wahrscheinlich Test-Hilfscode, der hier nicht genutzt wird).

### src/main/java/thkoeln/archilab/ecommerce/solution/address/domain/Address.java
-Anemic Entity-

### src/main/java/thkoeln/archilab/ecommerce/solution/delivery/application/DeliveryService.java
[Zeile 25]: [Shared persistency] : Der `DeliveryService` greift direkt auf das `ProductRepository` eines anderen Aggregats/Packages (`solution.product`) zu.
[Zeile 38-43]: [Duplication] [Zeile 25-30 in DeliveryService.java (hypothetisch, da Logik sehr generisch)] : Diese Art von "Null or Empty" Validierungsblöcken taucht in fast allen Services auf (z.B. `UserService`).
[Zeile 76]: [negative conditionals] : `!users.existsByMailAddress(...)`.
[Zeile 81]: [negative conditionals] : `!result.containsKey(...)`.

### src/main/java/thkoeln/archilab/ecommerce/solution/delivery/domain/Delivery.java
-Anemic Entity-

### src/main/java/thkoeln/archilab/ecommerce/solution/delivery/domain/DeliveryPosition.java
-Anemic Entity-

### src/main/java/thkoeln/archilab/ecommerce/solution/delivery/domain/DeliveryRepository.java
[Zeile 17-20]: [Duplication] [Zeile 17-20] : Die `save` Methode (und die gesamte HashMap-Implementierung) ist identisch in allen Repositories. Da dies das erste Vorkommen im Alphabet ist, markiere ich die anderen als Duplikate hiervon.

### src/main/java/thkoeln/archilab/ecommerce/solution/order/application/OrderController.java
[Zeile 21-23]: [layer violation] : Der Controller greift direkt auf Repositories (`OrderRepository`, `OrderPositionRepository`, `UserRepository`) der Domain-Schicht zu, anstatt über einen Application Service zu gehen.
[Zeile 38]: [negative conditionals] : `!users.existsById(mailAddress)`.

### src/main/java/thkoeln/archilab/ecommerce/solution/order/domain/Order.java
-Anemic Entity-

### src/main/java/thkoeln/archilab/ecommerce/solution/order/domain/OrderPosition.java
-Anemic Entity-

### src/main/java/thkoeln/archilab/ecommerce/solution/order/domain/OrderPositionRepository.java
[Zeile 17-20]: [Duplication] [Zeile 17-20 in DeliveryRepository.java] : Exakte Kopie der `save` Methode aus `DeliveryRepository`.
[Zeile 23-29]: [Duplication] [Zeile 23-29 in DeliveryRepository.java] : Exakte Kopie der `saveAll` Methode.
[Zeile 32-35]: [Duplication] [Zeile 32-35 in DeliveryRepository.java] : Exakte Kopie der `findById` Methode.
[Zeile 38-41]: [Duplication] [Zeile 38-41 in DeliveryRepository.java] : Exakte Kopie der `existsById` Methode.
[Zeile 44-47]: [Duplication] [Zeile 44-47 in DeliveryRepository.java] : Exakte Kopie der `findAll` Methode.
[Zeile 50-57]: [Duplication] [Zeile 50-57 in DeliveryRepository.java] : Exakte Kopie der `findAllById` Methode.
[Zeile 60-63]: [Duplication] [Zeile 60-63 in DeliveryRepository.java] : Exakte Kopie der `count` Methode.
[Zeile 66-69]: [Duplication] [Zeile 66-69 in DeliveryRepository.java] : Exakte Kopie der `deleteById` Methode.
[Zeile 72-75]: [Duplication] [Zeile 72-75 in DeliveryRepository.java] : Exakte Kopie der `delete` Methode.
[Zeile 78-83]: [Duplication] [Zeile 78-83 in DeliveryRepository.java] : Exakte Kopie der `deleteAll(Iterable)` Methode.
[Zeile 86-89]: [Duplication] [Zeile 86-89 in DeliveryRepository.java] : Exakte Kopie der `deleteAll()` Methode.

### src/main/java/thkoeln/archilab/ecommerce/solution/order/domain/OrderRepository.java
[Zeile 17-89]: [Duplication] [Zeile 17-89 in DeliveryRepository.java] : Die gesamte Implementierung der Repository-Methoden ist eine Kopie der HashMap-Logik aus `DeliveryRepository`.

### src/main/java/thkoeln/archilab/ecommerce/solution/payment/application/PaymentService.java
[Zeile 37]: [negative conditionals] : `!users.existsByMailAddress(...)`.
[Zeile 60]: [negative conditionals] : `!users.existsByMailAddress(...)`.

### src/main/java/thkoeln/archilab/ecommerce/solution/payment/domain/Payment.java
-Anemic Entity-

### src/main/java/thkoeln/archilab/ecommerce/solution/payment/domain/PaymentRepository.java
[Zeile 17-89]: [Duplication] [Zeile 17-89 in DeliveryRepository.java] : Die gesamte Implementierung der Repository-Methoden ist eine Kopie der HashMap-Logik aus `DeliveryRepository`.

### src/main/java/thkoeln/archilab/ecommerce/solution/product/application/InventoryService.java
[Zeile 24]: [negative conditionals] : `!products.existsById(productId)`.
[Zeile 37]: [negative conditionals] : `!products.existsById(productId)`.
[Zeile 85]: [negative conditionals] : `!products.existsById(productId)`.
[Zeile 106]: [negative conditionals] : `!products.existsById(productId)`.

### src/main/java/thkoeln/archilab/ecommerce/solution/product/application/ProductCatalogService.java
[Zeile 42]: [negative conditionals] : `!products.existsById(productId)`.
[Zeile 49]: [negative conditionals] : `!products.existsById(productId)`.

### src/main/java/thkoeln/archilab/ecommerce/solution/product/domain/Product.java
-Anemic Entity-

### src/main/java/thkoeln/archilab/ecommerce/solution/product/domain/ProductRepository.java
[Zeile 17-89]: [Duplication] [Zeile 17-89 in DeliveryRepository.java] : Die gesamte Implementierung der Repository-Methoden ist eine Kopie der HashMap-Logik aus `DeliveryRepository`.

### src/main/java/thkoeln/archilab/ecommerce/solution/shoppingbasket/application/ShoppingBasketConsumerService.java
[Zeile 23]: [negative conditionals] : `!shoppingBaskets.existsById(consumerId)`.

### src/main/java/thkoeln/archilab/ecommerce/solution/shoppingbasket/application/ShoppingBasketController.java
[Zeile 23-27]: [layer violation] : Der Controller greift direkt auf Repositories (`ShoppingBasketRepository`, `ProductRepository`, `OrderRepository`) zu.
[Zeile 38]: [negative conditionals] : `!StreamSupport.stream(...)`.
[Zeile 56]: [negative conditionals] : `!shoppingBaskets.existsById(...)`.
[Zeile 57]: [negative conditionals] : `!products.existsById(...)`.
[Zeile 66]: [negative conditionals] : `!positions.stream().anyMatch(...)`.
[Zeile 82]: [negative conditionals] : `!shoppingBasket.getPositions().stream().anyMatch(...)`.
[Zeile 104]: [negative conditionals] : `!shoppingBaskets.existsById(...)`.
[Zeile 105]: [negative conditionals] : `!products.existsById(...)`.
[Zeile 108]: [negative conditionals] : `!shoppingBasket.getPositions().stream().anyMatch(...)`.
[Zeile 122]: [negative conditionals] : `!shoppingBaskets.existsById(...)`.
[Zeile 123]: [negative conditionals] : `!products.existsById(...)`.
[Zeile 126]: [negative conditionals] : `!shoppingBasket.getPositions().stream().anyMatch(...)`.
[Zeile 137]: [negative conditionals] : `!shoppingBaskets.existsById(...)`.

### src/main/java/thkoeln/archilab/ecommerce/solution/shoppingbasket/application/ShoppingBasketService.java
[Zeile 29]: [Shared persistency] : Zugriff auf `ProductRepository` (anderes Package/Aggregat).
[Zeile 33]: [Shared persistency] : Zugriff auf `OrderRepository` (anderes Package/Aggregat).
[Zeile 51]: [negative conditionals] : `!users.existsById(...)`.
[Zeile 52]: [negative conditionals] : `!products.existsById(...)`.
[Zeile 56]: [negative conditionals] : `!shoppingBaskets.existsByMailAddress(...)`.
[Zeile 67]: [negative conditionals] : `!users.existsById(...)`.
[Zeile 68]: [negative conditionals] : `!products.existsById(...)`.
[Zeile 71]: [negative conditionals] : `!shoppingBaskets.existsByMailAddress(...)`.
[Zeile 82]: [negative conditionals] : `!users.existsById(...)`.
[Zeile 83]: [negative conditionals] : `!shoppingBaskets.existsByMailAddress(...)`.
[Zeile 97]: [negative conditionals] : `!users.existsById(...)`.
[Zeile 116]: [negative conditionals] : `!products.existsById(...)`.
[Zeile 131]: [negative conditionals] : `!users.existsById(...)`.
[Zeile 133]: [negative conditionals] : `!shoppingBaskets.existsByMailAddress(...)`.
[Zeile 153]: [negative conditionals] : `!users.existsById(...)`.
[Zeile 155]: [negative conditionals] : `!shoppingBaskets.existsByMailAddress(...)`.
[Zeile 160]: [missplaced resonsibility] : Die `checkout`-Methode erzeugt `Order` und `OrderPosition` Entitäten und speichert diese. Diese Logik gehört in den `Order`-Kontext (z.B. `OrderService`), nicht in den `ShoppingBasketService`.
[Zeile 162]: [negative conditionals] : `!users.existsById(...)`.
[Zeile 167]: [negative conditionals] : `!shoppingBaskets.existsByMailAddress(...)`.
[Zeile 178]: [negative conditionals] : `!isPaymentAuthorized(...)`.
[Zeile 207]: [negative conditionals] : `!users.existsById(...)`.
[Zeile 250]: [negative conditionals] : `!users.existsById(...)`.
[Zeile 251]: [negative conditionals] : `!products.existsById(...)`.
[Zeile 274]: [negative conditionals] : `!users.existsById(...)`.
[Zeile 275]: [negative conditionals] : `!products.existsById(...)`.

### src/main/java/thkoeln/archilab/ecommerce/solution/shoppingbasket/domain/ShoppingBasket.java
[Zeile 38]: [negative conditionals] : `!positions.stream().anyMatch(...)`.
[Zeile 59]: [negative conditionals] : `!positions.stream().anyMatch(...)`.

### src/main/java/thkoeln/archilab/ecommerce/solution/shoppingbasket/domain/ShoppingBasketPosition.java
-Anemic Entity-

### src/main/java/thkoeln/archilab/ecommerce/solution/shoppingbasket/domain/ShoppingBasketRepository.java
[Zeile 17-89]: [Duplication] [Zeile 17-89 in DeliveryRepository.java] : Die gesamte Implementierung der Repository-Methoden ist eine Kopie der HashMap-Logik aus `DeliveryRepository`.
[Zeile 94]: [negative conditionals] : `!basket.getPositions().stream().anyMatch(...)`.

### src/main/java/thkoeln/archilab/ecommerce/solution/user/application/UserService.java
[Zeile 28]: [negative conditionals] : `!users.existsById(...)`.
[Zeile 33-37]: [Duplication] [Zeile 56-59] : Die Validierung der Adressdaten (Street, City, Zip) ist fast identisch in `register` und `changeAddress`.
[Zeile 53]: [negative conditionals] : `!users.existsById(...)`.
[Zeile 72]: [negative conditionals] : `!users.existsById(...)`.

### src/main/java/thkoeln/archilab/ecommerce/solution/user/domain/User.java
-Anemic Entity-

### src/main/java/thkoeln/archilab/ecommerce/solution/user/domain/UserRepository.java
[Zeile 17-89]: [Duplication] [Zeile 17-89 in DeliveryRepository.java] : Die gesamte Implementierung der Repository-Methoden ist eine Kopie der HashMap-Logik aus `DeliveryRepository`.

ENDE
Generated by gemini-3-pro-preview
-----------------------------------