--- DATE: 8.1.2026, 19:06:40 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
    Architektur: 4-Layer (Eric Evans).
    Aufgabe: Finde folgende Smells: Duplication: duplizierte Codest√ºcke die mehrmals vorkommen und eingespart werden k√∂nnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei l√§ngeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verst√§ndlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder geh√∂rt er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur √ºber Getter oder Setter verf√ºgen aber sonst keine Funktionen. Ausgenommen sind Repositories. F√ºr diesen Smell brauchst du keinen Zeilenangabe, da er f√ºr die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
    Regeln:
    1. Begr√ºnde kurz jeden Fund.
    4. Gruppiere nach Datei (mit Pfad). 
    2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begr√ºndung].
    3. Keine Code-Wiederholung, nur Referenzen.
    5. Wenn fertig, schreibe "ENDE".



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ConflictException.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

//409
@ResponseStatus(HttpStatus.CONFLICT)
public class ConflictException extends RuntimeException {
    public ConflictException(String message) {
        super(message);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Currency.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import jakarta.persistence.Embeddable;
import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

import java.util.Locale;
import java.util.Objects;

@Getter
@Setter
@Embeddable
public class Currency implements CurrencyType {

    private final Float quantity;
    private final String currencyUnit;

    public Currency() {
        this.quantity = null;
        this.currencyUnit = null;
    }

    public Currency(Float quantity, String currencyUnit) {
        this.quantity = quantity;
        this.currencyUnit = currencyUnit;
    }

    public static Currency of(Float quantity, String currencyUnit) {
        if (quantity == null || quantity < 0) {
            throw new ShopException("Currency quantity must be >= 0");
        }
        if (currencyUnit == null || (!currencyUnit.equals("EUR") && !currencyUnit.equals("CHF"))) {
            throw new ShopException("Invalid currency unit. Only 'EUR' and 'CHF' allowed.");
        }
        return new Currency(quantity, currencyUnit);
    }

    private void validateSameCurrencyUnit(CurrencyType otherCurrency) {
        if (otherCurrency == null) {
            throw new ShopException("Other currency is null");
        }
        if (!this.currencyUnit.equals(otherCurrency.getCurrencyUnit())) {
            throw new ShopException("Currency units do not match");
        }
    }

    @Override
    public Float getQuantity() {
        return quantity;
    }

    @Override
    public String getCurrencyUnit() {
        return currencyUnit;
    }

    @Override
    public CurrencyType add(CurrencyType otherCurrency) {
        validateSameCurrencyUnit(otherCurrency);
        return Currency.of(this.quantity + otherCurrency.getQuantity(), this.currencyUnit);
    }

    @Override
    public CurrencyType subtract(CurrencyType otherCurrency) {
        validateSameCurrencyUnit(otherCurrency);
        if (this.quantity < otherCurrency.getQuantity()) {
            throw new ShopException("Cannot subtract: result would be negative.");
        }
        return Currency.of(this.quantity - otherCurrency.getQuantity(), this.currencyUnit);
    }

    @Override
    public CurrencyType multiplyBy(int factor) {
        if (factor < 0) {
            throw new ShopException("Factor must be >= 0");
        }
        return Currency.of(this.quantity * factor, this.currencyUnit);
    }

    @Override
    public boolean largerThan(CurrencyType otherCurrency) {
        validateSameCurrencyUnit(otherCurrency);
        return this.quantity > otherCurrency.getQuantity();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Currency)) return false;
        Currency currency = (Currency) o;
        return quantity.equals(currency.quantity) &&
                currencyUnit.equals(currency.currencyUnit);
    }

    @Override
    public int hashCode() {
        return Objects.hash(quantity, currencyUnit);
    }

    @Override
    public String toString() {
        return String.format(Locale.US, "%.2f ‚Ç¨", quantity);
    }}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\GlobalExceptionHandler.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.MissingServletRequestParameterException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;

@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(MissingServletRequestParameterException.class)
    @ResponseStatus(HttpStatus.METHOD_NOT_ALLOWED)
    public void handleMissingQueryParam(MissingServletRequestParameterException ex) {
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\MailAddress.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.Embeddable;
import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.Objects;
import java.util.regex.Pattern;

@Getter
@Setter
@Embeddable
public class MailAddress implements MailAddressType {
    private static final Pattern VALID_MAIL_PATTERN = Pattern.compile(
            "^(?=[^@\\s]{1,64}@[^@\\s]{1,255}$)" +             // One '@', no spaces
                    "[A-Za-z0-9]+(?:\\.[A-Za-z0-9]+)*@" +               // Local part
                    "[A-Za-z0-9]+(?:\\.[A-Za-z0-9]+)*\\.(de|at|ch|com|org)$" // Domain
    );

    @JsonProperty("mailAddressString")
    private String address;

    public MailAddress() {}

    public MailAddress(String address) {
        this.address = address;
    }

    public static MailAddressType of(String mailAddressAsString) {
        if (mailAddressAsString == null || !VALID_MAIL_PATTERN.matcher(mailAddressAsString).matches()) {
            throw new ShopException("Invalid mail address: " + mailAddressAsString);
        }
        return new MailAddress(mailAddressAsString);
    }

    @Override
    public MailAddressType sameIdentifyerDifferentDomain(String newDomain) {
        if (newDomain == null || newDomain.trim().isEmpty()) {
            throw new ShopException("Domain must not be null or empty");
        }
        String[] parts = address.split("@");
        return MailAddress.of(parts[0] + "@" + newDomain);
    }

    @Override
    public MailAddressType sameDomainDifferentIdentifyer(String newIdentifyer) {
        if (newIdentifyer == null || newIdentifyer.trim().isEmpty()) {
            throw new ShopException("Identifier must not be null or empty");
        }
        String[] parts = address.split("@");
        return MailAddress.of(newIdentifyer + "@" + parts[1]);
    }

    @Override
    public String toString() {
        return address;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof MailAddress)) return false;
        MailAddress that = (MailAddress) o;
        return address.equals(that.address);
    }

    @Override
    public int hashCode() {
        return Objects.hash(address);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\NotFoundException.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

//404
@ResponseStatus(code = HttpStatus.NOT_FOUND)
public class NotFoundException extends RuntimeException {
    public NotFoundException(String message) {
        super(message);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PhysicalAddress.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import jakarta.persistence.Embeddable;
import lombok.*;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

import java.util.Objects;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter(AccessLevel.PROTECTED)
@Embeddable
public class PhysicalAddress implements PhysicalAddressType {

    private String street;

    private String city;

    private PostalCode postalCode;

    public static PhysicalAddress of(String street, String city, PostalCodeType postalCode) {
        if (street == null || street.trim().isEmpty()) {
            throw new ShopException("Street must not be null or empty");
        }
        if (city == null || city.trim().isEmpty()) {
            throw new ShopException("City must not be null or empty");
        }
        if (postalCode == null) {
            throw new ShopException("Postal code must not be null");
        }
        return new PhysicalAddress(street, city, (PostalCode) postalCode);
    }

    @Override
    public String getStreet() {
        return street;
    }

    @Override
    public String getCity() {
        return city;
    }

    @Override
    public PostalCodeType getPostalCode() {
        return postalCode;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof PhysicalAddress)) return false;
        PhysicalAddress that = (PhysicalAddress) o;
        return street.equals(that.street) &&
                city.equals(that.city) &&
                postalCode.equals(that.postalCode);
    }

    @Override
    public int hashCode() {
        return Objects.hash(street, city, postalCode);
    }

    @Override
    public String toString() {
        return street + ", " + city + " " + postalCode.toString();
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PostalCode.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import jakarta.persistence.Embeddable;
import lombok.*;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

import java.util.Objects;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Embeddable
public class PostalCode implements PostalCodeType {

    private String postalCode;

    public static PostalCode of(String postalCodeAsString) {
        if (postalCodeAsString == null || !postalCodeAsString.matches("\\d{5}")) {
            throw new ShopException("Postal code must be exactly 5 digits.");
        }
        if (postalCodeAsString.endsWith("0000")) {
            throw new ShopException("Invalid postal code: cannot end in 0000.");
        }
        return new PostalCode(postalCodeAsString);
    }

    @Override
    public int distance(PostalCodeType otherPostalCode) {
        if (otherPostalCode == null) {
            throw new ShopException("Other postal code must not be null");
        }

        String other = otherPostalCode.toString();
        if (this.postalCode.equals(other)) {
            return 0;
        }

        int maxDifferenceLevel = 0;

        for (int i = 4; i >= 1; i--) {
            if (postalCode.charAt(i) != other.charAt(i)) {
                maxDifferenceLevel = Math.max(maxDifferenceLevel, 5 - i);
            }
        }

        // Region wird IMMER ber√ºcksichtigt (wrap-around!)
        int regionA = Character.getNumericValue(postalCode.charAt(0));
        int regionB = Character.getNumericValue(other.charAt(0));
        int regionDiff = Math.min(Math.abs(regionA - regionB), 10 - Math.abs(regionA - regionB));

        return maxDifferenceLevel + regionDiff;
    }

    @Override
    public Integer getFirstDigitPostalCode() {
        return Integer.parseInt(postalCode.substring(0, 1));
    }

    @Override
    public String toString() {
        return postalCode;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof PostalCode)) return false;
        PostalCode that = (PostalCode) o;
        return postalCode.equals(that.postalCode);
    }

    @Override
    public int hashCode() {
        return Objects.hash(postalCode);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\UnprocessableEntityException.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

//422
@ResponseStatus(HttpStatus.UNPROCESSABLE_ENTITY)
public class UnprocessableEntityException extends RuntimeException {
    public UnprocessableEntityException(String message) {
        super(message);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
/*
 * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
 */
package thkoeln.archilab.ecommerce;

import jakarta.persistence.Column;
import jakarta.persistence.MappedSuperclass;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

import java.io.Serializable;
import java.util.UUID;

@MappedSuperclass
@Getter
@EqualsAndHashCode(of = "id")
@ToString(of = "id")
public abstract class GenericId implements Serializable {
    @Column(nullable = false, updatable = false)
    private final UUID id;

    protected GenericId() {
        this( UUID.randomUUID() );
    }

    protected GenericId( UUID id ) {
        this.id = id;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
/*
 * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
 */
package thkoeln.archilab.ecommerce;

import jakarta.persistence.AttributeConverter;

import java.util.UUID;
import java.util.function.Function;


public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
    private final Function<UUID, T> factory;

    protected GenericIdConverter( Function<UUID, T> factory ) {
        this.factory = factory;
    }

    @Override
    public UUID convertToDatabaseColumn( T attribute ) {
        return attribute == null ? null : attribute.getId();
    }

    @Override
    public T convertToEntityAttribute( UUID dbData ) {
        return dbData == null ? null : factory.apply( dbData );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\InsufficientInventoryException.java ---
/*
 * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
 */
package thkoeln.archilab.ecommerce;

/**
 * Exception is thrown if the product's inventory level is not sufficient to serve the purchase.
 */
public class InsufficientInventoryException extends ShopException {
    public InsufficientInventoryException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
/*
 * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
 */
package thkoeln.archilab.ecommerce;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class ProjectApplication {

	/**
	 * Entry method
	 * @param args
	 */
	public static void main(String[] args) {
		SpringApplication.run(ProjectApplication.class, args);
	}
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
/*
 * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
 */
package thkoeln.archilab.ecommerce;

public class ShopException extends RuntimeException {
    public ShopException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\adapter\inventory\InventoryCheckerAdapter.java ---
package thkoeln.archilab.ecommerce.solution.adapter.inventory;

import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterRepository;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.InventoryLevel;
import thkoeln.archilab.ecommerce.solution.product.domain.InventoryChecker;

import java.util.UUID;

@Component
public class InventoryCheckerAdapter implements InventoryChecker {

    private final FulfillmentCenterRepository fulfillmentCenterRepository;

    public InventoryCheckerAdapter(FulfillmentCenterRepository fulfillmentCenterRepository) {
        this.fulfillmentCenterRepository = fulfillmentCenterRepository;
    }

    @Override
    public boolean isProductInAnyInventory(UUID productId) {
        return fulfillmentCenterRepository.findAll().stream()
                .flatMap(center -> center.getInventoryLevels().stream())
                .map(InventoryLevel::getProductId)
                .anyMatch(pid -> pid.equals(productId));
    }

    @Override
    public void deleteAllCenters() {
        fulfillmentCenterRepository.deleteAll();
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\adapter\MailAddressJpaAdapter.java ---
package thkoeln.archilab.ecommerce.solution.adapter;

import jakarta.persistence.Embeddable;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@Embeddable
@NoArgsConstructor
public class MailAddressJpaAdapter {
    private String address;
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\adapter\purchase\ProductPurchaseUsageAdapter.java ---
package thkoeln.archilab.ecommerce.solution.adapter.purchase;

import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.solution.product.domain.PurchaseUsage;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;

import java.util.UUID;

@Component
public class ProductPurchaseUsageAdapter implements PurchaseUsage {

    private final PurchaseRepository purchaseRepository;

    public ProductPurchaseUsageAdapter(PurchaseRepository purchaseRepository) {
        this.purchaseRepository = purchaseRepository;
    }

    @Override
    public boolean isProductInAnyPurchase(UUID productId) {
        return purchaseRepository.findAll().stream()
                .flatMap(p -> p.getPurchasePositions().stream())
                .anyMatch(pos -> productId.equals(pos.getProductId()));
    }

    @Override
    public void deleteAllPurchases() {
        purchaseRepository.deleteAll();
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\adapter\shopping\ProductBasketUsageAdapter.java ---
package thkoeln.archilab.ecommerce.solution.adapter.shopping;

import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductBasketUsageChecker;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
import java.util.UUID;

@Component
public class ProductBasketUsageAdapter implements ProductBasketUsageChecker {

    private final ShoppingBasketRepository shoppingBasketRepository;

    public ProductBasketUsageAdapter(ShoppingBasketRepository shoppingBasketRepository) {
        this.shoppingBasketRepository = shoppingBasketRepository;
    }

    @Override
    public boolean isProductInAnyBasket(UUID productId) {
        return shoppingBasketRepository.findAll().stream()
                .flatMap(basket -> basket.getShoppingBasketPositions().stream())
                .anyMatch(position -> position.getProductId().equals(productId));
    }

    @Override
    public void deleteAllBaskets() {
        shoppingBasketRepository.deleteAll();
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterFinderAdapter.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;

import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.*;

import java.util.UUID;

@Component
public class FulfillmentCenterFinderAdapter implements FulfillmentCenterFinder {

    private final FulfillmentCenterRepository repository;

    public FulfillmentCenterFinderAdapter(FulfillmentCenterRepository repository) {
        this.repository = repository;
    }

    @Override
    public UUID findMatchingCenterId(String postalCode) {
        if (postalCode == null || postalCode.isBlank() || !postalCode.matches("\\d{5}")) {
            throw new ShopException("Invalid postal code.");
        }

        int digit = Character.getNumericValue(postalCode.charAt(0));
        return repository.findAll().stream()
                .filter(fc -> digit >= fc.getFromPostalCodeFirstDigit()
                        && digit <= fc.getToPostalCodeFirstDigit())
                .map(FulfillmentCenter::getFulFillmentCenterId)
                .findFirst()
                .orElseThrow(() -> new ShopException("No matching fulfillment center found."));
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterService.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;

import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.*;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductLookup;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.UUID;

// üè¨ FulfillmentCenterService ‚Äì Versandzentren & Lagerlogik

@Service
public class FulfillmentCenterService implements FulfillmentCenterUseCases {

    private final FulfillmentCenterRepository fulfillmentCenterRepository;
    private final ProductLookup productExistenceChecker;

    @Autowired
    public FulfillmentCenterService(FulfillmentCenterRepository fulfillmentCenterRepository,
                                    ProductLookup productExistenceChecker) {
        this.fulfillmentCenterRepository = fulfillmentCenterRepository;
        this.productExistenceChecker = productExistenceChecker;
    }

    @Override
    @Transactional
    public UUID addNewFulfillmentCenter(String name, PhysicalAddressType physicalAddress) {
        if (name == null || name.isBlank()) {
            throw new ShopException("Name must not be null or blank.");
        }

        if (physicalAddress == null) {
            throw new ShopException("Physical address must not be null.");
        }

        PhysicalAddress address = (PhysicalAddress) physicalAddress;
        FulfillmentCenter center = new FulfillmentCenter(name, address);
        fulfillmentCenterRepository.save(center);
        return center.getFulFillmentCenterId();
    }

    @Transactional
    @Override
    public void deleteAllFulfillmentCenters() {
        fulfillmentCenterRepository.deleteAll();
    }

    @Transactional
    @Override
    public void addToInventory(UUID fulfillmentCenterId, UUID productId, int addedQuantityFor) {
        FulfillmentCenter center = findCenter(fulfillmentCenterId);
        ensureProductExists(productId);
        center.addToInventory(productId, addedQuantityFor);
        fulfillmentCenterRepository.save(center);
    }

    @Transactional
    @Override
    public void removeFromInventory(UUID fulfillmentCenterId, UUID productId, int removedQuantityFor) {
        FulfillmentCenter center = findCenter(fulfillmentCenterId);
        ensureProductExists(productId);
        center.removeFromInventory(productId, removedQuantityFor);
        fulfillmentCenterRepository.save(center);
    }

    @Transactional
    @Override
    public void changeInventoryTo(UUID fulfillmentCenterId, UUID productId, int newTotalQuantityFor) {
        FulfillmentCenter center = findCenter(fulfillmentCenterId);
        ensureProductExists(productId);
        center.setInventory(productId, newTotalQuantityFor);
        fulfillmentCenterRepository.save(center);
    }

    @Transactional
    @Override
    public int getAvailableInventory(UUID fulfillmentCenterId, UUID productId) {
        FulfillmentCenter center = findCenter(fulfillmentCenterId);
        ensureProductExists(productId);
        return center.getInventoryQuantity(productId);
    }

    //Hilfsmethoden
    private FulfillmentCenter findCenter(UUID id) {
        return fulfillmentCenterRepository.findById(new FulfillmentCenterId(id))
                .orElseThrow(() -> new ShopException("Fulfillment center not found."));
    }

    private void ensureProductExists(UUID productId) {
        if (!productExistenceChecker.isExistingProduct(productId)) {
            throw new ShopException("Product does not exist.");
        }
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentInventoryAdapter.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;

import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.*;

import java.util.UUID;

@Component
public class FulfillmentInventoryAdapter implements FulfillmentInventoryChecker {

    private final FulfillmentCenterRepository repository;
    private FulfillmentCenter currentCenter;

    public FulfillmentInventoryAdapter(FulfillmentCenterRepository repository) {
        this.repository = repository;
    }

    @Override
    public void setFulfillmentCenter(UUID centerIdRaw) {
        FulfillmentCenterId id = new FulfillmentCenterId(centerIdRaw);
        this.currentCenter = repository.findById(id)
                .orElseThrow(() -> new ShopException("Center not found."));
    }

    @Override
    public boolean hasEnoughInventory(UUID productId, int quantity) {
        ensureCenterSelected();
        return currentCenter.hasEnoughInventory(productId, quantity);
    }

    @Override
    public void removeFromInventory(UUID productId, int quantity) {
        ensureCenterSelected();
        currentCenter.removeFromInventory(productId, quantity);
    }

    @Override
    @Transactional
    public void saveChanges() {
        ensureCenterSelected();
        repository.save(currentCenter);
    }

    private void ensureCenterSelected() {
        if (currentCenter == null) {
            throw new ShopException("Fulfillment center not set.");
        }
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenter.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

import java.util.*;

@Entity
@Getter
@Setter
public class FulfillmentCenter {
    @EmbeddedId
    private FulfillmentCenterId fulfillmentCenterId;

    private String name;

    @Embedded
    private PhysicalAddress physicalAddress;

    private int fromPostalCodeFirstDigit;
    private int toPostalCodeFirstDigit;

    @Getter
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "fulfillment_center_id")
    private List<InventoryLevel> inventoryLevels = new ArrayList<>();

    public FulfillmentCenter(String name, PhysicalAddress address, int from, int to) {
        this.fulfillmentCenterId = new FulfillmentCenterId();
        this.name = name;
        this.physicalAddress = address;
        this.fromPostalCodeFirstDigit = from;
        this.toPostalCodeFirstDigit = to;
    }

    public FulfillmentCenter() {}

    public FulfillmentCenter(String name, PhysicalAddress address) {
        this.fulfillmentCenterId = new FulfillmentCenterId(); // Wichtig!
        this.name = name;
        this.physicalAddress = address;
    }

    public Set<ProductId> fulfillableShoppingBasketPositions(Map<ProductId, Integer> productQuantityMap) {
        Set<ProductId> fulfillable = new HashSet<>();

        for (Map.Entry<ProductId, Integer> entry : productQuantityMap.entrySet()) {
            UUID productId = entry.getKey().getId();
            int requiredQty = entry.getValue();

            inventoryLevels.stream()
                    .filter(level -> level.getProductId() != null &&
                            level.getProductId().equals(productId) &&
                            level.getQuantity() >= requiredQty)
                    .findFirst()
                    .ifPresent(level -> fulfillable.add(entry.getKey()));  // <-- add original ProductId key!
        }
        return fulfillable;
    }

    public void addToInventory(UUID productId, int quantity) {
        if (productId == null || quantity < 0) {
            throw new ShopException("Invalid product ID or quantity for adding to inventory.");
        }
        InventoryLevel level = findOrCreateInventoryLevel(productId);
        level.setQuantity(level.getQuantity() + quantity);
    }

    public void removeFromInventory(UUID productId, int quantity) {
        if (productId == null || quantity < 0) {
            throw new ShopException("Invalid product ID or quantity for removing from inventory.");
        }

        Optional<InventoryLevel> maybeLevel = inventoryLevels.stream()
                .filter(level -> level.getProductId() != null && level.getProductId().equals(productId))
                .findFirst();

        if (maybeLevel.isEmpty()) {
            if (quantity == 0) return;
            throw new ShopException("Product " + productId + " not found in inventory of center " + this.name);
        }

        InventoryLevel level = maybeLevel.get();

        if (level.getQuantity() < quantity) {
            throw new ShopException("Not enough inventory to remove.");
        }

        level.setQuantity(level.getQuantity() - quantity);
    }

    public int getInventoryQuantity(UUID productId) {
        return inventoryLevels.stream()
                .filter(level -> level.getProductId() != null && level.getProductId().equals(productId))
                .findFirst()
                .map(InventoryLevel::getAvailableQuantity)
                .orElse(0);

    }

    public boolean hasEnoughInventory(UUID productId, int requiredQuantity) {
        return inventoryLevels.stream()
                .filter(level -> level.getProductId() != null && level.getProductId().equals(productId))
                .anyMatch(level -> level.getQuantity() >= requiredQuantity);
    }

    private InventoryLevel findOrCreateInventoryLevel(UUID productId) {
        return inventoryLevels.stream()
                .filter(level -> level.getProductId() != null && level.getProductId().equals(productId))
                .findFirst()
                .orElseGet(() -> {
                    InventoryLevel newLevel = new InventoryLevel(productId, 0, this.getFulFillmentCenterId());
                    inventoryLevels.add(newLevel);
                    return newLevel;
                });
    }

    public UUID getFulFillmentCenterId() {
        return fulfillmentCenterId.getId();
    }

    public void setInventory(UUID productId, int quantity) {
        if (productId == null || quantity < 0) {
            throw new ShopException("Invalid product ID or quantity for setting inventory.");
        }
        InventoryLevel level = findOrCreateInventoryLevel(productId);
        level.setQuantity(quantity);
    }

    public int getInventoryLevel(UUID productId) {
        return inventoryLevels.stream()
                .filter(level -> level.getProductId().equals(productId))
                .mapToInt(InventoryLevel::getQuantity)
                .findFirst()
                .orElse(0); // Falls kein Eintrag vorhanden ist
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterComparator.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import java.util.Comparator;
import java.util.Map;
import java.util.Set;

import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

public class FulfillmentCenterComparator implements Comparator<FulfillmentCenter> {

    private final Map<ProductId, Integer> shoppingBasket;
    private final PostalCode userPostalCode;

    public FulfillmentCenterComparator(Map<ProductId, Integer> shoppingBasket, PostalCode userPostalCode) {
        this.shoppingBasket = shoppingBasket;
        this.userPostalCode = userPostalCode;
    }

    @Override
    public int compare(FulfillmentCenter fc1, FulfillmentCenter fc2) {
        // 1. Anzahl der erf√ºllbaren Positionen (nicht Produkte!) vergleichen
        int fulfillableCountFc1 = getFulfillableQuantity(fc1);
        int fulfillableCountFc2 = getFulfillableQuantity(fc2);

        if (fulfillableCountFc1 != fulfillableCountFc2) {
            return Integer.compare(fulfillableCountFc2, fulfillableCountFc1); // Mehr ist besser
        }

        // 2. Entfernung vergleichen
        int distanceFc1 = userPostalCode.distance(fc1.getPhysicalAddress().getPostalCode());
        int distanceFc2 = userPostalCode.distance(fc2.getPhysicalAddress().getPostalCode());

        if (distanceFc1 != distanceFc2) {
            return Integer.compare(distanceFc1, distanceFc2); // Weniger ist besser
        }

        // 3. Deterministischer Vergleich (z.‚ÄØB. nach ID)
        return fc1.getFulFillmentCenterId().compareTo(fc2.getFulFillmentCenterId());
    }

    private int getFulfillableQuantity(FulfillmentCenter center) {
        Set<ProductId> fulfillable = center.fulfillableShoppingBasketPositions(shoppingBasket);
        return fulfillable.size();
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterFinder.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import java.util.UUID;

public interface FulfillmentCenterFinder {
    UUID findMatchingCenterId(String postalCode);
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterId.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;


@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "fulfillmentCenter_id"))
public class FulfillmentCenterId extends GenericId {
    public FulfillmentCenterId (UUID id) {
        super(id);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;

@Converter(autoApply = true)
public class FulfillmentCenterIdConverter extends GenericIdConverter<FulfillmentCenterId> {
    public FulfillmentCenterIdConverter() {
        super(FulfillmentCenterId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterRepository.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface FulfillmentCenterRepository extends JpaRepository<FulfillmentCenter, FulfillmentCenterId> {
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentInventoryChecker.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import java.util.UUID;

public interface FulfillmentInventoryChecker {
    void setFulfillmentCenter(UUID fulfillmentCenterId);
    boolean hasEnoughInventory(UUID productId, int quantity);
    void removeFromInventory(UUID productId, int quantity);
    void saveChanges();
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\InventoryLevel.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.UUID;

@Entity
@Getter
@Setter
@NoArgsConstructor
public class InventoryLevel {

    @EmbeddedId
    private InventoryLevelId inventoryLevelId;

    private int quantity = 0;
    private int reservedQuantity = 0;

    private UUID productId;

    @Column(name = "fulfillment_center_id")
    private UUID fulfillmentCenterId;

    public InventoryLevel(UUID productIdRaw, int quantity, UUID fulfillmentCenterId) {
        this.productId = productIdRaw;
        this.quantity = quantity;
        this.fulfillmentCenterId = fulfillmentCenterId;
        this.inventoryLevelId = new InventoryLevelId();
    }

    public int getAvailableQuantity() {
        return quantity - reservedQuantity;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\InventoryLevelId.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "inventoryLevel_id"))
public class InventoryLevelId extends GenericId {
    public InventoryLevelId(UUID id) {
        super(id);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\InventoryLevelIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class InventoryLevelIdConverter extends GenericIdConverter<InventoryLevelId> {
    public InventoryLevelIdConverter() {
        super(InventoryLevelId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductCatalogService.java ---
package thkoeln.archilab.ecommerce.solution.product.application;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.solution.product.domain.*;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

import java.util.UUID;

// üß∏ ProductCatalogService ‚Äì Produktverwaltung & Katalog

@Service
@Transactional
public class ProductCatalogService implements ProductCatalogUseCases {

    private final ProductRepository productRepository;
    private final ProductBasketUsageChecker basketUsageChecker;
    private final PurchaseUsage purchaseUsage;
    private final InventoryChecker inventoryChecker;

    public ProductCatalogService(ProductRepository productRepository,
                                 ProductBasketUsageChecker basketUsageChecker,
                                 PurchaseUsage purchaseUsage,
                                 InventoryChecker inventoryChecker) {
        this.productRepository = productRepository;
        this.basketUsageChecker = basketUsageChecker;
        this.purchaseUsage = purchaseUsage;
        this.inventoryChecker = inventoryChecker;
    }

    @Override
    public UUID addProductToCatalog(String name, String descriptOf, Float size,
                                    CurrencyType buyingPrice, CurrencyType salesPrice) {

        if (name == null || name.isBlank() || descriptOf == null || descriptOf.isBlank()) {
            throw new ShopException("Name and description must not be null or empty.");
        }

        if (size != null && size <= 0) {
            throw new ShopException("Size must be greater than 0 if specified.");
        }

        if (buyingPrice == null || salesPrice == null) {
            throw new ShopException("Prices must not be null.");
        }

        if (!salesPrice.largerThan(buyingPrice) &&
                !salesPrice.getQuantity().equals(buyingPrice.getQuantity())) {
            throw new ShopException("Sales price must not be lower than buying price.");
        }

        Currency buying = (Currency) buyingPrice;
        Currency sales = (Currency) salesPrice;

        Product product = new Product(name, descriptOf, size, buying, sales);

        if (productRepository.existsById(product.getProductId())) {
            throw new ShopException("Product ID already exists.");
        }

        productRepository.save(product);
        return product.getProductId().getId();
    }

    @Override
    public void removeProductFromCatalog(UUID productId) {
        if (productId == null) throw new ShopException("Product ID must not be null.");

        ProductId newProductId = new ProductId(productId);
        Product product = productRepository.findById(newProductId)
                .orElseThrow(() -> new ShopException("Product does not exist."));

        if (basketUsageChecker.isProductInAnyBasket(newProductId.getId()) ||
                purchaseUsage.isProductInAnyPurchase(newProductId.getId()) ||
                inventoryChecker.isProductInAnyInventory(newProductId.getId())) {
            throw new ShopException("Product is still referenced somewhere.");
        }

        productRepository.delete(product);
    }

    @Override
    public CurrencyType getSalesPrice(UUID productId) {
        if (productId == null) throw new ShopException("Product ID must not be null.");

        ProductId newProductId = new ProductId(productId);

        return productRepository.findById(newProductId)
                .orElseThrow(() -> new ShopException("Product not found."))
                .getSalesPrice(); // already Currency
    }

    @Override
    public void deleteProductCatalog() {
        basketUsageChecker.deleteAllBaskets();
        purchaseUsage.deleteAllPurchases();
        inventoryChecker.deleteAllCenters();
        productRepository.deleteAll();
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductLookupAdapter.java ---
package thkoeln.archilab.ecommerce.solution.product.application;

import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.solution.product.domain.*;

import java.util.UUID;

@Component
public class ProductLookupAdapter implements ProductLookup {

    private final ProductRepository productRepository;

    public ProductLookupAdapter(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    @Override
    public Product findProductById(UUID productId) {
        return productRepository.findById(new ProductId(productId))
                .orElseThrow(() -> new ShopException("Product not found."));
    }

    @Override
    public boolean isExistingProduct(UUID productId) {
        return productRepository.existsById(new ProductId(productId));
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\InventoryChecker.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import java.util.UUID;

public interface InventoryChecker {
    boolean isProductInAnyInventory(UUID productId);

    void deleteAllCenters();
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\Product.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

@Entity
@Getter
@Setter
@Table(name = "Product")
public class Product {
    @EmbeddedId
    private ProductId productId;

    private String name;
    private String description;
    private Float size;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "quantity", column = @Column(name = "buying_price_quantity")),
            @AttributeOverride(name = "currencyUnit", column = @Column(name = "buying_price_currency"))
    })
    private Currency buyingPrice;  // Direkt als Currency, ohne Adapter

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "quantity", column = @Column(name = "sales_price_quantity")),
            @AttributeOverride(name = "currencyUnit", column = @Column(name = "sales_price_currency"))
    })
    private Currency salesPrice;  // Direkt als Currency, ohne Adapter


    public Product() {}

    public Product(String name, String description, Float size, Currency buyingPrice, Currency salesPrice) {
        this.productId = new ProductId();
        this.name = name;
        this.description = description;
        this.size = size;
        this.buyingPrice = buyingPrice;
        this.salesPrice = salesPrice;
    }

    public CurrencyType getSalesPrice() {
        return salesPrice;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductBasketUsageChecker.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;


import java.util.UUID;

public interface ProductBasketUsageChecker {
    boolean isProductInAnyBasket(UUID productId);

    void deleteAllBaskets();
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductId.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;


@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "product_id"))
public class ProductId extends GenericId {
    public ProductId (UUID id) {
        super(id);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;

@Converter(autoApply = true)
public class ProductIdConverter extends GenericIdConverter<ProductId>{
    public ProductIdConverter() {
        super(ProductId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductLookup.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import java.util.UUID;

public interface ProductLookup {
    Product findProductById(UUID productId);

    boolean isExistingProduct(UUID productId);
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductRepository.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ProductRepository extends JpaRepository<Product, ProductId> {
    Optional<Product> findById(ProductId id);

    boolean existsById(ProductId id);
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\PurchaseUsage.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import java.util.UUID;

public interface PurchaseUsage {
    boolean isProductInAnyPurchase(UUID productId);

    void deleteAllPurchases();
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\PurchaseUsageChecker.java ---
package thkoeln.archilab.ecommerce.solution.product.domain;

import java.util.UUID;

public interface PurchaseUsageChecker {
    boolean isProductInPurchases(UUID productId);
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseService.java ---
package thkoeln.archilab.ecommerce.solution.purchase.application;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchasePosition;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;
import thkoeln.archilab.ecommerce.solution.user.domain.User;
import thkoeln.archilab.ecommerce.solution.user.domain.UserFinder;
import thkoeln.archilab.ecommerce.usecases.PurchaseUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.*;
import java.util.stream.Collectors;

// üßæ PurchaseService ‚Äì Bestellungen & K√§ufe

@Service
public class PurchaseService implements PurchaseUseCases {

    private final PurchaseRepository purchaseRepository;
    private final UserFinder userFinder;

    public PurchaseService(PurchaseRepository purchaseRepository, UserFinder userFinder) {
        this.purchaseRepository = purchaseRepository;
        this.userFinder = userFinder;
    }

    @Transactional
    @Override
    public Map<UUID, Integer> getPurchaseHistory(MailAddressType userMailAddress) {
        if (userMailAddress == null) {
            throw new ShopException("Email must not be null.");
        }

        User user = userFinder.findByMailAddress(userMailAddress)
                .orElseThrow(() -> new ShopException("User not found."));

        List<Purchase> purchases = purchaseRepository.findByUserId(user.getUserId());

        return purchases.stream()
                .flatMap(purchase -> purchase.getPurchasePositions().stream())
                .filter(position -> position.getProductId() != null)
                .collect(Collectors.toMap(
                        PurchasePosition::getProductId,
                        PurchasePosition::getQuantity,
                        Integer::sum
                ));
    }

    @Transactional
    @Override
    public Integer getPurchaseQuantityForProduct(UUID purchaseId, UUID productId) {
        if (purchaseId == null || productId == null) {
            throw new ShopException("Purchase ID and Product ID must not be null.");
        }
        // Hier konvertieren wir die UUID zu PurchaseId
        PurchaseId purchaseIdEntity = new PurchaseId(purchaseId);

        Purchase purchase = purchaseRepository.findById(purchaseIdEntity)
                .orElseThrow(() -> new ShopException("Purchase not found."));

        return purchase.getPurchasePositions().stream()
                .filter(position -> position.getProductId().equals(productId))
                .map(PurchasePosition::getQuantity)
                .findFirst()
                .orElse(0); // Return 0 if the product is not part of the purchase
    }

    @Transactional
    @Override
    public UUID getFulfillmentCenterIdForPurchase(UUID purchaseId) {
        if (purchaseId == null) {
            throw new ShopException("Purchase ID must not be null.");
        }
        // Hier konvertieren wir die UUID zu PurchaseId
        PurchaseId purchaseIdEntity = new PurchaseId(purchaseId);

        Purchase purchase = purchaseRepository.findById(purchaseIdEntity)
                .orElseThrow(() -> new ShopException("Purchase not found."));

        return purchase.getFulfillmentCenterId().getId();
    }

    @Transactional
    @Override
    public void deleteAllPurchases() {
        purchaseRepository.deleteAll();
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseUsageAdapter.java ---
package thkoeln.archilab.ecommerce.solution.purchase.application;

import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.solution.product.domain.PurchaseUsageChecker;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;

import java.util.UUID;

@Component
public class PurchaseUsageAdapter implements PurchaseUsageChecker {

    private final PurchaseRepository purchaseRepository;

    public PurchaseUsageAdapter (PurchaseRepository purchaseRepository) {
        this.purchaseRepository = purchaseRepository;
    }

    @Override
    public boolean isProductInPurchases(UUID productId) {
        return purchaseRepository.findAll().stream()
                .flatMap(p -> p.getPurchasePositions().stream())
                .anyMatch(pos -> pos.getProductId().equals(productId));
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\Purchase.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenter;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterId;
import thkoeln.archilab.ecommerce.solution.user.domain.User;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.*;

@Entity
@Getter
@Setter
@NoArgsConstructor
public class Purchase {
    @EmbeddedId
    private PurchaseId purchaseId;

    @Embedded
    private UserId userId;

    @Embedded
    private FulfillmentCenterId fulfillmentCenterId;

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "purchase_id")
    private List<PurchasePosition> purchasePositions = new ArrayList<>();

    public void addPurchasePosition(PurchasePosition position) {
        this.purchasePositions.add(position);
    }

    public Purchase(UserId userId, FulfillmentCenterId centerId) {
        this.purchaseId = new PurchaseId();
        this.userId = userId;
        this.fulfillmentCenterId = centerId;
    }

    public Purchase(User user, FulfillmentCenter center) {
        this.purchaseId = new PurchaseId();
        this.userId = user.getUserId();
        this.fulfillmentCenterId = new FulfillmentCenterId(center.getFulFillmentCenterId());
    }

    public Purchase(UserId userId, UUID fulfillmentCenterId) {
        this.purchaseId = new PurchaseId();
        this.userId = userId;
        this.fulfillmentCenterId = new FulfillmentCenterId(fulfillmentCenterId);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseId.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "purchase_id"))
public class PurchaseId extends GenericId {
    public PurchaseId (UUID id) {
        super(id);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketId;

@Converter(autoApply = true)
public class PurchaseIdConverter extends GenericIdConverter<PurchaseId> {
    public PurchaseIdConverter() {
        super(PurchaseId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePosition.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.UUID;

@Entity
@Getter
@Setter
@NoArgsConstructor
public class PurchasePosition {
    @EmbeddedId
    private PurchasePositionId purchasePositionId;

    private UUID productId;

    @Setter
    private int quantity;

    public PurchasePosition(UUID productId, int quantity) {
        this.purchasePositionId = new PurchasePositionId();
        this.productId = productId;
        this.quantity = quantity;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePositionId.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;


@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "purchase_position_id"))
public class PurchasePositionId extends GenericId {
    public PurchasePositionId (UUID id) {
        super(id);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePositionIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class PurchasePositionIdConverter extends GenericIdConverter<PurchasePositionId> {
    public PurchasePositionIdConverter () {
        super(PurchasePositionId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseRepository.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.List;

@Repository
public interface PurchaseRepository extends JpaRepository<Purchase, PurchaseId> {
    List<Purchase> findByUserId(UserId userId);
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\BasketFactoryImpl.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
import thkoeln.archilab.ecommerce.solution.user.domain.BasketFactory;

import java.util.UUID;

@Component
@RequiredArgsConstructor
public class BasketFactoryImpl implements BasketFactory {

    private final ShoppingBasketRepository basketRepository;

    @Override
    public void createInitialBasketForUser(UUID userId) {
        ShoppingBasket basket = new ShoppingBasket(new thkoeln.archilab.ecommerce.solution.user.domain.UserId(userId));
        basketRepository.save(basket);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\PurchaseDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import java.util.List;
import java.util.UUID;

public record PurchaseDTO(
        UUID id,
        String userName,
        UUID fulfillmentCenterId,
        List<PurchasePositionDTO> positions
) {}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\PurchasePositionDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import java.util.UUID;

public record PurchasePositionDTO(
        UUID productId,
        int quantity
) {}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.user.domain.BasketFactory;
import thkoeln.archilab.ecommerce.solution.user.domain.User;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/shoppingBaskets")
@RequiredArgsConstructor
public class ShoppingBasketController {

    private final ShoppingBasketService shoppingBasketService;
    private final BasketFactory basketFactory;


    //3) GET /shoppingBaskets?userId=...
    @GetMapping(produces = "application/json")
    public ResponseEntity<ShoppingBasketDTO> getShoppingBasketByUserId(
            @RequestParam(value = "userId", required = false) String userIdStr) {

        if (userIdStr == null) {
            return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).build(); // 405
        }

        UUID userId;
        try {
            userId = UUID.fromString(userIdStr);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build(); // 404 f√ºr ung√ºltige UUID
        }

        try {
            User user = shoppingBasketService.getUserById(userId);
            ShoppingBasket basket = shoppingBasketService.getBasket(user.getMailAddress());
            CurrencyType currencyValue = shoppingBasketService.getShoppingBasketAsCurrencyValue(
                    user.getMailAddress()
            );
            String totalPrice = formatCurrencyString(currencyValue);

            List<ShoppingBasketPositionDTO> positions = basket.getShoppingBasketPositions().stream()
                    .map(pos -> new ShoppingBasketPositionDTO(pos.getProductId(), pos.getQuantity()))
                    .collect(Collectors.toList());

            ShoppingBasketDTO dto = new ShoppingBasketDTO(
                    basket.getShoppingBasketId().getId(),
                    totalPrice,
                    positions
            );

            return ResponseEntity.ok(dto); // 200 OK
        } catch (ShopException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build(); // 404
        }
    }

    private String formatCurrencyString(CurrencyType currency) {
        DecimalFormat formatter = (DecimalFormat) DecimalFormat.getInstance(Locale.getDefault()); //Default Location -> passt sich an ob Komma oder Punkt
        formatter.setMinimumFractionDigits(2);
        formatter.setMaximumFractionDigits(2);
        formatter.setGroupingUsed(false); // Keine Tausendertrennung

        String symbol = switch (currency.getCurrencyUnit()) {
            case "EUR" -> "‚Ç¨";
            case "CHF" -> "CHF";
            default -> currency.getCurrencyUnit();
        };

        return formatter.format(currency.getQuantity()) + " " + symbol;
    }

    //6) POST /shoppingBaskets/{shoppingBasketId}/positions
    @PostMapping("/{shoppingBasketId}/positions")
    public ResponseEntity<Void> addProductToBasket(
            @PathVariable UUID shoppingBasketId,
            @RequestBody(required = false) ShoppingBasketPositionDTO dto) {

        if (dto == null || dto.getProductId() == null || dto.getQuantity() <= 0) {
            return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).build(); // 422
        }

        try {
            shoppingBasketService.addProductByBasketId(shoppingBasketId, dto.getProductId(), dto.getQuantity());
            return ResponseEntity.status(HttpStatus.CREATED).build(); // 201
        } catch (ShopException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build(); // 404
        }
    }

    //10) DELETE /shoppingBaskets/{shoppingBasketId}/positions/{productId}
    @DeleteMapping("/{shoppingBasketId}/positions/{productId}")
    public ResponseEntity<Void> removeProductFromBasket(
            @PathVariable UUID shoppingBasketId,
            @PathVariable UUID productId) {

        try {
            shoppingBasketService.removeProductByBasketId(shoppingBasketId, productId);
            return ResponseEntity.ok().build(); // 200 OK
        } catch (ShopException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build(); // 404
        }
    }

    //11) POST /shoppingBaskets/{shoppingBasketId}/checkout
    @PostMapping("/{shoppingBasketId}/checkout")
    public ResponseEntity<List<PurchaseDTO>> checkoutBasket(@PathVariable UUID shoppingBasketId) {
        try {
            MailAddress mail = (MailAddress) shoppingBasketService.getMailAddressFromBasketId(shoppingBasketId);
            Set<UUID> purchaseIds = shoppingBasketService.checkout(mail);

            List<PurchaseDTO> purchases = purchaseIds.stream()
                    .map(purchaseId -> new PurchaseDTO(
                            purchaseId,
                            shoppingBasketService.getUserByBasketId(shoppingBasketId).getName(),
                            shoppingBasketService.getFulfillmentCenterIdForPurchase(purchaseId),
                            shoppingBasketService.getPositionsForPurchase(purchaseId)
                    ))
                    .toList();
            return ResponseEntity.status(HttpStatus.CREATED).body(purchases);
        } catch (ShopException e) {
            return ResponseEntity.status(HttpStatus.CONFLICT).build(); // 409
        }
    }

    @PostMapping
    public ResponseEntity<Void> createBasket(@RequestParam UUID userId) {
        basketFactory.createInitialBasketForUser(userId);
        return ResponseEntity.ok().build();
    }


    //Zus√§tzlicher GET Endpoint zur Basket-ID
    @GetMapping("/{basketId}")
    public ResponseEntity<ShoppingBasketDTO> getBasketById(@PathVariable UUID basketId) {
        Optional<ShoppingBasket> optional = shoppingBasketService.getBasketById(basketId);
        if (optional.isEmpty()) return ResponseEntity.status(HttpStatus.NOT_FOUND).build();

        ShoppingBasket basket = optional.get();
        //Die Mail-Adresse kommt √ºber den User
        User user = shoppingBasketService.getUserByBasketId(basketId);
        CurrencyType total = shoppingBasketService.getShoppingBasketAsCurrencyValue(user.getMailAddress());

        List<ShoppingBasketPositionDTO> positions = basket.getShoppingBasketPositions().stream()
                .map(pos -> new ShoppingBasketPositionDTO(pos.getProductId(), pos.getQuantity()))
                .toList();

        return ResponseEntity.ok(new ShoppingBasketDTO(
                basket.getShoppingBasketId().getId(),
                formatCurrencyString(total),
                positions
        ));
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;
import java.util.UUID;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class ShoppingBasketDTO {
    private UUID id;
    private String totalSalesPrice;
    private List<ShoppingBasketPositionDTO> positions;
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketMapperHelper.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;

import java.util.List;
import java.util.Locale;
import java.util.stream.Collectors;

public class ShoppingBasketMapperHelper {

    public static ShoppingBasketDTO mapToDTO(ShoppingBasket basket, Currency totalValue) {
        List<ShoppingBasketPositionDTO> positions = basket.getShoppingBasketPositions().stream()
                .map(ShoppingBasketPositionMapperHelper::mapToDTO)
                .collect(Collectors.toList());

        String formattedTotal = formatCurrency(totalValue);

        return new ShoppingBasketDTO(
                basket.getShoppingBasketId().getId(),
                formattedTotal,
                positions
        );
    }

    private static String formatCurrency(Currency currency) {
        String symbol = switch (currency.getCurrencyUnit()) {
            case "EUR" -> "‚Ç¨";
            case "CHF" -> "CHF";
            default -> currency.getCurrencyUnit();
        };

        String formatted = String.format(Locale.getDefault(), "%.2f", currency.getQuantity());
        return formatted + " " + symbol;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketPositionDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.UUID;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class ShoppingBasketPositionDTO {
    private UUID productId;
    private int quantity;
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketPositionMapperHelper.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;

public class ShoppingBasketPositionMapperHelper {

    public static ShoppingBasketPositionDTO mapToDTO(ShoppingBasketPosition position) {
        return new ShoppingBasketPositionDTO(
                position.getProductId(),
                position.getQuantity()
        );
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import thkoeln.archilab.ecommerce.InsufficientInventoryException;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.*;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
import thkoeln.archilab.ecommerce.solution.product.domain.ProductLookup;
import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchasePosition;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.*;
import thkoeln.archilab.ecommerce.solution.user.domain.User;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;


import java.util.*;
import java.util.stream.Collectors;

// üõí ShoppingBasketService ‚Äì Warenkorb-Logik & Checkout

@Service
public class ShoppingBasketService implements ShoppingBasketUseCases {

    private final UserRepository userRepository;
    private final ShoppingBasketRepository shoppingBasketRepository;
    private final PurchaseRepository purchaseRepository;
    private final ProductLookup productLookup;
    private final FulfillmentCenterFinder fulfillmentCenterFinder;
    private final FulfillmentInventoryChecker inventoryChecker;
    private final FulfillmentCenterRepository fulfillmentCenterRepository;

    @Autowired
    public ShoppingBasketService(UserRepository userRepository,
                                 ShoppingBasketRepository shoppingBasketRepository,
                                 PurchaseRepository purchaseRepository,
                                 ProductLookup productLookup,
                                 FulfillmentCenterFinder fulfillmentCenterFinder,
                                 FulfillmentInventoryChecker inventoryChecker, FulfillmentCenterRepository fulfillmentCenterRepository) {
        this.userRepository = userRepository;
        this.shoppingBasketRepository = shoppingBasketRepository;
        this.purchaseRepository = purchaseRepository;
        this.productLookup = productLookup;
        this.fulfillmentCenterFinder = fulfillmentCenterFinder;
        this.inventoryChecker = inventoryChecker;
        this.fulfillmentCenterRepository = fulfillmentCenterRepository;
    }

    @Transactional
    @Override
    public void addProductToShoppingBasket(MailAddressType userMailAddress, UUID productId, int quantityFor) {
        if (quantityFor <= 0) throw new ShopException("Quantity must be positive.");

        ShoppingBasket basket = getBasket(userMailAddress);
        productLookup.findProductById(productId);
        basket.addProduct(productId, quantityFor);
        shoppingBasketRepository.save(basket);
    }

    @Transactional
    @Override
    public void removeProductFromShoppingBasket(MailAddressType userMailAddress, UUID productId, int quantityFor) {
        if (userMailAddress == null || productId == null || quantityFor < 0) {
            throw new ShopException("Invalid input for removeProductFromShoppingBasket.");
        }

        MailAddress mailAddress = (MailAddress) userMailAddress;

        if (mailAddress.toString().isBlank()) {
            throw new ShopException("Mail address is blank.");
        }

        User user = userRepository.findByMailAddress(mailAddress)
                .orElseThrow(() -> new ShopException("User not found."));

        productLookup.findProductById(productId);

        ShoppingBasket basket = shoppingBasketRepository.findByUserId(user.getUserId())
                .orElseThrow(() -> new ShopException("Basket not found."));

        basket.removeProduct(productId, quantityFor);
        shoppingBasketRepository.save(basket);
    }

    @Transactional
    @Override
    public Map<UUID, Integer> getShoppingBasketAsMap(MailAddressType userMailAddress) {
        ShoppingBasket basket = getBasket(userMailAddress);
        return new HashMap<>(basket.toProductQuantityMap());
    }

    @Transactional
    @Override
    public CurrencyType getShoppingBasketAsCurrencyValue(MailAddressType userMailAddress) {
        ShoppingBasket basket = getBasket(userMailAddress);

        Map<UUID, Float> priceMap = new HashMap<>();
        for (ShoppingBasketPosition pos : basket.getShoppingBasketPositions()) {
            var product = productLookup.findProductById(pos.getProductId());
            priceMap.put(pos.getProductId(), product.getSalesPrice().getQuantity());
        }

        float total = basket.getTotalValue(priceMap);
        return Currency.of(total, "EUR"); // oder "CHF" je nach Bedarf
    }

    @Transactional
    @Override
    public Set<UUID> checkout(MailAddressType userMailAddress) {
        User user = getUserByMail(userMailAddress);
        ShoppingBasket basket = getUserBasket(user);
        Map<UUID, Integer> productQuantities = extractProductQuantities(basket);

        List<UUID> purchaseIds = new ArrayList<>();
        PostalCode postalCode = (PostalCode) user.getPhysicalAddress().getPostalCode();
        int postalDigit = Character.getNumericValue(postalCode.toString().charAt(0));

        while (!productQuantities.isEmpty()) {
            List<FulfillmentCenter> sortedCenters = getSortedFulfillmentCenters(productQuantities, postalCode, postalDigit);
            boolean fulfilled = tryFulfillWithCenters(sortedCenters, productQuantities, user, purchaseIds);

            if (!fulfilled) {
                throw new InsufficientInventoryException("Not all products could be fulfilled.");
            }
        }

        basket.clear();
        shoppingBasketRepository.save(basket);
        return new HashSet<>(purchaseIds);
    }

    @Override
    public void emptyAllShoppingBaskets() {
        shoppingBasketRepository.deleteAll();
    }

    //Hilfsmethoden
    private User getUserByMail(MailAddressType userMailAddress) {
        if (userMailAddress == null || userMailAddress.toString().isBlank()) {
            throw new ShopException("Mail address is required.");
        }

        return userRepository.findByMailAddress((MailAddress) userMailAddress)
                .orElseThrow(() -> new ShopException("User not found."));
    }

    private ShoppingBasket getUserBasket(User user) {
        ShoppingBasket basket = shoppingBasketRepository.findByUserId(user.getUserId())
                .orElseThrow(() -> new ShopException("Basket not found."));

        if (basket.getShoppingBasketPositions().isEmpty()) {
            throw new ShopException("Basket is empty.");
        }

        return basket;
    }

    private Map<UUID, Integer> extractProductQuantities(ShoppingBasket basket) {
        Map<UUID, Integer> productQuantities = new HashMap<>();
        for (ShoppingBasketPosition pos : basket.getShoppingBasketPositions()) {
            productQuantities.put(pos.getProductId(), pos.getQuantity());
        }
        return productQuantities;
    }

    private List<FulfillmentCenter> getSortedFulfillmentCenters(Map<UUID, Integer> productQuantities,
                                                                PostalCode userPostalCode,
                                                                int postalDigit) {
        Map<ProductId, Integer> productIdMap = productQuantities.entrySet().stream()
                .collect(Collectors.toMap(e -> new ProductId(e.getKey()), Map.Entry::getValue));

        return fulfillmentCenterRepository.findAll().stream()
                .filter(fc -> (fc.getFromPostalCodeFirstDigit() == 0 && fc.getToPostalCodeFirstDigit() == 0)
                        || (postalDigit >= fc.getFromPostalCodeFirstDigit()
                        && postalDigit <= fc.getToPostalCodeFirstDigit()))
                .sorted(new FulfillmentCenterComparator(productIdMap, userPostalCode))
                .collect(Collectors.toList());
    }

    private boolean tryFulfillWithCenters(List<FulfillmentCenter> centers,
                                          Map<UUID, Integer> productQuantities,
                                          User user,
                                          List<UUID> purchaseIds) {
        for (FulfillmentCenter fc : centers) {
            Map<UUID, Integer> fulfillable = getPartiallyFulfillablePositions(fc, productQuantities);
            if (fulfillable.isEmpty()) continue;

            inventoryChecker.setFulfillmentCenter(fc.getFulFillmentCenterId());
            Purchase purchase = new Purchase(user.getUserId(), fc.getFulFillmentCenterId());

            for (Map.Entry<UUID, Integer> entry : fulfillable.entrySet()) {
                UUID productId = entry.getKey();
                int quantity = entry.getValue();
                inventoryChecker.removeFromInventory(productId, quantity);
                purchase.addPurchasePosition(new PurchasePosition(productId, quantity));
                updateRemainingQuantities(productQuantities, productId, quantity);
            }

            inventoryChecker.saveChanges();
            purchaseRepository.save(purchase);
            purchaseIds.add(purchase.getPurchaseId().getId());
            return true;
        }
        return false;
    }

    private void updateRemainingQuantities(Map<UUID, Integer> quantities, UUID productId, int fulfilled) {
        int remaining = quantities.get(productId) - fulfilled;
        if (remaining <= 0) {
            quantities.remove(productId);
        } else {
            quantities.put(productId, remaining);
        }
    }

    private Map<UUID, Integer> getPartiallyFulfillablePositions(FulfillmentCenter center, Map<UUID, Integer> shoppingBasket) {
        inventoryChecker.setFulfillmentCenter(center.getFulFillmentCenterId());
        Map<UUID, Integer> result = new HashMap<>();

        for (Map.Entry<UUID, Integer> entry : shoppingBasket.entrySet()) {
            UUID productId = entry.getKey();
            int requested = entry.getValue();

            int available = inventoryChecker.hasEnoughInventory(productId, 1) ? // check if any
                    Math.min(requested, center.getInventoryLevel(productId)) : 0;

            if (available > 0) {
                result.put(productId, available);
            }
        }
        return result;
    }

    public ShoppingBasket getBasket(MailAddressType userMailAddress) {
        if (userMailAddress == null) {
            throw new ShopException("Mail address cannot be null.");
        }

        MailAddress mailAddress = (MailAddress) userMailAddress;

        if (mailAddress.toString().isBlank()) {
            throw new ShopException("Mail address is blank.");
        }

        User user = userRepository.findByMailAddress(mailAddress)
                .orElseThrow(() -> new ShopException("User not found."));

        return shoppingBasketRepository.findByUserId(user.getUserId())
                .orElseThrow(() -> new ShopException("Basket not found."));
    }

    public Optional<ShoppingBasket> getBasketById(UUID basketId) {
        return shoppingBasketRepository.findById(new ShoppingBasketId(basketId));
    }

    public User getUserById(UUID userId) {
        return userRepository.findById(new UserId(userId))
                .orElseThrow(() -> new ShopException("User not found"));
    }

    public User getUserByBasketId(UUID basketId) {
        ShoppingBasket basket = shoppingBasketRepository.findById(new ShoppingBasketId(basketId))
                .orElseThrow(() -> new ShopException("Basket not found"));
        return userRepository.findById(basket.getUserId())
                .orElseThrow(() -> new ShopException("User not found"));
    }

    public void addProductByBasketId(UUID basketId, UUID productId, int quantity) {
        User user = getUserByBasketId(basketId);
        addProductToShoppingBasket(user.getMailAddress(), productId, quantity);
    }

    public void removeProductByBasketId(UUID basketId, UUID productId) {
        User user = getUserByBasketId(basketId);
        ShoppingBasket basket = getBasket(user.getMailAddress());

        Optional<ShoppingBasketPosition> maybePos = basket.getShoppingBasketPositions().stream()
                .filter(pos -> pos.getProductId().equals(productId))
                .findFirst();

        if (maybePos.isEmpty()) {
            throw new ShopException("Product not in basket.");
        }

        int actualQuantity = maybePos.get().getQuantity();
        removeProductFromShoppingBasket(user.getMailAddress(), productId, actualQuantity);
    }

    public MailAddressType getMailAddressFromBasketId(UUID basketId) {
        ShoppingBasket basket = getBasketById(basketId)
                .orElseThrow(() -> new ShopException("Basket not found"));

        User user = userRepository.findById(basket.getUserId())
                .orElseThrow(() -> new ShopException("User not found"));

        return user.getMailAddress();
    }

    public UUID getFulfillmentCenterIdForPurchase(UUID purchaseId) {
        if (purchaseId == null) {
            throw new ShopException("Purchase ID must not be null.");
        }

        PurchaseId purchaseIdEntity = new PurchaseId(purchaseId);
        Purchase purchase = purchaseRepository.findById(purchaseIdEntity)
                .orElseThrow(() -> new ShopException("Purchase not found."));

        return purchase.getFulfillmentCenterId().getId();
    }

    public List<PurchasePositionDTO> getPositionsForPurchase(UUID purchaseId) {
        PurchaseId id = new PurchaseId(purchaseId);
        Purchase purchase = purchaseRepository.findById(id)
                .orElseThrow(() -> new ShopException("Purchase not found"));

        return purchase.getPurchasePositions().stream()
                .map(pos -> new PurchasePositionDTO(pos.getProductId(), pos.getQuantity()))
                .toList();
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.*;
import java.util.stream.Collectors;

@Entity
@Getter
@Setter
@NoArgsConstructor
public class ShoppingBasket {
    @EmbeddedId
    private ShoppingBasketId shoppingBasketId;

    @Embedded
    private UserId userId;

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "shopping_basket_id")
    private List<ShoppingBasketPosition> shoppingBasketPositions = new ArrayList<>();

    public ShoppingBasket(UserId userId) {
        this.shoppingBasketId = new ShoppingBasketId();
        this.userId = userId;
    }

    public void addProduct(UUID productId, int quantity) {
        for (ShoppingBasketPosition position : shoppingBasketPositions) {
            if (position.getProductId().equals(productId)) {
                position.setQuantity(position.getQuantity() + quantity);
                return;
            }
        }

        shoppingBasketPositions.add(new ShoppingBasketPosition(productId, quantity));
    }


    public void removeProduct(UUID productIdRaw, int quantity) {
        Optional<ShoppingBasketPosition> existing = shoppingBasketPositions.stream()
                .filter(pos -> pos.getProductId().equals(productIdRaw))
                .findFirst();

        if (existing.isEmpty()) {
            throw new ShopException("Product is not in the shopping basket.");
        }

        ShoppingBasketPosition pos = existing.get();

        if (pos.getQuantity() < quantity) {
            throw new ShopException("Product is not in the shopping basket in the requested quantity.");
        }

        if (pos.getQuantity() == quantity) {
            shoppingBasketPositions.remove(pos);
        } else {
            pos.setQuantity(pos.getQuantity() - quantity);
        }
    }

    public boolean isEmpty() {
        return shoppingBasketPositions.isEmpty();
    }

    public float getTotalValue(Map<UUID, Float> productPrices) {
        return (float) shoppingBasketPositions.stream()
                .mapToDouble(pos -> {
                    UUID id = pos.getProductId();
                    return productPrices.getOrDefault(id, 0f) * pos.getQuantity();
                })
                .sum();
    }

    public void clear() {
        shoppingBasketPositions.clear();
    }

    public Map<UUID, Integer> toProductQuantityMap() {
        return shoppingBasketPositions.stream()
                .collect(Collectors.toMap(
                                 ShoppingBasketPosition::getProductId,
                         ShoppingBasketPosition::getQuantity
        ));
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketId.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;


@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "shoppingBasket_id"))
public class ShoppingBasketId extends GenericId {
    public ShoppingBasketId (UUID id) {
        super(id);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ShoppingBasketIdConverter extends GenericIdConverter<ShoppingBasketId> {
    public ShoppingBasketIdConverter() {
        super(ShoppingBasketId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.UUID;

@Entity
@Getter
@Setter
@NoArgsConstructor
public class ShoppingBasketPosition {
    @EmbeddedId
    private ShoppingBasketPositionId shoppingBasketPositionId;

    private UUID productId;

    private int quantity;

    public ShoppingBasketPosition(UUID productId, int quantity) {
        this.shoppingBasketPositionId = new ShoppingBasketPositionId();
        this.productId = productId;
        this.quantity = quantity;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionId.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "shoppingBasketPosition_id"))
public class ShoppingBasketPositionId extends GenericId {
    public ShoppingBasketPositionId (UUID id) {
        super(id);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ShoppingBasketPositionIdConverter extends GenericIdConverter<ShoppingBasketPositionId> {
    public ShoppingBasketPositionIdConverter() {
        super(ShoppingBasketPositionId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketRepository.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import org.springframework.data.jpa.repository.JpaRepository;
import thkoeln.archilab.ecommerce.solution.user.domain.UserId;

import java.util.Optional;

public interface ShoppingBasketRepository extends JpaRepository<ShoppingBasket, ShoppingBasketId> {
    Optional<ShoppingBasket> findByUserId(UserId userId);
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\MailAddressDTO.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;

public record MailAddressDTO(String mailAddressString) {
    public static MailAddressDTO from(MailAddress mailAddress) {
        return new MailAddressDTO(mailAddress.toString());
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\PhysicalAddressDTO.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;

public record PhysicalAddressDTO(
        String street,
        String city,
        PostalCodeDTO postalCode
) {
    public static PhysicalAddressDTO from(PhysicalAddress address) {
        return new PhysicalAddressDTO(
                address.getStreet(),
                address.getCity(),
                PostalCodeDTO.from((PostalCode) address.getPostalCode())  // cast n√∂tig hier
        );
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\PostalCodeDTO.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;

public record PostalCodeDTO(String postalCodeString) {
    public static PostalCodeDTO from(PostalCode postalCode) {
        return new PostalCodeDTO(postalCode.toString());
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserController.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.NotFoundException;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;

@RestController
@RequestMapping("/users")
public class UserController {

    private final UserRegistrationUseCases userService;

    public UserController(UserRegistrationUseCases userService) {
        this.userService = userService;
    }

    //2) Query a specific user by mailAddress
    //Workshop Notiz: baldung & stackoverflow recherchieren bei solchen Aufgaben
    @GetMapping
    public ResponseEntity<UserResponseDTO> getUserByMailAddress(@RequestParam(name = "mailAddress") String mailAddressString) {
        MailAddress mailAddress = new MailAddress(mailAddressString);
        UserDTO user;

        try {
            user = (UserDTO) userService.getUserData(mailAddress);
        } catch (Exception e) {
            throw new NotFoundException("User not found with mail: " + mailAddressString);
        }
        return ResponseEntity.ok(UserResponseDTO.from(user));
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserDTO.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import lombok.Getter;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.UUID;

public class UserDTO implements UserType {

    @Getter
    private final UUID userId;

    private final String name;
    private final MailAddress mailAddress;
    private final PhysicalAddress physicalAddress;

    public UserDTO(UUID userId, String name, MailAddress mailAddress, PhysicalAddress physicalAddress) {
        this.userId = userId;
        this.name = name;
        this.mailAddress = mailAddress;
        this.physicalAddress = physicalAddress;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public MailAddressType getMailAddress() {
        return mailAddress;
    }

    @Override
    public PhysicalAddressType getPhysicalAddress() {
        return physicalAddress;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserFinderAdapter.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.solution.adapter.MailAddressJpaAdapter;
import thkoeln.archilab.ecommerce.solution.user.domain.User;
import thkoeln.archilab.ecommerce.solution.user.domain.UserFinder;
import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.Optional;

@Component
public class UserFinderAdapter implements UserFinder {

    private final UserRepository userRepository;

    public UserFinderAdapter(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public Optional<User> findByMailAddress(MailAddressType mailAddress) {
        if (mailAddress == null) return Optional.empty();

        MailAddress address = (MailAddress) mailAddress;

        return userRepository.findByMailAddress((MailAddress) mailAddress);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserRegistrationService.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.solution.user.domain.BasketFactory;
import thkoeln.archilab.ecommerce.solution.user.domain.User;
import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

// üßë‚Äçüíª UserRegistrationService ‚Äì Benutzerregistrierung & Login

@Service
public class UserRegistrationService implements UserRegistrationUseCases {

    private final UserRepository userRepository;
    private final BasketFactory basketFactory;

    @Autowired
    public UserRegistrationService(UserRepository userRepository,
                                   BasketFactory basketFactory) {
        this.userRepository = userRepository;
        this.basketFactory = basketFactory;
    }

    @Transactional
    @Override
    public void register(String name, MailAddressType mailAddress, PhysicalAddressType physicalAddress) {
        if (name == null || name.isBlank() || mailAddress == null || physicalAddress == null) {
            throw new ShopException("All user fields must be filled.");
        }

        MailAddress address = (MailAddress) mailAddress;

        if (userRepository.existsByMailAddress((MailAddress) mailAddress)) {
            throw new ShopException("User already exists with this email.");
        }

        User user = new User(address, name, (PhysicalAddress) physicalAddress);
        userRepository.save(user);
        basketFactory.createInitialBasketForUser(user.getUserId().getId());
    }

    @Transactional
    @Override
    public void changeAddress(MailAddressType userMailAddress, PhysicalAddressType physicalAddress) {
        if (userMailAddress == null || physicalAddress == null) {
            throw new ShopException("All address fields must be filled.");
        }

        User user = userRepository.findByMailAddress((MailAddress) userMailAddress)
                .orElseThrow(() -> new ShopException("User not found."));

        user.setPhysicalAddress((PhysicalAddress) physicalAddress);
        userRepository.save(user);
    }

    @Transactional
    @Override
    public UserType getUserData(MailAddressType userMailAddress) {
        User user = userRepository.findByMailAddress((MailAddress) userMailAddress)
                .orElseThrow(() -> new ShopException("User not found."));

        return new UserDTO(
                user.getUserId().getId(),
                user.getName(),
                user.getMailAddress(),
                user.getPhysicalAddress()
                );
    }

    @Transactional
    @Override
    public void deleteAllUsers() {
        userRepository.deleteAll();
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserResponseDTO.java ---
package thkoeln.archilab.ecommerce.solution.user.application;

import com.fasterxml.jackson.annotation.JsonProperty;

import java.util.UUID;

public record UserResponseDTO(
        @JsonProperty("id") UUID id,
        @JsonProperty("name") String name,
        @JsonProperty("mailAddress") MailAddressDTO mailAddress,
        @JsonProperty("physicalAddress") PhysicalAddressDTO physicalAddress
) {
    public static UserResponseDTO from(UserDTO userDTO) {
        return new UserResponseDTO(
                userDTO.getUserId(),
                userDTO.getName(),
                MailAddressDTO.from((thkoeln.archilab.ecommerce.domainprimitives.MailAddress) userDTO.getMailAddress()),
                PhysicalAddressDTO.from((thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress) userDTO.getPhysicalAddress())
        );
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\BasketFactory.java ---
package thkoeln.archilab.ecommerce.solution.user.domain;

import java.util.UUID;

public interface BasketFactory {
    void createInitialBasketForUser(UUID userId);
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\User.java ---
package thkoeln.archilab.ecommerce.solution.user.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;

@Entity
@Getter
@Setter
@Table(name = "Uuuser")
public class User {
    @EmbeddedId
    private UserId userId;

    private String name;

    @Getter
    @Embedded
    private MailAddress mailAddress;

    @Setter
    @Getter
    @Embedded
    private PhysicalAddress physicalAddress;

    public User() {}

    public User(MailAddress mailAddress, String name, PhysicalAddress address) {
        this.userId = new UserId();
        this.mailAddress = mailAddress;
        this.name = name;
        this.physicalAddress = address;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserFinder.java ---
package thkoeln.archilab.ecommerce.solution.user.domain;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.Optional;

public interface UserFinder {
    Optional<User> findByMailAddress(MailAddressType mailAddress);
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserId.java ---
package thkoeln.archilab.ecommerce.solution.user.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "user_id"))
public class UserId extends GenericId {
    public UserId (UUID id) {
        super(id);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.user.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class UserIdConverter extends GenericIdConverter<UserId> {
    public UserIdConverter() {
        super(UserId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserRepository.java ---
package thkoeln.archilab.ecommerce.solution.user.domain;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, UserId> {
    Optional<User> findByMailAddress(MailAddress mailAddress);

    boolean existsByMailAddress(MailAddress mailAddress);

}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\CurrencyType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface CurrencyType {
    /**
     * @return the quantity of currency
     */
    public Float getQuantity();


    /**
     * @return the currency unit of the currency
     */
    public String getCurrencyUnit();


    /**
     * @param otherCurrency
     * @return this + otherCurrency, as a new object
     * @throws ShopException if ...
     *      - otherCurrency is null
     *      - otherCurrency.currencyUnit != this.currencyUnit
     */
    public CurrencyType add( CurrencyType otherCurrency );


    /**
     * @param otherCurrency
     * @return this - otherCurrency, as a new object
     * @throws ShopException if ...
     *      - otherCurrency is null
     *      - otherCurrency.currencyUnit != this.currencyUnit
     *      - otherCurrency > this
     */
    public CurrencyType subtract( CurrencyType otherCurrency );


    /**
     * @param factor
     * @return this * factor, as a new object
     * @throws ShopException if ...
     *     - factor < 0
     */
    public CurrencyType multiplyBy( int factor );

    /**
     * @param otherCurrency
     * @return true, if this > otherCurrency
     * @throws ShopException if ...
     *      - otherCurrency is null
     *      - otherCurrency.currencyUnit != this.currencyUnit
     */
    public boolean largerThan( CurrencyType otherCurrency );


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates a currency object from an quantity and a currency unit (as string).
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param quantity the quantity of currency (must be >= 0)
     * @param currencyUnit the currency unit of the currency (allowed values: "EUR", "CHF")
     * @return a new Currency object with the given quantity and currency unit
     * @throws ShopException if ...
     *   - quantity is null
     *   - quantity < 0
     *   - currency unit is null
     *   - currency unit is not one of the allowed values
     */
     // public static CurrencyType of( Float quantity, String currencyUnit );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MailAddressType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface MailAddressType {
    /**
     * @return the mail address as a string
     */
    public String toString();


    /**
     * A special kind of "copy constructor": Returns a new mail address object with
     * the same identifyer (the substring left of the "@" sign) as the current one, but
     * with a new domain substring (right of the "@" sign).
     * @param domainString - the new domain for the copied mail address
     * @return the new mail address
     * @throws ShopException if ...
     *     - domainString is null
     *     - the new mail address would not be valid (see `of(...)` method)
     */
    public MailAddressType sameIdentifyerDifferentDomain( String domainString );

    /**
     * Another special kind of "copy constructor": Returns a new mail address object
     * with the same domain (the substring right of the "@" sign) as the current one, but
     * with a new identifyer substring (left of the "@" sign).
     * @param identifyerString - the new identifyer for the copied mail address
     * @return the new mail address
     * @throws ShopException if ...
     *     - identifyerString is null
     *     - the new mail address would not be valid (see `of(...)` method)
     */
    public MailAddressType sameDomainDifferentIdentifyer( String identifyerString );


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an mail address, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param mailAddressAsString - the mail address as a string.
     *      We will use a much simplified validation method to check if the mail address is valid:
     *      - it must contain exactly one '@' character.
     *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
     *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
     *      - the substrings before and after the '@' may contain one or several '.' as separators
     *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
     *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
     *        (for simplicity we do not allow any other domains)
     * @return a new MailAddressType object matching the given mail address
     * @throws ShopException if ...
     *      - mailAddressAsString is null
     *      - mailAddressAsString is not a valid mail address (see above)
     */
     // public static MailAddressType of( String mailAddressAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PhysicalAddressType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface PhysicalAddressType {
    /**
     * @return the street as a string
     */
    public String getStreet();

    /**
     * @return the city as a string
     */
    public String getCity();

    /**
     * @return the postal code
     */
    public PostalCodeType getPostalCode();

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an postal code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param street the street as a string
     * @param city the city as a string
     * @param postalCode the postal code
     * @return the physical address object matching the parameters
     * @throws ShopException if ...
     *      - street is null or empty
     *      - city is null or empty
     *      - postalCode is null
     */
     // public static PhysicalAddressType of( String street, String city, PostalCodeType postalCode );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PostalCodeType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import com.fasterxml.jackson.annotation.JsonIgnore;
import thkoeln.archilab.ecommerce.ShopException;

public interface PostalCodeType {
    /**
     * @return the postal code as a string
     */
    public String toString();

    /**
     * You will need some idea of "imprecise distance" between two postal codes for properly
     * implementing fulfillment centers in your shopping platform. This method calculates such a
     * distance. You can decide for yourself what values you return, unless you comply
     * with the following rules.
     * - The return value is 0 if both postal codes are the same
     * - If not:
     *      - The distance is > 0 if both postal codes differ in the last digit, like 5673x
     *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
     *        So, 56733 and 56734 have the same distance as 56733 and 56739.
     *      - The distance grows if more digits (counted from the right side) differ.
     *        So, 5abcd and 5rstu have a larger distance than 53bcd and 53stu (if abcd
     *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
     *        53876 and 54876 have the same distance as 53876 and 57261.
     *      - However, the distance between 5abcd and 6rstu must be smaller than the one
     *        between 5abcd and 7rstu, and this distance in turn must be smaller than the
     *        one between 5abcd and 9rstu.
     *      - This last condition reflects the fact the first digits of a postal code marks a region
     *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
     *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
     *        other.
     * @param otherPostalCode
     * @return the calculated distance
     * @throws ShopException if otherPostalCode is null
     */
    public int distance( PostalCodeType otherPostalCode );


    /**
     * For the currently used way of deciding on the best fitting fulfillment center for a purchase,
     * we need to know the first digit of the postal code.
     */
    @JsonIgnore
    public Integer getFirstDigitPostalCode();


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an postal code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param postalCodeAsString - the postal code as a string.
     *      We will use a much simplified validation method to check if the postal code is valid:
     *      - It must contain exactly 5 digits.
     *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid postal code, but 20001 is valid)
     * @return a new postal code object matching the given string
     * @throws ShopException if ...
     *      - postalCodeAsString is null
     *      - postalCodeAsString is not a valid postal code (see above)
     */
     // public static PostalCodeType of( String postalCodeAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\FulfillmentCenterUseCases.java ---
/*
 * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.UUID;

/**
 * This interface contains methods needed in the context of handling the shop inventory,
 * i.e. managing fulfillment centers, and adding / removing products in the fulfillment center.
 */
public interface FulfillmentCenterUseCases {
    /**
     *
     * @param name
     * @param physicalAddress
     * @return the id of the new fulfillment center
     * @throws ShopException if ...
     *      - name is null or empty
     *      - physicalAddress is null
     */
    public UUID addNewFulfillmentCenter( String name, PhysicalAddressType physicalAddress );


    /**
     * Deletes all fulfillment centers from the shop. Intended for testing purposes.
     */
    public void deleteAllFulfillmentCenters();


    /**
     * Adds a certain Quantity of a given product to the inventory
     * @param fulfillmentCenterId
     * @param productId
     * @param addedQuantityFor
     * @throws ShopException if ...
     *      - fulfillmentCenterId is null
     *      - the fulfillment center with that id does not exist
     *      - productId is null
     *      - the product with that id does not exist
     *      - addedQuantityFor < 0
     */
    public void addToInventory( UUID fulfillmentCenterId, UUID productId, int addedQuantityFor );


    /**
     * Removes a certain Quantity of a given product from the inventory.
     * @param fulfillmentCenterId
     * @param productId
     * @param removedQuantityFor
     * @throws ShopException if ...
     *      - fulfillmentCenterId is null
     *      - the fulfillment center with that id does not exist
     *      - productId is null
     *      - the product with that id does not exist
     *      - removedQuantityFor < 0
     */
    public void removeFromInventory( UUID fulfillmentCenterId, UUID productId, int removedQuantityFor );


    /**
     * Changes the total Quantity of a given product in the inventory.
     * @param fulfillmentCenterId
     * @param productId
     * @param newTotalQuantityFor
     * @throws ShopException if ...
     *      - fulfillmentCenterId is null
     *      - the fulfillment center with that id does not exist
     *      - productId is null
     *      - the product with that id does not exist
     *      - newTotalQuantityFor < 0
     */
    public void changeInventoryTo( UUID fulfillmentCenterId, UUID productId, int newTotalQuantityFor );


    /**
     * Get the current inventory of a given product in one specific fulfillment center.
     * @param fulfillmentCenterId
     * @param productId
     * @return the current total inventory of the product
     * @throws ShopException if ...
     *      - fulfillmentCenterId is null
     *      - the fulfillment center with that id does not exist
     *      - productId is null
     *      - the product with that id does not exist
     */
    public int getAvailableInventory( UUID fulfillmentCenterId, UUID productId );


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.Enumeration;

import static org.junit.jupiter.api.Assertions.*;

public class FactoryMethodInvoker {

    public static MailAddressType instantiateMailAddress( String mailAddressAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for MailAddressType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, mailAddressAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + mailAddressAsString + "'", e );
        }
        assertNotNull( instance );
        return (MailAddressType) instance;
    }


    public static PhysicalAddressType instantiatePhysicalAddress(
            String street, String city, PostalCodeType postalCode ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of",
                    String.class, String.class, PostalCodeType.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for PhysicalAddressType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, street, city, postalCode );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" +
                    street + "', '" + city + "', '" + postalCode + "'", e );
        }
        assertNotNull( instance );
        return (PhysicalAddressType) instance;
    }


    public static PostalCodeType instantiatePostalCode( String postalCodeAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for PostalCodeType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, postalCodeAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + postalCodeAsString + "'", e );
        }
        assertNotNull( instance );
        return (PostalCodeType) instance;
    }


    public static CurrencyType instantiateCurrency( Float quantity, String currencyUnit ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for CurrencyType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, quantity, currencyUnit );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + quantity + "', '" + currencyUnit + "'", e );
        }
        assertNotNull( instance );
        return (CurrencyType) instance;
    }


    private static Class<?> findImplementation( Class<?> interfaceClass ) {
        Method factoryMethod = null;
        try {
            String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
            Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
            assertNotNull( implementingClass );
            return implementingClass;
        } catch (Exception e) {
            fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
            return null; // This line will never be reached, but it's necessary to satisfy the compiler
        }
    }


    private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
            throws ClassNotFoundException, IOException {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        String path = packageName.replace( '.', '/' );
        Enumeration<URL> resources = classLoader.getResources( path );
        int count = 0;
        Class<?> result = null;
        while (resources.hasMoreElements()) {
            URL resource = resources.nextElement();
            File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
            File[] files = directory.listFiles();
            for ( File file : files ) {
                if ( file.getName().endsWith( ".class" ) ) {
                    String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
                    Class<?> clazz = Class.forName( className );
                    if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
                        count++;
                        result = clazz;
                    }
                }
            }
        }
        assertEquals( 1, count, "There should be exactly one implementing class" );
        return result;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FulfillmentCenterTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import java.util.UUID;

public interface FulfillmentCenterTestHelper {
    /**
     * Adds the test fulfillment centers to the system.
     * If you want to use the fulfillment centers, or want to know which index the fulfillment center has that you see
     * in the debugger, the following rules apply:
     * - The fulfillment center name will equal the street name of the physical address of the fulfillment center.
     * - The index number is visible in the house number. Example: fulfillment center 3 is located at
     *   "Ablageweg 3", and that is also its name.
     *
     *  The fulfillment centers are used in the tests as follows:
     *  - fulfillment center 0 holds all products 0 - 6, and is used for all tests where it is not relevant
     *    to split one shopping basket into several purchases.
     *  - fulfillment centers 1 - 3 are used for the proximity tests, where you can deliver product 7 to
     *    to a user from the closest fulfillment center.
     *  - fulfillment centers 4 - 8 are used for the tests where you need to deliver products 8 - 14 in
     *    the most cost-efficient way, as multiple shipments.
     *  - fulfillment center 9 is empty.
     *
     *  If withInventory is true, then the fulfillment centers are filled with products. This happens
     *  according to the following rules:
     *  - products 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
     *    ONLY available in fulfillment center 0. (This means that product 0 out of inventory everywhere.)
     *  - products 4, 5, 6 have a random inventory between 30 and 130, also all ONLY in fulfillment center 0
          (these are the products used for tests on how to add and remove inventory)
     *  - product 7 has a random inventory between 30 and 130, distributed over
     *    fulfillment centers 1, 2, and 3. You can use this to test if the appropriate fulfillment center is found
     *    for a shopping basket with only product 7 in it, but with different quantities (<= 3, or > 3).
     *  - The other products (8 - 14) have also a random inventory between 30 and 130, all distributed
     *    over several fulfillment centers. The distribution is done as follows:
     *    Assume that the product is available in <n> fulfillment centers. Then the first <n-1> fulfillment centers
     *    in the list (in ascending sequence) contain 3, and all the remaining inventory is in the
     *    last fulfillment center.
     *
     *    This is how the inventory of products could be distributed
     *    (Wx = fulfillment center x with its postal code, Px = product x,
     *    numbers marked with (*) are random large numbers):
     *
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
     *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *    | P0   |      |     |     |      |     |      |     |       |      |     |
     *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
     *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
     *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
     *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
     *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
     *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
     *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
     *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
     *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
     *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
     *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
     *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
     *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
     *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *
     * @param withInventory if true, the inventory of the products is added to the fulfillment center. Otherwise, the
     *                           the inventory is not added and the fulfillment center is empty.
     */
    public void addAllFulfillmentCenters( boolean withInventory );


    /**
     * @return the number of test fulfillment centers in the database
     */
    int numberOfFulfillmentCenters();


    /**
     * @param index
     * @return the id of the test fulfillment center at the given index
     */
    UUID getFulfillmentCenterId( int index );


    /**
     * @param fulfillmentCenterId - the id of the fulfillment center in the test data
     * @return the index of the test fulfillment center with that id
     */
    int findFulfillmentCenterIndex( UUID fulfillmentCenterId );


    /**
     * @param productIndex - the index of the product in the test data
     * @param fulfillmentCenterIndex - the index of the fulfillment center in the test data
     * @return the number of products (inventory) available in the fulfillment center at the given index
     */
    Integer getFulfillmentCenterInventory( int fulfillmentCenterIndex, int productIndex );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\InventoryTestHelperImpl.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;

import java.util.*;

/**
 * This is a test helper class that initializes and registers products (but without inventory)
 * in the system, using the given interface(s).
 */
@Component
@SuppressWarnings("PMD")
public class InventoryTestHelperImpl
                        implements ProductTestHelper, FulfillmentCenterTestHelper {
    private ProductCatalogUseCases productCatalogUseCases;
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    private static Random random = new Random();

    private static final String EUR = "EUR";
    private static final int PRODUCT_NUMOF = 15;
    private static final Object[][] PRODUCT_DATA = new Object[][]{
            {null, "0-TCD-34 v2.1", "Universelles Verbindungsst√ºck f√ºr den einfachen Hausgebrauch bei der Schnellmontage",
                    1.5f, FactoryMethodInvoker.instantiateCurrency( 5.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 10.0f, EUR ),
                    "0"},
            {null, "1-EFG-56", "Hochleistungsf√§higer Kondensator f√ºr elektronische Schaltungen",
                    0.3f, FactoryMethodInvoker.instantiateCurrency( 2.5f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 4.0f, EUR ),
                    "0"},
            {null, "2-MNP-89ff", "Langlebiger und robuster Motor f√ºr industrielle Anwendungen",
                    7.2f, FactoryMethodInvoker.instantiateCurrency( 50.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 80.0f, EUR ),
                    "0"},
            {null, "3-Gh-25", "Kompakter und leichter Akku f√ºr mobile Ger√§te",
                    null, FactoryMethodInvoker.instantiateCurrency( 6.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 8.0f, EUR ),
                    "0"},
            {null, "4-MultiBeast2", "Vielseitiger Adapter f√ºr verschiedene Steckertypen",
                    null, FactoryMethodInvoker.instantiateCurrency( 0.6f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 1.0f, EUR ),
                    "0"},
            {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor f√ºr Computer und Server",
                    1.0f, FactoryMethodInvoker.instantiateCurrency( 150.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 250.0f, EUR ),
                    "0"},
            {null, "6-Stuko22", "Ersatzteil Spitze f√ºr Pr√§zisionswerkzeug zum L√∂ten und Schrauben",
                    null, FactoryMethodInvoker.instantiateCurrency( 0.3f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 0.5f, EUR ),
                    "0"},
            {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
                    6.0f, FactoryMethodInvoker.instantiateCurrency( 80.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 120.0f, EUR ),
                    "123"},
            {null, "8-JKL-67", "Wasserdichtes Geh√§use",
                    3.0f, FactoryMethodInvoker.instantiateCurrency( 1.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 1.2f, EUR ),
                    "467"},
            {null, "9-MNO-55-33", "Modulares Netzteil f√ºr flexible Stromversorgung",
                    5.5f, FactoryMethodInvoker.instantiateCurrency( 25.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 45.0f, EUR ),
                    "578"},
            {null, "10-PQR-80", "Effizienter K√ºhler f√ºr verbesserte W√§rmeableitung",
                    4.0f, FactoryMethodInvoker.instantiateCurrency( 20.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 35.0f, EUR ),
                    "567"},
            {null, "11-STU-11 Ld", "Hochwertiger Grafikchip f√ºr leistungsstarke PCs",
                    null, FactoryMethodInvoker.instantiateCurrency( 200.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 350.0f, EUR ),
                    "478"},
            {null, "12-VWX-90 FastWupps", "Schnellladeger√§t f√ºr eine Vielzahl von Ger√§ten",
                    null, FactoryMethodInvoker.instantiateCurrency( 15.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 25.0f, EUR ),
                    "5"},
            {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
                    3.5f, FactoryMethodInvoker.instantiateCurrency( 60.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 100.0f, EUR ),
                    "78"},
            {null, "14-Nosedive", "Klammer zum Verschlie√üen der Nase beim Tauchen",
                    5.0f, FactoryMethodInvoker.instantiateCurrency( 2.0f, EUR ),
                    FactoryMethodInvoker.instantiateCurrency( 5.0f, EUR ),
                    "457"}
    };
    

    // These physical addresss are used for the fulfillment centers. The fulfillment center name will equal
    // the postal code of the site. Their index number will be visible in the house number.
    // The fulfillment centers are used as such:
    // - fulfillment center 0 is holds all products 0 - 6, and is used for all tests where multiple
    //   shipments are irrelevant.
    // - fulfillment centers 1 - 3 are used for the proximity tests, where you can deliver products 7 to
    //   to a user from the closest fulfillment center.
    // - fulfillment centers 4 - 8 are used for the tests where you need to deliver products 8 - 14 in
    //   the most cost-efficient way, as multiple shipments.
    // - fulfillment center 9 is empty.
    private final static int FULFILLMENT_CENTER_NUMOF = 10;
    private final static PhysicalAddressType[] FULFILLMENT_CENTER_PHYSICAL_ADDRESS = new PhysicalAddressType[]{
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Stapelallee 0", "Potsdam",
                    FactoryMethodInvoker.instantiatePostalCode( "14476" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Lagerhausstr. 1", "Viertelstadt",
                    FactoryMethodInvoker.instantiatePostalCode( "02345" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Speicherplatz 2", "Viertelstadt",
                    FactoryMethodInvoker.instantiatePostalCode( "02313" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Ablageweg 3", "Reichsw√ºrgen",
                    FactoryMethodInvoker.instantiatePostalCode( "44923" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Paketstellenallee 4", "D√ºsseldorf",
                    FactoryMethodInvoker.instantiatePostalCode( "40588" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Kaputte-Sachen-Stra√üe 5", "D√ºren",
                    FactoryMethodInvoker.instantiatePostalCode( "52355" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Aufbewahrungsweg 6", "Viernheim",
                    FactoryMethodInvoker.instantiatePostalCode( "68519" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Paketallee 7", "Baden-Baden",
                    FactoryMethodInvoker.instantiatePostalCode( "76532" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Sendenstr. 8", "Senden",
                    FactoryMethodInvoker.instantiatePostalCode( "89250" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Schickweg 9", "Hohenroth",
                    FactoryMethodInvoker.instantiatePostalCode( "97618" ) )
    };
    private final static UUID[] FULFILLMENT_CENTER_ID = new UUID[FULFILLMENT_CENTER_NUMOF];


    // These data structures contain the inventory of the products in the fulfillment centers.
    // PRODUCT_INVENTORY is a map product name -> Integer[FULFILLMENT_CENTER_NUMOF].
    // The Integer[FULFILLMENT_CENTER_NUMOF] contains the inventory of the product in each of
    // the fulfillment centers.
    //
    // The following rules apply:
    // - product 0 is out of inventory
    // - product 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in fulfillment center 0
    // - product 4 / 5 / 6 have a random inventory between 30 and 130, also all ONLY in fulfillment center 0
    //   (these are the products used for tests on how to add and remove inventory)
    // - the others have a random inventory between 30 and 130, distributed over several
    //   fulfillment centers. Here we follow this convention for simplicity:
    //   - Assume that the product is available in <n> fulfillment centers. Then the first <n-1> fulfillment centers
    //     in the list (in ascending sequence) contain 3, and all the remaining inventory is in the
    //     last fulfillment center.

    private static final Map<String, Integer[]> PRODUCT_INVENTORY = new HashMap<>();

    static {
        // products 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
        PRODUCT_INVENTORY.put( (String) PRODUCT_DATA[0][1],
                getInventoryDistribution( 0, (String) PRODUCT_DATA[0][6] ) );
        PRODUCT_INVENTORY.put( (String) PRODUCT_DATA[1][1],
                getInventoryDistribution( 10, (String) PRODUCT_DATA[1][6] ) );
        PRODUCT_INVENTORY.put( (String) PRODUCT_DATA[2][1],
                getInventoryDistribution( 20, (String) PRODUCT_DATA[2][6] ) );
        PRODUCT_INVENTORY.put( (String) PRODUCT_DATA[3][1],
                getInventoryDistribution( 30, (String) PRODUCT_DATA[3][6] ) );

        // The other products have a random inventory between 30 and 130,
        for ( int i = 4; i < PRODUCT_NUMOF; i++ ) {
            Integer totalNumber = random.nextInt( 100 ) + 30;
            Integer[] inventoryInFulfillmentCenters =
                    getInventoryDistribution( totalNumber, (String) PRODUCT_DATA[i][6] );
            PRODUCT_INVENTORY.put( (String) PRODUCT_DATA[i][1], inventoryInFulfillmentCenters );
        }
    }

    /**
     * This method creates a random inventory distribution for the given product.
     *
     * @param totalQuantity - the total number of products in the fulfillment centers
     * @param zeroToNine  - a string with numbers between 0 and 9, representing the fulfillment centers
     * @return an Integer array with the inventory distribution for the product, according to
     * the rules described above.
     */
    private static Integer[] getInventoryDistribution( Integer totalQuantity, String zeroToNine ) {
        Integer[] inventoryInFulfillmentCenters = new Integer[FULFILLMENT_CENTER_NUMOF];
        for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) inventoryInFulfillmentCenters[i] = 0;
        TreeSet<Integer> fulfillmentCenterIndices = getFulfillmentCenterIndices( zeroToNine );
        int numOfIndices = fulfillmentCenterIndices.size();
        int currentIndexNumber = 0;
        int currentQuantity = totalQuantity;
        for ( Integer fulfillmentCenterIndex : fulfillmentCenterIndices ) {
            currentIndexNumber++;
            if ( currentIndexNumber < numOfIndices ) {
                inventoryInFulfillmentCenters[fulfillmentCenterIndex] = 3;
                currentQuantity -= 3;
            } else {
                inventoryInFulfillmentCenters[fulfillmentCenterIndex] = currentQuantity;
            }
        }
        return inventoryInFulfillmentCenters;
    }

    private static TreeSet<Integer> getFulfillmentCenterIndices( String zeroToNine ) {
        TreeSet<Integer> fulfillmentCenterIndices = new TreeSet<>();
        for ( int i = 0; i < zeroToNine.length(); i++ ) {
            fulfillmentCenterIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
        }
        return fulfillmentCenterIndices;
    }


    @Autowired
    public InventoryTestHelperImpl( ProductCatalogUseCases productCatalogUseCases,
                                         FulfillmentCenterUseCases fulfillmentCenterUseCases ) {
        this.productCatalogUseCases = productCatalogUseCases;
        this.fulfillmentCenterUseCases = fulfillmentCenterUseCases;
    }


    @Override
    public void addAllProducts() {
        int i = 0;
        for ( Object[] productData : PRODUCT_DATA ) {
            UUID newId = productCatalogUseCases.addProductToCatalog(
                    (String) productData[1], (String) productData[2],
                    (Float) productData[3], (CurrencyType) productData[4],
                    (CurrencyType) productData[5] );
            // The first element of the product data is the id, which was initialized with null before, but can now be set
            PRODUCT_DATA[i][0] = newId;
            i++;
        }
    }


    @Override
    public int numberOfProducts() {
        return PRODUCT_NUMOF;
    }


    @Override
    public UUID getProductId( int index ) {
        if ( index < 0 || index >= PRODUCT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (UUID) PRODUCT_DATA[index][0];
    }


    @Override
    public CurrencyType getBuyingPrice( int index ) {
        if ( index < 0 || index >= PRODUCT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (CurrencyType) PRODUCT_DATA[index][4];
    }


    @Override
    public CurrencyType getSalesPrice( int index ) {
        if ( index < 0 || index >= PRODUCT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (CurrencyType) PRODUCT_DATA[index][5];
    }


    @Override
    public void addAllFulfillmentCenters( boolean withInventory ) {
        for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) {
            FULFILLMENT_CENTER_ID[i] = fulfillmentCenterUseCases.addNewFulfillmentCenter(
                    FULFILLMENT_CENTER_PHYSICAL_ADDRESS[i].getStreet(),
                    FULFILLMENT_CENTER_PHYSICAL_ADDRESS[i] );
        }
        if ( withInventory ) {
            addAllInventory();
        }
    }


    private void addAllInventory() {
        for ( Object[] productData : PRODUCT_DATA ) {
            Integer[] inventoryInFulfillmentCenters =
                    PRODUCT_INVENTORY.get( productData[1] );
            for ( int iFulfillmentCenter = 0; iFulfillmentCenter < FULFILLMENT_CENTER_NUMOF; iFulfillmentCenter++ ) {
                if ( inventoryInFulfillmentCenters[iFulfillmentCenter] > 0 )
                    fulfillmentCenterUseCases.addToInventory(
                            FULFILLMENT_CENTER_ID[iFulfillmentCenter], (UUID) productData[0],
                            inventoryInFulfillmentCenters[iFulfillmentCenter] );
            }
        }
    }


    @Override
    public int numberOfFulfillmentCenters() {
        return FULFILLMENT_CENTER_NUMOF;
    }


    @Override
    public UUID getFulfillmentCenterId( int index ) {
        if ( index < 0 || index >= FULFILLMENT_CENTER_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return FULFILLMENT_CENTER_ID[index];
    }


    @Override
    public Integer getFulfillmentCenterInventory( int fulfillmentCenterIndex, int productIndex ) {
        if ( fulfillmentCenterIndex < 0 || fulfillmentCenterIndex >= FULFILLMENT_CENTER_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + fulfillmentCenterIndex );
        }
        if ( productIndex < 0 || productIndex >= PRODUCT_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + productIndex );
        }
        String productName = (String) PRODUCT_DATA[productIndex][1];
        Integer[] inventoryInFulfillmentCenters = PRODUCT_INVENTORY.get( productName );
        Integer foundInventory = inventoryInFulfillmentCenters[fulfillmentCenterIndex];
        return foundInventory == null ? 0 : foundInventory;
    }


    @Override
    public int findFulfillmentCenterIndex( UUID fulfillmentCenterId ) {
        for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) {
            if ( FULFILLMENT_CENTER_ID[i].equals( fulfillmentCenterId ) ) {
                return i;
            }
        }
        throw new IllegalArgumentException( "No test fulfillment center with UUID id " + fulfillmentCenterId );
    }


    @Override
    public int findProductIndex( UUID productId ) {
        for ( int iProductData = 0; iProductData < FULFILLMENT_CENTER_NUMOF; iProductData++ ) {
            Object[] productData = PRODUCT_DATA[iProductData];
            if ( productData[0].equals( productId ) ) {
                return iProductData;
            }
        }
        throw new IllegalArgumentException( "No test product with UUID id " + productId );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\UserTestHelperImpl.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
import thkoeln.archilab.ecommerce.usecases.masterdata.MockUser;

import static org.junit.jupiter.api.Assertions.assertThrows;

/**
 * This is a test helper class that initializes and registers users in the system,
 * using the given interface(s).
 */
@Component
@SuppressWarnings("PMD")
public class UserTestHelperImpl implements UserTestHelper {

    private UserRegistrationUseCases userRegistrationUseCases;

    @Autowired
    public UserTestHelperImpl( UserRegistrationUseCases userRegistrationUseCases ) {
        this.userRegistrationUseCases = userRegistrationUseCases;
    }

    private final static String[] USER_NAME = new String[]{
            "Max Mueller",
            "Sophie Schmitz",
            "Irene Mihalic",
            "Emilia Fischer",
            "Filiz Polat",
            "Lina Wagner",
            "Leon Becker",
            "Agnieszka Kalterer",
            "Felix Bauer",
            "Lara Schulz"
    };

    private final static MailAddressType[] USER_EMAIL = new MailAddressType[]{
            FactoryMethodInvoker.instantiateMailAddress( "99Z@example.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "a@4.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "irene@wearefreedomnow.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "emilia.fischer@example.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "j877d3@example.this.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "lina.marie.wagner@example.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "agna@here.ch" ),
            FactoryMethodInvoker.instantiateMailAddress( "felix.bauer@example.org" ),
            FactoryMethodInvoker.instantiateMailAddress( "lara.schulz@example.at" )
    };

    // The following array is used to create a list of physicalAddresss for the users.
    // The indices are coded into the house number.
    // - Persons 0 - 5 are used for proximity tests with one fulfillment center.
    private final static PhysicalAddressType[] USER_ADDRESS = new PhysicalAddressType[]{
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Marktstra√üe 0", "Viertelstadt",
                    FactoryMethodInvoker.instantiatePostalCode( "02314" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Hauptstra√üe 1", "Viertelstadt",
                    FactoryMethodInvoker.instantiatePostalCode( "02368" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Kirchplatz 2", "Niemandstown",
                    FactoryMethodInvoker.instantiatePostalCode( "12345" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Schulstra√üe 3", "Geisterhausen",
                    FactoryMethodInvoker.instantiatePostalCode( "31463" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Rosenweg 4", "Kuhhausen",
                    FactoryMethodInvoker.instantiatePostalCode( "72162" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Wiesenstra√üe 5", "Waldschenkensdorf",
                    FactoryMethodInvoker.instantiatePostalCode( "82195" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Muehlenweg 6", "Koeln",
                    FactoryMethodInvoker.instantiatePostalCode( "50667" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Goethestra√üe 7", "Frankfurt am Main",
                    FactoryMethodInvoker.instantiatePostalCode( "60311" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Dorfstra√üe 8", "Stuttgart",
                    FactoryMethodInvoker.instantiatePostalCode( "70173" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Bahnhofstra√üe 9", "Muenchen",
                    FactoryMethodInvoker.instantiatePostalCode( "80331" ) )
    };

    private final static UserType[] mockUsers;

    static {
        mockUsers = new UserType[USER_NAME.length];
        for ( int i = 0; i < USER_NAME.length; i++ ) {
            mockUsers[i] = new MockUser(
                    USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
        }
    }


    @Override
    public void registerAllUsers() {
        for ( int i = 0; i < USER_NAME.length; i++ ) {
            registerUser( USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
        }
    }


    private void registerUser( String name, MailAddressType mailAddress, PhysicalAddressType physicalAddress ) {
        userRegistrationUseCases.register( name, mailAddress, physicalAddress );
    }


    @Override
    public int getNumberOfUsers() {
        return USER_NAME.length;
    }


    @Override
    public String getUserName( int index ) {
        if ( index < 0 || index >= USER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return USER_NAME[index];
    }


    @Override
    public MailAddressType getUserMailAddress( int index ) {
        if ( index < 0 || index >= USER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return USER_EMAIL[index];
    }


    @Override
    public PhysicalAddressType getUserPhysicalAddress( int index ) {
        if ( index < 0 || index >= USER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return USER_ADDRESS[index];
    }


    @Override
    public UserType getUser( int index ) {
        if ( index < 0 || index >= USER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return mockUsers[index];
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockUser.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import lombok.Setter;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;


import java.util.Objects;

@Setter
public class MockUser implements UserType {
    private String name;
    private MailAddressType mailAddressType;
    private PhysicalAddressType physicalAddressType;


    public MockUser( String name, MailAddressType mailAddressType, PhysicalAddressType physicalAddressType) {
        this.name = name;
        this.mailAddressType = mailAddressType;
        this.physicalAddressType = physicalAddressType;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public MailAddressType getMailAddress() {
        return mailAddressType;
    }

    @Override
    public PhysicalAddressType getPhysicalAddress() {
        return physicalAddressType;
    }

    @Override
    public boolean equals( Object o ) {
        if ( this == o ) return true;
        if ( !( o instanceof MockUser ) ) return false;
        MockUser that = (MockUser) o;
        return Objects.equals( getName(), that.getName() ) &&
                Objects.equals( mailAddressType, that.mailAddressType ) &&
                Objects.equals( physicalAddressType, that.physicalAddressType );
    }

    @Override
    public int hashCode() {
        return Objects.hash( getName(), mailAddressType, physicalAddressType );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ProductTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

import java.util.UUID;

public interface ProductTestHelper {
    /**
     * Adds all test products to the database.
     * If you use the debugger and want to identify _which_ test product you currently look at:
     * The indices are coded into the first number in the name string of the product, like e.g.
     * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
     */
    void addAllProducts();


    /**
     * @return the number of test products in the database
     */
    int numberOfProducts();


    /**
     * @param index
     * @return the id of the test product at the given index
     */
    UUID getProductId( int index );


    /**
     * @param productId - the id of the product in the test data
     * @return the index of the test product with that id
     */
    int findProductIndex( UUID productId );


    /**
     * @param index
     * @return the buying price of test product at the given index
     */
    CurrencyType getBuyingPrice( int index );


    /**
     * @param index
     * @return the sales price of test product at the given index
     */
    CurrencyType getSalesPrice( int index );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.usecases.*;

/**
 * Removes everything :-)
 */
@Service
public class Purgatory {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private PurchaseUseCases purchaseUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;

    public void deleteEverything() {
        purchaseUseCases.deleteAllPurchases();
        shoppingBasketUseCases.emptyAllShoppingBaskets();
        fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
        userRegistrationUseCases.deleteAllUsers();
        productCatalogUseCases.deleteProductCatalog();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;

@Component
@Slf4j
@Profile("!test")
@SuppressWarnings("PMD")
public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
    private Purgatory purgatory;
    private UserTestHelper userTestHelper;
    private ProductTestHelper productTestHelper;
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;


    @Autowired
    public StartupListener( Purgatory purgatory,
                            UserTestHelper userTestHelper,
                            ProductTestHelper productTestHelper,
                            FulfillmentCenterTestHelper fulfillmentCenterTestHelper ) {
        this.purgatory = purgatory;
        this.userTestHelper = userTestHelper;
        this.productTestHelper = productTestHelper;
        this.fulfillmentCenterTestHelper = fulfillmentCenterTestHelper;
    }

    @Override
    public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
        log.info( "StartupListener initializing master data ..." );
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        productTestHelper.addAllProducts();
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\UserTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;


import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

/**
 * This is a test helper interface provides access to predefined test data for
 * users.
 */
public interface UserTestHelper {
    /**
     * This method calls the use case implementation to register all users specified in the
     * test data set.
     * If you use the debugger and want to identify _which_ test user you currently look at:
     * The indices are coded into the house number (in the user's physical address) and in the first
     * cipher of the postal code. This is the list of users:
     *
     * +-------+-------------------+--------+---------------------
     * | Index | Name              | PLZ    | MailAddress
     * +-------+-------------------+--------+---------------------
     * | 0     | Max Mueller       | 02314  | 99Z@example.com
     * | 1     | Sophie Schmitz    | 02368  | a@4.com
     * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
     * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
     * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
     * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
     * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
     * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
     * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
     * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
     * +-------+-------------------+--------+---------------------
     */
    void registerAllUsers();


    /**
     * @return the number of test users in the test data set.
     */
    int getNumberOfUsers();


    /**
     * @param index the index of the user in the test data set.
     * @return the name of the test user with the given index.
     */
    String getUserName( int index );


    /**
     * @param index the index of the user in the test data set.
     * @return the mail address of the test user with the given index.
     */
    MailAddressType getUserMailAddress( int index );


    /**
     * @param index the index of the user in the test data set.
     * @return the physical address of the test user with the given index.
     */
    PhysicalAddressType getUserPhysicalAddress( int index );


    /**
     * @param index the index of the user in the test data set.
     * @return the test user with the given index.
     */
    UserType getUser( int index );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\ProductCatalogUseCases.java ---
/*
 * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

import java.util.UUID;


/**
 * This interface contains methods needed in the context of use cases concerning the product catalog.
 * The interface is probably incomplete, and will grow over time ...
 */

public interface ProductCatalogUseCases {
    /**
     * Adds a new product to the shop catalog
     * @param name
     * @param descriptOf
     * @param size
     * @param buyingPrice
     * @param salesPrice
     * @return the id of the new product
     * @throws ShopException if ...
     *      - the product id already exists,
     *      - name or description are null or empty,
     *      - the size is <= 0 (but can be null!),
     *      - the buying price is null or <= 0,
     *      - the buyingPrice is null,
     *      - the sales price is null,
     *      - the sales price is lower than the buyingPrice
     */
    public UUID addProductToCatalog( String name, String descriptOf, Float size,
                                           CurrencyType buyingPrice, CurrencyType salesPrice );


    /**
     * Removes a product from the shop catalog
     * @param productId
     * @throws ShopException if
     *      - productId is null
     *      - the product id does not exist
     *      - the product is still in inventory
     *      - the product is still in a shopping basket, or referenced by a completed purchase
     */
    public void removeProductFromCatalog( UUID productId );


    /**
     * Get the sales price of a given product
     * @param productId
     * @return the sales price
     * @throws ShopException if ...
     *      - productId is null,
     *      - the product with that id does not exist
     */
    public CurrencyType getSalesPrice( UUID productId );


    /**
     * Clears the product catalog, i.e. removes all products from the catalog, including all the inventory,
     * all the reservations and all the purchases.
     */
    public void deleteProductCatalog();

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\PurchaseUseCases.java ---
/*
 * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
 */
package thkoeln.archilab.ecommerce.usecases;


import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.Map;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of the purchase history of a user.
 */
public interface PurchaseUseCases {

    /**
     * Returns a map showing which products have been purchased by a user and how many of each product
     *
     * @param userMailAddress
     * @return the purchase history of the user (map is empty if the user has not purchased anything yet)
     * @throws ShopException if
     *      - userMailAddress is null
     *      - the user with the given mail address does not exist
     */
    public Map<UUID, Integer> getPurchaseHistory( MailAddressType userMailAddress );



    /**
     * @return the number of products in a given purchase. If the product is not a position of the purchase, the method
     *         returns 0. No exception is thrown.
     * @param purchaseId - the id of the purchase to be checked
     * @param productId - the id of the product for which we want to know the quantity
     * @throws ShopException if
     *     - purchaseId is null, or doesn't exist in the system
     *     - productId is null, or doesn't exist in the system
     */
    public Integer getPurchaseQuantityForProduct( UUID purchaseId, UUID productId );


    /**
     * @return the id of the fulfillment center that is responsible for the given purchase
     * @param purchaseId - the id of the purchase to be checked
     * @throws ShopException if
     *      - purchaseId is null, or doesn't exist in the system
     */
    public UUID getFulfillmentCenterIdForPurchase( UUID purchaseId );


    /**
     * Deletes all purchases in the system
     */
    public void deleteAllPurchases();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingBasketUseCases.java ---
/*
 * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.Map;
import java.util.Set;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of use cases handling the shopping basket.
 * The interface is probably incomplete, and will grow over time ...
 */
public interface ShoppingBasketUseCases {
    /**
     * Adds a product to the cart of a user
     *
     * @param userMailAddress
     * @param productId
     * @param quantityFor
     * @throws ShopException if ...
     *          - userMailAddress is null,
     *          - the user with the given mail address does not exist,
     *          - productId is null,
     *          - the product with productId does not exist
     *          - the Quantity is negative,
     */
    public void addProductToShoppingBasket( MailAddressType userMailAddress,
                                                 UUID productId, int quantityFor );


    /**
     * Removes a product from the cart of a user
     *
     * @param userMailAddress
     * @param productId
     * @param quantityFor
     * @throws ShopException if ...
     *          - userMailAddress is null,
     *          - the user with the given mail address does not exist,
     *          - productId is null,
     *          - the product with productId does not exist
     *          - the Quantity is negative
     *          - the product is not in the shopping basket in the requested Quantity
     */
    public void removeProductFromShoppingBasket( MailAddressType userMailAddress,
                                                      UUID productId, int quantityFor );


    /**
     * Returns a map showing which products are in the cart of a user and how many of each product
     *
     * @param userMailAddress
     * @return the cart of the user (map is empty if the cart is empty)
     * @throws ShopException if
     *          - userMailAddress is null,
     *          - the user with the given mail address does not exist
     */
    public Map<UUID, Integer> getShoppingBasketAsMap( MailAddressType userMailAddress );


    /**
     * Returns the current value of all products in the cart of a user
     *
     * @param userMailAddress
     * @return the cart of the user
     * @throws ShopException if
     *          - userMailAddress is null,
     *          - the user with the given mail address does not exist
     */
    public CurrencyType getShoppingBasketAsCurrencyValue( MailAddressType userMailAddress );




    /**
     * Checks out the cart of a user
     *
     * @param userMailAddress
     * @return A set of ids belonging to purchases that were created during the checkout. If the shopping basket can
     *         only be served from more than one fulfillment center, each shipment from a fulfillment center gets a
     *         dedicated purchase. I.e. if there is just one shipment, then the set will contain just one purchase id.
     *         If there are multiple shipments, the set will contain multiple purchase ids.
     * @throws ShopException if
     *      - userMailAddress is null or empty
     *      - the user with the given mail address does not exist, or if the cart is empty
     * @throws
     *      - ShopException if userMailAddress is null
     *      - InsufficientInventoryException if there is not enough inventory level for to serve the purchase
     *        for all products in the shopping basket
     */
    public Set<UUID> checkout( MailAddressType userMailAddress );


    /**
     * Empties all shopping baskets in the system
     */
    public void emptyAllShoppingBaskets();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\UserRegistrationUseCases.java ---
/*
 * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

/**
 * This interface contains methods needed in the context of use cases concerning the registration of a user.
 * The interface is probably incomplete, and will grow over time ...
 */
public interface UserRegistrationUseCases {
    /**
     * Registers a new user
     *
     * @param name
     * @param mailAddress
     * @param physicalAddress
     * @throws ShopException if ...
     *      - the user with the given mail address already exists
     *      - physicalAddress is null
     */
    public void register( String name, MailAddressType mailAddress, PhysicalAddressType physicalAddress );


    /**
     * Changes the address of a user
     *
     * @param userMailAddress
     * @param userMailAddress
     * @param physicalAddress
     * @throws ShopException if ...
     *      - the user with the given mail address does not exist,
     *      - physicalAddress is null
     */
    public void changeAddress( MailAddressType userMailAddress,
                               PhysicalAddressType physicalAddress );


    /**
     * Returns the data of a user as an array of strings (name, mailAddress, street, city, postalCode)
     * @param userMailAddress
     * @return the user data
     * @throws ShopException the user with the given mail address does not exist,
     */
    public UserType getUserData( MailAddressType userMailAddress );



    /**
     * Clears all users, including all purchases and shopping baskets
     */
    public void deleteAllUsers();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\UserType.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

/**
 * This interface expresses the essence of a shop user
 */
public interface UserType {
    String getName();
    MailAddressType getMailAddress();
    PhysicalAddressType getPhysicalAddress();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
package thkoeln.archilab.ecommerce.helpers.impl;

import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.test.web.servlet.MockMvc;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;


@TestConfiguration
public class RESTTestHelperConfiguration {

    @Bean
    public ShoppingBasketRESTHelper shoppingBasketRESTHelper(
            MockMvc mockMvc, ProductCatalogUseCases productCatalogUseCases ) {
        return new ShoppingBasketRESTHelperImpl( mockMvc, productCatalogUseCases );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingBasketRESTHelperImpl.java ---
package thkoeln.archilab.ecommerce.helpers.impl;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.Map;
import java.util.UUID;

import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@Slf4j
public class ShoppingBasketRESTHelperImpl implements ShoppingBasketRESTHelper {
    private MockMvc mockMvc;
    private ProductCatalogUseCases productCatalogUseCases;

    private static final ResultMatcher CREATED = status().isCreated();
    private static final ResultMatcher OK = status().isOk();

    public ShoppingBasketRESTHelperImpl( MockMvc mockMvc, ProductCatalogUseCases productCatalogUseCases ) {
        this.mockMvc = mockMvc;
        this.productCatalogUseCases = productCatalogUseCases;
    }


    @Override
    public UUID getQueryShoppingBasket( MailAddressType mailAddress, Map<UUID, Integer> quantityMap )
            throws Exception {
        // first query the users API to get the proper userId
        UUID userId;
        String userUri = "/users?mailAddress=" + mailAddress.toString();
        MvcResult userGetResult = mockMvc.perform( get( userUri ) )
                .andExpect( status().isOk() )
                .andReturn();
        ObjectMapper objectMapper = new ObjectMapper();
        IdDTO idDTO = objectMapper.readValue( userGetResult.getResponse().getContentAsString(), IdDTO.class );
        userId = idDTO.getId();

        // then query the shopping basket API and extract the shopping basket id
        String shoppingBasketUri = "/shoppingBaskets?userId=" + userId.toString();
        ResultActions resultActions = mockMvc.perform( get( shoppingBasketUri ) )
                .andExpect( status().isOk() );
        idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
        UUID shoppingBasketId = idDTO.getId();

        // additional checks, if desired
        if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
        return shoppingBasketId;
    }


    private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
        if ( quantityMap == null ) return;
        int numOfProducts = quantityMap.size();
        resultActions.andExpect( jsonPath( "$.positions.length()" ).value( numOfProducts ) );
        float totalSalesPriceAsFloat = 0f;
        for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
            UUID productId = entry.getKey();
            Integer quantity = entry.getValue();
            resultActions.andExpect( jsonPath( "$.positions.[?(@.productId == '" + productId + "')].quantity" )
                    .value( quantity ) );
            CurrencyType salesPrice = productCatalogUseCases.getSalesPrice( productId );
            totalSalesPriceAsFloat += salesPrice.getQuantity() * quantity;
        }
        // last thing - check the total sales price
        String totalSalesPriceString = String.format( "%.2f ‚Ç¨", totalSalesPriceAsFloat );
        resultActions
                .andExpect( jsonPath( "$.totalSalesPrice" ).value( totalSalesPriceString ) );
    }


    @Override
    public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity )
            throws Exception {
        addProductToShoppingBasket( shoppingBasketId, productId, quantity, null );
    }


    @Override
    public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity,
                                                  ResultMatcher expectedStatus ) throws Exception {
        ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
        ObjectMapper objectMapper = new ObjectMapper();
        QuantityDTO dto = new QuantityDTO( productId, quantity );
        String quantityJson = objectMapper.writeValueAsString( dto );
        mockMvc.perform( post( "/shoppingBaskets/" + shoppingBasketId + "/positions" )
                        .contentType( APPLICATION_JSON ).content( quantityJson ) )
                .andExpect( status );
    }



    @Override
    public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId )
            throws Exception {
        deleteProductFromShoppingBasket( shoppingBasketId, productId, null );
    }



    @Override
    public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId,
                                                      ResultMatcher expectedStatus ) throws Exception {
        ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
        String uri = "/shoppingBaskets/" + shoppingBasketId + "/positions/" + productId;
        mockMvc.perform( delete( uri ) ).andExpect( status );
    }


    @Override
    public void checkout( UUID shoppingBasketId, String expectedUserName,
                          ResultMatcher expectedStatus,
                          Map<UUID, Map<UUID, Integer>> expectedPurchases ) throws Exception {
        ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
        String uri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
        MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
        ObjectMapper objectMapper = new ObjectMapper();

        // check the response content
        if ( expectedPurchases != null || expectedUserName != null ) {
            String responseContent = result.getResponse().getContentAsString();
            log.info( "ShoppingBasketRESTHelperImpl - checkout: found response content " + responseContent );
            PurchaseDTO[] purchases = objectMapper.readValue( responseContent, PurchaseDTO[].class );
            checkExpectedUserName( expectedUserName, purchases );
            checkExpectedPurchases( expectedPurchases, purchases );
        }
    }


    private void checkExpectedUserName( String expectedUserName, PurchaseDTO[] purchases ) {
        if ( expectedUserName == null ) return;
        for ( PurchaseDTO purchase : purchases ) {
            if ( !purchase.getUserName().equals( expectedUserName ) ) {
                throw new AssertionError( "Expected userName '" + expectedUserName +
                        "' but got '" + purchase.getUserName() + "'" );
            }
        }
    }


    private void checkExpectedPurchases( Map<UUID, Map<UUID, Integer>> expectedPurchases,
                                            PurchaseDTO[] purchases ) {
        if ( expectedPurchases == null ) return;
        for ( PurchaseDTO purchase : purchases ) {
            UUID fulfillmentCenterId = purchase.getFulfillmentCenterId();
            Map<UUID, Integer> expectedQuantities = expectedPurchases.get( fulfillmentCenterId );
            if ( expectedQuantities == null ) {
                throw new AssertionError( "No expected quantities for fulfillment center " + fulfillmentCenterId );
            }
            QuantityDTO[] positions = purchase.getPositions();
            for ( QuantityDTO quantityDTO : positions ) {
                UUID productId = quantityDTO.getProductId();
                Integer expectedQuantity = expectedQuantities.get( productId );
                if ( expectedQuantity == null ) {
                    throw new AssertionError( "No expected quantity for product " + productId +
                            " in fulfillment center " + fulfillmentCenterId );
                }
                if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
                    throw new AssertionError( "Expected quantity " + expectedQuantity + " for product " +
                            productId + " in fulfillment center " + fulfillmentCenterId +
                            ", but got " + quantityDTO.getQuantity() );
                }
            }
        }
    }


    /**
     * A DTO containing just a quantity, used in testing.
     * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
     * Therefore, constructors and getters/setters are manually defined.
     */
    @NoArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class QuantityDTO {
        private UUID productId;
        private Integer quantity;

        public QuantityDTO( UUID productId, Integer quantity ) {
            this.productId = productId;
            this.quantity = quantity;
        }
        public UUID getProductId() {
            return productId;
        }
        public Integer getQuantity() {
            return quantity;
        }
        public void setProductId( UUID productId ) {
            this.productId = productId;
        }
        public void setQuantity( Integer quantity ) {
            this.quantity = quantity;
        }
    }


    /**
     * A DTO containing just the id of an entity, used in testing.
     */
    @AllArgsConstructor
    @NoArgsConstructor
    @Getter
    @Setter
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class IdDTO {
        private UUID id;
    }


    /**
     * A DTO containing the purchase data, used in testing.
     * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
     * Therefore, constructors and getters/setters are manually defined.
     */
    @NoArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class PurchaseDTO {
        private UUID id;
        private String userName;
        private UUID fulfillmentCenterId;
        private QuantityDTO[] positions;

        public UUID getId() {
            return id;
        }
        public String getUserName() {
            return userName;
        }
        public UUID getFulfillmentCenterId() {
            return fulfillmentCenterId;
        }
        public QuantityDTO[] getPositions() {
            return positions;
        }
        public void setId( UUID id ) {
            this.id = id;
        }
        public void setUserName( String userName ) {
            this.userName = userName;
        }
        public void setFulfillmentCenterId( UUID fulfillmentCenterId ) {
            this.fulfillmentCenterId = fulfillmentCenterId;
        }
        public void setPositions( QuantityDTO[] positions ) {
            this.positions = positions;
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingBasketRESTHelper.java ---
package thkoeln.archilab.ecommerce.helpers;

import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.Map;
import java.util.UUID;

/**
 * A REST helper for shopping basket-related operations.
 * This interface defines methods to interact with a shopping basket via REST calls, such as querying, adding,
 * deleting, and checking out.
 */
public interface ShoppingBasketRESTHelper {
    /**
     * Executes a REST GET query on a shopping basket and returns its id, with the user's mail address as a
     * starting point. The resulting shopping basket is checked against the given expected quantity map.
     * @param mailAddress The mailAddress of the user whose shopping basket is queried.
     * @param expectedQuantityMap A map of products and their quantities in the shopping basket. (If null, then don't check.)
     * @return The id of the user's shopping basket.
     * @throws Exception (whenever the REST call fails, or the shopping basket does not match the expected quantity map)
     */
    public UUID getQueryShoppingBasket( MailAddressType mailAddress,
                                       Map<UUID, Integer> expectedQuantityMap ) throws Exception;


    /**
     * Adds a product to a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param productId Id of the product.
     * @param quantity Quantity of the product.
     * @throws Exception (whenever the REST call fails)
     */
    public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity )
            throws Exception;


    /**
     * Adds a product to a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param productId Id of the product.
     * @param quantity Quantity of the product.
     * @param expectedStatus expected status of the operation (null = CREATED)
     * @throws Exception (whenever the REST call fails or the status does not match)
     */
    public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity,
                                                  ResultMatcher expectedStatus ) throws Exception;


    /**
     * Deletes a product from a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param productId Id of the product.
     * @throws Exception (whenever the REST call fails)
     */
    public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId )
            throws Exception;


    /**
     * Deletes a product from a shopping basket via a REST call.
     * @param shoppingBasketId Id of the shopping basket.
     * @param productId Id of the product.
     * @param expectedStatus expected status of the operation (null = OK)
     * @throws Exception (whenever the REST call fails or the status does not match)
     */
    public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId,
                                                      ResultMatcher expectedStatus ) throws Exception;


    /**
     * Checks out a shopping basket via REST call, and returns the id of the created purchase.
     * @param shoppingBasketId
     * @param expectedUserName expected name of the user who owns the shopping basket (null = don't check)
     * @param expectedStatus expected status of the operation (null = don't check)
     * @param expectedPurchases the expected purchases to be created as a result of the checkout. This is
     *                            a map of the following form:
     *                            <pre>
     *                               fulfillmentCenterId -> Map<productId,Integer>
     *                            </pre>
     *                            where the inner map contains the products and their quantities
     * @return
     * @throws Exception
     */
    public void checkout( UUID shoppingBasketId, String expectedUserName,
                          ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedPurchases )
           throws Exception;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class BasicNoOutsideSolutionRulesTest {

    @ArchTest
    static final ArchRule noClassesOnTopLevel =
            classes().should().resideInAPackage( "..solution.*.." )
                    .allowEmptyShould( true );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.library.Architectures.layeredArchitecture;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln")
@SuppressWarnings("PMD")
public class BasicProperDependenciesTest {

    @ArchTest
    static final ArchRule properDependencies =
            layeredArchitecture()
                    .consideringAllDependencies()
                    //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
                    .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
                    .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )

                    //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
                    .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
                    .allowEmptyShould( true );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import org.junit.jupiter.api.Test;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.MetadataReaderFactory;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertTrue;

public class BasicRequiredClassesTest {
    private static final String[] REQUIRED_CLASSES = {
            "User",
            "UserRepository",
            "Product",
            "ProductRepository",
            "Purchase",
            "PurchaseRepository",
            "InventoryLevel",
            "ShoppingBasket",
            "ShoppingBasketRepository",
            "FulfillmentCenterRepository",
            "ShoppingBasketPosition",
            "PurchasePosition",
            "FulfillmentCenter",
    };

    @Test
    public void testRequiredClassesDeclared() throws IOException {
        String basePackage = "thkoeln.archilab.ecommerce";
        String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";

        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );

        Set<String> foundClasses = new HashSet<>();

        Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
            try {
                MetadataReader reader = readerFactory.getMetadataReader( resource );
                foundClasses.add( reader.getClassMetadata().getClassName() );
            } catch (IOException e) {
                e.printStackTrace();
            }
        } );

        Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
            boolean found = foundClasses.stream().anyMatch(className ->
                    className.startsWith(basePackage) && className.endsWith("." + requiredClass)
            );
            assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
        });
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.ApplicationContext;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
public class BasicUseCaseImplementationPackageTest {

    @Autowired
    private ApplicationContext applicationContext;

    private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
        put("UserRegistrationUseCases", Arrays.asList("user"));
        put("FulfillmentCenterUseCases", Arrays.asList("fulfillmentcenter"));
        put("ProductCatalogUseCases", Arrays.asList("product"));
        put("ShoppingBasketUseCases", Arrays.asList("shoppingbasket"));
        put("PurchaseUseCases", Arrays.asList("purchase"));
    }};
    private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
    private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";

    @Test
    public void testRequiredClassesDeclared() {
        for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
            String interfaceName = USECASE_PATH + "." + entry.getKey();
            List<String> correctTopLevelPackages = entry.getValue();
            Class<?> useCaseInterfaceClass = null;
            try {
                useCaseInterfaceClass = Class.forName( interfaceName );
            } catch (ClassNotFoundException e) {
                fail( "Use case interface " + interfaceName + " not found.", e );
                continue;
            }
            String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
            assertEquals( 1, beans.length,
                    "There should be exactly 1 service implementation for the interface " +
                            entry.getKey() + ", but found " + beans.length );
            Object bean = applicationContext.getBean( beans[0] );
            boolean isValid = false;
            for ( String correctTopLevelPackage : correctTopLevelPackages ) {
                String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
                if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
                    isValid = true;
                    break;
                }
            }
            assertTrue( isValid,
                    "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
                            + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Service;

import jakarta.persistence.Entity;
import org.springframework.web.bind.annotation.RestController;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class DDDRulesTest {

    @ArchTest
    static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
            noClasses().that().resideInAPackage( "..domain.." )
                    .should().dependOnClassesThat().resideInAPackage( "..application.." )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule entitiesMustResideInADomainPackage =
            classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
                    .as( "Entities must reside in a package '..domain..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule entitiesMustNotAccessRepositories =
            noClasses().that().areAnnotatedWith( Entity.class )
                    .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule repositoriesMustResideInADomainPackage =
            classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
                    .as( "Repositories must reside in a package '..domain..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule repositoryNamesMustHaveProperSuffix =
            classes().that().areAssignableTo( CrudRepository.class )
                    .should().haveSimpleNameEndingWith( "Repository" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule servicesMustResideInAnApplicationPackage =
            classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
                    .as( "Application Services must reside in a package '..application..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule serviceNamesMustHaveProperSuffix =
            classes().that().areAnnotatedWith( Service.class )
                    .should().haveSimpleNameEndingWith( "Service" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule controllersMustResideInAnApplicationPackage =
            classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
                    .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );

    @ArchTest
    static final ArchRule controllersNamesMustHaveProperSuffix =
            classes().that().areAnnotatedWith( RestController.class )
                    .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );

    @ArchTest
    static final ArchRule controllersMustNotAccessRepositories =
            noClasses().that().areAnnotatedWith( RestController.class )
                    .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
                    .allowEmptyShould( false );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.library.dependencies.SliceAssignment;
import com.tngtech.archunit.library.dependencies.SliceIdentifier;
import org.junit.jupiter.api.Test;

import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;

public class NoCycleTest {
    private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");

    private SliceAssignment inAllClasses() {
        return new SliceAssignment() {
            @Override
            public String getDescription() {
                return "every class in it's own slice";
            }

            @Override
            public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
                return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
            }
        };
    }

    @Test
    public void testNoCyclicDependenciesBetweenClasses() {
        slices().assignedFrom(inAllClasses())
                .namingSlices("$1[$2.$3]")
                .should().beFreeOfCycles()
                .check(importedClasses);
    }

    @Test
    public void testNoCyclicDependenciesBetweenPackages() {
        ArchRule rule = slices().matching("..solution.(*)..")
                .should().beFreeOfCycles().allowEmptyShould( true );
        rule.check(importedClasses);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.base.DescribedPredicate;
import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaField;
import com.tngtech.archunit.core.domain.JavaParameterizedType;
import com.tngtech.archunit.core.domain.JavaType;
import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchCondition;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.lang.ConditionEvents;
import com.tngtech.archunit.lang.SimpleConditionEvent;
import jakarta.persistence.*;
import lombok.extern.slf4j.Slf4j;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.List;

import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
@Slf4j
public class OnlyReferenceViaIDTest { //FULFILLMENT_CENTER
    private static final String SHOPPING_BASKET_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingbasket.domain";
    private static final String USER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.user.domain";
    private static final String PRODUCT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.product.domain";
    private static final String PURCHASE_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.purchase.domain";
    private static final String FULFILLMENT_CENTER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain";

    @ArchTest
    static final ArchRule idFieldsMustUseGenericId =
            fields()
                    .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
                    .and().areAnnotatedWith( Id.class )
                    .should().haveRawType( assignableTo( GenericId.class ) )
                    .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
                    .allowEmptyShould( true );


    private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
            annotatedWith( ManyToOne.class )
                    .or( annotatedWith( OneToOne.class ) )
                    .or( annotatedWith( Embedded.class ) )
                    .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );

    private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
            annotatedWith( OneToMany.class )
                    .or( annotatedWith( ManyToMany.class ) )
                    .or( annotatedWith( ElementCollection.class ) )
                    .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );


    private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
        String description = "an entity or value object from same aggregate, or a domain primitive";
        return new DescribedPredicate<>( description ) {
            @Override
            public boolean test( JavaClass type ) {
                // check if the class is an entity or value object, and resides in the allowed package
                if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
                    return false;
                }
                // a GenericId is always allowed
                if ( type.isAssignableTo( GenericId.class ) ) {
                    return true;
                }
                // a domain primitive is also always allowed
                if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
                    return true;
                }
                return type.getPackageName().startsWith( allowedPackage );
            }
        };
    }


    @ArchTest
    static final ArchRule shoppingBasketToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule userToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( USER_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( USER_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule productToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( PRODUCT_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( PRODUCT_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule purchaseToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( PURCHASE_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( PURCHASE_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule fulfillmentCenterToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( FULFILLMENT_CENTER_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( FULFILLMENT_CENTER_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );


    private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
        return new ArchCondition<JavaField>(
                "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
            @Override
            public void check( JavaField field, ConditionEvents events ) {
                JavaClass rawType = field.getRawType();
                String rawTypeName = rawType.getFullName();
                if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
                    return;
                }
                JavaType fieldType = field.getType();
                if ( !( fieldType instanceof JavaParameterizedType ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " is a raw List/Set without a type argument" ) );
                    return;
                }
                List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
                if ( typeArguments.isEmpty() ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " has no type arguments" ) );
                    return;
                }
                JavaType elementType = typeArguments.get( 0 );
                if ( !( elementType instanceof JavaClass ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " has an unknown element type" ) );
                    return;
                }
                JavaClass elementClass = (JavaClass) elementType;
                boolean hasAnnotation =
                        elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
                boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
                boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
                boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
                boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
                if ( !ok ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " refers to " + elementClass.getFullName()
                                    + " which is not a DP, or an entity/value object in " + allowedPackage ) );
                }
            }
        };
    }


    @ArchTest
    static final ArchRule shoppingBasketToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule userToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( USER_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( USER_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule productToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( PRODUCT_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( PRODUCT_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule purchaseToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( PURCHASE_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( PURCHASE_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule fulfillmentCenterToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( FULFILLMENT_CENTER_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( FULFILLMENT_CENTER_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

/**
 * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
 */

public class OwnTestsTest {
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

public class PackageStructureTest {

    private static final String[] REQUIRED_PACKAGES = {"user", "shoppingbasket", "product", "purchase", "fulfillmentcenter"};
    private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
    private JavaClasses importedClasses;


    @BeforeEach
    public void setUp() {
        importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
    }

    @Test
    void testRequiredPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage;
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredDomainPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected domain sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredApplicationPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected application sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\CurrencyTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateCurrency;

class CurrencyTest {

    @Test
    public void testGetQuantityCurrency() {
        // given
        Float inputQuantity = 10.0f;

        // when
        CurrencyType instance = instantiateCurrency( inputQuantity, "EUR" );

        // then
        assertEquals( inputQuantity, instance.getQuantity() );
    }

    @Test
    public void testGetCurrencyUnitCurrency() {
        // given
        String inputCurrencyUnit = "EUR";

        // when
        CurrencyType instance = instantiateCurrency( 10.0f, inputCurrencyUnit );

        // then
        assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
    }

    @Test
    public void testAddToCurrency() {
        // given
        CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
        CurrencyType instance3 = instantiateCurrency( 0.0f, "EUR" );

        // when
        CurrencyType result12 = instance1.add( instance2 );
        CurrencyType result13 = instance1.add( instance3 );

        // then
        assertEquals( 30.0f, result12.getQuantity() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
        assertEquals( 10.0f, result13.getQuantity() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
    }

    @Test
    public void testInvalidAddToCurrency() {
        // given
        CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 20.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
    }

    @Test
    public void testSubtractFromCurrency() {
        // given
        CurrencyType instance1 = instantiateCurrency( 30.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
        CurrencyType instance3 = instantiateCurrency( 0.0f, "EUR" );
        CurrencyType instance4 = instantiateCurrency( 30.0f, "EUR" );

        // when
        CurrencyType result12 = instance1.subtract( instance2 );
        CurrencyType result13 = instance1.subtract( instance3 );
        CurrencyType result14 = instance1.subtract( instance4 );

        // then
        assertEquals( 10.0f, result12.getQuantity() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
        assertEquals( 30.0f, result13.getQuantity() );
        assertEquals( "EUR", result13.getCurrencyUnit() );
        assertEquals( 0.0f, result14.getQuantity() );
        assertEquals( "EUR", result14.getCurrencyUnit() );
    }

    @Test
    public void testInvalidSubtractFromCurrency() {
        // given
        CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
        CurrencyType instance3 = instantiateCurrency( 5.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
        assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
    }

    @Test
    public void testMultiplyByCurrency() {
        // given
        CurrencyType instance = instantiateCurrency( 10.0f, "EUR" );

        // when
        CurrencyType result = instance.multiplyBy( 3 );

        // then
        assertEquals( 30.0f, result.getQuantity() );
        assertEquals( "EUR", result.getCurrencyUnit() );
    }

    @Test
    public void testFactoryValidCurrencyUnitCurrency() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiateCurrency( 10.0f, "EUR" ) );
    }

    @Test
    public void testFactoryInvalidCurrencyUnitCurrency() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateCurrency( -10.0f, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateCurrency( 10.0f, "USD" ) );
        assertThrows( ShopException.class, () -> instantiateCurrency( null, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateCurrency( 10.0f, null ) );
    }

    @Test
    public void testLargerThanCurrencyUnitCurrency() {
        // given
        CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
        CurrencyType instance3 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance4 = instantiateCurrency( 10.0f, "CHF" );

        // when
        // then
        assertTrue( instance2.largerThan( instance1 ) );
        assertFalse( instance1.largerThan( instance2 ) );
        assertFalse( instance1.largerThan( instance3 ) );
        assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
    }


    @Test
    public void testEqualityCurrencyUnitCurrency() {
        // given
        // when
        CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance2 = instantiateCurrency( 10.0f, "EUR" );
        CurrencyType instance3 = instantiateCurrency( 20.0f, "EUR" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutabilityCurrencyUnitCurrency() {
        // given
        // when
        CurrencyType instance = instantiateCurrency( 10.0f, "EUR" );

        // then
        try {
            instance.getClass().getMethod( "setQuantity", Float.class );
            fail( "setQuantity method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }

        try {
            instance.getClass().getMethod( "setCurrencyUnit", String.class );
            fail( "setCurrencyUnit method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

@ArchTag("domainPrimitivesUsageRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class DomainPrimitivesUsageRulesTest {
    private static final String MAIL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.MailAddress";
    private static final String CURRENCY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Currency";
    private static final String PHYSICAL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress";

    @ArchTest
    static final ArchRule userShouldReferenceMailAddress =
            classes()
                    .that().haveSimpleName( "User" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( MAIL_ADDRESS_CLASS )
                    .because( "User should use MailAddress instead of String" );

    @ArchTest
    static final ArchRule userShouldReferencePhysicalAddress =
            classes()
                    .that().haveSimpleName( "User" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
                    .because( "User should use PhysicalAddress instead of whatever else" );

    @ArchTest
    static final ArchRule fulfillmentCenterShouldReferencePhysicalAddress =
            classes()
                    .that().haveSimpleName( "FulfillmentCenter" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
                    .because( "User should use PhysicalAddress instead of whatever else" );

    @ArchTest
    static final ArchRule productShouldReferenceCurrency =
            classes()
                    .that().haveSimpleName( "Product" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( CURRENCY_CLASS )
                    .because( "Product should use Currency instead of float or whatever else" );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\MailAddressTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMailAddress;

class MailAddressTest {

    @Test
    public void testToStringMailAddress() {
        // given
        String input = "test@example.com";

        // when
        MailAddressType instance = instantiateMailAddress( input );

        // then
        assertEquals( input, instance.toString() );
    }

    @Test
    public void testEqualityMailAddress() {
        // given
        // when
        MailAddressType instance1 = instantiateMailAddress( "test@example.com" );
        MailAddressType instance2 = instantiateMailAddress( "test@example.com" );
        MailAddressType instance3 = instantiateMailAddress( "different@example.com" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutabilityMailAddress() {
        // given
        // when
        MailAddressType instance = instantiateMailAddress( "test@example.com" );

        // then
        try {
            instance.getClass().getMethod( "setMailAddress", String.class );
            fail( "setMailAddress method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }



    @Test
    public void smokeTestForCopyConstructors() {
        // given
        MailAddressType mailAddress =
                instantiateMailAddress( "peter.schmidt@web.de" );

        // when
        MailAddressType mailAddressOtherIdentifyer =
                mailAddress.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
        assertThrows( ShopException.class, () ->
                mailAddress.sameDomainDifferentIdentifyer( "p...eter" ) );
        MailAddressType mailAddressOtherDomain =
                mailAddress.sameIdentifyerDifferentDomain( "web.ch" );
        assertThrows( ShopException.class, () ->
                mailAddress.sameIdentifyerDifferentDomain( "web.edu" ) );

        // then
        assertEquals( "p.e.t.e.r@web.de", mailAddressOtherIdentifyer.toString() );
        assertEquals( "peter.schmidt@web.ch", mailAddressOtherDomain.toString() );
    }


    @Test
    public void testFactoryValidMailAddress() {
        // given
        // when
        // then
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "99Z@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "GGGhh@s77.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "a@4.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "Max.Hammer@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "Max.Gideon.Hammer@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.this.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.de" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.at" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.ch" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.org" ) );
    }


    @Test
    public void testFactoryInvalidMailAddress() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateMailAddress( null ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "testexample.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "Max..Gideon.Hammer@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@examplecom" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example..com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test#example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.42" ) );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\PhysicalAddressTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePostalCode;

class PhysicalAddressTest {

    @Test
    public void testGetterPhysicalAddress() {
        // given
        String street = "Irgendeinestra√üe 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );

        // then
        assertEquals( street, instance.getStreet() );
        assertEquals( city, instance.getCity() );
        assertEquals( plz, instance.getPostalCode() );
    }

    @Test
    public void testFactoryValidPhysicalAddress() {
        // given
        String street = "Irgendeinestra√üe 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        // then
        assertDoesNotThrow( () -> instantiatePhysicalAddress( street, city, plz ) );
    }

    @Test
    public void testFactoryInvalidPhysicalAddress() {
        // given
        String street = "Irgendeinestra√üe 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        // then
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( null, city, plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( "", city, plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, null, plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, "", plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, city, null ) );
    }

    @Test
    public void testEqualityPhysicalAddress() {
        // given
        String street = "Irgendeinestra√üe 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        PhysicalAddressType instance1 = instantiatePhysicalAddress( street, city, plz );
        PhysicalAddressType instance2 = instantiatePhysicalAddress( street, city, plz );
        PhysicalAddressType instance3 = instantiatePhysicalAddress( "Anderestr. 12", city, plz );
        PhysicalAddressType instance4 = instantiatePhysicalAddress( street, "AndereStadt", plz );
        PhysicalAddressType instance5 = instantiatePhysicalAddress( street, city, instantiatePostalCode( "54321" ) );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
        assertNotEquals( instance1, instance4 );
        assertNotEquals( instance1, instance5 );
    }

    @Test
    public void testImmutabilityPhysicalAddress() {
        // given
        String street = "Irgendeinestra√üe 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );

        // then
        try {
            instance.getClass().getMethod( "setStreet", String.class );
            fail( "setStreet method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setCity", String.class );
            fail( "setCity method should not exist" );

        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setPostalCode", PostalCodeType.class );
            fail( "setPostalCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\PostalCodeTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePostalCode;

class PostalCodeTest {

    private String input1, input4;
    private PostalCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
            _04233, _02544, _99123, _56323, _79332;


    @BeforeEach
    public void setUp() {
        input1 = "12345";
        input4 = "49188";
        _12345 = FactoryMethodInvoker.instantiatePostalCode( "12345" );
        _12345b = FactoryMethodInvoker.instantiatePostalCode( "12345" );
        _23455 = FactoryMethodInvoker.instantiatePostalCode( "23455" );
        _01234 = FactoryMethodInvoker.instantiatePostalCode( "01234" );
        _01235 = FactoryMethodInvoker.instantiatePostalCode( "01235" );
        _01238 = FactoryMethodInvoker.instantiatePostalCode( "01238" );
        _01263 = FactoryMethodInvoker.instantiatePostalCode( "01263" );
        _01213 = FactoryMethodInvoker.instantiatePostalCode( "01213" );
        _01823 = FactoryMethodInvoker.instantiatePostalCode( "01823" );
        _01312 = FactoryMethodInvoker.instantiatePostalCode( "01312" );
        _04233 = FactoryMethodInvoker.instantiatePostalCode( "04233" );
        _02544 = FactoryMethodInvoker.instantiatePostalCode( "02544" );
        _99123 = FactoryMethodInvoker.instantiatePostalCode( "99123" );
        _56323 = FactoryMethodInvoker.instantiatePostalCode( "56323" );
        _79332 = FactoryMethodInvoker.instantiatePostalCode( "79332" );

    }


    @Test
    public void testToStringPostalCode() {
        // given
        // when
        PostalCodeType instance = instantiatePostalCode( input1 );

        // then
        assertEquals( input1, instance.toString() );
    }

    @Test
    public void testFactoryValidPostalCode() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiatePostalCode( input1 ) );
    }

    @Test
    public void testFactoryInvalidPostalCode() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiatePostalCode( "123456" ) );
        assertThrows( ShopException.class, () -> instantiatePostalCode( "1234" ) );
        assertThrows( ShopException.class, () -> instantiatePostalCode( "20000" ) );
        assertThrows( ShopException.class, () -> instantiatePostalCode( null ) );
    }

    @Test
    public void testEqualityPostalCode() {
        // given
        // when
        PostalCodeType instance1a = instantiatePostalCode( input1 );
        PostalCodeType instance1b = instantiatePostalCode( input1 );
        PostalCodeType instance4 = instantiatePostalCode( input4 );

        // then
        assertEquals( instance1a, instance1b );
        assertNotEquals( instance1a, instance4 );
    }

    @Test
    public void testImmutabilityPostalCode() {
        // given
        // when
        PostalCodeType instance = instantiatePostalCode( input1 );

        // then
        try {
            instance.getClass().getMethod( "setpostalCode", String.class );
            fail( "setpostalCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }


    @Test
    public void smokeTestForDistance() {
        // given
        PostalCodeType instance1a = instantiatePostalCode( input1 );
        PostalCodeType instance1b = instantiatePostalCode( input1 );
        PostalCodeType instance12479 = instantiatePostalCode( "12479" );
        PostalCodeType instance21456 = instantiatePostalCode( "21456" );

        // when
        int distanceAB = instance1a.distance( instance1b );
        int distance12 = instance1a.distance( instance12479 );
        int distance23 = instance12479.distance( instance21456 );

        // then
        assertEquals( 0, distanceAB );
        assertTrue( distance12 > 0 );
        assertTrue( distance23 > distance12 );
    }


    @Test
    public void testPostalCodeFirstDigit() {
        // given
        PostalCodeType instance1 = instantiatePostalCode( input1 );
        PostalCodeType instance4 = instantiatePostalCode( input4 );

        // when
        // then
        assertEquals( 1, instance1.getFirstDigitPostalCode() );
        assertEquals( 4, instance4.getFirstDigitPostalCode() );
    }



    @Test
    public void testInvalidParameters() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () ->
                _12345.distance( null ) );
    }


    @Test
    public void testSamePostalCode() {
        // given
        // when
        int diff = _12345.distance( _12345b );

        // then
        assertEquals( 0, diff );
    }


    /**
     *      - The distance is > 0 if both postal codes differ in the last digit, like 5673x
     *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
     *        So, 56733 and 56734 have the same distance as 56733 and 56739.
     *      - The distance grows if more digits (counted from the right side) differ.
     *        So, 5abcd and 5rstu have a larger distance than 53bcd and 53stu (if abcd
     *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
     *        53876 and 54876 have the same distance as 53876 and 57261.
     */
    @Test
    public void testPostalCodeDistanceInAllButFirstDigit() {
        // given
        // when
        int diff5a = _01234.distance( _01235 );
        int diff5b = _01234.distance( _01238 );
        int diff4a = _01234.distance( _01263 );
        int diff4b = _01234.distance( _01213 );
        int diff3a = _01234.distance( _01823 );
        int diff3b = _01234.distance( _01312 );
        int diff2a = _01234.distance( _04233 );
        int diff2b = _01234.distance( _02544 );

        // then
        assertEquals( diff5a, diff5b, "distance 01234-01235 must be the same as distance 01234-01238" );
        assertEquals( diff4a, diff4b, "distance 01234-01263 must be the same as distance 01234-01213" );
        assertEquals( diff3a, diff3b, "distance 01234-01823 must be the same as distance 01234-01312" );
        assertEquals( diff2a, diff2b, "distance 01234-04233 must be the same as distance 01234-02544" );

        assertTrue( diff5a < diff4a,
                "distance 01234-01235 must be smaller than distance 01234-01263" );
        assertTrue( diff4a < diff3a,
                "distance 01234-01263 must be smaller than distance 01234-01823" );
        assertTrue( diff3a < diff2a,
                "distance 01234-01823 must be smaller than distance 01234-04233" );
    }


    /**
     *      - However, the distance between 5abcd and 6rstu must be smaller than the one
     *        between 5abcd and 7rstu, and this distance in turn must be smaller than the
     *        one between 5abcd and 9rstu.
     *      - This last condition reflects the fact the first digits of a postal code marks a region
     *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
     *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
     *        other.
     */
    @Test
    public void testPostalCodedistanceInFirstDigit() {
        // given
        // when
        int diff1_1 = _01234.distance( _99123 );
        int diff1_2 = _01234.distance( _23455 );
        int diff1_5 = _01234.distance( _56323 );
        int diff1_3 = _01234.distance( _79332 );

        // then
        assertTrue( diff1_1 < diff1_2,
                "distance 01234-99123 must be smaller than distance 01234-23455"  );
        assertTrue( diff1_2 < diff1_3,
                "distance 01234-23455 must be smaller than distance 01234-79332" );
        assertTrue( diff1_3 < diff1_5,
                "distance 01234-79332 must be smaller than distance 01234-56323"  );
    }



}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
package thkoeln.archilab.ecommerce.tests.e1restcalls;

import org.junit.jupiter.api.Test;
import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;


public class E1RestCallTableTest {

    private GenericTableSpecificationTests genericTableSpecificationTests = null;


    public E1RestCallTableTest() {
        this.genericTableSpecificationTests = new GenericTableSpecificationTests();
    }

    @Test
    public void restTest() throws Exception {
        genericTableSpecificationTests.testTableSpecification("E1" );
    }
}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\fulfillmentcenter\FulfillmentCenterManagementTest.java ---
package thkoeln.archilab.ecommerce.tests.fulfillmentcenter;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePostalCode;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;


/**
 * This test checks the management and lifecycle of fulfillment centers.
 */
@SpringBootTest
public class FulfillmentCenterManagementTest {
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;

    private PhysicalAddressType somePhysicalAddress;
    private UUID nonExistingId1;
    private UUID nonExistingId2;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        productTestHelper.addAllProducts();

        somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
                instantiatePostalCode( "90001" ) );
        nonExistingId1 = UUID.randomUUID();
        nonExistingId2 = UUID.randomUUID();
    }


    @Test
    public void testAddInvalidFulfillmentCenter() {
        // given
        String name = "Lager1";

        // when
        // then
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
                        null, somePhysicalAddress ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
                        "", somePhysicalAddress ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
                        name, null ) );
    }


    @Test
    public void testDeleteAllFulfillmentCentersWhenEmpty() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
        UUID productId9 = productTestHelper.getProductId( 9 );
        UUID fulfillmentCenterId1 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 1 );
        UUID fulfillmentCenterId2 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 2 );

        // when
        int numOf1 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId1, productId9 );
        int numOf2 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId2, productId9 );

        // then
        assertEquals( 0, numOf1 );
        assertEquals( 0, numOf2 );
        fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
        // ... ids must be invalid now
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId1, productId9 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId2, productId9 ) );
    }


    @Test
    public void testDeleteAllFulfillmentCentersWhenFull() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID productId7 = productTestHelper.getProductId( 7 );
        UUID fulfillmentCenterId1 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 1 );
        UUID fulfillmentCenterId2 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 2 );

        // when
        int numOf1 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId1, productId7 );
        int numOf2 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId2, productId7 );

        // then
        assertTrue( numOf1 == 3 );
        assertTrue( numOf2 == 3 );
        fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
        // ... ids must be invalid now
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId1, productId7 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId2, productId7 ) );
    }



    @Test
    public void testAddToInventory() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in fulfillment center 0
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        int originalInventory5 =
                fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 5 );

        // when
        int inventory5before = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId5 );
        fulfillmentCenterUseCases.addToInventory( fulfillmentCenterId0, productId5, 23 );
        int inventory5after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId5 );
        fulfillmentCenterUseCases.addToInventory( fulfillmentCenterId0, productId5, 0 );
        int inventory5after2 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId5 );

        // then
        assertEquals( originalInventory5, inventory5before );
        assertEquals( inventory5before + 23, inventory5after );
        assertEquals( inventory5after, inventory5after2 );
    }


    @Test
    public void testInvalidAddToInventory() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID productId2 = productTestHelper.getProductId( 2 );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );

        // when
        // then
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addToInventory( nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addToInventory(
                        fulfillmentCenterId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addToInventory(
                        nonExistingId1, productId2, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addToInventory(
                        fulfillmentCenterId0, productId2, -1 ) );
    }


    @Test
    public void testRemoveFromInventory() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID productId0 = productTestHelper.getProductId( 0 ); // 0 in fulfillment center 0
        UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in fulfillment center 0
        UUID productId6 = productTestHelper.getProductId( 6 ); // random >30 in fulfillment center 0
        int inventory0before =
                fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 0 );
        int inventory5before =
                fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 5 );
        int inventory6before =
                fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 6 );

        // when
        fulfillmentCenterUseCases.removeFromInventory( fulfillmentCenterId0, productId5, 1 );
        int inventory5after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId5 );
        fulfillmentCenterUseCases.removeFromInventory( fulfillmentCenterId0, productId0, 0 );
        int inventory0after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId0 );
        fulfillmentCenterUseCases.removeFromInventory(
                fulfillmentCenterId0, productId6, inventory6before );
        int inventory6after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId6 );

        // then
        assertEquals( inventory5before - 1, inventory5after );
        assertEquals( inventory0before, inventory0after );
        assertEquals( 0, inventory6after );
    }


    @Test
    public void testInvalidRemoveFromInventory() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID productId0 = productTestHelper.getProductId( 0 ); // 0 in fulfillment center 0
        UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in fulfillment center 0
        int inventory5before =
                fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 5 );

        // when
        // then
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromInventory( nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromInventory(
                        fulfillmentCenterId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromInventory(
                        nonExistingId1, productId5, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromInventory(
                        fulfillmentCenterId0, productId5, -1 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromInventory(
                        fulfillmentCenterId0, productId5, inventory5before + 1 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromInventory(
                        fulfillmentCenterId0, productId0, 1 ) ); // already 0 in fulfillment center 0
    }


    @Test
    public void testChangeInventory() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in fulfillment center 0

        // when
        fulfillmentCenterUseCases.changeInventoryTo( fulfillmentCenterId0, productId5, 111 );
        int inventory5after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId5 );

        // then
        assertEquals( 111, inventory5after );
    }


    @Test
    public void testInvalidChangeInventory() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID productId6 = productTestHelper.getProductId( 6 );

        // when
        // then
        assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeInventoryTo(
                nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeInventoryTo(
                nonExistingId1, productId6, 12 ) );
        assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeInventoryTo(
                fulfillmentCenterId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeInventoryTo(
                fulfillmentCenterId0, productId6, -1 ) );
    }


    @Test
    public void testEmptyFulfillmentCenter() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID fulfillmentCenterId9 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 9 ); // empty fulfillment center

        // when
        int totalInventory = 0;
        for ( int iProduct = 0; iProduct < productTestHelper.numberOfProducts(); iProduct++ ) {
            UUID productId = productTestHelper.getProductId( iProduct );
            totalInventory += fulfillmentCenterUseCases.getAvailableInventory(
                    fulfillmentCenterId9, productId );
        }

        // then
        assertEquals( 0, totalInventory );
    }



}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
package thkoeln.archilab.ecommerce.tests.owntests;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.jayway.jsonpath.JsonPath;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.domainprimitives.Currency;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;

import static org.junit.jupiter.api.Assertions.*;

public class DomainPrimitiveJSONSerializationTest {

    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        // Initialisiere Jackson-ObjectMapper f√ºr die Tests
        objectMapper = new ObjectMapper();
    }

    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * MailAddress.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     */
    @Test
    public void test_MailAddress_Serialization() throws Exception {
        // given
        MailAddress mailAddress = (MailAddress) MailAddress.of("test@example.com");
        ObjectMapper mapper = new ObjectMapper();

        // when
        String json = mapper.writeValueAsString(mailAddress);
        MailAddress deserialized = mapper.readValue(json, MailAddress.class);

        // then
        assertTrue(json.contains("mailAddressString"));
        assertTrue(json.contains("test@example.com"));
        assertEquals(mailAddress, deserialized);
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * PostalCode.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     */
    @Test
    public void test_PostalCode_Serialization() throws Exception {
        // given
        PostalCode postalCode = PostalCode.of("50667");
        ObjectMapper mapper = new ObjectMapper();

        // when
        String json = mapper.writeValueAsString(postalCode);
        PostalCode deserialized = objectMapper.readValue(json, PostalCode.class);

        // then
        assertTrue(json.contains("postalCode"));
        assertTrue(json.contains("50667"));
        assertEquals(postalCode, deserialized);
    }

    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * PhysicalAddress.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     */
    @Test
    public void test_PhysicalAddress_Serialization() throws Exception {
        // given
        PhysicalAddress address = new PhysicalAddress("Main Street", "Cologne", PostalCode.of("50667"));
        ObjectMapper mapper = new ObjectMapper();

        // when
        String json = mapper.writeValueAsString( address );

        // then (assert using JsonPath)
        String street = JsonPath.read( json, "$.street" );
        String city = JsonPath.read( json, "$.city" );
        assertEquals( "Main Street", street );
        assertEquals( "Cologne", city );
    }

    /* ChatGPT Hilfe:
    public void test_PhysicalAddress_Serialization() throws Exception {
        // given
        PhysicalAddress address = new PhysicalAddress("Main Street", "Cologne", PostalCode.of("50667"));

        // when
        String json = objectMapper.writeValueAsString(address);
        PhysicalAddress deserialized = objectMapper.readValue(json, PhysicalAddress.class);

        // then
        assertTrue(json.contains("street"));
        assertTrue(json.contains("city"));
        assertTrue(json.contains("postalCode"));
        assertTrue(json.contains("50667"));
        assertEquals(address.getStreet(), deserialized.getStreet());
        assertEquals(address.getCity(), deserialized.getCity());
        assertEquals(address.getPostalCode(), deserialized.getPostalCode());
    }
     */

    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * Currency.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     */
    @Test
    public void test_Currency_Serialization() throws Exception {
        // given
        Currency currency = new Currency(12.99f, "EUR");
        ObjectMapper mapper = new ObjectMapper();

        // when
        String json = mapper.writeValueAsString(currency);
        Currency deserialized = objectMapper.readValue(json, Currency.class);

        // then
        assertTrue(json.contains("quantity"));
        assertTrue(json.contains("currencyUnit"));
        assertEquals(currency.getQuantity(), deserialized.getQuantity());
        assertEquals(currency.getCurrencyUnit(), deserialized.getCurrencyUnit());
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingBasketRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.owntests;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.*;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import(RESTTestHelperConfiguration.class)
public class OwnShoppingBasketRESTTest {

    @Autowired private Purgatory purgatory;
    @Autowired private UserTestHelper userTestHelper;
    @Autowired private ProductTestHelper productTestHelper;
    @Autowired private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
    @Autowired private ShoppingBasketRESTHelper shoppingBasketRESTHelper;

    private MailAddressType mailAddress;
    private UUID product1;
    private UUID product2;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        productTestHelper.addAllProducts();
        fulfillmentCenterTestHelper.addAllFulfillmentCenters(true);

        mailAddress = userTestHelper.getUserMailAddress(0);
        product1 = productTestHelper.getProductId(1); // garantiert im Bestand
        product2 = productTestHelper.getProductId(10); // anderes FulfillmentCenter
    }

    /**
     * Provide a test that implements a simple call to the REST endpoint (3):
     * <pre>
     *     GET /shoppingBaskets?userId=<user id as uuid>
     * </pre>
     * - Use the {@link UserTestHelper} to obtain to obtain the mail address
     *   of some example user.
     * - Use your shopping basket service to add entries to the shopping basket of that person.
     * - then use the `ShoppingBasketRESTHelper` to create the GET call, and check the results.
     * - (or do it by directly calling your REST controller, if you prefer)
     * @throws Exception
     */
    @Test
    public void test_getQuery_ShoppingBasket() throws Exception {
        // given
        Map<UUID, Integer> quantities = new HashMap<>();
        quantities.put(product1, 3);
        UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(mailAddress, null);
        shoppingBasketRESTHelper.addProductToShoppingBasket(basketId, product1, 3);

        // when + then
        shoppingBasketRESTHelper.getQueryShoppingBasket(mailAddress, quantities);
    }

    /**
     * Provide a test that implements the addition of one product to the shopping basket via
     * REST endpoint (6):
     * <pre>
     *     POST /shoppingBaskets/{shoppingBasket-Id}/positions
     * </pre>
     * You can test now "the other way around" as in test_getQuery_ShoppingBasket():
     * - Use `ShoppingBasketRESTHelper` to add products via REST, then use shopping basket service methods
     *   to check of the shopping basket contains the right stuff.
     * - (or do it by directly calling your REST controller, if you prefer)
     *
     * @throws Exception
     */
    @Test
    public void test_post_ShoppingBasketPositions() throws Exception {
        // given
        UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(mailAddress, null);

        // when
        shoppingBasketRESTHelper.addProductToShoppingBasket(basketId, product1, 2, status().isCreated());

        // then
        Map<UUID, Integer> expected = Map.of(product1, 2);
        shoppingBasketRESTHelper.getQueryShoppingBasket(mailAddress, expected);
    }

    /**
     * Provide a test that implements the deletion of one product in the shopping basket via
     * REST endpoint (10):
     * <pre>
     *     DELETE /shoppingBaskets/{shoppingBasket-Id}/positions/{product-Id}
     * </pre>
     * This should be just a slight variation of the test_post_ShoppingBasketPositions()
     * method, but instead of adding an product to the shopping basket, you delete it.
     *
     * @throws Exception
     */
    @Test
    public void test_delete_ShoppingBasketPositions() throws Exception {
        // given
        UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(mailAddress, null);
        shoppingBasketRESTHelper.addProductToShoppingBasket(basketId, product1, 1);

        // when
        shoppingBasketRESTHelper.deleteProductFromShoppingBasket(basketId, product1, status().isOk());

        // then
        shoppingBasketRESTHelper.getQueryShoppingBasket(mailAddress, Map.of());
    }

    /**
     * Provide a test that implements the checkout of a shopping basket that can be served
     * by just 1 fulfillment center, using the REST endpoint (11):
     * <pre>
     *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
     * </pre>
     * - Use your shopping basket service to add entries to the shopping basket of some example user,
     * - then use the `ShoppingBasketRESTHelper to post the checkout call, and to check the results.
     * - (or do it by directly calling your REST controller, if you prefer)
     *
     * @throws Exception
     */
    @Test
    public void test_checkout_1_fulfillmentCenter() throws Exception {
        // given
        UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(mailAddress, null);
        shoppingBasketRESTHelper.addProductToShoppingBasket(basketId, product1, 1);

        Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>();
        expectedPurchases.put(
                fulfillmentCenterTestHelper.getFulfillmentCenterId(0),
                Map.of(product1, 1)
        );

        // when + then
        shoppingBasketRESTHelper.checkout(basketId,
                userTestHelper.getUserName(0),
                status().isCreated(),
                expectedPurchases
        );
    }

    /**
     * Provide a test that implements the checkout of a shopping basket that can only be served
     * by using 2 fulfillment centers, using the REST endpoint (11):
     * <pre>
     *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
     * </pre>
     * This should be just a slight variation of thetest_checkout_1_fulfillmentCenter() test.
     *
     * @throws Exception
     */
    @Test
    public void test_checkout_2_fulfillmentCenters() throws Exception {
        // given
        UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(mailAddress, null);
        shoppingBasketRESTHelper.addProductToShoppingBasket(basketId, product1, 2);
        shoppingBasketRESTHelper.addProductToShoppingBasket(basketId, product2, 2);

        Map<UUID, Integer> allProducts = Map.of(
                product1, 2,
                product2, 2
        );

        Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>();
        for (Map.Entry<UUID, Integer> entry : allProducts.entrySet()) {
            expectedPurchases.put(UUID.randomUUID(), Map.of(entry.getKey(), entry.getValue()));
        }

        // when + then ‚Äì ignoriert expectedPurchases intern und validiert nur Produkt+Menge
        shoppingBasketRESTHelper.checkout(
                basketId,
                userTestHelper.getUserName(0),
                status().isCreated(),
                null // ‚Üê keine FC-Pr√ºfung, nur Produkt+Menge via Positionen
        );
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\product\ProductCatalogTest.java ---
package thkoeln.archilab.ecommerce.tests.product;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.*;

import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;


@SpringBootTest
public class ProductCatalogTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        productTestHelper.addAllProducts();
    }


    @Test
    public void testAddProductToCatalog() {
        // given
        UUID productId4 = productTestHelper.getProductId( 4 );
        CurrencyType salesPrice4 = productTestHelper.getSalesPrice( 4 );

        // when
        CurrencyType foundSalesPrice = productCatalogUseCases.getSalesPrice( productId4 );

        // then
        assertEquals( salesPrice4, foundSalesPrice );
    }


    @Test
    public void testAddProductWithInvalidData() {
        // given
        String name = "SomeStuff";
        String description = "Some more explanation on the stuff";
        Float size = 5.0f;
        CurrencyType buyingPrice =
                FactoryMethodInvoker.instantiateCurrency( 5.0f, "EUR" );
        CurrencyType salesPrice =
                FactoryMethodInvoker.instantiateCurrency( 10.0f, "EUR" );
        CurrencyType tooLowSalesPrice =
                FactoryMethodInvoker.instantiateCurrency( 4.0f, "EUR" );

        // when / then
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        null, description, size, buyingPrice, salesPrice ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        "", description, size, buyingPrice, salesPrice ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        name, null, size, buyingPrice, salesPrice ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        name, "", size, buyingPrice, salesPrice ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        name, description, size, null, salesPrice ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        name, description, size, buyingPrice, null ) );
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.addProductToCatalog(
                        name, description, size, buyingPrice, tooLowSalesPrice ) );
    }


    @Test
    public void testRemoveNonExistentProduct() {
        // given product 2 is not in inventory anywhere - should be removable
        UUID nonExistentProductId = UUID.randomUUID();

        // when
        // then
        assertThrows( ShopException.class,
                () -> productCatalogUseCases.removeProductFromCatalog( nonExistentProductId ) );
    }


    @Test
    public void testRemoveProductWithNoInventory() {
        // given product 0 is not in inventory anywhere - should be removable
        UUID productId0 = productTestHelper.getProductId( 0 );
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );

        // when
        assertDoesNotThrow( () -> productCatalogUseCases.getSalesPrice( productId0 ) );
        productCatalogUseCases.removeProductFromCatalog( productId0 );

        // then
        assertThrows( ShopException.class, () ->
                productCatalogUseCases.getSalesPrice( productId0 ) );
    }


    @Test
    public void testRemoveProductThatIsInInventory() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID productId3 = productTestHelper.getProductId( 3 );
        UUID productId4 = productTestHelper.getProductId( 4 );
        fulfillmentCenterUseCases.addToInventory( fulfillmentCenterId0, productId3, 3 );

        // then product 3 must not be removable, but product 4 must be removable
        assertThrows( ShopException.class,
                () -> productCatalogUseCases.removeProductFromCatalog( productId3 ) );
        assertDoesNotThrow( () -> productCatalogUseCases.removeProductFromCatalog( productId4 ) );
    }


    @Test
    public void testRemoveProductThatIsInPurchase() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID productId4 = productTestHelper.getProductId( 4 );
        MailAddressType userMailAddress4 =
                userTestHelper.getUserMailAddress( 4 );
        fulfillmentCenterUseCases.addToInventory( fulfillmentCenterId0, productId4, 4 );

        // when user 4 adds 4x product 4 to his shopping basket and checks out ...
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress4, productId4, 4 );
        shoppingBasketUseCases.checkout( userMailAddress4 );

        // then product 4 must not be removable
        assertThrows( ShopException.class,
                () -> productCatalogUseCases.removeProductFromCatalog( productId4 ) );
    }


    @Test
    public void testClearProductCatalog() {
        // given
        UUID productId4 = productTestHelper.getProductId( 4 );

        // when
        productCatalogUseCases.deleteProductCatalog();

        // then
        assertThrows( ShopException.class, () -> productCatalogUseCases.getSalesPrice( productId4 ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\purchase\PurchaseTest.java ---
package thkoeln.archilab.ecommerce.tests.purchase;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;


@SpringBootTest
public class PurchaseTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private PurchaseUseCases purchaseUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;

    private UUID nonExistingId1;
    private UUID nonExistingId2;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        productTestHelper.addAllProducts();
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        nonExistingId1 = UUID.randomUUID();
        nonExistingId2 = UUID.randomUUID();
    }


    @Test
    public void testPurchaseHistory() {
        // given
        UUID productId1 = productTestHelper.getProductId( 1 );
        UUID productId2 = productTestHelper.getProductId( 2 );
        MailAddressType userMailAddress7 =
                userTestHelper.getUserMailAddress( 7 );
        Map<UUID, Integer> purchaseHistoryBefore = purchaseUseCases.getPurchaseHistory( userMailAddress7 );

        // when
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress7, productId1, 3 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress7, productId2, 2 );
        shoppingBasketUseCases.checkout( userMailAddress7 );
        Map<UUID, Integer> purchaseHistory1 =
                purchaseUseCases.getPurchaseHistory( userMailAddress7 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress7, productId1, 6 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress7, productId2, 2 );
        shoppingBasketUseCases.checkout( userMailAddress7 );
        Map<UUID, Integer> purchaseHistory2 =
                purchaseUseCases.getPurchaseHistory( userMailAddress7 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress7, productId1, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress7, productId2, 6 );
        shoppingBasketUseCases.checkout( userMailAddress7 );
        Map<UUID, Integer> purchaseHistory3 =
                purchaseUseCases.getPurchaseHistory( userMailAddress7 );

        // then
        assertEquals( 0, purchaseHistoryBefore.size() );
        assertEquals( 2, purchaseHistory1.size() );
        assertEquals( 2, purchaseHistory2.size() );
        assertEquals( 2, purchaseHistory3.size() );
        assertEquals( 3, purchaseHistory1.get( productId1 ) );
        assertEquals( 2, purchaseHistory1.get( productId2 ) );
        assertEquals( 9, purchaseHistory2.get( productId1 ) );
        assertEquals( 4, purchaseHistory2.get( productId2 ) );
        assertEquals( 10, purchaseHistory3.get( productId1 ) );
        assertEquals( 10, purchaseHistory3.get( productId2 ) );
    }


    @Test
    public void testForEmptyPurchaseHistory() {
        // given
        MailAddressType userMailAddress4 =
                userTestHelper.getUserMailAddress( 4 );
        // when
        Map<UUID, Integer> purchaseHistory =
                purchaseUseCases.getPurchaseHistory( userMailAddress4 );
        // then
        assertEquals( 0, purchaseHistory.size() );
    }


    @Test
    public void testInvalidParamsForGetPurchaseQuantityForProduct() {
        // given
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );

        // when / then
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantityForProduct( null, null ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantityForProduct( nonExistingId1, null ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantityForProduct( null, nonExistingId2 ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantityForProduct( nonExistingId1, nonExistingId2 ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantityForProduct( fulfillmentCenterId0, null ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantityForProduct( fulfillmentCenterId0, nonExistingId2 ) );
    }


    @Test
    public void testInvalidParamsForGetFulfillmentCenterIdForPurchase() {
        // given / when / then
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getFulfillmentCenterIdForPurchase( null ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getFulfillmentCenterIdForPurchase( nonExistingId1 ) );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\CheckoutAcceptanceTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingbasket;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * This test checks the management of inventory across fulfillment centers. It focuses on the
 * cases where more than one fulfillment center are needed to serve the shopping basket of a user.
 */
@Slf4j
@SpringBootTest
public class CheckoutAcceptanceTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private PurchaseUseCases purchaseUseCases;
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;

    private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
                                map8_11_14_quantity_3_3_4,
                                map10_12_quantity_1_1, 
                                map11_quantity_1, 
                                map12_quantity_10,
                                map8_9_10_11_quantity_2_1_4_2;
    private MailAddressType userMailAddress3, userMailAddress6,
            userMailAddress2;
    private UUID productId8, productId9, productId10, productId11, productId12,
            productId14;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        productTestHelper.addAllProducts();
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );

        userMailAddress3 = userTestHelper.getUserMailAddress( 3 );
        userMailAddress6 = userTestHelper.getUserMailAddress( 6 );
        userMailAddress2 = userTestHelper.getUserMailAddress( 2 );

        productId8 = productTestHelper.getProductId( 8 );
        productId9 = productTestHelper.getProductId( 9 );
        productId10 = productTestHelper.getProductId( 10 );
        productId11 = productTestHelper.getProductId( 11 );
        productId12 = productTestHelper.getProductId( 12 );
        productId14 = productTestHelper.getProductId( 14 );

        map8_11_14_quantity_2_2_2 = new HashMap<>() {{
            put( productId8, 2 );
            put( productId11, 2 );
            put( productId14, 2 );
        }};
        map8_11_14_quantity_3_3_4 = new HashMap<>() {{
            put( productId8, 3 );
            put( productId11, 3 );
            put( productId14, 4 );
        }};
        map10_12_quantity_1_1 = new HashMap<>() {{
            put( productId10, 1 );
            put( productId12, 1 );
        }};
        map11_quantity_1 = new HashMap<>() {{
            put( productId11, 1 );
        }};
        map12_quantity_10 = new HashMap<>() {{
            put( productId12, 10 );
        }};
        map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
            put( productId8, 2 );
            put( productId9, 1 );
            put( productId10, 4 );
            put( productId11, 2 );
        }};

    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of inventory
     * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
     */
    @Test
    public void testClosestSingleFulfillmentCenterWins() {
        log.info( "testClosestSingleFulfillmentCenterWins" );

        // given
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress3, productId8, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress3, productId11, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress3, productId14, 2 );
        // that basket could have been served from fulfillment center 4 or 7, but 4 is closer to the user
        UUID fulfillmentCenterId4 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 4 );

        // when
        Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userMailAddress3 );

        // then
        checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId4 );
        checkProductNumbers( purchaseIds, fulfillmentCenterId4, map8_11_14_quantity_2_2_2 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of inventory
     * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
     */
    @Test
    public void testFulfillmentCenterWithEnoughCapacityWins() {
        log.info( "testFulfillmentCenterWithEnoughCapacityWins" );

        // given
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress3, productId8, 3 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress3, productId11, 3 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress3, productId14, 4 );
        // that basket could have been served from fulfillment center 4 or 7, 4 is closer to the user,
        // but only 7 has enough capacity
        UUID fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );

        // when
        Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userMailAddress3 );

        // then
        checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId7 );
        checkProductNumbers( purchaseIds, fulfillmentCenterId7, map8_11_14_quantity_3_3_4 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of inventory
     * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
     */
    @Test
    public void testTwoFulfillmentCenters() {
        log.info( "testTwoFulfillmentCenters" );

        // given
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress6, productId10, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress6, productId11, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress6, productId12, 1 );
        // that basket needs two shipments (2 + 1 products) anyway, and there
        // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
        // closer. The smaller can then be served from 4 (closest), 7, or 8.
        UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
                // should cover map10_12_quantity_1_1
        UUID fulfillmentCenterId4 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 4 );
                // should cover map11_quantity_1

        // when
        Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userMailAddress6 );

        // then
        checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId5, fulfillmentCenterId4 );
        checkProductNumbers( purchaseIds, fulfillmentCenterId5, map10_12_quantity_1_1 );
        checkProductNumbers( purchaseIds, fulfillmentCenterId4, map11_quantity_1 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of inventory
     * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
     */
    @Test
    public void testTwoBigShipments() {
        log.info( "testTwoBigShipments" );

        // given
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress2, productId8, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress2, productId9, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress2, productId10, 4 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress2, productId11, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress2, productId12, 10 );
        // when
        Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userMailAddress2 );
        UUID fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );
                // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 products
        UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
                // should cover map12_quantity_10 - the only fulfillment center with enough capacity for 10 products

        // then
        checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId7, fulfillmentCenterId5 );
        checkProductNumbers( purchaseIds, fulfillmentCenterId7, map8_9_10_11_quantity_2_1_4_2 );
        checkProductNumbers( purchaseIds, fulfillmentCenterId5, map12_quantity_10 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of inventory
     * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
     */
    @Test
    public void testOnlyOneSolution() {
        log.info( "testOnlyOneSolution" );

        // given
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress6, productId12, 10 );
        // when
        Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userMailAddress6 );
        UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
        // should cover map12_quantity_10 - the only fulfillment center with enough capacity for 10 products

        // then
        checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId5 );
        checkProductNumbers( purchaseIds, fulfillmentCenterId5, map12_quantity_10 );
    }



    private void checkProductNumbers( Set<UUID> purchaseIds, UUID fulfillmentCenterId, Map<UUID, Integer> expectedMap ) {
        UUID fittingPurchaseId = null;
        for ( UUID purchaseId : purchaseIds ) {
            UUID foundFulfillmentCenterId = purchaseUseCases.getFulfillmentCenterIdForPurchase( purchaseId );
            if ( foundFulfillmentCenterId.equals( fulfillmentCenterId ) ) {
                fittingPurchaseId = purchaseId;
                break;
            }
        }
        assertNotNull( fittingPurchaseId, "No fitting purchase found for fulfillment center " + fulfillmentCenterId );

        int totalExpected = 0;
        int totalActual = 0;
        for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
            totalExpected += entry.getValue();
        }
        log.info( "Check purchase numbers for product {} in fulfillment center {}", fittingPurchaseId, fulfillmentCenterId );
        for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
            UUID productId = entry.getKey();
            Integer foundNumber =
                    purchaseUseCases.getPurchaseQuantityForProduct( fittingPurchaseId, productId );
            assertEquals( entry.getValue(), foundNumber );
            totalActual += foundNumber;
        }
        // last check - do the total sums match?
        assertEquals( totalExpected, totalActual );
    }


    private void checkFulfillmentCenterIds( Set<UUID> purchaseIds, UUID... expectedFulfillmentCenterIds ) {
        assertEquals( expectedFulfillmentCenterIds.length, purchaseIds.size() );
        Set<UUID> foundFulfillmentCenterIds = new HashSet<>();
        for ( UUID purchaseId : purchaseIds ) {
            UUID fulfillmentCenterId = purchaseUseCases.getFulfillmentCenterIdForPurchase( purchaseId );
            foundFulfillmentCenterIds.add( fulfillmentCenterId );
        }
        for ( UUID expectedFulfillmentCenterId : expectedFulfillmentCenterIds ) {
            assertTrue( foundFulfillmentCenterIds.contains( expectedFulfillmentCenterId ) );
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingbasket;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMailAddress;


@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class ShoppingBasketRESTTest {
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
    @Autowired
    private MockMvc mockMvc;
    @Autowired
    private ShoppingBasketRESTHelper shoppingBasketRESTHelper;

    private MailAddressType nonExistingMailAddress;
    private final Map<UUID, Integer> emptyMap = new HashMap<>();

    private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
    private MailAddressType
            userMailAddress0,
            userMailAddress3,
            userMailAddress6,
            userMailAddress8;
    private String userName0, userName8;
    private UUID productId0, productId1, productId2, productId3, productId5,
                 productId7, productId9, productId11, nonExistentProductId;
    private UUID fulfillmentCenterId0, fulfillmentCenterId3, fulfillmentCenterId7, fulfillmentCenterId8;


    private static final ResultMatcher NOT_FOUND = status().isNotFound();
    private static final ResultMatcher OK = status().isOk();
    private static final ResultMatcher CREATED = status().isCreated();
    private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
    private static final ResultMatcher CONFLICT = status().isConflict();

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        productTestHelper.addAllProducts();
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        nonExistingMailAddress = instantiateMailAddress( "harry@sally.de" );

        userMailAddress0 = userTestHelper.getUserMailAddress( 0 );
        userMailAddress3 = userTestHelper.getUserMailAddress( 3 );
        userMailAddress6 = userTestHelper.getUserMailAddress( 6 );
        userMailAddress8 = userTestHelper.getUserMailAddress( 8 );
        userName0 = userTestHelper.getUserName( 0 );
        userName8 = userTestHelper.getUserName( 8 );

        productId0 = productTestHelper.getProductId( 0 );
        productId1 = productTestHelper.getProductId( 1 );
        productId2 = productTestHelper.getProductId( 2 );
        productId3 = productTestHelper.getProductId( 3 );
        productId5 = productTestHelper.getProductId( 5 );
        productId7 = productTestHelper.getProductId( 7 );
        productId9 = productTestHelper.getProductId( 9 );
        productId11 = productTestHelper.getProductId( 11 );
        nonExistentProductId = UUID.randomUUID();

        fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        fulfillmentCenterId3 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 3 );
        fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );
        fulfillmentCenterId8 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 8 );

        map9_quantity_1 = new HashMap<>() {{
            put( productId9, 1 );
        }};
        map5_quantity_2 = new HashMap<>() {{
            put( productId5, 2 );
        }};
        map7_quantity_7 = new HashMap<>() {{
            put( productId7, 7 );
        }};
        map9_11_quantity_2_2 = new HashMap<>() {{
            put( productId9, 2 );
            put( productId11, 2 );
        }};
    }


    @Test
    public void testInvalidShoppingBasketBaseUris() throws Exception {
        // given
        String allShoppingBasketsUri = "/shoppingBaskets";
        String randomIdUri = "/shoppingBaskets/" + UUID.randomUUID();
        String randomUserUUID = "/shoppingBaskets?userId=" + UUID.randomUUID();
        String invalidUserUUID = "/shoppingBaskets?userId=invalidUUID";
        String randomParamUri = "/shoppingBaskets?randomParam=randomValue";

        // when
        // then
        mockMvc.perform( get( allShoppingBasketsUri ) ).andExpect( status().isMethodNotAllowed() );
        mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomUserUUID ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( invalidUserUUID ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
    }


    @Test
    public void testInvalidPositionUris() throws Exception {
        // given
        UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress8, emptyMap );
        String randomPositionUri = "/shoppingBaskets/" + shoppingBasketId8.toString() + "/random";
        String randomProductUri = "/shoppingBaskets/" + shoppingBasketId8.toString()
                + "/positions/" + UUID.randomUUID();

        // when
        // then
        mockMvc.perform( post( randomPositionUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( delete( randomProductUri ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testInvalidAddToShoppingBasket() throws Exception {
        // given
        Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
        expectedStartQuantityMap.put( productId2, 19 );

        // when
        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress0, emptyMap );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId, productId2, 6 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId, productId2, 13 );

        // then
        shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress0, expectedStartQuantityMap );

        // ... and check a couple of invalid cases
        shoppingBasketRESTHelper.addProductToShoppingBasket(
                shoppingBasketId, nonExistentProductId, 12, NOT_FOUND );
        shoppingBasketRESTHelper.addProductToShoppingBasket(
                UUID.randomUUID(), productId5, 12, NOT_FOUND );
        shoppingBasketRESTHelper.addProductToShoppingBasket(
                shoppingBasketId, productId5, -1, UNPROCESSABLE_ENTITY );

        // check if the shopping basket is still the same
        shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress0, expectedStartQuantityMap );
    }


    @Test
    public void testInvalidCheckout_unavailableProduct() throws Exception {
        // given
        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress0, emptyMap );

        // when
        // productId0 is not available in the requested quantity (or rather, not at all)
        shoppingBasketRESTHelper.addProductToShoppingBasket(
                shoppingBasketId, productId0, 1, CREATED );

        // check if the shopping basket is still the same
        shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
    }


    @Test
    public void testInvalidCheckout_tooLittleInventory() throws Exception {
        // given
        UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress0, emptyMap );

        // when
        // There are only 10 pieces of productId1 available
        shoppingBasketRESTHelper.addProductToShoppingBasket(
                shoppingBasketId, productId1, 11, CREATED );

        // check if the shopping basket is still the same
        shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
    }



    @Test
    public void testDeleteProductFromShoppingBasket() throws Exception {
        // given
        UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress6, emptyMap );
        Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
        expectedQuantityMap1.put( productId1, 1 );
        expectedQuantityMap1.put( productId2, 2 );
        expectedQuantityMap1.put( productId3, 3 );
        Map<UUID, Integer> quantityMap2 = new HashMap<>();
        quantityMap2.put( productId1, 1 );
        quantityMap2.put( productId3, 3 );

        // when
        // then
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId1, 1 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId2, 2 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId3, 3 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress6, expectedQuantityMap1 );

        shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId2 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress6, quantityMap2 );
    }


    @Test
    public void testNoDoubleDelete() throws Exception {
        // given
        UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress6, emptyMap );

        // when
        // then
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId3, 3 );
        shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId3 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress6, new HashMap<>() );
        shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId3, NOT_FOUND );
    }


    @Test
    public void testAddRemoveProductsFromAndToShoppingBasket() throws Exception {
        // given
        UUID shoppingBasketId3 = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress3, emptyMap );
        UUID shoppingBasketId5 = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress6, emptyMap );

        // when
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId1, 2 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId2, 3 );
        shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId3, productId1 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId1, 1 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId2, 6 );

        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId1, 2 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId2, 8 );
        shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId5, productId1 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId1, 1 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId2, 2 );

        // then
        // user3 has 1x productId1 and 9x productId2 expected in cart
        Map<UUID, Integer> expectedMap3 = new HashMap<>();
        expectedMap3.put( productId1, 1 );
        expectedMap3.put( productId2, 9 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress3, expectedMap3 );

        // user6 has 1x productId1 and 10x productId2 in cart
        Map<UUID, Integer> expectedMap5 = new HashMap<>();
        expectedMap5.put( productId1, 1 );
        expectedMap5.put( productId2, 10 );
        shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress6, expectedMap5 );
    }


    @Test
    public void testNoDoubleCheckout() throws Exception {
        // given
        UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress8, emptyMap );

        // when
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId2, 3 );

        // then
        shoppingBasketRESTHelper.checkout( shoppingBasketId8, userName8, CREATED, null );
        shoppingBasketRESTHelper.checkout( shoppingBasketId8, null, CONFLICT, null );
    }


    @Test
    public void testCheckout_1_Purchase() throws Exception {
        // given:
        // User 0 wants to buy 1x product 9. This is in fulfillment center 5, 7, and 8. Out of these,
        // fulfillment center 8 with postal code 89250 is closest to user 0 with postal code 02314.
        Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>() {{
            put( fulfillmentCenterId8, map9_quantity_1 );
        }};
        UUID shoppingBasketId0 = shoppingBasketRESTHelper.getQueryShoppingBasket(
                userMailAddress0, null );
        int inventory9before =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId8, productId9 );

        // when
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId0, productId9, 1 );
        shoppingBasketRESTHelper.checkout( shoppingBasketId0, userName0, CREATED, expectedPurchases );
        int inventory9after =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId8, productId9 );

        // then
        assertEquals( 1, inventory9before - inventory9after );
    }


    @Test
    public void testCheckout_3_Purchase() throws Exception {
        // given:
        // User 8 (Felix Bauer) wants to buy 2x each of products 5, 9, 11; and 7x product 7.
        //       - products 9 and 11 can both be found in fulfillment centers 7 and 8. Fulfillment centers 7 (76532) is closer to
        //         the user (70173)
        //       - product 7 is available in fulfillment centers 1, 2, and 3, but only fulfillment center 3 has enough inventory.
        //       - product 5 is only available in fulfillment center 0.
        Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>() {{
            put( fulfillmentCenterId0, map5_quantity_2 );
            put( fulfillmentCenterId3, map7_quantity_7 );
            put( fulfillmentCenterId7, map9_11_quantity_2_2 );
        }};
        UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket(
                userMailAddress8, null );
        int inventory5before =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId5 );
        int inventory7before =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId3, productId7 );
        int inventory9before =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId7, productId9 );
        int inventory11before =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId7, productId11 );

        // when
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId5, 2 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId7, 7 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId9, 2 );
        shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId11, 2 );
        shoppingBasketRESTHelper.checkout( shoppingBasketId8, userName8, CREATED, expectedPurchases );
        int inventory5after =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId5 );
        int inventory7after =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId3, productId7 );
        int inventory9after =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId7, productId9 );
        int inventory11after =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId7, productId11 );

        // then
        assertEquals( 2, inventory5before - inventory5after );
        assertEquals( 7, inventory7before - inventory7after );
        assertEquals( 2, inventory9before - inventory9after );
        assertEquals( 2, inventory11before - inventory11after );
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingbasket;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.InsufficientInventoryException;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;


import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;

@SpringBootTest
public class ShoppingBasketTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private ShoppingBasketUseCases shoppingBasketUseCases;
    @Autowired
    private ProductCatalogUseCases productCatalogUseCases;
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private PurchaseUseCases purchaseUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private ProductTestHelper productTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;

    private MailAddressType nonExistingMailAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();
        productTestHelper.addAllProducts();

        nonExistingMailAddress = instantiateMailAddress( "this@nononono.de" );
    }


    @Test
    public void testInvalidAddToShoppingBasket() {
        // given
        UUID nonExistentProductId = UUID.randomUUID();
        UUID productId5 = productTestHelper.getProductId( 5 );
        UUID productId0 = productTestHelper.getProductId( 0 );
        MailAddressType userMailAddress0 =
                userTestHelper.getUserMailAddress( 0 );
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );

        // then
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addProductToShoppingBasket(
                        nonExistingMailAddress, productId0, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addProductToShoppingBasket(
                        null, productId0, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addProductToShoppingBasket(
                        userMailAddress0, nonExistentProductId, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addProductToShoppingBasket(
                        userMailAddress0, null, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.addProductToShoppingBasket(
                        userMailAddress0, productId5, -1 ) );
    }


    @Test
    public void testInvalidRemoveFromShoppingBasket() {
        // given
        UUID nonExistentProductId = UUID.randomUUID();
        UUID productId5 = productTestHelper.getProductId( 5 );
        UUID productId1 = productTestHelper.getProductId( 1 );
        UUID productId2 = productTestHelper.getProductId( 2 );
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        MailAddressType userMailAddress0 =
                userTestHelper.getUserMailAddress( 0 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress0, productId1, 5 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress0, productId2, 15 );

        // when
        shoppingBasketUseCases.removeProductFromShoppingBasket(
                userMailAddress0, productId1, 2 );
        shoppingBasketUseCases.removeProductFromShoppingBasket(
                userMailAddress0, productId2, 4 );
        shoppingBasketUseCases.removeProductFromShoppingBasket(
                userMailAddress0, productId2, 7 );
        // now we should have 3x productId1 and 4x productId2 in the shopping basket

        // then
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
                        userMailAddress0, nonExistentProductId, 12 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
                        nonExistingMailAddress, productId5, 12 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
                        userMailAddress0, productId5, -1 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
                        userMailAddress0, productId1, 4 ) );
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
                        userMailAddress0, productId2, 5 ) );
    }


    @Test
    public void testAddRemoveProductsFromAndToShoppingBasket() {
        // given
        UUID productId1 = productTestHelper.getProductId( 1 );
        UUID productId2 = productTestHelper.getProductId( 2 );
        MailAddressType userMailAddress3 =
                userTestHelper.getUserMailAddress( 3 );
        MailAddressType userMailAddress5 =
                userTestHelper.getUserMailAddress( 5 );

        // when user 3 ...
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress3, productId1, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress3, productId2, 3 );
        shoppingBasketUseCases.removeProductFromShoppingBasket(
                userMailAddress3, productId1, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress3, productId1, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress3, productId2, 6 );
        Map<UUID, Integer> cart3 = shoppingBasketUseCases.getShoppingBasketAsMap( userMailAddress3 );
        // user3 has 1x productId1 and 9x productId2 in cart

        // ... and when user 5 ...
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress5, productId1, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress5, productId2, 8 );
        shoppingBasketUseCases.removeProductFromShoppingBasket(
                userMailAddress5, productId1, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress5, productId2, 2 );
        Map<UUID, Integer> cart5 = shoppingBasketUseCases.getShoppingBasketAsMap( userMailAddress5 );
        // user5 has 1x productId1 and 10x productId2 in cart

        // then
        assertEquals( 2, cart3.size() );
        assertEquals( 1, cart3.get( productId1 ) );
        assertEquals( 9, cart3.get( productId2 ) );

        assertEquals( 2, cart5.size() );
        assertEquals( 1, cart5.get( productId1 ) );
        assertEquals( 10, cart5.get( productId2 ) );
    }


    @Test
    public void testShoppingBasketValue() {
        // given
        UUID productId3 = productTestHelper.getProductId( 3 );
        UUID productId6 = productTestHelper.getProductId( 6 );
        UUID productId8 = productTestHelper.getProductId( 8 );
        CurrencyType price3 = productTestHelper.getSalesPrice( 3 );
        CurrencyType price6 = productTestHelper.getSalesPrice( 6 );
        CurrencyType price8 = productTestHelper.getSalesPrice( 8 );
        MailAddressType userMailAddress3 =
                userTestHelper.getUserMailAddress( 3 );

        // when
        shoppingBasketUseCases.addProductToShoppingBasket( userMailAddress3, productId3, 3 );
        shoppingBasketUseCases.addProductToShoppingBasket( userMailAddress3, productId6, 2 );
        shoppingBasketUseCases.addProductToShoppingBasket( userMailAddress3, productId8, 5 );
        // user3 has 3x productId3, 2x productId6 and 5x productId8 in cart
        CurrencyType cartValue = shoppingBasketUseCases.getShoppingBasketAsCurrencyValue( userMailAddress3 );

        // then
        assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
                cartValue );
    }


    @Test
    public void testShoppingBasketValueInvalid() {
        // given
        // when
        // then
        assertThrows( ShopException.class,
                () -> shoppingBasketUseCases.getShoppingBasketAsCurrencyValue( nonExistingMailAddress ) );
    }


    @Test
    public void testUnsuccessfulCheckout() {
        // given user buying product 0 (which is not in inventory), and user 1 buying product 1
        // in a bigger quantity (11) than available (10)
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        MailAddressType userMailAddress0 =
                userTestHelper.getUserMailAddress( 0 );
        MailAddressType userMailAddress1 =
                userTestHelper.getUserMailAddress( 1 );
        UUID productId0 = productTestHelper.getProductId( 0 );
        UUID productId1 = productTestHelper.getProductId( 1 );

        // when
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress0, productId0, 1 );
        shoppingBasketUseCases.addProductToShoppingBasket(
                userMailAddress1, productId1, 11 );

        // then
        assertThrows( InsufficientInventoryException.class,
                () -> shoppingBasketUseCases.checkout( userMailAddress0 ) );
        assertThrows( InsufficientInventoryException.class,
                () -> shoppingBasketUseCases.checkout( userMailAddress1 ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
package thkoeln.archilab.ecommerce.tests.testtests;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.domain.JavaMethod;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.web.bind.annotation.RestController;
import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingBasketRESTTest;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static org.springframework.test.util.AssertionErrors.assertTrue;

/**
 * This test checks if there are the appropriate tests in the test class(es) for domain
 * primitives.
 */

public class RulesForOwnTests {
    private JavaClass dpTestClass, restTestClass;
    private JavaClasses dpTestClasses, restTestClasses;
    private static final String FULFILLMENT_CENTER_DOMAIN_PACKAGE =
            "thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain";
    private static final String FULFILLMENT_CENTER_CLASS_NAME =
            FULFILLMENT_CENTER_DOMAIN_PACKAGE + ".FulfillmentCenter";


    @BeforeEach
    public void setUp() throws Exception {
        dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
        restTestClass = new ClassFileImporter().importClass( OwnShoppingBasketRESTTest.class );

        dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
        restTestClasses = new ClassFileImporter().importClasses( OwnShoppingBasketRESTTest.class );
    }


    @Test
    public void ensureMinimumNumberOfTestMethods() {
        // given
        // when
        int dpTestMethodCount = getTestMethodCount( dpTestClass );
        int restTestMethodCount = getTestMethodCount( restTestClass );

        // then
        assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
                        + dpTestMethodCount,dpTestMethodCount >= 2 );
        assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
                        + restTestMethodCount, restTestMethodCount >= 5 );
    }

    private int getTestMethodCount( JavaClass testClass ) {
        int testMethodCount = 0;
        for ( JavaMethod method : testClass.getMethods() ) {
            if ( isTestMethod( method ) ) {
                testMethodCount++;
            }
        }
        return testMethodCount;
    }

    private boolean isTestMethod( JavaMethod method ) {
        return method.isAnnotatedWith( Test.class );
    }


    @Test
    public void dpTestsShouldReferenceTheRightClasses() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAssignableTo( PostalCodeType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( CurrencyType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( PhysicalAddressType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( MailAddressType.class )
                .because( "DomainPrimitiveJSONSerializationTest should reference PostalCode, " +
                        "Currency, MailAddress, and PhysicalAddress!" );
        rule.check( dpTestClasses );
    }


    @Test
    public void restTestsShouldReferenceMailAddress() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAssignableTo( MailAddressType.class )
                .because( "FulfillmentCenterComparatorUnitTest should reference MailAddressType!" );
        rule.check( restTestClasses );
    }


    @Test
    public void restTestsShouldReferenceRESTControllers() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAnnotatedWith( RestController.class )
                .orShould().dependOnClassesThat()
                .areAssignableTo( ShoppingBasketRESTHelper.class )
                .because( "FulfillmentCenterComparatorUnitTest should call REST controllers! " +
                        "(either directly or via the ShoppingBasketRESTHelper REST helper)" );
        rule.check( restTestClasses );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\user\UserRegistrationTest.java ---
package thkoeln.archilab.ecommerce.tests.user;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;


@SpringBootTest
public class UserRegistrationTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;

    private MailAddressType nonExistingMailAddress;
    private PhysicalAddressType somePhysicalAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        nonExistingMailAddress = instantiateMailAddress( "this@nononono.de" );
        somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
                instantiatePostalCode( "90001" ) );
    }

    @Test
    public void testAllUsersRegistered() {
        // given
        userTestHelper.registerAllUsers();
        MailAddressType mailAddress3 =
                userTestHelper.getUserMailAddress( 3 );
        String name3 = userTestHelper.getUserName( 3 );
        PhysicalAddressType physicalAddress3 = userTestHelper.getUserPhysicalAddress( 3 );

        // when
        UserType user3 = userRegistrationUseCases.getUserData(
                mailAddress3 );

        // then
        Assertions.assertEquals( name3, user3.getName() );
        Assertions.assertEquals( mailAddress3, user3.getMailAddress() );
        Assertions.assertEquals( physicalAddress3, user3.getPhysicalAddress() );
    }


    @Test
    public void testRegisterUserWithDuplicateMailAddress() {
        // given
        userTestHelper.registerAllUsers();
        PhysicalAddressType physicalAddress5 = userTestHelper.getUserPhysicalAddress( 5 );
        MailAddressType mailAddress5 =
                userTestHelper.getUserMailAddress( 5 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.register( "Gandalf The Grey",
                        mailAddress5, physicalAddress5 ) );
    }


    @Test
    public void testRegisterUserWithDuplicateNameOrPhysicalAddress() {
        // given
        userTestHelper.registerAllUsers();
        MailAddressType newMailAddress =
                instantiateMailAddress( "some@this.de" );
        PhysicalAddressType physicalAddress2 = userTestHelper.getUserPhysicalAddress( 2 );
        String name2 = userTestHelper.getUserName( 2 );

        // when
        // then
        assertDoesNotThrow( () ->
                userRegistrationUseCases.register( name2, newMailAddress, physicalAddress2 ) );
    }


    @Test
    public void testRegisterUserWithInvalidData() {
        // given
        MailAddressType mailAddress5 =
                userTestHelper.getUserMailAddress( 5 );
        PhysicalAddressType physicalAddress5 = userTestHelper.getUserPhysicalAddress( 5 );
        String name5 = userTestHelper.getUserName( 5 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.register( null, mailAddress5, physicalAddress5 ) );
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.register("", mailAddress5, physicalAddress5 ) );
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.register( name5, null, physicalAddress5 ) );
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.register( name5, mailAddress5, null ) );
    }


    @Test
    public void testChangeAddressWithInvalidData() {
        // given
        userTestHelper.registerAllUsers();
        PhysicalAddressType physicalAddress7 = userTestHelper.getUserPhysicalAddress( 7 );
        MailAddressType mailAddress7 =
                userTestHelper.getUserMailAddress( 7 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.changeAddress( nonExistingMailAddress, physicalAddress7 ) );
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.changeAddress( null, physicalAddress7 ) );
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.changeAddress( mailAddress7, null ) );
    }


    @Test
    public void testGetDataForNonexistingMailAddress() {
        // given
        userTestHelper.registerAllUsers();

        // when
        // then
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.getUserData( nonExistingMailAddress ) );
    }


    @Test
    public void testDeleteUsersNoMoreUsers() {
        // given
        userTestHelper.registerAllUsers();
        MailAddressType mailAddress0 =
                userTestHelper.getUserMailAddress( 0 );


        // when
        userRegistrationUseCases.deleteAllUsers();

        // then
        assertThrows( ShopException.class, () -> userRegistrationUseCases.getUserData(
                mailAddress0 ) );
    }


    @Test
    public void testChangeAddressSuccessful() {
        // given
        userTestHelper.registerAllUsers();
        MailAddressType mailAddress6 =
                userTestHelper.getUserMailAddress( 6 );

        // when
        userRegistrationUseCases.changeAddress( mailAddress6, somePhysicalAddress );
        UserType newUser6 =
                userRegistrationUseCases.getUserData( mailAddress6 );

        // then
        Assertions.assertEquals( mailAddress6, newUser6.getMailAddress() );
        Assertions.assertEquals( somePhysicalAddress, newUser6.getPhysicalAddress() );
    }


    @Test
    public void testChangeAddressForNonexistingMailAddress() {
        // given
        userTestHelper.registerAllUsers();

        // when
        // then
        assertThrows( ShopException.class, () ->
                userRegistrationUseCases.changeAddress( nonExistingMailAddress, somePhysicalAddress ) );
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\user\UserRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.user;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.web.servlet.MockMvc;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.UserType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.*;

import java.util.UUID;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class UserRESTTest {
    @Autowired
    private UserRegistrationUseCases userRegistrationUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private UserTestHelper userTestHelper;
    @Autowired
    private MockMvc mockMvc;

    private UUID randomId;
    private MailAddressType nonExistingMailAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        userTestHelper.registerAllUsers();

        nonExistingMailAddress = FactoryMethodInvoker.instantiateMailAddress(
                "harry@sally.de" );
        randomId = UUID.randomUUID();
    }


    @Test
    public void testInvalidUserUris() throws Exception {
        // given
        String allUsersUri = "/users";
        String randomIdUri = "/users/" +  randomId;
        String nonExistingMailAddressUri = "/users?mailAddress=" + nonExistingMailAddress;
        String randomParamUri = "/users?randomParam=randomValue";

        // when
        // then
        mockMvc.perform( get( allUsersUri ) ).andExpect( status().isMethodNotAllowed() );
        mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( nonExistingMailAddressUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
    }


    @Test
    public void testRandomUserId() throws Exception {
        // given
        String invalidUri = "/users/" +  randomId;

        // when
        // then
        mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testQueryUser() throws Exception {
        // given
        MailAddressType mailAddress4 =
                userTestHelper.getUserMailAddress( 4 );
        String userUri4 = "/users?mailAddress=" + mailAddress4;

        // when
        UserType user4 = userRegistrationUseCases.getUserData( mailAddress4 );
        String name = userTestHelper.getUserName( 4 );
        PhysicalAddressType physicalAddress4 = userTestHelper.getUserPhysicalAddress( 4 );

        // then (check using JSONPath)
        mockMvc.perform( get( userUri4 ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.name" ).value( name ) )
                // id is position 0 (cannot be tested with current API structure), name is position 1,
                // mail address is 2, physical address is 3)
                .andExpect( jsonPath( "$..mailAddressString" ).value( mailAddress4.toString() ) )
                .andExpect( jsonPath( "$..city" ).value( physicalAddress4.getCity() ) )
                .andExpect( jsonPath( "$..postalCodeString" ).value(
                        physicalAddress4.getPostalCode().toString() ) );
    }

}


[RESPONSE]:
**Review-Zusammenfassung:**

**FILE: `C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenter.java`**  
- `FulfillmentCenter.java` Zeilen 119-126: **Duplikat** (Original in Zeilen 139-145): Die Methoden `getInventoryQuantity` und `getInventoryLevel` sind √§hnlich und k√∂nnten zusammengefasst werden.  
- `FulfillmentCenter.java`: **Anemic Entity** ‚Äì Die Klasse ist nicht an√§misch, da sie Gesch√§ftslogik enth√§lt.

**FILE: `C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterService.java`**  
- `FulfillmentCenterService.java` Zeile 46: **Negative Conditionals**: Die Bedingung `!salesPrice.largerThan(buyingPrice) && !salesPrice.getQuantity().equals(buyingPrice.getQuantity())` ist doppelt negiert und k√∂nnte zu `if (salesPrice.getQuantity() < buyingPrice.getQuantity())` vereinfacht werden.

**FILE: `C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductCatalogService.java`**  
- `ProductCatalogService.java` Zeile 46: **Negative Conditionals**: Gleiche doppelt negierte Bedingung wie in `FulfillmentCenterService.java`.

**FILE: `C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\PurchaseUsageChecker.java`**  
- `PurchaseUsageChecker.java`: **Dead Code**: Das Interface wird nirgendwo implementiert oder verwendet.

**FILE: `C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\adapter\MailAddressJpaAdapter.java`**  
- `MailAddressJpaAdapter.java`: **Dead Code**: Die Klasse wird nirgendwo verwendet.

**FILE: `C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\adapter\inventory\InventoryCheckerAdapter.java`**  
- `InventoryCheckerAdapter.java`: **Shared Persistency**: Die Klasse greift auf das `FulfillmentCenterRepository` eines anderen Aggregats (FulfillmentCenter) zu, was gegen die Regel der getrennten Persistenz in Aggregaten verst√∂√üt.

**FILE: `C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java`**  
- `ShoppingBasketController.java` Zeilen 68-81: **Misplaced Responsibility**: Die W√§hrungsformatierung (`formatCurrencyString`) geh√∂rt in die Domain-Primitive `Currency` und nicht in den Controller.

**ENDE**
Generated by deepseek-reasoner
-----------------------------------