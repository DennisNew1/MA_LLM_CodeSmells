--- DATE: 13.1.2026, 14:47:15 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
        Architektur: 4-Layer (Eric Evans).
        Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
        Regeln:
        1. Begründe kurz jeden Fund.
        4. Gruppiere nach Datei (mit Pfad). 
        2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
        3. Keine Code-Wiederholung, nur Referenzen.
        5. Wenn fertig, schreibe "ENDE". 
        6. Nutze die Zeilenangaben die mitgeschickt worden sind.



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\CustomerNotFoundException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Customer not found")
8: public class CustomerNotFoundException extends ShopException {
9:     public CustomerNotFoundException(String message) {
10:         super(message);
11:     }
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\EmptyNameException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY, reason = "Customer name empty")
8: public class EmptyNameException extends ShopException {
9:     public EmptyNameException(String message) {
10:         super(message);
11:     }
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\InsufficientMerchandiseInventoryException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.InsufficientInventoryException;
6: import thkoeln.archilab.ecommerce.ShopException;
7: 
8: @ResponseStatus(code = HttpStatus.CONFLICT, reason = "Insufficient inventory")
9: public class InsufficientMerchandiseInventoryException extends InsufficientInventoryException {
10:     public InsufficientMerchandiseInventoryException(String message) {
11:         super(message);
12:     }
13: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\InvalidMailAddressException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY, reason = "Invalid mail address")
8: public class InvalidMailAddressException extends ShopException {
9:     public InvalidMailAddressException(String message) {
10:         super(message);
11:     }
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\InvalidPhysicalAddressException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY, reason = "Invalid physical address")
8: public class InvalidPhysicalAddressException extends ShopException {
9:     public InvalidPhysicalAddressException(String message) {
10:         super(message);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\MailAddressInUseException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.CONFLICT, reason = "Mail address already in use")
8: public class MailAddressInUseException extends ShopException {
9:     public MailAddressInUseException(String message) {
10:         super(message);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\MerchandiseNotFoundException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Merchandise not found")
8: public class MerchandiseNotFoundException extends ShopException {
9:     public MerchandiseNotFoundException(String message) {
10:         super(message);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\NegativeQuantityException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY, reason = "Negative quantity")
8: public class NegativeQuantityException extends ShopException {
9:     public NegativeQuantityException(String message) {
10:         super(message);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\PurchaseNotFoundException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Purchase not found")
8: public class PurchaseNotFoundException extends ShopException {
9:     public PurchaseNotFoundException(String message) {
10:         super(message);
11:     }
12: }
13: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\ShoppingCartNotFoundException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives.exceptions;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: import thkoeln.archilab.ecommerce.ShopException;
6: 
7: @ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Shopping cart not found")
8: public class ShoppingCartNotFoundException extends ShopException {
9:     public ShoppingCartNotFoundException(String message) {
10:         super(message);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\MailAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonValue;
4: import jakarta.persistence.Embeddable;
5: import lombok.EqualsAndHashCode;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
10: 
11: @Embeddable
12: @Getter
13: @EqualsAndHashCode
14: @NoArgsConstructor(access = lombok.AccessLevel.PROTECTED, force = true)
15: public class MailAddress implements MailAddressType {
16:     private final String mailAddressString;
17:     private final String identifier;
18:     private final String domain;
19: 
20:     private MailAddress(String identifier, String domain) {
21:         if(identifier == null || identifier.isEmpty() || identifier.contains(" ") || identifier.matches(".*\\.{2,}.*")
22:                 || !identifier.matches("^[a-zA-Z0-9._-]+$")){
23:             throw new ShopException("Invalid mail address identifier");
24:         }
25: 
26:         if(domain == null || domain.isEmpty() || domain.contains(" ") || domain.matches(".*\\.{2,}.*")
27:                 || !domain.matches(".*\\.(de|at|ch|com|org)")){
28:             throw new ShopException("Invalid mail address domain");
29:         }
30: 
31:         this.identifier = identifier;
32:         this.domain = domain;
33:         this.mailAddressString = identifier + "@" + domain;
34:     }
35: 
36:     public static MailAddress of( String mailAddressAsString ){
37:         if(mailAddressAsString == null || mailAddressAsString.isEmpty()){
38:             throw new ShopException("Mail address is null or empty");
39:         }
40: 
41:         if(!mailAddressAsString.contains("@")){
42:             throw new ShopException("Mail address is not a valid email address");
43:         }
44: 
45:         String[] mailAddressParts = mailAddressAsString.split("@");
46: 
47:         if(mailAddressParts.length != 2){
48:             throw new ShopException("Mail address is not a valid email address");
49:         }
50: 
51:         return new MailAddress(mailAddressParts[0], mailAddressParts[1]);
52:     }
53: 
54:     @Override
55:     public MailAddress sameIdentifyerDifferentDomain(String domainString) {
56:        return new MailAddress(identifier, domainString);
57:     }
58: 
59:     @Override
60:     public MailAddress sameDomainDifferentIdentifyer(String identifyerString) {
61:         return new MailAddress(identifyerString, domain);
62:     }
63: 
64:     @Override
65:     public String toString(){
66:         return identifier + "@" + domain;
67:     }
68: }
69: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.EqualsAndHashCode;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: 
10: @Embeddable
11: @Getter
12: @EqualsAndHashCode
13: @NoArgsConstructor(access = lombok.AccessLevel.PROTECTED, force = true)
14: public class Money implements MoneyType {
15:     private final Float amount;
16:     private final String currency;
17: 
18:     private Money(final Float amount, final String currency) {
19:         if(amount == null || amount < 0f){
20:             throw new ShopException("Amount must be greater than zero");
21:         }
22: 
23:         if(currency == null || currency.isEmpty() || !currency.matches("EUR|CHF")){
24:             throw new ShopException("Currency must be either EUR or CHF");
25:         }
26: 
27:         this.amount = amount;
28:         this.currency = currency;
29:     }
30: 
31:     public static Money of( Float amount, String currencyUnit ){
32:         return new Money( amount, currencyUnit );
33:     }
34: 
35:     @Override
36:     public Float getAmount() {
37:         return amount;
38:     }
39: 
40:     @Override
41:     public String getCurrencyUnit() {
42:         return currency;
43:     }
44: 
45:     @Override
46:     public Money add(MoneyType otherMoney) {
47:         if(otherMoney == null){
48:             throw new ShopException("Cannot add null to MoneyType");
49:         }
50: 
51:         if(!otherMoney.getCurrencyUnit().equals(currency)){
52:             throw new ShopException("Currency does not match");
53:         }
54:         return new Money(amount + otherMoney.getAmount(), currency);
55:     }
56: 
57:     @Override
58:     public Money subtract(MoneyType otherMoney) {
59:         if(otherMoney == null){
60:             throw new ShopException("Cannot add null to MoneyType");
61:         }
62: 
63:         if(!otherMoney.getCurrencyUnit().equals(currency)){
64:             throw new ShopException("Currency does not match");
65:         }
66: 
67:         if(amount < otherMoney.getAmount()){
68:             throw new ShopException("Cannot subtract from amount less than currency amount");
69:         }
70: 
71:         return new Money(amount - otherMoney.getAmount(), currency);
72:     }
73: 
74:     @Override
75:     public Money multiplyBy(int factor) {
76:         if(factor < 0){
77:             throw new ShopException("Factor must be greater than zero");
78:         }
79:         return new Money(amount * factor, currency);
80:     }
81: 
82:     @Override
83:     public boolean largerThan(MoneyType otherMoney) {
84:         if(otherMoney == null){
85:             throw new ShopException("Cannot add null to MoneyType");
86:         }
87: 
88:         if(!otherMoney.getCurrencyUnit().equals(currency)){
89:             throw new ShopException("Currency does not match");
90:         }
91: 
92:         return amount > otherMoney.getAmount();
93:     }
94: 
95:     @Override
96:     public String toString(){
97:         return String.format("%.2f %s", amount, switch (currency) {
98:             case "EUR": yield "€";
99:             case "CHF": yield "CHF";
100:             default:
101:                 throw new ShopException("Currency not supported");
102:         });
103:     }
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PhysicalAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Embeddable;
4: import jakarta.persistence.Embedded;
5: import lombok.EqualsAndHashCode;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
11: 
12: @Embeddable
13: @Getter
14: @EqualsAndHashCode
15: @NoArgsConstructor(access = lombok.AccessLevel.PROTECTED, force = true)
16: public class PhysicalAddress implements PhysicalAddressType {
17:     private final String street;
18:     private final String city;
19:     @Embedded
20:     private final ZipCode zipCode;
21: 
22:     private PhysicalAddress(String street, String city, ZipCode zipCode){
23:         if(street == null || street.isEmpty()){
24:             throw new ShopException("Street is null or empty");
25:         }
26: 
27:         if(city == null || city.isEmpty()){
28:             throw new ShopException("City is null or empty");
29:         }
30: 
31:         if(zipCode == null){
32:             throw new ShopException("ZipCode is null");
33:         }
34: 
35:         this.street = street;
36:         this.city = city;
37:         this.zipCode = zipCode;
38:     }
39: 
40:     public static PhysicalAddress of( String street, String city, ZipCodeType zipCode){
41:         return new PhysicalAddress(street, city, (ZipCode) zipCode);
42:     }
43: 
44:     @Override
45:     public String getStreet() {
46:         return street;
47:     }
48: 
49:     @Override
50:     public String getCity() {
51:         return city;
52:     }
53: 
54:     @Override
55:     public ZipCode getZipCode() {
56:         return zipCode;
57:     }
58: }
59: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import jakarta.persistence.Embeddable;
5: import lombok.EqualsAndHashCode;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
10: 
11: @Embeddable
12: @Getter
13: @EqualsAndHashCode
14: @NoArgsConstructor(access = lombok.AccessLevel.PROTECTED, force = true)
15: public class ZipCode implements ZipCodeType {
16:     @JsonProperty("zipCodeString")
17:     private final String zipCode;
18: 
19:     public ZipCode(String zipCode) {
20:         if(zipCode == null
21:                 || !zipCode.matches("\\d{5}")
22:                 || zipCode.matches(".*0000")){
23:             throw new ShopException("Zip code is not a valid zip code");
24:         }
25:         this.zipCode = zipCode;
26:     }
27: 
28:     public static ZipCode of( String zipCodeAsString ){
29:        return new ZipCode(zipCodeAsString);
30:     }
31: 
32:     @Override
33:     public int difference(ZipCodeType otherZipCode) {
34:         if(otherZipCode == null){
35:             throw new ShopException("Zip code is null");
36:         }
37: 
38:         if(zipCode.equals(otherZipCode.toString())){
39:             return 0;
40:         }
41: 
42:         int difference = 0;
43: 
44:         for(int i = 1; i < zipCode.length(); i++){
45:             if(zipCode.charAt(i) != otherZipCode.toString().charAt(i)){
46:                 difference = zipCode.length() - i;
47:                 break;
48:             }
49:         }
50: 
51:         int firstDigitDiff = Math.abs(zipCode.charAt(0) - otherZipCode.toString().charAt(0));
52: 
53:         if(firstDigitDiff > 5){
54:             firstDigitDiff = 10 - firstDigitDiff;
55:         }
56: 
57:         return difference + firstDigitDiff;
58:     }
59: 
60:     @Override
61:     public Integer getFirstDigitZipCode() {
62:         return Integer.parseInt(zipCode.substring(0, 1));
63:     }
64: 
65:     @Override
66:     public String toString(){
67:         return zipCode;
68:     }
69: }
70: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.Column;
7: import jakarta.persistence.MappedSuperclass;
8: import lombok.EqualsAndHashCode;
9: import lombok.Getter;
10: import lombok.ToString;
11: 
12: import java.io.Serializable;
13: import java.util.UUID;
14: 
15: @MappedSuperclass
16: @Getter
17: @EqualsAndHashCode(of = "id")
18: @ToString(of = "id")
19: public abstract class GenericId implements Serializable {
20:     @Column(nullable = false, updatable = false)
21:     private final UUID id;
22: 
23:     protected GenericId() {
24:         this( UUID.randomUUID() );
25:     }
26: 
27:     protected GenericId( UUID id ) {
28:         this.id = id;
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.AttributeConverter;
7: 
8: import java.util.UUID;
9: import java.util.function.Function;
10: 
11: 
12: public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
13:     private final Function<UUID, T> factory;
14: 
15:     protected GenericIdConverter( Function<UUID, T> factory ) {
16:         this.factory = factory;
17:     }
18: 
19:     @Override
20:     public UUID convertToDatabaseColumn( T attribute ) {
21:         return attribute == null ? null : attribute.getId();
22:     }
23: 
24:     @Override
25:     public T convertToEntityAttribute( UUID dbData ) {
26:         return dbData == null ? null : factory.apply( dbData );
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\InsufficientInventoryException.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: /**
7:  * Exception is thrown if the merchandise's inventory level is not sufficient to serve the purchase.
8:  */
9: public class InsufficientInventoryException extends ShopException {
10:     public InsufficientInventoryException( String message ) {
11:         super( message );
12:     }
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import org.springframework.boot.SpringApplication;
7: import org.springframework.boot.autoconfigure.SpringBootApplication;
8: 
9: 
10: @SpringBootApplication
11: public class ProjectApplication {
12: 
13: 	/**
14: 	 * Entry method
15: 	 * @param args
16: 	 */
17: 	public static void main(String[] args) {
18: 		SpringApplication.run(ProjectApplication.class, args);
19: 	}
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: public class ShopException extends RuntimeException {
7:     public ShopException( String message ) {
8:         super( message );
9:     }
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
7: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
8: import thkoeln.archilab.ecommerce.usecases.CustomerType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
11: 
12: @Service
13: public
14: class CustomerAdapterService implements CustomerRegistrationUseCases {
15:     private final CustomerRegistrationService customerRegistrationService;
16: 
17:     @Autowired
18:     public CustomerAdapterService(CustomerRegistrationService customerRegistrationService) {
19:         this.customerRegistrationService = customerRegistrationService;
20:     }
21: 
22:     @Override
23:     public void register(String name, MailAddressType mailAddress, PhysicalAddressType physicalAddress) {
24:         this.customerRegistrationService.register(
25:                 name,
26:                 (MailAddress) mailAddress,
27:                 (PhysicalAddress) physicalAddress);
28:     }
29: 
30:     @Override
31:     public void changeAddress(MailAddressType customerMailAddress, PhysicalAddressType physicalAddress) {
32:         this.customerRegistrationService.changeAddress(
33:                 (MailAddress) customerMailAddress,
34:                 (PhysicalAddress) physicalAddress);
35:     }
36: 
37:     @Override
38:     public CustomerType getCustomerData(MailAddressType customerMailAddress) {
39:         return this.customerRegistrationService.getCustomerData(
40:                 (MailAddress) customerMailAddress);
41:     }
42: 
43:     @Override
44:     public void deleteAllCustomers() {
45:         this.customerRegistrationService.deleteAllCustomers();
46:     }
47: }
48: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerController.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.application;
2: 
3: import org.modelmapper.ModelMapper;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.http.HttpStatus;
6: import org.springframework.http.ResponseEntity;
7: import org.springframework.web.bind.annotation.GetMapping;
8: import org.springframework.web.bind.annotation.RequestMapping;
9: import org.springframework.web.bind.annotation.RequestParam;
10: import org.springframework.web.bind.annotation.RestController;
11: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
12: import thkoeln.archilab.ecommerce.usecases.CustomerType;
13: 
14: @RestController
15: @RequestMapping("/customers")
16: public class CustomerController {
17:     private final CustomerRegistrationService customerRegistrationService;
18:     private static final ModelMapper MODEL_MAPPER = new ModelMapper();
19: 
20:     @Autowired
21:     public CustomerController(CustomerRegistrationService customerRegistrationService) {
22:         this.customerRegistrationService = customerRegistrationService;
23:     }
24: 
25:     @GetMapping(params = "mailAddress")
26:     public ResponseEntity<CustomerDTO> getOneCustomerByMailAddress(
27:             @RequestParam("mailAddress") String mailAddress) {
28:         CustomerType customer = customerRegistrationService.getCustomerData(MailAddress.of(mailAddress));
29:         CustomerDTO customerDTO = MODEL_MAPPER.map(customer, CustomerDTO.class);
30: 
31:         return new ResponseEntity<>( customerDTO, HttpStatus.OK);
32:     }
33: 
34:     @GetMapping
35:     public ResponseEntity<CustomerDTO> getAllCustomers() {
36:         return new ResponseEntity<>(HttpStatus.METHOD_NOT_ALLOWED);
37:     }
38: }
39: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.application;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
8: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
9: 
10: import java.util.UUID;
11: 
12: @AllArgsConstructor
13: @NoArgsConstructor
14: @Setter
15: @Getter
16: public class CustomerDTO {
17:     private UUID id;
18:     private MailAddress mailAddress;
19:     private String name;
20:     private PhysicalAddress physicalAddress;
21: }
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerRegistrationService.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
7: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.*;
8: import thkoeln.archilab.ecommerce.solution.customer.domain.*;
9: 
10: @Service
11: public class CustomerRegistrationService{
12:     private final CustomerRepository customerRepository;
13: 
14:     @Autowired
15:     public CustomerRegistrationService(CustomerRepository customerRepository) {
16:         this.customerRepository = customerRepository;
17:     }
18: 
19:     public void register(String name, MailAddress mailAddress, PhysicalAddress physicalAddress) {
20:         if (name == null || name.isBlank()) {
21:             throw new EmptyNameException("Customer name can not be null or empty");
22:         }
23:         if (mailAddress == null ) {
24:             throw new InvalidMailAddressException("Customer mail address can not be null");
25:         }
26: 
27:         if(physicalAddress == null){
28:             throw new InvalidPhysicalAddressException("Customer physical address can not be null");
29:         }
30: 
31:         if (this.customerRepository.findByMailAddress(mailAddress).isPresent()) {
32:             throw new MailAddressInUseException("mailAddress already in use");
33:         }
34: 
35:         this.customerRepository.save(new Customer(mailAddress, name, physicalAddress));
36:     }
37: 
38:     public void changeAddress(MailAddress customerMailAddress, PhysicalAddress physicalAddress) {
39:         if (customerMailAddress == null) {
40:             throw new InvalidMailAddressException("Customer mail address can not be null or empty");
41:         }
42: 
43:         if (physicalAddress == null) {
44:             throw new InvalidPhysicalAddressException("Customer physical address can not be null or empty");
45:         }
46: 
47:         Customer customer = this.customerRepository.findByMailAddress(customerMailAddress)
48:                 .orElseThrow(() -> new CustomerNotFoundException("customer not found"));
49: 
50:         customer.setPhysicalAddress(physicalAddress);
51:         customerRepository.save(customer);
52:     }
53: 
54:     public Customer getCustomerData(CustomerId customerId) {
55:         return this.customerRepository.findById(customerId)
56:                 .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));
57:     }
58: 
59:     public Customer getCustomerData(MailAddress customerMailAddress) {
60:         if (customerMailAddress == null) {
61:             throw new InvalidMailAddressException("Customer mail address can not be null or empty");
62:         }
63: 
64:         return this.customerRepository.findByMailAddress(customerMailAddress)
65:                 .orElseThrow(() -> new CustomerNotFoundException("customer not found"));
66:     }
67: 
68:     public void deleteAllCustomers() {
69:         this.customerRepository.deleteAll();
70:     }
71: }
72: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\Customer.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.domain;
2: 
3: import jakarta.persistence.Column;
4: import jakarta.persistence.Embedded;
5: import jakarta.persistence.EmbeddedId;
6: import jakarta.persistence.Entity;
7: import lombok.*;
8: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
9: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
10: import thkoeln.archilab.ecommerce.usecases.CustomerType;
11: 
12: import java.util.UUID;
13: 
14: @Entity
15: @Data
16: @NoArgsConstructor
17: @AllArgsConstructor
18: public class Customer implements CustomerType {
19:     @Setter(AccessLevel.PRIVATE)
20:     @EmbeddedId
21:     private CustomerId id;
22: 
23:     @Column(unique = true)
24:     @Embedded
25:     private MailAddress mailAddress;
26:     private String name;
27:     @Embedded
28:     private PhysicalAddress physicalAddress;
29: 
30:     public Customer(MailAddress mailAddress, String name, PhysicalAddress physicalAddress) {
31:         this.id = new CustomerId(UUID.randomUUID());
32:         this.mailAddress = mailAddress;
33:         this.name = name;
34:         this.physicalAddress = physicalAddress;
35:     }
36: }
37: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\CustomerId.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "customer_id"))
15: public class CustomerId extends GenericId {
16:     public CustomerId(UUID uuid) {
17:         super(uuid);
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\CustomerIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class CustomerIdConverter extends GenericIdConverter<CustomerId> {
8:     public CustomerIdConverter() {
9:         super(CustomerId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\CustomerRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.customer.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
6: 
7: import java.util.Optional;
8: 
9: public interface CustomerRepository extends CrudRepository<Customer, CustomerId> {
10:     // find by
11:     Optional<Customer> findByMailAddress(MailAddressType mailAddress);
12: 
13:     Iterable<Customer> findByName(String name);
14: 
15:     Iterable<Customer> findByPhysicalAddress(PhysicalAddressType physicalAddress);
16: 
17:     // existsBy
18:     boolean existsByName(String name);
19: 
20:     boolean existsByMailAddress(MailAddressType mailAddress);
21: 
22:     boolean existsByPhysicalAddress(PhysicalAddressType physicalAddress);
23: }
24: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
6: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterId;
7: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
8: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: 
11: import java.util.UUID;
12: 
13: @Service
14: public class FulfillmentCenterAdapterService implements FulfillmentCenterUseCases {
15:     private final FulfillmentCenterService fulfillmentCenterService;
16: 
17:     @Autowired
18:     public FulfillmentCenterAdapterService(FulfillmentCenterService fulfillmentCenterService) {
19:         this.fulfillmentCenterService = fulfillmentCenterService;
20:     }
21: 
22:     @Override
23:     public UUID addNewFulfillmentCenter(String name, PhysicalAddressType physicalAddress) {
24:         return fulfillmentCenterService.addNewFulfillmentCenter(name, (PhysicalAddress) physicalAddress).getId();
25:     }
26: 
27:     @Override
28:     public void deleteAllFulfillmentCenters() {
29:         this.fulfillmentCenterService.deleteAllFulfillmentCenters();
30:     }
31: 
32:     @Override
33:     public void addToInventory(UUID fulfillmentCenterId, UUID merchandiseId, int addedQuantiOf) {
34:         this.fulfillmentCenterService.addToInventory(
35:                 new FulfillmentCenterId(fulfillmentCenterId),
36:                 new MerchandiseId(merchandiseId),
37:                 addedQuantiOf);
38:     }
39: 
40:     @Override
41:     public void removeFromInventory(UUID fulfillmentCenterId, UUID merchandiseId, int removedQuantiOf) {
42:         this.fulfillmentCenterService.removeFromInventory(
43:                 new FulfillmentCenterId(fulfillmentCenterId),
44:                 new MerchandiseId(merchandiseId),
45:                 removedQuantiOf
46:         );
47:     }
48: 
49:     @Override
50:     public void changeInventoryTo(UUID fulfillmentCenterId, UUID merchandiseId, int newTotalQuantiOf) {
51:         this.fulfillmentCenterService.changeInventoryTo(
52:                 new FulfillmentCenterId(fulfillmentCenterId),
53:                 new MerchandiseId(merchandiseId),
54:                 newTotalQuantiOf
55:         );
56:     }
57: 
58:     @Override
59:     public int getAvailableInventory(UUID fulfillmentCenterId, UUID merchandiseId) {
60:         return this.fulfillmentCenterService.getAvailableInventory(
61:                 new FulfillmentCenterId(fulfillmentCenterId),
62:                 new MerchandiseId(merchandiseId)
63:         );
64:     }
65: }
66: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterService.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
7: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenter;
8: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterId;
9: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterRepository;
10: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
11: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseRepository;
12: 
13: @Service
14: public class FulfillmentCenterService {
15:     private final FulfillmentCenterRepository fulfillmentCenterRepository;
16:     private final MerchandiseRepository merchandiseRepository;
17: 
18:     @Autowired
19:     public FulfillmentCenterService(
20:             FulfillmentCenterRepository fulfillmentCenterRepository,
21:             MerchandiseRepository merchandiseRepository) {
22:         this.fulfillmentCenterRepository = fulfillmentCenterRepository;
23:         this.merchandiseRepository = merchandiseRepository;
24:     }
25: 
26:     public FulfillmentCenterId addNewFulfillmentCenter(
27:             String name,
28:             PhysicalAddress physicalAddress) {
29:         if (name == null || name.isEmpty())
30:             throw new ShopException("FulfillmentCenter name can not be null or empty");
31:         if (physicalAddress == null)
32:             throw new ShopException("FulfillmentCenter physicalAddress can not be null or empty");
33: 
34:         return this.fulfillmentCenterRepository.save(
35:                 new FulfillmentCenter(name,physicalAddress)).getId();
36:     }
37: 
38:     public void deleteAllFulfillmentCenters() {
39:         this.fulfillmentCenterRepository.deleteAll();
40:     }
41: 
42:     public void addToInventory(FulfillmentCenterId fulfillmentCenterId, MerchandiseId merchandiseId, int addedQuantiOf) {
43:         FulfillmentCenter fulfillmentCenter = this.fulfillmentCenterRepository.findById(fulfillmentCenterId)
44:                 .orElseThrow(() -> new ShopException("FulfillmentCenter not found"));
45: 
46:         if(addedQuantiOf < 0) throw new ShopException("Quantity must be greater than zero");
47: 
48:         if(!this.merchandiseRepository.existsById(merchandiseId))
49:                 throw new ShopException("Merchandise not found");
50: 
51:         fulfillmentCenter.addToInventory(merchandiseId, addedQuantiOf);
52:         this.fulfillmentCenterRepository.save(fulfillmentCenter);
53:     }
54: 
55:     public void removeFromInventory(FulfillmentCenterId fulfillmentCenterId, MerchandiseId merchandiseId, int removedQuantiOf) {
56:         FulfillmentCenter fulfillmentCenter = this.fulfillmentCenterRepository.findById(fulfillmentCenterId)
57:                 .orElseThrow(() -> new ShopException("FulfillmentCenter not found"));
58: 
59:         if(removedQuantiOf < 0) throw new ShopException("Quantity must be greater than zero");
60: 
61:         if(!this.merchandiseRepository.existsById(merchandiseId))
62:             throw new ShopException("Merchandise not found");
63: 
64:         fulfillmentCenter.removeFromInventory(merchandiseId, removedQuantiOf);
65:         this.fulfillmentCenterRepository.save(fulfillmentCenter);
66:     }
67: 
68:     public void changeInventoryTo(FulfillmentCenterId fulfillmentCenterId, MerchandiseId merchandiseId, int newTotalQuantiOf) {
69:         FulfillmentCenter fulfillmentCenter = this.fulfillmentCenterRepository.findById(fulfillmentCenterId)
70:                 .orElseThrow(() -> new ShopException("FulfillmentCenter not found"));
71: 
72:         if(newTotalQuantiOf < 0) throw new ShopException("Quantity must be greater than zero");
73: 
74:         if(!this.merchandiseRepository.existsById(merchandiseId))
75:             throw new ShopException("Merchandise not found");
76: 
77:         fulfillmentCenter.setInventoryQuantity(merchandiseId, newTotalQuantiOf);
78:         this.fulfillmentCenterRepository.save(fulfillmentCenter);
79:     }
80: 
81:     public int getAvailableInventory(FulfillmentCenterId fulfillmentCenterId, MerchandiseId merchandiseId) {
82:         FulfillmentCenter fulfillmentCenter = this.fulfillmentCenterRepository.findById(fulfillmentCenterId)
83:                 .orElseThrow(() -> new ShopException("FulfillmentCenter not found"));
84: 
85:         if(!this.merchandiseRepository.existsById(merchandiseId))
86:             throw new ShopException("Merchandise not found");
87: 
88:         return fulfillmentCenter.getInventoryLevel(merchandiseId);
89:     }
90: }
91: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\StorableService.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenter;
6: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterRepository;
7: import thkoeln.archilab.ecommerce.solution.merchandise.application.StorableServiceInterface;
8: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
9: 
10: @Service
11: public class StorableService implements StorableServiceInterface {
12:     private final FulfillmentCenterRepository fulfillmentCenterRepository;
13: 
14:     @Autowired
15:     public StorableService(FulfillmentCenterRepository fulfillmentCenterRepository) {
16:         this.fulfillmentCenterRepository = fulfillmentCenterRepository;
17:     }
18: 
19:     @Override
20:     public boolean isMerchandiseInStock(MerchandiseId merchandiseId) {
21:         for(FulfillmentCenter fulfillmentCenter : this.fulfillmentCenterRepository.findAll())
22:             if(fulfillmentCenter.getInventoryLevel(merchandiseId) != 0)
23:                 return true;
24:         return false;
25:     }
26: }
27: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenter.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.*;
5: import thkoeln.archilab.ecommerce.InsufficientInventoryException;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
8: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
9: 
10: import java.util.*;
11: 
12: @Entity
13: @Data
14: @NoArgsConstructor
15: @AllArgsConstructor
16: public class FulfillmentCenter {
17:     @Setter(AccessLevel.PRIVATE)
18:     @EmbeddedId
19:     private FulfillmentCenterId id;
20: 
21:     private String name;
22:     @Embedded
23:     private PhysicalAddress physicalAddress;
24: 
25:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
26:     private List<InventoryLevel> inventoryLevelList;
27: 
28:     public FulfillmentCenter(
29:             String name,
30:             PhysicalAddress physicalAddress) {
31: 
32:         this.id = new FulfillmentCenterId(UUID.randomUUID());
33:         this.name = name;
34:         this.physicalAddress = physicalAddress;
35:         this.inventoryLevelList = new ArrayList<>();
36:     }
37: 
38:     public Set<MerchandiseId> fulfillableShoppingCartParts(Map<MerchandiseId, Integer> merchandiseQuantityMap ){
39:         Set<MerchandiseId> fulfillable = new HashSet<>();
40: 
41:         for(InventoryLevel inventoryLevel : inventoryLevelList){
42:             MerchandiseId merchandiseId = inventoryLevel.getMerchandiseId();
43: 
44:             if(merchandiseQuantityMap.containsKey(merchandiseId)
45:                 && inventoryLevel.getQuantity() >= merchandiseQuantityMap.get(merchandiseId)){
46:                 fulfillable.add(merchandiseId);
47:             }
48:         }
49:         return fulfillable;
50:     }
51: 
52:     public void setInventoryQuantity(MerchandiseId merchandiseId, int quantity) {
53:         if(quantity < 0) throw new ShopException("Quantity must be greater than zero");
54: 
55:         inventoryLevelList.stream()
56:                 .filter(inventoryLevel -> inventoryLevel.getMerchandiseId().equals(merchandiseId))
57:                 .findFirst()
58:                 .ifPresentOrElse(
59:                         inventoryLevel -> inventoryLevel.setQuantity(quantity),
60:                         () -> inventoryLevelList.add(new InventoryLevel(merchandiseId, quantity))
61:                 );
62:     }
63: 
64:     public void addToInventory(Map<MerchandiseId, Integer> merchandiseQuantityMap) {
65:         for(MerchandiseId merchandiseId : merchandiseQuantityMap.keySet()){
66:             addToInventory(merchandiseId, merchandiseQuantityMap.get(merchandiseId));
67:         }
68:     }
69: 
70:     public void addToInventory(MerchandiseId merchandiseId, int quantity) {
71:         if(quantity == 0) return;
72:         else if(quantity < 0) throw new ShopException("Quantity must be greater than zero");
73: 
74:         inventoryLevelList.stream()
75:                 .filter(inventoryLevel -> inventoryLevel.getMerchandiseId().equals(merchandiseId))
76:                 .findFirst()
77:                 .ifPresentOrElse(
78:                         inventoryLevel -> inventoryLevel.setQuantity(
79:                                 inventoryLevel.getQuantity() + quantity),
80:                         () -> inventoryLevelList.add(
81:                                 new InventoryLevel(merchandiseId, quantity))
82:                 );
83:     }
84: 
85:     public void removeFromInventory(MerchandiseId merchandiseId, int quantity) {
86:         if(quantity == 0) return;
87:         else if(quantity < 0) throw new ShopException("Quantity must be greater than zero");
88: 
89:         Optional<InventoryLevel> optionalIL = inventoryLevelList.stream()
90:                 .filter(inventoryLevel -> inventoryLevel.getMerchandiseId().equals(merchandiseId))
91:                 .findFirst();
92: 
93:         if(optionalIL.isPresent()){
94:             InventoryLevel inventoryLevel = optionalIL.get();
95:             int newQuantity = inventoryLevel.getQuantity() - quantity;
96:             if (newQuantity < 0)
97:                 throw new InsufficientInventoryException(
98:                         "Cannot remove " + quantity
99:                                 + " of merchandise " + merchandiseId +
100:                                 ". Only " + inventoryLevel.getQuantity()
101:                                 + " available in this fulfillment center");
102:             inventoryLevel.setQuantity(newQuantity);
103:         }
104:         else{
105:             throw new InsufficientInventoryException("Cannot remove " + quantity
106:                     + " of merchandise " + merchandiseId + ". No inventory found");
107:         }
108:     }
109: 
110:     public Integer getInventoryLevel(MerchandiseId merchandiseId) {
111:         return inventoryLevelList.stream()
112:                 .filter(il -> il.getMerchandiseId().equals(merchandiseId))
113:                 .findFirst()
114:                 .map(InventoryLevel::getQuantity)
115:                 .orElse(0);
116:     }
117: }
118: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterComparator.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
4: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
5: 
6: import java.util.Comparator;
7: import java.util.Map;
8: import java.util.Set;
9: 
10: public class FulfillmentCenterComparator implements Comparator<FulfillmentCenter> {
11: 
12:     private final Map<MerchandiseId, Integer> merchandiseMap;
13:     private final ZipCode zipCode;
14: 
15:     public FulfillmentCenterComparator(final Map<MerchandiseId, Integer> merchandiseMap, final ZipCode zipCode) {
16:         this.merchandiseMap = merchandiseMap;
17:         this.zipCode = zipCode;
18:     }
19: 
20:     public int compare(FulfillmentCenter c1, FulfillmentCenter c2) {
21:         Set<MerchandiseId> c1Merchandises =  c1.fulfillableShoppingCartParts(merchandiseMap);
22:         Set<MerchandiseId> c2Merchandises =  c2.fulfillableShoppingCartParts(merchandiseMap);
23: 
24:         int compare = Integer.compare(c2Merchandises.size(), c1Merchandises.size());
25: 
26:         if(compare != 0) return compare;
27:         else {
28:             ZipCode c1ZipCode = c1.getPhysicalAddress().getZipCode();
29:             ZipCode c2ZipCode = c2.getPhysicalAddress().getZipCode();
30: 
31:             return Integer.compare(c1ZipCode.difference(zipCode), c2ZipCode.difference(zipCode));
32:         }
33:     }
34: }
35: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterId.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "fulfillmentcenter_id"))
15: public class FulfillmentCenterId extends GenericId {
16:     public FulfillmentCenterId(UUID id) {
17:         super(id);
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class FulfillmentCenterIdConverter extends GenericIdConverter<FulfillmentCenterId> {
8:     public FulfillmentCenterIdConverter() {
9:         super(FulfillmentCenterId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: 
4: import org.springframework.data.repository.CrudRepository;
5: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
6: 
7: public interface FulfillmentCenterRepository extends CrudRepository<FulfillmentCenter, FulfillmentCenterId> {
8:     // find by
9:     Iterable<FulfillmentCenter> findByName(String name);
10: 
11:     Iterable<FulfillmentCenter> findByPhysicalAddress(PhysicalAddress physicalAddress);
12: 
13:     // exists by
14:     boolean existsByName(String name);
15: 
16:     boolean existsByPhysicalAddress(PhysicalAddress physicalAddress);
17: }
18: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\InventoryLevel.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.AccessLevel;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import lombok.Setter;
8: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
9: import thkoeln.archilab.ecommerce.solution.merchandise.domain.Storable;
10: 
11: import java.util.UUID;
12: 
13: @Entity
14: @Inheritance (strategy = InheritanceType.SINGLE_TABLE)
15: @Getter
16: @Setter
17: @NoArgsConstructor(access = AccessLevel.PROTECTED)
18: public class InventoryLevel extends Storable {
19:     @Setter(AccessLevel.PRIVATE)
20:     @EmbeddedId
21:     private InventoryLevelId id;
22: 
23:     @Column(nullable = false)
24:     private MerchandiseId merchandiseId;
25: 
26:     private int quantity;
27: 
28:     public InventoryLevel(MerchandiseId merchandiseId, int quantity) {
29:         this.id = new InventoryLevelId(UUID.randomUUID());
30:         this.merchandiseId = merchandiseId;
31:         this.quantity = quantity;
32:     }
33: }
34: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\InventoryLevelId.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "inventorylevel_id"))
15: public class InventoryLevelId extends GenericId {
16:     public InventoryLevelId(UUID id) {
17:         super(id);
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\InventoryLevelIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class InventoryLevelIdConverter extends GenericIdConverter<InventoryLevelId> {
8:     public InventoryLevelIdConverter() {
9:         super(InventoryLevelId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\application\MerchandiseCatalogAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.merchandise.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.Money;
6: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
7: import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: 
10: import java.util.UUID;
11: 
12: @Service
13: public class MerchandiseCatalogAdapterService implements MerchandiseCatalogUseCases {
14:     private final MerchandiseCatalogService merchandiseCatalogService;
15: 
16:     @Autowired
17:     public MerchandiseCatalogAdapterService(MerchandiseCatalogService merchandiseCatalogService) {
18:         this.merchandiseCatalogService = merchandiseCatalogService;
19:     }
20: 
21:     @Override
22:     public UUID addMerchandiseToCatalog(String name, String descriptFor, Float size, MoneyType buyingPrice, MoneyType salesPrice) {
23:         return this.merchandiseCatalogService.addMerchandiseToCatalog(
24:                 name,
25:                 descriptFor,
26:                 size,
27:                 (Money) buyingPrice,
28:                 (Money) salesPrice).getId();
29:     }
30: 
31:     @Override
32:     public void removeMerchandiseFromCatalog(UUID merchandiseId) {
33:         this.merchandiseCatalogService.removeMerchandiseFromCatalog(
34:                 new MerchandiseId(merchandiseId));
35:     }
36: 
37:     @Override
38:     public MoneyType getSalesPrice(UUID merchandiseId) {
39:         return this.merchandiseCatalogService.getSalesPrice(new MerchandiseId(merchandiseId));
40:     }
41: 
42:     @Override
43:     public void deleteMerchandiseCatalog() {
44:         this.merchandiseCatalogService.deleteMerchandiseCatalog();
45:     }
46: }
47: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\application\MerchandiseCatalogService.java ---
1: package thkoeln.archilab.ecommerce.solution.merchandise.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Money;
7: import thkoeln.archilab.ecommerce.solution.merchandise.domain.Merchandise;
8: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
9: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseRepository;
10: 
11: @Service
12: public class MerchandiseCatalogService{
13:     private final MerchandiseRepository merchandiseRepository;
14: 
15:     private final StorableServiceInterface storableServiceInterface;
16:     private final PurchasableServiceInterface purchasableServiceInterface;
17: 
18:     @Autowired
19:     public MerchandiseCatalogService(MerchandiseRepository merchandiseRepository,
20:                                      StorableServiceInterface storableServiceInterface,
21:                                      PurchasableServiceInterface purchasableServiceInterface) {
22:         this.merchandiseRepository = merchandiseRepository;
23:         this.storableServiceInterface = storableServiceInterface;
24:         this.purchasableServiceInterface = purchasableServiceInterface;
25:     }
26: 
27:     public MerchandiseId addMerchandiseToCatalog(
28:             String name,
29:             String descriptFor,
30:             Float size,
31:             Money buyingPrice,
32:             Money salesPrice) {
33:         if (name == null || name.isEmpty())
34:             throw new ShopException("Merchandise name can not be null or empty");
35:         if (descriptFor == null || descriptFor.isEmpty())
36:             throw new ShopException("Merchandise description can not be null or empty");
37:         if (buyingPrice == null)
38:             throw new ShopException("Merchandise buyingPrice can not be null or <= 0");
39:         if (salesPrice == null || salesPrice.getAmount() < buyingPrice.getAmount())
40:             throw new ShopException("Merchandise salesPrice can not be null or lower than buyingPrice");
41: 
42:         return this.merchandiseRepository.save(
43:                 new Merchandise(name, descriptFor, size, buyingPrice, salesPrice)).getId();
44:     }
45: 
46:     public void removeMerchandiseFromCatalog(MerchandiseId merchandiseId) {
47:         if (!this.merchandiseRepository.existsById(merchandiseId))
48:             throw new ShopException("Merchandise not found");
49: 
50:         if(storableServiceInterface.isMerchandiseInStock(merchandiseId))
51:             throw new ShopException("Unable to delete merchandise: still in inventory");
52: 
53:         if(purchasableServiceInterface.isMerchandiseInPurchase(merchandiseId))
54:             throw new ShopException("Unable to delete merchandise: already purchased");
55: 
56:         this.merchandiseRepository.deleteById(merchandiseId);
57:     }
58: 
59:     public Money getSalesPrice(MerchandiseId merchandiseId) {
60:         return this.merchandiseRepository.findById(merchandiseId)
61:                 .orElseThrow(() -> new ShopException("Merchandise not found"))
62:                 .getSalesPrice();
63:     }
64: 
65:     public void deleteMerchandiseCatalog() {
66:         this.merchandiseRepository.deleteAll();
67:     }
68: }
69: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\application\PurchasableServiceInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.merchandise.application;
2: 
3: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
4: 
5: public interface PurchasableServiceInterface {
6:     public boolean isMerchandiseInPurchase(MerchandiseId merchandiseId);
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\application\StorableServiceInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.merchandise.application;
2: 
3: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
4: 
5: public interface StorableServiceInterface {
6:     public boolean isMerchandiseInStock(MerchandiseId merchandiseId);
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\Merchandise.java ---
1: package thkoeln.archilab.ecommerce.solution.merchandise.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.*;
5: import thkoeln.archilab.ecommerce.domainprimitives.Money;
6: 
7: import java.util.UUID;
8: 
9: @Entity
10: @Data
11: @NoArgsConstructor
12: @AllArgsConstructor
13: public class Merchandise {
14:     @Setter(AccessLevel.PRIVATE)
15:     @EmbeddedId
16:     private MerchandiseId id;
17: 
18:     private String name;
19:     private String description;
20:     private Float size;
21:     @Embedded
22:     @AttributeOverrides({
23:             @AttributeOverride(name = "amount", column = @Column(name = "buyingPrice_amount")),
24:             @AttributeOverride(name = "currency", column = @Column(name = "buyingPrice_currency"))
25:     })
26:     private Money buyingPrice;
27:     @Embedded
28:     @AttributeOverrides({
29:             @AttributeOverride(name = "amount", column = @Column(name = "salesPrice_amount")),
30:             @AttributeOverride(name = "currency", column = @Column(name = "salesPrice_currency"))
31:     })
32:     private Money salesPrice;
33: 
34:     public Merchandise(
35:             String name,
36:             String description,
37:             Float size,
38:             Money buyingPrice,
39:             Money salesPrice){
40:         this.id = new MerchandiseId(UUID.randomUUID());
41:         this.name = name;
42:         this.description = description;
43:         this.size = size;
44:         this.buyingPrice = buyingPrice;
45:         this.salesPrice = salesPrice;
46:     }
47: }
48: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\MerchandiseId.java ---
1: package thkoeln.archilab.ecommerce.solution.merchandise.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "merchandise_id"))
15: public class MerchandiseId extends GenericId {
16:     public MerchandiseId(UUID uuid) {
17:         super(uuid);
18:     }
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\MerchandiseIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.merchandise.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class MerchandiseIdConverter extends GenericIdConverter<MerchandiseId> {
8:     public MerchandiseIdConverter() {
9:         super(MerchandiseId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\MerchandiseRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.merchandise.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import thkoeln.archilab.ecommerce.domainprimitives.Money;
5: 
6: public interface MerchandiseRepository extends CrudRepository<Merchandise, MerchandiseId> {
7:     // find by
8:     Iterable<Merchandise> findByName(String name);
9: 
10:     Iterable<Merchandise> findByDescription(String description);
11: 
12:     Iterable<Merchandise> findBySize(Float size);
13: 
14:     Iterable<Merchandise> findByBuyingPrice(Money buyingPrice);
15: 
16:     Iterable<Merchandise> findBySalesPrice(Money salesPrice);
17: 
18:     // exists by
19:     boolean existsByName(String name);
20: 
21:     boolean existsByDescription(String description);
22: 
23:     boolean existsBySize(Float size);
24: 
25:     boolean existsByBuyingPrice(Money buyingPrice);
26: 
27:     boolean existsBySalesPrice(Money salesPrice);
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\Purchasable.java ---
1: package thkoeln.archilab.ecommerce.solution.merchandise.domain;
2: 
3: import jakarta.persistence.MappedSuperclass;
4: import lombok.Getter;
5: import lombok.Setter;
6: 
7: @MappedSuperclass
8: @Setter
9: @Getter
10: public abstract class Purchasable {}
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\Storable.java ---
1: package thkoeln.archilab.ecommerce.solution.merchandise.domain;
2: 
3: import jakarta.persistence.MappedSuperclass;
4: import lombok.Getter;
5: import lombok.Setter;
6: 
7: @MappedSuperclass
8: @Setter
9: @Getter
10: public abstract class Storable {}
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchasableService.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.merchandise.application.PurchasableServiceInterface;
6: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
7: import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
8: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;
9: 
10: @Service
11: public class PurchasableService implements PurchasableServiceInterface {
12:     private final PurchaseRepository purchaseRepository;
13: 
14:     @Autowired
15:     public PurchasableService(PurchaseRepository purchaseRepository) {
16:         this.purchaseRepository = purchaseRepository;
17:     }
18: 
19:     @Override
20:     public boolean isMerchandiseInPurchase(MerchandiseId merchandiseId) {
21:         for (Purchase purchase : this.purchaseRepository.findAll())
22:             if (purchase.getQuantity(merchandiseId) != 0)
23:                 return true;
24:         return false;
25:     }
26: }
27: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
7: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
8: import thkoeln.archilab.ecommerce.usecases.PurchaseUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
10: 
11: import java.util.Map;
12: import java.util.UUID;
13: import java.util.stream.Collectors;
14: 
15: @Service
16: public class PurchaseAdapterService implements PurchaseUseCases {
17:     private final PurchaseService purchaseService;
18: 
19:     @Autowired
20:     public PurchaseAdapterService(PurchaseService purchaseService) {
21:         this.purchaseService = purchaseService;
22:     }
23: 
24:     @Override
25:     public Map<UUID, Integer> getPurchaseHistory(MailAddressType customerMailAddress) {
26:         return this.purchaseService.getPurchaseHistory((MailAddress) customerMailAddress)
27:                 .entrySet()
28:                 .stream()
29:                 .collect(Collectors.toMap(
30:                         entry -> entry.getKey().getId(),
31:                         Map.Entry::getValue));
32:     }
33: 
34:     @Override
35:     public Integer getPurchaseQuantiOfMerchandise(UUID purchaseId, UUID merchandiseId) {
36:         return this.purchaseService.getPurchaseQuantiOfMerchandise(
37:                 new PurchaseId(purchaseId),
38:                 new MerchandiseId(merchandiseId));
39:     }
40: 
41:     @Override
42:     public UUID getFulfillmentCenterIdForPurchase(UUID purchaseId) {
43:         return this.purchaseService.getFulfillmentCenterIdForPurchase(
44:                 new PurchaseId(purchaseId)).getId();
45:     }
46: 
47:     @Override
48:     public void deleteAllPurchases() {
49:         this.purchaseService.deleteAllPurchases();
50:     }
51: }
52: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.application;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.UUID;
9: 
10: @AllArgsConstructor
11: @NoArgsConstructor
12: @Setter
13: @Getter
14: public class PurchaseDTO {
15:     UUID id;
16:     String customerName;
17:     UUID fulfillmentCenterId;
18:     PurchasePartDTO[] parts;
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchasePartDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.application;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.UUID;
9: 
10: @AllArgsConstructor
11: @NoArgsConstructor
12: @Setter
13: @Getter
14: public class PurchasePartDTO {
15:     UUID merchandiseId;
16:     int quantity;
17: }
18: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseService.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
7: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.CustomerNotFoundException;
8: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.PurchaseNotFoundException;
9: import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
10: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerRepository;
11: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterId;
12: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
13: import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
14: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
15: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;
16: 
17: import java.util.HashMap;
18: import java.util.Map;
19: 
20: @Service
21: public class PurchaseService {
22:     private final PurchaseRepository purchaseRepository;
23:     private final CustomerRepository customerRepository;
24: 
25:     @Autowired
26:     public PurchaseService(
27:             PurchaseRepository purchaseRepository,
28:             CustomerRepository customerRepository) {
29:         this.purchaseRepository = purchaseRepository;
30:         this.customerRepository = customerRepository;
31:     }
32: 
33:     public Purchase getPurchase(PurchaseId purchaseId){
34:         return purchaseRepository.findById(purchaseId)
35:                 .orElseThrow(() -> new PurchaseNotFoundException("Purchase not found"));
36:     }
37: 
38:     public Map<MerchandiseId, Integer> getPurchaseHistory(MailAddress customerMailAddress) {
39:         Customer customer = this.customerRepository.findByMailAddress(customerMailAddress)
40:                 .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));
41: 
42:         Map<MerchandiseId, Integer> purchaseHistory = new HashMap<>();
43: 
44:         for (Purchase purchase : this.purchaseRepository.findByCustomerId(customer.getId())){
45:             for (Map.Entry<MerchandiseId, Integer> entry : purchase.getPurchaseAsMap().entrySet()) {
46:                 purchaseHistory.merge(
47:                         entry.getKey(),
48:                         entry.getValue(),
49:                         Integer::sum
50:                 );
51:             }
52:         }
53: 
54: 
55:         return purchaseHistory;
56:     }
57: 
58:     public Integer getPurchaseQuantiOfMerchandise(PurchaseId purchaseId, MerchandiseId merchandiseId) {
59:         Purchase purchase = this.purchaseRepository.findById(purchaseId)
60:                 .orElseThrow(() -> new PurchaseNotFoundException("Purchase not found"));
61: 
62:         return purchase.getQuantity(merchandiseId);
63:     }
64: 
65:     public FulfillmentCenterId getFulfillmentCenterIdForPurchase(PurchaseId purchaseId) {
66:         Purchase purchase = this.purchaseRepository.findById(purchaseId)
67:                 .orElseThrow(() -> new PurchaseNotFoundException("Purchase not found"));
68: 
69:         return purchase.getFulfillmentCenterId();
70:     }
71: 
72:     public void deleteAllPurchases() {
73:         this.purchaseRepository.deleteAll();
74:     }
75: }
76: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\Purchase.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.*;
5: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
6: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterId;
7: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
8: 
9: import java.util.ArrayList;
10: import java.util.List;
11: import java.util.Map;
12: import java.util.UUID;
13: import java.util.stream.Collectors;
14: 
15: @Entity
16: @Data
17: @NoArgsConstructor
18: @AllArgsConstructor
19: public class Purchase {
20:     @Setter(AccessLevel.PRIVATE)
21:     @EmbeddedId
22:     private PurchaseId id;
23: 
24:     @Column(nullable = false)
25:     private CustomerId customerId;
26: 
27:     @Column(nullable = false)
28:     private FulfillmentCenterId fulfillmentCenterId;
29: 
30:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
31:     private List<PurchasePart> purchasePartList;
32: 
33:     public Purchase(
34:             CustomerId customerId,
35:             FulfillmentCenterId fulfillmentCenterId) {
36:         this.id = new PurchaseId(UUID.randomUUID());
37:         this.customerId = customerId;
38:         this.fulfillmentCenterId = fulfillmentCenterId;
39:         this.purchasePartList = new ArrayList<>();
40:     }
41: 
42:     public void addPurchasePart(MerchandiseId merchandiseId, int quantity) {
43:         for(PurchasePart purchasePart : purchasePartList) {
44:             if(purchasePart.getMerchandiseId().equals(merchandiseId)) {
45:                 purchasePart.setQuantity(purchasePart.getQuantity() + quantity);
46:                 return;
47:             }
48:         }
49:         purchasePartList.add(new PurchasePart(
50:                 merchandiseId,
51:                 quantity
52:         ));
53:     }
54: 
55:     public void removePurchasePart(MerchandiseId merchandiseId) {
56:         purchasePartList.stream()
57:                 .filter(purchasePart ->
58:                         purchasePart.getMerchandiseId().equals(merchandiseId))
59:                 .findFirst()
60:                 .ifPresent(purchasePart -> purchasePartList.remove(purchasePart));
61:     }
62: 
63:     public Integer getQuantity(MerchandiseId merchandiseId) {
64:         return purchasePartList.stream()
65:                 .filter(purchasePart ->
66:                         purchasePart.getMerchandiseId().equals(merchandiseId))
67:                 .findFirst()
68:                 .map(PurchasePart::getQuantity)
69:                 .orElse(0);
70:     }
71: 
72:     public Map<MerchandiseId, Integer> getPurchaseAsMap() {
73:         return purchasePartList.stream()
74:                 .collect(Collectors.toMap(
75:                         PurchasePart::getMerchandiseId,
76:                         PurchasePart::getQuantity
77:                 ));
78:     }
79: }
80: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseId.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: @Embeddable
12: @NoArgsConstructor(access = AccessLevel.PROTECTED)
13: @AttributeOverride(name = "id", column = @Column(name = "purchase_id"))
14: public class PurchaseId extends GenericId {
15:     public PurchaseId(UUID uuid) {
16:         super(uuid);
17:     }
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import thkoeln.archilab.ecommerce.GenericIdConverter;
4: 
5: public class PurchaseIdConverter extends GenericIdConverter<PurchaseId> {
6:     public PurchaseIdConverter() {
7:         super(PurchaseId::new);
8:     }
9: }
10: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePart.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.AccessLevel;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import lombok.Setter;
8: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
9: import thkoeln.archilab.ecommerce.solution.merchandise.domain.Purchasable;
10: 
11: import java.util.UUID;
12: 
13: @Entity
14: @Inheritance (strategy = InheritanceType.SINGLE_TABLE)
15: @Getter
16: @Setter
17: @NoArgsConstructor(access = AccessLevel.PROTECTED)
18: public class PurchasePart extends Purchasable {
19:     @Setter(AccessLevel.PRIVATE)
20:     @EmbeddedId
21:     private PurchasePartId id;
22: 
23:     @Column(nullable = false)
24:     private MerchandiseId merchandiseId;
25: 
26:     private Integer quantity;
27: 
28:     public PurchasePart(MerchandiseId merchandiseId, int quantity) {
29:         this.id = new PurchasePartId(UUID.randomUUID());
30:         this.merchandiseId = merchandiseId;
31:         this.quantity = quantity;
32:     }
33: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePartId.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "customer_id"))
15: public class PurchasePartId extends GenericId {
16:     public PurchasePartId(UUID uuid) {
17:         super(uuid);
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePartIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class PurchasePartIdConverter extends GenericIdConverter<PurchasePartId> {
8:     public PurchasePartIdConverter() {
9:         super(PurchasePartId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
5: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterId;
6: 
7: public interface PurchaseRepository extends CrudRepository<Purchase, PurchaseId> {
8:     // find by
9:     Iterable<Purchase> findByCustomerId(CustomerId customerId);
10: 
11:     Iterable<Purchase> findByFulfillmentCenterId(FulfillmentCenterId fulfillmentCenterId);
12: 
13: 
14:     // exists by
15:     boolean existsByCustomerId(CustomerId customerId);
16: 
17:     boolean existsByFulfillmentCenterId(FulfillmentCenterId fulfillmentCenterId);
18: 
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartAdapterService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.GenericId;
6: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
7: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
8: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
11: 
12: import java.util.Map;
13: import java.util.Set;
14: import java.util.UUID;
15: import java.util.stream.Collectors;
16: 
17: @Service
18: public class ShoppingCartAdapterService implements ShoppingCartUseCases {
19:     private final ShoppingCartService shoppingCartService;
20: 
21:     @Autowired
22:     public ShoppingCartAdapterService(ShoppingCartService shoppingCartService) {
23:         this.shoppingCartService = shoppingCartService;
24:     }
25: 
26:     @Override
27:     public void addMerchandiseToShoppingCart(MailAddressType customerMailAddress, UUID merchandiseId, int quantiOf) {
28:         this.shoppingCartService.addMerchandiseToShoppingCart(
29:                 (MailAddress) customerMailAddress,
30:                 new MerchandiseId(merchandiseId),
31:                 quantiOf);
32:     }
33: 
34:     @Override
35:     public void removeMerchandiseFromShoppingCart(MailAddressType customerMailAddress, UUID merchandiseId, int quantiOf) {
36:         this.shoppingCartService.removeMerchandiseFromShoppingCart(
37:                 (MailAddress) customerMailAddress,
38:                 new MerchandiseId(merchandiseId),
39:                 quantiOf);
40:     }
41: 
42:     @Override
43:     public Map<UUID, Integer> getShoppingCartAsMap(MailAddressType customerMailAddress) {
44:         return this.shoppingCartService.getShoppingCartAsMap((MailAddress) customerMailAddress);
45:     }
46: 
47:     @Override
48:     public MoneyType getShoppingCartAsMoneyValue(MailAddressType customerMailAddress) {
49:         return this.shoppingCartService.getShoppingCartAsMoneyValue(
50:                         (MailAddress) customerMailAddress);
51:     }
52: 
53:     @Override
54:     public Set<UUID> checkout(MailAddressType customerMailAddress) {
55:         return this.shoppingCartService.checkout((MailAddress) customerMailAddress)
56:                 .stream()
57:                 .map(GenericId::getId)
58:                 .collect(Collectors.toSet());
59:     }
60: 
61:     @Override
62:     public void emptyAllShoppingCarts() {
63:         this.shoppingCartService.emptyAllShoppingCarts();
64:     }
65: }
66: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartController.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import org.modelmapper.ModelMapper;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.web.bind.annotation.*;
6: import org.springframework.http.HttpStatus;
7: import org.springframework.http.ResponseEntity;
8: import thkoeln.archilab.ecommerce.domainprimitives.Money;
9: import thkoeln.archilab.ecommerce.solution.customer.application.CustomerRegistrationService;
10: import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
11: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
12: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
13: import thkoeln.archilab.ecommerce.solution.purchase.application.PurchaseDTO;
14: import thkoeln.archilab.ecommerce.solution.purchase.application.PurchasePartDTO;
15: import thkoeln.archilab.ecommerce.solution.purchase.application.PurchaseService;
16: import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
17: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
18: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
19: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartId;
20: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartPart;
21: 
22: import java.util.Map;
23: import java.util.Set;
24: import java.util.UUID;
25: 
26: @RestController
27: @RequestMapping("/shoppingCarts")
28: public class ShoppingCartController {
29:     private final ShoppingCartService shoppingCartService;
30:     private final PurchaseService purchaseService;
31: 
32:     private static final ModelMapper MODEL_MAPPER = new ModelMapper();
33:     private final CustomerRegistrationService customerRegistrationService;
34: 
35:     @Autowired
36:     public ShoppingCartController(
37:             ShoppingCartService shoppingCartService,
38:             PurchaseService purchaseService, CustomerRegistrationService customerRegistrationService) {
39:         this.shoppingCartService = shoppingCartService;
40:         this.purchaseService = purchaseService;
41:         this.customerRegistrationService = customerRegistrationService;
42:     }
43: 
44:     @GetMapping(params = "customerId")
45:     public ResponseEntity<ShoppingCartDTO> getShoppingCart(
46:             @RequestParam("customerId") String customerId) {
47:         UUID customerUUID;
48:         try {
49:             customerUUID = UUID.fromString( customerId );
50:         } catch ( IllegalArgumentException e ) {
51:             return new ResponseEntity<>( HttpStatus.NOT_FOUND );
52:         }
53: 
54:         Customer customer = customerRegistrationService.getCustomerData(new CustomerId(customerUUID));
55:         ShoppingCart shoppingCart = shoppingCartService.getShoppingCart(customer.getId());
56: 
57:         Money totalSalesPrice = shoppingCartService.getShoppingCartAsMoneyValue(customer.getId());
58: 
59:         ShoppingCartPartDTO[] partDTOS = new ShoppingCartPartDTO[shoppingCart.getShoppingCartPartList().size()];
60: 
61:         for(int i = 0; i < shoppingCart.getShoppingCartPartList().size(); i++){
62:             ShoppingCartPart shoppingCartPart = shoppingCart.getShoppingCartPartList().get(i);
63:             partDTOS[i] = MODEL_MAPPER.map(shoppingCartPart, ShoppingCartPartDTO.class);
64:         }
65: 
66:         ShoppingCartDTO shoppingCartDTO = new ShoppingCartDTO(
67:                 shoppingCart.getId().getId(),
68:                 totalSalesPrice.toString(),
69:                 partDTOS
70:         );
71: 
72:         return new ResponseEntity<>(shoppingCartDTO, HttpStatus.OK);
73:     }
74: 
75:     @GetMapping()
76:     public ResponseEntity<ShoppingCartDTO> getShoppingCarts(){
77:         return new ResponseEntity<>(HttpStatus.METHOD_NOT_ALLOWED);
78:     }
79: 
80:     @PostMapping("/{shoppingCartId}/parts")
81:     public ResponseEntity addMerchandiseToShoppingCart(
82:             @PathVariable String shoppingCartId,
83:             @RequestBody ShoppingCartPartDTO shoppingCartPartDTO){
84:         UUID shoppingCartUUID;
85:         try {
86:             shoppingCartUUID = UUID.fromString( shoppingCartId );
87:         } catch ( IllegalArgumentException e ) {
88:             return new ResponseEntity<>( HttpStatus.NOT_FOUND );
89:         }
90: 
91:         ShoppingCart shoppingCart = shoppingCartService.getShoppingCart(
92:                 new ShoppingCartId(shoppingCartUUID));
93: 
94:         shoppingCartService.addMerchandiseToShoppingCart(
95:                 shoppingCart.getCustomerId(),
96:                 new MerchandiseId(shoppingCartPartDTO.getMerchandiseId()),
97:                 shoppingCartPartDTO.getQuantity()
98:         );
99:         
100:         return new ResponseEntity(HttpStatus.CREATED);
101:     }
102: 
103:     @PostMapping("/{shoppingCartId}/checkout")
104:     public ResponseEntity<PurchaseDTO[]> checkout(
105:             @PathVariable String shoppingCartId){
106:         UUID shoppingCartUUID;
107:         try {
108:             shoppingCartUUID = UUID.fromString( shoppingCartId );
109:         } catch ( IllegalArgumentException e ) {
110:             return new ResponseEntity<>( HttpStatus.NOT_FOUND );
111:         }
112: 
113:         Set<PurchaseId> purchaseIds = shoppingCartService.checkout(new ShoppingCartId(shoppingCartUUID));
114:         PurchaseDTO[] purchaseDTOS = new PurchaseDTO[purchaseIds.size()];
115: 
116:         if(purchaseIds.isEmpty()) return new ResponseEntity<>( HttpStatus.CONFLICT );
117: 
118:         int i = 0;
119:         for(PurchaseId purchaseId : purchaseIds){
120:             Purchase purchase = purchaseService.getPurchase(purchaseId);
121:             Customer customer = customerRegistrationService.getCustomerData(purchase.getCustomerId());
122:             Map<MerchandiseId, Integer> purchaseMap = purchase.getPurchaseAsMap();
123: 
124:             PurchasePartDTO[] purchasePartDTOS = new PurchasePartDTO[purchaseMap.size()];
125: 
126:             int j = 0;
127:             for(MerchandiseId merchandiseId : purchaseMap.keySet()){
128:                 PurchasePartDTO purchasePartDTO = new PurchasePartDTO(
129:                         merchandiseId.getId(),
130:                         purchaseMap.get(merchandiseId));
131:                 purchasePartDTOS[j] = purchasePartDTO;
132:                 j++;
133:             }
134: 
135:             MODEL_MAPPER.map(purchaseMap, purchasePartDTOS);
136: 
137:             purchaseDTOS[i] =  new PurchaseDTO(
138:                 purchaseId.getId(),
139:                 customer.getName(),
140:                     purchase.getFulfillmentCenterId().getId(),
141:                     purchasePartDTOS
142:             );
143:             i++;
144:         }
145: 
146:         return new ResponseEntity<>(purchaseDTOS, HttpStatus.CREATED);
147:     }
148: 
149:     @DeleteMapping("/{shoppingCartId}/parts/{merchandiseId}")
150:     public ResponseEntity removeMerchandiseFromShoppingCart(
151:             @PathVariable String shoppingCartId,
152:             @PathVariable String merchandiseId)
153:     {
154:         UUID shoppingCartUUID;
155:         try {
156:             shoppingCartUUID = UUID.fromString( shoppingCartId );
157:         } catch ( IllegalArgumentException e ) {
158:             return new ResponseEntity<>( HttpStatus.NOT_FOUND );
159:         }
160: 
161:         UUID merchandiseUUID;
162:         try {
163:             merchandiseUUID = UUID.fromString( merchandiseId );
164:         } catch ( IllegalArgumentException e ) {
165:             return new ResponseEntity<>( HttpStatus.NOT_FOUND );
166:         }
167: 
168:         ShoppingCart shoppingCart = shoppingCartService.getShoppingCart(
169:                 new ShoppingCartId(shoppingCartUUID));
170: 
171:         shoppingCartService.removeMerchandiseFromShoppingCart(
172:                 shoppingCart.getCustomerId(),
173:                 new MerchandiseId(merchandiseUUID));
174: 
175:         return new ResponseEntity(HttpStatus.OK);
176:     }
177: }
178: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.UUID;
9: 
10: @AllArgsConstructor
11: @NoArgsConstructor
12: @Setter
13: @Getter
14: public class ShoppingCartDTO {
15:     UUID id;
16:     String totalSalesPrice;
17:     ShoppingCartPartDTO[] parts ;
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartPartDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.UUID;
9: 
10: @AllArgsConstructor
11: @NoArgsConstructor
12: @Setter
13: @Getter
14: public class ShoppingCartPartDTO {
15:     UUID merchandiseId;
16:     int quantity;
17: }
18: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.InsufficientInventoryException;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
8: import thkoeln.archilab.ecommerce.domainprimitives.Money;
9: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.*;
10: import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
11: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
12: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerRepository;
13: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenter;
14: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterComparator;
15: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterRepository;
16: import thkoeln.archilab.ecommerce.solution.merchandise.domain.Merchandise;
17: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
18: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseRepository;
19: import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
20: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
21: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;
22: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
23: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartId;
24: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartPart;
25: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartRepository;
26: 
27: import java.util.*;
28: import java.util.stream.Collectors;
29: 
30: @Service
31: public class ShoppingCartService{
32:     private final ShoppingCartRepository shoppingCartRepository;
33:     private final CustomerRepository customerRepository;
34:     private final MerchandiseRepository merchandiseRepository;
35:     private final FulfillmentCenterRepository fulfillmentCenterRepository;
36:     private final PurchaseRepository purchaseRepository;
37: 
38:     @Autowired
39:     public ShoppingCartService(
40:             ShoppingCartRepository shoppingCartRepository,
41:             CustomerRepository customerRepository,
42:             MerchandiseRepository merchandiseRepository,
43:             FulfillmentCenterRepository fulfillmentCenterRepository,
44:             PurchaseRepository purchaseRepository) {
45:         this.shoppingCartRepository = shoppingCartRepository;
46:         this.customerRepository = customerRepository;
47:         this.merchandiseRepository = merchandiseRepository;
48:         this.fulfillmentCenterRepository = fulfillmentCenterRepository;
49:         this.purchaseRepository = purchaseRepository;
50:     }
51: 
52:     public void addMerchandiseToShoppingCart(
53:             Customer customer,
54:             MerchandiseId merchandiseId,
55:             int quantiOf) {
56:         if (quantiOf <= 0) throw new NegativeQuantityException("Quantity must be positive");
57: 
58:         if(!merchandiseRepository.existsById(merchandiseId))
59:             throw new MerchandiseNotFoundException("Merchandise not found");
60: 
61:         ShoppingCart shoppingCart = shoppingCartRepository.findByCustomerId(customer.getId())
62:                 .orElseGet(() -> shoppingCartRepository.save(new ShoppingCart(customer.getId())));
63: 
64:         shoppingCart.addToShoppingCart(merchandiseId, quantiOf);
65:         shoppingCartRepository.save(shoppingCart);
66:     }
67: 
68:     public void addMerchandiseToShoppingCart(
69:             CustomerId customerId,
70:             MerchandiseId merchandiseId,
71:             int quantiOf) {
72:         Customer customer = customerRepository.findById(customerId)
73:                 .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));
74: 
75:         addMerchandiseToShoppingCart(customer, merchandiseId, quantiOf);
76:     }
77: 
78:     public void addMerchandiseToShoppingCart(
79:             MailAddress customerMailAddress,
80:             MerchandiseId merchandiseId,
81:             int quantiOf) {
82:         if (customerMailAddress == null || merchandiseId == null)
83:             throw new InvalidMailAddressException("Customer mail address and merchandise ID must not be null");
84: 
85:         Customer customer = customerRepository.findByMailAddress(customerMailAddress)
86:                 .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));
87: 
88:         addMerchandiseToShoppingCart(customer, merchandiseId, quantiOf);
89:     }
90: 
91:     public void removeMerchandiseFromShoppingCart(
92:             MailAddress customerMailAddress,
93:             MerchandiseId merchandiseId){
94:         if (customerMailAddress == null || merchandiseId == null)
95:             throw new InvalidMailAddressException("Customer mail address and merchandise ID must not be null");
96: 
97:         Customer customer = customerRepository.findByMailAddress(customerMailAddress)
98:                 .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));
99: 
100:         removeMerchandiseFromShoppingCart(customer.getId(), merchandiseId);
101:     }
102: 
103:     public void removeMerchandiseFromShoppingCart(
104:             CustomerId customerId,
105:             MerchandiseId merchandiseId){
106:         ShoppingCart shoppingCart = this.shoppingCartRepository.findByCustomerId(customerId)
107:                 .orElseThrow(() -> new ShoppingCartNotFoundException("Shopping cart of customer not found"));
108: 
109:         shoppingCart.removeFromShoppingCart(merchandiseId);
110:         shoppingCartRepository.save(shoppingCart);
111:     }
112: 
113:     public void removeMerchandiseFromShoppingCart(
114:             MailAddress customerMailAddress,
115:             MerchandiseId merchandiseId,
116:             int quantiOf) {
117:         if (customerMailAddress == null || merchandiseId == null)
118:             throw new InvalidMailAddressException("Customer mail address and merchandise ID must not be null");
119: 
120:         Customer customer = customerRepository.findByMailAddress(customerMailAddress)
121:                 .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));
122: 
123:         removeMerchandiseFromShoppingCart(customer.getId(), merchandiseId, quantiOf);
124:     }
125: 
126:     public void removeMerchandiseFromShoppingCart(
127:             CustomerId customerId,
128:             MerchandiseId merchandiseId,
129:             int quantiOf) {
130:         if (quantiOf <= 0) throw new NegativeQuantityException("Quantity must be positive");
131: 
132:         if (!merchandiseRepository.existsById(merchandiseId))
133:             throw new MerchandiseNotFoundException("Merchandise not found");
134: 
135:         ShoppingCart shoppingCart = this.shoppingCartRepository.findByCustomerId(customerId)
136:                 .orElseThrow(() -> new ShoppingCartNotFoundException("Shopping cart of customer not found"));
137: 
138:         shoppingCart.removeFromShoppingCart(merchandiseId, quantiOf);
139:         shoppingCartRepository.save(shoppingCart);
140:     }
141: 
142:     public ShoppingCart getShoppingCart(CustomerId customerId) {
143:         Customer customer = this.customerRepository.findById(customerId)
144:                 .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));
145: 
146:         return getShoppingCart(customer);
147:     }
148: 
149:     public ShoppingCart getShoppingCart(MailAddress customerMailAddress) {
150:         Customer customer = this.customerRepository.findByMailAddress(customerMailAddress)
151:                 .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));
152: 
153:         return getShoppingCart(customer);
154:     }
155: 
156:     public ShoppingCart getShoppingCart(Customer customer) {
157:         return this.shoppingCartRepository.findByCustomerId(customer.getId())
158:                 .orElseGet(() -> {
159:                     ShoppingCart shoppingCart = new ShoppingCart(customer.getId());
160:                     this.shoppingCartRepository.save(shoppingCart);
161:                     return shoppingCart;
162:                 });
163:     }
164: 
165:     public ShoppingCart getShoppingCart(ShoppingCartId shoppingCartId) {
166:         return this.shoppingCartRepository.findById(shoppingCartId)
167:                 .orElseThrow(() -> new ShoppingCartNotFoundException("Shopping cart not found"));
168:     }
169: 
170:     public Map<UUID, Integer> getShoppingCartAsMap(MailAddress customerMailAddress) {
171:         return getShoppingCart(customerMailAddress)
172:                 .toMap()
173:                 .entrySet()
174:                 .stream()
175:                 .collect(Collectors.toMap(
176:                         entry -> entry.getKey().getId(),
177:                         Map.Entry::getValue));
178:     }
179: 
180:     public Money getShoppingCartAsMoneyValue(MailAddress customerMailAddress) {
181:         Customer customer = this.customerRepository.findByMailAddress(customerMailAddress)
182:                 .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));
183: 
184:         return getShoppingCartAsMoneyValue(customer.getId());
185:     }
186: 
187:     public Money getShoppingCartAsMoneyValue(CustomerId customerId) {
188:         ShoppingCart shoppingCart = this.shoppingCartRepository.findByCustomerId(customerId)
189:                 .orElseThrow(() -> new ShoppingCartNotFoundException("Shopping cart of customer not found"));
190: 
191:         if(shoppingCart.getShoppingCartPartList().isEmpty()) return Money.of(0f, "EUR");
192: 
193:         Merchandise firstItem = this.merchandiseRepository.findById(
194:                         shoppingCart.getShoppingCartPartList().getFirst().getMerchandiseId())
195:                 .orElseThrow(() -> new MerchandiseNotFoundException("First merchandise not found"));
196: 
197:         String currency = firstItem.getSalesPrice().getCurrencyUnit();
198: 
199:         Money total = Money.of(0f, currency);
200: 
201:         for(ShoppingCartPart shoppingCartPart : shoppingCart.getShoppingCartPartList()) {
202:             Merchandise merchandise = this.merchandiseRepository.findById(shoppingCartPart.getMerchandiseId())
203:                     .orElseThrow(() -> new MerchandiseNotFoundException("Merchandise not found"));
204: 
205:             total = total.add(merchandise.getSalesPrice().multiplyBy(shoppingCartPart.getQuantity()));
206:         }
207: 
208:         return total;
209:     }
210: 
211:     public Set<PurchaseId> checkout(MailAddress customerMailAddress) {
212:         if (customerMailAddress == null)
213:             throw new InvalidMailAddressException("Customer mail address can not be null");
214: 
215:         // get customer
216:         Customer customer = this.customerRepository.findByMailAddress(customerMailAddress)
217:                 .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));
218: 
219:         return checkout(customer);
220:     }
221: 
222:     public Set<PurchaseId> checkout(CustomerId customerId) {
223:         // get customer
224:         Customer customer = this.customerRepository.findById(customerId)
225:                 .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));
226: 
227:         return checkout(customer);
228:     }
229: 
230:     public Set<PurchaseId> checkout(Customer customer) {
231:         // get shoppingCart
232:         ShoppingCart shoppingCart = shoppingCartRepository.findByCustomerId(customer.getId())
233:                 .orElseThrow(() -> new ShoppingCartNotFoundException("Shopping cart not found"));
234: 
235:         return checkout(customer, shoppingCart);
236:     }
237: 
238:     public Set<PurchaseId> checkout(ShoppingCartId shoppingCartId) {
239:         // get shoppingCart
240:         ShoppingCart shoppingCart = shoppingCartRepository.findById(shoppingCartId)
241:                 .orElseThrow(() -> new ShoppingCartNotFoundException("Shopping cart not found"));
242: 
243:         // get customer
244:         Customer customer = this.customerRepository.findById(shoppingCart.getCustomerId())
245:                 .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));
246: 
247:         return checkout(customer, shoppingCart);
248:     }
249: 
250:     public Set<PurchaseId> checkout(ShoppingCart shoppingCart) {
251:         // get customer
252:         Customer customer = this.customerRepository.findById(shoppingCart.getCustomerId())
253:                 .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));
254: 
255:         return checkout(customer, shoppingCart);
256:     }
257: 
258:     private Set<PurchaseId> checkout(Customer customer, ShoppingCart shoppingCart) {
259:         List<FulfillmentCenter> fulfillmentCenters = (List<FulfillmentCenter>) this.fulfillmentCenterRepository.findAll();
260: 
261:         Set<PurchaseId> purchaseIds = new HashSet<>();
262: 
263:         while(!shoppingCart.getShoppingCartPartList().isEmpty()) {
264:             fulfillmentCenters.sort(new FulfillmentCenterComparator(
265:                     shoppingCart.toMap(),
266:                     customer.getPhysicalAddress().getZipCode()));
267: 
268:             FulfillmentCenter selectedFulfillmentCenter = fulfillmentCenters.getFirst();
269:             Set<MerchandiseId> selectedMerchandise = selectedFulfillmentCenter
270:                     .fulfillableShoppingCartParts(shoppingCart.toMap());
271: 
272:             if(selectedMerchandise.isEmpty()) {
273:                 throw new InsufficientMerchandiseInventoryException("Checkout failed: Merchandise not in stock");
274:             }
275: 
276:             Purchase purchase = new Purchase(customer.getId(), selectedFulfillmentCenter.getId());
277:             this.purchaseRepository.save(purchase);
278: 
279:             purchaseIds.add(purchase.getId());
280: 
281:             for(MerchandiseId merchandiseId :selectedMerchandise){
282:                 int quantity = shoppingCart.getQuantity(merchandiseId);
283: 
284:                 purchase.addPurchasePart(merchandiseId, quantity);
285:                 this.purchaseRepository.save(purchase);
286: 
287:                 shoppingCart.removeFromShoppingCart(merchandiseId, quantity);
288:                 selectedFulfillmentCenter.removeFromInventory(merchandiseId, quantity);
289:             }
290:         }
291: 
292:         // clear shopping cart
293:         shoppingCart.clear();
294:         this.shoppingCartRepository.save(shoppingCart);
295: 
296:         return purchaseIds;
297:     }
298: 
299:     public void emptyAllShoppingCarts() {
300:         this.shoppingCartRepository.findAll().forEach(ShoppingCart::clear);
301:     }
302: }
303: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCart.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.*;
5: import thkoeln.archilab.ecommerce.InsufficientInventoryException;
6: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.InsufficientMerchandiseInventoryException;
7: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.MerchandiseNotFoundException;
8: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
9: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
10: 
11: import java.util.ArrayList;
12: import java.util.List;
13: import java.util.Map;
14: import java.util.UUID;
15: import java.util.stream.Collectors;
16: 
17: @Entity
18: @Data
19: @NoArgsConstructor
20: @AllArgsConstructor
21: public class ShoppingCart {
22:     @Setter(AccessLevel.PRIVATE)
23:     @EmbeddedId
24:     private ShoppingCartId id;
25: 
26:     @Column(nullable = false, unique = true)
27:     private CustomerId customerId;
28: 
29:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
30:     private List<ShoppingCartPart> shoppingCartPartList;
31: 
32:     public ShoppingCart(CustomerId customerId) {
33:         this.id = new ShoppingCartId(UUID.randomUUID());
34:         this.customerId = customerId;
35:         this.shoppingCartPartList = new ArrayList<>();
36:     }
37: 
38:     public void addToShoppingCart(MerchandiseId merchandiseId, int quantity) {
39:         shoppingCartPartList.stream()
40:                 .filter(shoppingCartPart -> shoppingCartPart.getMerchandiseId().equals(merchandiseId))
41:                 .findFirst()
42:                 .ifPresentOrElse(
43:                         shoppingCartPart -> shoppingCartPart.setQuantity(
44:                                 shoppingCartPart.getQuantity() + quantity),
45:                         () -> shoppingCartPartList.add(
46:                                 new ShoppingCartPart(merchandiseId, quantity))
47:                 );
48:     }
49: 
50:     public void removeFromShoppingCart(MerchandiseId merchandiseId) {
51:         shoppingCartPartList
52:                 .stream()
53:                 .filter(shoppingCartPart -> shoppingCartPart.getMerchandiseId().equals(merchandiseId))
54:                 .findFirst()
55:                 .ifPresentOrElse(
56:                         shoppingCartPart -> shoppingCartPartList.remove(shoppingCartPart),
57:                         () -> {
58:                             throw new MerchandiseNotFoundException("Merchandise not found");
59:                         }
60:                 );
61:     }
62: 
63:     public void removeFromShoppingCart(MerchandiseId merchandiseId, int quantity) {
64:         shoppingCartPartList.stream()
65:                 .filter(shoppingCartPart -> shoppingCartPart.getMerchandiseId().equals(merchandiseId))
66:                 .findFirst()
67:                 .ifPresent(shoppingCartPart -> {
68:                     int newQuantity = shoppingCartPart.getQuantity() - quantity;
69:                     if (newQuantity < 0)
70:                         throw new InsufficientMerchandiseInventoryException(
71:                                 "Cannot remove " + quantity
72:                                         + " of merchandise " + merchandiseId +
73:                                         ". Only " + shoppingCartPart.getQuantity()
74:                                         + " in shopping cart");
75:                     else if(newQuantity == 0) shoppingCartPartList.remove(shoppingCartPart);
76:                     else shoppingCartPart.setQuantity(newQuantity);
77:                 });
78:     }
79: 
80:     public Integer getQuantity(MerchandiseId merchandiseId) {
81:         return shoppingCartPartList.stream()
82:                 .filter(shoppingCartPart ->
83:                         shoppingCartPart.getMerchandiseId().equals(merchandiseId))
84:                 .findFirst()
85:                 .map(ShoppingCartPart::getQuantity)
86:                 .orElseThrow(() -> new MerchandiseNotFoundException(
87:                         "Merchandise not found in shopping cart"));
88:     }
89: 
90:     public Map<MerchandiseId, Integer> toMap() {
91:         return shoppingCartPartList.stream()
92:                 .collect(Collectors.toMap(
93:                         ShoppingCartPart::getMerchandiseId,
94:                         ShoppingCartPart::getQuantity
95:                 ));
96:     }
97: 
98:     public void clear(){
99:         shoppingCartPartList.clear();
100:     }
101: }
102: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: 
4: import jakarta.persistence.AttributeOverride;
5: import jakarta.persistence.Column;
6: import jakarta.persistence.Embeddable;
7: import lombok.AccessLevel;
8: import lombok.NoArgsConstructor;
9: import thkoeln.archilab.ecommerce.GenericId;
10: 
11: import java.util.UUID;
12: 
13: @Embeddable
14: @NoArgsConstructor(access = AccessLevel.PROTECTED)
15: @AttributeOverride(name = "id", column = @Column(name = "shoppingcart_id"))
16: public class ShoppingCartId extends GenericId {
17:     public ShoppingCartId(UUID id) {
18:         super(id);
19:     }
20: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ShoppingCartIdConverter extends GenericIdConverter<ShoppingCartId> {
8:     public ShoppingCartIdConverter() {
9:         super(ShoppingCartId::new);
10:     }
11: }
12: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPart.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.Column;
4: import jakarta.persistence.EmbeddedId;
5: import jakarta.persistence.Entity;
6: import lombok.AccessLevel;
7: import lombok.Getter;
8: import lombok.NoArgsConstructor;
9: import lombok.Setter;
10: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
11: 
12: import java.util.UUID;
13: 
14: @Entity
15: @Getter
16: @NoArgsConstructor(access = AccessLevel.PROTECTED)
17: public class ShoppingCartPart {
18:     @Setter(AccessLevel.PRIVATE)
19:     @EmbeddedId
20:     private ShoppingCartPartId id;
21: 
22:     @Column(nullable = false)
23:     private MerchandiseId merchandiseId;
24: 
25:     @Setter
26:     private int quantity;
27: 
28:     public ShoppingCartPart(MerchandiseId merchandiseId, int quantity) {
29:         this.id = new ShoppingCartPartId(UUID.randomUUID());
30:         this.merchandiseId = merchandiseId;
31:         this.quantity = quantity;
32:     }
33: }
34: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPartId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "shoppingcartpart_id"))
15: public class ShoppingCartPartId extends GenericId {
16:     public ShoppingCartPartId(UUID id) {
17:         super(id);
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPartIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: 
7: @Converter(autoApply = true)
8: public class ShoppingCartPartIdConverter extends GenericIdConverter<ShoppingCartPartId> {
9:     public ShoppingCartPartIdConverter() {
10:         super(ShoppingCartPartId::new);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
5: 
6: import java.util.Optional;
7: 
8: public interface ShoppingCartRepository extends CrudRepository<ShoppingCart, ShoppingCartId> {
9:     // find by
10:     Optional<ShoppingCart> findByCustomerId(CustomerId customerId);
11: 
12:     // exists by
13:     boolean existsByCustomerId(CustomerId customerId);
14: }
15: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\CustomerRegistrationUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: 
11: /**
12:  * This interface contains methods needed in the context of use cases concerning the registration of a customer.
13:  * The interface is probably incomplete, and will grow over time ...
14:  */
15: public interface CustomerRegistrationUseCases {
16:     /**
17:      * Registers a new customer
18:      *
19:      * @param name
20:      * @param mailAddress
21:      * @param physicalAddress
22:      * @throws ShopException if ...
23:      *      - the customer with the given mail address already exists
24:      *      - physicalAddress is null
25:      */
26:     public void register( String name, MailAddressType mailAddress, PhysicalAddressType physicalAddress );
27: 
28: 
29:     /**
30:      * Changes the address of a customer
31:      *
32:      * @param customerMailAddress
33:      * @param customerMailAddress
34:      * @param physicalAddress
35:      * @throws ShopException if ...
36:      *      - the customer with the given mail address does not exist,
37:      *      - physicalAddress is null
38:      */
39:     public void changeAddress( MailAddressType customerMailAddress,
40:                                PhysicalAddressType physicalAddress );
41: 
42: 
43:     /**
44:      * Returns the data of a customer as an array of strings (name, mailAddress, street, city, zipCode)
45:      * @param customerMailAddress
46:      * @return the customer data
47:      * @throws ShopException the customer with the given mail address does not exist,
48:      */
49:     public CustomerType getCustomerData( MailAddressType customerMailAddress );
50: 
51: 
52: 
53:     /**
54:      * Clears all customers, including all purchases and shopping carts
55:      */
56:     public void deleteAllCustomers();
57: }
58: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\CustomerType.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
5: 
6: /**
7:  * This interface expresses the essence of a shop customer
8:  */
9: public interface CustomerType {
10:     String getName();
11:     MailAddressType getMailAddress();
12:     PhysicalAddressType getPhysicalAddress();
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MailAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface MailAddressType {
6:     /**
7:      * @return the mail address as a string
8:      */
9:     public String toString();
10: 
11: 
12:     /**
13:      * A special kind of "copy constructor": Returns a new mail address object with
14:      * the same identifyer (the substring left of the "@" sign) as the current one, but
15:      * with a new domain substring (right of the "@" sign).
16:      * @param domainString - the new domain for the copied mail address
17:      * @return the new mail address
18:      * @throws ShopException if ...
19:      *     - domainString is null
20:      *     - the new mail address would not be valid (see `of(...)` method)
21:      */
22:     public MailAddressType sameIdentifyerDifferentDomain( String domainString );
23: 
24:     /**
25:      * Another special kind of "copy constructor": Returns a new mail address object
26:      * with the same domain (the substring right of the "@" sign) as the current one, but
27:      * with a new identifyer substring (left of the "@" sign).
28:      * @param identifyerString - the new identifyer for the copied mail address
29:      * @return the new mail address
30:      * @throws ShopException if ...
31:      *     - identifyerString is null
32:      *     - the new mail address would not be valid (see `of(...)` method)
33:      */
34:     public MailAddressType sameDomainDifferentIdentifyer( String identifyerString );
35: 
36: 
37:     /**
38:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
39:      * implementing class to provide a static factory method (simply named "of(...)"),
40:      * which creates an mail address, given as a string.
41:      * We specify this factory method here as a comment, using the Javadoc documentation style.
42:      *
43:      * @param mailAddressAsString - the mail address as a string.
44:      *      We will use a much simplified validation method to check if the mail address is valid:
45:      *      - it must contain exactly one '@' character.
46:      *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
47:      *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
48:      *      - the substrings before and after the '@' may contain one or several '.' as separators
49:      *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
50:      *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
51:      *        (for simplicity we do not allow any other domains)
52:      * @return a new MailAddressType object matching the given mail address
53:      * @throws ShopException if ...
54:      *      - mailAddressAsString is null
55:      *      - mailAddressAsString is not a valid mail address (see above)
56:      */
57:      // public static MailAddressType of( String mailAddressAsString );
58: }
59: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MoneyType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface MoneyType {
6:     /**
7:      * @return the amount of money
8:      */
9:     public Float getAmount();
10: 
11: 
12:     /**
13:      * @return the currency unit of the money
14:      */
15:     public String getCurrencyUnit();
16: 
17: 
18:     /**
19:      * @param otherMoney
20:      * @return this + otherMoney, as a new object
21:      * @throws ShopException if ...
22:      *      - otherMoney is null
23:      *      - otherMoney.currencyUnit != this.currencyUnit
24:      */
25:     public MoneyType add( MoneyType otherMoney );
26: 
27: 
28:     /**
29:      * @param otherMoney
30:      * @return this - otherMoney, as a new object
31:      * @throws ShopException if ...
32:      *      - otherMoney is null
33:      *      - otherMoney.currencyUnit != this.currencyUnit
34:      *      - otherMoney > this
35:      */
36:     public MoneyType subtract( MoneyType otherMoney );
37: 
38: 
39:     /**
40:      * @param factor
41:      * @return this * factor, as a new object
42:      * @throws ShopException if ...
43:      *     - factor < 0
44:      */
45:     public MoneyType multiplyBy( int factor );
46: 
47:     /**
48:      * @param otherMoney
49:      * @return true, if this > otherMoney
50:      * @throws ShopException if ...
51:      *      - otherMoney is null
52:      *      - otherMoney.currencyUnit != this.currencyUnit
53:      */
54:     public boolean largerThan( MoneyType otherMoney );
55: 
56: 
57:     /**
58:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
59:      * implementing class to provide a static factory method (simply named "of(...)"),
60:      * which creates a money object from an amount and a currency unit (as string).
61:      * We specify this factory method here as a comment, using the Javadoc documentation style.
62:      *
63:      * @param amount the amount of money (must be >= 0)
64:      * @param currencyUnit the currency unit of the money (allowed values: "EUR", "CHF")
65:      * @return a new Money object with the given amount and currency unit
66:      * @throws ShopException if ...
67:      *   - amount is null
68:      *   - amount < 0
69:      *   - currency unit is null
70:      *   - currency unit is not one of the allowed values
71:      */
72:      // public static MoneyType of( Float amount, String currencyUnit );
73: }
74: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PhysicalAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface PhysicalAddressType {
6:     /**
7:      * @return the street as a string
8:      */
9:     public String getStreet();
10: 
11:     /**
12:      * @return the city as a string
13:      */
14:     public String getCity();
15: 
16:     /**
17:      * @return the zip code
18:      */
19:     public ZipCodeType getZipCode();
20: 
21:     /**
22:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
23:      * implementing class to provide a static factory method (simply named "of(...)"),
24:      * which creates an zip code, given as a string.
25:      * We specify this factory method here as a comment, using the Javadoc documentation style.
26:      *
27:      * @param street the street as a string
28:      * @param city the city as a string
29:      * @param zipCode the zip code
30:      * @return the physical address object matching the parameters
31:      * @throws ShopException if ...
32:      *      - street is null or empty
33:      *      - city is null or empty
34:      *      - zipCode is null
35:      */
36:      // public static PhysicalAddressType of( String street, String city, ZipCodeType zipCode );
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\ZipCodeType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnore;
4: import thkoeln.archilab.ecommerce.ShopException;
5: 
6: public interface ZipCodeType {
7:     /**
8:      * @return the zip code as a string
9:      */
10:     public String toString();
11: 
12:     /**
13:      * You will need some idea of "imprecise difference" between two zip codes for properly
14:      * implementing fulfillment centers in your shopping platform. This method calculates such a
15:      * difference. You can decide for yourself what values you return, unless you comply
16:      * with the following rules.
17:      * - The return value is 0 if both zip codes are the same
18:      * - If not:
19:      *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
20:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
21:      *        So, 56733 and 56734 have the same difference as 56733 and 56739.
22:      *      - The difference grows if more digits (counted from the right side) differ.
23:      *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
24:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
25:      *        53876 and 54876 have the same difference as 53876 and 57261.
26:      *      - However, the difference between 5abcd and 6rstu must be smaller than the one
27:      *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
28:      *        one between 5abcd and 9rstu.
29:      *      - This last condition reflects the fact the first digits of a zip code marks a region
30:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
31:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
32:      *        other.
33:      * @param otherZipCode
34:      * @return the calculated difference
35:      * @throws ShopException if otherZipCode is null
36:      */
37:     public int difference( ZipCodeType otherZipCode );
38: 
39: 
40:     /**
41:      * For the currently used way of deciding on the best fitting fulfillment center for a purchase,
42:      * we need to know the first digit of the zip code.
43:      */
44:     @JsonIgnore
45:     public Integer getFirstDigitZipCode();
46: 
47: 
48:     /**
49:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
50:      * implementing class to provide a static factory method (simply named "of(...)"),
51:      * which creates an zip code, given as a string.
52:      * We specify this factory method here as a comment, using the Javadoc documentation style.
53:      *
54:      * @param zipCodeAsString - the zip code as a string.
55:      *      We will use a much simplified validation method to check if the zip code is valid:
56:      *      - It must contain exactly 5 digits.
57:      *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid zip code, but 20001 is valid)
58:      * @return a new zip code object matching the given string
59:      * @throws ShopException if ...
60:      *      - zipCodeAsString is null
61:      *      - zipCodeAsString is not a valid zip code (see above)
62:      */
63:      // public static ZipCodeType of( String zipCodeAsString );
64: }
65: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\FulfillmentCenterUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
9: 
10: import java.util.UUID;
11: 
12: /**
13:  * This interface contains methods needed in the context of handling the shop inventory,
14:  * i.e. managing fulfillment centers, and adding / removing merchandises in the fulfillment center.
15:  */
16: public interface FulfillmentCenterUseCases {
17:     /**
18:      *
19:      * @param name
20:      * @param physicalAddress
21:      * @return the id of the new fulfillment center
22:      * @throws ShopException if ...
23:      *      - name is null or empty
24:      *      - physicalAddress is null
25:      */
26:     public UUID addNewFulfillmentCenter( String name, PhysicalAddressType physicalAddress );
27: 
28: 
29:     /**
30:      * Deletes all fulfillment centers from the shop. Intended for testing purposes.
31:      */
32:     public void deleteAllFulfillmentCenters();
33: 
34: 
35:     /**
36:      * Adds a certain Quantity of a given merchandise to the inventory
37:      * @param fulfillmentCenterId
38:      * @param merchandiseId
39:      * @param addedQuantiOf
40:      * @throws ShopException if ...
41:      *      - fulfillmentCenterId is null
42:      *      - the fulfillment center with that id does not exist
43:      *      - merchandiseId is null
44:      *      - the merchandise with that id does not exist
45:      *      - addedQuantiOf < 0
46:      */
47:     public void addToInventory( UUID fulfillmentCenterId, UUID merchandiseId, int addedQuantiOf );
48: 
49: 
50:     /**
51:      * Removes a certain Quantity of a given merchandise from the inventory.
52:      * @param fulfillmentCenterId
53:      * @param merchandiseId
54:      * @param removedQuantiOf
55:      * @throws ShopException if ...
56:      *      - fulfillmentCenterId is null
57:      *      - the fulfillment center with that id does not exist
58:      *      - merchandiseId is null
59:      *      - the merchandise with that id does not exist
60:      *      - removedQuantiOf < 0
61:      */
62:     public void removeFromInventory( UUID fulfillmentCenterId, UUID merchandiseId, int removedQuantiOf );
63: 
64: 
65:     /**
66:      * Changes the total Quantity of a given merchandise in the inventory.
67:      * @param fulfillmentCenterId
68:      * @param merchandiseId
69:      * @param newTotalQuantiOf
70:      * @throws ShopException if ...
71:      *      - fulfillmentCenterId is null
72:      *      - the fulfillment center with that id does not exist
73:      *      - merchandiseId is null
74:      *      - the merchandise with that id does not exist
75:      *      - newTotalQuantiOf < 0
76:      */
77:     public void changeInventoryTo( UUID fulfillmentCenterId, UUID merchandiseId, int newTotalQuantiOf );
78: 
79: 
80:     /**
81:      * Get the current inventory of a given merchandise in one specific fulfillment center.
82:      * @param fulfillmentCenterId
83:      * @param merchandiseId
84:      * @return the current total inventory of the merchandise
85:      * @throws ShopException if ...
86:      *      - fulfillmentCenterId is null
87:      *      - the fulfillment center with that id does not exist
88:      *      - merchandiseId is null
89:      *      - the merchandise with that id does not exist
90:      */
91:     public int getAvailableInventory( UUID fulfillmentCenterId, UUID merchandiseId );
92: 
93: 
94: }
95: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\CustomerTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: 
4: import thkoeln.archilab.ecommerce.usecases.CustomerType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
7: 
8: /**
9:  * This is a test helper interface provides access to predefined test data for
10:  * customers.
11:  */
12: public interface CustomerTestHelper {
13:     /**
14:      * This method calls the use case implementation to register all customers specified in the
15:      * test data set.
16:      * If you use the debugger and want to identify _which_ test customer you currently look at:
17:      * The indices are coded into the house number (in the customer's physical address) and in the first
18:      * cipher of the zip code. This is the list of customers:
19:      *
20:      * +-------+-------------------+--------+---------------------
21:      * | Index | Name              | PLZ    | MailAddress
22:      * +-------+-------------------+--------+---------------------
23:      * | 0     | Max Mueller       | 02314  | 99Z@example.com
24:      * | 1     | Sophie Schmitz    | 02368  | a@4.com
25:      * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
26:      * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
27:      * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
28:      * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
29:      * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
30:      * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
31:      * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
32:      * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
33:      * +-------+-------------------+--------+---------------------
34:      */
35:     void registerAllCustomers();
36: 
37: 
38:     /**
39:      * @return the number of test customers in the test data set.
40:      */
41:     int getNumberOfCustomers();
42: 
43: 
44:     /**
45:      * @param index the index of the customer in the test data set.
46:      * @return the name of the test customer with the given index.
47:      */
48:     String getCustomerName( int index );
49: 
50: 
51:     /**
52:      * @param index the index of the customer in the test data set.
53:      * @return the mail address of the test customer with the given index.
54:      */
55:     MailAddressType getCustomerMailAddress( int index );
56: 
57: 
58:     /**
59:      * @param index the index of the customer in the test data set.
60:      * @return the physical address of the test customer with the given index.
61:      */
62:     PhysicalAddressType getCustomerPhysicalAddress( int index );
63: 
64: 
65:     /**
66:      * @param index the index of the customer in the test data set.
67:      * @return the test customer with the given index.
68:      */
69:     CustomerType getCustomer( int index );
70: 
71: }
72: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
8: 
9: import java.io.File;
10: import java.io.IOException;
11: import java.lang.reflect.InvocationTargetException;
12: import java.lang.reflect.Method;
13: import java.lang.reflect.Modifier;
14: import java.net.URL;
15: import java.net.URLDecoder;
16: import java.nio.charset.StandardCharsets;
17: import java.util.Enumeration;
18: 
19: import static org.junit.jupiter.api.Assertions.*;
20: 
21: public class FactoryMethodInvoker {
22: 
23:     public static MailAddressType instantiateMailAddress( String mailAddressAsString ) {
24:         Method factoryMethod = null;
25:         try {
26:             Class<?> interfaceClass = Class.forName(
27:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType" );
28:             Class<?> implementingClass = findImplementation( interfaceClass );
29: 
30:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
31:             assertNotNull( factoryMethod );
32:             int modifiers = factoryMethod.getModifiers();
33:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
34:         } catch (Exception e) {
35:             fail( "Failed to find implementation for MailAddressType", e );
36:         }
37: 
38:         Object instance = null;
39:         try {
40:             instance = factoryMethod.invoke( null, mailAddressAsString );
41:         } catch (Exception e) {
42:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
43:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
44:             fail( "Failed to invoke factory method 'of' for '" + mailAddressAsString + "'", e );
45:         }
46:         assertNotNull( instance );
47:         return (MailAddressType) instance;
48:     }
49: 
50: 
51:     public static PhysicalAddressType instantiatePhysicalAddress(
52:             String street, String city, ZipCodeType zipCode ) {
53:         Method factoryMethod = null;
54:         try {
55:             Class<?> interfaceClass = Class.forName(
56:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType" );
57:             Class<?> implementingClass = findImplementation( interfaceClass );
58: 
59:             factoryMethod = implementingClass.getDeclaredMethod( "of",
60:                     String.class, String.class, ZipCodeType.class );
61:             assertNotNull( factoryMethod );
62:             int modifiers = factoryMethod.getModifiers();
63:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
64:         } catch (Exception e) {
65:             fail( "Failed to find implementation for PhysicalAddressType", e );
66:         }
67: 
68:         Object instance = null;
69:         try {
70:             instance = factoryMethod.invoke( null, street, city, zipCode );
71:         } catch (Exception e) {
72:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
73:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
74:             fail( "Failed to invoke factory method 'of' for '" +
75:                     street + "', '" + city + "', '" + zipCode + "'", e );
76:         }
77:         assertNotNull( instance );
78:         return (PhysicalAddressType) instance;
79:     }
80: 
81: 
82:     public static ZipCodeType instantiateZipCode( String zipCodeAsString ) {
83:         Method factoryMethod = null;
84:         try {
85:             Class<?> interfaceClass = Class.forName(
86:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType" );
87:             Class<?> implementingClass = findImplementation( interfaceClass );
88: 
89:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
90:             assertNotNull( factoryMethod );
91:             int modifiers = factoryMethod.getModifiers();
92:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
93:         } catch (Exception e) {
94:             fail( "Failed to find implementation for ZipCodeType", e );
95:         }
96: 
97:         Object instance = null;
98:         try {
99:             instance = factoryMethod.invoke( null, zipCodeAsString );
100:         } catch (Exception e) {
101:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
102:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
103:             fail( "Failed to invoke factory method 'of' for '" + zipCodeAsString + "'", e );
104:         }
105:         assertNotNull( instance );
106:         return (ZipCodeType) instance;
107:     }
108: 
109: 
110:     public static MoneyType instantiateMoney( Float amount, String currencyUnit ) {
111:         Method factoryMethod = null;
112:         try {
113:             Class<?> interfaceClass = Class.forName(
114:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType" );
115:             Class<?> implementingClass = findImplementation( interfaceClass );
116: 
117:             factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
118:             assertNotNull( factoryMethod );
119:             int modifiers = factoryMethod.getModifiers();
120:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
121:         } catch (Exception e) {
122:             fail( "Failed to find implementation for MoneyType", e );
123:         }
124: 
125:         Object instance = null;
126:         try {
127:             instance = factoryMethod.invoke( null, amount, currencyUnit );
128:         } catch (Exception e) {
129:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
130:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
131:             fail( "Failed to invoke factory method 'of' for '" + amount + "', '" + currencyUnit + "'", e );
132:         }
133:         assertNotNull( instance );
134:         return (MoneyType) instance;
135:     }
136: 
137: 
138:     private static Class<?> findImplementation( Class<?> interfaceClass ) {
139:         Method factoryMethod = null;
140:         try {
141:             String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
142:             Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
143:             assertNotNull( implementingClass );
144:             return implementingClass;
145:         } catch (Exception e) {
146:             fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
147:             return null; // This line will never be reached, but it's necessary to satisfy the compiler
148:         }
149:     }
150: 
151: 
152:     private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
153:             throws ClassNotFoundException, IOException {
154:         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
155:         String path = packageName.replace( '.', '/' );
156:         Enumeration<URL> resources = classLoader.getResources( path );
157:         int count = 0;
158:         Class<?> result = null;
159:         while (resources.hasMoreElements()) {
160:             URL resource = resources.nextElement();
161:             File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
162:             File[] files = directory.listFiles();
163:             for ( File file : files ) {
164:                 if ( file.getName().endsWith( ".class" ) ) {
165:                     String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
166:                     Class<?> clazz = Class.forName( className );
167:                     if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
168:                         count++;
169:                         result = clazz;
170:                     }
171:                 }
172:             }
173:         }
174:         assertEquals( 1, count, "There should be exactly one implementing class" );
175:         return result;
176:     }
177: }
178: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FulfillmentCenterTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import java.util.UUID;
4: 
5: public interface FulfillmentCenterTestHelper {
6:     /**
7:      * Adds the test fulfillment centers to the system.
8:      * If you want to use the fulfillment centers, or want to know which index the fulfillment center has that you see
9:      * in the debugger, the following rules apply:
10:      * - The fulfillment center name will equal the street name of the physical address of the fulfillment center.
11:      * - The index number is visible in the house number. Example: fulfillment center 3 is located at
12:      *   "Ablageweg 3", and that is also its name.
13:      *
14:      *  The fulfillment centers are used in the tests as follows:
15:      *  - fulfillment center 0 holds all merchandises 0 - 6, and is used for all tests where it is not relevant
16:      *    to split one shopping cart into several purchases.
17:      *  - fulfillment centers 1 - 3 are used for the proximity tests, where you can deliver merchandise 7 to
18:      *    to a customer from the closest fulfillment center.
19:      *  - fulfillment centers 4 - 8 are used for the tests where you need to deliver merchandises 8 - 14 in
20:      *    the most cost-efficient way, as multiple shipments.
21:      *  - fulfillment center 9 is empty.
22:      *
23:      *  If withInventory is true, then the fulfillment centers are filled with merchandises. This happens
24:      *  according to the following rules:
25:      *  - merchandises 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
26:      *    ONLY available in fulfillment center 0. (This means that merchandise 0 out of inventory everywhere.)
27:      *  - merchandises 4, 5, 6 have a random inventory between 30 and 130, also all ONLY in fulfillment center 0
28:           (these are the merchandises used for tests on how to add and remove inventory)
29:      *  - merchandise 7 has a random inventory between 30 and 130, distributed over
30:      *    fulfillment centers 1, 2, and 3. You can use this to test if the appropriate fulfillment center is found
31:      *    for a shopping cart with only merchandise 7 in it, but with different quantities (<= 3, or > 3).
32:      *  - The other merchandises (8 - 14) have also a random inventory between 30 and 130, all distributed
33:      *    over several fulfillment centers. The distribution is done as follows:
34:      *    Assume that the merchandise is available in <n> fulfillment centers. Then the first <n-1> fulfillment centers
35:      *    in the list (in ascending sequence) contain 3, and all the remaining inventory is in the
36:      *    last fulfillment center.
37:      *
38:      *    This is how the inventory of merchandises could be distributed
39:      *    (Wx = fulfillment center x with its zip code, Px = merchandise x,
40:      *    numbers marked with (*) are random large numbers):
41:      *
42:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
43:      *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
44:      *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
45:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
46:      *    | P0   |      |     |     |      |     |      |     |       |      |     |
47:      *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
48:      *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
49:      *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
50:      *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
51:      *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
52:      *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
53:      *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
54:      *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
55:      *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
56:      *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
57:      *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
58:      *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
59:      *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
60:      *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
61:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
62:      *
63:      * @param withInventory if true, the inventory of the merchandises is added to the fulfillment center. Otherwise, the
64:      *                           the inventory is not added and the fulfillment center is empty.
65:      */
66:     public void addAllFulfillmentCenters( boolean withInventory );
67: 
68: 
69:     /**
70:      * @return the number of test fulfillment centers in the database
71:      */
72:     int numberOfFulfillmentCenters();
73: 
74: 
75:     /**
76:      * @param index
77:      * @return the id of the test fulfillment center at the given index
78:      */
79:     UUID getFulfillmentCenterId( int index );
80: 
81: 
82:     /**
83:      * @param fulfillmentCenterId - the id of the fulfillment center in the test data
84:      * @return the index of the test fulfillment center with that id
85:      */
86:     int findFulfillmentCenterIndex( UUID fulfillmentCenterId );
87: 
88: 
89:     /**
90:      * @param merchandiseIndex - the index of the merchandise in the test data
91:      * @param fulfillmentCenterIndex - the index of the fulfillment center in the test data
92:      * @return the number of merchandises (inventory) available in the fulfillment center at the given index
93:      */
94:     Integer getFulfillmentCenterInventory( int fulfillmentCenterIndex, int merchandiseIndex );
95: 
96: }
97: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\CustomerTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
7: import thkoeln.archilab.ecommerce.usecases.CustomerType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.MockCustomer;
12: 
13: import static org.junit.jupiter.api.Assertions.assertThrows;
14: 
15: /**
16:  * This is a test helper class that initializes and registers customers in the system,
17:  * using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class CustomerTestHelperImpl implements CustomerTestHelper {
22: 
23:     private CustomerRegistrationUseCases customerRegistrationUseCases;
24: 
25:     @Autowired
26:     public CustomerTestHelperImpl( CustomerRegistrationUseCases customerRegistrationUseCases ) {
27:         this.customerRegistrationUseCases = customerRegistrationUseCases;
28:     }
29: 
30:     private final static String[] CUSTOMER_NAME = new String[]{
31:             "Max Mueller",
32:             "Sophie Schmitz",
33:             "Irene Mihalic",
34:             "Emilia Fischer",
35:             "Filiz Polat",
36:             "Lina Wagner",
37:             "Leon Becker",
38:             "Agnieszka Kalterer",
39:             "Felix Bauer",
40:             "Lara Schulz"
41:     };
42: 
43:     private final static MailAddressType[] CUSTOMER_EMAIL = new MailAddressType[]{
44:             FactoryMethodInvoker.instantiateMailAddress( "99Z@example.com" ),
45:             FactoryMethodInvoker.instantiateMailAddress( "a@4.com" ),
46:             FactoryMethodInvoker.instantiateMailAddress( "irene@wearefreedomnow.com" ),
47:             FactoryMethodInvoker.instantiateMailAddress( "emilia.fischer@example.com" ),
48:             FactoryMethodInvoker.instantiateMailAddress( "j877d3@example.this.com" ),
49:             FactoryMethodInvoker.instantiateMailAddress( "lina.marie.wagner@example.com" ),
50:             FactoryMethodInvoker.instantiateMailAddress( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
51:             FactoryMethodInvoker.instantiateMailAddress( "agna@here.ch" ),
52:             FactoryMethodInvoker.instantiateMailAddress( "felix.bauer@example.org" ),
53:             FactoryMethodInvoker.instantiateMailAddress( "lara.schulz@example.at" )
54:     };
55: 
56:     // The following array is used to create a list of physicalAddresss for the customers.
57:     // The indices are coded into the house number.
58:     // - Persons 0 - 5 are used for proximity tests with one fulfillment center.
59:     private final static PhysicalAddressType[] CUSTOMER_ADDRESS = new PhysicalAddressType[]{
60:             FactoryMethodInvoker.instantiatePhysicalAddress(
61:                     "Marktstraße 0", "Viertelstadt",
62:                     FactoryMethodInvoker.instantiateZipCode( "02314" ) ),
63:             FactoryMethodInvoker.instantiatePhysicalAddress(
64:                     "Hauptstraße 1", "Viertelstadt",
65:                     FactoryMethodInvoker.instantiateZipCode( "02368" ) ),
66:             FactoryMethodInvoker.instantiatePhysicalAddress(
67:                     "Kirchplatz 2", "Niemandstown",
68:                     FactoryMethodInvoker.instantiateZipCode( "12345" ) ),
69:             FactoryMethodInvoker.instantiatePhysicalAddress(
70:                     "Schulstraße 3", "Geisterhausen",
71:                     FactoryMethodInvoker.instantiateZipCode( "31463" ) ),
72:             FactoryMethodInvoker.instantiatePhysicalAddress(
73:                     "Rosenweg 4", "Kuhhausen",
74:                     FactoryMethodInvoker.instantiateZipCode( "72162" ) ),
75:             FactoryMethodInvoker.instantiatePhysicalAddress(
76:                     "Wiesenstraße 5", "Waldschenkensdorf",
77:                     FactoryMethodInvoker.instantiateZipCode( "82195" ) ),
78:             FactoryMethodInvoker.instantiatePhysicalAddress(
79:                     "Muehlenweg 6", "Koeln",
80:                     FactoryMethodInvoker.instantiateZipCode( "50667" ) ),
81:             FactoryMethodInvoker.instantiatePhysicalAddress(
82:                     "Goethestraße 7", "Frankfurt am Main",
83:                     FactoryMethodInvoker.instantiateZipCode( "60311" ) ),
84:             FactoryMethodInvoker.instantiatePhysicalAddress(
85:                     "Dorfstraße 8", "Stuttgart",
86:                     FactoryMethodInvoker.instantiateZipCode( "70173" ) ),
87:             FactoryMethodInvoker.instantiatePhysicalAddress(
88:                     "Bahnhofstraße 9", "Muenchen",
89:                     FactoryMethodInvoker.instantiateZipCode( "80331" ) )
90:     };
91: 
92:     private final static CustomerType[] mockCustomers;
93: 
94:     static {
95:         mockCustomers = new CustomerType[CUSTOMER_NAME.length];
96:         for ( int i = 0; i < CUSTOMER_NAME.length; i++ ) {
97:             mockCustomers[i] = new MockCustomer(
98:                     CUSTOMER_NAME[i], CUSTOMER_EMAIL[i], CUSTOMER_ADDRESS[i] );
99:         }
100:     }
101: 
102: 
103:     @Override
104:     public void registerAllCustomers() {
105:         for ( int i = 0; i < CUSTOMER_NAME.length; i++ ) {
106:             registerCustomer( CUSTOMER_NAME[i], CUSTOMER_EMAIL[i], CUSTOMER_ADDRESS[i] );
107:         }
108:     }
109: 
110: 
111:     private void registerCustomer( String name, MailAddressType mailAddress, PhysicalAddressType physicalAddress ) {
112:         customerRegistrationUseCases.register( name, mailAddress, physicalAddress );
113:     }
114: 
115: 
116:     @Override
117:     public int getNumberOfCustomers() {
118:         return CUSTOMER_NAME.length;
119:     }
120: 
121: 
122:     @Override
123:     public String getCustomerName( int index ) {
124:         if ( index < 0 || index >= CUSTOMER_NAME.length ) {
125:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
126:         }
127:         return CUSTOMER_NAME[index];
128:     }
129: 
130: 
131:     @Override
132:     public MailAddressType getCustomerMailAddress( int index ) {
133:         if ( index < 0 || index >= CUSTOMER_NAME.length ) {
134:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
135:         }
136:         return CUSTOMER_EMAIL[index];
137:     }
138: 
139: 
140:     @Override
141:     public PhysicalAddressType getCustomerPhysicalAddress( int index ) {
142:         if ( index < 0 || index >= CUSTOMER_NAME.length ) {
143:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
144:         }
145:         return CUSTOMER_ADDRESS[index];
146:     }
147: 
148: 
149:     @Override
150:     public CustomerType getCustomer( int index ) {
151:         if ( index < 0 || index >= CUSTOMER_NAME.length ) {
152:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
153:         }
154:         return mockCustomers[index];
155:     }
156: }
157: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\InventoryTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
7: import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
8: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
12: 
13: import java.util.*;
14: 
15: /**
16:  * This is a test helper class that initializes and registers merchandises (but without inventory)
17:  * in the system, using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class InventoryTestHelperImpl
22:                         implements MerchandiseTestHelper, FulfillmentCenterTestHelper {
23:     private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
24:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
25:     private static Random random = new Random();
26: 
27:     private static final String EUR = "EUR";
28:     private static final int MERCHANDISE_NUMOF = 15;
29:     private static final Object[][] MERCHANDISE_DATA = new Object[][]{
30:             {null, "0-TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
31:                     1.5f, FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
32:                     FactoryMethodInvoker.instantiateMoney( 10.0f, EUR ),
33:                     "0"},
34:             {null, "1-EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
35:                     0.3f, FactoryMethodInvoker.instantiateMoney( 2.5f, EUR ),
36:                     FactoryMethodInvoker.instantiateMoney( 4.0f, EUR ),
37:                     "0"},
38:             {null, "2-MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
39:                     7.2f, FactoryMethodInvoker.instantiateMoney( 50.0f, EUR ),
40:                     FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
41:                     "0"},
42:             {null, "3-Gh-25", "Kompakter und leichter Akku für mobile Geräte",
43:                     null, FactoryMethodInvoker.instantiateMoney( 6.0f, EUR ),
44:                     FactoryMethodInvoker.instantiateMoney( 8.0f, EUR ),
45:                     "0"},
46:             {null, "4-MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
47:                     null, FactoryMethodInvoker.instantiateMoney( 0.6f, EUR ),
48:                     FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
49:                     "0"},
50:             {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
51:                     1.0f, FactoryMethodInvoker.instantiateMoney( 150.0f, EUR ),
52:                     FactoryMethodInvoker.instantiateMoney( 250.0f, EUR ),
53:                     "0"},
54:             {null, "6-Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
55:                     null, FactoryMethodInvoker.instantiateMoney( 0.3f, EUR ),
56:                     FactoryMethodInvoker.instantiateMoney( 0.5f, EUR ),
57:                     "0"},
58:             {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
59:                     6.0f, FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
60:                     FactoryMethodInvoker.instantiateMoney( 120.0f, EUR ),
61:                     "123"},
62:             {null, "8-JKL-67", "Wasserdichtes Gehäuse",
63:                     3.0f, FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
64:                     FactoryMethodInvoker.instantiateMoney( 1.2f, EUR ),
65:                     "467"},
66:             {null, "9-MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
67:                     5.5f, FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
68:                     FactoryMethodInvoker.instantiateMoney( 45.0f, EUR ),
69:                     "578"},
70:             {null, "10-PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
71:                     4.0f, FactoryMethodInvoker.instantiateMoney( 20.0f, EUR ),
72:                     FactoryMethodInvoker.instantiateMoney( 35.0f, EUR ),
73:                     "567"},
74:             {null, "11-STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
75:                     null, FactoryMethodInvoker.instantiateMoney( 200.0f, EUR ),
76:                     FactoryMethodInvoker.instantiateMoney( 350.0f, EUR ),
77:                     "478"},
78:             {null, "12-VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
79:                     null, FactoryMethodInvoker.instantiateMoney( 15.0f, EUR ),
80:                     FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
81:                     "5"},
82:             {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
83:                     3.5f, FactoryMethodInvoker.instantiateMoney( 60.0f, EUR ),
84:                     FactoryMethodInvoker.instantiateMoney( 100.0f, EUR ),
85:                     "78"},
86:             {null, "14-Nosedive", "Klammer zum Verschließen der Nase beim Tauchen",
87:                     5.0f, FactoryMethodInvoker.instantiateMoney( 2.0f, EUR ),
88:                     FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
89:                     "457"}
90:     };
91:     
92: 
93:     // These physical addresss are used for the fulfillment centers. The fulfillment center name will equal
94:     // the zip code of the site. Their index number will be visible in the house number.
95:     // The fulfillment centers are used as such:
96:     // - fulfillment center 0 is holds all merchandises 0 - 6, and is used for all tests where multiple
97:     //   shipments are irrelevant.
98:     // - fulfillment centers 1 - 3 are used for the proximity tests, where you can deliver merchandises 7 to
99:     //   to a customer from the closest fulfillment center.
100:     // - fulfillment centers 4 - 8 are used for the tests where you need to deliver merchandises 8 - 14 in
101:     //   the most cost-efficient way, as multiple shipments.
102:     // - fulfillment center 9 is empty.
103:     private final static int FULFILLMENT_CENTER_NUMOF = 10;
104:     private final static PhysicalAddressType[] FULFILLMENT_CENTER_PHYSICAL_ADDRESS = new PhysicalAddressType[]{
105:             FactoryMethodInvoker.instantiatePhysicalAddress(
106:                     "Stapelallee 0", "Potsdam",
107:                     FactoryMethodInvoker.instantiateZipCode( "14476" ) ),
108:             FactoryMethodInvoker.instantiatePhysicalAddress(
109:                     "Lagerhausstr. 1", "Viertelstadt",
110:                     FactoryMethodInvoker.instantiateZipCode( "02345" ) ),
111:             FactoryMethodInvoker.instantiatePhysicalAddress(
112:                     "Speicherplatz 2", "Viertelstadt",
113:                     FactoryMethodInvoker.instantiateZipCode( "02313" ) ),
114:             FactoryMethodInvoker.instantiatePhysicalAddress(
115:                     "Ablageweg 3", "Reichswürgen",
116:                     FactoryMethodInvoker.instantiateZipCode( "44923" ) ),
117:             FactoryMethodInvoker.instantiatePhysicalAddress(
118:                     "Paketstellenallee 4", "Düsseldorf",
119:                     FactoryMethodInvoker.instantiateZipCode( "40588" ) ),
120:             FactoryMethodInvoker.instantiatePhysicalAddress(
121:                     "Kaputte-Sachen-Straße 5", "Düren",
122:                     FactoryMethodInvoker.instantiateZipCode( "52355" ) ),
123:             FactoryMethodInvoker.instantiatePhysicalAddress(
124:                     "Aufbewahrungsweg 6", "Viernheim",
125:                     FactoryMethodInvoker.instantiateZipCode( "68519" ) ),
126:             FactoryMethodInvoker.instantiatePhysicalAddress(
127:                     "Paketallee 7", "Baden-Baden",
128:                     FactoryMethodInvoker.instantiateZipCode( "76532" ) ),
129:             FactoryMethodInvoker.instantiatePhysicalAddress(
130:                     "Sendenstr. 8", "Senden",
131:                     FactoryMethodInvoker.instantiateZipCode( "89250" ) ),
132:             FactoryMethodInvoker.instantiatePhysicalAddress(
133:                     "Schickweg 9", "Hohenroth",
134:                     FactoryMethodInvoker.instantiateZipCode( "97618" ) )
135:     };
136:     private final static UUID[] FULFILLMENT_CENTER_ID = new UUID[FULFILLMENT_CENTER_NUMOF];
137: 
138: 
139:     // These data structures contain the inventory of the merchandises in the fulfillment centers.
140:     // MERCHANDISE_INVENTORY is a map merchandise name -> Integer[FULFILLMENT_CENTER_NUMOF].
141:     // The Integer[FULFILLMENT_CENTER_NUMOF] contains the inventory of the merchandise in each of
142:     // the fulfillment centers.
143:     //
144:     // The following rules apply:
145:     // - merchandise 0 is out of inventory
146:     // - merchandise 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in fulfillment center 0
147:     // - merchandise 4 / 5 / 6 have a random inventory between 30 and 130, also all ONLY in fulfillment center 0
148:     //   (these are the merchandises used for tests on how to add and remove inventory)
149:     // - the others have a random inventory between 30 and 130, distributed over several
150:     //   fulfillment centers. Here we follow this convention for simplicity:
151:     //   - Assume that the merchandise is available in <n> fulfillment centers. Then the first <n-1> fulfillment centers
152:     //     in the list (in ascending sequence) contain 3, and all the remaining inventory is in the
153:     //     last fulfillment center.
154: 
155:     private static final Map<String, Integer[]> MERCHANDISE_INVENTORY = new HashMap<>();
156: 
157:     static {
158:         // merchandises 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
159:         MERCHANDISE_INVENTORY.put( (String) MERCHANDISE_DATA[0][1],
160:                 getInventoryDistribution( 0, (String) MERCHANDISE_DATA[0][6] ) );
161:         MERCHANDISE_INVENTORY.put( (String) MERCHANDISE_DATA[1][1],
162:                 getInventoryDistribution( 10, (String) MERCHANDISE_DATA[1][6] ) );
163:         MERCHANDISE_INVENTORY.put( (String) MERCHANDISE_DATA[2][1],
164:                 getInventoryDistribution( 20, (String) MERCHANDISE_DATA[2][6] ) );
165:         MERCHANDISE_INVENTORY.put( (String) MERCHANDISE_DATA[3][1],
166:                 getInventoryDistribution( 30, (String) MERCHANDISE_DATA[3][6] ) );
167: 
168:         // The other merchandises have a random inventory between 30 and 130,
169:         for ( int i = 4; i < MERCHANDISE_NUMOF; i++ ) {
170:             Integer totalNumber = random.nextInt( 100 ) + 30;
171:             Integer[] inventoryInFulfillmentCenters =
172:                     getInventoryDistribution( totalNumber, (String) MERCHANDISE_DATA[i][6] );
173:             MERCHANDISE_INVENTORY.put( (String) MERCHANDISE_DATA[i][1], inventoryInFulfillmentCenters );
174:         }
175:     }
176: 
177:     /**
178:      * This method creates a random inventory distribution for the given merchandise.
179:      *
180:      * @param totalQuantity - the total number of merchandises in the fulfillment centers
181:      * @param zeroToNine  - a string with numbers between 0 and 9, representing the fulfillment centers
182:      * @return an Integer array with the inventory distribution for the merchandise, according to
183:      * the rules described above.
184:      */
185:     private static Integer[] getInventoryDistribution( Integer totalQuantity, String zeroToNine ) {
186:         Integer[] inventoryInFulfillmentCenters = new Integer[FULFILLMENT_CENTER_NUMOF];
187:         for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) inventoryInFulfillmentCenters[i] = 0;
188:         TreeSet<Integer> fulfillmentCenterIndices = getFulfillmentCenterIndices( zeroToNine );
189:         int numOfIndices = fulfillmentCenterIndices.size();
190:         int currentIndexNumber = 0;
191:         int currentQuantity = totalQuantity;
192:         for ( Integer fulfillmentCenterIndex : fulfillmentCenterIndices ) {
193:             currentIndexNumber++;
194:             if ( currentIndexNumber < numOfIndices ) {
195:                 inventoryInFulfillmentCenters[fulfillmentCenterIndex] = 3;
196:                 currentQuantity -= 3;
197:             } else {
198:                 inventoryInFulfillmentCenters[fulfillmentCenterIndex] = currentQuantity;
199:             }
200:         }
201:         return inventoryInFulfillmentCenters;
202:     }
203: 
204:     private static TreeSet<Integer> getFulfillmentCenterIndices( String zeroToNine ) {
205:         TreeSet<Integer> fulfillmentCenterIndices = new TreeSet<>();
206:         for ( int i = 0; i < zeroToNine.length(); i++ ) {
207:             fulfillmentCenterIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
208:         }
209:         return fulfillmentCenterIndices;
210:     }
211: 
212: 
213:     @Autowired
214:     public InventoryTestHelperImpl( MerchandiseCatalogUseCases merchandiseCatalogUseCases,
215:                                          FulfillmentCenterUseCases fulfillmentCenterUseCases ) {
216:         this.merchandiseCatalogUseCases = merchandiseCatalogUseCases;
217:         this.fulfillmentCenterUseCases = fulfillmentCenterUseCases;
218:     }
219: 
220: 
221:     @Override
222:     public void addAllMerchandises() {
223:         int i = 0;
224:         for ( Object[] merchandiseData : MERCHANDISE_DATA ) {
225:             UUID newId = merchandiseCatalogUseCases.addMerchandiseToCatalog(
226:                     (String) merchandiseData[1], (String) merchandiseData[2],
227:                     (Float) merchandiseData[3], (MoneyType) merchandiseData[4],
228:                     (MoneyType) merchandiseData[5] );
229:             // The first element of the merchandise data is the id, which was initialized with null before, but can now be set
230:             MERCHANDISE_DATA[i][0] = newId;
231:             i++;
232:         }
233:     }
234: 
235: 
236:     @Override
237:     public int numberOfMerchandises() {
238:         return MERCHANDISE_NUMOF;
239:     }
240: 
241: 
242:     @Override
243:     public UUID getMerchandiseId( int index ) {
244:         if ( index < 0 || index >= MERCHANDISE_NUMOF ) {
245:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
246:         }
247:         return (UUID) MERCHANDISE_DATA[index][0];
248:     }
249: 
250: 
251:     @Override
252:     public MoneyType getBuyingPrice( int index ) {
253:         if ( index < 0 || index >= MERCHANDISE_NUMOF ) {
254:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
255:         }
256:         return (MoneyType) MERCHANDISE_DATA[index][4];
257:     }
258: 
259: 
260:     @Override
261:     public MoneyType getSalesPrice( int index ) {
262:         if ( index < 0 || index >= MERCHANDISE_NUMOF ) {
263:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
264:         }
265:         return (MoneyType) MERCHANDISE_DATA[index][5];
266:     }
267: 
268: 
269:     @Override
270:     public void addAllFulfillmentCenters( boolean withInventory ) {
271:         for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) {
272:             FULFILLMENT_CENTER_ID[i] = fulfillmentCenterUseCases.addNewFulfillmentCenter(
273:                     FULFILLMENT_CENTER_PHYSICAL_ADDRESS[i].getStreet(),
274:                     FULFILLMENT_CENTER_PHYSICAL_ADDRESS[i] );
275:         }
276:         if ( withInventory ) {
277:             addAllInventory();
278:         }
279:     }
280: 
281: 
282:     private void addAllInventory() {
283:         for ( Object[] merchandiseData : MERCHANDISE_DATA ) {
284:             Integer[] inventoryInFulfillmentCenters =
285:                     MERCHANDISE_INVENTORY.get( merchandiseData[1] );
286:             for ( int iFulfillmentCenter = 0; iFulfillmentCenter < FULFILLMENT_CENTER_NUMOF; iFulfillmentCenter++ ) {
287:                 if ( inventoryInFulfillmentCenters[iFulfillmentCenter] > 0 )
288:                     fulfillmentCenterUseCases.addToInventory(
289:                             FULFILLMENT_CENTER_ID[iFulfillmentCenter], (UUID) merchandiseData[0],
290:                             inventoryInFulfillmentCenters[iFulfillmentCenter] );
291:             }
292:         }
293:     }
294: 
295: 
296:     @Override
297:     public int numberOfFulfillmentCenters() {
298:         return FULFILLMENT_CENTER_NUMOF;
299:     }
300: 
301: 
302:     @Override
303:     public UUID getFulfillmentCenterId( int index ) {
304:         if ( index < 0 || index >= FULFILLMENT_CENTER_NUMOF ) {
305:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
306:         }
307:         return FULFILLMENT_CENTER_ID[index];
308:     }
309: 
310: 
311:     @Override
312:     public Integer getFulfillmentCenterInventory( int fulfillmentCenterIndex, int merchandiseIndex ) {
313:         if ( fulfillmentCenterIndex < 0 || fulfillmentCenterIndex >= FULFILLMENT_CENTER_NUMOF ) {
314:             throw new IndexOutOfBoundsException( "Index out of bounds: " + fulfillmentCenterIndex );
315:         }
316:         if ( merchandiseIndex < 0 || merchandiseIndex >= MERCHANDISE_NUMOF ) {
317:             throw new IndexOutOfBoundsException( "Index out of bounds: " + merchandiseIndex );
318:         }
319:         String merchandiseName = (String) MERCHANDISE_DATA[merchandiseIndex][1];
320:         Integer[] inventoryInFulfillmentCenters = MERCHANDISE_INVENTORY.get( merchandiseName );
321:         Integer foundInventory = inventoryInFulfillmentCenters[fulfillmentCenterIndex];
322:         return foundInventory == null ? 0 : foundInventory;
323:     }
324: 
325: 
326:     @Override
327:     public int findFulfillmentCenterIndex( UUID fulfillmentCenterId ) {
328:         for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) {
329:             if ( FULFILLMENT_CENTER_ID[i].equals( fulfillmentCenterId ) ) {
330:                 return i;
331:             }
332:         }
333:         throw new IllegalArgumentException( "No test fulfillment center with UUID id " + fulfillmentCenterId );
334:     }
335: 
336: 
337:     @Override
338:     public int findMerchandiseIndex( UUID merchandiseId ) {
339:         for ( int iMerchandiseData = 0; iMerchandiseData < FULFILLMENT_CENTER_NUMOF; iMerchandiseData++ ) {
340:             Object[] merchandiseData = MERCHANDISE_DATA[iMerchandiseData];
341:             if ( merchandiseData[0].equals( merchandiseId ) ) {
342:                 return iMerchandiseData;
343:             }
344:         }
345:         throw new IllegalArgumentException( "No test merchandise with UUID id " + merchandiseId );
346:     }
347: }
348: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MerchandiseTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
4: 
5: import java.util.UUID;
6: 
7: public interface MerchandiseTestHelper {
8:     /**
9:      * Adds all test merchandises to the database.
10:      * If you use the debugger and want to identify _which_ test merchandise you currently look at:
11:      * The indices are coded into the first number in the name string of the merchandise, like e.g.
12:      * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
13:      */
14:     void addAllMerchandises();
15: 
16: 
17:     /**
18:      * @return the number of test merchandises in the database
19:      */
20:     int numberOfMerchandises();
21: 
22: 
23:     /**
24:      * @param index
25:      * @return the id of the test merchandise at the given index
26:      */
27:     UUID getMerchandiseId( int index );
28: 
29: 
30:     /**
31:      * @param merchandiseId - the id of the merchandise in the test data
32:      * @return the index of the test merchandise with that id
33:      */
34:     int findMerchandiseIndex( UUID merchandiseId );
35: 
36: 
37:     /**
38:      * @param index
39:      * @return the buying price of test merchandise at the given index
40:      */
41:     MoneyType getBuyingPrice( int index );
42: 
43: 
44:     /**
45:      * @param index
46:      * @return the sales price of test merchandise at the given index
47:      */
48:     MoneyType getSalesPrice( int index );
49: }
50: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockCustomer.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.Setter;
4: import thkoeln.archilab.ecommerce.usecases.CustomerType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;
6: 
7: 
8: import java.util.Objects;
9: 
10: @Setter
11: public class MockCustomer implements CustomerType {
12:     private String name;
13:     private MailAddressType mailAddressType;
14:     private PhysicalAddressType physicalAddressType;
15: 
16: 
17:     public MockCustomer( String name, MailAddressType mailAddressType, PhysicalAddressType physicalAddressType) {
18:         this.name = name;
19:         this.mailAddressType = mailAddressType;
20:         this.physicalAddressType = physicalAddressType;
21:     }
22: 
23:     @Override
24:     public String getName() {
25:         return name;
26:     }
27: 
28:     @Override
29:     public MailAddressType getMailAddress() {
30:         return mailAddressType;
31:     }
32: 
33:     @Override
34:     public PhysicalAddressType getPhysicalAddress() {
35:         return physicalAddressType;
36:     }
37: 
38:     @Override
39:     public boolean equals( Object o ) {
40:         if ( this == o ) return true;
41:         if ( !( o instanceof MockCustomer ) ) return false;
42:         MockCustomer that = (MockCustomer) o;
43:         return Objects.equals( getName(), that.getName() ) &&
44:                 Objects.equals( mailAddressType, that.mailAddressType ) &&
45:                 Objects.equals( physicalAddressType, that.physicalAddressType );
46:     }
47: 
48:     @Override
49:     public int hashCode() {
50:         return Objects.hash( getName(), mailAddressType, physicalAddressType );
51:     }
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.usecases.*;
6: 
7: /**
8:  * Removes everything :-)
9:  */
10: @Service
11: public class Purgatory {
12:     @Autowired
13:     private CustomerRegistrationUseCases customerRegistrationUseCases;
14:     @Autowired
15:     private ShoppingCartUseCases shoppingCartUseCases;
16:     @Autowired
17:     private PurchaseUseCases purchaseUseCases;
18:     @Autowired
19:     private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
20:     @Autowired
21:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
22: 
23:     public void deleteEverything() {
24:         purchaseUseCases.deleteAllPurchases();
25:         shoppingCartUseCases.emptyAllShoppingCarts();
26:         fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
27:         customerRegistrationUseCases.deleteAllCustomers();
28:         merchandiseCatalogUseCases.deleteMerchandiseCatalog();
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.context.ApplicationListener;
6: import org.springframework.context.annotation.Profile;
7: import org.springframework.context.event.ContextRefreshedEvent;
8: import org.springframework.stereotype.Component;
9: import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
12: 
13: @Component
14: @Slf4j
15: @Profile("!test")
16: @SuppressWarnings("PMD")
17: public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
18:     private Purgatory purgatory;
19:     private CustomerTestHelper customerTestHelper;
20:     private MerchandiseTestHelper merchandiseTestHelper;
21:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
22: 
23: 
24:     @Autowired
25:     public StartupListener( Purgatory purgatory,
26:                             CustomerTestHelper customerTestHelper,
27:                             MerchandiseTestHelper merchandiseTestHelper,
28:                             FulfillmentCenterTestHelper fulfillmentCenterTestHelper ) {
29:         this.purgatory = purgatory;
30:         this.customerTestHelper = customerTestHelper;
31:         this.merchandiseTestHelper = merchandiseTestHelper;
32:         this.fulfillmentCenterTestHelper = fulfillmentCenterTestHelper;
33:     }
34: 
35:     @Override
36:     public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
37:         log.info( "StartupListener initializing master data ..." );
38:         purgatory.deleteEverything();
39:         customerTestHelper.registerAllCustomers();
40:         merchandiseTestHelper.addAllMerchandises();
41:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
42:     }
43: }
44: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\MerchandiseCatalogUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: 
10: import java.util.UUID;
11: 
12: 
13: /**
14:  * This interface contains methods needed in the context of use cases concerning the merchandise catalog.
15:  * The interface is probably incomplete, and will grow over time ...
16:  */
17: 
18: public interface MerchandiseCatalogUseCases {
19:     /**
20:      * Adds a new merchandise to the shop catalog
21:      * @param name
22:      * @param descriptFor
23:      * @param size
24:      * @param buyingPrice
25:      * @param salesPrice
26:      * @return the id of the new merchandise
27:      * @throws ShopException if ...
28:      *      - the merchandise id already exists,
29:      *      - name or description are null or empty,
30:      *      - the size is <= 0 (but can be null!),
31:      *      - the buying price is null or <= 0,
32:      *      - the buyingPrice is null,
33:      *      - the sales price is null,
34:      *      - the sales price is lower than the buyingPrice
35:      */
36:     public UUID addMerchandiseToCatalog( String name, String descriptFor, Float size,
37:                                            MoneyType buyingPrice, MoneyType salesPrice );
38: 
39: 
40:     /**
41:      * Removes a merchandise from the shop catalog
42:      * @param merchandiseId
43:      * @throws ShopException if
44:      *      - merchandiseId is null
45:      *      - the merchandise id does not exist
46:      *      - the merchandise is still in inventory
47:      *      - the merchandise is still in a shopping cart, or referenced by a completed purchase
48:      */
49:     public void removeMerchandiseFromCatalog( UUID merchandiseId );
50: 
51: 
52:     /**
53:      * Get the sales price of a given merchandise
54:      * @param merchandiseId
55:      * @return the sales price
56:      * @throws ShopException if ...
57:      *      - merchandiseId is null,
58:      *      - the merchandise with that id does not exist
59:      */
60:     public MoneyType getSalesPrice( UUID merchandiseId );
61: 
62: 
63:     /**
64:      * Clears the merchandise catalog, i.e. removes all merchandises from the catalog, including all the inventory,
65:      * all the reservations and all the purchases.
66:      */
67:     public void deleteMerchandiseCatalog();
68: 
69: }
70: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\PurchaseUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: package thkoeln.archilab.ecommerce.usecases;
5: 
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
9: 
10: import java.util.Map;
11: import java.util.UUID;
12: 
13: /**
14:  * This interface contains methods needed in the context of the purchase history of a customer.
15:  */
16: public interface PurchaseUseCases {
17: 
18:     /**
19:      * Returns a map showing which merchandises have been purchased by a customer and how many of each merchandise
20:      *
21:      * @param customerMailAddress
22:      * @return the purchase history of the customer (map is empty if the customer has not purchased anything yet)
23:      * @throws ShopException if
24:      *      - customerMailAddress is null
25:      *      - the customer with the given mail address does not exist
26:      */
27:     public Map<UUID, Integer> getPurchaseHistory( MailAddressType customerMailAddress );
28: 
29: 
30: 
31:     /**
32:      * @return the number of merchandises in a given purchase. If the merchandise is not a part of the purchase, the method
33:      *         returns 0. No exception is thrown.
34:      * @param purchaseId - the id of the purchase to be checked
35:      * @param merchandiseId - the id of the merchandise for which we want to know the quantity
36:      * @throws ShopException if
37:      *     - purchaseId is null, or doesn't exist in the system
38:      *     - merchandiseId is null, or doesn't exist in the system
39:      */
40:     public Integer getPurchaseQuantiOfMerchandise( UUID purchaseId, UUID merchandiseId );
41: 
42: 
43:     /**
44:      * @return the id of the fulfillment center that is responsible for the given purchase
45:      * @param purchaseId - the id of the purchase to be checked
46:      * @throws ShopException if
47:      *      - purchaseId is null, or doesn't exist in the system
48:      */
49:     public UUID getFulfillmentCenterIdForPurchase( UUID purchaseId );
50: 
51: 
52:     /**
53:      * Deletes all purchases in the system
54:      */
55:     public void deleteAllPurchases();
56: }
57: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingCartUseCases.java ---
1: /*
2:  * Copyright ArchiLab 2025. All rights reserved.
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
10: 
11: import java.util.Map;
12: import java.util.Set;
13: import java.util.UUID;
14: 
15: /**
16:  * This interface contains methods needed in the context of use cases handling the shopping cart.
17:  * The interface is probably incomplete, and will grow over time ...
18:  */
19: public interface ShoppingCartUseCases {
20:     /**
21:      * Adds a merchandise to the cart of a customer
22:      *
23:      * @param customerMailAddress
24:      * @param merchandiseId
25:      * @param quantiOf
26:      * @throws ShopException if ...
27:      *          - customerMailAddress is null,
28:      *          - the customer with the given mail address does not exist,
29:      *          - merchandiseId is null,
30:      *          - the merchandise with merchandiseId does not exist
31:      *          - the Quantity is negative,
32:      */
33:     public void addMerchandiseToShoppingCart( MailAddressType customerMailAddress,
34:                                                  UUID merchandiseId, int quantiOf );
35: 
36: 
37:     /**
38:      * Removes a merchandise from the cart of a customer
39:      *
40:      * @param customerMailAddress
41:      * @param merchandiseId
42:      * @param quantiOf
43:      * @throws ShopException if ...
44:      *          - customerMailAddress is null,
45:      *          - the customer with the given mail address does not exist,
46:      *          - merchandiseId is null,
47:      *          - the merchandise with merchandiseId does not exist
48:      *          - the Quantity is negative
49:      *          - the merchandise is not in the shopping cart in the requested Quantity
50:      */
51:     public void removeMerchandiseFromShoppingCart( MailAddressType customerMailAddress,
52:                                                       UUID merchandiseId, int quantiOf );
53: 
54: 
55:     /**
56:      * Returns a map showing which merchandises are in the cart of a customer and how many of each merchandise
57:      *
58:      * @param customerMailAddress
59:      * @return the cart of the customer (map is empty if the cart is empty)
60:      * @throws ShopException if
61:      *          - customerMailAddress is null,
62:      *          - the customer with the given mail address does not exist
63:      */
64:     public Map<UUID, Integer> getShoppingCartAsMap( MailAddressType customerMailAddress );
65: 
66: 
67:     /**
68:      * Returns the current value of all merchandises in the cart of a customer
69:      *
70:      * @param customerMailAddress
71:      * @return the cart of the customer
72:      * @throws ShopException if
73:      *          - customerMailAddress is null,
74:      *          - the customer with the given mail address does not exist
75:      */
76:     public MoneyType getShoppingCartAsMoneyValue( MailAddressType customerMailAddress );
77: 
78: 
79: 
80: 
81:     /**
82:      * Checks out the cart of a customer
83:      *
84:      * @param customerMailAddress
85:      * @return A set of ids belonging to purchases that were created during the checkout. If the shopping cart can
86:      *         only be served from more than one fulfillment center, each shipment from a fulfillment center gets a
87:      *         dedicated purchase. I.e. if there is just one shipment, then the set will contain just one purchase id.
88:      *         If there are multiple shipments, the set will contain multiple purchase ids.
89:      * @throws ShopException if
90:      *      - customerMailAddress is null or empty
91:      *      - the customer with the given mail address does not exist, or if the cart is empty
92:      * @throws
93:      *      - ShopException if customerMailAddress is null
94:      *      - InsufficientInventoryException if there is not enough inventory level for to serve the purchase
95:      *        for all merchandises in the shopping cart
96:      */
97:     public Set<UUID> checkout( MailAddressType customerMailAddress );
98: 
99: 
100:     /**
101:      * Empties all shopping carts in the system
102:      */
103:     public void emptyAllShoppingCarts();
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import org.springframework.boot.test.context.TestConfiguration;
4: import org.springframework.context.annotation.Bean;
5: import org.springframework.test.web.servlet.MockMvc;
6: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
7: import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
8: 
9: 
10: @TestConfiguration
11: public class RESTTestHelperConfiguration {
12: 
13:     @Bean
14:     public ShoppingCartRESTHelper shoppingCartRESTHelper(
15:             MockMvc mockMvc, MerchandiseCatalogUseCases merchandiseCatalogUseCases ) {
16:         return new ShoppingCartRESTHelperImpl( mockMvc, merchandiseCatalogUseCases );
17:     }
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingCartRESTHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import com.fasterxml.jackson.databind.ObjectMapper;
5: import lombok.AllArgsConstructor;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import lombok.Setter;
9: import lombok.extern.slf4j.Slf4j;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.MvcResult;
12: import org.springframework.test.web.servlet.ResultActions;
13: import org.springframework.test.web.servlet.ResultMatcher;
14: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
15: import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
18: 
19: import java.util.Map;
20: import java.util.UUID;
21: 
22: import static org.springframework.http.MediaType.APPLICATION_JSON;
23: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
24: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
25: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
26: 
27: @Slf4j
28: public class ShoppingCartRESTHelperImpl implements ShoppingCartRESTHelper {
29:     private MockMvc mockMvc;
30:     private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
31: 
32:     private static final ResultMatcher CREATED = status().isCreated();
33:     private static final ResultMatcher OK = status().isOk();
34: 
35:     public ShoppingCartRESTHelperImpl( MockMvc mockMvc, MerchandiseCatalogUseCases merchandiseCatalogUseCases ) {
36:         this.mockMvc = mockMvc;
37:         this.merchandiseCatalogUseCases = merchandiseCatalogUseCases;
38:     }
39: 
40: 
41:     @Override
42:     public UUID getQueryShoppingCart( MailAddressType mailAddress, Map<UUID, Integer> quantityMap )
43:             throws Exception {
44:         // first query the customers API to get the proper customerId
45:         UUID customerId;
46:         String customerUri = "/customers?mailAddress=" + mailAddress.toString();
47:         MvcResult customerGetResult = mockMvc.perform( get( customerUri ) )
48:                 .andExpect( status().isOk() )
49:                 .andReturn();
50:         ObjectMapper objectMapper = new ObjectMapper();
51:         IdDTO idDTO = objectMapper.readValue( customerGetResult.getResponse().getContentAsString(), IdDTO.class );
52:         customerId = idDTO.getId();
53: 
54:         // then query the shopping cart API and extract the shopping cart id
55:         String shoppingCartUri = "/shoppingCarts?customerId=" + customerId.toString();
56:         ResultActions resultActions = mockMvc.perform( get( shoppingCartUri ) )
57:                 .andExpect( status().isOk() );
58:         idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
59:         UUID shoppingCartId = idDTO.getId();
60: 
61:         // additional checks, if desired
62:         if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
63:         return shoppingCartId;
64:     }
65: 
66: 
67:     private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
68:         if ( quantityMap == null ) return;
69:         int numOfMerchandises = quantityMap.size();
70:         resultActions.andExpect( jsonPath( "$.parts.length()" ).value( numOfMerchandises ) );
71:         float totalSalesPriceAsFloat = 0f;
72:         for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
73:             UUID merchandiseId = entry.getKey();
74:             Integer quantity = entry.getValue();
75:             resultActions.andExpect( jsonPath( "$.parts.[?(@.merchandiseId == '" + merchandiseId + "')].quantity" )
76:                     .value( quantity ) );
77:             MoneyType salesPrice = merchandiseCatalogUseCases.getSalesPrice( merchandiseId );
78:             totalSalesPriceAsFloat += salesPrice.getAmount() * quantity;
79:         }
80:         // last thing - check the total sales price
81:         String totalSalesPriceString = String.format( "%.2f €", totalSalesPriceAsFloat );
82:         resultActions
83:                 .andExpect( jsonPath( "$.totalSalesPrice" ).value( totalSalesPriceString ) );
84:     }
85: 
86: 
87:     @Override
88:     public void addMerchandiseToShoppingCart( UUID shoppingCartId, UUID merchandiseId, Integer quantity )
89:             throws Exception {
90:         addMerchandiseToShoppingCart( shoppingCartId, merchandiseId, quantity, null );
91:     }
92: 
93: 
94:     @Override
95:     public void addMerchandiseToShoppingCart( UUID shoppingCartId, UUID merchandiseId, Integer quantity,
96:                                                   ResultMatcher expectedStatus ) throws Exception {
97:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
98:         ObjectMapper objectMapper = new ObjectMapper();
99:         QuantityDTO dto = new QuantityDTO( merchandiseId, quantity );
100:         String quantityJson = objectMapper.writeValueAsString( dto );
101:         mockMvc.perform( post( "/shoppingCarts/" + shoppingCartId + "/parts" )
102:                         .contentType( APPLICATION_JSON ).content( quantityJson ) )
103:                 .andExpect( status );
104:     }
105: 
106: 
107: 
108:     @Override
109:     public void deleteMerchandiseFromShoppingCart( UUID shoppingCartId, UUID merchandiseId )
110:             throws Exception {
111:         deleteMerchandiseFromShoppingCart( shoppingCartId, merchandiseId, null );
112:     }
113: 
114: 
115: 
116:     @Override
117:     public void deleteMerchandiseFromShoppingCart( UUID shoppingCartId, UUID merchandiseId,
118:                                                       ResultMatcher expectedStatus ) throws Exception {
119:         ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
120:         String uri = "/shoppingCarts/" + shoppingCartId + "/parts/" + merchandiseId;
121:         mockMvc.perform( delete( uri ) ).andExpect( status );
122:     }
123: 
124: 
125:     @Override
126:     public void checkout( UUID shoppingCartId, String expectedCustomerName,
127:                           ResultMatcher expectedStatus,
128:                           Map<UUID, Map<UUID, Integer>> expectedPurchases ) throws Exception {
129:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
130:         String uri = "/shoppingCarts/" + shoppingCartId + "/checkout";
131:         MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
132:         ObjectMapper objectMapper = new ObjectMapper();
133: 
134:         // check the response content
135:         if ( expectedPurchases != null || expectedCustomerName != null ) {
136:             String responseContent = result.getResponse().getContentAsString();
137:             log.info( "ShoppingCartRESTHelperImpl - checkout: found response content " + responseContent );
138:             PurchaseDTO[] purchases = objectMapper.readValue( responseContent, PurchaseDTO[].class );
139:             checkExpectedCustomerName( expectedCustomerName, purchases );
140:             checkExpectedPurchases( expectedPurchases, purchases );
141:         }
142:     }
143: 
144: 
145:     private void checkExpectedCustomerName( String expectedCustomerName, PurchaseDTO[] purchases ) {
146:         if ( expectedCustomerName == null ) return;
147:         for ( PurchaseDTO purchase : purchases ) {
148:             if ( !purchase.getCustomerName().equals( expectedCustomerName ) ) {
149:                 throw new AssertionError( "Expected customerName '" + expectedCustomerName +
150:                         "' but got '" + purchase.getCustomerName() + "'" );
151:             }
152:         }
153:     }
154: 
155: 
156:     private void checkExpectedPurchases( Map<UUID, Map<UUID, Integer>> expectedPurchases,
157:                                             PurchaseDTO[] purchases ) {
158:         if ( expectedPurchases == null ) return;
159:         for ( PurchaseDTO purchase : purchases ) {
160:             UUID fulfillmentCenterId = purchase.getFulfillmentCenterId();
161:             Map<UUID, Integer> expectedQuantities = expectedPurchases.get( fulfillmentCenterId );
162:             if ( expectedQuantities == null ) {
163:                 throw new AssertionError( "No expected quantities for fulfillment center " + fulfillmentCenterId );
164:             }
165:             QuantityDTO[] parts = purchase.getParts();
166:             for ( QuantityDTO quantityDTO : parts ) {
167:                 UUID merchandiseId = quantityDTO.getMerchandiseId();
168:                 Integer expectedQuantity = expectedQuantities.get( merchandiseId );
169:                 if ( expectedQuantity == null ) {
170:                     throw new AssertionError( "No expected quantity for merchandise " + merchandiseId +
171:                             " in fulfillment center " + fulfillmentCenterId );
172:                 }
173:                 if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
174:                     throw new AssertionError( "Expected quantity " + expectedQuantity + " for merchandise " +
175:                             merchandiseId + " in fulfillment center " + fulfillmentCenterId +
176:                             ", but got " + quantityDTO.getQuantity() );
177:                 }
178:             }
179:         }
180:     }
181: 
182: 
183:     /**
184:      * A DTO containing just a quantity, used in testing.
185:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
186:      * Therefore, constructors and getters/setters are manually defined.
187:      */
188:     @NoArgsConstructor
189:     @JsonIgnoreProperties(ignoreUnknown = true)
190:     private static class QuantityDTO {
191:         private UUID merchandiseId;
192:         private Integer quantity;
193: 
194:         public QuantityDTO( UUID merchandiseId, Integer quantity ) {
195:             this.merchandiseId = merchandiseId;
196:             this.quantity = quantity;
197:         }
198:         public UUID getMerchandiseId() {
199:             return merchandiseId;
200:         }
201:         public Integer getQuantity() {
202:             return quantity;
203:         }
204:         public void setMerchandiseId( UUID merchandiseId ) {
205:             this.merchandiseId = merchandiseId;
206:         }
207:         public void setQuantity( Integer quantity ) {
208:             this.quantity = quantity;
209:         }
210:     }
211: 
212: 
213:     /**
214:      * A DTO containing just the id of an entity, used in testing.
215:      */
216:     @AllArgsConstructor
217:     @NoArgsConstructor
218:     @Getter
219:     @Setter
220:     @JsonIgnoreProperties(ignoreUnknown = true)
221:     private static class IdDTO {
222:         private UUID id;
223:     }
224: 
225: 
226:     /**
227:      * A DTO containing the purchase data, used in testing.
228:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
229:      * Therefore, constructors and getters/setters are manually defined.
230:      */
231:     @NoArgsConstructor
232:     @JsonIgnoreProperties(ignoreUnknown = true)
233:     private static class PurchaseDTO {
234:         private UUID id;
235:         private String customerName;
236:         private UUID fulfillmentCenterId;
237:         private QuantityDTO[] parts;
238: 
239:         public UUID getId() {
240:             return id;
241:         }
242:         public String getCustomerName() {
243:             return customerName;
244:         }
245:         public UUID getFulfillmentCenterId() {
246:             return fulfillmentCenterId;
247:         }
248:         public QuantityDTO[] getParts() {
249:             return parts;
250:         }
251:         public void setId( UUID id ) {
252:             this.id = id;
253:         }
254:         public void setCustomerName( String customerName ) {
255:             this.customerName = customerName;
256:         }
257:         public void setFulfillmentCenterId( UUID fulfillmentCenterId ) {
258:             this.fulfillmentCenterId = fulfillmentCenterId;
259:         }
260:         public void setParts( QuantityDTO[] parts ) {
261:             this.parts = parts;
262:         }
263:     }
264: 
265: }
266: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingCartRESTHelper.java ---
1: package thkoeln.archilab.ecommerce.helpers;
2: 
3: import org.springframework.test.web.servlet.ResultMatcher;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: 
6: import java.util.Map;
7: import java.util.UUID;
8: 
9: /**
10:  * A REST helper for shopping cart-related operations.
11:  * This interface defines methods to interact with a shopping cart via REST calls, such as querying, adding,
12:  * deleting, and checking out.
13:  */
14: public interface ShoppingCartRESTHelper {
15:     /**
16:      * Executes a REST GET query on a shopping cart and returns its id, with the customer's mail address as a
17:      * starting point. The resulting shopping cart is checked against the given expected quantity map.
18:      * @param mailAddress The mailAddress of the customer whose shopping cart is queried.
19:      * @param expectedQuantityMap A map of merchandises and their quantities in the shopping cart. (If null, then don't check.)
20:      * @return The id of the customer's shopping cart.
21:      * @throws Exception (whenever the REST call fails, or the shopping cart does not match the expected quantity map)
22:      */
23:     public UUID getQueryShoppingCart( MailAddressType mailAddress,
24:                                        Map<UUID, Integer> expectedQuantityMap ) throws Exception;
25: 
26: 
27:     /**
28:      * Adds a merchandise to a shopping cart via a REST call.
29:      * @param shoppingCartId Id of the shopping cart.
30:      * @param merchandiseId Id of the merchandise.
31:      * @param quantity Quantity of the merchandise.
32:      * @throws Exception (whenever the REST call fails)
33:      */
34:     public void addMerchandiseToShoppingCart( UUID shoppingCartId, UUID merchandiseId, Integer quantity )
35:             throws Exception;
36: 
37: 
38:     /**
39:      * Adds a merchandise to a shopping cart via a REST call.
40:      * @param shoppingCartId Id of the shopping cart.
41:      * @param merchandiseId Id of the merchandise.
42:      * @param quantity Quantity of the merchandise.
43:      * @param expectedStatus expected status of the operation (null = CREATED)
44:      * @throws Exception (whenever the REST call fails or the status does not match)
45:      */
46:     public void addMerchandiseToShoppingCart( UUID shoppingCartId, UUID merchandiseId, Integer quantity,
47:                                                   ResultMatcher expectedStatus ) throws Exception;
48: 
49: 
50:     /**
51:      * Deletes a merchandise from a shopping cart via a REST call.
52:      * @param shoppingCartId Id of the shopping cart.
53:      * @param merchandiseId Id of the merchandise.
54:      * @throws Exception (whenever the REST call fails)
55:      */
56:     public void deleteMerchandiseFromShoppingCart( UUID shoppingCartId, UUID merchandiseId )
57:             throws Exception;
58: 
59: 
60:     /**
61:      * Deletes a merchandise from a shopping cart via a REST call.
62:      * @param shoppingCartId Id of the shopping cart.
63:      * @param merchandiseId Id of the merchandise.
64:      * @param expectedStatus expected status of the operation (null = OK)
65:      * @throws Exception (whenever the REST call fails or the status does not match)
66:      */
67:     public void deleteMerchandiseFromShoppingCart( UUID shoppingCartId, UUID merchandiseId,
68:                                                       ResultMatcher expectedStatus ) throws Exception;
69: 
70: 
71:     /**
72:      * Checks out a shopping cart via REST call, and returns the id of the created purchase.
73:      * @param shoppingCartId
74:      * @param expectedCustomerName expected name of the customer who owns the shopping cart (null = don't check)
75:      * @param expectedStatus expected status of the operation (null = don't check)
76:      * @param expectedPurchases the expected purchases to be created as a result of the checkout. This is
77:      *                            a map of the following form:
78:      *                            <pre>
79:      *                               fulfillmentCenterId -> Map<merchandiseId,Integer>
80:      *                            </pre>
81:      *                            where the inner map contains the merchandises and their quantities
82:      * @return
83:      * @throws Exception
84:      */
85:     public void checkout( UUID shoppingCartId, String expectedCustomerName,
86:                           ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedPurchases )
87:            throws Exception;
88: }
89: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\customer\CustomerRegistrationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.customer;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
12: import thkoeln.archilab.ecommerce.usecases.CustomerType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
15: 
16: import static org.junit.jupiter.api.Assertions.*;
17: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
18: 
19: 
20: @SpringBootTest
21: public class CustomerRegistrationTest {
22:     @Autowired
23:     private CustomerRegistrationUseCases customerRegistrationUseCases;
24:     @Autowired
25:     private Purgatory purgatory;
26:     @Autowired
27:     private CustomerTestHelper customerTestHelper;
28: 
29:     private MailAddressType nonExistingMailAddress;
30:     private PhysicalAddressType somePhysicalAddress;
31: 
32:     @BeforeEach
33:     public void setUp() {
34:         purgatory.deleteEverything();
35:         nonExistingMailAddress = instantiateMailAddress( "this@nononono.de" );
36:         somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
37:                 instantiateZipCode( "90001" ) );
38:     }
39: 
40:     @Test
41:     public void testAllCustomersRegistered() {
42:         // given
43:         customerTestHelper.registerAllCustomers();
44:         MailAddressType mailAddress3 =
45:                 customerTestHelper.getCustomerMailAddress( 3 );
46:         String name3 = customerTestHelper.getCustomerName( 3 );
47:         PhysicalAddressType physicalAddress3 = customerTestHelper.getCustomerPhysicalAddress( 3 );
48: 
49:         // when
50:         CustomerType customer3 = customerRegistrationUseCases.getCustomerData(
51:                 mailAddress3 );
52: 
53:         // then
54:         Assertions.assertEquals( name3, customer3.getName() );
55:         Assertions.assertEquals( mailAddress3, customer3.getMailAddress() );
56:         Assertions.assertEquals( physicalAddress3, customer3.getPhysicalAddress() );
57:     }
58: 
59: 
60:     @Test
61:     public void testRegisterCustomerWithDuplicateMailAddress() {
62:         // given
63:         customerTestHelper.registerAllCustomers();
64:         PhysicalAddressType physicalAddress5 = customerTestHelper.getCustomerPhysicalAddress( 5 );
65:         MailAddressType mailAddress5 =
66:                 customerTestHelper.getCustomerMailAddress( 5 );
67: 
68:         // when
69:         // then
70:         assertThrows( ShopException.class, () ->
71:                 customerRegistrationUseCases.register( "Gandalf The Grey",
72:                         mailAddress5, physicalAddress5 ) );
73:     }
74: 
75: 
76:     @Test
77:     public void testRegisterCustomerWithDuplicateNameOrPhysicalAddress() {
78:         // given
79:         customerTestHelper.registerAllCustomers();
80:         MailAddressType newMailAddress =
81:                 instantiateMailAddress( "some@this.de" );
82:         PhysicalAddressType physicalAddress2 = customerTestHelper.getCustomerPhysicalAddress( 2 );
83:         String name2 = customerTestHelper.getCustomerName( 2 );
84: 
85:         // when
86:         // then
87:         assertDoesNotThrow( () ->
88:                 customerRegistrationUseCases.register( name2, newMailAddress, physicalAddress2 ) );
89:     }
90: 
91: 
92:     @Test
93:     public void testRegisterCustomerWithInvalidData() {
94:         // given
95:         MailAddressType mailAddress5 =
96:                 customerTestHelper.getCustomerMailAddress( 5 );
97:         PhysicalAddressType physicalAddress5 = customerTestHelper.getCustomerPhysicalAddress( 5 );
98:         String name5 = customerTestHelper.getCustomerName( 5 );
99: 
100:         // when
101:         // then
102:         assertThrows( ShopException.class, () ->
103:                 customerRegistrationUseCases.register( null, mailAddress5, physicalAddress5 ) );
104:         assertThrows( ShopException.class, () ->
105:                 customerRegistrationUseCases.register("", mailAddress5, physicalAddress5 ) );
106:         assertThrows( ShopException.class, () ->
107:                 customerRegistrationUseCases.register( name5, null, physicalAddress5 ) );
108:         assertThrows( ShopException.class, () ->
109:                 customerRegistrationUseCases.register( name5, mailAddress5, null ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testChangeAddressWithInvalidData() {
115:         // given
116:         customerTestHelper.registerAllCustomers();
117:         PhysicalAddressType physicalAddress7 = customerTestHelper.getCustomerPhysicalAddress( 7 );
118:         MailAddressType mailAddress7 =
119:                 customerTestHelper.getCustomerMailAddress( 7 );
120: 
121:         // when
122:         // then
123:         assertThrows( ShopException.class, () ->
124:                 customerRegistrationUseCases.changeAddress( nonExistingMailAddress, physicalAddress7 ) );
125:         assertThrows( ShopException.class, () ->
126:                 customerRegistrationUseCases.changeAddress( null, physicalAddress7 ) );
127:         assertThrows( ShopException.class, () ->
128:                 customerRegistrationUseCases.changeAddress( mailAddress7, null ) );
129:     }
130: 
131: 
132:     @Test
133:     public void testGetDataForNonexistingMailAddress() {
134:         // given
135:         customerTestHelper.registerAllCustomers();
136: 
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 customerRegistrationUseCases.getCustomerData( nonExistingMailAddress ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testDeleteCustomersNoMoreCustomers() {
146:         // given
147:         customerTestHelper.registerAllCustomers();
148:         MailAddressType mailAddress0 =
149:                 customerTestHelper.getCustomerMailAddress( 0 );
150: 
151: 
152:         // when
153:         customerRegistrationUseCases.deleteAllCustomers();
154: 
155:         // then
156:         assertThrows( ShopException.class, () -> customerRegistrationUseCases.getCustomerData(
157:                 mailAddress0 ) );
158:     }
159: 
160: 
161:     @Test
162:     public void testChangeAddressSuccessful() {
163:         // given
164:         customerTestHelper.registerAllCustomers();
165:         MailAddressType mailAddress6 =
166:                 customerTestHelper.getCustomerMailAddress( 6 );
167: 
168:         // when
169:         customerRegistrationUseCases.changeAddress( mailAddress6, somePhysicalAddress );
170:         CustomerType newCustomer6 =
171:                 customerRegistrationUseCases.getCustomerData( mailAddress6 );
172: 
173:         // then
174:         Assertions.assertEquals( mailAddress6, newCustomer6.getMailAddress() );
175:         Assertions.assertEquals( somePhysicalAddress, newCustomer6.getPhysicalAddress() );
176:     }
177: 
178: 
179:     @Test
180:     public void testChangeAddressForNonexistingMailAddress() {
181:         // given
182:         customerTestHelper.registerAllCustomers();
183: 
184:         // when
185:         // then
186:         assertThrows( ShopException.class, () ->
187:                 customerRegistrationUseCases.changeAddress( nonExistingMailAddress, somePhysicalAddress ) );
188:     }
189: 
190: 
191: }
192: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\customer\CustomerRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.customer;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
12: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
13: import thkoeln.archilab.ecommerce.usecases.CustomerType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
16: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
17: 
18: import java.util.UUID;
19: 
20: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
21: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
22: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
23: 
24: @SpringBootTest
25: @Transactional
26: @AutoConfigureMockMvc
27: @Import( RESTTestHelperConfiguration.class )
28: public class CustomerRESTTest {
29:     @Autowired
30:     private CustomerRegistrationUseCases customerRegistrationUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private CustomerTestHelper customerTestHelper;
35:     @Autowired
36:     private MockMvc mockMvc;
37: 
38:     private UUID randomId;
39:     private MailAddressType nonExistingMailAddress;
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         customerTestHelper.registerAllCustomers();
45: 
46:         nonExistingMailAddress = FactoryMethodInvoker.instantiateMailAddress(
47:                 "harry@sally.de" );
48:         randomId = UUID.randomUUID();
49:     }
50: 
51: 
52:     @Test
53:     public void testInvalidCustomerUris() throws Exception {
54:         // given
55:         String allCustomersUri = "/customers";
56:         String randomIdUri = "/customers/" +  randomId;
57:         String nonExistingMailAddressUri = "/customers?mailAddress=" + nonExistingMailAddress;
58:         String randomParamUri = "/customers?randomParam=randomValue";
59: 
60:         // when
61:         // then
62:         mockMvc.perform( get( allCustomersUri ) ).andExpect( status().isMethodNotAllowed() );
63:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
64:         mockMvc.perform( get( nonExistingMailAddressUri ) ).andExpect( status().isNotFound() );
65:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
66:     }
67: 
68: 
69:     @Test
70:     public void testRandomCustomerId() throws Exception {
71:         // given
72:         String invalidUri = "/customers/" +  randomId;
73: 
74:         // when
75:         // then
76:         mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
77:     }
78: 
79: 
80:     @Test
81:     public void testQueryCustomer() throws Exception {
82:         // given
83:         MailAddressType mailAddress4 =
84:                 customerTestHelper.getCustomerMailAddress( 4 );
85:         String customerUri4 = "/customers?mailAddress=" + mailAddress4;
86: 
87:         // when
88:         CustomerType customer4 = customerRegistrationUseCases.getCustomerData( mailAddress4 );
89:         String name = customerTestHelper.getCustomerName( 4 );
90:         PhysicalAddressType physicalAddress4 = customerTestHelper.getCustomerPhysicalAddress( 4 );
91: 
92:         // then (check using JSONPath)
93:         mockMvc.perform( get( customerUri4 ) )
94:                 .andExpect( status().isOk() )
95:                 .andExpect( jsonPath( "$.name" ).value( name ) )
96:                 // id is position 0 (cannot be tested with current API structure), name is position 1,
97:                 // mail address is 2, physical address is 3)
98:                 .andExpect( jsonPath( "$..mailAddressString" ).value( mailAddress4.toString() ) )
99:                 .andExpect( jsonPath( "$..city" ).value( physicalAddress4.getCity() ) )
100:                 .andExpect( jsonPath( "$..zipCodeString" ).value(
101:                         physicalAddress4.getZipCode().toString() ) );
102:     }
103: 
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class BasicNoOutsideSolutionRulesTest {
14: 
15:     @ArchTest
16:     static final ArchRule noClassesOnTopLevel =
17:             classes().should().resideInAPackage( "..solution.*.." )
18:                     .allowEmptyShould( true );
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.library.Architectures.layeredArchitecture;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln")
12: @SuppressWarnings("PMD")
13: public class BasicProperDependenciesTest {
14: 
15:     @ArchTest
16:     static final ArchRule properDependencies =
17:             layeredArchitecture()
18:                     .consideringAllDependencies()
19:                     //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
20:                     .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
21:                     .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )
22: 
23:                     //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
24:                     .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
25:                     .allowEmptyShould( true );
26: }
27: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
5: import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
6: import org.springframework.core.type.classreading.MetadataReader;
7: import org.springframework.core.type.classreading.MetadataReaderFactory;
8: 
9: import java.io.IOException;
10: import java.util.Arrays;
11: import java.util.HashSet;
12: import java.util.Set;
13: 
14: import static org.junit.jupiter.api.Assertions.assertTrue;
15: 
16: public class BasicRequiredClassesTest {
17:     private static final String[] REQUIRED_CLASSES = {
18:             "Customer",
19:             "CustomerRepository",
20:             "Merchandise",
21:             "MerchandiseRepository",
22:             "Purchase",
23:             "PurchaseRepository",
24:             "InventoryLevel",
25:             "ShoppingCart",
26:             "ShoppingCartRepository",
27:             "FulfillmentCenterRepository",
28:             "ShoppingCartPart",
29:             "PurchasePart",
30:             "FulfillmentCenter",
31:     };
32: 
33:     @Test
34:     public void testRequiredClassesDeclared() throws IOException {
35:         String basePackage = "thkoeln.archilab.ecommerce";
36:         String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";
37: 
38:         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
39:         MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );
40: 
41:         Set<String> foundClasses = new HashSet<>();
42: 
43:         Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
44:             try {
45:                 MetadataReader reader = readerFactory.getMetadataReader( resource );
46:                 foundClasses.add( reader.getClassMetadata().getClassName() );
47:             } catch (IOException e) {
48:                 e.printStackTrace();
49:             }
50:         } );
51: 
52:         Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
53:             boolean found = foundClasses.stream().anyMatch(className ->
54:                     className.startsWith(basePackage) && className.endsWith("." + requiredClass)
55:             );
56:             assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
57:         });
58:     }
59: }
60: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.boot.test.context.SpringBootTest;
6: import org.springframework.context.ApplicationContext;
7: 
8: import java.util.Arrays;
9: import java.util.HashMap;
10: import java.util.List;
11: import java.util.Map;
12: 
13: import static org.junit.jupiter.api.Assertions.*;
14: 
15: @SpringBootTest
16: public class BasicUseCaseImplementationPackageTest {
17: 
18:     @Autowired
19:     private ApplicationContext applicationContext;
20: 
21:     private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
22:         put("CustomerRegistrationUseCases", Arrays.asList("customer"));
23:         put("FulfillmentCenterUseCases", Arrays.asList("fulfillmentcenter"));
24:         put("MerchandiseCatalogUseCases", Arrays.asList("merchandise"));
25:         put("ShoppingCartUseCases", Arrays.asList("shoppingcart"));
26:         put("PurchaseUseCases", Arrays.asList("purchase"));
27:     }};
28:     private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
29:     private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";
30: 
31:     @Test
32:     public void testRequiredClassesDeclared() {
33:         for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
34:             String interfaceName = USECASE_PATH + "." + entry.getKey();
35:             List<String> correctTopLevelPackages = entry.getValue();
36:             Class<?> useCaseInterfaceClass = null;
37:             try {
38:                 useCaseInterfaceClass = Class.forName( interfaceName );
39:             } catch (ClassNotFoundException e) {
40:                 fail( "Use case interface " + interfaceName + " not found.", e );
41:                 continue;
42:             }
43:             String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
44:             assertEquals( 1, beans.length,
45:                     "There should be exactly 1 service implementation for the interface " +
46:                             entry.getKey() + ", but found " + beans.length );
47:             Object bean = applicationContext.getBean( beans[0] );
48:             boolean isValid = false;
49:             for ( String correctTopLevelPackage : correctTopLevelPackages ) {
50:                 String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
51:                 if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
52:                     isValid = true;
53:                     break;
54:                 }
55:             }
56:             assertTrue( isValid,
57:                     "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
58:                             + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
59:         }
60:     }
61: }
62: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: import org.springframework.data.repository.CrudRepository;
8: import org.springframework.stereotype.Service;
9: 
10: import jakarta.persistence.Entity;
11: import org.springframework.web.bind.annotation.RestController;
12: 
13: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
14: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
15: 
16: @ArchTag("layerRules")
17: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
18: @SuppressWarnings("PMD")
19: public class DDDRulesTest {
20: 
21:     @ArchTest
22:     static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
23:             noClasses().that().resideInAPackage( "..domain.." )
24:                     .should().dependOnClassesThat().resideInAPackage( "..application.." )
25:                     .allowEmptyShould( true );
26: 
27:     @ArchTest
28:     static final ArchRule entitiesMustResideInADomainPackage =
29:             classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
30:                     .as( "Entities must reside in a package '..domain..'" )
31:                     .allowEmptyShould( true );
32: 
33:     @ArchTest
34:     static final ArchRule entitiesMustNotAccessRepositories =
35:             noClasses().that().areAnnotatedWith( Entity.class )
36:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
37:                     .allowEmptyShould( true );
38: 
39:     @ArchTest
40:     static final ArchRule repositoriesMustResideInADomainPackage =
41:             classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
42:                     .as( "Repositories must reside in a package '..domain..'" )
43:                     .allowEmptyShould( true );
44: 
45:     @ArchTest
46:     static final ArchRule repositoryNamesMustHaveProperSuffix =
47:             classes().that().areAssignableTo( CrudRepository.class )
48:                     .should().haveSimpleNameEndingWith( "Repository" )
49:                     .allowEmptyShould( true );
50: 
51:     @ArchTest
52:     static final ArchRule servicesMustResideInAnApplicationPackage =
53:             classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
54:                     .as( "Application Services must reside in a package '..application..'" )
55:                     .allowEmptyShould( true );
56: 
57:     @ArchTest
58:     static final ArchRule serviceNamesMustHaveProperSuffix =
59:             classes().that().areAnnotatedWith( Service.class )
60:                     .should().haveSimpleNameEndingWith( "Service" )
61:                     .allowEmptyShould( true );
62: 
63:     @ArchTest
64:     static final ArchRule controllersMustResideInAnApplicationPackage =
65:             classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
66:                     .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );
67: 
68:     @ArchTest
69:     static final ArchRule controllersNamesMustHaveProperSuffix =
70:             classes().that().areAnnotatedWith( RestController.class )
71:                     .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );
72: 
73:     @ArchTest
74:     static final ArchRule controllersMustNotAccessRepositories =
75:             noClasses().that().areAnnotatedWith( RestController.class )
76:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
77:                     .allowEmptyShould( false );
78: }
79: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.importer.ClassFileImporter;
6: import com.tngtech.archunit.lang.ArchRule;
7: import com.tngtech.archunit.library.dependencies.SliceAssignment;
8: import com.tngtech.archunit.library.dependencies.SliceIdentifier;
9: import org.junit.jupiter.api.Test;
10: 
11: import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
12: 
13: public class NoCycleTest {
14:     private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");
15: 
16:     private SliceAssignment inAllClasses() {
17:         return new SliceAssignment() {
18:             @Override
19:             public String getDescription() {
20:                 return "every class in it's own slice";
21:             }
22: 
23:             @Override
24:             public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
25:                 return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
26:             }
27:         };
28:     }
29: 
30:     @Test
31:     public void testNoCyclicDependenciesBetweenClasses() {
32:         slices().assignedFrom(inAllClasses())
33:                 .namingSlices("$1[$2.$3]")
34:                 .should().beFreeOfCycles()
35:                 .check(importedClasses);
36:     }
37: 
38:     @Test
39:     public void testNoCyclicDependenciesBetweenPackages() {
40:         ArchRule rule = slices().matching("..solution.(*)..")
41:                 .should().beFreeOfCycles().allowEmptyShould( true );
42:         rule.check(importedClasses);
43:     }
44: }
45: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.base.DescribedPredicate;
4: import com.tngtech.archunit.core.domain.JavaClass;
5: import com.tngtech.archunit.core.domain.JavaField;
6: import com.tngtech.archunit.core.domain.JavaParameterizedType;
7: import com.tngtech.archunit.core.domain.JavaType;
8: import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
9: import com.tngtech.archunit.junit.AnalyzeClasses;
10: import com.tngtech.archunit.junit.ArchTag;
11: import com.tngtech.archunit.junit.ArchTest;
12: import com.tngtech.archunit.lang.ArchCondition;
13: import com.tngtech.archunit.lang.ArchRule;
14: import com.tngtech.archunit.lang.ConditionEvents;
15: import com.tngtech.archunit.lang.SimpleConditionEvent;
16: import jakarta.persistence.*;
17: import lombok.extern.slf4j.Slf4j;
18: import thkoeln.archilab.ecommerce.GenericId;
19: 
20: import java.util.List;
21: 
22: import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
23: import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
24: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;
25: 
26: @ArchTag("layerRules")
27: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
28: @SuppressWarnings("PMD")
29: @Slf4j
30: public class OnlyReferenceViaIDTest { //FULFILLMENT_CENTER
31:     private static final String SHOPPING_CART_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingcart.domain";
32:     private static final String CUSTOMER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.customer.domain";
33:     private static final String MERCHANDISE_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.merchandise.domain";
34:     private static final String PURCHASE_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.purchase.domain";
35:     private static final String FULFILLMENT_CENTER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain";
36: 
37:     @ArchTest
38:     static final ArchRule idFieldsMustUseGenericId =
39:             fields()
40:                     .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
41:                     .and().areAnnotatedWith( Id.class )
42:                     .should().haveRawType( assignableTo( GenericId.class ) )
43:                     .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
44:                     .allowEmptyShould( true );
45: 
46: 
47:     private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
48:             annotatedWith( ManyToOne.class )
49:                     .or( annotatedWith( OneToOne.class ) )
50:                     .or( annotatedWith( Embedded.class ) )
51:                     .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );
52: 
53:     private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
54:             annotatedWith( OneToMany.class )
55:                     .or( annotatedWith( ManyToMany.class ) )
56:                     .or( annotatedWith( ElementCollection.class ) )
57:                     .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );
58: 
59: 
60:     private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
61:         String description = "an entity or value object from same aggregate, or a domain primitive";
62:         return new DescribedPredicate<>( description ) {
63:             @Override
64:             public boolean test( JavaClass type ) {
65:                 // check if the class is an entity or value object, and resides in the allowed package
66:                 if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
67:                     return false;
68:                 }
69:                 // a GenericId is always allowed
70:                 if ( type.isAssignableTo( GenericId.class ) ) {
71:                     return true;
72:                 }
73:                 // a domain primitive is also always allowed
74:                 if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
75:                     return true;
76:                 }
77:                 return type.getPackageName().startsWith( allowedPackage );
78:             }
79:         };
80:     }
81: 
82: 
83:     @ArchTest
84:     static final ArchRule shoppingCartToOneReferences =
85:             fields()
86:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_CART_DOMAIN_PACKAGE )
87:                     .and( isToOneAnnotation )
88:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_CART_DOMAIN_PACKAGE ) ) )
89:                     .allowEmptyShould( true );
90: 
91:     @ArchTest
92:     static final ArchRule customerToOneReferences =
93:             fields()
94:                     .that().areDeclaredInClassesThat().resideInAPackage( CUSTOMER_DOMAIN_PACKAGE )
95:                     .and( isToOneAnnotation )
96:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( CUSTOMER_DOMAIN_PACKAGE ) ) )
97:                     .allowEmptyShould( true );
98: 
99:     @ArchTest
100:     static final ArchRule merchandiseToOneReferences =
101:             fields()
102:                     .that().areDeclaredInClassesThat().resideInAPackage( MERCHANDISE_DOMAIN_PACKAGE )
103:                     .and( isToOneAnnotation )
104:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( MERCHANDISE_DOMAIN_PACKAGE ) ) )
105:                     .allowEmptyShould( true );
106: 
107:     @ArchTest
108:     static final ArchRule purchaseToOneReferences =
109:             fields()
110:                     .that().areDeclaredInClassesThat().resideInAPackage( PURCHASE_DOMAIN_PACKAGE )
111:                     .and( isToOneAnnotation )
112:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( PURCHASE_DOMAIN_PACKAGE ) ) )
113:                     .allowEmptyShould( true );
114: 
115:     @ArchTest
116:     static final ArchRule fulfillmentCenterToOneReferences =
117:             fields()
118:                     .that().areDeclaredInClassesThat().resideInAPackage( FULFILLMENT_CENTER_DOMAIN_PACKAGE )
119:                     .and( isToOneAnnotation )
120:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( FULFILLMENT_CENTER_DOMAIN_PACKAGE ) ) )
121:                     .allowEmptyShould( true );
122: 
123: 
124:     private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
125:         return new ArchCondition<JavaField>(
126:                 "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
127:             @Override
128:             public void check( JavaField field, ConditionEvents events ) {
129:                 JavaClass rawType = field.getRawType();
130:                 String rawTypeName = rawType.getFullName();
131:                 if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
132:                     events.add( SimpleConditionEvent.violated( field,
133:                             field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
134:                     return;
135:                 }
136:                 JavaType fieldType = field.getType();
137:                 if ( !( fieldType instanceof JavaParameterizedType ) ) {
138:                     events.add( SimpleConditionEvent.violated( field,
139:                             field.getFullName() + " is a raw List/Set without a type argument" ) );
140:                     return;
141:                 }
142:                 List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
143:                 if ( typeArguments.isEmpty() ) {
144:                     events.add( SimpleConditionEvent.violated( field,
145:                             field.getFullName() + " has no type arguments" ) );
146:                     return;
147:                 }
148:                 JavaType elementType = typeArguments.get( 0 );
149:                 if ( !( elementType instanceof JavaClass ) ) {
150:                     events.add( SimpleConditionEvent.violated( field,
151:                             field.getFullName() + " has an unknown element type" ) );
152:                     return;
153:                 }
154:                 JavaClass elementClass = (JavaClass) elementType;
155:                 boolean hasAnnotation =
156:                         elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
157:                 boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
158:                 boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
159:                 boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
160:                 boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
161:                 if ( !ok ) {
162:                     events.add( SimpleConditionEvent.violated( field,
163:                             field.getFullName() + " refers to " + elementClass.getFullName()
164:                                     + " which is not a DP, or an entity/value object in " + allowedPackage ) );
165:                 }
166:             }
167:         };
168:     }
169: 
170: 
171:     @ArchTest
172:     static final ArchRule shoppingCartToManyReferences =
173:             fields()
174:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_CART_DOMAIN_PACKAGE )
175:                     .and( isToManyAnnotation )
176:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_CART_DOMAIN_PACKAGE ) )
177:                     .allowEmptyShould( true );
178: 
179:     @ArchTest
180:     static final ArchRule customerToManyReferences =
181:             fields()
182:                     .that().areDeclaredInClassesThat().resideInAPackage( CUSTOMER_DOMAIN_PACKAGE )
183:                     .and( isToManyAnnotation )
184:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( CUSTOMER_DOMAIN_PACKAGE ) )
185:                     .allowEmptyShould( true );
186: 
187:     @ArchTest
188:     static final ArchRule merchandiseToManyReferences =
189:             fields()
190:                     .that().areDeclaredInClassesThat().resideInAPackage( MERCHANDISE_DOMAIN_PACKAGE )
191:                     .and( isToManyAnnotation )
192:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( MERCHANDISE_DOMAIN_PACKAGE ) )
193:                     .allowEmptyShould( true );
194: 
195:     @ArchTest
196:     static final ArchRule purchaseToManyReferences =
197:             fields()
198:                     .that().areDeclaredInClassesThat().resideInAPackage( PURCHASE_DOMAIN_PACKAGE )
199:                     .and( isToManyAnnotation )
200:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( PURCHASE_DOMAIN_PACKAGE ) )
201:                     .allowEmptyShould( true );
202: 
203:     @ArchTest
204:     static final ArchRule fulfillmentCenterToManyReferences =
205:             fields()
206:                     .that().areDeclaredInClassesThat().resideInAPackage( FULFILLMENT_CENTER_DOMAIN_PACKAGE )
207:                     .and( isToManyAnnotation )
208:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( FULFILLMENT_CENTER_DOMAIN_PACKAGE ) )
209:                     .allowEmptyShould( true );
210: 
211: }
212: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: /**
4:  * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
5:  */
6: 
7: public class OwnTestsTest {
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClasses;
4: import com.tngtech.archunit.core.importer.ClassFileImporter;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: 
8: import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
9: 
10: public class PackageStructureTest {
11: 
12:     private static final String[] REQUIRED_PACKAGES = {"customer", "shoppingcart", "merchandise", "purchase", "fulfillmentcenter"};
13:     private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
14:     private JavaClasses importedClasses;
15: 
16: 
17:     @BeforeEach
18:     public void setUp() {
19:         importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
20:     }
21: 
22:     @Test
23:     void testRequiredPackagesAreThere() {
24:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
25:             String packageName = BASE_PACKAGE + "." + requiredPackage;
26:             assertThat( importedClasses.containPackage( packageName ) )
27:                     .as( "Expected package %s not found!", packageName )
28:                     .isTrue();
29:         }
30:     }
31: 
32:     @Test
33:     void testRequiredDomainPackagesAreThere() {
34:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
35:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
36:             assertThat( importedClasses.containPackage( packageName ) )
37:                     .as( "Expected domain sub-package %s not found!", packageName )
38:                     .isTrue();
39:         }
40:     }
41: 
42:     @Test
43:     void testRequiredApplicationPackagesAreThere() {
44:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
45:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
46:             assertThat( importedClasses.containPackage( packageName ) )
47:                     .as( "Expected application sub-package %s not found!", packageName )
48:                     .isTrue();
49:         }
50:     }
51: 
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("domainPrimitivesUsageRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class DomainPrimitivesUsageRulesTest {
14:     private static final String MAIL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.MailAddress";
15:     private static final String MONEY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Money";
16:     private static final String PHYSICAL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress";
17: 
18:     @ArchTest
19:     static final ArchRule customerShouldReferenceMailAddress =
20:             classes()
21:                     .that().haveSimpleName( "Customer" )
22:                     .should().dependOnClassesThat().haveFullyQualifiedName( MAIL_ADDRESS_CLASS )
23:                     .because( "Customer should use MailAddress instead of String" );
24: 
25:     @ArchTest
26:     static final ArchRule customerShouldReferencePhysicalAddress =
27:             classes()
28:                     .that().haveSimpleName( "Customer" )
29:                     .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
30:                     .because( "Customer should use PhysicalAddress instead of whatever else" );
31: 
32:     @ArchTest
33:     static final ArchRule fulfillmentCenterShouldReferencePhysicalAddress =
34:             classes()
35:                     .that().haveSimpleName( "FulfillmentCenter" )
36:                     .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
37:                     .because( "Customer should use PhysicalAddress instead of whatever else" );
38: 
39:     @ArchTest
40:     static final ArchRule merchandiseShouldReferenceMoney =
41:             classes()
42:                     .that().haveSimpleName( "Merchandise" )
43:                     .should().dependOnClassesThat().haveFullyQualifiedName( MONEY_CLASS )
44:                     .because( "Merchandise should use Money instead of float or whatever else" );
45: }
46: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\MailAddressTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMailAddress;
10: 
11: class MailAddressTest {
12: 
13:     @Test
14:     public void testToStringMailAddress() {
15:         // given
16:         String input = "test@example.com";
17: 
18:         // when
19:         MailAddressType instance = instantiateMailAddress( input );
20: 
21:         // then
22:         assertEquals( input, instance.toString() );
23:     }
24: 
25:     @Test
26:     public void testEqualityMailAddress() {
27:         // given
28:         // when
29:         MailAddressType instance1 = instantiateMailAddress( "test@example.com" );
30:         MailAddressType instance2 = instantiateMailAddress( "test@example.com" );
31:         MailAddressType instance3 = instantiateMailAddress( "different@example.com" );
32: 
33:         // then
34:         assertEquals( instance1, instance2 );
35:         assertNotEquals( instance1, instance3 );
36:     }
37: 
38:     @Test
39:     public void testImmutabilityMailAddress() {
40:         // given
41:         // when
42:         MailAddressType instance = instantiateMailAddress( "test@example.com" );
43: 
44:         // then
45:         try {
46:             instance.getClass().getMethod( "setMailAddress", String.class );
47:             fail( "setMailAddress method should not exist" );
48:         } catch (NoSuchMethodException e) {
49:             // Success: the object is immutable
50:         }
51:     }
52: 
53: 
54: 
55:     @Test
56:     public void smokeTestForCopyConstructors() {
57:         // given
58:         MailAddressType mailAddress =
59:                 instantiateMailAddress( "peter.schmidt@web.de" );
60: 
61:         // when
62:         MailAddressType mailAddressOtherIdentifyer =
63:                 mailAddress.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
64:         assertThrows( ShopException.class, () ->
65:                 mailAddress.sameDomainDifferentIdentifyer( "p...eter" ) );
66:         MailAddressType mailAddressOtherDomain =
67:                 mailAddress.sameIdentifyerDifferentDomain( "web.ch" );
68:         assertThrows( ShopException.class, () ->
69:                 mailAddress.sameIdentifyerDifferentDomain( "web.edu" ) );
70: 
71:         // then
72:         assertEquals( "p.e.t.e.r@web.de", mailAddressOtherIdentifyer.toString() );
73:         assertEquals( "peter.schmidt@web.ch", mailAddressOtherDomain.toString() );
74:     }
75: 
76: 
77:     @Test
78:     public void testFactoryValidMailAddress() {
79:         // given
80:         // when
81:         // then
82:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.com" ) );
83:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "99Z@example.com" ) );
84:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "GGGhh@s77.com" ) );
85:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "a@4.com" ) );
86:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "Max.Hammer@example.com" ) );
87:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "Max.Gideon.Hammer@example.com" ) );
88:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.this.com" ) );
89:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.de" ) );
90:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.at" ) );
91:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.ch" ) );
92:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.org" ) );
93:     }
94: 
95: 
96:     @Test
97:     public void testFactoryInvalidMailAddress() {
98:         // given
99:         // when
100:         // then
101:         assertThrows( ShopException.class, () -> instantiateMailAddress( null ) );
102:         assertThrows( ShopException.class, () -> instantiateMailAddress( "testexample.com" ) );
103:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@" ) );
104:         assertThrows( ShopException.class, () -> instantiateMailAddress( "@example.com" ) );
105:         assertThrows( ShopException.class, () -> instantiateMailAddress( "Max..Gideon.Hammer@example.com" ) );
106:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@examplecom" ) );
107:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example..com" ) );
108:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example@that.com" ) );
109:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test example@that.com" ) );
110:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test#example@that.com" ) );
111:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.biz" ) );
112:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.biz" ) );
113:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.42" ) );
114:     }
115: }
116: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\MoneyTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMoney;
9: 
10: class MoneyTest {
11: 
12:     @Test
13:     public void testGetAmountMoney() {
14:         // given
15:         Float inputAmount = 10.0f;
16: 
17:         // when
18:         MoneyType instance = instantiateMoney( inputAmount, "EUR" );
19: 
20:         // then
21:         assertEquals( inputAmount, instance.getAmount() );
22:     }
23: 
24:     @Test
25:     public void testGetCurrencyUnitMoney() {
26:         // given
27:         String inputCurrencyUnit = "EUR";
28: 
29:         // when
30:         MoneyType instance = instantiateMoney( 10.0f, inputCurrencyUnit );
31: 
32:         // then
33:         assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
34:     }
35: 
36:     @Test
37:     public void testAddToMoney() {
38:         // given
39:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
40:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
41:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
42: 
43:         // when
44:         MoneyType result12 = instance1.add( instance2 );
45:         MoneyType result13 = instance1.add( instance3 );
46: 
47:         // then
48:         assertEquals( 30.0f, result12.getAmount() );
49:         assertEquals( "EUR", result12.getCurrencyUnit() );
50:         assertEquals( 10.0f, result13.getAmount() );
51:         assertEquals( "EUR", result12.getCurrencyUnit() );
52:     }
53: 
54:     @Test
55:     public void testInvalidAddToMoney() {
56:         // given
57:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
58:         MoneyType instance2 = instantiateMoney( 20.0f, "CHF" );
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
63:     }
64: 
65:     @Test
66:     public void testSubtractFromMoney() {
67:         // given
68:         MoneyType instance1 = instantiateMoney( 30.0f, "EUR" );
69:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
70:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
71:         MoneyType instance4 = instantiateMoney( 30.0f, "EUR" );
72: 
73:         // when
74:         MoneyType result12 = instance1.subtract( instance2 );
75:         MoneyType result13 = instance1.subtract( instance3 );
76:         MoneyType result14 = instance1.subtract( instance4 );
77: 
78:         // then
79:         assertEquals( 10.0f, result12.getAmount() );
80:         assertEquals( "EUR", result12.getCurrencyUnit() );
81:         assertEquals( 30.0f, result13.getAmount() );
82:         assertEquals( "EUR", result13.getCurrencyUnit() );
83:         assertEquals( 0.0f, result14.getAmount() );
84:         assertEquals( "EUR", result14.getCurrencyUnit() );
85:     }
86: 
87:     @Test
88:     public void testInvalidSubtractFromMoney() {
89:         // given
90:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
91:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
92:         MoneyType instance3 = instantiateMoney( 5.0f, "CHF" );
93: 
94:         // when
95:         // then
96:         assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
97:         assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
98:     }
99: 
100:     @Test
101:     public void testMultiplyByMoney() {
102:         // given
103:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
104: 
105:         // when
106:         MoneyType result = instance.multiplyBy( 3 );
107: 
108:         // then
109:         assertEquals( 30.0f, result.getAmount() );
110:         assertEquals( "EUR", result.getCurrencyUnit() );
111:     }
112: 
113:     @Test
114:     public void testFactoryValidCurrencyUnitMoney() {
115:         // given
116:         // when
117:         // then
118:         assertDoesNotThrow( () -> instantiateMoney( 10.0f, "EUR" ) );
119:     }
120: 
121:     @Test
122:     public void testFactoryInvalidCurrencyUnitMoney() {
123:         // given
124:         // when
125:         // then
126:         assertThrows( ShopException.class, () -> instantiateMoney( -10.0f, "EUR" ) );
127:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, "USD" ) );
128:         assertThrows( ShopException.class, () -> instantiateMoney( null, "EUR" ) );
129:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, null ) );
130:     }
131: 
132:     @Test
133:     public void testLargerThanCurrencyUnitMoney() {
134:         // given
135:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
136:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
137:         MoneyType instance3 = instantiateMoney( 10.0f, "EUR" );
138:         MoneyType instance4 = instantiateMoney( 10.0f, "CHF" );
139: 
140:         // when
141:         // then
142:         assertTrue( instance2.largerThan( instance1 ) );
143:         assertFalse( instance1.largerThan( instance2 ) );
144:         assertFalse( instance1.largerThan( instance3 ) );
145:         assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
146:     }
147: 
148: 
149:     @Test
150:     public void testEqualityCurrencyUnitMoney() {
151:         // given
152:         // when
153:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
154:         MoneyType instance2 = instantiateMoney( 10.0f, "EUR" );
155:         MoneyType instance3 = instantiateMoney( 20.0f, "EUR" );
156: 
157:         // then
158:         assertEquals( instance1, instance2 );
159:         assertNotEquals( instance1, instance3 );
160:     }
161: 
162:     @Test
163:     public void testImmutabilityCurrencyUnitMoney() {
164:         // given
165:         // when
166:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
167: 
168:         // then
169:         try {
170:             instance.getClass().getMethod( "setAmount", Float.class );
171:             fail( "setAmount method should not exist" );
172:         } catch (NoSuchMethodException e) {
173:             // Success: the object is immutable
174:         }
175: 
176:         try {
177:             instance.getClass().getMethod( "setCurrencyUnit", String.class );
178:             fail( "setCurrencyUnit method should not exist" );
179:         } catch (NoSuchMethodException e) {
180:             // Success: the object is immutable
181:         }
182:     }
183: }
184: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\PhysicalAddressTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
11: 
12: class PhysicalAddressTest {
13: 
14:     @Test
15:     public void testGetterPhysicalAddress() {
16:         // given
17:         String street = "Irgendeinestraße 42";
18:         String city = "Irgendeinestadt";
19:         ZipCodeType plz = instantiateZipCode( "12345" );
20: 
21:         // when
22:         PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );
23: 
24:         // then
25:         assertEquals( street, instance.getStreet() );
26:         assertEquals( city, instance.getCity() );
27:         assertEquals( plz, instance.getZipCode() );
28:     }
29: 
30:     @Test
31:     public void testFactoryValidPhysicalAddress() {
32:         // given
33:         String street = "Irgendeinestraße 42";
34:         String city = "Irgendeinestadt";
35:         ZipCodeType plz = instantiateZipCode( "12345" );
36: 
37:         // when
38:         // then
39:         assertDoesNotThrow( () -> instantiatePhysicalAddress( street, city, plz ) );
40:     }
41: 
42:     @Test
43:     public void testFactoryInvalidPhysicalAddress() {
44:         // given
45:         String street = "Irgendeinestraße 42";
46:         String city = "Irgendeinestadt";
47:         ZipCodeType plz = instantiateZipCode( "12345" );
48: 
49:         // when
50:         // then
51:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( null, city, plz ) );
52:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( "", city, plz ) );
53:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, null, plz ) );
54:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, "", plz ) );
55:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, city, null ) );
56:     }
57: 
58:     @Test
59:     public void testEqualityPhysicalAddress() {
60:         // given
61:         String street = "Irgendeinestraße 42";
62:         String city = "Irgendeinestadt";
63:         ZipCodeType plz = instantiateZipCode( "12345" );
64: 
65:         // when
66:         PhysicalAddressType instance1 = instantiatePhysicalAddress( street, city, plz );
67:         PhysicalAddressType instance2 = instantiatePhysicalAddress( street, city, plz );
68:         PhysicalAddressType instance3 = instantiatePhysicalAddress( "Anderestr. 12", city, plz );
69:         PhysicalAddressType instance4 = instantiatePhysicalAddress( street, "AndereStadt", plz );
70:         PhysicalAddressType instance5 = instantiatePhysicalAddress( street, city, instantiateZipCode( "54321" ) );
71: 
72:         // then
73:         assertEquals( instance1, instance2 );
74:         assertNotEquals( instance1, instance3 );
75:         assertNotEquals( instance1, instance4 );
76:         assertNotEquals( instance1, instance5 );
77:     }
78: 
79:     @Test
80:     public void testImmutabilityPhysicalAddress() {
81:         // given
82:         String street = "Irgendeinestraße 42";
83:         String city = "Irgendeinestadt";
84:         ZipCodeType plz = instantiateZipCode( "12345" );
85: 
86:         // when
87:         PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );
88: 
89:         // then
90:         try {
91:             instance.getClass().getMethod( "setStreet", String.class );
92:             fail( "setStreet method should not exist" );
93:         } catch (NoSuchMethodException e) {
94:             // Success: the object is immutable
95:         }
96:         try {
97:             instance.getClass().getMethod( "setCity", String.class );
98:             fail( "setCity method should not exist" );
99: 
100:         } catch (NoSuchMethodException e) {
101:             // Success: the object is immutable
102:         }
103:         try {
104:             instance.getClass().getMethod( "setZipCode", ZipCodeType.class );
105:             fail( "setZipCode method should not exist" );
106:         } catch (NoSuchMethodException e) {
107:             // Success: the object is immutable
108:         }
109:     }
110: }
111: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\ZipCodeTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
8: 
9: import static org.junit.jupiter.api.Assertions.*;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
11: 
12: class ZipCodeTest {
13: 
14:     private String input1, input4;
15:     private ZipCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
16:             _04233, _02544, _99123, _56323, _79332;
17: 
18: 
19:     @BeforeEach
20:     public void setUp() {
21:         input1 = "12345";
22:         input4 = "49188";
23:         _12345 = FactoryMethodInvoker.instantiateZipCode( "12345" );
24:         _12345b = FactoryMethodInvoker.instantiateZipCode( "12345" );
25:         _23455 = FactoryMethodInvoker.instantiateZipCode( "23455" );
26:         _01234 = FactoryMethodInvoker.instantiateZipCode( "01234" );
27:         _01235 = FactoryMethodInvoker.instantiateZipCode( "01235" );
28:         _01238 = FactoryMethodInvoker.instantiateZipCode( "01238" );
29:         _01263 = FactoryMethodInvoker.instantiateZipCode( "01263" );
30:         _01213 = FactoryMethodInvoker.instantiateZipCode( "01213" );
31:         _01823 = FactoryMethodInvoker.instantiateZipCode( "01823" );
32:         _01312 = FactoryMethodInvoker.instantiateZipCode( "01312" );
33:         _04233 = FactoryMethodInvoker.instantiateZipCode( "04233" );
34:         _02544 = FactoryMethodInvoker.instantiateZipCode( "02544" );
35:         _99123 = FactoryMethodInvoker.instantiateZipCode( "99123" );
36:         _56323 = FactoryMethodInvoker.instantiateZipCode( "56323" );
37:         _79332 = FactoryMethodInvoker.instantiateZipCode( "79332" );
38: 
39:     }
40: 
41: 
42:     @Test
43:     public void testToStringZipCode() {
44:         // given
45:         // when
46:         ZipCodeType instance = instantiateZipCode( input1 );
47: 
48:         // then
49:         assertEquals( input1, instance.toString() );
50:     }
51: 
52:     @Test
53:     public void testFactoryValidZipCode() {
54:         // given
55:         // when
56:         // then
57:         assertDoesNotThrow( () -> instantiateZipCode( input1 ) );
58:     }
59: 
60:     @Test
61:     public void testFactoryInvalidZipCode() {
62:         // given
63:         // when
64:         // then
65:         assertThrows( ShopException.class, () -> instantiateZipCode( "123456" ) );
66:         assertThrows( ShopException.class, () -> instantiateZipCode( "1234" ) );
67:         assertThrows( ShopException.class, () -> instantiateZipCode( "20000" ) );
68:         assertThrows( ShopException.class, () -> instantiateZipCode( null ) );
69:     }
70: 
71:     @Test
72:     public void testEqualityZipCode() {
73:         // given
74:         // when
75:         ZipCodeType instance1a = instantiateZipCode( input1 );
76:         ZipCodeType instance1b = instantiateZipCode( input1 );
77:         ZipCodeType instance4 = instantiateZipCode( input4 );
78: 
79:         // then
80:         assertEquals( instance1a, instance1b );
81:         assertNotEquals( instance1a, instance4 );
82:     }
83: 
84:     @Test
85:     public void testImmutabilityZipCode() {
86:         // given
87:         // when
88:         ZipCodeType instance = instantiateZipCode( input1 );
89: 
90:         // then
91:         try {
92:             instance.getClass().getMethod( "setzipCode", String.class );
93:             fail( "setzipCode method should not exist" );
94:         } catch (NoSuchMethodException e) {
95:             // Success: the object is immutable
96:         }
97:     }
98: 
99: 
100:     @Test
101:     public void smokeTestForDifference() {
102:         // given
103:         ZipCodeType instance1a = instantiateZipCode( input1 );
104:         ZipCodeType instance1b = instantiateZipCode( input1 );
105:         ZipCodeType instance12479 = instantiateZipCode( "12479" );
106:         ZipCodeType instance21456 = instantiateZipCode( "21456" );
107: 
108:         // when
109:         int differenceAB = instance1a.difference( instance1b );
110:         int difference12 = instance1a.difference( instance12479 );
111:         int difference23 = instance12479.difference( instance21456 );
112: 
113:         // then
114:         assertEquals( 0, differenceAB );
115:         assertTrue( difference12 > 0 );
116:         assertTrue( difference23 > difference12 );
117:     }
118: 
119: 
120:     @Test
121:     public void testZipCodeFirstDigit() {
122:         // given
123:         ZipCodeType instance1 = instantiateZipCode( input1 );
124:         ZipCodeType instance4 = instantiateZipCode( input4 );
125: 
126:         // when
127:         // then
128:         assertEquals( 1, instance1.getFirstDigitZipCode() );
129:         assertEquals( 4, instance4.getFirstDigitZipCode() );
130:     }
131: 
132: 
133: 
134:     @Test
135:     public void testInvalidParameters() {
136:         // given
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 _12345.difference( null ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testSameZipCode() {
146:         // given
147:         // when
148:         int diff = _12345.difference( _12345b );
149: 
150:         // then
151:         assertEquals( 0, diff );
152:     }
153: 
154: 
155:     /**
156:      *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
157:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
158:      *        So, 56733 and 56734 have the same difference as 56733 and 56739.
159:      *      - The difference grows if more digits (counted from the right side) differ.
160:      *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
161:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
162:      *        53876 and 54876 have the same difference as 53876 and 57261.
163:      */
164:     @Test
165:     public void testZipCodeDifferenceInAllButFirstDigit() {
166:         // given
167:         // when
168:         int diff5a = _01234.difference( _01235 );
169:         int diff5b = _01234.difference( _01238 );
170:         int diff4a = _01234.difference( _01263 );
171:         int diff4b = _01234.difference( _01213 );
172:         int diff3a = _01234.difference( _01823 );
173:         int diff3b = _01234.difference( _01312 );
174:         int diff2a = _01234.difference( _04233 );
175:         int diff2b = _01234.difference( _02544 );
176: 
177:         // then
178:         assertEquals( diff5a, diff5b, "difference 01234-01235 must be the same as difference 01234-01238" );
179:         assertEquals( diff4a, diff4b, "difference 01234-01263 must be the same as difference 01234-01213" );
180:         assertEquals( diff3a, diff3b, "difference 01234-01823 must be the same as difference 01234-01312" );
181:         assertEquals( diff2a, diff2b, "difference 01234-04233 must be the same as difference 01234-02544" );
182: 
183:         assertTrue( diff5a < diff4a,
184:                 "difference 01234-01235 must be smaller than difference 01234-01263" );
185:         assertTrue( diff4a < diff3a,
186:                 "difference 01234-01263 must be smaller than difference 01234-01823" );
187:         assertTrue( diff3a < diff2a,
188:                 "difference 01234-01823 must be smaller than difference 01234-04233" );
189:     }
190: 
191: 
192:     /**
193:      *      - However, the difference between 5abcd and 6rstu must be smaller than the one
194:      *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
195:      *        one between 5abcd and 9rstu.
196:      *      - This last condition reflects the fact the first digits of a zip code marks a region
197:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
198:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
199:      *        other.
200:      */
201:     @Test
202:     public void testZipCodedifferenceInFirstDigit() {
203:         // given
204:         // when
205:         int diff1_1 = _01234.difference( _99123 );
206:         int diff1_2 = _01234.difference( _23455 );
207:         int diff1_5 = _01234.difference( _56323 );
208:         int diff1_3 = _01234.difference( _79332 );
209: 
210:         // then
211:         assertTrue( diff1_1 < diff1_2,
212:                 "difference 01234-99123 must be smaller than difference 01234-23455"  );
213:         assertTrue( diff1_2 < diff1_3,
214:                 "difference 01234-23455 must be smaller than difference 01234-79332" );
215:         assertTrue( diff1_3 < diff1_5,
216:                 "difference 01234-79332 must be smaller than difference 01234-56323"  );
217:     }
218: 
219: 
220: 
221: }
222: 
223: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
1: package thkoeln.archilab.ecommerce.tests.e1restcalls;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;
5: 
6: 
7: public class E1RestCallTableTest {
8: 
9:     private GenericTableSpecificationTests genericTableSpecificationTests = null;
10: 
11: 
12:     public E1RestCallTableTest() {
13:         this.genericTableSpecificationTests = new GenericTableSpecificationTests();
14:     }
15: 
16:     @Test
17:     public void restTest() throws Exception {
18:         genericTableSpecificationTests.testTableSpecification("E1" );
19:     }
20: }
21: 
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\fulfillmentcenter\FulfillmentCenterManagementTest.java ---
1: package thkoeln.archilab.ecommerce.tests.fulfillmentcenter;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
12: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
14: 
15: import java.util.UUID;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
19: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
20: 
21: 
22: /**
23:  * This test checks the management and lifecycle of fulfillment centers.
24:  */
25: @SpringBootTest
26: public class FulfillmentCenterManagementTest {
27:     @Autowired
28:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
29:     @Autowired
30:     private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private MerchandiseTestHelper merchandiseTestHelper;
35:     @Autowired
36:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
37: 
38:     private PhysicalAddressType somePhysicalAddress;
39:     private UUID nonExistingId1;
40:     private UUID nonExistingId2;
41: 
42: 
43:     @BeforeEach
44:     public void setUp() {
45:         purgatory.deleteEverything();
46:         merchandiseTestHelper.addAllMerchandises();
47: 
48:         somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
49:                 instantiateZipCode( "90001" ) );
50:         nonExistingId1 = UUID.randomUUID();
51:         nonExistingId2 = UUID.randomUUID();
52:     }
53: 
54: 
55:     @Test
56:     public void testAddInvalidFulfillmentCenter() {
57:         // given
58:         String name = "Lager1";
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class,
63:                 () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
64:                         null, somePhysicalAddress ) );
65:         assertThrows( ShopException.class,
66:                 () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
67:                         "", somePhysicalAddress ) );
68:         assertThrows( ShopException.class,
69:                 () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
70:                         name, null ) );
71:     }
72: 
73: 
74:     @Test
75:     public void testDeleteAllFulfillmentCentersWhenEmpty() {
76:         // given
77:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
78:         UUID merchandiseId9 = merchandiseTestHelper.getMerchandiseId( 9 );
79:         UUID fulfillmentCenterId1 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 1 );
80:         UUID fulfillmentCenterId2 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 2 );
81: 
82:         // when
83:         int numOf1 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId1, merchandiseId9 );
84:         int numOf2 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId2, merchandiseId9 );
85: 
86:         // then
87:         assertEquals( 0, numOf1 );
88:         assertEquals( 0, numOf2 );
89:         fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
90:         // ... ids must be invalid now
91:         assertThrows( ShopException.class,
92:                 () -> fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId1, merchandiseId9 ) );
93:         assertThrows( ShopException.class,
94:                 () -> fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId2, merchandiseId9 ) );
95:     }
96: 
97: 
98:     @Test
99:     public void testDeleteAllFulfillmentCentersWhenFull() {
100:         // given
101:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
102:         UUID merchandiseId7 = merchandiseTestHelper.getMerchandiseId( 7 );
103:         UUID fulfillmentCenterId1 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 1 );
104:         UUID fulfillmentCenterId2 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 2 );
105: 
106:         // when
107:         int numOf1 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId1, merchandiseId7 );
108:         int numOf2 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId2, merchandiseId7 );
109: 
110:         // then
111:         assertTrue( numOf1 == 3 );
112:         assertTrue( numOf2 == 3 );
113:         fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
114:         // ... ids must be invalid now
115:         assertThrows( ShopException.class,
116:                 () -> fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId1, merchandiseId7 ) );
117:         assertThrows( ShopException.class,
118:                 () -> fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId2, merchandiseId7 ) );
119:     }
120: 
121: 
122: 
123:     @Test
124:     public void testAddToInventory() {
125:         // given
126:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
127:         UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 ); // random >30 in fulfillment center 0
128:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
129:         int originalInventory5 =
130:                 fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 5 );
131: 
132:         // when
133:         int inventory5before = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId5 );
134:         fulfillmentCenterUseCases.addToInventory( fulfillmentCenterId0, merchandiseId5, 23 );
135:         int inventory5after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId5 );
136:         fulfillmentCenterUseCases.addToInventory( fulfillmentCenterId0, merchandiseId5, 0 );
137:         int inventory5after2 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId5 );
138: 
139:         // then
140:         assertEquals( originalInventory5, inventory5before );
141:         assertEquals( inventory5before + 23, inventory5after );
142:         assertEquals( inventory5after, inventory5after2 );
143:     }
144: 
145: 
146:     @Test
147:     public void testInvalidAddToInventory() {
148:         // given
149:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
150:         UUID merchandiseId2 = merchandiseTestHelper.getMerchandiseId( 2 );
151:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
152: 
153:         // when
154:         // then
155:         assertThrows( ShopException.class,
156:                 () -> fulfillmentCenterUseCases.addToInventory( nonExistingId1, nonExistingId2, 12 ) );
157:         assertThrows( ShopException.class,
158:                 () -> fulfillmentCenterUseCases.addToInventory(
159:                         fulfillmentCenterId0, nonExistingId2, 12 ) );
160:         assertThrows( ShopException.class,
161:                 () -> fulfillmentCenterUseCases.addToInventory(
162:                         nonExistingId1, merchandiseId2, 12 ) );
163:         assertThrows( ShopException.class,
164:                 () -> fulfillmentCenterUseCases.addToInventory(
165:                         fulfillmentCenterId0, merchandiseId2, -1 ) );
166:     }
167: 
168: 
169:     @Test
170:     public void testRemoveFromInventory() {
171:         // given
172:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
173:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
174:         UUID merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 ); // 0 in fulfillment center 0
175:         UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 ); // random >30 in fulfillment center 0
176:         UUID merchandiseId6 = merchandiseTestHelper.getMerchandiseId( 6 ); // random >30 in fulfillment center 0
177:         int inventory0before =
178:                 fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 0 );
179:         int inventory5before =
180:                 fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 5 );
181:         int inventory6before =
182:                 fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 6 );
183: 
184:         // when
185:         fulfillmentCenterUseCases.removeFromInventory( fulfillmentCenterId0, merchandiseId5, 1 );
186:         int inventory5after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId5 );
187:         fulfillmentCenterUseCases.removeFromInventory( fulfillmentCenterId0, merchandiseId0, 0 );
188:         int inventory0after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId0 );
189:         fulfillmentCenterUseCases.removeFromInventory(
190:                 fulfillmentCenterId0, merchandiseId6, inventory6before );
191:         int inventory6after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId6 );
192: 
193:         // then
194:         assertEquals( inventory5before - 1, inventory5after );
195:         assertEquals( inventory0before, inventory0after );
196:         assertEquals( 0, inventory6after );
197:     }
198: 
199: 
200:     @Test
201:     public void testInvalidRemoveFromInventory() {
202:         // given
203:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
204:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
205:         UUID merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 ); // 0 in fulfillment center 0
206:         UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 ); // random >30 in fulfillment center 0
207:         int inventory5before =
208:                 fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 5 );
209: 
210:         // when
211:         // then
212:         assertThrows( ShopException.class,
213:                 () -> fulfillmentCenterUseCases.removeFromInventory( nonExistingId1, nonExistingId2, 12 ) );
214:         assertThrows( ShopException.class,
215:                 () -> fulfillmentCenterUseCases.removeFromInventory(
216:                         fulfillmentCenterId0, nonExistingId2, 12 ) );
217:         assertThrows( ShopException.class,
218:                 () -> fulfillmentCenterUseCases.removeFromInventory(
219:                         nonExistingId1, merchandiseId5, 12 ) );
220:         assertThrows( ShopException.class,
221:                 () -> fulfillmentCenterUseCases.removeFromInventory(
222:                         fulfillmentCenterId0, merchandiseId5, -1 ) );
223:         assertThrows( ShopException.class,
224:                 () -> fulfillmentCenterUseCases.removeFromInventory(
225:                         fulfillmentCenterId0, merchandiseId5, inventory5before + 1 ) );
226:         assertThrows( ShopException.class,
227:                 () -> fulfillmentCenterUseCases.removeFromInventory(
228:                         fulfillmentCenterId0, merchandiseId0, 1 ) ); // already 0 in fulfillment center 0
229:     }
230: 
231: 
232:     @Test
233:     public void testChangeInventory() {
234:         // given
235:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
236:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
237:         UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 ); // random >30 in fulfillment center 0
238: 
239:         // when
240:         fulfillmentCenterUseCases.changeInventoryTo( fulfillmentCenterId0, merchandiseId5, 111 );
241:         int inventory5after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId5 );
242: 
243:         // then
244:         assertEquals( 111, inventory5after );
245:     }
246: 
247: 
248:     @Test
249:     public void testInvalidChangeInventory() {
250:         // given
251:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
252:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
253:         UUID merchandiseId6 = merchandiseTestHelper.getMerchandiseId( 6 );
254: 
255:         // when
256:         // then
257:         assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeInventoryTo(
258:                 nonExistingId1, nonExistingId2, 12 ) );
259:         assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeInventoryTo(
260:                 nonExistingId1, merchandiseId6, 12 ) );
261:         assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeInventoryTo(
262:                 fulfillmentCenterId0, nonExistingId2, 12 ) );
263:         assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeInventoryTo(
264:                 fulfillmentCenterId0, merchandiseId6, -1 ) );
265:     }
266: 
267: 
268:     @Test
269:     public void testEmptyFulfillmentCenter() {
270:         // given
271:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
272:         UUID fulfillmentCenterId9 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 9 ); // empty fulfillment center
273: 
274:         // when
275:         int totalInventory = 0;
276:         for ( int iMerchandise = 0; iMerchandise < merchandiseTestHelper.numberOfMerchandises(); iMerchandise++ ) {
277:             UUID merchandiseId = merchandiseTestHelper.getMerchandiseId( iMerchandise );
278:             totalInventory += fulfillmentCenterUseCases.getAvailableInventory(
279:                     fulfillmentCenterId9, merchandiseId );
280:         }
281: 
282:         // then
283:         assertEquals( 0, totalInventory );
284:     }
285: 
286: 
287: 
288: }
289: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\merchandise\MerchandiseCatalogTest.java ---
1: package thkoeln.archilab.ecommerce.tests.merchandise;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
9: import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
15: 
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.*;
19: 
20: 
21: @SpringBootTest
22: public class MerchandiseCatalogTest {
23:     @Autowired
24:     private CustomerRegistrationUseCases customerRegistrationUseCases;
25:     @Autowired
26:     private ShoppingCartUseCases shoppingCartUseCases;
27:     @Autowired
28:     private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
29:     @Autowired
30:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private CustomerTestHelper customerTestHelper;
35:     @Autowired
36:     private MerchandiseTestHelper merchandiseTestHelper;
37:     @Autowired
38:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
39: 
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         customerTestHelper.registerAllCustomers();
45:         merchandiseTestHelper.addAllMerchandises();
46:     }
47: 
48: 
49:     @Test
50:     public void testAddMerchandiseToCatalog() {
51:         // given
52:         UUID merchandiseId4 = merchandiseTestHelper.getMerchandiseId( 4 );
53:         MoneyType salesPrice4 = merchandiseTestHelper.getSalesPrice( 4 );
54: 
55:         // when
56:         MoneyType foundSalesPrice = merchandiseCatalogUseCases.getSalesPrice( merchandiseId4 );
57: 
58:         // then
59:         assertEquals( salesPrice4, foundSalesPrice );
60:     }
61: 
62: 
63:     @Test
64:     public void testAddMerchandiseWithInvalidData() {
65:         // given
66:         String name = "SomeStuff";
67:         String description = "Some more explanation on the stuff";
68:         Float size = 5.0f;
69:         MoneyType buyingPrice =
70:                 FactoryMethodInvoker.instantiateMoney( 5.0f, "EUR" );
71:         MoneyType salesPrice =
72:                 FactoryMethodInvoker.instantiateMoney( 10.0f, "EUR" );
73:         MoneyType tooLowSalesPrice =
74:                 FactoryMethodInvoker.instantiateMoney( 4.0f, "EUR" );
75: 
76:         // when / then
77:         assertThrows( ShopException.class, () ->
78:                 merchandiseCatalogUseCases.addMerchandiseToCatalog(
79:                         null, description, size, buyingPrice, salesPrice ) );
80:         assertThrows( ShopException.class, () ->
81:                 merchandiseCatalogUseCases.addMerchandiseToCatalog(
82:                         "", description, size, buyingPrice, salesPrice ) );
83:         assertThrows( ShopException.class, () ->
84:                 merchandiseCatalogUseCases.addMerchandiseToCatalog(
85:                         name, null, size, buyingPrice, salesPrice ) );
86:         assertThrows( ShopException.class, () ->
87:                 merchandiseCatalogUseCases.addMerchandiseToCatalog(
88:                         name, "", size, buyingPrice, salesPrice ) );
89:         assertThrows( ShopException.class, () ->
90:                 merchandiseCatalogUseCases.addMerchandiseToCatalog(
91:                         name, description, size, null, salesPrice ) );
92:         assertThrows( ShopException.class, () ->
93:                 merchandiseCatalogUseCases.addMerchandiseToCatalog(
94:                         name, description, size, buyingPrice, null ) );
95:         assertThrows( ShopException.class, () ->
96:                 merchandiseCatalogUseCases.addMerchandiseToCatalog(
97:                         name, description, size, buyingPrice, tooLowSalesPrice ) );
98:     }
99: 
100: 
101:     @Test
102:     public void testRemoveNonExistentMerchandise() {
103:         // given merchandise 2 is not in inventory anywhere - should be removable
104:         UUID nonExistentMerchandiseId = UUID.randomUUID();
105: 
106:         // when
107:         // then
108:         assertThrows( ShopException.class,
109:                 () -> merchandiseCatalogUseCases.removeMerchandiseFromCatalog( nonExistentMerchandiseId ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testRemoveMerchandiseWithNoInventory() {
115:         // given merchandise 0 is not in inventory anywhere - should be removable
116:         UUID merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 );
117:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
118: 
119:         // when
120:         assertDoesNotThrow( () -> merchandiseCatalogUseCases.getSalesPrice( merchandiseId0 ) );
121:         merchandiseCatalogUseCases.removeMerchandiseFromCatalog( merchandiseId0 );
122: 
123:         // then
124:         assertThrows( ShopException.class, () ->
125:                 merchandiseCatalogUseCases.getSalesPrice( merchandiseId0 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testRemoveMerchandiseThatIsInInventory() {
131:         // given
132:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
133:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
134:         UUID merchandiseId3 = merchandiseTestHelper.getMerchandiseId( 3 );
135:         UUID merchandiseId4 = merchandiseTestHelper.getMerchandiseId( 4 );
136:         fulfillmentCenterUseCases.addToInventory( fulfillmentCenterId0, merchandiseId3, 3 );
137: 
138:         // then merchandise 3 must not be removable, but merchandise 4 must be removable
139:         assertThrows( ShopException.class,
140:                 () -> merchandiseCatalogUseCases.removeMerchandiseFromCatalog( merchandiseId3 ) );
141:         assertDoesNotThrow( () -> merchandiseCatalogUseCases.removeMerchandiseFromCatalog( merchandiseId4 ) );
142:     }
143: 
144: 
145:     @Test
146:     public void testRemoveMerchandiseThatIsInPurchase() {
147:         // given
148:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
149:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
150:         UUID merchandiseId4 = merchandiseTestHelper.getMerchandiseId( 4 );
151:         MailAddressType customerMailAddress4 =
152:                 customerTestHelper.getCustomerMailAddress( 4 );
153:         fulfillmentCenterUseCases.addToInventory( fulfillmentCenterId0, merchandiseId4, 4 );
154: 
155:         // when customer 4 adds 4x merchandise 4 to his shopping cart and checks out ...
156:         shoppingCartUseCases.addMerchandiseToShoppingCart(
157:                 customerMailAddress4, merchandiseId4, 4 );
158:         shoppingCartUseCases.checkout( customerMailAddress4 );
159: 
160:         // then merchandise 4 must not be removable
161:         assertThrows( ShopException.class,
162:                 () -> merchandiseCatalogUseCases.removeMerchandiseFromCatalog( merchandiseId4 ) );
163:     }
164: 
165: 
166:     @Test
167:     public void testClearMerchandiseCatalog() {
168:         // given
169:         UUID merchandiseId4 = merchandiseTestHelper.getMerchandiseId( 4 );
170: 
171:         // when
172:         merchandiseCatalogUseCases.deleteMerchandiseCatalog();
173: 
174:         // then
175:         assertThrows( ShopException.class, () -> merchandiseCatalogUseCases.getSalesPrice( merchandiseId4 ) );
176:     }
177: 
178: }
179: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import com.fasterxml.jackson.databind.ObjectMapper;
4: import com.jayway.jsonpath.JsonPath;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
8: import thkoeln.archilab.ecommerce.domainprimitives.Money;
9: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
10: import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
12: 
13: import static org.junit.jupiter.api.Assertions.assertEquals;
14: 
15: 
16: public class DomainPrimitiveJSONSerializationTest {
17: 
18:     @BeforeEach
19:     public void setUp() {
20:         // ... add own setup code here
21:     }
22: 
23: 
24:     /**
25:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
26:      * MailAddress.
27:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
28:      * on how to implement this test, and how to change property names.
29:      * @throws Exception
30:      */
31:     @Test
32:     public void test_MailAddress_Serialization() throws Exception {
33:         // given
34:         MailAddressType mailAddress = MailAddress.of("test@gmail.com");
35:         ObjectMapper mapper = new ObjectMapper();
36: 
37:         // when
38:         String json = mapper.writeValueAsString(mailAddress);
39: 
40:         // then (assert using JsonPath)
41:         String identifier = JsonPath.read( json, "$.identifier" );
42:         String domain = JsonPath.read( json, "$.domain" );
43:         assertEquals( "test", identifier);
44:         assertEquals( "gmail.com", domain );
45:     }
46: 
47: 
48:     /**
49:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
50:      * ZipCode.
51:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
52:      * on how to implement this test, and how to change property names.
53:      * @throws Exception
54:      */
55:     @Test
56:     public void test_ZipCode_Serialization() throws Exception {
57:         // given
58:         ZipCode zipCode = ZipCode.of("12345");
59:         ObjectMapper mapper = new ObjectMapper();
60: 
61:         // when
62:         String json = mapper.writeValueAsString(zipCode);
63: 
64:         // then
65:         String zipCodeString = JsonPath.read( json, "$.zipCodeString" );
66:         assertEquals( "12345", zipCodeString);
67:     }
68: 
69: 
70:     /**
71:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
72:      * PhysicalAddress.
73:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
74:      * on how to implement this test, and how to change property names.
75:      * @throws Exception
76:      */
77:     @Test
78:     public void test_PhysicalAddress_Serialization() throws Exception {
79:         // given
80:         ZipCode zipCode = ZipCode.of("12345");
81:         PhysicalAddress physicalAddress = PhysicalAddress.of("testStreet", "testCity", zipCode);
82:         ObjectMapper mapper = new ObjectMapper();
83: 
84:         // when
85:         String json = mapper.writeValueAsString(physicalAddress);
86: 
87:         // then
88:         String street = JsonPath.read( json, "$.street" );
89:         String city = JsonPath.read( json, "$.city" );
90:         String zipCodeString = JsonPath.read( json, "$.zipCode.zipCodeString" );
91: 
92:         assertEquals( "testStreet", street);
93:         assertEquals( "testCity", city);
94:         assertEquals( "12345", zipCodeString);
95:     }
96: 
97: 
98:     /**
99:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
100:      * Money.
101:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
102:      * on how to implement this test, and how to change property names.
103:      * @throws Exception
104:      */
105:     @Test
106:     public void test_Money_Serialization() throws Exception {
107:         // given
108:         Money money = Money.of(132.25f, "EUR");
109:         ObjectMapper mapper = new ObjectMapper();
110: 
111:         // when
112:         String json = mapper.writeValueAsString(money);
113: 
114:         // then
115:         Double amount = JsonPath.read( json, "$.amount" );
116:         String currency = JsonPath.read( json, "$.currency" );
117: 
118:         assertEquals( 132.25f, amount);
119:         assertEquals( "EUR", currency);
120:     }
121: 
122: }
123: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingCartRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
11: import thkoeln.archilab.ecommerce.domainprimitives.exceptions.MerchandiseNotFoundException;
12: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
13: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
14: import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
15: import thkoeln.archilab.ecommerce.solution.shoppingcart.application.ShoppingCartService;
16: import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
18: import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
19: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
20: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
21: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
22: 
23: import java.util.HashMap;
24: import java.util.Map;
25: import java.util.UUID;
26: 
27: import static org.junit.jupiter.api.Assertions.*;
28: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
29: 
30: 
31: @SpringBootTest
32: @Transactional
33: @AutoConfigureMockMvc
34: @Import( RESTTestHelperConfiguration.class )
35: public class OwnShoppingCartRESTTest {
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private CustomerTestHelper customerTestHelper;
40:     @Autowired
41:     private MerchandiseTestHelper merchandiseTestHelper;
42:     @Autowired
43:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
44:     @Autowired
45:     private ShoppingCartService shoppingCartService;
46:     @Autowired
47:     private ShoppingCartRESTHelper shoppingCartRESTHelper;
48: 
49:     @BeforeEach
50:     public void setUp() {
51:         purgatory.deleteEverything();
52:         customerTestHelper.registerAllCustomers();
53:         merchandiseTestHelper.addAllMerchandises();
54:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
55: 
56:         // ... add own setup code here
57: 
58:         // necessary for test restTestsShouldReferenceMailAddress() to go green,
59:         // because calling customerTestHelper.getCustomerMailAddress() is not recognised by the test
60:         MailAddress.of("test@test.com");
61:     }
62: 
63: 
64:     /**
65:      * Provide a test that implements a simple call to the REST endpoint (3):
66:      * <pre>
67:      *     GET /shoppingCarts?customerId=<customer id as uuid>
68:      * </pre>
69:      * - Use the {@link CustomerTestHelper} to obtain to obtain the mail address
70:      *   of some example customer.
71:      * - Use your shopping cart service to add entries to the shopping cart of that person.
72:      * - then use the `ShoppingCartRESTHelper` to create the GET call, and check the results.
73:      * - (or do it by directly calling your REST controller, if you prefer)
74:      * @throws Exception
75:      */
76:     @Test
77:     public void test_getQuery_ShoppingCart() throws Exception {
78:         // given
79:         MailAddress mailAddress = (MailAddress) customerTestHelper.getCustomerMailAddress(0);
80: 
81:         // when
82:         shoppingCartService.addMerchandiseToShoppingCart(
83:                 mailAddress,
84:                 new MerchandiseId( merchandiseTestHelper.getMerchandiseId(0)),
85:                 7);
86: 
87:         shoppingCartService.addMerchandiseToShoppingCart(
88:                 mailAddress,
89:                 new MerchandiseId( merchandiseTestHelper.getMerchandiseId(1)),
90:                 80);
91: 
92:         shoppingCartService.addMerchandiseToShoppingCart(
93:                 mailAddress,
94:                 new MerchandiseId( merchandiseTestHelper.getMerchandiseId(2)),
95:                 53);
96: 
97:         // then
98:         shoppingCartRESTHelper.getQueryShoppingCart(
99:                 mailAddress,
100:                 shoppingCartService.getShoppingCartAsMap(mailAddress));
101:     }
102: 
103: 
104: 
105:     /**
106:      * Provide a test that implements the addition of one merchandise to the shopping cart via
107:      * REST endpoint (6):
108:      * <pre>
109:      *     POST /shoppingCarts/{shoppingCart-Id}/parts
110:      * </pre>
111:      * You can test now "the other way around" as in test_getQuery_ShoppingCart():
112:      * - Use `ShoppingCartRESTHelper` to add merchandises via REST, then use shopping cart service methods
113:      *   to check of the shopping cart contains the right stuff.
114:      * - (or do it by directly calling your REST controller, if you prefer)
115:      *
116:      * @throws Exception
117:      */
118:     @Test
119:     public void test_post_ShoppingCartParts() throws Exception {
120:         // given
121:         MailAddress mailAddress = (MailAddress) customerTestHelper.getCustomerMailAddress(0);
122: 
123:         shoppingCartService.addMerchandiseToShoppingCart(
124:                 mailAddress,
125:                 new MerchandiseId( merchandiseTestHelper.getMerchandiseId(0)),
126:                 7);
127: 
128:         // when
129:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart(
130:                 mailAddress,
131:                 shoppingCartService.getShoppingCartAsMap(mailAddress));
132: 
133: 
134:         shoppingCartRESTHelper.addMerchandiseToShoppingCart(
135:                 shoppingCartId,
136:                 merchandiseTestHelper.getMerchandiseId(1),
137:                 80
138:         );
139: 
140:         // then
141:         ShoppingCart shoppingCart = shoppingCartService.getShoppingCart(mailAddress);
142:         int quantity = shoppingCart.getQuantity(
143:                 new MerchandiseId(merchandiseTestHelper.getMerchandiseId(1)));
144: 
145:         assertEquals(80, quantity);
146:     }
147: 
148: 
149: 
150:     /**
151:      * Provide a test that implements the deletion of one merchandise in the shopping cart via
152:      * REST endpoint (10):
153:      * <pre>
154:      *     DELETE /shoppingCarts/{shoppingCart-Id}/parts/{merchandise-Id}
155:      * </pre>
156:      * This should be just a slight variation of the test_post_ShoppingCartParts()
157:      * method, but instead of adding an merchandise to the shopping cart, you delete it.
158:      *
159:      * @throws Exception
160:      */
161:     @Test
162:     public void test_delete_ShoppingCartParts() throws Exception {
163:         // given /when
164:         MailAddress mailAddress = (MailAddress) customerTestHelper.getCustomerMailAddress(0);
165: 
166:         shoppingCartService.addMerchandiseToShoppingCart(
167:                 mailAddress,
168:                 new MerchandiseId( merchandiseTestHelper.getMerchandiseId(1)),
169:                 7);
170: 
171:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart(
172:                 mailAddress,
173:                 shoppingCartService.getShoppingCartAsMap(mailAddress));
174: 
175: 
176:         // then
177:         shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart(
178:                 shoppingCartId,
179:                 merchandiseTestHelper.getMerchandiseId(1)
180:         );
181: 
182:         ShoppingCart shoppingCart = shoppingCartService.getShoppingCart(mailAddress);
183:         assertThrows(
184:                 MerchandiseNotFoundException.class,
185:                 () -> shoppingCart.getQuantity(
186:                     new MerchandiseId(merchandiseTestHelper.getMerchandiseId(1))));
187:     }
188: 
189: 
190: 
191:     /**
192:      * Provide a test that implements the checkout of a shopping cart that can be served
193:      * by just 1 fulfillment center, using the REST endpoint (11):
194:      * <pre>
195:      *     POST /shoppingCarts/{shoppingCart-Id}/checkout
196:      * </pre>
197:      * - Use your shopping cart service to add entries to the shopping cart of some example customer,
198:      * - then use the `ShoppingCartRESTHelper to post the checkout call, and to check the results.
199:      * - (or do it by directly calling your REST controller, if you prefer)
200:      *
201:      * @throws Exception
202:      */
203:     @Test
204:     public void test_checkout_1_fulfillmentCenter() throws Exception {
205:         // given
206:         MailAddress mailAddress = (MailAddress) customerTestHelper.getCustomerMailAddress(0);
207:         String customerName = customerTestHelper.getCustomerName(0);
208: 
209:         // when
210:         shoppingCartService.addMerchandiseToShoppingCart(
211:                 mailAddress,
212:                 new MerchandiseId(merchandiseTestHelper.getMerchandiseId(1)),
213:                 10);
214: 
215:         shoppingCartService.addMerchandiseToShoppingCart(
216:                 mailAddress,
217:                 new MerchandiseId(merchandiseTestHelper.getMerchandiseId(2)),
218:                 20);
219: 
220:         shoppingCartService.addMerchandiseToShoppingCart(
221:                 mailAddress,
222:                 new MerchandiseId(merchandiseTestHelper.getMerchandiseId(3)),
223:                 30);
224: 
225:         Map<UUID, Integer> merchandiseMap = shoppingCartService.getShoppingCartAsMap(mailAddress);
226: 
227:         Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>();
228:         expectedPurchases.put(fulfillmentCenterTestHelper.getFulfillmentCenterId(0), merchandiseMap);
229: 
230:         ShoppingCart shoppingCart = shoppingCartService.getShoppingCart(mailAddress);
231: 
232:         // then
233:         shoppingCartRESTHelper.checkout(
234:                 shoppingCart.getId().getId(),
235:                 customerName,
236:                 status().isCreated(),
237:                 expectedPurchases
238:         );
239:     }
240: 
241: 
242: 
243:     /**
244:      * Provide a test that implements the checkout of a shopping cart that can only be served
245:      * by using 2 fulfillment centers, using the REST endpoint (11):
246:      * <pre>
247:      *     POST /shoppingCarts/{shoppingCart-Id}/checkout
248:      * </pre>
249:      * This should be just a slight variation of thetest_checkout_1_fulfillmentCenter() test.
250:      *
251:      * @throws Exception
252:      */
253:     @Test
254:     public void test_checkout_2_fulfillmentCenters() throws Exception {
255:         // given
256:         MailAddress mailAddress = (MailAddress) customerTestHelper.getCustomerMailAddress(0);
257:         String customerName = customerTestHelper.getCustomerName(0);
258: 
259:         // when
260:         MerchandiseId merchandiseId1 = new MerchandiseId(merchandiseTestHelper.getMerchandiseId(1));
261:         shoppingCartService.addMerchandiseToShoppingCart(
262:                 mailAddress,
263:                 merchandiseId1,
264:                 10);
265:         Map<UUID, Integer> merchandiseMap1 = new HashMap<>();
266:         merchandiseMap1.put(merchandiseId1.getId(), 10);
267: 
268:         MerchandiseId merchandiseId12 = new MerchandiseId(merchandiseTestHelper.getMerchandiseId(12));
269:         shoppingCartService.addMerchandiseToShoppingCart(
270:                 mailAddress,
271:                 merchandiseId12,
272:                 1);
273:         Map<UUID, Integer> merchandiseMap12 = new HashMap<>();
274:         merchandiseMap12.put(merchandiseId12.getId(), 1);
275: 
276:         Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>();
277: 
278:         expectedPurchases.put(fulfillmentCenterTestHelper.getFulfillmentCenterId(0), merchandiseMap1);
279:         expectedPurchases.put(fulfillmentCenterTestHelper.getFulfillmentCenterId(5), merchandiseMap12);
280: 
281:         ShoppingCart shoppingCart = shoppingCartService.getShoppingCart(mailAddress);
282: 
283:         // then
284:         shoppingCartRESTHelper.checkout(
285:                 shoppingCart.getId().getId(),
286:                 customerName,
287:                 status().isCreated(),
288:                 expectedPurchases
289:         );
290:     }
291: 
292: }
293: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\purchase\PurchaseTest.java ---
1: package thkoeln.archilab.ecommerce.tests.purchase;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: 
15: import java.util.Map;
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.assertEquals;
19: import static org.junit.jupiter.api.Assertions.assertThrows;
20: 
21: 
22: @SpringBootTest
23: public class PurchaseTest {
24:     @Autowired
25:     private CustomerRegistrationUseCases customerRegistrationUseCases;
26:     @Autowired
27:     private ShoppingCartUseCases shoppingCartUseCases;
28:     @Autowired
29:     private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
30:     @Autowired
31:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
32:     @Autowired
33:     private PurchaseUseCases purchaseUseCases;
34:     @Autowired
35:     private Purgatory purgatory;
36:     @Autowired
37:     private CustomerTestHelper customerTestHelper;
38:     @Autowired
39:     private MerchandiseTestHelper merchandiseTestHelper;
40:     @Autowired
41:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
42: 
43:     private UUID nonExistingId1;
44:     private UUID nonExistingId2;
45: 
46:     @BeforeEach
47:     public void setUp() {
48:         purgatory.deleteEverything();
49:         customerTestHelper.registerAllCustomers();
50:         merchandiseTestHelper.addAllMerchandises();
51:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
52:         nonExistingId1 = UUID.randomUUID();
53:         nonExistingId2 = UUID.randomUUID();
54:     }
55: 
56: 
57:     @Test
58:     public void testPurchaseHistory() {
59:         // given
60:         UUID merchandiseId1 = merchandiseTestHelper.getMerchandiseId( 1 );
61:         UUID merchandiseId2 = merchandiseTestHelper.getMerchandiseId( 2 );
62:         MailAddressType customerMailAddress7 =
63:                 customerTestHelper.getCustomerMailAddress( 7 );
64:         Map<UUID, Integer> purchaseHistoryBefore = purchaseUseCases.getPurchaseHistory( customerMailAddress7 );
65: 
66:         // when
67:         shoppingCartUseCases.addMerchandiseToShoppingCart(
68:                 customerMailAddress7, merchandiseId1, 3 );
69:         shoppingCartUseCases.addMerchandiseToShoppingCart(
70:                 customerMailAddress7, merchandiseId2, 2 );
71:         shoppingCartUseCases.checkout( customerMailAddress7 );
72:         Map<UUID, Integer> purchaseHistory1 =
73:                 purchaseUseCases.getPurchaseHistory( customerMailAddress7 );
74:         shoppingCartUseCases.addMerchandiseToShoppingCart(
75:                 customerMailAddress7, merchandiseId1, 6 );
76:         shoppingCartUseCases.addMerchandiseToShoppingCart(
77:                 customerMailAddress7, merchandiseId2, 2 );
78:         shoppingCartUseCases.checkout( customerMailAddress7 );
79:         Map<UUID, Integer> purchaseHistory2 =
80:                 purchaseUseCases.getPurchaseHistory( customerMailAddress7 );
81:         shoppingCartUseCases.addMerchandiseToShoppingCart(
82:                 customerMailAddress7, merchandiseId1, 1 );
83:         shoppingCartUseCases.addMerchandiseToShoppingCart(
84:                 customerMailAddress7, merchandiseId2, 6 );
85:         shoppingCartUseCases.checkout( customerMailAddress7 );
86:         Map<UUID, Integer> purchaseHistory3 =
87:                 purchaseUseCases.getPurchaseHistory( customerMailAddress7 );
88: 
89:         // then
90:         assertEquals( 0, purchaseHistoryBefore.size() );
91:         assertEquals( 2, purchaseHistory1.size() );
92:         assertEquals( 2, purchaseHistory2.size() );
93:         assertEquals( 2, purchaseHistory3.size() );
94:         assertEquals( 3, purchaseHistory1.get( merchandiseId1 ) );
95:         assertEquals( 2, purchaseHistory1.get( merchandiseId2 ) );
96:         assertEquals( 9, purchaseHistory2.get( merchandiseId1 ) );
97:         assertEquals( 4, purchaseHistory2.get( merchandiseId2 ) );
98:         assertEquals( 10, purchaseHistory3.get( merchandiseId1 ) );
99:         assertEquals( 10, purchaseHistory3.get( merchandiseId2 ) );
100:     }
101: 
102: 
103:     @Test
104:     public void testForEmptyPurchaseHistory() {
105:         // given
106:         MailAddressType customerMailAddress4 =
107:                 customerTestHelper.getCustomerMailAddress( 4 );
108:         // when
109:         Map<UUID, Integer> purchaseHistory =
110:                 purchaseUseCases.getPurchaseHistory( customerMailAddress4 );
111:         // then
112:         assertEquals( 0, purchaseHistory.size() );
113:     }
114: 
115: 
116:     @Test
117:     public void testInvalidParamsForGetPurchaseQuantiOfMerchandise() {
118:         // given
119:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
120: 
121:         // when / then
122:         assertThrows ( ShopException.class,
123:                 () -> purchaseUseCases.getPurchaseQuantiOfMerchandise( null, null ) );
124:         assertThrows ( ShopException.class,
125:                 () -> purchaseUseCases.getPurchaseQuantiOfMerchandise( nonExistingId1, null ) );
126:         assertThrows ( ShopException.class,
127:                 () -> purchaseUseCases.getPurchaseQuantiOfMerchandise( null, nonExistingId2 ) );
128:         assertThrows ( ShopException.class,
129:                 () -> purchaseUseCases.getPurchaseQuantiOfMerchandise( nonExistingId1, nonExistingId2 ) );
130:         assertThrows ( ShopException.class,
131:                 () -> purchaseUseCases.getPurchaseQuantiOfMerchandise( fulfillmentCenterId0, null ) );
132:         assertThrows ( ShopException.class,
133:                 () -> purchaseUseCases.getPurchaseQuantiOfMerchandise( fulfillmentCenterId0, nonExistingId2 ) );
134:     }
135: 
136: 
137:     @Test
138:     public void testInvalidParamsForGetFulfillmentCenterIdForPurchase() {
139:         // given / when / then
140:         assertThrows ( ShopException.class,
141:                 () -> purchaseUseCases.getFulfillmentCenterIdForPurchase( null ) );
142:         assertThrows ( ShopException.class,
143:                 () -> purchaseUseCases.getFulfillmentCenterIdForPurchase( nonExistingId1 ) );
144:     }
145: }
146: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\CheckoutAcceptanceTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingcart;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: 
15: import java.util.*;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: 
19: /**
20:  * This test checks the management of inventory across fulfillment centers. It focuses on the
21:  * cases where more than one fulfillment center are needed to serve the shopping cart of a customer.
22:  */
23: @Slf4j
24: @SpringBootTest
25: public class CheckoutAcceptanceTest {
26:     @Autowired
27:     private CustomerRegistrationUseCases customerRegistrationUseCases;
28:     @Autowired
29:     private ShoppingCartUseCases shoppingCartUseCases;
30:     @Autowired
31:     private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
32:     @Autowired
33:     private PurchaseUseCases purchaseUseCases;
34:     @Autowired
35:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private CustomerTestHelper customerTestHelper;
40:     @Autowired
41:     private MerchandiseTestHelper merchandiseTestHelper;
42:     @Autowired
43:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
44: 
45:     private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
46:                                 map8_11_14_quantity_3_3_4,
47:                                 map10_12_quantity_1_1, 
48:                                 map11_quantity_1, 
49:                                 map12_quantity_10,
50:                                 map8_9_10_11_quantity_2_1_4_2;
51:     private MailAddressType customerMailAddress3, customerMailAddress6,
52:             customerMailAddress2;
53:     private UUID merchandiseId8, merchandiseId9, merchandiseId10, merchandiseId11, merchandiseId12,
54:             merchandiseId14;
55: 
56: 
57:     @BeforeEach
58:     public void setUp() {
59:         purgatory.deleteEverything();
60:         customerTestHelper.registerAllCustomers();
61:         merchandiseTestHelper.addAllMerchandises();
62:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
63: 
64:         customerMailAddress3 = customerTestHelper.getCustomerMailAddress( 3 );
65:         customerMailAddress6 = customerTestHelper.getCustomerMailAddress( 6 );
66:         customerMailAddress2 = customerTestHelper.getCustomerMailAddress( 2 );
67: 
68:         merchandiseId8 = merchandiseTestHelper.getMerchandiseId( 8 );
69:         merchandiseId9 = merchandiseTestHelper.getMerchandiseId( 9 );
70:         merchandiseId10 = merchandiseTestHelper.getMerchandiseId( 10 );
71:         merchandiseId11 = merchandiseTestHelper.getMerchandiseId( 11 );
72:         merchandiseId12 = merchandiseTestHelper.getMerchandiseId( 12 );
73:         merchandiseId14 = merchandiseTestHelper.getMerchandiseId( 14 );
74: 
75:         map8_11_14_quantity_2_2_2 = new HashMap<>() {{
76:             put( merchandiseId8, 2 );
77:             put( merchandiseId11, 2 );
78:             put( merchandiseId14, 2 );
79:         }};
80:         map8_11_14_quantity_3_3_4 = new HashMap<>() {{
81:             put( merchandiseId8, 3 );
82:             put( merchandiseId11, 3 );
83:             put( merchandiseId14, 4 );
84:         }};
85:         map10_12_quantity_1_1 = new HashMap<>() {{
86:             put( merchandiseId10, 1 );
87:             put( merchandiseId12, 1 );
88:         }};
89:         map11_quantity_1 = new HashMap<>() {{
90:             put( merchandiseId11, 1 );
91:         }};
92:         map12_quantity_10 = new HashMap<>() {{
93:             put( merchandiseId12, 10 );
94:         }};
95:         map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
96:             put( merchandiseId8, 2 );
97:             put( merchandiseId9, 1 );
98:             put( merchandiseId10, 4 );
99:             put( merchandiseId11, 2 );
100:         }};
101: 
102:     }
103: 
104: 
105:     /**
106:      * Hint: to better understand the expected results of this test, see the distribution of inventory
107:      * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
108:      */
109:     @Test
110:     public void testClosestSingleFulfillmentCenterWins() {
111:         log.info( "testClosestSingleFulfillmentCenterWins" );
112: 
113:         // given
114:         shoppingCartUseCases.addMerchandiseToShoppingCart(
115:                 customerMailAddress3, merchandiseId8, 2 );
116:         shoppingCartUseCases.addMerchandiseToShoppingCart(
117:                 customerMailAddress3, merchandiseId11, 2 );
118:         shoppingCartUseCases.addMerchandiseToShoppingCart(
119:                 customerMailAddress3, merchandiseId14, 2 );
120:         // that basket could have been served from fulfillment center 4 or 7, but 4 is closer to the customer
121:         UUID fulfillmentCenterId4 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 4 );
122: 
123:         // when
124:         Set<UUID> purchaseIds = shoppingCartUseCases.checkout( customerMailAddress3 );
125: 
126:         // then
127:         checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId4 );
128:         checkMerchandiseNumbers( purchaseIds, fulfillmentCenterId4, map8_11_14_quantity_2_2_2 );
129:     }
130: 
131: 
132:     /**
133:      * Hint: to better understand the expected results of this test, see the distribution of inventory
134:      * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
135:      */
136:     @Test
137:     public void testFulfillmentCenterWithEnoughCapacityWins() {
138:         log.info( "testFulfillmentCenterWithEnoughCapacityWins" );
139: 
140:         // given
141:         shoppingCartUseCases.addMerchandiseToShoppingCart(
142:                 customerMailAddress3, merchandiseId8, 3 );
143:         shoppingCartUseCases.addMerchandiseToShoppingCart(
144:                 customerMailAddress3, merchandiseId11, 3 );
145:         shoppingCartUseCases.addMerchandiseToShoppingCart(
146:                 customerMailAddress3, merchandiseId14, 4 );
147:         // that basket could have been served from fulfillment center 4 or 7, 4 is closer to the customer,
148:         // but only 7 has enough capacity
149:         UUID fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );
150: 
151:         // when
152:         Set<UUID> purchaseIds = shoppingCartUseCases.checkout( customerMailAddress3 );
153: 
154:         // then
155:         checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId7 );
156:         checkMerchandiseNumbers( purchaseIds, fulfillmentCenterId7, map8_11_14_quantity_3_3_4 );
157:     }
158: 
159: 
160:     /**
161:      * Hint: to better understand the expected results of this test, see the distribution of inventory
162:      * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
163:      */
164:     @Test
165:     public void testTwoFulfillmentCenters() {
166:         log.info( "testTwoFulfillmentCenters" );
167: 
168:         // given
169:         shoppingCartUseCases.addMerchandiseToShoppingCart(
170:                 customerMailAddress6, merchandiseId10, 1 );
171:         shoppingCartUseCases.addMerchandiseToShoppingCart(
172:                 customerMailAddress6, merchandiseId11, 1 );
173:         shoppingCartUseCases.addMerchandiseToShoppingCart(
174:                 customerMailAddress6, merchandiseId12, 1 );
175:         // that basket needs two shipments (2 + 1 merchandises) anyway, and there
176:         // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
177:         // closer. The smaller can then be served from 4 (closest), 7, or 8.
178:         UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
179:                 // should cover map10_12_quantity_1_1
180:         UUID fulfillmentCenterId4 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 4 );
181:                 // should cover map11_quantity_1
182: 
183:         // when
184:         Set<UUID> purchaseIds = shoppingCartUseCases.checkout( customerMailAddress6 );
185: 
186:         // then
187:         checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId5, fulfillmentCenterId4 );
188:         checkMerchandiseNumbers( purchaseIds, fulfillmentCenterId5, map10_12_quantity_1_1 );
189:         checkMerchandiseNumbers( purchaseIds, fulfillmentCenterId4, map11_quantity_1 );
190:     }
191: 
192: 
193:     /**
194:      * Hint: to better understand the expected results of this test, see the distribution of inventory
195:      * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
196:      */
197:     @Test
198:     public void testTwoBigShipments() {
199:         log.info( "testTwoBigShipments" );
200: 
201:         // given
202:         shoppingCartUseCases.addMerchandiseToShoppingCart(
203:                 customerMailAddress2, merchandiseId8, 2 );
204:         shoppingCartUseCases.addMerchandiseToShoppingCart(
205:                 customerMailAddress2, merchandiseId9, 1 );
206:         shoppingCartUseCases.addMerchandiseToShoppingCart(
207:                 customerMailAddress2, merchandiseId10, 4 );
208:         shoppingCartUseCases.addMerchandiseToShoppingCart(
209:                 customerMailAddress2, merchandiseId11, 2 );
210:         shoppingCartUseCases.addMerchandiseToShoppingCart(
211:                 customerMailAddress2, merchandiseId12, 10 );
212:         // when
213:         Set<UUID> purchaseIds = shoppingCartUseCases.checkout( customerMailAddress2 );
214:         UUID fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );
215:                 // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 merchandises
216:         UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
217:                 // should cover map12_quantity_10 - the only fulfillment center with enough capacity for 10 merchandises
218: 
219:         // then
220:         checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId7, fulfillmentCenterId5 );
221:         checkMerchandiseNumbers( purchaseIds, fulfillmentCenterId7, map8_9_10_11_quantity_2_1_4_2 );
222:         checkMerchandiseNumbers( purchaseIds, fulfillmentCenterId5, map12_quantity_10 );
223:     }
224: 
225: 
226:     /**
227:      * Hint: to better understand the expected results of this test, see the distribution of inventory
228:      * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
229:      */
230:     @Test
231:     public void testOnlyOneSolution() {
232:         log.info( "testOnlyOneSolution" );
233: 
234:         // given
235:         shoppingCartUseCases.addMerchandiseToShoppingCart(
236:                 customerMailAddress6, merchandiseId12, 10 );
237:         // when
238:         Set<UUID> purchaseIds = shoppingCartUseCases.checkout( customerMailAddress6 );
239:         UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
240:         // should cover map12_quantity_10 - the only fulfillment center with enough capacity for 10 merchandises
241: 
242:         // then
243:         checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId5 );
244:         checkMerchandiseNumbers( purchaseIds, fulfillmentCenterId5, map12_quantity_10 );
245:     }
246: 
247: 
248: 
249:     private void checkMerchandiseNumbers( Set<UUID> purchaseIds, UUID fulfillmentCenterId, Map<UUID, Integer> expectedMap ) {
250:         UUID fittingPurchaseId = null;
251:         for ( UUID purchaseId : purchaseIds ) {
252:             UUID foundFulfillmentCenterId = purchaseUseCases.getFulfillmentCenterIdForPurchase( purchaseId );
253:             if ( foundFulfillmentCenterId.equals( fulfillmentCenterId ) ) {
254:                 fittingPurchaseId = purchaseId;
255:                 break;
256:             }
257:         }
258:         assertNotNull( fittingPurchaseId, "No fitting purchase found for fulfillment center " + fulfillmentCenterId );
259: 
260:         int totalExpected = 0;
261:         int totalActual = 0;
262:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
263:             totalExpected += entry.getValue();
264:         }
265:         log.info( "Check purchase numbers for merchandise {} in fulfillment center {}", fittingPurchaseId, fulfillmentCenterId );
266:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
267:             UUID merchandiseId = entry.getKey();
268:             Integer foundNumber =
269:                     purchaseUseCases.getPurchaseQuantiOfMerchandise( fittingPurchaseId, merchandiseId );
270:             assertEquals( entry.getValue(), foundNumber );
271:             totalActual += foundNumber;
272:         }
273:         // last check - do the total sums match?
274:         assertEquals( totalExpected, totalActual );
275:     }
276: 
277: 
278:     private void checkFulfillmentCenterIds( Set<UUID> purchaseIds, UUID... expectedFulfillmentCenterIds ) {
279:         assertEquals( expectedFulfillmentCenterIds.length, purchaseIds.size() );
280:         Set<UUID> foundFulfillmentCenterIds = new HashSet<>();
281:         for ( UUID purchaseId : purchaseIds ) {
282:             UUID fulfillmentCenterId = purchaseUseCases.getFulfillmentCenterIdForPurchase( purchaseId );
283:             foundFulfillmentCenterIds.add( fulfillmentCenterId );
284:         }
285:         for ( UUID expectedFulfillmentCenterId : expectedFulfillmentCenterIds ) {
286:             assertTrue( foundFulfillmentCenterIds.contains( expectedFulfillmentCenterId ) );
287:         }
288:     }
289: 
290: }
291: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\ShoppingCartRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingcart;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.ResultMatcher;
12: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
13: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
14: import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
15: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
17: import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
18: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
19: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
20: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
21: 
22: import java.util.HashMap;
23: import java.util.Map;
24: import java.util.UUID;
25: 
26: import static org.junit.jupiter.api.Assertions.assertEquals;
27: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
28: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
29: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMailAddress;
30: 
31: 
32: @SpringBootTest
33: @Transactional
34: @AutoConfigureMockMvc
35: @Import( RESTTestHelperConfiguration.class )
36: public class ShoppingCartRESTTest {
37:     @Autowired
38:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
39:     @Autowired
40:     private ShoppingCartUseCases shoppingCartUseCases;
41:     @Autowired
42:     private Purgatory purgatory;
43:     @Autowired
44:     private CustomerTestHelper customerTestHelper;
45:     @Autowired
46:     private MerchandiseTestHelper merchandiseTestHelper;
47:     @Autowired
48:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
49:     @Autowired
50:     private MockMvc mockMvc;
51:     @Autowired
52:     private ShoppingCartRESTHelper shoppingCartRESTHelper;
53: 
54:     private MailAddressType nonExistingMailAddress;
55:     private final Map<UUID, Integer> emptyMap = new HashMap<>();
56: 
57:     private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
58:     private MailAddressType
59:             customerMailAddress0,
60:             customerMailAddress3,
61:             customerMailAddress6,
62:             customerMailAddress8;
63:     private String customerName0, customerName8;
64:     private UUID merchandiseId0, merchandiseId1, merchandiseId2, merchandiseId3, merchandiseId5,
65:                  merchandiseId7, merchandiseId9, merchandiseId11, nonExistentMerchandiseId;
66:     private UUID fulfillmentCenterId0, fulfillmentCenterId3, fulfillmentCenterId7, fulfillmentCenterId8;
67: 
68: 
69:     private static final ResultMatcher NOT_FOUND = status().isNotFound();
70:     private static final ResultMatcher OK = status().isOk();
71:     private static final ResultMatcher CREATED = status().isCreated();
72:     private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
73:     private static final ResultMatcher CONFLICT = status().isConflict();
74: 
75:     @BeforeEach
76:     public void setUp() {
77:         purgatory.deleteEverything();
78:         customerTestHelper.registerAllCustomers();
79:         merchandiseTestHelper.addAllMerchandises();
80:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
81:         nonExistingMailAddress = instantiateMailAddress( "harry@sally.de" );
82: 
83:         customerMailAddress0 = customerTestHelper.getCustomerMailAddress( 0 );
84:         customerMailAddress3 = customerTestHelper.getCustomerMailAddress( 3 );
85:         customerMailAddress6 = customerTestHelper.getCustomerMailAddress( 6 );
86:         customerMailAddress8 = customerTestHelper.getCustomerMailAddress( 8 );
87:         customerName0 = customerTestHelper.getCustomerName( 0 );
88:         customerName8 = customerTestHelper.getCustomerName( 8 );
89: 
90:         merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 );
91:         merchandiseId1 = merchandiseTestHelper.getMerchandiseId( 1 );
92:         merchandiseId2 = merchandiseTestHelper.getMerchandiseId( 2 );
93:         merchandiseId3 = merchandiseTestHelper.getMerchandiseId( 3 );
94:         merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 );
95:         merchandiseId7 = merchandiseTestHelper.getMerchandiseId( 7 );
96:         merchandiseId9 = merchandiseTestHelper.getMerchandiseId( 9 );
97:         merchandiseId11 = merchandiseTestHelper.getMerchandiseId( 11 );
98:         nonExistentMerchandiseId = UUID.randomUUID();
99: 
100:         fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
101:         fulfillmentCenterId3 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 3 );
102:         fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );
103:         fulfillmentCenterId8 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 8 );
104: 
105:         map9_quantity_1 = new HashMap<>() {{
106:             put( merchandiseId9, 1 );
107:         }};
108:         map5_quantity_2 = new HashMap<>() {{
109:             put( merchandiseId5, 2 );
110:         }};
111:         map7_quantity_7 = new HashMap<>() {{
112:             put( merchandiseId7, 7 );
113:         }};
114:         map9_11_quantity_2_2 = new HashMap<>() {{
115:             put( merchandiseId9, 2 );
116:             put( merchandiseId11, 2 );
117:         }};
118:     }
119: 
120: 
121:     @Test
122:     public void testInvalidShoppingCartBaseUris() throws Exception {
123:         // given
124:         String allShoppingCartsUri = "/shoppingCarts";
125:         String randomIdUri = "/shoppingCarts/" + UUID.randomUUID();
126:         String randomCustomerUUID = "/shoppingCarts?customerId=" + UUID.randomUUID();
127:         String invalidCustomerUUID = "/shoppingCarts?customerId=invalidUUID";
128:         String randomParamUri = "/shoppingCarts?randomParam=randomValue";
129: 
130:         // when
131:         // then
132:         mockMvc.perform( get( allShoppingCartsUri ) ).andExpect( status().isMethodNotAllowed() );
133:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
134:         mockMvc.perform( get( randomCustomerUUID ) ).andExpect( status().isNotFound() );
135:         mockMvc.perform( get( invalidCustomerUUID ) ).andExpect( status().isNotFound() );
136:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
137:     }
138: 
139: 
140:     @Test
141:     public void testInvalidPartUris() throws Exception {
142:         // given
143:         UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress8, emptyMap );
144:         String randomPartUri = "/shoppingCarts/" + shoppingCartId8.toString() + "/random";
145:         String randomMerchandiseUri = "/shoppingCarts/" + shoppingCartId8.toString()
146:                 + "/parts/" + UUID.randomUUID();
147: 
148:         // when
149:         // then
150:         mockMvc.perform( post( randomPartUri ) ).andExpect( status().isNotFound() );
151:         mockMvc.perform( delete( randomMerchandiseUri ) ).andExpect( status().isNotFound() );
152:     }
153: 
154: 
155:     @Test
156:     public void testInvalidAddToShoppingCart() throws Exception {
157:         // given
158:         Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
159:         expectedStartQuantityMap.put( merchandiseId2, 19 );
160: 
161:         // when
162:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress0, emptyMap );
163:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId, merchandiseId2, 6 );
164:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId, merchandiseId2, 13 );
165: 
166:         // then
167:         shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress0, expectedStartQuantityMap );
168: 
169:         // ... and check a couple of invalid cases
170:         shoppingCartRESTHelper.addMerchandiseToShoppingCart(
171:                 shoppingCartId, nonExistentMerchandiseId, 12, NOT_FOUND );
172:         shoppingCartRESTHelper.addMerchandiseToShoppingCart(
173:                 UUID.randomUUID(), merchandiseId5, 12, NOT_FOUND );
174:         shoppingCartRESTHelper.addMerchandiseToShoppingCart(
175:                 shoppingCartId, merchandiseId5, -1, UNPROCESSABLE_ENTITY );
176: 
177:         // check if the shopping cart is still the same
178:         shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress0, expectedStartQuantityMap );
179:     }
180: 
181: 
182:     @Test
183:     public void testInvalidCheckout_unavailableMerchandise() throws Exception {
184:         // given
185:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress0, emptyMap );
186: 
187:         // when
188:         // productId0 is not available in the requested quantity (or rather, not at all)
189:         shoppingCartRESTHelper.addMerchandiseToShoppingCart(
190:                 shoppingCartId, merchandiseId0, 1, CREATED );
191: 
192:         // check if the shopping cart is still the same
193:         shoppingCartRESTHelper.checkout( shoppingCartId, null, CONFLICT, null );
194:     }
195: 
196: 
197:     @Test
198:     public void testInvalidCheckout_tooLittleInventory() throws Exception {
199:         // given
200:         UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress0, emptyMap );
201: 
202:         // when
203:         // There are only 10 pieces of productId1 available
204:         shoppingCartRESTHelper.addMerchandiseToShoppingCart(
205:                 shoppingCartId, merchandiseId1, 11, CREATED );
206: 
207:         // check if the shopping cart is still the same
208:         shoppingCartRESTHelper.checkout( shoppingCartId, null, CONFLICT, null );
209:     }
210: 
211: 
212: 
213:     @Test
214:     public void testDeleteMerchandiseFromShoppingCart() throws Exception {
215:         // given
216:         UUID shoppingCartId6 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, emptyMap );
217:         Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
218:         expectedQuantityMap1.put( merchandiseId1, 1 );
219:         expectedQuantityMap1.put( merchandiseId2, 2 );
220:         expectedQuantityMap1.put( merchandiseId3, 3 );
221:         Map<UUID, Integer> quantityMap2 = new HashMap<>();
222:         quantityMap2.put( merchandiseId1, 1 );
223:         quantityMap2.put( merchandiseId3, 3 );
224: 
225:         // when
226:         // then
227:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId6, merchandiseId1, 1 );
228:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId6, merchandiseId2, 2 );
229:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId6, merchandiseId3, 3 );
230:         shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, expectedQuantityMap1 );
231: 
232:         shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart( shoppingCartId6, merchandiseId2 );
233:         shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, quantityMap2 );
234:     }
235: 
236: 
237:     @Test
238:     public void testNoDoubleDelete() throws Exception {
239:         // given
240:         UUID shoppingCartId6 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, emptyMap );
241: 
242:         // when
243:         // then
244:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId6, merchandiseId3, 3 );
245:         shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart( shoppingCartId6, merchandiseId3 );
246:         shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, new HashMap<>() );
247:         shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart( shoppingCartId6, merchandiseId3, NOT_FOUND );
248:     }
249: 
250: 
251:     @Test
252:     public void testAddRemoveMerchandisesFromAndToShoppingCart() throws Exception {
253:         // given
254:         UUID shoppingCartId3 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress3, emptyMap );
255:         UUID shoppingCartId5 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, emptyMap );
256: 
257:         // when
258:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId3, merchandiseId1, 2 );
259:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId3, merchandiseId2, 3 );
260:         shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart( shoppingCartId3, merchandiseId1 );
261:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId3, merchandiseId1, 1 );
262:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId3, merchandiseId2, 6 );
263: 
264:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId5, merchandiseId1, 2 );
265:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId5, merchandiseId2, 8 );
266:         shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart( shoppingCartId5, merchandiseId1 );
267:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId5, merchandiseId1, 1 );
268:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId5, merchandiseId2, 2 );
269: 
270:         // then
271:         // customer3 has 1x merchandiseId1 and 9x merchandiseId2 expected in cart
272:         Map<UUID, Integer> expectedMap3 = new HashMap<>();
273:         expectedMap3.put( merchandiseId1, 1 );
274:         expectedMap3.put( merchandiseId2, 9 );
275:         shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress3, expectedMap3 );
276: 
277:         // customer6 has 1x merchandiseId1 and 10x merchandiseId2 in cart
278:         Map<UUID, Integer> expectedMap5 = new HashMap<>();
279:         expectedMap5.put( merchandiseId1, 1 );
280:         expectedMap5.put( merchandiseId2, 10 );
281:         shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, expectedMap5 );
282:     }
283: 
284: 
285:     @Test
286:     public void testNoDoubleCheckout() throws Exception {
287:         // given
288:         UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress8, emptyMap );
289: 
290:         // when
291:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId8, merchandiseId2, 3 );
292: 
293:         // then
294:         shoppingCartRESTHelper.checkout( shoppingCartId8, customerName8, CREATED, null );
295:         shoppingCartRESTHelper.checkout( shoppingCartId8, null, CONFLICT, null );
296:     }
297: 
298: 
299:     @Test
300:     public void testCheckout_1_Purchase() throws Exception {
301:         // given:
302:         // Customer 0 wants to buy 1x merchandise 9. This is in fulfillment center 5, 7, and 8. Out of these,
303:         // fulfillment center 8 with zip code 89250 is closest to customer 0 with zip code 02314.
304:         Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>() {{
305:             put( fulfillmentCenterId8, map9_quantity_1 );
306:         }};
307:         UUID shoppingCartId0 = shoppingCartRESTHelper.getQueryShoppingCart(
308:                 customerMailAddress0, null );
309:         int inventory9before =
310:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId8, merchandiseId9 );
311: 
312:         // when
313:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId0, merchandiseId9, 1 );
314:         shoppingCartRESTHelper.checkout( shoppingCartId0, customerName0, CREATED, expectedPurchases );
315:         int inventory9after =
316:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId8, merchandiseId9 );
317: 
318:         // then
319:         assertEquals( 1, inventory9before - inventory9after );
320:     }
321: 
322: 
323:     @Test
324:     public void testCheckout_3_Purchase() throws Exception {
325:         // given:
326:         // Customer 8 (Felix Bauer) wants to buy 2x each of merchandises 5, 9, 11; and 7x merchandise 7.
327:         //       - merchandises 9 and 11 can both be found in fulfillment centers 7 and 8. Fulfillment centers 7 (76532) is closer to
328:         //         the customer (70173)
329:         //       - merchandise 7 is available in fulfillment centers 1, 2, and 3, but only fulfillment center 3 has enough inventory.
330:         //       - merchandise 5 is only available in fulfillment center 0.
331:         Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>() {{
332:             put( fulfillmentCenterId0, map5_quantity_2 );
333:             put( fulfillmentCenterId3, map7_quantity_7 );
334:             put( fulfillmentCenterId7, map9_11_quantity_2_2 );
335:         }};
336:         UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart(
337:                 customerMailAddress8, null );
338:         int inventory5before =
339:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId5 );
340:         int inventory7before =
341:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId3, merchandiseId7 );
342:         int inventory9before =
343:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId7, merchandiseId9 );
344:         int inventory11before =
345:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId7, merchandiseId11 );
346: 
347:         // when
348:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId8, merchandiseId5, 2 );
349:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId8, merchandiseId7, 7 );
350:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId8, merchandiseId9, 2 );
351:         shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId8, merchandiseId11, 2 );
352:         shoppingCartRESTHelper.checkout( shoppingCartId8, customerName8, CREATED, expectedPurchases );
353:         int inventory5after =
354:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId5 );
355:         int inventory7after =
356:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId3, merchandiseId7 );
357:         int inventory9after =
358:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId7, merchandiseId9 );
359:         int inventory11after =
360:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId7, merchandiseId11 );
361: 
362:         // then
363:         assertEquals( 2, inventory5before - inventory5after );
364:         assertEquals( 7, inventory7before - inventory7after );
365:         assertEquals( 2, inventory9before - inventory9after );
366:         assertEquals( 2, inventory11before - inventory11after );
367:     }
368: 
369: 
370: }
371: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\ShoppingCartTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingcart;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.InsufficientInventoryException;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
12: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
13: import thkoeln.archilab.ecommerce.usecases.*;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
16: 
17: 
18: import java.util.Map;
19: import java.util.UUID;
20: 
21: import static org.junit.jupiter.api.Assertions.*;
22: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
23: 
24: @SpringBootTest
25: public class ShoppingCartTest {
26:     @Autowired
27:     private CustomerRegistrationUseCases customerRegistrationUseCases;
28:     @Autowired
29:     private ShoppingCartUseCases shoppingCartUseCases;
30:     @Autowired
31:     private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
32:     @Autowired
33:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
34:     @Autowired
35:     private PurchaseUseCases purchaseUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private CustomerTestHelper customerTestHelper;
40:     @Autowired
41:     private MerchandiseTestHelper merchandiseTestHelper;
42:     @Autowired
43:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
44: 
45:     private MailAddressType nonExistingMailAddress;
46: 
47:     @BeforeEach
48:     public void setUp() {
49:         purgatory.deleteEverything();
50:         customerTestHelper.registerAllCustomers();
51:         merchandiseTestHelper.addAllMerchandises();
52: 
53:         nonExistingMailAddress = instantiateMailAddress( "this@nononono.de" );
54:     }
55: 
56: 
57:     @Test
58:     public void testInvalidAddToShoppingCart() {
59:         // given
60:         UUID nonExistentMerchandiseId = UUID.randomUUID();
61:         UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 );
62:         UUID merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 );
63:         MailAddressType customerMailAddress0 =
64:                 customerTestHelper.getCustomerMailAddress( 0 );
65:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
66: 
67:         // then
68:         assertThrows( ShopException.class,
69:                 () -> shoppingCartUseCases.addMerchandiseToShoppingCart(
70:                         nonExistingMailAddress, merchandiseId0, 1 ) );
71:         assertThrows( ShopException.class,
72:                 () -> shoppingCartUseCases.addMerchandiseToShoppingCart(
73:                         null, merchandiseId0, 1 ) );
74:         assertThrows( ShopException.class,
75:                 () -> shoppingCartUseCases.addMerchandiseToShoppingCart(
76:                         customerMailAddress0, nonExistentMerchandiseId, 1 ) );
77:         assertThrows( ShopException.class,
78:                 () -> shoppingCartUseCases.addMerchandiseToShoppingCart(
79:                         customerMailAddress0, null, 1 ) );
80:         assertThrows( ShopException.class,
81:                 () -> shoppingCartUseCases.addMerchandiseToShoppingCart(
82:                         customerMailAddress0, merchandiseId5, -1 ) );
83:     }
84: 
85: 
86:     @Test
87:     public void testInvalidRemoveFromShoppingCart() {
88:         // given
89:         UUID nonExistentMerchandiseId = UUID.randomUUID();
90:         UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 );
91:         UUID merchandiseId1 = merchandiseTestHelper.getMerchandiseId( 1 );
92:         UUID merchandiseId2 = merchandiseTestHelper.getMerchandiseId( 2 );
93:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
94:         MailAddressType customerMailAddress0 =
95:                 customerTestHelper.getCustomerMailAddress( 0 );
96:         shoppingCartUseCases.addMerchandiseToShoppingCart(
97:                 customerMailAddress0, merchandiseId1, 5 );
98:         shoppingCartUseCases.addMerchandiseToShoppingCart(
99:                 customerMailAddress0, merchandiseId2, 15 );
100: 
101:         // when
102:         shoppingCartUseCases.removeMerchandiseFromShoppingCart(
103:                 customerMailAddress0, merchandiseId1, 2 );
104:         shoppingCartUseCases.removeMerchandiseFromShoppingCart(
105:                 customerMailAddress0, merchandiseId2, 4 );
106:         shoppingCartUseCases.removeMerchandiseFromShoppingCart(
107:                 customerMailAddress0, merchandiseId2, 7 );
108:         // now we should have 3x merchandiseId1 and 4x merchandiseId2 in the shopping cart
109: 
110:         // then
111:         assertThrows( ShopException.class,
112:                 () -> shoppingCartUseCases.removeMerchandiseFromShoppingCart(
113:                         customerMailAddress0, nonExistentMerchandiseId, 12 ) );
114:         assertThrows( ShopException.class,
115:                 () -> shoppingCartUseCases.removeMerchandiseFromShoppingCart(
116:                         nonExistingMailAddress, merchandiseId5, 12 ) );
117:         assertThrows( ShopException.class,
118:                 () -> shoppingCartUseCases.removeMerchandiseFromShoppingCart(
119:                         customerMailAddress0, merchandiseId5, -1 ) );
120:         assertThrows( ShopException.class,
121:                 () -> shoppingCartUseCases.removeMerchandiseFromShoppingCart(
122:                         customerMailAddress0, merchandiseId1, 4 ) );
123:         assertThrows( ShopException.class,
124:                 () -> shoppingCartUseCases.removeMerchandiseFromShoppingCart(
125:                         customerMailAddress0, merchandiseId2, 5 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testAddRemoveMerchandisesFromAndToShoppingCart() {
131:         // given
132:         UUID merchandiseId1 = merchandiseTestHelper.getMerchandiseId( 1 );
133:         UUID merchandiseId2 = merchandiseTestHelper.getMerchandiseId( 2 );
134:         MailAddressType customerMailAddress3 =
135:                 customerTestHelper.getCustomerMailAddress( 3 );
136:         MailAddressType customerMailAddress5 =
137:                 customerTestHelper.getCustomerMailAddress( 5 );
138: 
139:         // when customer 3 ...
140:         shoppingCartUseCases.addMerchandiseToShoppingCart(
141:                 customerMailAddress3, merchandiseId1, 2 );
142:         shoppingCartUseCases.addMerchandiseToShoppingCart(
143:                 customerMailAddress3, merchandiseId2, 3 );
144:         shoppingCartUseCases.removeMerchandiseFromShoppingCart(
145:                 customerMailAddress3, merchandiseId1, 2 );
146:         shoppingCartUseCases.addMerchandiseToShoppingCart(
147:                 customerMailAddress3, merchandiseId1, 1 );
148:         shoppingCartUseCases.addMerchandiseToShoppingCart(
149:                 customerMailAddress3, merchandiseId2, 6 );
150:         Map<UUID, Integer> cart3 = shoppingCartUseCases.getShoppingCartAsMap( customerMailAddress3 );
151:         // customer3 has 1x merchandiseId1 and 9x merchandiseId2 in cart
152: 
153:         // ... and when customer 5 ...
154:         shoppingCartUseCases.addMerchandiseToShoppingCart(
155:                 customerMailAddress5, merchandiseId1, 2 );
156:         shoppingCartUseCases.addMerchandiseToShoppingCart(
157:                 customerMailAddress5, merchandiseId2, 8 );
158:         shoppingCartUseCases.removeMerchandiseFromShoppingCart(
159:                 customerMailAddress5, merchandiseId1, 1 );
160:         shoppingCartUseCases.addMerchandiseToShoppingCart(
161:                 customerMailAddress5, merchandiseId2, 2 );
162:         Map<UUID, Integer> cart5 = shoppingCartUseCases.getShoppingCartAsMap( customerMailAddress5 );
163:         // customer5 has 1x merchandiseId1 and 10x merchandiseId2 in cart
164: 
165:         // then
166:         assertEquals( 2, cart3.size() );
167:         assertEquals( 1, cart3.get( merchandiseId1 ) );
168:         assertEquals( 9, cart3.get( merchandiseId2 ) );
169: 
170:         assertEquals( 2, cart5.size() );
171:         assertEquals( 1, cart5.get( merchandiseId1 ) );
172:         assertEquals( 10, cart5.get( merchandiseId2 ) );
173:     }
174: 
175: 
176:     @Test
177:     public void testShoppingCartValue() {
178:         // given
179:         UUID merchandiseId3 = merchandiseTestHelper.getMerchandiseId( 3 );
180:         UUID merchandiseId6 = merchandiseTestHelper.getMerchandiseId( 6 );
181:         UUID merchandiseId8 = merchandiseTestHelper.getMerchandiseId( 8 );
182:         MoneyType price3 = merchandiseTestHelper.getSalesPrice( 3 );
183:         MoneyType price6 = merchandiseTestHelper.getSalesPrice( 6 );
184:         MoneyType price8 = merchandiseTestHelper.getSalesPrice( 8 );
185:         MailAddressType customerMailAddress3 =
186:                 customerTestHelper.getCustomerMailAddress( 3 );
187: 
188:         // when
189:         shoppingCartUseCases.addMerchandiseToShoppingCart( customerMailAddress3, merchandiseId3, 3 );
190:         shoppingCartUseCases.addMerchandiseToShoppingCart( customerMailAddress3, merchandiseId6, 2 );
191:         shoppingCartUseCases.addMerchandiseToShoppingCart( customerMailAddress3, merchandiseId8, 5 );
192:         // customer3 has 3x merchandiseId3, 2x merchandiseId6 and 5x merchandiseId8 in cart
193:         MoneyType cartValue = shoppingCartUseCases.getShoppingCartAsMoneyValue( customerMailAddress3 );
194: 
195:         // then
196:         assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
197:                 cartValue );
198:     }
199: 
200: 
201:     @Test
202:     public void testShoppingCartValueInvalid() {
203:         // given
204:         // when
205:         // then
206:         assertThrows( ShopException.class,
207:                 () -> shoppingCartUseCases.getShoppingCartAsMoneyValue( nonExistingMailAddress ) );
208:     }
209: 
210: 
211:     @Test
212:     public void testUnsuccessfulCheckout() {
213:         // given customer buying merchandise 0 (which is not in inventory), and customer 1 buying merchandise 1
214:         // in a bigger quantity (11) than available (10)
215:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
216:         MailAddressType customerMailAddress0 =
217:                 customerTestHelper.getCustomerMailAddress( 0 );
218:         MailAddressType customerMailAddress1 =
219:                 customerTestHelper.getCustomerMailAddress( 1 );
220:         UUID merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 );
221:         UUID merchandiseId1 = merchandiseTestHelper.getMerchandiseId( 1 );
222: 
223:         // when
224:         shoppingCartUseCases.addMerchandiseToShoppingCart(
225:                 customerMailAddress0, merchandiseId0, 1 );
226:         shoppingCartUseCases.addMerchandiseToShoppingCart(
227:                 customerMailAddress1, merchandiseId1, 11 );
228: 
229:         // then
230:         assertThrows( InsufficientInventoryException.class,
231:                 () -> shoppingCartUseCases.checkout( customerMailAddress0 ) );
232:         assertThrows( InsufficientInventoryException.class,
233:                 () -> shoppingCartUseCases.checkout( customerMailAddress1 ) );
234:     }
235: 
236: }
237: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
1: package thkoeln.archilab.ecommerce.tests.testtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.domain.JavaMethod;
6: import com.tngtech.archunit.core.importer.ClassFileImporter;
7: import com.tngtech.archunit.lang.ArchRule;
8: import org.junit.jupiter.api.BeforeEach;
9: import org.junit.jupiter.api.Test;
10: import org.springframework.web.bind.annotation.RestController;
11: import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
12: import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
13: import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingCartRESTTest;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
18: 
19: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
20: import static org.springframework.test.util.AssertionErrors.assertTrue;
21: 
22: /**
23:  * This test checks if there are the appropriate tests in the test class(es) for domain
24:  * primitives.
25:  */
26: 
27: public class RulesForOwnTests {
28:     private JavaClass dpTestClass, restTestClass;
29:     private JavaClasses dpTestClasses, restTestClasses;
30:     private static final String FULFILLMENT_CENTER_DOMAIN_PACKAGE =
31:             "thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain";
32:     private static final String FULFILLMENT_CENTER_CLASS_NAME =
33:             FULFILLMENT_CENTER_DOMAIN_PACKAGE + ".FulfillmentCenter";
34: 
35: 
36:     @BeforeEach
37:     public void setUp() throws Exception {
38:         dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
39:         restTestClass = new ClassFileImporter().importClass( OwnShoppingCartRESTTest.class );
40: 
41:         dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
42:         restTestClasses = new ClassFileImporter().importClasses( OwnShoppingCartRESTTest.class );
43:     }
44: 
45: 
46:     @Test
47:     public void ensureMinimumNumberOfTestMethods() {
48:         // given
49:         // when
50:         int dpTestMethodCount = getTestMethodCount( dpTestClass );
51:         int restTestMethodCount = getTestMethodCount( restTestClass );
52: 
53:         // then
54:         assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
55:                         + dpTestMethodCount,dpTestMethodCount >= 2 );
56:         assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
57:                         + restTestMethodCount, restTestMethodCount >= 5 );
58:     }
59: 
60:     private int getTestMethodCount( JavaClass testClass ) {
61:         int testMethodCount = 0;
62:         for ( JavaMethod method : testClass.getMethods() ) {
63:             if ( isTestMethod( method ) ) {
64:                 testMethodCount++;
65:             }
66:         }
67:         return testMethodCount;
68:     }
69: 
70:     private boolean isTestMethod( JavaMethod method ) {
71:         return method.isAnnotatedWith( Test.class );
72:     }
73: 
74: 
75:     @Test
76:     public void dpTestsShouldReferenceTheRightClasses() {
77:         ArchRule rule = classes()
78:                 .should().dependOnClassesThat()
79:                 .areAssignableTo( ZipCodeType.class )
80:                 .andShould().dependOnClassesThat()
81:                 .areAssignableTo( MoneyType.class )
82:                 .andShould().dependOnClassesThat()
83:                 .areAssignableTo( PhysicalAddressType.class )
84:                 .andShould().dependOnClassesThat()
85:                 .areAssignableTo( MailAddressType.class )
86:                 .because( "DomainPrimitiveJSONSerializationTest should reference ZipCode, " +
87:                         "Money, MailAddress, and PhysicalAddress!" );
88:         rule.check( dpTestClasses );
89:     }
90: 
91: 
92:     @Test
93:     public void restTestsShouldReferenceMailAddress() {
94:         ArchRule rule = classes()
95:                 .should().dependOnClassesThat()
96:                 .areAssignableTo( MailAddressType.class )
97:                 .because( "FulfillmentCenterComparatorUnitTest should reference MailAddressType!" );
98:         rule.check( restTestClasses );
99:     }
100: 
101: 
102:     @Test
103:     public void restTestsShouldReferenceRESTControllers() {
104:         ArchRule rule = classes()
105:                 .should().dependOnClassesThat()
106:                 .areAnnotatedWith( RestController.class )
107:                 .orShould().dependOnClassesThat()
108:                 .areAssignableTo( ShoppingCartRESTHelper.class )
109:                 .because( "FulfillmentCenterComparatorUnitTest should call REST controllers! " +
110:                         "(either directly or via the ShoppingCartRESTHelper REST helper)" );
111:         rule.check( restTestClasses );
112:     }
113: 
114: }
115: 

[RESPONSE]:
## Code-Review

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\MailAddress.java
- **MailAddress.java Zeile(n) 21-29**: Duplication (Original: Zeile(n) 26-29) : Die Validierungslogik für `identifier` und `domain` ist strukturell identisch (Null-/Leerstring-Prüfung, Leerzeichen, doppelte Punkte). Könnte in eine gemeinsame Methode extrahiert werden.
- **MailAddress.java Zeile(n) 21-22**: Negative conditionals : `!identifier.matches("^[a-zA-Z0-9._-]+$")` ist eine negativ formulierte Bedingung. Besser wäre `identifier.matches("[^a-zA-Z0-9._-]")` oder eine separate Hilfsmethode `isValidIdentifier`.
- **MailAddress.java Zeile(n) 27**: Negative conditionals : `!domain.matches(".*\\.(de|at|ch|com|org)")` ist eine negativ formulierte Bedingung.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java
- **Money.java Zeile(n) 19-25**: Duplication (Original: Zeile(n) 23-25) : Die Validierung von `amount` und `currency` folgt demselben Muster (Null, Bereich, Werte). Könnte konsolidiert werden.
- **Money.java Zeile(n) 48, 60, 84**: Duplication (Original: Zeile(n) 48) : Die Prüfung `if(otherMoney == null)` und die zugehörige Exception-Nachricht "Cannot add null to MoneyType" wiederholt sich in `add`, `subtract` und `largerThan`. Die Nachricht ist in `subtract` (Zeile 60) sogar falsch ("Cannot add null to MoneyType").
- **Money.java Zeile(n) 51, 63, 88**: Duplication (Original: Zeile(n) 51) : Die Währungsprüfung `if(!otherMoney.getCurrencyUnit().equals(currency))` wiederholt sich in `add`, `subtract` und `largerThan`.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java
- **ZipCode.java Zeile(n) 22**: Negative conditionals : `zipCode.matches(".*0000")` ist eine negativ formulierte Bedingung, um "0000" am Ende zu finden. Besser wäre eine positive Prüfung oder `zipCode.endsWith("0000")`.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerRegistrationService.java
- **CustomerRegistrationService.java Zeile(n) 20-22, 23-25, 27-29**: Duplication (Original: Zeile(n) 20-22) : Das Muster `if (param == null) { throw new XyzException("..."); }` wiederholt sich für `name`, `mailAddress` und `physicalAddress` in der `register`-Methode.
- **CustomerRegistrationService.java Zeile(n) 39-41, 43-45**: Duplication (Original: Zeile(n) 39-41) : Das gleiche Null-Prüfungsmuster wiederholt sich in `changeAddress`.
- **CustomerRegistrationService.java Zeile(n) 60-62**: Duplication (Original: Zeile(n) 20-22) : Das gleiche Null-Prüfungsmuster in `getCustomerData(MailAddress)`.
- **CustomerRegistrationService.java Zeile(n) 31-33, 47-48**: Duplication (Original: Zeile(n) 31-33) : Das Abrufen eines Customers per `mailAddress` mit `orElseThrow` wiederholt sich in `register` und `changeAddress`.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\Customer.java
- **Customer.java**: Anemic Entity - Die Klasse besteht hauptsächlich aus Gettern/Setters und hat keine Domänenlogik.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\CustomerRepository.java
- **CustomerRepository.java Zeile(n) 13-15, 18-22**: Dead code - Die Methoden `findByName`, `findByPhysicalAddress`, `existsByName`, `existsByPhysicalAddress` werden in den bereitgestellten Code-Ausschnitten nicht verwendet.
- **CustomerRepository.java Zeile(n) 11, 20**: Shared persistency - Das Repository definiert Methoden, die `MailAddressType` und `PhysicalAddressType` aus dem Use-Case-Layer verwenden. Dies ist eine Schichtverletzung, da das Repository in der Domänenschicht liegen sollte und Domänentypen verwenden sollte, nicht Schnittstellen aus dem Use-Case-Layer.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterService.java
- **FulfillmentCenterService.java Zeile(n) 29-32**: Duplication (Original: Zeile(n) 29-30) : Null-/Leerstring-Prüfungen für `name` und `physicalAddress`.
- **FulfillmentCenterService.java Zeile(n) 43-44, 46-47, 48-49**: Duplication (Original: Zeile(n) 43-44) : Das Abrufen des `FulfillmentCenter` per ID mit `orElseThrow` und die Prüfung `if(addedQuantiOf < 0)` wiederholen sich in `addToInventory`, `removeFromInventory`, `changeInventoryTo` und `getAvailableInventory`.
- **FulfillmentCenterService.java Zeile(n) 48-49, 61-62, 74-75, 85-86**: Duplication (Original: Zeile(n) 48-49) : Die Prüfung `if(!this.merchandiseRepository.existsById(merchandiseId))` wiederholt sich in allen Methoden, die `merchandiseId` verwenden.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenter.java
- **FulfillmentCenter.java**: Anemic Entity - Die Klasse enthält einige Domänenlogik (z.B. `fulfillableShoppingCartParts`, `addToInventory`), ist daher nicht vollständig anämisch.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterRepository.java
- **FulfillmentCenterRepository.java Zeile(n) 9-11, 14-16**: Dead code - Die Methoden `findByName`, `findByPhysicalAddress`, `existsByName`, `existsByPhysicalAddress` werden nicht verwendet.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\application\MerchandiseCatalogService.java
- **MerchandiseCatalogService.java Zeile(n) 33-40**: Duplication (Original: Zeile(n) 33-34) : Mehrere Null-/Leerstring-Prüfungen für Parameter.
- **MerchandiseCatalogService.java Zeile(n) 50-51, 53-54**: Duplication (Original: Zeile(n) 50-51) : Die Prüfungen `if(storableServiceInterface.isMerchandiseInStock(...))` und `if(purchasableServiceInterface.isMerchandiseInPurchase(...))` haben ähnliche Strukturen und Fehlermeldungen.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\Merchandise.java
- **Merchandise.java**: Anemic Entity - Die Klasse hat nur Felder mit Gettern/Setters und keine Domänenlogik.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\MerchandiseRepository.java
- **MerchandiseRepository.java Zeile(n) 8-16, 19-27**: Dead code - Viele `findBy*` und `existsBy*` Methoden werden nicht verwendet.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\Purchase.java
- **Purchase.java**: Anemic Entity - Die Klasse enthält Domänenlogik (z.B. `addPurchasePart`, `getQuantity`), ist daher nicht vollständig anämisch.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseRepository.java
- **PurchaseRepository.java Zeile(n) 9-11, 15-17**: Dead code - Die Methoden `findByFulfillmentCenterId`, `existsByCustomerId`, `existsByFulfillmentCenterId` werden nicht verwendet.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartService.java
- **ShoppingCartService.java Zeile(n) 79-89, 91-101, 113-124, 126-140**: Duplication (Original: Zeile(n) 79-89) : Mehrere überladene Methoden `addMerchandiseToShoppingCart` und `removeMerchandiseFromShoppingCart` haben sehr ähnliche Logik (Kundenabruf, Validierung). Die zentrale Logik könnte in private Methoden extrahiert werden.
- **ShoppingCartService.java Zeile(n) 142-147, 149-154, 156-163, 165-168**: Duplication (Original: Zeile(n) 142-147) : Mehrere `getShoppingCart`-Überladungen, die im Wesentlichen denselben Code wiederholen (Kundenabruf, ShoppingCart-Abruf/Erstellung).
- **ShoppingCartService.java Zeile(n) 212-220, 222-228, 230-236, 238-248, 250-256**: Duplication (Original: Zeile(n) 212-220) : Mehrere `checkout`-Überladungen, die lediglich den Kunden oder Warenkorb auf unterschiedliche Weise abrufen und dann eine private `checkout`-Methode aufrufen.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCart.java
- **ShoppingCart.java**: Anemic Entity - Die Klasse enthält Domänenlogik (z.B. `addToShoppingCart`, `removeFromShoppingCart`), ist daher nicht vollständig anämisch.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartRepository.java
- **ShoppingCartRepository.java Zeile(n) 13**: Dead code - Die Methode `existsByCustomerId` wird nicht verwendet.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\InventoryTestHelperImpl.java
- **InventoryTestHelperImpl.java Zeile(n) 339-346**: Dead code - Die Methode `findMerchandiseIndex` wird in der bereitgestellten Code-Basis nicht verwendet (obwohl sie im Interface deklariert ist).

### Allgemeine Bemerkungen:
- **Layer violation / Shared persistency**: Die Repositories in der Domänenschicht verwenden Use-Case-Typen (`MailAddressType`, `PhysicalAddressType`) in ihren Methodensignaturen. Dies ist eine Schichtverletzung, da die Domänenschicht unabhängig von Use-Case-Schnittstellen sein sollte. Die Repositories sollten konkrete Domänentypen verwenden.
- **Missplaced responsibility**: Die Interfaces `StorableServiceInterface` und `PurchasableServiceInterface` sind im Package `merchandise.application` definiert, werden aber von anderen Domänen (`fulfillmentcenter`, `purchase`) implementiert und verwendet. Dies könnte als verteilte Verantwortlichkeit angesehen werden. Besser wäre eine Platzierung in einem gemeinsamen Package oder eine klarere Abgrenzung der Abhängigkeiten.

ENDE
Generated by deepseek-reasoner
-----------------------------------