--- DATE: 13.1.2026, 14:25:53 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
        Architektur: 4-Layer (Eric Evans).
        Aufgabe: Finde folgende Smells: Duplication: duplizierte Codest√ºcke die mehrmals vorkommen und eingespart werden k√∂nnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei l√§ngeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verst√§ndlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder geh√∂rt er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur √ºber Getter oder Setter verf√ºgen aber sonst keine Funktionen. Ausgenommen sind Repositories. F√ºr diesen Smell brauchst du keinen Zeilenangabe, da er f√ºr die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
        Regeln:
        1. Begr√ºnde kurz jeden Fund.
        4. Gruppiere nach Datei (mit Pfad). 
        2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begr√ºndung].
        3. Keine Code-Wiederholung, nur Referenzen.
        5. Wenn fertig, schreibe "ENDE". 
        6. Nutze die Zeilenangaben die mitgeschickt worden sind.



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ConflictException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: 
6: //409
7: @ResponseStatus(HttpStatus.CONFLICT)
8: public class ConflictException extends RuntimeException {
9:     public ConflictException(String message) {
10:         super(message);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Currency.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.Getter;
5: import lombok.Setter;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
8: 
9: import java.util.Locale;
10: import java.util.Objects;
11: 
12: @Getter
13: @Setter
14: @Embeddable
15: public class Currency implements CurrencyType {
16: 
17:     private final Float quantity;
18:     private final String currencyUnit;
19: 
20:     public Currency() {
21:         this.quantity = null;
22:         this.currencyUnit = null;
23:     }
24: 
25:     public Currency(Float quantity, String currencyUnit) {
26:         this.quantity = quantity;
27:         this.currencyUnit = currencyUnit;
28:     }
29: 
30:     public static Currency of(Float quantity, String currencyUnit) {
31:         if (quantity == null || quantity < 0) {
32:             throw new ShopException("Currency quantity must be >= 0");
33:         }
34:         if (currencyUnit == null || (!currencyUnit.equals("EUR") && !currencyUnit.equals("CHF"))) {
35:             throw new ShopException("Invalid currency unit. Only 'EUR' and 'CHF' allowed.");
36:         }
37:         return new Currency(quantity, currencyUnit);
38:     }
39: 
40:     private void validateSameCurrencyUnit(CurrencyType otherCurrency) {
41:         if (otherCurrency == null) {
42:             throw new ShopException("Other currency is null");
43:         }
44:         if (!this.currencyUnit.equals(otherCurrency.getCurrencyUnit())) {
45:             throw new ShopException("Currency units do not match");
46:         }
47:     }
48: 
49:     @Override
50:     public Float getQuantity() {
51:         return quantity;
52:     }
53: 
54:     @Override
55:     public String getCurrencyUnit() {
56:         return currencyUnit;
57:     }
58: 
59:     @Override
60:     public CurrencyType add(CurrencyType otherCurrency) {
61:         validateSameCurrencyUnit(otherCurrency);
62:         return Currency.of(this.quantity + otherCurrency.getQuantity(), this.currencyUnit);
63:     }
64: 
65:     @Override
66:     public CurrencyType subtract(CurrencyType otherCurrency) {
67:         validateSameCurrencyUnit(otherCurrency);
68:         if (this.quantity < otherCurrency.getQuantity()) {
69:             throw new ShopException("Cannot subtract: result would be negative.");
70:         }
71:         return Currency.of(this.quantity - otherCurrency.getQuantity(), this.currencyUnit);
72:     }
73: 
74:     @Override
75:     public CurrencyType multiplyBy(int factor) {
76:         if (factor < 0) {
77:             throw new ShopException("Factor must be >= 0");
78:         }
79:         return Currency.of(this.quantity * factor, this.currencyUnit);
80:     }
81: 
82:     @Override
83:     public boolean largerThan(CurrencyType otherCurrency) {
84:         validateSameCurrencyUnit(otherCurrency);
85:         return this.quantity > otherCurrency.getQuantity();
86:     }
87: 
88:     @Override
89:     public boolean equals(Object o) {
90:         if (this == o) return true;
91:         if (!(o instanceof Currency)) return false;
92:         Currency currency = (Currency) o;
93:         return quantity.equals(currency.quantity) &&
94:                 currencyUnit.equals(currency.currencyUnit);
95:     }
96: 
97:     @Override
98:     public int hashCode() {
99:         return Objects.hash(quantity, currencyUnit);
100:     }
101: 
102:     @Override
103:     public String toString() {
104:         return String.format(Locale.US, "%.2f ‚Ç¨", quantity);
105:     }}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\GlobalExceptionHandler.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.MissingServletRequestParameterException;
5: import org.springframework.web.bind.annotation.ControllerAdvice;
6: import org.springframework.web.bind.annotation.ExceptionHandler;
7: import org.springframework.web.bind.annotation.ResponseStatus;
8: 
9: @ControllerAdvice
10: public class GlobalExceptionHandler {
11:     @ExceptionHandler(MissingServletRequestParameterException.class)
12:     @ResponseStatus(HttpStatus.METHOD_NOT_ALLOWED)
13:     public void handleMissingQueryParam(MissingServletRequestParameterException ex) {
14:     }
15: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\MailAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import jakarta.persistence.Embeddable;
5: import lombok.Getter;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
9: 
10: import java.util.Objects;
11: import java.util.regex.Pattern;
12: 
13: @Getter
14: @Setter
15: @Embeddable
16: public class MailAddress implements MailAddressType {
17:     private static final Pattern VALID_MAIL_PATTERN = Pattern.compile(
18:             "^(?=[^@\\s]{1,64}@[^@\\s]{1,255}$)" +             // One '@', no spaces
19:                     "[A-Za-z0-9]+(?:\\.[A-Za-z0-9]+)*@" +               // Local part
20:                     "[A-Za-z0-9]+(?:\\.[A-Za-z0-9]+)*\\.(de|at|ch|com|org)$" // Domain
21:     );
22: 
23:     @JsonProperty("mailAddressString")
24:     private String address;
25: 
26:     public MailAddress() {}
27: 
28:     public MailAddress(String address) {
29:         this.address = address;
30:     }
31: 
32:     public static MailAddressType of(String mailAddressAsString) {
33:         if (mailAddressAsString == null || !VALID_MAIL_PATTERN.matcher(mailAddressAsString).matches()) {
34:             throw new ShopException("Invalid mail address: " + mailAddressAsString);
35:         }
36:         return new MailAddress(mailAddressAsString);
37:     }
38: 
39:     @Override
40:     public MailAddressType sameIdentifyerDifferentDomain(String newDomain) {
41:         if (newDomain == null || newDomain.trim().isEmpty()) {
42:             throw new ShopException("Domain must not be null or empty");
43:         }
44:         String[] parts = address.split("@");
45:         return MailAddress.of(parts[0] + "@" + newDomain);
46:     }
47: 
48:     @Override
49:     public MailAddressType sameDomainDifferentIdentifyer(String newIdentifyer) {
50:         if (newIdentifyer == null || newIdentifyer.trim().isEmpty()) {
51:             throw new ShopException("Identifier must not be null or empty");
52:         }
53:         String[] parts = address.split("@");
54:         return MailAddress.of(newIdentifyer + "@" + parts[1]);
55:     }
56: 
57:     @Override
58:     public String toString() {
59:         return address;
60:     }
61: 
62:     @Override
63:     public boolean equals(Object o) {
64:         if (this == o) return true;
65:         if (!(o instanceof MailAddress)) return false;
66:         MailAddress that = (MailAddress) o;
67:         return address.equals(that.address);
68:     }
69: 
70:     @Override
71:     public int hashCode() {
72:         return Objects.hash(address);
73:     }
74: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\NotFoundException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: 
6: //404
7: @ResponseStatus(code = HttpStatus.NOT_FOUND)
8: public class NotFoundException extends RuntimeException {
9:     public NotFoundException(String message) {
10:         super(message);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PhysicalAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.*;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
8: 
9: import java.util.Objects;
10: 
11: @AllArgsConstructor
12: @NoArgsConstructor
13: @Getter
14: @Setter(AccessLevel.PROTECTED)
15: @Embeddable
16: public class PhysicalAddress implements PhysicalAddressType {
17: 
18:     private String street;
19: 
20:     private String city;
21: 
22:     private PostalCode postalCode;
23: 
24:     public static PhysicalAddress of(String street, String city, PostalCodeType postalCode) {
25:         if (street == null || street.trim().isEmpty()) {
26:             throw new ShopException("Street must not be null or empty");
27:         }
28:         if (city == null || city.trim().isEmpty()) {
29:             throw new ShopException("City must not be null or empty");
30:         }
31:         if (postalCode == null) {
32:             throw new ShopException("Postal code must not be null");
33:         }
34:         return new PhysicalAddress(street, city, (PostalCode) postalCode);
35:     }
36: 
37:     @Override
38:     public String getStreet() {
39:         return street;
40:     }
41: 
42:     @Override
43:     public String getCity() {
44:         return city;
45:     }
46: 
47:     @Override
48:     public PostalCodeType getPostalCode() {
49:         return postalCode;
50:     }
51: 
52:     @Override
53:     public boolean equals(Object o) {
54:         if (this == o) return true;
55:         if (!(o instanceof PhysicalAddress)) return false;
56:         PhysicalAddress that = (PhysicalAddress) o;
57:         return street.equals(that.street) &&
58:                 city.equals(that.city) &&
59:                 postalCode.equals(that.postalCode);
60:     }
61: 
62:     @Override
63:     public int hashCode() {
64:         return Objects.hash(street, city, postalCode);
65:     }
66: 
67:     @Override
68:     public String toString() {
69:         return street + ", " + city + " " + postalCode.toString();
70:     }
71: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PostalCode.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.*;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
7: 
8: import java.util.Objects;
9: 
10: @AllArgsConstructor
11: @NoArgsConstructor
12: @Getter
13: @Setter
14: @Embeddable
15: public class PostalCode implements PostalCodeType {
16: 
17:     private String postalCode;
18: 
19:     public static PostalCode of(String postalCodeAsString) {
20:         if (postalCodeAsString == null || !postalCodeAsString.matches("\\d{5}")) {
21:             throw new ShopException("Postal code must be exactly 5 digits.");
22:         }
23:         if (postalCodeAsString.endsWith("0000")) {
24:             throw new ShopException("Invalid postal code: cannot end in 0000.");
25:         }
26:         return new PostalCode(postalCodeAsString);
27:     }
28: 
29:     @Override
30:     public int distance(PostalCodeType otherPostalCode) {
31:         if (otherPostalCode == null) {
32:             throw new ShopException("Other postal code must not be null");
33:         }
34: 
35:         String other = otherPostalCode.toString();
36:         if (this.postalCode.equals(other)) {
37:             return 0;
38:         }
39: 
40:         int maxDifferenceLevel = 0;
41: 
42:         for (int i = 4; i >= 1; i--) {
43:             if (postalCode.charAt(i) != other.charAt(i)) {
44:                 maxDifferenceLevel = Math.max(maxDifferenceLevel, 5 - i);
45:             }
46:         }
47: 
48:         // Region wird IMMER ber√ºcksichtigt (wrap-around!)
49:         int regionA = Character.getNumericValue(postalCode.charAt(0));
50:         int regionB = Character.getNumericValue(other.charAt(0));
51:         int regionDiff = Math.min(Math.abs(regionA - regionB), 10 - Math.abs(regionA - regionB));
52: 
53:         return maxDifferenceLevel + regionDiff;
54:     }
55: 
56:     @Override
57:     public Integer getFirstDigitPostalCode() {
58:         return Integer.parseInt(postalCode.substring(0, 1));
59:     }
60: 
61:     @Override
62:     public String toString() {
63:         return postalCode;
64:     }
65: 
66:     @Override
67:     public boolean equals(Object o) {
68:         if (this == o) return true;
69:         if (!(o instanceof PostalCode)) return false;
70:         PostalCode that = (PostalCode) o;
71:         return postalCode.equals(that.postalCode);
72:     }
73: 
74:     @Override
75:     public int hashCode() {
76:         return Objects.hash(postalCode);
77:     }
78: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\UnprocessableEntityException.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import org.springframework.http.HttpStatus;
4: import org.springframework.web.bind.annotation.ResponseStatus;
5: 
6: //422
7: @ResponseStatus(HttpStatus.UNPROCESSABLE_ENTITY)
8: public class UnprocessableEntityException extends RuntimeException {
9:     public UnprocessableEntityException(String message) {
10:         super(message);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
1: /*
2:  * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.Column;
7: import jakarta.persistence.MappedSuperclass;
8: import lombok.EqualsAndHashCode;
9: import lombok.Getter;
10: import lombok.ToString;
11: 
12: import java.io.Serializable;
13: import java.util.UUID;
14: 
15: @MappedSuperclass
16: @Getter
17: @EqualsAndHashCode(of = "id")
18: @ToString(of = "id")
19: public abstract class GenericId implements Serializable {
20:     @Column(nullable = false, updatable = false)
21:     private final UUID id;
22: 
23:     protected GenericId() {
24:         this( UUID.randomUUID() );
25:     }
26: 
27:     protected GenericId( UUID id ) {
28:         this.id = id;
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
1: /*
2:  * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import jakarta.persistence.AttributeConverter;
7: 
8: import java.util.UUID;
9: import java.util.function.Function;
10: 
11: 
12: public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
13:     private final Function<UUID, T> factory;
14: 
15:     protected GenericIdConverter( Function<UUID, T> factory ) {
16:         this.factory = factory;
17:     }
18: 
19:     @Override
20:     public UUID convertToDatabaseColumn( T attribute ) {
21:         return attribute == null ? null : attribute.getId();
22:     }
23: 
24:     @Override
25:     public T convertToEntityAttribute( UUID dbData ) {
26:         return dbData == null ? null : factory.apply( dbData );
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\InsufficientInventoryException.java ---
1: /*
2:  * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: /**
7:  * Exception is thrown if the product's inventory level is not sufficient to serve the purchase.
8:  */
9: public class InsufficientInventoryException extends ShopException {
10:     public InsufficientInventoryException( String message ) {
11:         super( message );
12:     }
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
1: /*
2:  * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: import org.springframework.boot.SpringApplication;
7: import org.springframework.boot.autoconfigure.SpringBootApplication;
8: 
9: 
10: @SpringBootApplication
11: public class ProjectApplication {
12: 
13: 	/**
14: 	 * Entry method
15: 	 * @param args
16: 	 */
17: 	public static void main(String[] args) {
18: 		SpringApplication.run(ProjectApplication.class, args);
19: 	}
20: }
21: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
1: /*
2:  * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
3:  */
4: package thkoeln.archilab.ecommerce;
5: 
6: public class ShopException extends RuntimeException {
7:     public ShopException( String message ) {
8:         super( message );
9:     }
10: }
11: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\adapter\inventory\InventoryCheckerAdapter.java ---
1: package thkoeln.archilab.ecommerce.solution.adapter.inventory;
2: 
3: import org.springframework.stereotype.Component;
4: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterRepository;
5: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.InventoryLevel;
6: import thkoeln.archilab.ecommerce.solution.product.domain.InventoryChecker;
7: 
8: import java.util.UUID;
9: 
10: @Component
11: public class InventoryCheckerAdapter implements InventoryChecker {
12: 
13:     private final FulfillmentCenterRepository fulfillmentCenterRepository;
14: 
15:     public InventoryCheckerAdapter(FulfillmentCenterRepository fulfillmentCenterRepository) {
16:         this.fulfillmentCenterRepository = fulfillmentCenterRepository;
17:     }
18: 
19:     @Override
20:     public boolean isProductInAnyInventory(UUID productId) {
21:         return fulfillmentCenterRepository.findAll().stream()
22:                 .flatMap(center -> center.getInventoryLevels().stream())
23:                 .map(InventoryLevel::getProductId)
24:                 .anyMatch(pid -> pid.equals(productId));
25:     }
26: 
27:     @Override
28:     public void deleteAllCenters() {
29:         fulfillmentCenterRepository.deleteAll();
30:     }
31: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\adapter\MailAddressJpaAdapter.java ---
1: package thkoeln.archilab.ecommerce.solution.adapter;
2: 
3: import jakarta.persistence.Embeddable;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: 
7: @Getter
8: @Embeddable
9: @NoArgsConstructor
10: public class MailAddressJpaAdapter {
11:     private String address;
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\adapter\purchase\ProductPurchaseUsageAdapter.java ---
1: package thkoeln.archilab.ecommerce.solution.adapter.purchase;
2: 
3: import org.springframework.stereotype.Component;
4: import thkoeln.archilab.ecommerce.solution.product.domain.PurchaseUsage;
5: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;
6: 
7: import java.util.UUID;
8: 
9: @Component
10: public class ProductPurchaseUsageAdapter implements PurchaseUsage {
11: 
12:     private final PurchaseRepository purchaseRepository;
13: 
14:     public ProductPurchaseUsageAdapter(PurchaseRepository purchaseRepository) {
15:         this.purchaseRepository = purchaseRepository;
16:     }
17: 
18:     @Override
19:     public boolean isProductInAnyPurchase(UUID productId) {
20:         return purchaseRepository.findAll().stream()
21:                 .flatMap(p -> p.getPurchasePositions().stream())
22:                 .anyMatch(pos -> productId.equals(pos.getProductId()));
23:     }
24: 
25:     @Override
26:     public void deleteAllPurchases() {
27:         purchaseRepository.deleteAll();
28:     }
29: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\adapter\shopping\ProductBasketUsageAdapter.java ---
1: package thkoeln.archilab.ecommerce.solution.adapter.shopping;
2: 
3: import org.springframework.stereotype.Component;
4: import thkoeln.archilab.ecommerce.solution.product.domain.ProductBasketUsageChecker;
5: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
6: import java.util.UUID;
7: 
8: @Component
9: public class ProductBasketUsageAdapter implements ProductBasketUsageChecker {
10: 
11:     private final ShoppingBasketRepository shoppingBasketRepository;
12: 
13:     public ProductBasketUsageAdapter(ShoppingBasketRepository shoppingBasketRepository) {
14:         this.shoppingBasketRepository = shoppingBasketRepository;
15:     }
16: 
17:     @Override
18:     public boolean isProductInAnyBasket(UUID productId) {
19:         return shoppingBasketRepository.findAll().stream()
20:                 .flatMap(basket -> basket.getShoppingBasketPositions().stream())
21:                 .anyMatch(position -> position.getProductId().equals(productId));
22:     }
23: 
24:     @Override
25:     public void deleteAllBaskets() {
26:         shoppingBasketRepository.deleteAll();
27:     }
28: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterFinderAdapter.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;
2: 
3: import org.springframework.stereotype.Component;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.*;
6: 
7: import java.util.UUID;
8: 
9: @Component
10: public class FulfillmentCenterFinderAdapter implements FulfillmentCenterFinder {
11: 
12:     private final FulfillmentCenterRepository repository;
13: 
14:     public FulfillmentCenterFinderAdapter(FulfillmentCenterRepository repository) {
15:         this.repository = repository;
16:     }
17: 
18:     @Override
19:     public UUID findMatchingCenterId(String postalCode) {
20:         if (postalCode == null || postalCode.isBlank() || !postalCode.matches("\\d{5}")) {
21:             throw new ShopException("Invalid postal code.");
22:         }
23: 
24:         int digit = Character.getNumericValue(postalCode.charAt(0));
25:         return repository.findAll().stream()
26:                 .filter(fc -> digit >= fc.getFromPostalCodeFirstDigit()
27:                         && digit <= fc.getToPostalCodeFirstDigit())
28:                 .map(FulfillmentCenter::getFulFillmentCenterId)
29:                 .findFirst()
30:                 .orElseThrow(() -> new ShopException("No matching fulfillment center found."));
31:     }
32: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterService.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;
2: 
3: import jakarta.transaction.Transactional;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.stereotype.Service;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
8: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.*;
9: import thkoeln.archilab.ecommerce.solution.product.domain.ProductLookup;
10: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
12: 
13: import java.util.UUID;
14: 
15: // üè¨ FulfillmentCenterService ‚Äì Versandzentren & Lagerlogik
16: 
17: @Service
18: public class FulfillmentCenterService implements FulfillmentCenterUseCases {
19: 
20:     private final FulfillmentCenterRepository fulfillmentCenterRepository;
21:     private final ProductLookup productExistenceChecker;
22: 
23:     @Autowired
24:     public FulfillmentCenterService(FulfillmentCenterRepository fulfillmentCenterRepository,
25:                                     ProductLookup productExistenceChecker) {
26:         this.fulfillmentCenterRepository = fulfillmentCenterRepository;
27:         this.productExistenceChecker = productExistenceChecker;
28:     }
29: 
30:     @Override
31:     @Transactional
32:     public UUID addNewFulfillmentCenter(String name, PhysicalAddressType physicalAddress) {
33:         if (name == null || name.isBlank()) {
34:             throw new ShopException("Name must not be null or blank.");
35:         }
36: 
37:         if (physicalAddress == null) {
38:             throw new ShopException("Physical address must not be null.");
39:         }
40: 
41:         PhysicalAddress address = (PhysicalAddress) physicalAddress;
42:         FulfillmentCenter center = new FulfillmentCenter(name, address);
43:         fulfillmentCenterRepository.save(center);
44:         return center.getFulFillmentCenterId();
45:     }
46: 
47:     @Transactional
48:     @Override
49:     public void deleteAllFulfillmentCenters() {
50:         fulfillmentCenterRepository.deleteAll();
51:     }
52: 
53:     @Transactional
54:     @Override
55:     public void addToInventory(UUID fulfillmentCenterId, UUID productId, int addedQuantityFor) {
56:         FulfillmentCenter center = findCenter(fulfillmentCenterId);
57:         ensureProductExists(productId);
58:         center.addToInventory(productId, addedQuantityFor);
59:         fulfillmentCenterRepository.save(center);
60:     }
61: 
62:     @Transactional
63:     @Override
64:     public void removeFromInventory(UUID fulfillmentCenterId, UUID productId, int removedQuantityFor) {
65:         FulfillmentCenter center = findCenter(fulfillmentCenterId);
66:         ensureProductExists(productId);
67:         center.removeFromInventory(productId, removedQuantityFor);
68:         fulfillmentCenterRepository.save(center);
69:     }
70: 
71:     @Transactional
72:     @Override
73:     public void changeInventoryTo(UUID fulfillmentCenterId, UUID productId, int newTotalQuantityFor) {
74:         FulfillmentCenter center = findCenter(fulfillmentCenterId);
75:         ensureProductExists(productId);
76:         center.setInventory(productId, newTotalQuantityFor);
77:         fulfillmentCenterRepository.save(center);
78:     }
79: 
80:     @Transactional
81:     @Override
82:     public int getAvailableInventory(UUID fulfillmentCenterId, UUID productId) {
83:         FulfillmentCenter center = findCenter(fulfillmentCenterId);
84:         ensureProductExists(productId);
85:         return center.getInventoryQuantity(productId);
86:     }
87: 
88:     //Hilfsmethoden
89:     private FulfillmentCenter findCenter(UUID id) {
90:         return fulfillmentCenterRepository.findById(new FulfillmentCenterId(id))
91:                 .orElseThrow(() -> new ShopException("Fulfillment center not found."));
92:     }
93: 
94:     private void ensureProductExists(UUID productId) {
95:         if (!productExistenceChecker.isExistingProduct(productId)) {
96:             throw new ShopException("Product does not exist.");
97:         }
98:     }
99: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentInventoryAdapter.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;
2: 
3: import org.springframework.stereotype.Component;
4: import org.springframework.transaction.annotation.Transactional;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.*;
7: 
8: import java.util.UUID;
9: 
10: @Component
11: public class FulfillmentInventoryAdapter implements FulfillmentInventoryChecker {
12: 
13:     private final FulfillmentCenterRepository repository;
14:     private FulfillmentCenter currentCenter;
15: 
16:     public FulfillmentInventoryAdapter(FulfillmentCenterRepository repository) {
17:         this.repository = repository;
18:     }
19: 
20:     @Override
21:     public void setFulfillmentCenter(UUID centerIdRaw) {
22:         FulfillmentCenterId id = new FulfillmentCenterId(centerIdRaw);
23:         this.currentCenter = repository.findById(id)
24:                 .orElseThrow(() -> new ShopException("Center not found."));
25:     }
26: 
27:     @Override
28:     public boolean hasEnoughInventory(UUID productId, int quantity) {
29:         ensureCenterSelected();
30:         return currentCenter.hasEnoughInventory(productId, quantity);
31:     }
32: 
33:     @Override
34:     public void removeFromInventory(UUID productId, int quantity) {
35:         ensureCenterSelected();
36:         currentCenter.removeFromInventory(productId, quantity);
37:     }
38: 
39:     @Override
40:     @Transactional
41:     public void saveChanges() {
42:         ensureCenterSelected();
43:         repository.save(currentCenter);
44:     }
45: 
46:     private void ensureCenterSelected() {
47:         if (currentCenter == null) {
48:             throw new ShopException("Fulfillment center not set.");
49:         }
50:     }
51: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenter.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Getter;
5: import lombok.Setter;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
8: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
9: 
10: import java.util.*;
11: 
12: @Entity
13: @Getter
14: @Setter
15: public class FulfillmentCenter {
16:     @EmbeddedId
17:     private FulfillmentCenterId fulfillmentCenterId;
18: 
19:     private String name;
20: 
21:     @Embedded
22:     private PhysicalAddress physicalAddress;
23: 
24:     private int fromPostalCodeFirstDigit;
25:     private int toPostalCodeFirstDigit;
26: 
27:     @Getter
28:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
29:     @JoinColumn(name = "fulfillment_center_id")
30:     private List<InventoryLevel> inventoryLevels = new ArrayList<>();
31: 
32:     public FulfillmentCenter(String name, PhysicalAddress address, int from, int to) {
33:         this.fulfillmentCenterId = new FulfillmentCenterId();
34:         this.name = name;
35:         this.physicalAddress = address;
36:         this.fromPostalCodeFirstDigit = from;
37:         this.toPostalCodeFirstDigit = to;
38:     }
39: 
40:     public FulfillmentCenter() {}
41: 
42:     public FulfillmentCenter(String name, PhysicalAddress address) {
43:         this.fulfillmentCenterId = new FulfillmentCenterId(); // Wichtig!
44:         this.name = name;
45:         this.physicalAddress = address;
46:     }
47: 
48:     public Set<ProductId> fulfillableShoppingBasketPositions(Map<ProductId, Integer> productQuantityMap) {
49:         Set<ProductId> fulfillable = new HashSet<>();
50: 
51:         for (Map.Entry<ProductId, Integer> entry : productQuantityMap.entrySet()) {
52:             UUID productId = entry.getKey().getId();
53:             int requiredQty = entry.getValue();
54: 
55:             inventoryLevels.stream()
56:                     .filter(level -> level.getProductId() != null &&
57:                             level.getProductId().equals(productId) &&
58:                             level.getQuantity() >= requiredQty)
59:                     .findFirst()
60:                     .ifPresent(level -> fulfillable.add(entry.getKey()));  // <-- add original ProductId key!
61:         }
62:         return fulfillable;
63:     }
64: 
65:     public void addToInventory(UUID productId, int quantity) {
66:         if (productId == null || quantity < 0) {
67:             throw new ShopException("Invalid product ID or quantity for adding to inventory.");
68:         }
69:         InventoryLevel level = findOrCreateInventoryLevel(productId);
70:         level.setQuantity(level.getQuantity() + quantity);
71:     }
72: 
73:     public void removeFromInventory(UUID productId, int quantity) {
74:         if (productId == null || quantity < 0) {
75:             throw new ShopException("Invalid product ID or quantity for removing from inventory.");
76:         }
77: 
78:         Optional<InventoryLevel> maybeLevel = inventoryLevels.stream()
79:                 .filter(level -> level.getProductId() != null && level.getProductId().equals(productId))
80:                 .findFirst();
81: 
82:         if (maybeLevel.isEmpty()) {
83:             if (quantity == 0) return;
84:             throw new ShopException("Product " + productId + " not found in inventory of center " + this.name);
85:         }
86: 
87:         InventoryLevel level = maybeLevel.get();
88: 
89:         if (level.getQuantity() < quantity) {
90:             throw new ShopException("Not enough inventory to remove.");
91:         }
92: 
93:         level.setQuantity(level.getQuantity() - quantity);
94:     }
95: 
96:     public int getInventoryQuantity(UUID productId) {
97:         return inventoryLevels.stream()
98:                 .filter(level -> level.getProductId() != null && level.getProductId().equals(productId))
99:                 .findFirst()
100:                 .map(InventoryLevel::getAvailableQuantity)
101:                 .orElse(0);
102: 
103:     }
104: 
105:     public boolean hasEnoughInventory(UUID productId, int requiredQuantity) {
106:         return inventoryLevels.stream()
107:                 .filter(level -> level.getProductId() != null && level.getProductId().equals(productId))
108:                 .anyMatch(level -> level.getQuantity() >= requiredQuantity);
109:     }
110: 
111:     private InventoryLevel findOrCreateInventoryLevel(UUID productId) {
112:         return inventoryLevels.stream()
113:                 .filter(level -> level.getProductId() != null && level.getProductId().equals(productId))
114:                 .findFirst()
115:                 .orElseGet(() -> {
116:                     InventoryLevel newLevel = new InventoryLevel(productId, 0, this.getFulFillmentCenterId());
117:                     inventoryLevels.add(newLevel);
118:                     return newLevel;
119:                 });
120:     }
121: 
122:     public UUID getFulFillmentCenterId() {
123:         return fulfillmentCenterId.getId();
124:     }
125: 
126:     public void setInventory(UUID productId, int quantity) {
127:         if (productId == null || quantity < 0) {
128:             throw new ShopException("Invalid product ID or quantity for setting inventory.");
129:         }
130:         InventoryLevel level = findOrCreateInventoryLevel(productId);
131:         level.setQuantity(quantity);
132:     }
133: 
134:     public int getInventoryLevel(UUID productId) {
135:         return inventoryLevels.stream()
136:                 .filter(level -> level.getProductId().equals(productId))
137:                 .mapToInt(InventoryLevel::getQuantity)
138:                 .findFirst()
139:                 .orElse(0); // Falls kein Eintrag vorhanden ist
140:     }
141: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterComparator.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import java.util.Comparator;
4: import java.util.Map;
5: import java.util.Set;
6: 
7: import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;
8: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
9: 
10: public class FulfillmentCenterComparator implements Comparator<FulfillmentCenter> {
11: 
12:     private final Map<ProductId, Integer> shoppingBasket;
13:     private final PostalCode userPostalCode;
14: 
15:     public FulfillmentCenterComparator(Map<ProductId, Integer> shoppingBasket, PostalCode userPostalCode) {
16:         this.shoppingBasket = shoppingBasket;
17:         this.userPostalCode = userPostalCode;
18:     }
19: 
20:     @Override
21:     public int compare(FulfillmentCenter fc1, FulfillmentCenter fc2) {
22:         // 1. Anzahl der erf√ºllbaren Positionen (nicht Produkte!) vergleichen
23:         int fulfillableCountFc1 = getFulfillableQuantity(fc1);
24:         int fulfillableCountFc2 = getFulfillableQuantity(fc2);
25: 
26:         if (fulfillableCountFc1 != fulfillableCountFc2) {
27:             return Integer.compare(fulfillableCountFc2, fulfillableCountFc1); // Mehr ist besser
28:         }
29: 
30:         // 2. Entfernung vergleichen
31:         int distanceFc1 = userPostalCode.distance(fc1.getPhysicalAddress().getPostalCode());
32:         int distanceFc2 = userPostalCode.distance(fc2.getPhysicalAddress().getPostalCode());
33: 
34:         if (distanceFc1 != distanceFc2) {
35:             return Integer.compare(distanceFc1, distanceFc2); // Weniger ist besser
36:         }
37: 
38:         // 3. Deterministischer Vergleich (z.‚ÄØB. nach ID)
39:         return fc1.getFulFillmentCenterId().compareTo(fc2.getFulFillmentCenterId());
40:     }
41: 
42:     private int getFulfillableQuantity(FulfillmentCenter center) {
43:         Set<ProductId> fulfillable = center.fulfillableShoppingBasketPositions(shoppingBasket);
44:         return fulfillable.size();
45:     }
46: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterFinder.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import java.util.UUID;
4: 
5: public interface FulfillmentCenterFinder {
6:     UUID findMatchingCenterId(String postalCode);
7: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterId.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: 
13: @Embeddable
14: @NoArgsConstructor(access = AccessLevel.PROTECTED)
15: @AttributeOverride(name = "id", column = @Column(name = "fulfillmentCenter_id"))
16: public class FulfillmentCenterId extends GenericId {
17:     public FulfillmentCenterId (UUID id) {
18:         super(id);
19:     }
20: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
6: 
7: @Converter(autoApply = true)
8: public class FulfillmentCenterIdConverter extends GenericIdConverter<FulfillmentCenterId> {
9:     public FulfillmentCenterIdConverter() {
10:         super(FulfillmentCenterId::new);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.stereotype.Repository;
5: 
6: @Repository
7: public interface FulfillmentCenterRepository extends JpaRepository<FulfillmentCenter, FulfillmentCenterId> {
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentInventoryChecker.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import java.util.UUID;
4: 
5: public interface FulfillmentInventoryChecker {
6:     void setFulfillmentCenter(UUID fulfillmentCenterId);
7:     boolean hasEnoughInventory(UUID productId, int quantity);
8:     void removeFromInventory(UUID productId, int quantity);
9:     void saveChanges();
10: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\InventoryLevel.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.UUID;
9: 
10: @Entity
11: @Getter
12: @Setter
13: @NoArgsConstructor
14: public class InventoryLevel {
15: 
16:     @EmbeddedId
17:     private InventoryLevelId inventoryLevelId;
18: 
19:     private int quantity = 0;
20:     private int reservedQuantity = 0;
21: 
22:     private UUID productId;
23: 
24:     @Column(name = "fulfillment_center_id")
25:     private UUID fulfillmentCenterId;
26: 
27:     public InventoryLevel(UUID productIdRaw, int quantity, UUID fulfillmentCenterId) {
28:         this.productId = productIdRaw;
29:         this.quantity = quantity;
30:         this.fulfillmentCenterId = fulfillmentCenterId;
31:         this.inventoryLevelId = new InventoryLevelId();
32:     }
33: 
34:     public int getAvailableQuantity() {
35:         return quantity - reservedQuantity;
36:     }
37: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\InventoryLevelId.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "inventoryLevel_id"))
15: public class InventoryLevelId extends GenericId {
16:     public InventoryLevelId(UUID id) {
17:         super(id);
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\InventoryLevelIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class InventoryLevelIdConverter extends GenericIdConverter<InventoryLevelId> {
8:     public InventoryLevelIdConverter() {
9:         super(InventoryLevelId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductCatalogService.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: 
3: import org.springframework.stereotype.Service;
4: import org.springframework.transaction.annotation.Transactional;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
7: import thkoeln.archilab.ecommerce.solution.product.domain.*;
8: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
10: 
11: import java.util.UUID;
12: 
13: // üß∏ ProductCatalogService ‚Äì Produktverwaltung & Katalog
14: 
15: @Service
16: @Transactional
17: public class ProductCatalogService implements ProductCatalogUseCases {
18: 
19:     private final ProductRepository productRepository;
20:     private final ProductBasketUsageChecker basketUsageChecker;
21:     private final PurchaseUsage purchaseUsage;
22:     private final InventoryChecker inventoryChecker;
23: 
24:     public ProductCatalogService(ProductRepository productRepository,
25:                                  ProductBasketUsageChecker basketUsageChecker,
26:                                  PurchaseUsage purchaseUsage,
27:                                  InventoryChecker inventoryChecker) {
28:         this.productRepository = productRepository;
29:         this.basketUsageChecker = basketUsageChecker;
30:         this.purchaseUsage = purchaseUsage;
31:         this.inventoryChecker = inventoryChecker;
32:     }
33: 
34:     @Override
35:     public UUID addProductToCatalog(String name, String descriptOf, Float size,
36:                                     CurrencyType buyingPrice, CurrencyType salesPrice) {
37: 
38:         if (name == null || name.isBlank() || descriptOf == null || descriptOf.isBlank()) {
39:             throw new ShopException("Name and description must not be null or empty.");
40:         }
41: 
42:         if (size != null && size <= 0) {
43:             throw new ShopException("Size must be greater than 0 if specified.");
44:         }
45: 
46:         if (buyingPrice == null || salesPrice == null) {
47:             throw new ShopException("Prices must not be null.");
48:         }
49: 
50:         if (!salesPrice.largerThan(buyingPrice) &&
51:                 !salesPrice.getQuantity().equals(buyingPrice.getQuantity())) {
52:             throw new ShopException("Sales price must not be lower than buying price.");
53:         }
54: 
55:         Currency buying = (Currency) buyingPrice;
56:         Currency sales = (Currency) salesPrice;
57: 
58:         Product product = new Product(name, descriptOf, size, buying, sales);
59: 
60:         if (productRepository.existsById(product.getProductId())) {
61:             throw new ShopException("Product ID already exists.");
62:         }
63: 
64:         productRepository.save(product);
65:         return product.getProductId().getId();
66:     }
67: 
68:     @Override
69:     public void removeProductFromCatalog(UUID productId) {
70:         if (productId == null) throw new ShopException("Product ID must not be null.");
71: 
72:         ProductId newProductId = new ProductId(productId);
73:         Product product = productRepository.findById(newProductId)
74:                 .orElseThrow(() -> new ShopException("Product does not exist."));
75: 
76:         if (basketUsageChecker.isProductInAnyBasket(newProductId.getId()) ||
77:                 purchaseUsage.isProductInAnyPurchase(newProductId.getId()) ||
78:                 inventoryChecker.isProductInAnyInventory(newProductId.getId())) {
79:             throw new ShopException("Product is still referenced somewhere.");
80:         }
81: 
82:         productRepository.delete(product);
83:     }
84: 
85:     @Override
86:     public CurrencyType getSalesPrice(UUID productId) {
87:         if (productId == null) throw new ShopException("Product ID must not be null.");
88: 
89:         ProductId newProductId = new ProductId(productId);
90: 
91:         return productRepository.findById(newProductId)
92:                 .orElseThrow(() -> new ShopException("Product not found."))
93:                 .getSalesPrice(); // already Currency
94:     }
95: 
96:     @Override
97:     public void deleteProductCatalog() {
98:         basketUsageChecker.deleteAllBaskets();
99:         purchaseUsage.deleteAllPurchases();
100:         inventoryChecker.deleteAllCenters();
101:         productRepository.deleteAll();
102:     }
103: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductLookupAdapter.java ---
1: package thkoeln.archilab.ecommerce.solution.product.application;
2: 
3: import org.springframework.stereotype.Component;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.solution.product.domain.*;
6: 
7: import java.util.UUID;
8: 
9: @Component
10: public class ProductLookupAdapter implements ProductLookup {
11: 
12:     private final ProductRepository productRepository;
13: 
14:     public ProductLookupAdapter(ProductRepository productRepository) {
15:         this.productRepository = productRepository;
16:     }
17: 
18:     @Override
19:     public Product findProductById(UUID productId) {
20:         return productRepository.findById(new ProductId(productId))
21:                 .orElseThrow(() -> new ShopException("Product not found."));
22:     }
23: 
24:     @Override
25:     public boolean isExistingProduct(UUID productId) {
26:         return productRepository.existsById(new ProductId(productId));
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\InventoryChecker.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import java.util.UUID;
4: 
5: public interface InventoryChecker {
6:     boolean isProductInAnyInventory(UUID productId);
7: 
8:     void deleteAllCenters();
9: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\Product.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Getter;
5: import lombok.Setter;
6: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
8: 
9: @Entity
10: @Getter
11: @Setter
12: @Table(name = "Product")
13: public class Product {
14:     @EmbeddedId
15:     private ProductId productId;
16: 
17:     private String name;
18:     private String description;
19:     private Float size;
20: 
21:     @Embedded
22:     @AttributeOverrides({
23:             @AttributeOverride(name = "quantity", column = @Column(name = "buying_price_quantity")),
24:             @AttributeOverride(name = "currencyUnit", column = @Column(name = "buying_price_currency"))
25:     })
26:     private Currency buyingPrice;  // Direkt als Currency, ohne Adapter
27: 
28:     @Embedded
29:     @AttributeOverrides({
30:             @AttributeOverride(name = "quantity", column = @Column(name = "sales_price_quantity")),
31:             @AttributeOverride(name = "currencyUnit", column = @Column(name = "sales_price_currency"))
32:     })
33:     private Currency salesPrice;  // Direkt als Currency, ohne Adapter
34: 
35: 
36:     public Product() {}
37: 
38:     public Product(String name, String description, Float size, Currency buyingPrice, Currency salesPrice) {
39:         this.productId = new ProductId();
40:         this.name = name;
41:         this.description = description;
42:         this.size = size;
43:         this.buyingPrice = buyingPrice;
44:         this.salesPrice = salesPrice;
45:     }
46: 
47:     public CurrencyType getSalesPrice() {
48:         return salesPrice;
49:     }
50: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductBasketUsageChecker.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: 
4: import java.util.UUID;
5: 
6: public interface ProductBasketUsageChecker {
7:     boolean isProductInAnyBasket(UUID productId);
8: 
9:     void deleteAllBaskets();
10: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductId.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: 
13: @Embeddable
14: @NoArgsConstructor(access = AccessLevel.PROTECTED)
15: @AttributeOverride(name = "id", column = @Column(name = "product_id"))
16: public class ProductId extends GenericId {
17:     public ProductId (UUID id) {
18:         super(id);
19:     }
20: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
6: 
7: @Converter(autoApply = true)
8: public class ProductIdConverter extends GenericIdConverter<ProductId>{
9:     public ProductIdConverter() {
10:         super(ProductId::new);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductLookup.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import java.util.UUID;
4: 
5: public interface ProductLookup {
6:     Product findProductById(UUID productId);
7: 
8:     boolean isExistingProduct(UUID productId);
9: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\ProductRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.stereotype.Repository;
5: 
6: import java.util.Optional;
7: 
8: @Repository
9: public interface ProductRepository extends JpaRepository<Product, ProductId> {
10:     Optional<Product> findById(ProductId id);
11: 
12:     boolean existsById(ProductId id);
13: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\PurchaseUsage.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import java.util.UUID;
4: 
5: public interface PurchaseUsage {
6:     boolean isProductInAnyPurchase(UUID productId);
7: 
8:     void deleteAllPurchases();
9: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\PurchaseUsageChecker.java ---
1: package thkoeln.archilab.ecommerce.solution.product.domain;
2: 
3: import java.util.UUID;
4: 
5: public interface PurchaseUsageChecker {
6:     boolean isProductInPurchases(UUID productId);
7: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseService.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.application;
2: 
3: import org.springframework.stereotype.Service;
4: import org.springframework.transaction.annotation.Transactional;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
7: import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
8: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
9: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchasePosition;
10: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;
11: import thkoeln.archilab.ecommerce.solution.user.domain.User;
12: import thkoeln.archilab.ecommerce.solution.user.domain.UserFinder;
13: import thkoeln.archilab.ecommerce.usecases.PurchaseUseCases;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
15: 
16: import java.util.*;
17: import java.util.stream.Collectors;
18: 
19: // üßæ PurchaseService ‚Äì Bestellungen & K√§ufe
20: 
21: @Service
22: public class PurchaseService implements PurchaseUseCases {
23: 
24:     private final PurchaseRepository purchaseRepository;
25:     private final UserFinder userFinder;
26: 
27:     public PurchaseService(PurchaseRepository purchaseRepository, UserFinder userFinder) {
28:         this.purchaseRepository = purchaseRepository;
29:         this.userFinder = userFinder;
30:     }
31: 
32:     @Transactional
33:     @Override
34:     public Map<UUID, Integer> getPurchaseHistory(MailAddressType userMailAddress) {
35:         if (userMailAddress == null) {
36:             throw new ShopException("Email must not be null.");
37:         }
38: 
39:         User user = userFinder.findByMailAddress(userMailAddress)
40:                 .orElseThrow(() -> new ShopException("User not found."));
41: 
42:         List<Purchase> purchases = purchaseRepository.findByUserId(user.getUserId());
43: 
44:         return purchases.stream()
45:                 .flatMap(purchase -> purchase.getPurchasePositions().stream())
46:                 .filter(position -> position.getProductId() != null)
47:                 .collect(Collectors.toMap(
48:                         PurchasePosition::getProductId,
49:                         PurchasePosition::getQuantity,
50:                         Integer::sum
51:                 ));
52:     }
53: 
54:     @Transactional
55:     @Override
56:     public Integer getPurchaseQuantityForProduct(UUID purchaseId, UUID productId) {
57:         if (purchaseId == null || productId == null) {
58:             throw new ShopException("Purchase ID and Product ID must not be null.");
59:         }
60:         // Hier konvertieren wir die UUID zu PurchaseId
61:         PurchaseId purchaseIdEntity = new PurchaseId(purchaseId);
62: 
63:         Purchase purchase = purchaseRepository.findById(purchaseIdEntity)
64:                 .orElseThrow(() -> new ShopException("Purchase not found."));
65: 
66:         return purchase.getPurchasePositions().stream()
67:                 .filter(position -> position.getProductId().equals(productId))
68:                 .map(PurchasePosition::getQuantity)
69:                 .findFirst()
70:                 .orElse(0); // Return 0 if the product is not part of the purchase
71:     }
72: 
73:     @Transactional
74:     @Override
75:     public UUID getFulfillmentCenterIdForPurchase(UUID purchaseId) {
76:         if (purchaseId == null) {
77:             throw new ShopException("Purchase ID must not be null.");
78:         }
79:         // Hier konvertieren wir die UUID zu PurchaseId
80:         PurchaseId purchaseIdEntity = new PurchaseId(purchaseId);
81: 
82:         Purchase purchase = purchaseRepository.findById(purchaseIdEntity)
83:                 .orElseThrow(() -> new ShopException("Purchase not found."));
84: 
85:         return purchase.getFulfillmentCenterId().getId();
86:     }
87: 
88:     @Transactional
89:     @Override
90:     public void deleteAllPurchases() {
91:         purchaseRepository.deleteAll();
92:     }
93: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseUsageAdapter.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.application;
2: 
3: import org.springframework.stereotype.Component;
4: import thkoeln.archilab.ecommerce.solution.product.domain.PurchaseUsageChecker;
5: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;
6: 
7: import java.util.UUID;
8: 
9: @Component
10: public class PurchaseUsageAdapter implements PurchaseUsageChecker {
11: 
12:     private final PurchaseRepository purchaseRepository;
13: 
14:     public PurchaseUsageAdapter (PurchaseRepository purchaseRepository) {
15:         this.purchaseRepository = purchaseRepository;
16:     }
17: 
18:     @Override
19:     public boolean isProductInPurchases(UUID productId) {
20:         return purchaseRepository.findAll().stream()
21:                 .flatMap(p -> p.getPurchasePositions().stream())
22:                 .anyMatch(pos -> pos.getProductId().equals(productId));
23:     }
24: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\Purchase.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenter;
8: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterId;
9: import thkoeln.archilab.ecommerce.solution.user.domain.User;
10: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
11: 
12: import java.util.*;
13: 
14: @Entity
15: @Getter
16: @Setter
17: @NoArgsConstructor
18: public class Purchase {
19:     @EmbeddedId
20:     private PurchaseId purchaseId;
21: 
22:     @Embedded
23:     private UserId userId;
24: 
25:     @Embedded
26:     private FulfillmentCenterId fulfillmentCenterId;
27: 
28:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
29:     @JoinColumn(name = "purchase_id")
30:     private List<PurchasePosition> purchasePositions = new ArrayList<>();
31: 
32:     public void addPurchasePosition(PurchasePosition position) {
33:         this.purchasePositions.add(position);
34:     }
35: 
36:     public Purchase(UserId userId, FulfillmentCenterId centerId) {
37:         this.purchaseId = new PurchaseId();
38:         this.userId = userId;
39:         this.fulfillmentCenterId = centerId;
40:     }
41: 
42:     public Purchase(User user, FulfillmentCenter center) {
43:         this.purchaseId = new PurchaseId();
44:         this.userId = user.getUserId();
45:         this.fulfillmentCenterId = new FulfillmentCenterId(center.getFulFillmentCenterId());
46:     }
47: 
48:     public Purchase(UserId userId, UUID fulfillmentCenterId) {
49:         this.purchaseId = new PurchaseId();
50:         this.userId = userId;
51:         this.fulfillmentCenterId = new FulfillmentCenterId(fulfillmentCenterId);
52:     }
53: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseId.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "purchase_id"))
15: public class PurchaseId extends GenericId {
16:     public PurchaseId (UUID id) {
17:         super(id);
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketId;
6: 
7: @Converter(autoApply = true)
8: public class PurchaseIdConverter extends GenericIdConverter<PurchaseId> {
9:     public PurchaseIdConverter() {
10:         super(PurchaseId::new);
11:     }
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePosition.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.UUID;
9: 
10: @Entity
11: @Getter
12: @Setter
13: @NoArgsConstructor
14: public class PurchasePosition {
15:     @EmbeddedId
16:     private PurchasePositionId purchasePositionId;
17: 
18:     private UUID productId;
19: 
20:     @Setter
21:     private int quantity;
22: 
23:     public PurchasePosition(UUID productId, int quantity) {
24:         this.purchasePositionId = new PurchasePositionId();
25:         this.productId = productId;
26:         this.quantity = quantity;
27:     }
28: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePositionId.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: 
13: @Embeddable
14: @NoArgsConstructor(access = AccessLevel.PROTECTED)
15: @AttributeOverride(name = "id", column = @Column(name = "purchase_position_id"))
16: public class PurchasePositionId extends GenericId {
17:     public PurchasePositionId (UUID id) {
18:         super(id);
19:     }
20: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePositionIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class PurchasePositionIdConverter extends GenericIdConverter<PurchasePositionId> {
8:     public PurchasePositionIdConverter () {
9:         super(PurchasePositionId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.purchase.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
6: 
7: import java.util.List;
8: 
9: @Repository
10: public interface PurchaseRepository extends JpaRepository<Purchase, PurchaseId> {
11:     List<Purchase> findByUserId(UserId userId);
12: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\BasketFactoryImpl.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import lombok.RequiredArgsConstructor;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
6: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
7: import thkoeln.archilab.ecommerce.solution.user.domain.BasketFactory;
8: 
9: import java.util.UUID;
10: 
11: @Component
12: @RequiredArgsConstructor
13: public class BasketFactoryImpl implements BasketFactory {
14: 
15:     private final ShoppingBasketRepository basketRepository;
16: 
17:     @Override
18:     public void createInitialBasketForUser(UUID userId) {
19:         ShoppingBasket basket = new ShoppingBasket(new thkoeln.archilab.ecommerce.solution.user.domain.UserId(userId));
20:         basketRepository.save(basket);
21:     }
22: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\PurchaseDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import java.util.List;
4: import java.util.UUID;
5: 
6: public record PurchaseDTO(
7:         UUID id,
8:         String userName,
9:         UUID fulfillmentCenterId,
10:         List<PurchasePositionDTO> positions
11: ) {}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\PurchasePositionDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import java.util.UUID;
4: 
5: public record PurchasePositionDTO(
6:         UUID productId,
7:         int quantity
8: ) {}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import lombok.RequiredArgsConstructor;
4: import org.springframework.http.HttpStatus;
5: import org.springframework.http.ResponseEntity;
6: import org.springframework.web.bind.annotation.*;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
9: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
10: import thkoeln.archilab.ecommerce.solution.user.domain.BasketFactory;
11: import thkoeln.archilab.ecommerce.solution.user.domain.User;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
13: 
14: import java.text.DecimalFormat;
15: import java.text.DecimalFormatSymbols;
16: import java.text.NumberFormat;
17: import java.util.*;
18: import java.util.stream.Collectors;
19: 
20: @RestController
21: @RequestMapping("/shoppingBaskets")
22: @RequiredArgsConstructor
23: public class ShoppingBasketController {
24: 
25:     private final ShoppingBasketService shoppingBasketService;
26:     private final BasketFactory basketFactory;
27: 
28: 
29:     //3) GET /shoppingBaskets?userId=...
30:     @GetMapping(produces = "application/json")
31:     public ResponseEntity<ShoppingBasketDTO> getShoppingBasketByUserId(
32:             @RequestParam(value = "userId", required = false) String userIdStr) {
33: 
34:         if (userIdStr == null) {
35:             return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).build(); // 405
36:         }
37: 
38:         UUID userId;
39:         try {
40:             userId = UUID.fromString(userIdStr);
41:         } catch (IllegalArgumentException e) {
42:             return ResponseEntity.status(HttpStatus.NOT_FOUND).build(); // 404 f√ºr ung√ºltige UUID
43:         }
44: 
45:         try {
46:             User user = shoppingBasketService.getUserById(userId);
47:             ShoppingBasket basket = shoppingBasketService.getBasket(user.getMailAddress());
48:             CurrencyType currencyValue = shoppingBasketService.getShoppingBasketAsCurrencyValue(
49:                     user.getMailAddress()
50:             );
51:             String totalPrice = formatCurrencyString(currencyValue);
52: 
53:             List<ShoppingBasketPositionDTO> positions = basket.getShoppingBasketPositions().stream()
54:                     .map(pos -> new ShoppingBasketPositionDTO(pos.getProductId(), pos.getQuantity()))
55:                     .collect(Collectors.toList());
56: 
57:             ShoppingBasketDTO dto = new ShoppingBasketDTO(
58:                     basket.getShoppingBasketId().getId(),
59:                     totalPrice,
60:                     positions
61:             );
62: 
63:             return ResponseEntity.ok(dto); // 200 OK
64:         } catch (ShopException e) {
65:             return ResponseEntity.status(HttpStatus.NOT_FOUND).build(); // 404
66:         }
67:     }
68: 
69:     private String formatCurrencyString(CurrencyType currency) {
70:         DecimalFormat formatter = (DecimalFormat) DecimalFormat.getInstance(Locale.getDefault()); //Default Location -> passt sich an ob Komma oder Punkt
71:         formatter.setMinimumFractionDigits(2);
72:         formatter.setMaximumFractionDigits(2);
73:         formatter.setGroupingUsed(false); // Keine Tausendertrennung
74: 
75:         String symbol = switch (currency.getCurrencyUnit()) {
76:             case "EUR" -> "‚Ç¨";
77:             case "CHF" -> "CHF";
78:             default -> currency.getCurrencyUnit();
79:         };
80: 
81:         return formatter.format(currency.getQuantity()) + " " + symbol;
82:     }
83: 
84:     //6) POST /shoppingBaskets/{shoppingBasketId}/positions
85:     @PostMapping("/{shoppingBasketId}/positions")
86:     public ResponseEntity<Void> addProductToBasket(
87:             @PathVariable UUID shoppingBasketId,
88:             @RequestBody(required = false) ShoppingBasketPositionDTO dto) {
89: 
90:         if (dto == null || dto.getProductId() == null || dto.getQuantity() <= 0) {
91:             return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).build(); // 422
92:         }
93: 
94:         try {
95:             shoppingBasketService.addProductByBasketId(shoppingBasketId, dto.getProductId(), dto.getQuantity());
96:             return ResponseEntity.status(HttpStatus.CREATED).build(); // 201
97:         } catch (ShopException e) {
98:             return ResponseEntity.status(HttpStatus.NOT_FOUND).build(); // 404
99:         }
100:     }
101: 
102:     //10) DELETE /shoppingBaskets/{shoppingBasketId}/positions/{productId}
103:     @DeleteMapping("/{shoppingBasketId}/positions/{productId}")
104:     public ResponseEntity<Void> removeProductFromBasket(
105:             @PathVariable UUID shoppingBasketId,
106:             @PathVariable UUID productId) {
107: 
108:         try {
109:             shoppingBasketService.removeProductByBasketId(shoppingBasketId, productId);
110:             return ResponseEntity.ok().build(); // 200 OK
111:         } catch (ShopException e) {
112:             return ResponseEntity.status(HttpStatus.NOT_FOUND).build(); // 404
113:         }
114:     }
115: 
116:     //11) POST /shoppingBaskets/{shoppingBasketId}/checkout
117:     @PostMapping("/{shoppingBasketId}/checkout")
118:     public ResponseEntity<List<PurchaseDTO>> checkoutBasket(@PathVariable UUID shoppingBasketId) {
119:         try {
120:             MailAddress mail = (MailAddress) shoppingBasketService.getMailAddressFromBasketId(shoppingBasketId);
121:             Set<UUID> purchaseIds = shoppingBasketService.checkout(mail);
122: 
123:             List<PurchaseDTO> purchases = purchaseIds.stream()
124:                     .map(purchaseId -> new PurchaseDTO(
125:                             purchaseId,
126:                             shoppingBasketService.getUserByBasketId(shoppingBasketId).getName(),
127:                             shoppingBasketService.getFulfillmentCenterIdForPurchase(purchaseId),
128:                             shoppingBasketService.getPositionsForPurchase(purchaseId)
129:                     ))
130:                     .toList();
131:             return ResponseEntity.status(HttpStatus.CREATED).body(purchases);
132:         } catch (ShopException e) {
133:             return ResponseEntity.status(HttpStatus.CONFLICT).build(); // 409
134:         }
135:     }
136: 
137:     @PostMapping
138:     public ResponseEntity<Void> createBasket(@RequestParam UUID userId) {
139:         basketFactory.createInitialBasketForUser(userId);
140:         return ResponseEntity.ok().build();
141:     }
142: 
143: 
144:     //Zus√§tzlicher GET Endpoint zur Basket-ID
145:     @GetMapping("/{basketId}")
146:     public ResponseEntity<ShoppingBasketDTO> getBasketById(@PathVariable UUID basketId) {
147:         Optional<ShoppingBasket> optional = shoppingBasketService.getBasketById(basketId);
148:         if (optional.isEmpty()) return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
149: 
150:         ShoppingBasket basket = optional.get();
151:         //Die Mail-Adresse kommt √ºber den User
152:         User user = shoppingBasketService.getUserByBasketId(basketId);
153:         CurrencyType total = shoppingBasketService.getShoppingBasketAsCurrencyValue(user.getMailAddress());
154: 
155:         List<ShoppingBasketPositionDTO> positions = basket.getShoppingBasketPositions().stream()
156:                 .map(pos -> new ShoppingBasketPositionDTO(pos.getProductId(), pos.getQuantity()))
157:                 .toList();
158: 
159:         return ResponseEntity.ok(new ShoppingBasketDTO(
160:                 basket.getShoppingBasketId().getId(),
161:                 formatCurrencyString(total),
162:                 positions
163:         ));
164:     }
165: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Data;
5: import lombok.NoArgsConstructor;
6: 
7: import java.util.List;
8: import java.util.UUID;
9: 
10: @Data
11: @AllArgsConstructor
12: @NoArgsConstructor
13: public class ShoppingBasketDTO {
14:     private UUID id;
15:     private String totalSalesPrice;
16:     private List<ShoppingBasketPositionDTO> positions;
17: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketMapperHelper.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
4: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
5: 
6: import java.util.List;
7: import java.util.Locale;
8: import java.util.stream.Collectors;
9: 
10: public class ShoppingBasketMapperHelper {
11: 
12:     public static ShoppingBasketDTO mapToDTO(ShoppingBasket basket, Currency totalValue) {
13:         List<ShoppingBasketPositionDTO> positions = basket.getShoppingBasketPositions().stream()
14:                 .map(ShoppingBasketPositionMapperHelper::mapToDTO)
15:                 .collect(Collectors.toList());
16: 
17:         String formattedTotal = formatCurrency(totalValue);
18: 
19:         return new ShoppingBasketDTO(
20:                 basket.getShoppingBasketId().getId(),
21:                 formattedTotal,
22:                 positions
23:         );
24:     }
25: 
26:     private static String formatCurrency(Currency currency) {
27:         String symbol = switch (currency.getCurrencyUnit()) {
28:             case "EUR" -> "‚Ç¨";
29:             case "CHF" -> "CHF";
30:             default -> currency.getCurrencyUnit();
31:         };
32: 
33:         String formatted = String.format(Locale.getDefault(), "%.2f", currency.getQuantity());
34:         return formatted + " " + symbol;
35:     }
36: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketPositionDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Data;
5: import lombok.NoArgsConstructor;
6: 
7: import java.util.UUID;
8: 
9: @Data
10: @AllArgsConstructor
11: @NoArgsConstructor
12: public class ShoppingBasketPositionDTO {
13:     private UUID productId;
14:     private int quantity;
15: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketPositionMapperHelper.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
4: 
5: public class ShoppingBasketPositionMapperHelper {
6: 
7:     public static ShoppingBasketPositionDTO mapToDTO(ShoppingBasketPosition position) {
8:         return new ShoppingBasketPositionDTO(
9:                 position.getProductId(),
10:                 position.getQuantity()
11:         );
12:     }
13: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import org.springframework.transaction.annotation.Transactional;
6: import thkoeln.archilab.ecommerce.InsufficientInventoryException;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
9: import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;
10: import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.*;
11: import thkoeln.archilab.ecommerce.solution.product.domain.ProductId;
12: import thkoeln.archilab.ecommerce.solution.product.domain.ProductLookup;
13: import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
14: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
15: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchasePosition;
16: import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;
17: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.*;
18: import thkoeln.archilab.ecommerce.solution.user.domain.User;
19: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
20: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
21: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
22: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
23: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
24: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
25: 
26: 
27: import java.util.*;
28: import java.util.stream.Collectors;
29: 
30: // üõí ShoppingBasketService ‚Äì Warenkorb-Logik & Checkout
31: 
32: @Service
33: public class ShoppingBasketService implements ShoppingBasketUseCases {
34: 
35:     private final UserRepository userRepository;
36:     private final ShoppingBasketRepository shoppingBasketRepository;
37:     private final PurchaseRepository purchaseRepository;
38:     private final ProductLookup productLookup;
39:     private final FulfillmentCenterFinder fulfillmentCenterFinder;
40:     private final FulfillmentInventoryChecker inventoryChecker;
41:     private final FulfillmentCenterRepository fulfillmentCenterRepository;
42: 
43:     @Autowired
44:     public ShoppingBasketService(UserRepository userRepository,
45:                                  ShoppingBasketRepository shoppingBasketRepository,
46:                                  PurchaseRepository purchaseRepository,
47:                                  ProductLookup productLookup,
48:                                  FulfillmentCenterFinder fulfillmentCenterFinder,
49:                                  FulfillmentInventoryChecker inventoryChecker, FulfillmentCenterRepository fulfillmentCenterRepository) {
50:         this.userRepository = userRepository;
51:         this.shoppingBasketRepository = shoppingBasketRepository;
52:         this.purchaseRepository = purchaseRepository;
53:         this.productLookup = productLookup;
54:         this.fulfillmentCenterFinder = fulfillmentCenterFinder;
55:         this.inventoryChecker = inventoryChecker;
56:         this.fulfillmentCenterRepository = fulfillmentCenterRepository;
57:     }
58: 
59:     @Transactional
60:     @Override
61:     public void addProductToShoppingBasket(MailAddressType userMailAddress, UUID productId, int quantityFor) {
62:         if (quantityFor <= 0) throw new ShopException("Quantity must be positive.");
63: 
64:         ShoppingBasket basket = getBasket(userMailAddress);
65:         productLookup.findProductById(productId);
66:         basket.addProduct(productId, quantityFor);
67:         shoppingBasketRepository.save(basket);
68:     }
69: 
70:     @Transactional
71:     @Override
72:     public void removeProductFromShoppingBasket(MailAddressType userMailAddress, UUID productId, int quantityFor) {
73:         if (userMailAddress == null || productId == null || quantityFor < 0) {
74:             throw new ShopException("Invalid input for removeProductFromShoppingBasket.");
75:         }
76: 
77:         MailAddress mailAddress = (MailAddress) userMailAddress;
78: 
79:         if (mailAddress.toString().isBlank()) {
80:             throw new ShopException("Mail address is blank.");
81:         }
82: 
83:         User user = userRepository.findByMailAddress(mailAddress)
84:                 .orElseThrow(() -> new ShopException("User not found."));
85: 
86:         productLookup.findProductById(productId);
87: 
88:         ShoppingBasket basket = shoppingBasketRepository.findByUserId(user.getUserId())
89:                 .orElseThrow(() -> new ShopException("Basket not found."));
90: 
91:         basket.removeProduct(productId, quantityFor);
92:         shoppingBasketRepository.save(basket);
93:     }
94: 
95:     @Transactional
96:     @Override
97:     public Map<UUID, Integer> getShoppingBasketAsMap(MailAddressType userMailAddress) {
98:         ShoppingBasket basket = getBasket(userMailAddress);
99:         return new HashMap<>(basket.toProductQuantityMap());
100:     }
101: 
102:     @Transactional
103:     @Override
104:     public CurrencyType getShoppingBasketAsCurrencyValue(MailAddressType userMailAddress) {
105:         ShoppingBasket basket = getBasket(userMailAddress);
106: 
107:         Map<UUID, Float> priceMap = new HashMap<>();
108:         for (ShoppingBasketPosition pos : basket.getShoppingBasketPositions()) {
109:             var product = productLookup.findProductById(pos.getProductId());
110:             priceMap.put(pos.getProductId(), product.getSalesPrice().getQuantity());
111:         }
112: 
113:         float total = basket.getTotalValue(priceMap);
114:         return Currency.of(total, "EUR"); // oder "CHF" je nach Bedarf
115:     }
116: 
117:     @Transactional
118:     @Override
119:     public Set<UUID> checkout(MailAddressType userMailAddress) {
120:         User user = getUserByMail(userMailAddress);
121:         ShoppingBasket basket = getUserBasket(user);
122:         Map<UUID, Integer> productQuantities = extractProductQuantities(basket);
123: 
124:         List<UUID> purchaseIds = new ArrayList<>();
125:         PostalCode postalCode = (PostalCode) user.getPhysicalAddress().getPostalCode();
126:         int postalDigit = Character.getNumericValue(postalCode.toString().charAt(0));
127: 
128:         while (!productQuantities.isEmpty()) {
129:             List<FulfillmentCenter> sortedCenters = getSortedFulfillmentCenters(productQuantities, postalCode, postalDigit);
130:             boolean fulfilled = tryFulfillWithCenters(sortedCenters, productQuantities, user, purchaseIds);
131: 
132:             if (!fulfilled) {
133:                 throw new InsufficientInventoryException("Not all products could be fulfilled.");
134:             }
135:         }
136: 
137:         basket.clear();
138:         shoppingBasketRepository.save(basket);
139:         return new HashSet<>(purchaseIds);
140:     }
141: 
142:     @Override
143:     public void emptyAllShoppingBaskets() {
144:         shoppingBasketRepository.deleteAll();
145:     }
146: 
147:     //Hilfsmethoden
148:     private User getUserByMail(MailAddressType userMailAddress) {
149:         if (userMailAddress == null || userMailAddress.toString().isBlank()) {
150:             throw new ShopException("Mail address is required.");
151:         }
152: 
153:         return userRepository.findByMailAddress((MailAddress) userMailAddress)
154:                 .orElseThrow(() -> new ShopException("User not found."));
155:     }
156: 
157:     private ShoppingBasket getUserBasket(User user) {
158:         ShoppingBasket basket = shoppingBasketRepository.findByUserId(user.getUserId())
159:                 .orElseThrow(() -> new ShopException("Basket not found."));
160: 
161:         if (basket.getShoppingBasketPositions().isEmpty()) {
162:             throw new ShopException("Basket is empty.");
163:         }
164: 
165:         return basket;
166:     }
167: 
168:     private Map<UUID, Integer> extractProductQuantities(ShoppingBasket basket) {
169:         Map<UUID, Integer> productQuantities = new HashMap<>();
170:         for (ShoppingBasketPosition pos : basket.getShoppingBasketPositions()) {
171:             productQuantities.put(pos.getProductId(), pos.getQuantity());
172:         }
173:         return productQuantities;
174:     }
175: 
176:     private List<FulfillmentCenter> getSortedFulfillmentCenters(Map<UUID, Integer> productQuantities,
177:                                                                 PostalCode userPostalCode,
178:                                                                 int postalDigit) {
179:         Map<ProductId, Integer> productIdMap = productQuantities.entrySet().stream()
180:                 .collect(Collectors.toMap(e -> new ProductId(e.getKey()), Map.Entry::getValue));
181: 
182:         return fulfillmentCenterRepository.findAll().stream()
183:                 .filter(fc -> (fc.getFromPostalCodeFirstDigit() == 0 && fc.getToPostalCodeFirstDigit() == 0)
184:                         || (postalDigit >= fc.getFromPostalCodeFirstDigit()
185:                         && postalDigit <= fc.getToPostalCodeFirstDigit()))
186:                 .sorted(new FulfillmentCenterComparator(productIdMap, userPostalCode))
187:                 .collect(Collectors.toList());
188:     }
189: 
190:     private boolean tryFulfillWithCenters(List<FulfillmentCenter> centers,
191:                                           Map<UUID, Integer> productQuantities,
192:                                           User user,
193:                                           List<UUID> purchaseIds) {
194:         for (FulfillmentCenter fc : centers) {
195:             Map<UUID, Integer> fulfillable = getPartiallyFulfillablePositions(fc, productQuantities);
196:             if (fulfillable.isEmpty()) continue;
197: 
198:             inventoryChecker.setFulfillmentCenter(fc.getFulFillmentCenterId());
199:             Purchase purchase = new Purchase(user.getUserId(), fc.getFulFillmentCenterId());
200: 
201:             for (Map.Entry<UUID, Integer> entry : fulfillable.entrySet()) {
202:                 UUID productId = entry.getKey();
203:                 int quantity = entry.getValue();
204:                 inventoryChecker.removeFromInventory(productId, quantity);
205:                 purchase.addPurchasePosition(new PurchasePosition(productId, quantity));
206:                 updateRemainingQuantities(productQuantities, productId, quantity);
207:             }
208: 
209:             inventoryChecker.saveChanges();
210:             purchaseRepository.save(purchase);
211:             purchaseIds.add(purchase.getPurchaseId().getId());
212:             return true;
213:         }
214:         return false;
215:     }
216: 
217:     private void updateRemainingQuantities(Map<UUID, Integer> quantities, UUID productId, int fulfilled) {
218:         int remaining = quantities.get(productId) - fulfilled;
219:         if (remaining <= 0) {
220:             quantities.remove(productId);
221:         } else {
222:             quantities.put(productId, remaining);
223:         }
224:     }
225: 
226:     private Map<UUID, Integer> getPartiallyFulfillablePositions(FulfillmentCenter center, Map<UUID, Integer> shoppingBasket) {
227:         inventoryChecker.setFulfillmentCenter(center.getFulFillmentCenterId());
228:         Map<UUID, Integer> result = new HashMap<>();
229: 
230:         for (Map.Entry<UUID, Integer> entry : shoppingBasket.entrySet()) {
231:             UUID productId = entry.getKey();
232:             int requested = entry.getValue();
233: 
234:             int available = inventoryChecker.hasEnoughInventory(productId, 1) ? // check if any
235:                     Math.min(requested, center.getInventoryLevel(productId)) : 0;
236: 
237:             if (available > 0) {
238:                 result.put(productId, available);
239:             }
240:         }
241:         return result;
242:     }
243: 
244:     public ShoppingBasket getBasket(MailAddressType userMailAddress) {
245:         if (userMailAddress == null) {
246:             throw new ShopException("Mail address cannot be null.");
247:         }
248: 
249:         MailAddress mailAddress = (MailAddress) userMailAddress;
250: 
251:         if (mailAddress.toString().isBlank()) {
252:             throw new ShopException("Mail address is blank.");
253:         }
254: 
255:         User user = userRepository.findByMailAddress(mailAddress)
256:                 .orElseThrow(() -> new ShopException("User not found."));
257: 
258:         return shoppingBasketRepository.findByUserId(user.getUserId())
259:                 .orElseThrow(() -> new ShopException("Basket not found."));
260:     }
261: 
262:     public Optional<ShoppingBasket> getBasketById(UUID basketId) {
263:         return shoppingBasketRepository.findById(new ShoppingBasketId(basketId));
264:     }
265: 
266:     public User getUserById(UUID userId) {
267:         return userRepository.findById(new UserId(userId))
268:                 .orElseThrow(() -> new ShopException("User not found"));
269:     }
270: 
271:     public User getUserByBasketId(UUID basketId) {
272:         ShoppingBasket basket = shoppingBasketRepository.findById(new ShoppingBasketId(basketId))
273:                 .orElseThrow(() -> new ShopException("Basket not found"));
274:         return userRepository.findById(basket.getUserId())
275:                 .orElseThrow(() -> new ShopException("User not found"));
276:     }
277: 
278:     public void addProductByBasketId(UUID basketId, UUID productId, int quantity) {
279:         User user = getUserByBasketId(basketId);
280:         addProductToShoppingBasket(user.getMailAddress(), productId, quantity);
281:     }
282: 
283:     public void removeProductByBasketId(UUID basketId, UUID productId) {
284:         User user = getUserByBasketId(basketId);
285:         ShoppingBasket basket = getBasket(user.getMailAddress());
286: 
287:         Optional<ShoppingBasketPosition> maybePos = basket.getShoppingBasketPositions().stream()
288:                 .filter(pos -> pos.getProductId().equals(productId))
289:                 .findFirst();
290: 
291:         if (maybePos.isEmpty()) {
292:             throw new ShopException("Product not in basket.");
293:         }
294: 
295:         int actualQuantity = maybePos.get().getQuantity();
296:         removeProductFromShoppingBasket(user.getMailAddress(), productId, actualQuantity);
297:     }
298: 
299:     public MailAddressType getMailAddressFromBasketId(UUID basketId) {
300:         ShoppingBasket basket = getBasketById(basketId)
301:                 .orElseThrow(() -> new ShopException("Basket not found"));
302: 
303:         User user = userRepository.findById(basket.getUserId())
304:                 .orElseThrow(() -> new ShopException("User not found"));
305: 
306:         return user.getMailAddress();
307:     }
308: 
309:     public UUID getFulfillmentCenterIdForPurchase(UUID purchaseId) {
310:         if (purchaseId == null) {
311:             throw new ShopException("Purchase ID must not be null.");
312:         }
313: 
314:         PurchaseId purchaseIdEntity = new PurchaseId(purchaseId);
315:         Purchase purchase = purchaseRepository.findById(purchaseIdEntity)
316:                 .orElseThrow(() -> new ShopException("Purchase not found."));
317: 
318:         return purchase.getFulfillmentCenterId().getId();
319:     }
320: 
321:     public List<PurchasePositionDTO> getPositionsForPurchase(UUID purchaseId) {
322:         PurchaseId id = new PurchaseId(purchaseId);
323:         Purchase purchase = purchaseRepository.findById(id)
324:                 .orElseThrow(() -> new ShopException("Purchase not found"));
325: 
326:         return purchase.getPurchasePositions().stream()
327:                 .map(pos -> new PurchasePositionDTO(pos.getProductId(), pos.getQuantity()))
328:                 .toList();
329:     }
330: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
9: 
10: import java.util.*;
11: import java.util.stream.Collectors;
12: 
13: @Entity
14: @Getter
15: @Setter
16: @NoArgsConstructor
17: public class ShoppingBasket {
18:     @EmbeddedId
19:     private ShoppingBasketId shoppingBasketId;
20: 
21:     @Embedded
22:     private UserId userId;
23: 
24:     @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
25:     @JoinColumn(name = "shopping_basket_id")
26:     private List<ShoppingBasketPosition> shoppingBasketPositions = new ArrayList<>();
27: 
28:     public ShoppingBasket(UserId userId) {
29:         this.shoppingBasketId = new ShoppingBasketId();
30:         this.userId = userId;
31:     }
32: 
33:     public void addProduct(UUID productId, int quantity) {
34:         for (ShoppingBasketPosition position : shoppingBasketPositions) {
35:             if (position.getProductId().equals(productId)) {
36:                 position.setQuantity(position.getQuantity() + quantity);
37:                 return;
38:             }
39:         }
40: 
41:         shoppingBasketPositions.add(new ShoppingBasketPosition(productId, quantity));
42:     }
43: 
44: 
45:     public void removeProduct(UUID productIdRaw, int quantity) {
46:         Optional<ShoppingBasketPosition> existing = shoppingBasketPositions.stream()
47:                 .filter(pos -> pos.getProductId().equals(productIdRaw))
48:                 .findFirst();
49: 
50:         if (existing.isEmpty()) {
51:             throw new ShopException("Product is not in the shopping basket.");
52:         }
53: 
54:         ShoppingBasketPosition pos = existing.get();
55: 
56:         if (pos.getQuantity() < quantity) {
57:             throw new ShopException("Product is not in the shopping basket in the requested quantity.");
58:         }
59: 
60:         if (pos.getQuantity() == quantity) {
61:             shoppingBasketPositions.remove(pos);
62:         } else {
63:             pos.setQuantity(pos.getQuantity() - quantity);
64:         }
65:     }
66: 
67:     public boolean isEmpty() {
68:         return shoppingBasketPositions.isEmpty();
69:     }
70: 
71:     public float getTotalValue(Map<UUID, Float> productPrices) {
72:         return (float) shoppingBasketPositions.stream()
73:                 .mapToDouble(pos -> {
74:                     UUID id = pos.getProductId();
75:                     return productPrices.getOrDefault(id, 0f) * pos.getQuantity();
76:                 })
77:                 .sum();
78:     }
79: 
80:     public void clear() {
81:         shoppingBasketPositions.clear();
82:     }
83: 
84:     public Map<UUID, Integer> toProductQuantityMap() {
85:         return shoppingBasketPositions.stream()
86:                 .collect(Collectors.toMap(
87:                                  ShoppingBasketPosition::getProductId,
88:                          ShoppingBasketPosition::getQuantity
89:         ));
90:     }
91: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: 
13: @Embeddable
14: @NoArgsConstructor(access = AccessLevel.PROTECTED)
15: @AttributeOverride(name = "id", column = @Column(name = "shoppingBasket_id"))
16: public class ShoppingBasketId extends GenericId {
17:     public ShoppingBasketId (UUID id) {
18:         super(id);
19:     }
20: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ShoppingBasketIdConverter extends GenericIdConverter<ShoppingBasketId> {
8:     public ShoppingBasketIdConverter() {
9:         super(ShoppingBasketId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: 
8: import java.util.UUID;
9: 
10: @Entity
11: @Getter
12: @Setter
13: @NoArgsConstructor
14: public class ShoppingBasketPosition {
15:     @EmbeddedId
16:     private ShoppingBasketPositionId shoppingBasketPositionId;
17: 
18:     private UUID productId;
19: 
20:     private int quantity;
21: 
22:     public ShoppingBasketPosition(UUID productId, int quantity) {
23:         this.shoppingBasketPositionId = new ShoppingBasketPositionId();
24:         this.productId = productId;
25:         this.quantity = quantity;
26:     }
27: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionId.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "shoppingBasketPosition_id"))
15: public class ShoppingBasketPositionId extends GenericId {
16:     public ShoppingBasketPositionId (UUID id) {
17:         super(id);
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPositionIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class ShoppingBasketPositionIdConverter extends GenericIdConverter<ShoppingBasketPositionId> {
8:     public ShoppingBasketPositionIdConverter() {
9:         super(ShoppingBasketPositionId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import thkoeln.archilab.ecommerce.solution.user.domain.UserId;
5: 
6: import java.util.Optional;
7: 
8: public interface ShoppingBasketRepository extends JpaRepository<ShoppingBasket, ShoppingBasketId> {
9:     Optional<ShoppingBasket> findByUserId(UserId userId);
10: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\MailAddressDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
4: 
5: public record MailAddressDTO(String mailAddressString) {
6:     public static MailAddressDTO from(MailAddress mailAddress) {
7:         return new MailAddressDTO(mailAddress.toString());
8:     }
9: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\PhysicalAddressDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
4: import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;
5: 
6: public record PhysicalAddressDTO(
7:         String street,
8:         String city,
9:         PostalCodeDTO postalCode
10: ) {
11:     public static PhysicalAddressDTO from(PhysicalAddress address) {
12:         return new PhysicalAddressDTO(
13:                 address.getStreet(),
14:                 address.getCity(),
15:                 PostalCodeDTO.from((PostalCode) address.getPostalCode())  // cast n√∂tig hier
16:         );
17:     }
18: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\PostalCodeDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;
4: 
5: public record PostalCodeDTO(String postalCodeString) {
6:     public static PostalCodeDTO from(PostalCode postalCode) {
7:         return new PostalCodeDTO(postalCode.toString());
8:     }
9: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserController.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import org.springframework.http.ResponseEntity;
4: import org.springframework.web.bind.annotation.*;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.domainprimitives.NotFoundException;
7: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
8: 
9: @RestController
10: @RequestMapping("/users")
11: public class UserController {
12: 
13:     private final UserRegistrationUseCases userService;
14: 
15:     public UserController(UserRegistrationUseCases userService) {
16:         this.userService = userService;
17:     }
18: 
19:     //2) Query a specific user by mailAddress
20:     //Workshop Notiz: baldung & stackoverflow recherchieren bei solchen Aufgaben
21:     @GetMapping
22:     public ResponseEntity<UserResponseDTO> getUserByMailAddress(@RequestParam(name = "mailAddress") String mailAddressString) {
23:         MailAddress mailAddress = new MailAddress(mailAddressString);
24:         UserDTO user;
25: 
26:         try {
27:             user = (UserDTO) userService.getUserData(mailAddress);
28:         } catch (Exception e) {
29:             throw new NotFoundException("User not found with mail: " + mailAddressString);
30:         }
31:         return ResponseEntity.ok(UserResponseDTO.from(user));
32:     }
33: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import lombok.Getter;
4: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
5: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
6: import thkoeln.archilab.ecommerce.usecases.UserType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
9: 
10: import java.util.UUID;
11: 
12: public class UserDTO implements UserType {
13: 
14:     @Getter
15:     private final UUID userId;
16: 
17:     private final String name;
18:     private final MailAddress mailAddress;
19:     private final PhysicalAddress physicalAddress;
20: 
21:     public UserDTO(UUID userId, String name, MailAddress mailAddress, PhysicalAddress physicalAddress) {
22:         this.userId = userId;
23:         this.name = name;
24:         this.mailAddress = mailAddress;
25:         this.physicalAddress = physicalAddress;
26:     }
27: 
28:     @Override
29:     public String getName() {
30:         return name;
31:     }
32: 
33:     @Override
34:     public MailAddressType getMailAddress() {
35:         return mailAddress;
36:     }
37: 
38:     @Override
39:     public PhysicalAddressType getPhysicalAddress() {
40:         return physicalAddress;
41:     }
42: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserFinderAdapter.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import org.springframework.stereotype.Component;
4: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
5: import thkoeln.archilab.ecommerce.solution.adapter.MailAddressJpaAdapter;
6: import thkoeln.archilab.ecommerce.solution.user.domain.User;
7: import thkoeln.archilab.ecommerce.solution.user.domain.UserFinder;
8: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
10: 
11: import java.util.Optional;
12: 
13: @Component
14: public class UserFinderAdapter implements UserFinder {
15: 
16:     private final UserRepository userRepository;
17: 
18:     public UserFinderAdapter(UserRepository userRepository) {
19:         this.userRepository = userRepository;
20:     }
21: 
22:     @Override
23:     public Optional<User> findByMailAddress(MailAddressType mailAddress) {
24:         if (mailAddress == null) return Optional.empty();
25: 
26:         MailAddress address = (MailAddress) mailAddress;
27: 
28:         return userRepository.findByMailAddress((MailAddress) mailAddress);
29:     }
30: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserRegistrationService.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import org.springframework.transaction.annotation.Transactional;
6: import thkoeln.archilab.ecommerce.ShopException;
7: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
8: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
9: import thkoeln.archilab.ecommerce.solution.user.domain.BasketFactory;
10: import thkoeln.archilab.ecommerce.solution.user.domain.User;
11: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
12: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
13: import thkoeln.archilab.ecommerce.usecases.UserType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
16: 
17: // üßë‚Äçüíª UserRegistrationService ‚Äì Benutzerregistrierung & Login
18: 
19: @Service
20: public class UserRegistrationService implements UserRegistrationUseCases {
21: 
22:     private final UserRepository userRepository;
23:     private final BasketFactory basketFactory;
24: 
25:     @Autowired
26:     public UserRegistrationService(UserRepository userRepository,
27:                                    BasketFactory basketFactory) {
28:         this.userRepository = userRepository;
29:         this.basketFactory = basketFactory;
30:     }
31: 
32:     @Transactional
33:     @Override
34:     public void register(String name, MailAddressType mailAddress, PhysicalAddressType physicalAddress) {
35:         if (name == null || name.isBlank() || mailAddress == null || physicalAddress == null) {
36:             throw new ShopException("All user fields must be filled.");
37:         }
38: 
39:         MailAddress address = (MailAddress) mailAddress;
40: 
41:         if (userRepository.existsByMailAddress((MailAddress) mailAddress)) {
42:             throw new ShopException("User already exists with this email.");
43:         }
44: 
45:         User user = new User(address, name, (PhysicalAddress) physicalAddress);
46:         userRepository.save(user);
47:         basketFactory.createInitialBasketForUser(user.getUserId().getId());
48:     }
49: 
50:     @Transactional
51:     @Override
52:     public void changeAddress(MailAddressType userMailAddress, PhysicalAddressType physicalAddress) {
53:         if (userMailAddress == null || physicalAddress == null) {
54:             throw new ShopException("All address fields must be filled.");
55:         }
56: 
57:         User user = userRepository.findByMailAddress((MailAddress) userMailAddress)
58:                 .orElseThrow(() -> new ShopException("User not found."));
59: 
60:         user.setPhysicalAddress((PhysicalAddress) physicalAddress);
61:         userRepository.save(user);
62:     }
63: 
64:     @Transactional
65:     @Override
66:     public UserType getUserData(MailAddressType userMailAddress) {
67:         User user = userRepository.findByMailAddress((MailAddress) userMailAddress)
68:                 .orElseThrow(() -> new ShopException("User not found."));
69: 
70:         return new UserDTO(
71:                 user.getUserId().getId(),
72:                 user.getName(),
73:                 user.getMailAddress(),
74:                 user.getPhysicalAddress()
75:                 );
76:     }
77: 
78:     @Transactional
79:     @Override
80:     public void deleteAllUsers() {
81:         userRepository.deleteAll();
82:     }
83: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserResponseDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: 
5: import java.util.UUID;
6: 
7: public record UserResponseDTO(
8:         @JsonProperty("id") UUID id,
9:         @JsonProperty("name") String name,
10:         @JsonProperty("mailAddress") MailAddressDTO mailAddress,
11:         @JsonProperty("physicalAddress") PhysicalAddressDTO physicalAddress
12: ) {
13:     public static UserResponseDTO from(UserDTO userDTO) {
14:         return new UserResponseDTO(
15:                 userDTO.getUserId(),
16:                 userDTO.getName(),
17:                 MailAddressDTO.from((thkoeln.archilab.ecommerce.domainprimitives.MailAddress) userDTO.getMailAddress()),
18:                 PhysicalAddressDTO.from((thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress) userDTO.getPhysicalAddress())
19:         );
20:     }
21: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\BasketFactory.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import java.util.UUID;
4: 
5: public interface BasketFactory {
6:     void createInitialBasketForUser(UUID userId);
7: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\User.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import jakarta.persistence.*;
4: import lombok.Getter;
5: import lombok.Setter;
6: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
7: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
8: 
9: @Entity
10: @Getter
11: @Setter
12: @Table(name = "Uuuser")
13: public class User {
14:     @EmbeddedId
15:     private UserId userId;
16: 
17:     private String name;
18: 
19:     @Getter
20:     @Embedded
21:     private MailAddress mailAddress;
22: 
23:     @Setter
24:     @Getter
25:     @Embedded
26:     private PhysicalAddress physicalAddress;
27: 
28:     public User() {}
29: 
30:     public User(MailAddress mailAddress, String name, PhysicalAddress address) {
31:         this.userId = new UserId();
32:         this.mailAddress = mailAddress;
33:         this.name = name;
34:         this.physicalAddress = address;
35:     }
36: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserFinder.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
4: 
5: import java.util.Optional;
6: 
7: public interface UserFinder {
8:     Optional<User> findByMailAddress(MailAddressType mailAddress);
9: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserId.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import jakarta.persistence.AttributeOverride;
4: import jakarta.persistence.Column;
5: import jakarta.persistence.Embeddable;
6: import lombok.AccessLevel;
7: import lombok.NoArgsConstructor;
8: import thkoeln.archilab.ecommerce.GenericId;
9: 
10: import java.util.UUID;
11: 
12: @Embeddable
13: @NoArgsConstructor(access = AccessLevel.PROTECTED)
14: @AttributeOverride(name = "id", column = @Column(name = "user_id"))
15: public class UserId extends GenericId {
16:     public UserId (UUID id) {
17:         super(id);
18:     }
19: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserIdConverter.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import jakarta.persistence.Converter;
4: import thkoeln.archilab.ecommerce.GenericIdConverter;
5: 
6: @Converter(autoApply = true)
7: public class UserIdConverter extends GenericIdConverter<UserId> {
8:     public UserIdConverter() {
9:         super(UserId::new);
10:     }
11: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import org.springframework.data.jpa.repository.JpaRepository;
4: import org.springframework.stereotype.Repository;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: 
7: import java.util.Optional;
8: 
9: @Repository
10: public interface UserRepository extends JpaRepository<User, UserId> {
11:     Optional<User> findByMailAddress(MailAddress mailAddress);
12: 
13:     boolean existsByMailAddress(MailAddress mailAddress);
14: 
15: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\CurrencyType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface CurrencyType {
6:     /**
7:      * @return the quantity of currency
8:      */
9:     public Float getQuantity();
10: 
11: 
12:     /**
13:      * @return the currency unit of the currency
14:      */
15:     public String getCurrencyUnit();
16: 
17: 
18:     /**
19:      * @param otherCurrency
20:      * @return this + otherCurrency, as a new object
21:      * @throws ShopException if ...
22:      *      - otherCurrency is null
23:      *      - otherCurrency.currencyUnit != this.currencyUnit
24:      */
25:     public CurrencyType add( CurrencyType otherCurrency );
26: 
27: 
28:     /**
29:      * @param otherCurrency
30:      * @return this - otherCurrency, as a new object
31:      * @throws ShopException if ...
32:      *      - otherCurrency is null
33:      *      - otherCurrency.currencyUnit != this.currencyUnit
34:      *      - otherCurrency > this
35:      */
36:     public CurrencyType subtract( CurrencyType otherCurrency );
37: 
38: 
39:     /**
40:      * @param factor
41:      * @return this * factor, as a new object
42:      * @throws ShopException if ...
43:      *     - factor < 0
44:      */
45:     public CurrencyType multiplyBy( int factor );
46: 
47:     /**
48:      * @param otherCurrency
49:      * @return true, if this > otherCurrency
50:      * @throws ShopException if ...
51:      *      - otherCurrency is null
52:      *      - otherCurrency.currencyUnit != this.currencyUnit
53:      */
54:     public boolean largerThan( CurrencyType otherCurrency );
55: 
56: 
57:     /**
58:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
59:      * implementing class to provide a static factory method (simply named "of(...)"),
60:      * which creates a currency object from an quantity and a currency unit (as string).
61:      * We specify this factory method here as a comment, using the Javadoc documentation style.
62:      *
63:      * @param quantity the quantity of currency (must be >= 0)
64:      * @param currencyUnit the currency unit of the currency (allowed values: "EUR", "CHF")
65:      * @return a new Currency object with the given quantity and currency unit
66:      * @throws ShopException if ...
67:      *   - quantity is null
68:      *   - quantity < 0
69:      *   - currency unit is null
70:      *   - currency unit is not one of the allowed values
71:      */
72:      // public static CurrencyType of( Float quantity, String currencyUnit );
73: }
74: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MailAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface MailAddressType {
6:     /**
7:      * @return the mail address as a string
8:      */
9:     public String toString();
10: 
11: 
12:     /**
13:      * A special kind of "copy constructor": Returns a new mail address object with
14:      * the same identifyer (the substring left of the "@" sign) as the current one, but
15:      * with a new domain substring (right of the "@" sign).
16:      * @param domainString - the new domain for the copied mail address
17:      * @return the new mail address
18:      * @throws ShopException if ...
19:      *     - domainString is null
20:      *     - the new mail address would not be valid (see `of(...)` method)
21:      */
22:     public MailAddressType sameIdentifyerDifferentDomain( String domainString );
23: 
24:     /**
25:      * Another special kind of "copy constructor": Returns a new mail address object
26:      * with the same domain (the substring right of the "@" sign) as the current one, but
27:      * with a new identifyer substring (left of the "@" sign).
28:      * @param identifyerString - the new identifyer for the copied mail address
29:      * @return the new mail address
30:      * @throws ShopException if ...
31:      *     - identifyerString is null
32:      *     - the new mail address would not be valid (see `of(...)` method)
33:      */
34:     public MailAddressType sameDomainDifferentIdentifyer( String identifyerString );
35: 
36: 
37:     /**
38:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
39:      * implementing class to provide a static factory method (simply named "of(...)"),
40:      * which creates an mail address, given as a string.
41:      * We specify this factory method here as a comment, using the Javadoc documentation style.
42:      *
43:      * @param mailAddressAsString - the mail address as a string.
44:      *      We will use a much simplified validation method to check if the mail address is valid:
45:      *      - it must contain exactly one '@' character.
46:      *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
47:      *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
48:      *      - the substrings before and after the '@' may contain one or several '.' as separators
49:      *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
50:      *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
51:      *        (for simplicity we do not allow any other domains)
52:      * @return a new MailAddressType object matching the given mail address
53:      * @throws ShopException if ...
54:      *      - mailAddressAsString is null
55:      *      - mailAddressAsString is not a valid mail address (see above)
56:      */
57:      // public static MailAddressType of( String mailAddressAsString );
58: }
59: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PhysicalAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface PhysicalAddressType {
6:     /**
7:      * @return the street as a string
8:      */
9:     public String getStreet();
10: 
11:     /**
12:      * @return the city as a string
13:      */
14:     public String getCity();
15: 
16:     /**
17:      * @return the postal code
18:      */
19:     public PostalCodeType getPostalCode();
20: 
21:     /**
22:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
23:      * implementing class to provide a static factory method (simply named "of(...)"),
24:      * which creates an postal code, given as a string.
25:      * We specify this factory method here as a comment, using the Javadoc documentation style.
26:      *
27:      * @param street the street as a string
28:      * @param city the city as a string
29:      * @param postalCode the postal code
30:      * @return the physical address object matching the parameters
31:      * @throws ShopException if ...
32:      *      - street is null or empty
33:      *      - city is null or empty
34:      *      - postalCode is null
35:      */
36:      // public static PhysicalAddressType of( String street, String city, PostalCodeType postalCode );
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PostalCodeType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnore;
4: import thkoeln.archilab.ecommerce.ShopException;
5: 
6: public interface PostalCodeType {
7:     /**
8:      * @return the postal code as a string
9:      */
10:     public String toString();
11: 
12:     /**
13:      * You will need some idea of "imprecise distance" between two postal codes for properly
14:      * implementing fulfillment centers in your shopping platform. This method calculates such a
15:      * distance. You can decide for yourself what values you return, unless you comply
16:      * with the following rules.
17:      * - The return value is 0 if both postal codes are the same
18:      * - If not:
19:      *      - The distance is > 0 if both postal codes differ in the last digit, like 5673x
20:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
21:      *        So, 56733 and 56734 have the same distance as 56733 and 56739.
22:      *      - The distance grows if more digits (counted from the right side) differ.
23:      *        So, 5abcd and 5rstu have a larger distance than 53bcd and 53stu (if abcd
24:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
25:      *        53876 and 54876 have the same distance as 53876 and 57261.
26:      *      - However, the distance between 5abcd and 6rstu must be smaller than the one
27:      *        between 5abcd and 7rstu, and this distance in turn must be smaller than the
28:      *        one between 5abcd and 9rstu.
29:      *      - This last condition reflects the fact the first digits of a postal code marks a region
30:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
31:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
32:      *        other.
33:      * @param otherPostalCode
34:      * @return the calculated distance
35:      * @throws ShopException if otherPostalCode is null
36:      */
37:     public int distance( PostalCodeType otherPostalCode );
38: 
39: 
40:     /**
41:      * For the currently used way of deciding on the best fitting fulfillment center for a purchase,
42:      * we need to know the first digit of the postal code.
43:      */
44:     @JsonIgnore
45:     public Integer getFirstDigitPostalCode();
46: 
47: 
48:     /**
49:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
50:      * implementing class to provide a static factory method (simply named "of(...)"),
51:      * which creates an postal code, given as a string.
52:      * We specify this factory method here as a comment, using the Javadoc documentation style.
53:      *
54:      * @param postalCodeAsString - the postal code as a string.
55:      *      We will use a much simplified validation method to check if the postal code is valid:
56:      *      - It must contain exactly 5 digits.
57:      *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid postal code, but 20001 is valid)
58:      * @return a new postal code object matching the given string
59:      * @throws ShopException if ...
60:      *      - postalCodeAsString is null
61:      *      - postalCodeAsString is not a valid postal code (see above)
62:      */
63:      // public static PostalCodeType of( String postalCodeAsString );
64: }
65: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\FulfillmentCenterUseCases.java ---
1: /*
2:  * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
9: 
10: import java.util.UUID;
11: 
12: /**
13:  * This interface contains methods needed in the context of handling the shop inventory,
14:  * i.e. managing fulfillment centers, and adding / removing products in the fulfillment center.
15:  */
16: public interface FulfillmentCenterUseCases {
17:     /**
18:      *
19:      * @param name
20:      * @param physicalAddress
21:      * @return the id of the new fulfillment center
22:      * @throws ShopException if ...
23:      *      - name is null or empty
24:      *      - physicalAddress is null
25:      */
26:     public UUID addNewFulfillmentCenter( String name, PhysicalAddressType physicalAddress );
27: 
28: 
29:     /**
30:      * Deletes all fulfillment centers from the shop. Intended for testing purposes.
31:      */
32:     public void deleteAllFulfillmentCenters();
33: 
34: 
35:     /**
36:      * Adds a certain Quantity of a given product to the inventory
37:      * @param fulfillmentCenterId
38:      * @param productId
39:      * @param addedQuantityFor
40:      * @throws ShopException if ...
41:      *      - fulfillmentCenterId is null
42:      *      - the fulfillment center with that id does not exist
43:      *      - productId is null
44:      *      - the product with that id does not exist
45:      *      - addedQuantityFor < 0
46:      */
47:     public void addToInventory( UUID fulfillmentCenterId, UUID productId, int addedQuantityFor );
48: 
49: 
50:     /**
51:      * Removes a certain Quantity of a given product from the inventory.
52:      * @param fulfillmentCenterId
53:      * @param productId
54:      * @param removedQuantityFor
55:      * @throws ShopException if ...
56:      *      - fulfillmentCenterId is null
57:      *      - the fulfillment center with that id does not exist
58:      *      - productId is null
59:      *      - the product with that id does not exist
60:      *      - removedQuantityFor < 0
61:      */
62:     public void removeFromInventory( UUID fulfillmentCenterId, UUID productId, int removedQuantityFor );
63: 
64: 
65:     /**
66:      * Changes the total Quantity of a given product in the inventory.
67:      * @param fulfillmentCenterId
68:      * @param productId
69:      * @param newTotalQuantityFor
70:      * @throws ShopException if ...
71:      *      - fulfillmentCenterId is null
72:      *      - the fulfillment center with that id does not exist
73:      *      - productId is null
74:      *      - the product with that id does not exist
75:      *      - newTotalQuantityFor < 0
76:      */
77:     public void changeInventoryTo( UUID fulfillmentCenterId, UUID productId, int newTotalQuantityFor );
78: 
79: 
80:     /**
81:      * Get the current inventory of a given product in one specific fulfillment center.
82:      * @param fulfillmentCenterId
83:      * @param productId
84:      * @return the current total inventory of the product
85:      * @throws ShopException if ...
86:      *      - fulfillmentCenterId is null
87:      *      - the fulfillment center with that id does not exist
88:      *      - productId is null
89:      *      - the product with that id does not exist
90:      */
91:     public int getAvailableInventory( UUID fulfillmentCenterId, UUID productId );
92: 
93: 
94: }
95: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
8: 
9: import java.io.File;
10: import java.io.IOException;
11: import java.lang.reflect.InvocationTargetException;
12: import java.lang.reflect.Method;
13: import java.lang.reflect.Modifier;
14: import java.net.URL;
15: import java.net.URLDecoder;
16: import java.nio.charset.StandardCharsets;
17: import java.util.Enumeration;
18: 
19: import static org.junit.jupiter.api.Assertions.*;
20: 
21: public class FactoryMethodInvoker {
22: 
23:     public static MailAddressType instantiateMailAddress( String mailAddressAsString ) {
24:         Method factoryMethod = null;
25:         try {
26:             Class<?> interfaceClass = Class.forName(
27:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType" );
28:             Class<?> implementingClass = findImplementation( interfaceClass );
29: 
30:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
31:             assertNotNull( factoryMethod );
32:             int modifiers = factoryMethod.getModifiers();
33:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
34:         } catch (Exception e) {
35:             fail( "Failed to find implementation for MailAddressType", e );
36:         }
37: 
38:         Object instance = null;
39:         try {
40:             instance = factoryMethod.invoke( null, mailAddressAsString );
41:         } catch (Exception e) {
42:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
43:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
44:             fail( "Failed to invoke factory method 'of' for '" + mailAddressAsString + "'", e );
45:         }
46:         assertNotNull( instance );
47:         return (MailAddressType) instance;
48:     }
49: 
50: 
51:     public static PhysicalAddressType instantiatePhysicalAddress(
52:             String street, String city, PostalCodeType postalCode ) {
53:         Method factoryMethod = null;
54:         try {
55:             Class<?> interfaceClass = Class.forName(
56:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType" );
57:             Class<?> implementingClass = findImplementation( interfaceClass );
58: 
59:             factoryMethod = implementingClass.getDeclaredMethod( "of",
60:                     String.class, String.class, PostalCodeType.class );
61:             assertNotNull( factoryMethod );
62:             int modifiers = factoryMethod.getModifiers();
63:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
64:         } catch (Exception e) {
65:             fail( "Failed to find implementation for PhysicalAddressType", e );
66:         }
67: 
68:         Object instance = null;
69:         try {
70:             instance = factoryMethod.invoke( null, street, city, postalCode );
71:         } catch (Exception e) {
72:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
73:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
74:             fail( "Failed to invoke factory method 'of' for '" +
75:                     street + "', '" + city + "', '" + postalCode + "'", e );
76:         }
77:         assertNotNull( instance );
78:         return (PhysicalAddressType) instance;
79:     }
80: 
81: 
82:     public static PostalCodeType instantiatePostalCode( String postalCodeAsString ) {
83:         Method factoryMethod = null;
84:         try {
85:             Class<?> interfaceClass = Class.forName(
86:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType" );
87:             Class<?> implementingClass = findImplementation( interfaceClass );
88: 
89:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
90:             assertNotNull( factoryMethod );
91:             int modifiers = factoryMethod.getModifiers();
92:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
93:         } catch (Exception e) {
94:             fail( "Failed to find implementation for PostalCodeType", e );
95:         }
96: 
97:         Object instance = null;
98:         try {
99:             instance = factoryMethod.invoke( null, postalCodeAsString );
100:         } catch (Exception e) {
101:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
102:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
103:             fail( "Failed to invoke factory method 'of' for '" + postalCodeAsString + "'", e );
104:         }
105:         assertNotNull( instance );
106:         return (PostalCodeType) instance;
107:     }
108: 
109: 
110:     public static CurrencyType instantiateCurrency( Float quantity, String currencyUnit ) {
111:         Method factoryMethod = null;
112:         try {
113:             Class<?> interfaceClass = Class.forName(
114:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType" );
115:             Class<?> implementingClass = findImplementation( interfaceClass );
116: 
117:             factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
118:             assertNotNull( factoryMethod );
119:             int modifiers = factoryMethod.getModifiers();
120:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
121:         } catch (Exception e) {
122:             fail( "Failed to find implementation for CurrencyType", e );
123:         }
124: 
125:         Object instance = null;
126:         try {
127:             instance = factoryMethod.invoke( null, quantity, currencyUnit );
128:         } catch (Exception e) {
129:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
130:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
131:             fail( "Failed to invoke factory method 'of' for '" + quantity + "', '" + currencyUnit + "'", e );
132:         }
133:         assertNotNull( instance );
134:         return (CurrencyType) instance;
135:     }
136: 
137: 
138:     private static Class<?> findImplementation( Class<?> interfaceClass ) {
139:         Method factoryMethod = null;
140:         try {
141:             String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
142:             Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
143:             assertNotNull( implementingClass );
144:             return implementingClass;
145:         } catch (Exception e) {
146:             fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
147:             return null; // This line will never be reached, but it's necessary to satisfy the compiler
148:         }
149:     }
150: 
151: 
152:     private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
153:             throws ClassNotFoundException, IOException {
154:         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
155:         String path = packageName.replace( '.', '/' );
156:         Enumeration<URL> resources = classLoader.getResources( path );
157:         int count = 0;
158:         Class<?> result = null;
159:         while (resources.hasMoreElements()) {
160:             URL resource = resources.nextElement();
161:             File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
162:             File[] files = directory.listFiles();
163:             for ( File file : files ) {
164:                 if ( file.getName().endsWith( ".class" ) ) {
165:                     String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
166:                     Class<?> clazz = Class.forName( className );
167:                     if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
168:                         count++;
169:                         result = clazz;
170:                     }
171:                 }
172:             }
173:         }
174:         assertEquals( 1, count, "There should be exactly one implementing class" );
175:         return result;
176:     }
177: }
178: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FulfillmentCenterTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import java.util.UUID;
4: 
5: public interface FulfillmentCenterTestHelper {
6:     /**
7:      * Adds the test fulfillment centers to the system.
8:      * If you want to use the fulfillment centers, or want to know which index the fulfillment center has that you see
9:      * in the debugger, the following rules apply:
10:      * - The fulfillment center name will equal the street name of the physical address of the fulfillment center.
11:      * - The index number is visible in the house number. Example: fulfillment center 3 is located at
12:      *   "Ablageweg 3", and that is also its name.
13:      *
14:      *  The fulfillment centers are used in the tests as follows:
15:      *  - fulfillment center 0 holds all products 0 - 6, and is used for all tests where it is not relevant
16:      *    to split one shopping basket into several purchases.
17:      *  - fulfillment centers 1 - 3 are used for the proximity tests, where you can deliver product 7 to
18:      *    to a user from the closest fulfillment center.
19:      *  - fulfillment centers 4 - 8 are used for the tests where you need to deliver products 8 - 14 in
20:      *    the most cost-efficient way, as multiple shipments.
21:      *  - fulfillment center 9 is empty.
22:      *
23:      *  If withInventory is true, then the fulfillment centers are filled with products. This happens
24:      *  according to the following rules:
25:      *  - products 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
26:      *    ONLY available in fulfillment center 0. (This means that product 0 out of inventory everywhere.)
27:      *  - products 4, 5, 6 have a random inventory between 30 and 130, also all ONLY in fulfillment center 0
28:           (these are the products used for tests on how to add and remove inventory)
29:      *  - product 7 has a random inventory between 30 and 130, distributed over
30:      *    fulfillment centers 1, 2, and 3. You can use this to test if the appropriate fulfillment center is found
31:      *    for a shopping basket with only product 7 in it, but with different quantities (<= 3, or > 3).
32:      *  - The other products (8 - 14) have also a random inventory between 30 and 130, all distributed
33:      *    over several fulfillment centers. The distribution is done as follows:
34:      *    Assume that the product is available in <n> fulfillment centers. Then the first <n-1> fulfillment centers
35:      *    in the list (in ascending sequence) contain 3, and all the remaining inventory is in the
36:      *    last fulfillment center.
37:      *
38:      *    This is how the inventory of products could be distributed
39:      *    (Wx = fulfillment center x with its postal code, Px = product x,
40:      *    numbers marked with (*) are random large numbers):
41:      *
42:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
43:      *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
44:      *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
45:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
46:      *    | P0   |      |     |     |      |     |      |     |       |      |     |
47:      *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
48:      *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
49:      *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
50:      *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
51:      *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
52:      *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
53:      *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
54:      *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
55:      *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
56:      *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
57:      *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
58:      *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
59:      *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
60:      *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
61:      *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
62:      *
63:      * @param withInventory if true, the inventory of the products is added to the fulfillment center. Otherwise, the
64:      *                           the inventory is not added and the fulfillment center is empty.
65:      */
66:     public void addAllFulfillmentCenters( boolean withInventory );
67: 
68: 
69:     /**
70:      * @return the number of test fulfillment centers in the database
71:      */
72:     int numberOfFulfillmentCenters();
73: 
74: 
75:     /**
76:      * @param index
77:      * @return the id of the test fulfillment center at the given index
78:      */
79:     UUID getFulfillmentCenterId( int index );
80: 
81: 
82:     /**
83:      * @param fulfillmentCenterId - the id of the fulfillment center in the test data
84:      * @return the index of the test fulfillment center with that id
85:      */
86:     int findFulfillmentCenterIndex( UUID fulfillmentCenterId );
87: 
88: 
89:     /**
90:      * @param productIndex - the index of the product in the test data
91:      * @param fulfillmentCenterIndex - the index of the fulfillment center in the test data
92:      * @return the number of products (inventory) available in the fulfillment center at the given index
93:      */
94:     Integer getFulfillmentCenterInventory( int fulfillmentCenterIndex, int productIndex );
95: 
96: }
97: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\InventoryTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
7: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
8: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
12: 
13: import java.util.*;
14: 
15: /**
16:  * This is a test helper class that initializes and registers products (but without inventory)
17:  * in the system, using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class InventoryTestHelperImpl
22:                         implements ProductTestHelper, FulfillmentCenterTestHelper {
23:     private ProductCatalogUseCases productCatalogUseCases;
24:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
25:     private static Random random = new Random();
26: 
27:     private static final String EUR = "EUR";
28:     private static final int PRODUCT_NUMOF = 15;
29:     private static final Object[][] PRODUCT_DATA = new Object[][]{
30:             {null, "0-TCD-34 v2.1", "Universelles Verbindungsst√ºck f√ºr den einfachen Hausgebrauch bei der Schnellmontage",
31:                     1.5f, FactoryMethodInvoker.instantiateCurrency( 5.0f, EUR ),
32:                     FactoryMethodInvoker.instantiateCurrency( 10.0f, EUR ),
33:                     "0"},
34:             {null, "1-EFG-56", "Hochleistungsf√§higer Kondensator f√ºr elektronische Schaltungen",
35:                     0.3f, FactoryMethodInvoker.instantiateCurrency( 2.5f, EUR ),
36:                     FactoryMethodInvoker.instantiateCurrency( 4.0f, EUR ),
37:                     "0"},
38:             {null, "2-MNP-89ff", "Langlebiger und robuster Motor f√ºr industrielle Anwendungen",
39:                     7.2f, FactoryMethodInvoker.instantiateCurrency( 50.0f, EUR ),
40:                     FactoryMethodInvoker.instantiateCurrency( 80.0f, EUR ),
41:                     "0"},
42:             {null, "3-Gh-25", "Kompakter und leichter Akku f√ºr mobile Ger√§te",
43:                     null, FactoryMethodInvoker.instantiateCurrency( 6.0f, EUR ),
44:                     FactoryMethodInvoker.instantiateCurrency( 8.0f, EUR ),
45:                     "0"},
46:             {null, "4-MultiBeast2", "Vielseitiger Adapter f√ºr verschiedene Steckertypen",
47:                     null, FactoryMethodInvoker.instantiateCurrency( 0.6f, EUR ),
48:                     FactoryMethodInvoker.instantiateCurrency( 1.0f, EUR ),
49:                     "0"},
50:             {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor f√ºr Computer und Server",
51:                     1.0f, FactoryMethodInvoker.instantiateCurrency( 150.0f, EUR ),
52:                     FactoryMethodInvoker.instantiateCurrency( 250.0f, EUR ),
53:                     "0"},
54:             {null, "6-Stuko22", "Ersatzteil Spitze f√ºr Pr√§zisionswerkzeug zum L√∂ten und Schrauben",
55:                     null, FactoryMethodInvoker.instantiateCurrency( 0.3f, EUR ),
56:                     FactoryMethodInvoker.instantiateCurrency( 0.5f, EUR ),
57:                     "0"},
58:             {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
59:                     6.0f, FactoryMethodInvoker.instantiateCurrency( 80.0f, EUR ),
60:                     FactoryMethodInvoker.instantiateCurrency( 120.0f, EUR ),
61:                     "123"},
62:             {null, "8-JKL-67", "Wasserdichtes Geh√§use",
63:                     3.0f, FactoryMethodInvoker.instantiateCurrency( 1.0f, EUR ),
64:                     FactoryMethodInvoker.instantiateCurrency( 1.2f, EUR ),
65:                     "467"},
66:             {null, "9-MNO-55-33", "Modulares Netzteil f√ºr flexible Stromversorgung",
67:                     5.5f, FactoryMethodInvoker.instantiateCurrency( 25.0f, EUR ),
68:                     FactoryMethodInvoker.instantiateCurrency( 45.0f, EUR ),
69:                     "578"},
70:             {null, "10-PQR-80", "Effizienter K√ºhler f√ºr verbesserte W√§rmeableitung",
71:                     4.0f, FactoryMethodInvoker.instantiateCurrency( 20.0f, EUR ),
72:                     FactoryMethodInvoker.instantiateCurrency( 35.0f, EUR ),
73:                     "567"},
74:             {null, "11-STU-11 Ld", "Hochwertiger Grafikchip f√ºr leistungsstarke PCs",
75:                     null, FactoryMethodInvoker.instantiateCurrency( 200.0f, EUR ),
76:                     FactoryMethodInvoker.instantiateCurrency( 350.0f, EUR ),
77:                     "478"},
78:             {null, "12-VWX-90 FastWupps", "Schnellladeger√§t f√ºr eine Vielzahl von Ger√§ten",
79:                     null, FactoryMethodInvoker.instantiateCurrency( 15.0f, EUR ),
80:                     FactoryMethodInvoker.instantiateCurrency( 25.0f, EUR ),
81:                     "5"},
82:             {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
83:                     3.5f, FactoryMethodInvoker.instantiateCurrency( 60.0f, EUR ),
84:                     FactoryMethodInvoker.instantiateCurrency( 100.0f, EUR ),
85:                     "78"},
86:             {null, "14-Nosedive", "Klammer zum Verschlie√üen der Nase beim Tauchen",
87:                     5.0f, FactoryMethodInvoker.instantiateCurrency( 2.0f, EUR ),
88:                     FactoryMethodInvoker.instantiateCurrency( 5.0f, EUR ),
89:                     "457"}
90:     };
91:     
92: 
93:     // These physical addresss are used for the fulfillment centers. The fulfillment center name will equal
94:     // the postal code of the site. Their index number will be visible in the house number.
95:     // The fulfillment centers are used as such:
96:     // - fulfillment center 0 is holds all products 0 - 6, and is used for all tests where multiple
97:     //   shipments are irrelevant.
98:     // - fulfillment centers 1 - 3 are used for the proximity tests, where you can deliver products 7 to
99:     //   to a user from the closest fulfillment center.
100:     // - fulfillment centers 4 - 8 are used for the tests where you need to deliver products 8 - 14 in
101:     //   the most cost-efficient way, as multiple shipments.
102:     // - fulfillment center 9 is empty.
103:     private final static int FULFILLMENT_CENTER_NUMOF = 10;
104:     private final static PhysicalAddressType[] FULFILLMENT_CENTER_PHYSICAL_ADDRESS = new PhysicalAddressType[]{
105:             FactoryMethodInvoker.instantiatePhysicalAddress(
106:                     "Stapelallee 0", "Potsdam",
107:                     FactoryMethodInvoker.instantiatePostalCode( "14476" ) ),
108:             FactoryMethodInvoker.instantiatePhysicalAddress(
109:                     "Lagerhausstr. 1", "Viertelstadt",
110:                     FactoryMethodInvoker.instantiatePostalCode( "02345" ) ),
111:             FactoryMethodInvoker.instantiatePhysicalAddress(
112:                     "Speicherplatz 2", "Viertelstadt",
113:                     FactoryMethodInvoker.instantiatePostalCode( "02313" ) ),
114:             FactoryMethodInvoker.instantiatePhysicalAddress(
115:                     "Ablageweg 3", "Reichsw√ºrgen",
116:                     FactoryMethodInvoker.instantiatePostalCode( "44923" ) ),
117:             FactoryMethodInvoker.instantiatePhysicalAddress(
118:                     "Paketstellenallee 4", "D√ºsseldorf",
119:                     FactoryMethodInvoker.instantiatePostalCode( "40588" ) ),
120:             FactoryMethodInvoker.instantiatePhysicalAddress(
121:                     "Kaputte-Sachen-Stra√üe 5", "D√ºren",
122:                     FactoryMethodInvoker.instantiatePostalCode( "52355" ) ),
123:             FactoryMethodInvoker.instantiatePhysicalAddress(
124:                     "Aufbewahrungsweg 6", "Viernheim",
125:                     FactoryMethodInvoker.instantiatePostalCode( "68519" ) ),
126:             FactoryMethodInvoker.instantiatePhysicalAddress(
127:                     "Paketallee 7", "Baden-Baden",
128:                     FactoryMethodInvoker.instantiatePostalCode( "76532" ) ),
129:             FactoryMethodInvoker.instantiatePhysicalAddress(
130:                     "Sendenstr. 8", "Senden",
131:                     FactoryMethodInvoker.instantiatePostalCode( "89250" ) ),
132:             FactoryMethodInvoker.instantiatePhysicalAddress(
133:                     "Schickweg 9", "Hohenroth",
134:                     FactoryMethodInvoker.instantiatePostalCode( "97618" ) )
135:     };
136:     private final static UUID[] FULFILLMENT_CENTER_ID = new UUID[FULFILLMENT_CENTER_NUMOF];
137: 
138: 
139:     // These data structures contain the inventory of the products in the fulfillment centers.
140:     // PRODUCT_INVENTORY is a map product name -> Integer[FULFILLMENT_CENTER_NUMOF].
141:     // The Integer[FULFILLMENT_CENTER_NUMOF] contains the inventory of the product in each of
142:     // the fulfillment centers.
143:     //
144:     // The following rules apply:
145:     // - product 0 is out of inventory
146:     // - product 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in fulfillment center 0
147:     // - product 4 / 5 / 6 have a random inventory between 30 and 130, also all ONLY in fulfillment center 0
148:     //   (these are the products used for tests on how to add and remove inventory)
149:     // - the others have a random inventory between 30 and 130, distributed over several
150:     //   fulfillment centers. Here we follow this convention for simplicity:
151:     //   - Assume that the product is available in <n> fulfillment centers. Then the first <n-1> fulfillment centers
152:     //     in the list (in ascending sequence) contain 3, and all the remaining inventory is in the
153:     //     last fulfillment center.
154: 
155:     private static final Map<String, Integer[]> PRODUCT_INVENTORY = new HashMap<>();
156: 
157:     static {
158:         // products 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
159:         PRODUCT_INVENTORY.put( (String) PRODUCT_DATA[0][1],
160:                 getInventoryDistribution( 0, (String) PRODUCT_DATA[0][6] ) );
161:         PRODUCT_INVENTORY.put( (String) PRODUCT_DATA[1][1],
162:                 getInventoryDistribution( 10, (String) PRODUCT_DATA[1][6] ) );
163:         PRODUCT_INVENTORY.put( (String) PRODUCT_DATA[2][1],
164:                 getInventoryDistribution( 20, (String) PRODUCT_DATA[2][6] ) );
165:         PRODUCT_INVENTORY.put( (String) PRODUCT_DATA[3][1],
166:                 getInventoryDistribution( 30, (String) PRODUCT_DATA[3][6] ) );
167: 
168:         // The other products have a random inventory between 30 and 130,
169:         for ( int i = 4; i < PRODUCT_NUMOF; i++ ) {
170:             Integer totalNumber = random.nextInt( 100 ) + 30;
171:             Integer[] inventoryInFulfillmentCenters =
172:                     getInventoryDistribution( totalNumber, (String) PRODUCT_DATA[i][6] );
173:             PRODUCT_INVENTORY.put( (String) PRODUCT_DATA[i][1], inventoryInFulfillmentCenters );
174:         }
175:     }
176: 
177:     /**
178:      * This method creates a random inventory distribution for the given product.
179:      *
180:      * @param totalQuantity - the total number of products in the fulfillment centers
181:      * @param zeroToNine  - a string with numbers between 0 and 9, representing the fulfillment centers
182:      * @return an Integer array with the inventory distribution for the product, according to
183:      * the rules described above.
184:      */
185:     private static Integer[] getInventoryDistribution( Integer totalQuantity, String zeroToNine ) {
186:         Integer[] inventoryInFulfillmentCenters = new Integer[FULFILLMENT_CENTER_NUMOF];
187:         for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) inventoryInFulfillmentCenters[i] = 0;
188:         TreeSet<Integer> fulfillmentCenterIndices = getFulfillmentCenterIndices( zeroToNine );
189:         int numOfIndices = fulfillmentCenterIndices.size();
190:         int currentIndexNumber = 0;
191:         int currentQuantity = totalQuantity;
192:         for ( Integer fulfillmentCenterIndex : fulfillmentCenterIndices ) {
193:             currentIndexNumber++;
194:             if ( currentIndexNumber < numOfIndices ) {
195:                 inventoryInFulfillmentCenters[fulfillmentCenterIndex] = 3;
196:                 currentQuantity -= 3;
197:             } else {
198:                 inventoryInFulfillmentCenters[fulfillmentCenterIndex] = currentQuantity;
199:             }
200:         }
201:         return inventoryInFulfillmentCenters;
202:     }
203: 
204:     private static TreeSet<Integer> getFulfillmentCenterIndices( String zeroToNine ) {
205:         TreeSet<Integer> fulfillmentCenterIndices = new TreeSet<>();
206:         for ( int i = 0; i < zeroToNine.length(); i++ ) {
207:             fulfillmentCenterIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
208:         }
209:         return fulfillmentCenterIndices;
210:     }
211: 
212: 
213:     @Autowired
214:     public InventoryTestHelperImpl( ProductCatalogUseCases productCatalogUseCases,
215:                                          FulfillmentCenterUseCases fulfillmentCenterUseCases ) {
216:         this.productCatalogUseCases = productCatalogUseCases;
217:         this.fulfillmentCenterUseCases = fulfillmentCenterUseCases;
218:     }
219: 
220: 
221:     @Override
222:     public void addAllProducts() {
223:         int i = 0;
224:         for ( Object[] productData : PRODUCT_DATA ) {
225:             UUID newId = productCatalogUseCases.addProductToCatalog(
226:                     (String) productData[1], (String) productData[2],
227:                     (Float) productData[3], (CurrencyType) productData[4],
228:                     (CurrencyType) productData[5] );
229:             // The first element of the product data is the id, which was initialized with null before, but can now be set
230:             PRODUCT_DATA[i][0] = newId;
231:             i++;
232:         }
233:     }
234: 
235: 
236:     @Override
237:     public int numberOfProducts() {
238:         return PRODUCT_NUMOF;
239:     }
240: 
241: 
242:     @Override
243:     public UUID getProductId( int index ) {
244:         if ( index < 0 || index >= PRODUCT_NUMOF ) {
245:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
246:         }
247:         return (UUID) PRODUCT_DATA[index][0];
248:     }
249: 
250: 
251:     @Override
252:     public CurrencyType getBuyingPrice( int index ) {
253:         if ( index < 0 || index >= PRODUCT_NUMOF ) {
254:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
255:         }
256:         return (CurrencyType) PRODUCT_DATA[index][4];
257:     }
258: 
259: 
260:     @Override
261:     public CurrencyType getSalesPrice( int index ) {
262:         if ( index < 0 || index >= PRODUCT_NUMOF ) {
263:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
264:         }
265:         return (CurrencyType) PRODUCT_DATA[index][5];
266:     }
267: 
268: 
269:     @Override
270:     public void addAllFulfillmentCenters( boolean withInventory ) {
271:         for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) {
272:             FULFILLMENT_CENTER_ID[i] = fulfillmentCenterUseCases.addNewFulfillmentCenter(
273:                     FULFILLMENT_CENTER_PHYSICAL_ADDRESS[i].getStreet(),
274:                     FULFILLMENT_CENTER_PHYSICAL_ADDRESS[i] );
275:         }
276:         if ( withInventory ) {
277:             addAllInventory();
278:         }
279:     }
280: 
281: 
282:     private void addAllInventory() {
283:         for ( Object[] productData : PRODUCT_DATA ) {
284:             Integer[] inventoryInFulfillmentCenters =
285:                     PRODUCT_INVENTORY.get( productData[1] );
286:             for ( int iFulfillmentCenter = 0; iFulfillmentCenter < FULFILLMENT_CENTER_NUMOF; iFulfillmentCenter++ ) {
287:                 if ( inventoryInFulfillmentCenters[iFulfillmentCenter] > 0 )
288:                     fulfillmentCenterUseCases.addToInventory(
289:                             FULFILLMENT_CENTER_ID[iFulfillmentCenter], (UUID) productData[0],
290:                             inventoryInFulfillmentCenters[iFulfillmentCenter] );
291:             }
292:         }
293:     }
294: 
295: 
296:     @Override
297:     public int numberOfFulfillmentCenters() {
298:         return FULFILLMENT_CENTER_NUMOF;
299:     }
300: 
301: 
302:     @Override
303:     public UUID getFulfillmentCenterId( int index ) {
304:         if ( index < 0 || index >= FULFILLMENT_CENTER_NUMOF ) {
305:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
306:         }
307:         return FULFILLMENT_CENTER_ID[index];
308:     }
309: 
310: 
311:     @Override
312:     public Integer getFulfillmentCenterInventory( int fulfillmentCenterIndex, int productIndex ) {
313:         if ( fulfillmentCenterIndex < 0 || fulfillmentCenterIndex >= FULFILLMENT_CENTER_NUMOF ) {
314:             throw new IndexOutOfBoundsException( "Index out of bounds: " + fulfillmentCenterIndex );
315:         }
316:         if ( productIndex < 0 || productIndex >= PRODUCT_NUMOF ) {
317:             throw new IndexOutOfBoundsException( "Index out of bounds: " + productIndex );
318:         }
319:         String productName = (String) PRODUCT_DATA[productIndex][1];
320:         Integer[] inventoryInFulfillmentCenters = PRODUCT_INVENTORY.get( productName );
321:         Integer foundInventory = inventoryInFulfillmentCenters[fulfillmentCenterIndex];
322:         return foundInventory == null ? 0 : foundInventory;
323:     }
324: 
325: 
326:     @Override
327:     public int findFulfillmentCenterIndex( UUID fulfillmentCenterId ) {
328:         for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) {
329:             if ( FULFILLMENT_CENTER_ID[i].equals( fulfillmentCenterId ) ) {
330:                 return i;
331:             }
332:         }
333:         throw new IllegalArgumentException( "No test fulfillment center with UUID id " + fulfillmentCenterId );
334:     }
335: 
336: 
337:     @Override
338:     public int findProductIndex( UUID productId ) {
339:         for ( int iProductData = 0; iProductData < FULFILLMENT_CENTER_NUMOF; iProductData++ ) {
340:             Object[] productData = PRODUCT_DATA[iProductData];
341:             if ( productData[0].equals( productId ) ) {
342:                 return iProductData;
343:             }
344:         }
345:         throw new IllegalArgumentException( "No test product with UUID id " + productId );
346:     }
347: }
348: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\UserTestHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata.impl;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Component;
5: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
6: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
7: import thkoeln.archilab.ecommerce.usecases.UserType;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.MockUser;
12: 
13: import static org.junit.jupiter.api.Assertions.assertThrows;
14: 
15: /**
16:  * This is a test helper class that initializes and registers users in the system,
17:  * using the given interface(s).
18:  */
19: @Component
20: @SuppressWarnings("PMD")
21: public class UserTestHelperImpl implements UserTestHelper {
22: 
23:     private UserRegistrationUseCases userRegistrationUseCases;
24: 
25:     @Autowired
26:     public UserTestHelperImpl( UserRegistrationUseCases userRegistrationUseCases ) {
27:         this.userRegistrationUseCases = userRegistrationUseCases;
28:     }
29: 
30:     private final static String[] USER_NAME = new String[]{
31:             "Max Mueller",
32:             "Sophie Schmitz",
33:             "Irene Mihalic",
34:             "Emilia Fischer",
35:             "Filiz Polat",
36:             "Lina Wagner",
37:             "Leon Becker",
38:             "Agnieszka Kalterer",
39:             "Felix Bauer",
40:             "Lara Schulz"
41:     };
42: 
43:     private final static MailAddressType[] USER_EMAIL = new MailAddressType[]{
44:             FactoryMethodInvoker.instantiateMailAddress( "99Z@example.com" ),
45:             FactoryMethodInvoker.instantiateMailAddress( "a@4.com" ),
46:             FactoryMethodInvoker.instantiateMailAddress( "irene@wearefreedomnow.com" ),
47:             FactoryMethodInvoker.instantiateMailAddress( "emilia.fischer@example.com" ),
48:             FactoryMethodInvoker.instantiateMailAddress( "j877d3@example.this.com" ),
49:             FactoryMethodInvoker.instantiateMailAddress( "lina.marie.wagner@example.com" ),
50:             FactoryMethodInvoker.instantiateMailAddress( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
51:             FactoryMethodInvoker.instantiateMailAddress( "agna@here.ch" ),
52:             FactoryMethodInvoker.instantiateMailAddress( "felix.bauer@example.org" ),
53:             FactoryMethodInvoker.instantiateMailAddress( "lara.schulz@example.at" )
54:     };
55: 
56:     // The following array is used to create a list of physicalAddresss for the users.
57:     // The indices are coded into the house number.
58:     // - Persons 0 - 5 are used for proximity tests with one fulfillment center.
59:     private final static PhysicalAddressType[] USER_ADDRESS = new PhysicalAddressType[]{
60:             FactoryMethodInvoker.instantiatePhysicalAddress(
61:                     "Marktstra√üe 0", "Viertelstadt",
62:                     FactoryMethodInvoker.instantiatePostalCode( "02314" ) ),
63:             FactoryMethodInvoker.instantiatePhysicalAddress(
64:                     "Hauptstra√üe 1", "Viertelstadt",
65:                     FactoryMethodInvoker.instantiatePostalCode( "02368" ) ),
66:             FactoryMethodInvoker.instantiatePhysicalAddress(
67:                     "Kirchplatz 2", "Niemandstown",
68:                     FactoryMethodInvoker.instantiatePostalCode( "12345" ) ),
69:             FactoryMethodInvoker.instantiatePhysicalAddress(
70:                     "Schulstra√üe 3", "Geisterhausen",
71:                     FactoryMethodInvoker.instantiatePostalCode( "31463" ) ),
72:             FactoryMethodInvoker.instantiatePhysicalAddress(
73:                     "Rosenweg 4", "Kuhhausen",
74:                     FactoryMethodInvoker.instantiatePostalCode( "72162" ) ),
75:             FactoryMethodInvoker.instantiatePhysicalAddress(
76:                     "Wiesenstra√üe 5", "Waldschenkensdorf",
77:                     FactoryMethodInvoker.instantiatePostalCode( "82195" ) ),
78:             FactoryMethodInvoker.instantiatePhysicalAddress(
79:                     "Muehlenweg 6", "Koeln",
80:                     FactoryMethodInvoker.instantiatePostalCode( "50667" ) ),
81:             FactoryMethodInvoker.instantiatePhysicalAddress(
82:                     "Goethestra√üe 7", "Frankfurt am Main",
83:                     FactoryMethodInvoker.instantiatePostalCode( "60311" ) ),
84:             FactoryMethodInvoker.instantiatePhysicalAddress(
85:                     "Dorfstra√üe 8", "Stuttgart",
86:                     FactoryMethodInvoker.instantiatePostalCode( "70173" ) ),
87:             FactoryMethodInvoker.instantiatePhysicalAddress(
88:                     "Bahnhofstra√üe 9", "Muenchen",
89:                     FactoryMethodInvoker.instantiatePostalCode( "80331" ) )
90:     };
91: 
92:     private final static UserType[] mockUsers;
93: 
94:     static {
95:         mockUsers = new UserType[USER_NAME.length];
96:         for ( int i = 0; i < USER_NAME.length; i++ ) {
97:             mockUsers[i] = new MockUser(
98:                     USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
99:         }
100:     }
101: 
102: 
103:     @Override
104:     public void registerAllUsers() {
105:         for ( int i = 0; i < USER_NAME.length; i++ ) {
106:             registerUser( USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
107:         }
108:     }
109: 
110: 
111:     private void registerUser( String name, MailAddressType mailAddress, PhysicalAddressType physicalAddress ) {
112:         userRegistrationUseCases.register( name, mailAddress, physicalAddress );
113:     }
114: 
115: 
116:     @Override
117:     public int getNumberOfUsers() {
118:         return USER_NAME.length;
119:     }
120: 
121: 
122:     @Override
123:     public String getUserName( int index ) {
124:         if ( index < 0 || index >= USER_NAME.length ) {
125:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
126:         }
127:         return USER_NAME[index];
128:     }
129: 
130: 
131:     @Override
132:     public MailAddressType getUserMailAddress( int index ) {
133:         if ( index < 0 || index >= USER_NAME.length ) {
134:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
135:         }
136:         return USER_EMAIL[index];
137:     }
138: 
139: 
140:     @Override
141:     public PhysicalAddressType getUserPhysicalAddress( int index ) {
142:         if ( index < 0 || index >= USER_NAME.length ) {
143:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
144:         }
145:         return USER_ADDRESS[index];
146:     }
147: 
148: 
149:     @Override
150:     public UserType getUser( int index ) {
151:         if ( index < 0 || index >= USER_NAME.length ) {
152:             throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
153:         }
154:         return mockUsers[index];
155:     }
156: }
157: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockUser.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.Setter;
4: import thkoeln.archilab.ecommerce.usecases.UserType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;
6: 
7: 
8: import java.util.Objects;
9: 
10: @Setter
11: public class MockUser implements UserType {
12:     private String name;
13:     private MailAddressType mailAddressType;
14:     private PhysicalAddressType physicalAddressType;
15: 
16: 
17:     public MockUser( String name, MailAddressType mailAddressType, PhysicalAddressType physicalAddressType) {
18:         this.name = name;
19:         this.mailAddressType = mailAddressType;
20:         this.physicalAddressType = physicalAddressType;
21:     }
22: 
23:     @Override
24:     public String getName() {
25:         return name;
26:     }
27: 
28:     @Override
29:     public MailAddressType getMailAddress() {
30:         return mailAddressType;
31:     }
32: 
33:     @Override
34:     public PhysicalAddressType getPhysicalAddress() {
35:         return physicalAddressType;
36:     }
37: 
38:     @Override
39:     public boolean equals( Object o ) {
40:         if ( this == o ) return true;
41:         if ( !( o instanceof MockUser ) ) return false;
42:         MockUser that = (MockUser) o;
43:         return Objects.equals( getName(), that.getName() ) &&
44:                 Objects.equals( mailAddressType, that.mailAddressType ) &&
45:                 Objects.equals( physicalAddressType, that.physicalAddressType );
46:     }
47: 
48:     @Override
49:     public int hashCode() {
50:         return Objects.hash( getName(), mailAddressType, physicalAddressType );
51:     }
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\ProductTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
4: 
5: import java.util.UUID;
6: 
7: public interface ProductTestHelper {
8:     /**
9:      * Adds all test products to the database.
10:      * If you use the debugger and want to identify _which_ test product you currently look at:
11:      * The indices are coded into the first number in the name string of the product, like e.g.
12:      * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
13:      */
14:     void addAllProducts();
15: 
16: 
17:     /**
18:      * @return the number of test products in the database
19:      */
20:     int numberOfProducts();
21: 
22: 
23:     /**
24:      * @param index
25:      * @return the id of the test product at the given index
26:      */
27:     UUID getProductId( int index );
28: 
29: 
30:     /**
31:      * @param productId - the id of the product in the test data
32:      * @return the index of the test product with that id
33:      */
34:     int findProductIndex( UUID productId );
35: 
36: 
37:     /**
38:      * @param index
39:      * @return the buying price of test product at the given index
40:      */
41:     CurrencyType getBuyingPrice( int index );
42: 
43: 
44:     /**
45:      * @param index
46:      * @return the sales price of test product at the given index
47:      */
48:     CurrencyType getSalesPrice( int index );
49: }
50: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.usecases.*;
6: 
7: /**
8:  * Removes everything :-)
9:  */
10: @Service
11: public class Purgatory {
12:     @Autowired
13:     private UserRegistrationUseCases userRegistrationUseCases;
14:     @Autowired
15:     private ShoppingBasketUseCases shoppingBasketUseCases;
16:     @Autowired
17:     private PurchaseUseCases purchaseUseCases;
18:     @Autowired
19:     private ProductCatalogUseCases productCatalogUseCases;
20:     @Autowired
21:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
22: 
23:     public void deleteEverything() {
24:         purchaseUseCases.deleteAllPurchases();
25:         shoppingBasketUseCases.emptyAllShoppingBaskets();
26:         fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
27:         userRegistrationUseCases.deleteAllUsers();
28:         productCatalogUseCases.deleteProductCatalog();
29:     }
30: }
31: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.context.ApplicationListener;
6: import org.springframework.context.annotation.Profile;
7: import org.springframework.context.event.ContextRefreshedEvent;
8: import org.springframework.stereotype.Component;
9: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
12: 
13: @Component
14: @Slf4j
15: @Profile("!test")
16: @SuppressWarnings("PMD")
17: public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
18:     private Purgatory purgatory;
19:     private UserTestHelper userTestHelper;
20:     private ProductTestHelper productTestHelper;
21:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
22: 
23: 
24:     @Autowired
25:     public StartupListener( Purgatory purgatory,
26:                             UserTestHelper userTestHelper,
27:                             ProductTestHelper productTestHelper,
28:                             FulfillmentCenterTestHelper fulfillmentCenterTestHelper ) {
29:         this.purgatory = purgatory;
30:         this.userTestHelper = userTestHelper;
31:         this.productTestHelper = productTestHelper;
32:         this.fulfillmentCenterTestHelper = fulfillmentCenterTestHelper;
33:     }
34: 
35:     @Override
36:     public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
37:         log.info( "StartupListener initializing master data ..." );
38:         purgatory.deleteEverything();
39:         userTestHelper.registerAllUsers();
40:         productTestHelper.addAllProducts();
41:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
42:     }
43: }
44: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\UserTestHelper.java ---
1: package thkoeln.archilab.ecommerce.usecases.masterdata;
2: 
3: 
4: import thkoeln.archilab.ecommerce.usecases.UserType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
7: 
8: /**
9:  * This is a test helper interface provides access to predefined test data for
10:  * users.
11:  */
12: public interface UserTestHelper {
13:     /**
14:      * This method calls the use case implementation to register all users specified in the
15:      * test data set.
16:      * If you use the debugger and want to identify _which_ test user you currently look at:
17:      * The indices are coded into the house number (in the user's physical address) and in the first
18:      * cipher of the postal code. This is the list of users:
19:      *
20:      * +-------+-------------------+--------+---------------------
21:      * | Index | Name              | PLZ    | MailAddress
22:      * +-------+-------------------+--------+---------------------
23:      * | 0     | Max Mueller       | 02314  | 99Z@example.com
24:      * | 1     | Sophie Schmitz    | 02368  | a@4.com
25:      * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
26:      * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
27:      * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
28:      * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
29:      * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
30:      * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
31:      * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
32:      * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
33:      * +-------+-------------------+--------+---------------------
34:      */
35:     void registerAllUsers();
36: 
37: 
38:     /**
39:      * @return the number of test users in the test data set.
40:      */
41:     int getNumberOfUsers();
42: 
43: 
44:     /**
45:      * @param index the index of the user in the test data set.
46:      * @return the name of the test user with the given index.
47:      */
48:     String getUserName( int index );
49: 
50: 
51:     /**
52:      * @param index the index of the user in the test data set.
53:      * @return the mail address of the test user with the given index.
54:      */
55:     MailAddressType getUserMailAddress( int index );
56: 
57: 
58:     /**
59:      * @param index the index of the user in the test data set.
60:      * @return the physical address of the test user with the given index.
61:      */
62:     PhysicalAddressType getUserPhysicalAddress( int index );
63: 
64: 
65:     /**
66:      * @param index the index of the user in the test data set.
67:      * @return the test user with the given index.
68:      */
69:     UserType getUser( int index );
70: 
71: }
72: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\ProductCatalogUseCases.java ---
1: /*
2:  * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
9: 
10: import java.util.UUID;
11: 
12: 
13: /**
14:  * This interface contains methods needed in the context of use cases concerning the product catalog.
15:  * The interface is probably incomplete, and will grow over time ...
16:  */
17: 
18: public interface ProductCatalogUseCases {
19:     /**
20:      * Adds a new product to the shop catalog
21:      * @param name
22:      * @param descriptOf
23:      * @param size
24:      * @param buyingPrice
25:      * @param salesPrice
26:      * @return the id of the new product
27:      * @throws ShopException if ...
28:      *      - the product id already exists,
29:      *      - name or description are null or empty,
30:      *      - the size is <= 0 (but can be null!),
31:      *      - the buying price is null or <= 0,
32:      *      - the buyingPrice is null,
33:      *      - the sales price is null,
34:      *      - the sales price is lower than the buyingPrice
35:      */
36:     public UUID addProductToCatalog( String name, String descriptOf, Float size,
37:                                            CurrencyType buyingPrice, CurrencyType salesPrice );
38: 
39: 
40:     /**
41:      * Removes a product from the shop catalog
42:      * @param productId
43:      * @throws ShopException if
44:      *      - productId is null
45:      *      - the product id does not exist
46:      *      - the product is still in inventory
47:      *      - the product is still in a shopping basket, or referenced by a completed purchase
48:      */
49:     public void removeProductFromCatalog( UUID productId );
50: 
51: 
52:     /**
53:      * Get the sales price of a given product
54:      * @param productId
55:      * @return the sales price
56:      * @throws ShopException if ...
57:      *      - productId is null,
58:      *      - the product with that id does not exist
59:      */
60:     public CurrencyType getSalesPrice( UUID productId );
61: 
62: 
63:     /**
64:      * Clears the product catalog, i.e. removes all products from the catalog, including all the inventory,
65:      * all the reservations and all the purchases.
66:      */
67:     public void deleteProductCatalog();
68: 
69: }
70: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\PurchaseUseCases.java ---
1: /*
2:  * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
3:  */
4: package thkoeln.archilab.ecommerce.usecases;
5: 
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
9: 
10: import java.util.Map;
11: import java.util.UUID;
12: 
13: /**
14:  * This interface contains methods needed in the context of the purchase history of a user.
15:  */
16: public interface PurchaseUseCases {
17: 
18:     /**
19:      * Returns a map showing which products have been purchased by a user and how many of each product
20:      *
21:      * @param userMailAddress
22:      * @return the purchase history of the user (map is empty if the user has not purchased anything yet)
23:      * @throws ShopException if
24:      *      - userMailAddress is null
25:      *      - the user with the given mail address does not exist
26:      */
27:     public Map<UUID, Integer> getPurchaseHistory( MailAddressType userMailAddress );
28: 
29: 
30: 
31:     /**
32:      * @return the number of products in a given purchase. If the product is not a position of the purchase, the method
33:      *         returns 0. No exception is thrown.
34:      * @param purchaseId - the id of the purchase to be checked
35:      * @param productId - the id of the product for which we want to know the quantity
36:      * @throws ShopException if
37:      *     - purchaseId is null, or doesn't exist in the system
38:      *     - productId is null, or doesn't exist in the system
39:      */
40:     public Integer getPurchaseQuantityForProduct( UUID purchaseId, UUID productId );
41: 
42: 
43:     /**
44:      * @return the id of the fulfillment center that is responsible for the given purchase
45:      * @param purchaseId - the id of the purchase to be checked
46:      * @throws ShopException if
47:      *      - purchaseId is null, or doesn't exist in the system
48:      */
49:     public UUID getFulfillmentCenterIdForPurchase( UUID purchaseId );
50: 
51: 
52:     /**
53:      * Deletes all purchases in the system
54:      */
55:     public void deleteAllPurchases();
56: }
57: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingBasketUseCases.java ---
1: /*
2:  * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
10: 
11: import java.util.Map;
12: import java.util.Set;
13: import java.util.UUID;
14: 
15: /**
16:  * This interface contains methods needed in the context of use cases handling the shopping basket.
17:  * The interface is probably incomplete, and will grow over time ...
18:  */
19: public interface ShoppingBasketUseCases {
20:     /**
21:      * Adds a product to the cart of a user
22:      *
23:      * @param userMailAddress
24:      * @param productId
25:      * @param quantityFor
26:      * @throws ShopException if ...
27:      *          - userMailAddress is null,
28:      *          - the user with the given mail address does not exist,
29:      *          - productId is null,
30:      *          - the product with productId does not exist
31:      *          - the Quantity is negative,
32:      */
33:     public void addProductToShoppingBasket( MailAddressType userMailAddress,
34:                                                  UUID productId, int quantityFor );
35: 
36: 
37:     /**
38:      * Removes a product from the cart of a user
39:      *
40:      * @param userMailAddress
41:      * @param productId
42:      * @param quantityFor
43:      * @throws ShopException if ...
44:      *          - userMailAddress is null,
45:      *          - the user with the given mail address does not exist,
46:      *          - productId is null,
47:      *          - the product with productId does not exist
48:      *          - the Quantity is negative
49:      *          - the product is not in the shopping basket in the requested Quantity
50:      */
51:     public void removeProductFromShoppingBasket( MailAddressType userMailAddress,
52:                                                       UUID productId, int quantityFor );
53: 
54: 
55:     /**
56:      * Returns a map showing which products are in the cart of a user and how many of each product
57:      *
58:      * @param userMailAddress
59:      * @return the cart of the user (map is empty if the cart is empty)
60:      * @throws ShopException if
61:      *          - userMailAddress is null,
62:      *          - the user with the given mail address does not exist
63:      */
64:     public Map<UUID, Integer> getShoppingBasketAsMap( MailAddressType userMailAddress );
65: 
66: 
67:     /**
68:      * Returns the current value of all products in the cart of a user
69:      *
70:      * @param userMailAddress
71:      * @return the cart of the user
72:      * @throws ShopException if
73:      *          - userMailAddress is null,
74:      *          - the user with the given mail address does not exist
75:      */
76:     public CurrencyType getShoppingBasketAsCurrencyValue( MailAddressType userMailAddress );
77: 
78: 
79: 
80: 
81:     /**
82:      * Checks out the cart of a user
83:      *
84:      * @param userMailAddress
85:      * @return A set of ids belonging to purchases that were created during the checkout. If the shopping basket can
86:      *         only be served from more than one fulfillment center, each shipment from a fulfillment center gets a
87:      *         dedicated purchase. I.e. if there is just one shipment, then the set will contain just one purchase id.
88:      *         If there are multiple shipments, the set will contain multiple purchase ids.
89:      * @throws ShopException if
90:      *      - userMailAddress is null or empty
91:      *      - the user with the given mail address does not exist, or if the cart is empty
92:      * @throws
93:      *      - ShopException if userMailAddress is null
94:      *      - InsufficientInventoryException if there is not enough inventory level for to serve the purchase
95:      *        for all products in the shopping basket
96:      */
97:     public Set<UUID> checkout( MailAddressType userMailAddress );
98: 
99: 
100:     /**
101:      * Empties all shopping baskets in the system
102:      */
103:     public void emptyAllShoppingBaskets();
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\UserRegistrationUseCases.java ---
1: /*
2:  * Authored by ArchiLab 2025, Prof. Bente & Team, not for distribution
3:  */
4: 
5: package thkoeln.archilab.ecommerce.usecases;
6: 
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
10: 
11: /**
12:  * This interface contains methods needed in the context of use cases concerning the registration of a user.
13:  * The interface is probably incomplete, and will grow over time ...
14:  */
15: public interface UserRegistrationUseCases {
16:     /**
17:      * Registers a new user
18:      *
19:      * @param name
20:      * @param mailAddress
21:      * @param physicalAddress
22:      * @throws ShopException if ...
23:      *      - the user with the given mail address already exists
24:      *      - physicalAddress is null
25:      */
26:     public void register( String name, MailAddressType mailAddress, PhysicalAddressType physicalAddress );
27: 
28: 
29:     /**
30:      * Changes the address of a user
31:      *
32:      * @param userMailAddress
33:      * @param userMailAddress
34:      * @param physicalAddress
35:      * @throws ShopException if ...
36:      *      - the user with the given mail address does not exist,
37:      *      - physicalAddress is null
38:      */
39:     public void changeAddress( MailAddressType userMailAddress,
40:                                PhysicalAddressType physicalAddress );
41: 
42: 
43:     /**
44:      * Returns the data of a user as an array of strings (name, mailAddress, street, city, postalCode)
45:      * @param userMailAddress
46:      * @return the user data
47:      * @throws ShopException the user with the given mail address does not exist,
48:      */
49:     public UserType getUserData( MailAddressType userMailAddress );
50: 
51: 
52: 
53:     /**
54:      * Clears all users, including all purchases and shopping baskets
55:      */
56:     public void deleteAllUsers();
57: }
58: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\usecases\UserType.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
5: 
6: /**
7:  * This interface expresses the essence of a shop user
8:  */
9: public interface UserType {
10:     String getName();
11:     MailAddressType getMailAddress();
12:     PhysicalAddressType getPhysicalAddress();
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import org.springframework.boot.test.context.TestConfiguration;
4: import org.springframework.context.annotation.Bean;
5: import org.springframework.test.web.servlet.MockMvc;
6: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
7: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
8: 
9: 
10: @TestConfiguration
11: public class RESTTestHelperConfiguration {
12: 
13:     @Bean
14:     public ShoppingBasketRESTHelper shoppingBasketRESTHelper(
15:             MockMvc mockMvc, ProductCatalogUseCases productCatalogUseCases ) {
16:         return new ShoppingBasketRESTHelperImpl( mockMvc, productCatalogUseCases );
17:     }
18: }
19: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingBasketRESTHelperImpl.java ---
1: package thkoeln.archilab.ecommerce.helpers.impl;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import com.fasterxml.jackson.databind.ObjectMapper;
5: import lombok.AllArgsConstructor;
6: import lombok.Getter;
7: import lombok.NoArgsConstructor;
8: import lombok.Setter;
9: import lombok.extern.slf4j.Slf4j;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.MvcResult;
12: import org.springframework.test.web.servlet.ResultActions;
13: import org.springframework.test.web.servlet.ResultMatcher;
14: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
15: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
18: 
19: import java.util.Map;
20: import java.util.UUID;
21: 
22: import static org.springframework.http.MediaType.APPLICATION_JSON;
23: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
24: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
25: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
26: 
27: @Slf4j
28: public class ShoppingBasketRESTHelperImpl implements ShoppingBasketRESTHelper {
29:     private MockMvc mockMvc;
30:     private ProductCatalogUseCases productCatalogUseCases;
31: 
32:     private static final ResultMatcher CREATED = status().isCreated();
33:     private static final ResultMatcher OK = status().isOk();
34: 
35:     public ShoppingBasketRESTHelperImpl( MockMvc mockMvc, ProductCatalogUseCases productCatalogUseCases ) {
36:         this.mockMvc = mockMvc;
37:         this.productCatalogUseCases = productCatalogUseCases;
38:     }
39: 
40: 
41:     @Override
42:     public UUID getQueryShoppingBasket( MailAddressType mailAddress, Map<UUID, Integer> quantityMap )
43:             throws Exception {
44:         // first query the users API to get the proper userId
45:         UUID userId;
46:         String userUri = "/users?mailAddress=" + mailAddress.toString();
47:         MvcResult userGetResult = mockMvc.perform( get( userUri ) )
48:                 .andExpect( status().isOk() )
49:                 .andReturn();
50:         ObjectMapper objectMapper = new ObjectMapper();
51:         IdDTO idDTO = objectMapper.readValue( userGetResult.getResponse().getContentAsString(), IdDTO.class );
52:         userId = idDTO.getId();
53: 
54:         // then query the shopping basket API and extract the shopping basket id
55:         String shoppingBasketUri = "/shoppingBaskets?userId=" + userId.toString();
56:         ResultActions resultActions = mockMvc.perform( get( shoppingBasketUri ) )
57:                 .andExpect( status().isOk() );
58:         idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
59:         UUID shoppingBasketId = idDTO.getId();
60: 
61:         // additional checks, if desired
62:         if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
63:         return shoppingBasketId;
64:     }
65: 
66: 
67:     private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
68:         if ( quantityMap == null ) return;
69:         int numOfProducts = quantityMap.size();
70:         resultActions.andExpect( jsonPath( "$.positions.length()" ).value( numOfProducts ) );
71:         float totalSalesPriceAsFloat = 0f;
72:         for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
73:             UUID productId = entry.getKey();
74:             Integer quantity = entry.getValue();
75:             resultActions.andExpect( jsonPath( "$.positions.[?(@.productId == '" + productId + "')].quantity" )
76:                     .value( quantity ) );
77:             CurrencyType salesPrice = productCatalogUseCases.getSalesPrice( productId );
78:             totalSalesPriceAsFloat += salesPrice.getQuantity() * quantity;
79:         }
80:         // last thing - check the total sales price
81:         String totalSalesPriceString = String.format( "%.2f ‚Ç¨", totalSalesPriceAsFloat );
82:         resultActions
83:                 .andExpect( jsonPath( "$.totalSalesPrice" ).value( totalSalesPriceString ) );
84:     }
85: 
86: 
87:     @Override
88:     public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity )
89:             throws Exception {
90:         addProductToShoppingBasket( shoppingBasketId, productId, quantity, null );
91:     }
92: 
93: 
94:     @Override
95:     public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity,
96:                                                   ResultMatcher expectedStatus ) throws Exception {
97:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
98:         ObjectMapper objectMapper = new ObjectMapper();
99:         QuantityDTO dto = new QuantityDTO( productId, quantity );
100:         String quantityJson = objectMapper.writeValueAsString( dto );
101:         mockMvc.perform( post( "/shoppingBaskets/" + shoppingBasketId + "/positions" )
102:                         .contentType( APPLICATION_JSON ).content( quantityJson ) )
103:                 .andExpect( status );
104:     }
105: 
106: 
107: 
108:     @Override
109:     public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId )
110:             throws Exception {
111:         deleteProductFromShoppingBasket( shoppingBasketId, productId, null );
112:     }
113: 
114: 
115: 
116:     @Override
117:     public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId,
118:                                                       ResultMatcher expectedStatus ) throws Exception {
119:         ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
120:         String uri = "/shoppingBaskets/" + shoppingBasketId + "/positions/" + productId;
121:         mockMvc.perform( delete( uri ) ).andExpect( status );
122:     }
123: 
124: 
125:     @Override
126:     public void checkout( UUID shoppingBasketId, String expectedUserName,
127:                           ResultMatcher expectedStatus,
128:                           Map<UUID, Map<UUID, Integer>> expectedPurchases ) throws Exception {
129:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
130:         String uri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
131:         MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
132:         ObjectMapper objectMapper = new ObjectMapper();
133: 
134:         // check the response content
135:         if ( expectedPurchases != null || expectedUserName != null ) {
136:             String responseContent = result.getResponse().getContentAsString();
137:             log.info( "ShoppingBasketRESTHelperImpl - checkout: found response content " + responseContent );
138:             PurchaseDTO[] purchases = objectMapper.readValue( responseContent, PurchaseDTO[].class );
139:             checkExpectedUserName( expectedUserName, purchases );
140:             checkExpectedPurchases( expectedPurchases, purchases );
141:         }
142:     }
143: 
144: 
145:     private void checkExpectedUserName( String expectedUserName, PurchaseDTO[] purchases ) {
146:         if ( expectedUserName == null ) return;
147:         for ( PurchaseDTO purchase : purchases ) {
148:             if ( !purchase.getUserName().equals( expectedUserName ) ) {
149:                 throw new AssertionError( "Expected userName '" + expectedUserName +
150:                         "' but got '" + purchase.getUserName() + "'" );
151:             }
152:         }
153:     }
154: 
155: 
156:     private void checkExpectedPurchases( Map<UUID, Map<UUID, Integer>> expectedPurchases,
157:                                             PurchaseDTO[] purchases ) {
158:         if ( expectedPurchases == null ) return;
159:         for ( PurchaseDTO purchase : purchases ) {
160:             UUID fulfillmentCenterId = purchase.getFulfillmentCenterId();
161:             Map<UUID, Integer> expectedQuantities = expectedPurchases.get( fulfillmentCenterId );
162:             if ( expectedQuantities == null ) {
163:                 throw new AssertionError( "No expected quantities for fulfillment center " + fulfillmentCenterId );
164:             }
165:             QuantityDTO[] positions = purchase.getPositions();
166:             for ( QuantityDTO quantityDTO : positions ) {
167:                 UUID productId = quantityDTO.getProductId();
168:                 Integer expectedQuantity = expectedQuantities.get( productId );
169:                 if ( expectedQuantity == null ) {
170:                     throw new AssertionError( "No expected quantity for product " + productId +
171:                             " in fulfillment center " + fulfillmentCenterId );
172:                 }
173:                 if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
174:                     throw new AssertionError( "Expected quantity " + expectedQuantity + " for product " +
175:                             productId + " in fulfillment center " + fulfillmentCenterId +
176:                             ", but got " + quantityDTO.getQuantity() );
177:                 }
178:             }
179:         }
180:     }
181: 
182: 
183:     /**
184:      * A DTO containing just a quantity, used in testing.
185:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
186:      * Therefore, constructors and getters/setters are manually defined.
187:      */
188:     @NoArgsConstructor
189:     @JsonIgnoreProperties(ignoreUnknown = true)
190:     private static class QuantityDTO {
191:         private UUID productId;
192:         private Integer quantity;
193: 
194:         public QuantityDTO( UUID productId, Integer quantity ) {
195:             this.productId = productId;
196:             this.quantity = quantity;
197:         }
198:         public UUID getProductId() {
199:             return productId;
200:         }
201:         public Integer getQuantity() {
202:             return quantity;
203:         }
204:         public void setProductId( UUID productId ) {
205:             this.productId = productId;
206:         }
207:         public void setQuantity( Integer quantity ) {
208:             this.quantity = quantity;
209:         }
210:     }
211: 
212: 
213:     /**
214:      * A DTO containing just the id of an entity, used in testing.
215:      */
216:     @AllArgsConstructor
217:     @NoArgsConstructor
218:     @Getter
219:     @Setter
220:     @JsonIgnoreProperties(ignoreUnknown = true)
221:     private static class IdDTO {
222:         private UUID id;
223:     }
224: 
225: 
226:     /**
227:      * A DTO containing the purchase data, used in testing.
228:      * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
229:      * Therefore, constructors and getters/setters are manually defined.
230:      */
231:     @NoArgsConstructor
232:     @JsonIgnoreProperties(ignoreUnknown = true)
233:     private static class PurchaseDTO {
234:         private UUID id;
235:         private String userName;
236:         private UUID fulfillmentCenterId;
237:         private QuantityDTO[] positions;
238: 
239:         public UUID getId() {
240:             return id;
241:         }
242:         public String getUserName() {
243:             return userName;
244:         }
245:         public UUID getFulfillmentCenterId() {
246:             return fulfillmentCenterId;
247:         }
248:         public QuantityDTO[] getPositions() {
249:             return positions;
250:         }
251:         public void setId( UUID id ) {
252:             this.id = id;
253:         }
254:         public void setUserName( String userName ) {
255:             this.userName = userName;
256:         }
257:         public void setFulfillmentCenterId( UUID fulfillmentCenterId ) {
258:             this.fulfillmentCenterId = fulfillmentCenterId;
259:         }
260:         public void setPositions( QuantityDTO[] positions ) {
261:             this.positions = positions;
262:         }
263:     }
264: 
265: }
266: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingBasketRESTHelper.java ---
1: package thkoeln.archilab.ecommerce.helpers;
2: 
3: import org.springframework.test.web.servlet.ResultMatcher;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: 
6: import java.util.Map;
7: import java.util.UUID;
8: 
9: /**
10:  * A REST helper for shopping basket-related operations.
11:  * This interface defines methods to interact with a shopping basket via REST calls, such as querying, adding,
12:  * deleting, and checking out.
13:  */
14: public interface ShoppingBasketRESTHelper {
15:     /**
16:      * Executes a REST GET query on a shopping basket and returns its id, with the user's mail address as a
17:      * starting point. The resulting shopping basket is checked against the given expected quantity map.
18:      * @param mailAddress The mailAddress of the user whose shopping basket is queried.
19:      * @param expectedQuantityMap A map of products and their quantities in the shopping basket. (If null, then don't check.)
20:      * @return The id of the user's shopping basket.
21:      * @throws Exception (whenever the REST call fails, or the shopping basket does not match the expected quantity map)
22:      */
23:     public UUID getQueryShoppingBasket( MailAddressType mailAddress,
24:                                        Map<UUID, Integer> expectedQuantityMap ) throws Exception;
25: 
26: 
27:     /**
28:      * Adds a product to a shopping basket via a REST call.
29:      * @param shoppingBasketId Id of the shopping basket.
30:      * @param productId Id of the product.
31:      * @param quantity Quantity of the product.
32:      * @throws Exception (whenever the REST call fails)
33:      */
34:     public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity )
35:             throws Exception;
36: 
37: 
38:     /**
39:      * Adds a product to a shopping basket via a REST call.
40:      * @param shoppingBasketId Id of the shopping basket.
41:      * @param productId Id of the product.
42:      * @param quantity Quantity of the product.
43:      * @param expectedStatus expected status of the operation (null = CREATED)
44:      * @throws Exception (whenever the REST call fails or the status does not match)
45:      */
46:     public void addProductToShoppingBasket( UUID shoppingBasketId, UUID productId, Integer quantity,
47:                                                   ResultMatcher expectedStatus ) throws Exception;
48: 
49: 
50:     /**
51:      * Deletes a product from a shopping basket via a REST call.
52:      * @param shoppingBasketId Id of the shopping basket.
53:      * @param productId Id of the product.
54:      * @throws Exception (whenever the REST call fails)
55:      */
56:     public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId )
57:             throws Exception;
58: 
59: 
60:     /**
61:      * Deletes a product from a shopping basket via a REST call.
62:      * @param shoppingBasketId Id of the shopping basket.
63:      * @param productId Id of the product.
64:      * @param expectedStatus expected status of the operation (null = OK)
65:      * @throws Exception (whenever the REST call fails or the status does not match)
66:      */
67:     public void deleteProductFromShoppingBasket( UUID shoppingBasketId, UUID productId,
68:                                                       ResultMatcher expectedStatus ) throws Exception;
69: 
70: 
71:     /**
72:      * Checks out a shopping basket via REST call, and returns the id of the created purchase.
73:      * @param shoppingBasketId
74:      * @param expectedUserName expected name of the user who owns the shopping basket (null = don't check)
75:      * @param expectedStatus expected status of the operation (null = don't check)
76:      * @param expectedPurchases the expected purchases to be created as a result of the checkout. This is
77:      *                            a map of the following form:
78:      *                            <pre>
79:      *                               fulfillmentCenterId -> Map<productId,Integer>
80:      *                            </pre>
81:      *                            where the inner map contains the products and their quantities
82:      * @return
83:      * @throws Exception
84:      */
85:     public void checkout( UUID shoppingBasketId, String expectedUserName,
86:                           ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedPurchases )
87:            throws Exception;
88: }
89: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class BasicNoOutsideSolutionRulesTest {
14: 
15:     @ArchTest
16:     static final ArchRule noClassesOnTopLevel =
17:             classes().should().resideInAPackage( "..solution.*.." )
18:                     .allowEmptyShould( true );
19: }
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.library.Architectures.layeredArchitecture;
9: 
10: @ArchTag("layerRules")
11: @AnalyzeClasses(packages = "thkoeln")
12: @SuppressWarnings("PMD")
13: public class BasicProperDependenciesTest {
14: 
15:     @ArchTest
16:     static final ArchRule properDependencies =
17:             layeredArchitecture()
18:                     .consideringAllDependencies()
19:                     //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
20:                     .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
21:                     .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )
22: 
23:                     //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
24:                     .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
25:                     .allowEmptyShould( true );
26: }
27: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
5: import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
6: import org.springframework.core.type.classreading.MetadataReader;
7: import org.springframework.core.type.classreading.MetadataReaderFactory;
8: 
9: import java.io.IOException;
10: import java.util.Arrays;
11: import java.util.HashSet;
12: import java.util.Set;
13: 
14: import static org.junit.jupiter.api.Assertions.assertTrue;
15: 
16: public class BasicRequiredClassesTest {
17:     private static final String[] REQUIRED_CLASSES = {
18:             "User",
19:             "UserRepository",
20:             "Product",
21:             "ProductRepository",
22:             "Purchase",
23:             "PurchaseRepository",
24:             "InventoryLevel",
25:             "ShoppingBasket",
26:             "ShoppingBasketRepository",
27:             "FulfillmentCenterRepository",
28:             "ShoppingBasketPosition",
29:             "PurchasePosition",
30:             "FulfillmentCenter",
31:     };
32: 
33:     @Test
34:     public void testRequiredClassesDeclared() throws IOException {
35:         String basePackage = "thkoeln.archilab.ecommerce";
36:         String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";
37: 
38:         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
39:         MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );
40: 
41:         Set<String> foundClasses = new HashSet<>();
42: 
43:         Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
44:             try {
45:                 MetadataReader reader = readerFactory.getMetadataReader( resource );
46:                 foundClasses.add( reader.getClassMetadata().getClassName() );
47:             } catch (IOException e) {
48:                 e.printStackTrace();
49:             }
50:         } );
51: 
52:         Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
53:             boolean found = foundClasses.stream().anyMatch(className ->
54:                     className.startsWith(basePackage) && className.endsWith("." + requiredClass)
55:             );
56:             assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
57:         });
58:     }
59: }
60: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import org.junit.jupiter.api.Test;
4: import org.springframework.beans.factory.annotation.Autowired;
5: import org.springframework.boot.test.context.SpringBootTest;
6: import org.springframework.context.ApplicationContext;
7: 
8: import java.util.Arrays;
9: import java.util.HashMap;
10: import java.util.List;
11: import java.util.Map;
12: 
13: import static org.junit.jupiter.api.Assertions.*;
14: 
15: @SpringBootTest
16: public class BasicUseCaseImplementationPackageTest {
17: 
18:     @Autowired
19:     private ApplicationContext applicationContext;
20: 
21:     private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
22:         put("UserRegistrationUseCases", Arrays.asList("user"));
23:         put("FulfillmentCenterUseCases", Arrays.asList("fulfillmentcenter"));
24:         put("ProductCatalogUseCases", Arrays.asList("product"));
25:         put("ShoppingBasketUseCases", Arrays.asList("shoppingbasket"));
26:         put("PurchaseUseCases", Arrays.asList("purchase"));
27:     }};
28:     private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
29:     private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";
30: 
31:     @Test
32:     public void testRequiredClassesDeclared() {
33:         for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
34:             String interfaceName = USECASE_PATH + "." + entry.getKey();
35:             List<String> correctTopLevelPackages = entry.getValue();
36:             Class<?> useCaseInterfaceClass = null;
37:             try {
38:                 useCaseInterfaceClass = Class.forName( interfaceName );
39:             } catch (ClassNotFoundException e) {
40:                 fail( "Use case interface " + interfaceName + " not found.", e );
41:                 continue;
42:             }
43:             String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
44:             assertEquals( 1, beans.length,
45:                     "There should be exactly 1 service implementation for the interface " +
46:                             entry.getKey() + ", but found " + beans.length );
47:             Object bean = applicationContext.getBean( beans[0] );
48:             boolean isValid = false;
49:             for ( String correctTopLevelPackage : correctTopLevelPackages ) {
50:                 String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
51:                 if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
52:                     isValid = true;
53:                     break;
54:                 }
55:             }
56:             assertTrue( isValid,
57:                     "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
58:                             + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
59:         }
60:     }
61: }
62: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: import org.springframework.data.repository.CrudRepository;
8: import org.springframework.stereotype.Service;
9: 
10: import jakarta.persistence.Entity;
11: import org.springframework.web.bind.annotation.RestController;
12: 
13: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
14: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
15: 
16: @ArchTag("layerRules")
17: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
18: @SuppressWarnings("PMD")
19: public class DDDRulesTest {
20: 
21:     @ArchTest
22:     static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
23:             noClasses().that().resideInAPackage( "..domain.." )
24:                     .should().dependOnClassesThat().resideInAPackage( "..application.." )
25:                     .allowEmptyShould( true );
26: 
27:     @ArchTest
28:     static final ArchRule entitiesMustResideInADomainPackage =
29:             classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
30:                     .as( "Entities must reside in a package '..domain..'" )
31:                     .allowEmptyShould( true );
32: 
33:     @ArchTest
34:     static final ArchRule entitiesMustNotAccessRepositories =
35:             noClasses().that().areAnnotatedWith( Entity.class )
36:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
37:                     .allowEmptyShould( true );
38: 
39:     @ArchTest
40:     static final ArchRule repositoriesMustResideInADomainPackage =
41:             classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
42:                     .as( "Repositories must reside in a package '..domain..'" )
43:                     .allowEmptyShould( true );
44: 
45:     @ArchTest
46:     static final ArchRule repositoryNamesMustHaveProperSuffix =
47:             classes().that().areAssignableTo( CrudRepository.class )
48:                     .should().haveSimpleNameEndingWith( "Repository" )
49:                     .allowEmptyShould( true );
50: 
51:     @ArchTest
52:     static final ArchRule servicesMustResideInAnApplicationPackage =
53:             classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
54:                     .as( "Application Services must reside in a package '..application..'" )
55:                     .allowEmptyShould( true );
56: 
57:     @ArchTest
58:     static final ArchRule serviceNamesMustHaveProperSuffix =
59:             classes().that().areAnnotatedWith( Service.class )
60:                     .should().haveSimpleNameEndingWith( "Service" )
61:                     .allowEmptyShould( true );
62: 
63:     @ArchTest
64:     static final ArchRule controllersMustResideInAnApplicationPackage =
65:             classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
66:                     .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );
67: 
68:     @ArchTest
69:     static final ArchRule controllersNamesMustHaveProperSuffix =
70:             classes().that().areAnnotatedWith( RestController.class )
71:                     .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );
72: 
73:     @ArchTest
74:     static final ArchRule controllersMustNotAccessRepositories =
75:             noClasses().that().areAnnotatedWith( RestController.class )
76:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
77:                     .allowEmptyShould( false );
78: }
79: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.importer.ClassFileImporter;
6: import com.tngtech.archunit.lang.ArchRule;
7: import com.tngtech.archunit.library.dependencies.SliceAssignment;
8: import com.tngtech.archunit.library.dependencies.SliceIdentifier;
9: import org.junit.jupiter.api.Test;
10: 
11: import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
12: 
13: public class NoCycleTest {
14:     private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");
15: 
16:     private SliceAssignment inAllClasses() {
17:         return new SliceAssignment() {
18:             @Override
19:             public String getDescription() {
20:                 return "every class in it's own slice";
21:             }
22: 
23:             @Override
24:             public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
25:                 return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
26:             }
27:         };
28:     }
29: 
30:     @Test
31:     public void testNoCyclicDependenciesBetweenClasses() {
32:         slices().assignedFrom(inAllClasses())
33:                 .namingSlices("$1[$2.$3]")
34:                 .should().beFreeOfCycles()
35:                 .check(importedClasses);
36:     }
37: 
38:     @Test
39:     public void testNoCyclicDependenciesBetweenPackages() {
40:         ArchRule rule = slices().matching("..solution.(*)..")
41:                 .should().beFreeOfCycles().allowEmptyShould( true );
42:         rule.check(importedClasses);
43:     }
44: }
45: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.base.DescribedPredicate;
4: import com.tngtech.archunit.core.domain.JavaClass;
5: import com.tngtech.archunit.core.domain.JavaField;
6: import com.tngtech.archunit.core.domain.JavaParameterizedType;
7: import com.tngtech.archunit.core.domain.JavaType;
8: import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
9: import com.tngtech.archunit.junit.AnalyzeClasses;
10: import com.tngtech.archunit.junit.ArchTag;
11: import com.tngtech.archunit.junit.ArchTest;
12: import com.tngtech.archunit.lang.ArchCondition;
13: import com.tngtech.archunit.lang.ArchRule;
14: import com.tngtech.archunit.lang.ConditionEvents;
15: import com.tngtech.archunit.lang.SimpleConditionEvent;
16: import jakarta.persistence.*;
17: import lombok.extern.slf4j.Slf4j;
18: import thkoeln.archilab.ecommerce.GenericId;
19: 
20: import java.util.List;
21: 
22: import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
23: import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
24: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;
25: 
26: @ArchTag("layerRules")
27: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
28: @SuppressWarnings("PMD")
29: @Slf4j
30: public class OnlyReferenceViaIDTest { //FULFILLMENT_CENTER
31:     private static final String SHOPPING_BASKET_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingbasket.domain";
32:     private static final String USER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.user.domain";
33:     private static final String PRODUCT_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.product.domain";
34:     private static final String PURCHASE_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.purchase.domain";
35:     private static final String FULFILLMENT_CENTER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain";
36: 
37:     @ArchTest
38:     static final ArchRule idFieldsMustUseGenericId =
39:             fields()
40:                     .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
41:                     .and().areAnnotatedWith( Id.class )
42:                     .should().haveRawType( assignableTo( GenericId.class ) )
43:                     .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
44:                     .allowEmptyShould( true );
45: 
46: 
47:     private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
48:             annotatedWith( ManyToOne.class )
49:                     .or( annotatedWith( OneToOne.class ) )
50:                     .or( annotatedWith( Embedded.class ) )
51:                     .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );
52: 
53:     private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
54:             annotatedWith( OneToMany.class )
55:                     .or( annotatedWith( ManyToMany.class ) )
56:                     .or( annotatedWith( ElementCollection.class ) )
57:                     .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );
58: 
59: 
60:     private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
61:         String description = "an entity or value object from same aggregate, or a domain primitive";
62:         return new DescribedPredicate<>( description ) {
63:             @Override
64:             public boolean test( JavaClass type ) {
65:                 // check if the class is an entity or value object, and resides in the allowed package
66:                 if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
67:                     return false;
68:                 }
69:                 // a GenericId is always allowed
70:                 if ( type.isAssignableTo( GenericId.class ) ) {
71:                     return true;
72:                 }
73:                 // a domain primitive is also always allowed
74:                 if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
75:                     return true;
76:                 }
77:                 return type.getPackageName().startsWith( allowedPackage );
78:             }
79:         };
80:     }
81: 
82: 
83:     @ArchTest
84:     static final ArchRule shoppingBasketToOneReferences =
85:             fields()
86:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
87:                     .and( isToOneAnnotation )
88:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) ) )
89:                     .allowEmptyShould( true );
90: 
91:     @ArchTest
92:     static final ArchRule userToOneReferences =
93:             fields()
94:                     .that().areDeclaredInClassesThat().resideInAPackage( USER_DOMAIN_PACKAGE )
95:                     .and( isToOneAnnotation )
96:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( USER_DOMAIN_PACKAGE ) ) )
97:                     .allowEmptyShould( true );
98: 
99:     @ArchTest
100:     static final ArchRule productToOneReferences =
101:             fields()
102:                     .that().areDeclaredInClassesThat().resideInAPackage( PRODUCT_DOMAIN_PACKAGE )
103:                     .and( isToOneAnnotation )
104:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( PRODUCT_DOMAIN_PACKAGE ) ) )
105:                     .allowEmptyShould( true );
106: 
107:     @ArchTest
108:     static final ArchRule purchaseToOneReferences =
109:             fields()
110:                     .that().areDeclaredInClassesThat().resideInAPackage( PURCHASE_DOMAIN_PACKAGE )
111:                     .and( isToOneAnnotation )
112:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( PURCHASE_DOMAIN_PACKAGE ) ) )
113:                     .allowEmptyShould( true );
114: 
115:     @ArchTest
116:     static final ArchRule fulfillmentCenterToOneReferences =
117:             fields()
118:                     .that().areDeclaredInClassesThat().resideInAPackage( FULFILLMENT_CENTER_DOMAIN_PACKAGE )
119:                     .and( isToOneAnnotation )
120:                     .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( FULFILLMENT_CENTER_DOMAIN_PACKAGE ) ) )
121:                     .allowEmptyShould( true );
122: 
123: 
124:     private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
125:         return new ArchCondition<JavaField>(
126:                 "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
127:             @Override
128:             public void check( JavaField field, ConditionEvents events ) {
129:                 JavaClass rawType = field.getRawType();
130:                 String rawTypeName = rawType.getFullName();
131:                 if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
132:                     events.add( SimpleConditionEvent.violated( field,
133:                             field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
134:                     return;
135:                 }
136:                 JavaType fieldType = field.getType();
137:                 if ( !( fieldType instanceof JavaParameterizedType ) ) {
138:                     events.add( SimpleConditionEvent.violated( field,
139:                             field.getFullName() + " is a raw List/Set without a type argument" ) );
140:                     return;
141:                 }
142:                 List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
143:                 if ( typeArguments.isEmpty() ) {
144:                     events.add( SimpleConditionEvent.violated( field,
145:                             field.getFullName() + " has no type arguments" ) );
146:                     return;
147:                 }
148:                 JavaType elementType = typeArguments.get( 0 );
149:                 if ( !( elementType instanceof JavaClass ) ) {
150:                     events.add( SimpleConditionEvent.violated( field,
151:                             field.getFullName() + " has an unknown element type" ) );
152:                     return;
153:                 }
154:                 JavaClass elementClass = (JavaClass) elementType;
155:                 boolean hasAnnotation =
156:                         elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
157:                 boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
158:                 boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
159:                 boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
160:                 boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
161:                 if ( !ok ) {
162:                     events.add( SimpleConditionEvent.violated( field,
163:                             field.getFullName() + " refers to " + elementClass.getFullName()
164:                                     + " which is not a DP, or an entity/value object in " + allowedPackage ) );
165:                 }
166:             }
167:         };
168:     }
169: 
170: 
171:     @ArchTest
172:     static final ArchRule shoppingBasketToManyReferences =
173:             fields()
174:                     .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_BASKET_DOMAIN_PACKAGE )
175:                     .and( isToManyAnnotation )
176:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_BASKET_DOMAIN_PACKAGE ) )
177:                     .allowEmptyShould( true );
178: 
179:     @ArchTest
180:     static final ArchRule userToManyReferences =
181:             fields()
182:                     .that().areDeclaredInClassesThat().resideInAPackage( USER_DOMAIN_PACKAGE )
183:                     .and( isToManyAnnotation )
184:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( USER_DOMAIN_PACKAGE ) )
185:                     .allowEmptyShould( true );
186: 
187:     @ArchTest
188:     static final ArchRule productToManyReferences =
189:             fields()
190:                     .that().areDeclaredInClassesThat().resideInAPackage( PRODUCT_DOMAIN_PACKAGE )
191:                     .and( isToManyAnnotation )
192:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( PRODUCT_DOMAIN_PACKAGE ) )
193:                     .allowEmptyShould( true );
194: 
195:     @ArchTest
196:     static final ArchRule purchaseToManyReferences =
197:             fields()
198:                     .that().areDeclaredInClassesThat().resideInAPackage( PURCHASE_DOMAIN_PACKAGE )
199:                     .and( isToManyAnnotation )
200:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( PURCHASE_DOMAIN_PACKAGE ) )
201:                     .allowEmptyShould( true );
202: 
203:     @ArchTest
204:     static final ArchRule fulfillmentCenterToManyReferences =
205:             fields()
206:                     .that().areDeclaredInClassesThat().resideInAPackage( FULFILLMENT_CENTER_DOMAIN_PACKAGE )
207:                     .and( isToManyAnnotation )
208:                     .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( FULFILLMENT_CENTER_DOMAIN_PACKAGE ) )
209:                     .allowEmptyShould( true );
210: 
211: }
212: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: /**
4:  * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
5:  */
6: 
7: public class OwnTestsTest {
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
1: package thkoeln.archilab.ecommerce.tests.dddtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClasses;
4: import com.tngtech.archunit.core.importer.ClassFileImporter;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: 
8: import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
9: 
10: public class PackageStructureTest {
11: 
12:     private static final String[] REQUIRED_PACKAGES = {"user", "shoppingbasket", "product", "purchase", "fulfillmentcenter"};
13:     private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
14:     private JavaClasses importedClasses;
15: 
16: 
17:     @BeforeEach
18:     public void setUp() {
19:         importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
20:     }
21: 
22:     @Test
23:     void testRequiredPackagesAreThere() {
24:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
25:             String packageName = BASE_PACKAGE + "." + requiredPackage;
26:             assertThat( importedClasses.containPackage( packageName ) )
27:                     .as( "Expected package %s not found!", packageName )
28:                     .isTrue();
29:         }
30:     }
31: 
32:     @Test
33:     void testRequiredDomainPackagesAreThere() {
34:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
35:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
36:             assertThat( importedClasses.containPackage( packageName ) )
37:                     .as( "Expected domain sub-package %s not found!", packageName )
38:                     .isTrue();
39:         }
40:     }
41: 
42:     @Test
43:     void testRequiredApplicationPackagesAreThere() {
44:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
45:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
46:             assertThat( importedClasses.containPackage( packageName ) )
47:                     .as( "Expected application sub-package %s not found!", packageName )
48:                     .isTrue();
49:         }
50:     }
51: 
52: }
53: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\CurrencyTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateCurrency;
9: 
10: class CurrencyTest {
11: 
12:     @Test
13:     public void testGetQuantityCurrency() {
14:         // given
15:         Float inputQuantity = 10.0f;
16: 
17:         // when
18:         CurrencyType instance = instantiateCurrency( inputQuantity, "EUR" );
19: 
20:         // then
21:         assertEquals( inputQuantity, instance.getQuantity() );
22:     }
23: 
24:     @Test
25:     public void testGetCurrencyUnitCurrency() {
26:         // given
27:         String inputCurrencyUnit = "EUR";
28: 
29:         // when
30:         CurrencyType instance = instantiateCurrency( 10.0f, inputCurrencyUnit );
31: 
32:         // then
33:         assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
34:     }
35: 
36:     @Test
37:     public void testAddToCurrency() {
38:         // given
39:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
40:         CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
41:         CurrencyType instance3 = instantiateCurrency( 0.0f, "EUR" );
42: 
43:         // when
44:         CurrencyType result12 = instance1.add( instance2 );
45:         CurrencyType result13 = instance1.add( instance3 );
46: 
47:         // then
48:         assertEquals( 30.0f, result12.getQuantity() );
49:         assertEquals( "EUR", result12.getCurrencyUnit() );
50:         assertEquals( 10.0f, result13.getQuantity() );
51:         assertEquals( "EUR", result12.getCurrencyUnit() );
52:     }
53: 
54:     @Test
55:     public void testInvalidAddToCurrency() {
56:         // given
57:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
58:         CurrencyType instance2 = instantiateCurrency( 20.0f, "CHF" );
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
63:     }
64: 
65:     @Test
66:     public void testSubtractFromCurrency() {
67:         // given
68:         CurrencyType instance1 = instantiateCurrency( 30.0f, "EUR" );
69:         CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
70:         CurrencyType instance3 = instantiateCurrency( 0.0f, "EUR" );
71:         CurrencyType instance4 = instantiateCurrency( 30.0f, "EUR" );
72: 
73:         // when
74:         CurrencyType result12 = instance1.subtract( instance2 );
75:         CurrencyType result13 = instance1.subtract( instance3 );
76:         CurrencyType result14 = instance1.subtract( instance4 );
77: 
78:         // then
79:         assertEquals( 10.0f, result12.getQuantity() );
80:         assertEquals( "EUR", result12.getCurrencyUnit() );
81:         assertEquals( 30.0f, result13.getQuantity() );
82:         assertEquals( "EUR", result13.getCurrencyUnit() );
83:         assertEquals( 0.0f, result14.getQuantity() );
84:         assertEquals( "EUR", result14.getCurrencyUnit() );
85:     }
86: 
87:     @Test
88:     public void testInvalidSubtractFromCurrency() {
89:         // given
90:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
91:         CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
92:         CurrencyType instance3 = instantiateCurrency( 5.0f, "CHF" );
93: 
94:         // when
95:         // then
96:         assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
97:         assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
98:     }
99: 
100:     @Test
101:     public void testMultiplyByCurrency() {
102:         // given
103:         CurrencyType instance = instantiateCurrency( 10.0f, "EUR" );
104: 
105:         // when
106:         CurrencyType result = instance.multiplyBy( 3 );
107: 
108:         // then
109:         assertEquals( 30.0f, result.getQuantity() );
110:         assertEquals( "EUR", result.getCurrencyUnit() );
111:     }
112: 
113:     @Test
114:     public void testFactoryValidCurrencyUnitCurrency() {
115:         // given
116:         // when
117:         // then
118:         assertDoesNotThrow( () -> instantiateCurrency( 10.0f, "EUR" ) );
119:     }
120: 
121:     @Test
122:     public void testFactoryInvalidCurrencyUnitCurrency() {
123:         // given
124:         // when
125:         // then
126:         assertThrows( ShopException.class, () -> instantiateCurrency( -10.0f, "EUR" ) );
127:         assertThrows( ShopException.class, () -> instantiateCurrency( 10.0f, "USD" ) );
128:         assertThrows( ShopException.class, () -> instantiateCurrency( null, "EUR" ) );
129:         assertThrows( ShopException.class, () -> instantiateCurrency( 10.0f, null ) );
130:     }
131: 
132:     @Test
133:     public void testLargerThanCurrencyUnitCurrency() {
134:         // given
135:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
136:         CurrencyType instance2 = instantiateCurrency( 20.0f, "EUR" );
137:         CurrencyType instance3 = instantiateCurrency( 10.0f, "EUR" );
138:         CurrencyType instance4 = instantiateCurrency( 10.0f, "CHF" );
139: 
140:         // when
141:         // then
142:         assertTrue( instance2.largerThan( instance1 ) );
143:         assertFalse( instance1.largerThan( instance2 ) );
144:         assertFalse( instance1.largerThan( instance3 ) );
145:         assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
146:     }
147: 
148: 
149:     @Test
150:     public void testEqualityCurrencyUnitCurrency() {
151:         // given
152:         // when
153:         CurrencyType instance1 = instantiateCurrency( 10.0f, "EUR" );
154:         CurrencyType instance2 = instantiateCurrency( 10.0f, "EUR" );
155:         CurrencyType instance3 = instantiateCurrency( 20.0f, "EUR" );
156: 
157:         // then
158:         assertEquals( instance1, instance2 );
159:         assertNotEquals( instance1, instance3 );
160:     }
161: 
162:     @Test
163:     public void testImmutabilityCurrencyUnitCurrency() {
164:         // given
165:         // when
166:         CurrencyType instance = instantiateCurrency( 10.0f, "EUR" );
167: 
168:         // then
169:         try {
170:             instance.getClass().getMethod( "setQuantity", Float.class );
171:             fail( "setQuantity method should not exist" );
172:         } catch (NoSuchMethodException e) {
173:             // Success: the object is immutable
174:         }
175: 
176:         try {
177:             instance.getClass().getMethod( "setCurrencyUnit", String.class );
178:             fail( "setCurrencyUnit method should not exist" );
179:         } catch (NoSuchMethodException e) {
180:             // Success: the object is immutable
181:         }
182:     }
183: }
184: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: 
8: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
9: 
10: @ArchTag("domainPrimitivesUsageRules")
11: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
12: @SuppressWarnings("PMD")
13: public class DomainPrimitivesUsageRulesTest {
14:     private static final String MAIL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.MailAddress";
15:     private static final String CURRENCY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Currency";
16:     private static final String PHYSICAL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress";
17: 
18:     @ArchTest
19:     static final ArchRule userShouldReferenceMailAddress =
20:             classes()
21:                     .that().haveSimpleName( "User" )
22:                     .should().dependOnClassesThat().haveFullyQualifiedName( MAIL_ADDRESS_CLASS )
23:                     .because( "User should use MailAddress instead of String" );
24: 
25:     @ArchTest
26:     static final ArchRule userShouldReferencePhysicalAddress =
27:             classes()
28:                     .that().haveSimpleName( "User" )
29:                     .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
30:                     .because( "User should use PhysicalAddress instead of whatever else" );
31: 
32:     @ArchTest
33:     static final ArchRule fulfillmentCenterShouldReferencePhysicalAddress =
34:             classes()
35:                     .that().haveSimpleName( "FulfillmentCenter" )
36:                     .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
37:                     .because( "User should use PhysicalAddress instead of whatever else" );
38: 
39:     @ArchTest
40:     static final ArchRule productShouldReferenceCurrency =
41:             classes()
42:                     .that().haveSimpleName( "Product" )
43:                     .should().dependOnClassesThat().haveFullyQualifiedName( CURRENCY_CLASS )
44:                     .because( "Product should use Currency instead of float or whatever else" );
45: }
46: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\MailAddressTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMailAddress;
10: 
11: class MailAddressTest {
12: 
13:     @Test
14:     public void testToStringMailAddress() {
15:         // given
16:         String input = "test@example.com";
17: 
18:         // when
19:         MailAddressType instance = instantiateMailAddress( input );
20: 
21:         // then
22:         assertEquals( input, instance.toString() );
23:     }
24: 
25:     @Test
26:     public void testEqualityMailAddress() {
27:         // given
28:         // when
29:         MailAddressType instance1 = instantiateMailAddress( "test@example.com" );
30:         MailAddressType instance2 = instantiateMailAddress( "test@example.com" );
31:         MailAddressType instance3 = instantiateMailAddress( "different@example.com" );
32: 
33:         // then
34:         assertEquals( instance1, instance2 );
35:         assertNotEquals( instance1, instance3 );
36:     }
37: 
38:     @Test
39:     public void testImmutabilityMailAddress() {
40:         // given
41:         // when
42:         MailAddressType instance = instantiateMailAddress( "test@example.com" );
43: 
44:         // then
45:         try {
46:             instance.getClass().getMethod( "setMailAddress", String.class );
47:             fail( "setMailAddress method should not exist" );
48:         } catch (NoSuchMethodException e) {
49:             // Success: the object is immutable
50:         }
51:     }
52: 
53: 
54: 
55:     @Test
56:     public void smokeTestForCopyConstructors() {
57:         // given
58:         MailAddressType mailAddress =
59:                 instantiateMailAddress( "peter.schmidt@web.de" );
60: 
61:         // when
62:         MailAddressType mailAddressOtherIdentifyer =
63:                 mailAddress.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
64:         assertThrows( ShopException.class, () ->
65:                 mailAddress.sameDomainDifferentIdentifyer( "p...eter" ) );
66:         MailAddressType mailAddressOtherDomain =
67:                 mailAddress.sameIdentifyerDifferentDomain( "web.ch" );
68:         assertThrows( ShopException.class, () ->
69:                 mailAddress.sameIdentifyerDifferentDomain( "web.edu" ) );
70: 
71:         // then
72:         assertEquals( "p.e.t.e.r@web.de", mailAddressOtherIdentifyer.toString() );
73:         assertEquals( "peter.schmidt@web.ch", mailAddressOtherDomain.toString() );
74:     }
75: 
76: 
77:     @Test
78:     public void testFactoryValidMailAddress() {
79:         // given
80:         // when
81:         // then
82:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.com" ) );
83:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "99Z@example.com" ) );
84:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "GGGhh@s77.com" ) );
85:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "a@4.com" ) );
86:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "Max.Hammer@example.com" ) );
87:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "Max.Gideon.Hammer@example.com" ) );
88:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.this.com" ) );
89:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.de" ) );
90:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.at" ) );
91:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.ch" ) );
92:         Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.org" ) );
93:     }
94: 
95: 
96:     @Test
97:     public void testFactoryInvalidMailAddress() {
98:         // given
99:         // when
100:         // then
101:         assertThrows( ShopException.class, () -> instantiateMailAddress( null ) );
102:         assertThrows( ShopException.class, () -> instantiateMailAddress( "testexample.com" ) );
103:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@" ) );
104:         assertThrows( ShopException.class, () -> instantiateMailAddress( "@example.com" ) );
105:         assertThrows( ShopException.class, () -> instantiateMailAddress( "Max..Gideon.Hammer@example.com" ) );
106:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@examplecom" ) );
107:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example..com" ) );
108:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example@that.com" ) );
109:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test example@that.com" ) );
110:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test#example@that.com" ) );
111:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.biz" ) );
112:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.biz" ) );
113:         assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.42" ) );
114:     }
115: }
116: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\PhysicalAddressTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
7: 
8: import static org.junit.jupiter.api.Assertions.*;
9: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePostalCode;
11: 
12: class PhysicalAddressTest {
13: 
14:     @Test
15:     public void testGetterPhysicalAddress() {
16:         // given
17:         String street = "Irgendeinestra√üe 42";
18:         String city = "Irgendeinestadt";
19:         PostalCodeType plz = instantiatePostalCode( "12345" );
20: 
21:         // when
22:         PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );
23: 
24:         // then
25:         assertEquals( street, instance.getStreet() );
26:         assertEquals( city, instance.getCity() );
27:         assertEquals( plz, instance.getPostalCode() );
28:     }
29: 
30:     @Test
31:     public void testFactoryValidPhysicalAddress() {
32:         // given
33:         String street = "Irgendeinestra√üe 42";
34:         String city = "Irgendeinestadt";
35:         PostalCodeType plz = instantiatePostalCode( "12345" );
36: 
37:         // when
38:         // then
39:         assertDoesNotThrow( () -> instantiatePhysicalAddress( street, city, plz ) );
40:     }
41: 
42:     @Test
43:     public void testFactoryInvalidPhysicalAddress() {
44:         // given
45:         String street = "Irgendeinestra√üe 42";
46:         String city = "Irgendeinestadt";
47:         PostalCodeType plz = instantiatePostalCode( "12345" );
48: 
49:         // when
50:         // then
51:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( null, city, plz ) );
52:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( "", city, plz ) );
53:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, null, plz ) );
54:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, "", plz ) );
55:         assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, city, null ) );
56:     }
57: 
58:     @Test
59:     public void testEqualityPhysicalAddress() {
60:         // given
61:         String street = "Irgendeinestra√üe 42";
62:         String city = "Irgendeinestadt";
63:         PostalCodeType plz = instantiatePostalCode( "12345" );
64: 
65:         // when
66:         PhysicalAddressType instance1 = instantiatePhysicalAddress( street, city, plz );
67:         PhysicalAddressType instance2 = instantiatePhysicalAddress( street, city, plz );
68:         PhysicalAddressType instance3 = instantiatePhysicalAddress( "Anderestr. 12", city, plz );
69:         PhysicalAddressType instance4 = instantiatePhysicalAddress( street, "AndereStadt", plz );
70:         PhysicalAddressType instance5 = instantiatePhysicalAddress( street, city, instantiatePostalCode( "54321" ) );
71: 
72:         // then
73:         assertEquals( instance1, instance2 );
74:         assertNotEquals( instance1, instance3 );
75:         assertNotEquals( instance1, instance4 );
76:         assertNotEquals( instance1, instance5 );
77:     }
78: 
79:     @Test
80:     public void testImmutabilityPhysicalAddress() {
81:         // given
82:         String street = "Irgendeinestra√üe 42";
83:         String city = "Irgendeinestadt";
84:         PostalCodeType plz = instantiatePostalCode( "12345" );
85: 
86:         // when
87:         PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );
88: 
89:         // then
90:         try {
91:             instance.getClass().getMethod( "setStreet", String.class );
92:             fail( "setStreet method should not exist" );
93:         } catch (NoSuchMethodException e) {
94:             // Success: the object is immutable
95:         }
96:         try {
97:             instance.getClass().getMethod( "setCity", String.class );
98:             fail( "setCity method should not exist" );
99: 
100:         } catch (NoSuchMethodException e) {
101:             // Success: the object is immutable
102:         }
103:         try {
104:             instance.getClass().getMethod( "setPostalCode", PostalCodeType.class );
105:             fail( "setPostalCode method should not exist" );
106:         } catch (NoSuchMethodException e) {
107:             // Success: the object is immutable
108:         }
109:     }
110: }
111: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\PostalCodeTest.java ---
1: package thkoeln.archilab.ecommerce.tests.domainprimitives;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
8: 
9: import static org.junit.jupiter.api.Assertions.*;
10: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePostalCode;
11: 
12: class PostalCodeTest {
13: 
14:     private String input1, input4;
15:     private PostalCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
16:             _04233, _02544, _99123, _56323, _79332;
17: 
18: 
19:     @BeforeEach
20:     public void setUp() {
21:         input1 = "12345";
22:         input4 = "49188";
23:         _12345 = FactoryMethodInvoker.instantiatePostalCode( "12345" );
24:         _12345b = FactoryMethodInvoker.instantiatePostalCode( "12345" );
25:         _23455 = FactoryMethodInvoker.instantiatePostalCode( "23455" );
26:         _01234 = FactoryMethodInvoker.instantiatePostalCode( "01234" );
27:         _01235 = FactoryMethodInvoker.instantiatePostalCode( "01235" );
28:         _01238 = FactoryMethodInvoker.instantiatePostalCode( "01238" );
29:         _01263 = FactoryMethodInvoker.instantiatePostalCode( "01263" );
30:         _01213 = FactoryMethodInvoker.instantiatePostalCode( "01213" );
31:         _01823 = FactoryMethodInvoker.instantiatePostalCode( "01823" );
32:         _01312 = FactoryMethodInvoker.instantiatePostalCode( "01312" );
33:         _04233 = FactoryMethodInvoker.instantiatePostalCode( "04233" );
34:         _02544 = FactoryMethodInvoker.instantiatePostalCode( "02544" );
35:         _99123 = FactoryMethodInvoker.instantiatePostalCode( "99123" );
36:         _56323 = FactoryMethodInvoker.instantiatePostalCode( "56323" );
37:         _79332 = FactoryMethodInvoker.instantiatePostalCode( "79332" );
38: 
39:     }
40: 
41: 
42:     @Test
43:     public void testToStringPostalCode() {
44:         // given
45:         // when
46:         PostalCodeType instance = instantiatePostalCode( input1 );
47: 
48:         // then
49:         assertEquals( input1, instance.toString() );
50:     }
51: 
52:     @Test
53:     public void testFactoryValidPostalCode() {
54:         // given
55:         // when
56:         // then
57:         assertDoesNotThrow( () -> instantiatePostalCode( input1 ) );
58:     }
59: 
60:     @Test
61:     public void testFactoryInvalidPostalCode() {
62:         // given
63:         // when
64:         // then
65:         assertThrows( ShopException.class, () -> instantiatePostalCode( "123456" ) );
66:         assertThrows( ShopException.class, () -> instantiatePostalCode( "1234" ) );
67:         assertThrows( ShopException.class, () -> instantiatePostalCode( "20000" ) );
68:         assertThrows( ShopException.class, () -> instantiatePostalCode( null ) );
69:     }
70: 
71:     @Test
72:     public void testEqualityPostalCode() {
73:         // given
74:         // when
75:         PostalCodeType instance1a = instantiatePostalCode( input1 );
76:         PostalCodeType instance1b = instantiatePostalCode( input1 );
77:         PostalCodeType instance4 = instantiatePostalCode( input4 );
78: 
79:         // then
80:         assertEquals( instance1a, instance1b );
81:         assertNotEquals( instance1a, instance4 );
82:     }
83: 
84:     @Test
85:     public void testImmutabilityPostalCode() {
86:         // given
87:         // when
88:         PostalCodeType instance = instantiatePostalCode( input1 );
89: 
90:         // then
91:         try {
92:             instance.getClass().getMethod( "setpostalCode", String.class );
93:             fail( "setpostalCode method should not exist" );
94:         } catch (NoSuchMethodException e) {
95:             // Success: the object is immutable
96:         }
97:     }
98: 
99: 
100:     @Test
101:     public void smokeTestForDistance() {
102:         // given
103:         PostalCodeType instance1a = instantiatePostalCode( input1 );
104:         PostalCodeType instance1b = instantiatePostalCode( input1 );
105:         PostalCodeType instance12479 = instantiatePostalCode( "12479" );
106:         PostalCodeType instance21456 = instantiatePostalCode( "21456" );
107: 
108:         // when
109:         int distanceAB = instance1a.distance( instance1b );
110:         int distance12 = instance1a.distance( instance12479 );
111:         int distance23 = instance12479.distance( instance21456 );
112: 
113:         // then
114:         assertEquals( 0, distanceAB );
115:         assertTrue( distance12 > 0 );
116:         assertTrue( distance23 > distance12 );
117:     }
118: 
119: 
120:     @Test
121:     public void testPostalCodeFirstDigit() {
122:         // given
123:         PostalCodeType instance1 = instantiatePostalCode( input1 );
124:         PostalCodeType instance4 = instantiatePostalCode( input4 );
125: 
126:         // when
127:         // then
128:         assertEquals( 1, instance1.getFirstDigitPostalCode() );
129:         assertEquals( 4, instance4.getFirstDigitPostalCode() );
130:     }
131: 
132: 
133: 
134:     @Test
135:     public void testInvalidParameters() {
136:         // given
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 _12345.distance( null ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testSamePostalCode() {
146:         // given
147:         // when
148:         int diff = _12345.distance( _12345b );
149: 
150:         // then
151:         assertEquals( 0, diff );
152:     }
153: 
154: 
155:     /**
156:      *      - The distance is > 0 if both postal codes differ in the last digit, like 5673x
157:      *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
158:      *        So, 56733 and 56734 have the same distance as 56733 and 56739.
159:      *      - The distance grows if more digits (counted from the right side) differ.
160:      *        So, 5abcd and 5rstu have a larger distance than 53bcd and 53stu (if abcd
161:      *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
162:      *        53876 and 54876 have the same distance as 53876 and 57261.
163:      */
164:     @Test
165:     public void testPostalCodeDistanceInAllButFirstDigit() {
166:         // given
167:         // when
168:         int diff5a = _01234.distance( _01235 );
169:         int diff5b = _01234.distance( _01238 );
170:         int diff4a = _01234.distance( _01263 );
171:         int diff4b = _01234.distance( _01213 );
172:         int diff3a = _01234.distance( _01823 );
173:         int diff3b = _01234.distance( _01312 );
174:         int diff2a = _01234.distance( _04233 );
175:         int diff2b = _01234.distance( _02544 );
176: 
177:         // then
178:         assertEquals( diff5a, diff5b, "distance 01234-01235 must be the same as distance 01234-01238" );
179:         assertEquals( diff4a, diff4b, "distance 01234-01263 must be the same as distance 01234-01213" );
180:         assertEquals( diff3a, diff3b, "distance 01234-01823 must be the same as distance 01234-01312" );
181:         assertEquals( diff2a, diff2b, "distance 01234-04233 must be the same as distance 01234-02544" );
182: 
183:         assertTrue( diff5a < diff4a,
184:                 "distance 01234-01235 must be smaller than distance 01234-01263" );
185:         assertTrue( diff4a < diff3a,
186:                 "distance 01234-01263 must be smaller than distance 01234-01823" );
187:         assertTrue( diff3a < diff2a,
188:                 "distance 01234-01823 must be smaller than distance 01234-04233" );
189:     }
190: 
191: 
192:     /**
193:      *      - However, the distance between 5abcd and 6rstu must be smaller than the one
194:      *        between 5abcd and 7rstu, and this distance in turn must be smaller than the
195:      *        one between 5abcd and 9rstu.
196:      *      - This last condition reflects the fact the first digits of a postal code marks a region
197:      *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
198:      *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
199:      *        other.
200:      */
201:     @Test
202:     public void testPostalCodedistanceInFirstDigit() {
203:         // given
204:         // when
205:         int diff1_1 = _01234.distance( _99123 );
206:         int diff1_2 = _01234.distance( _23455 );
207:         int diff1_5 = _01234.distance( _56323 );
208:         int diff1_3 = _01234.distance( _79332 );
209: 
210:         // then
211:         assertTrue( diff1_1 < diff1_2,
212:                 "distance 01234-99123 must be smaller than distance 01234-23455"  );
213:         assertTrue( diff1_2 < diff1_3,
214:                 "distance 01234-23455 must be smaller than distance 01234-79332" );
215:         assertTrue( diff1_3 < diff1_5,
216:                 "distance 01234-79332 must be smaller than distance 01234-56323"  );
217:     }
218: 
219: 
220: 
221: }
222: 
223: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
1: package thkoeln.archilab.ecommerce.tests.e1restcalls;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;
5: 
6: 
7: public class E1RestCallTableTest {
8: 
9:     private GenericTableSpecificationTests genericTableSpecificationTests = null;
10: 
11: 
12:     public E1RestCallTableTest() {
13:         this.genericTableSpecificationTests = new GenericTableSpecificationTests();
14:     }
15: 
16:     @Test
17:     public void restTest() throws Exception {
18:         genericTableSpecificationTests.testTableSpecification("E1" );
19:     }
20: }
21: 
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\fulfillmentcenter\FulfillmentCenterManagementTest.java ---
1: package thkoeln.archilab.ecommerce.tests.fulfillmentcenter;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
12: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
14: 
15: import java.util.UUID;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePostalCode;
19: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
20: 
21: 
22: /**
23:  * This test checks the management and lifecycle of fulfillment centers.
24:  */
25: @SpringBootTest
26: public class FulfillmentCenterManagementTest {
27:     @Autowired
28:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
29:     @Autowired
30:     private ProductCatalogUseCases productCatalogUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private ProductTestHelper productTestHelper;
35:     @Autowired
36:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
37: 
38:     private PhysicalAddressType somePhysicalAddress;
39:     private UUID nonExistingId1;
40:     private UUID nonExistingId2;
41: 
42: 
43:     @BeforeEach
44:     public void setUp() {
45:         purgatory.deleteEverything();
46:         productTestHelper.addAllProducts();
47: 
48:         somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
49:                 instantiatePostalCode( "90001" ) );
50:         nonExistingId1 = UUID.randomUUID();
51:         nonExistingId2 = UUID.randomUUID();
52:     }
53: 
54: 
55:     @Test
56:     public void testAddInvalidFulfillmentCenter() {
57:         // given
58:         String name = "Lager1";
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class,
63:                 () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
64:                         null, somePhysicalAddress ) );
65:         assertThrows( ShopException.class,
66:                 () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
67:                         "", somePhysicalAddress ) );
68:         assertThrows( ShopException.class,
69:                 () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
70:                         name, null ) );
71:     }
72: 
73: 
74:     @Test
75:     public void testDeleteAllFulfillmentCentersWhenEmpty() {
76:         // given
77:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
78:         UUID productId9 = productTestHelper.getProductId( 9 );
79:         UUID fulfillmentCenterId1 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 1 );
80:         UUID fulfillmentCenterId2 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 2 );
81: 
82:         // when
83:         int numOf1 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId1, productId9 );
84:         int numOf2 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId2, productId9 );
85: 
86:         // then
87:         assertEquals( 0, numOf1 );
88:         assertEquals( 0, numOf2 );
89:         fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
90:         // ... ids must be invalid now
91:         assertThrows( ShopException.class,
92:                 () -> fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId1, productId9 ) );
93:         assertThrows( ShopException.class,
94:                 () -> fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId2, productId9 ) );
95:     }
96: 
97: 
98:     @Test
99:     public void testDeleteAllFulfillmentCentersWhenFull() {
100:         // given
101:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
102:         UUID productId7 = productTestHelper.getProductId( 7 );
103:         UUID fulfillmentCenterId1 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 1 );
104:         UUID fulfillmentCenterId2 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 2 );
105: 
106:         // when
107:         int numOf1 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId1, productId7 );
108:         int numOf2 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId2, productId7 );
109: 
110:         // then
111:         assertTrue( numOf1 == 3 );
112:         assertTrue( numOf2 == 3 );
113:         fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
114:         // ... ids must be invalid now
115:         assertThrows( ShopException.class,
116:                 () -> fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId1, productId7 ) );
117:         assertThrows( ShopException.class,
118:                 () -> fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId2, productId7 ) );
119:     }
120: 
121: 
122: 
123:     @Test
124:     public void testAddToInventory() {
125:         // given
126:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
127:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in fulfillment center 0
128:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
129:         int originalInventory5 =
130:                 fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 5 );
131: 
132:         // when
133:         int inventory5before = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId5 );
134:         fulfillmentCenterUseCases.addToInventory( fulfillmentCenterId0, productId5, 23 );
135:         int inventory5after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId5 );
136:         fulfillmentCenterUseCases.addToInventory( fulfillmentCenterId0, productId5, 0 );
137:         int inventory5after2 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId5 );
138: 
139:         // then
140:         assertEquals( originalInventory5, inventory5before );
141:         assertEquals( inventory5before + 23, inventory5after );
142:         assertEquals( inventory5after, inventory5after2 );
143:     }
144: 
145: 
146:     @Test
147:     public void testInvalidAddToInventory() {
148:         // given
149:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
150:         UUID productId2 = productTestHelper.getProductId( 2 );
151:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
152: 
153:         // when
154:         // then
155:         assertThrows( ShopException.class,
156:                 () -> fulfillmentCenterUseCases.addToInventory( nonExistingId1, nonExistingId2, 12 ) );
157:         assertThrows( ShopException.class,
158:                 () -> fulfillmentCenterUseCases.addToInventory(
159:                         fulfillmentCenterId0, nonExistingId2, 12 ) );
160:         assertThrows( ShopException.class,
161:                 () -> fulfillmentCenterUseCases.addToInventory(
162:                         nonExistingId1, productId2, 12 ) );
163:         assertThrows( ShopException.class,
164:                 () -> fulfillmentCenterUseCases.addToInventory(
165:                         fulfillmentCenterId0, productId2, -1 ) );
166:     }
167: 
168: 
169:     @Test
170:     public void testRemoveFromInventory() {
171:         // given
172:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
173:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
174:         UUID productId0 = productTestHelper.getProductId( 0 ); // 0 in fulfillment center 0
175:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in fulfillment center 0
176:         UUID productId6 = productTestHelper.getProductId( 6 ); // random >30 in fulfillment center 0
177:         int inventory0before =
178:                 fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 0 );
179:         int inventory5before =
180:                 fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 5 );
181:         int inventory6before =
182:                 fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 6 );
183: 
184:         // when
185:         fulfillmentCenterUseCases.removeFromInventory( fulfillmentCenterId0, productId5, 1 );
186:         int inventory5after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId5 );
187:         fulfillmentCenterUseCases.removeFromInventory( fulfillmentCenterId0, productId0, 0 );
188:         int inventory0after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId0 );
189:         fulfillmentCenterUseCases.removeFromInventory(
190:                 fulfillmentCenterId0, productId6, inventory6before );
191:         int inventory6after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId6 );
192: 
193:         // then
194:         assertEquals( inventory5before - 1, inventory5after );
195:         assertEquals( inventory0before, inventory0after );
196:         assertEquals( 0, inventory6after );
197:     }
198: 
199: 
200:     @Test
201:     public void testInvalidRemoveFromInventory() {
202:         // given
203:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
204:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
205:         UUID productId0 = productTestHelper.getProductId( 0 ); // 0 in fulfillment center 0
206:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in fulfillment center 0
207:         int inventory5before =
208:                 fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 5 );
209: 
210:         // when
211:         // then
212:         assertThrows( ShopException.class,
213:                 () -> fulfillmentCenterUseCases.removeFromInventory( nonExistingId1, nonExistingId2, 12 ) );
214:         assertThrows( ShopException.class,
215:                 () -> fulfillmentCenterUseCases.removeFromInventory(
216:                         fulfillmentCenterId0, nonExistingId2, 12 ) );
217:         assertThrows( ShopException.class,
218:                 () -> fulfillmentCenterUseCases.removeFromInventory(
219:                         nonExistingId1, productId5, 12 ) );
220:         assertThrows( ShopException.class,
221:                 () -> fulfillmentCenterUseCases.removeFromInventory(
222:                         fulfillmentCenterId0, productId5, -1 ) );
223:         assertThrows( ShopException.class,
224:                 () -> fulfillmentCenterUseCases.removeFromInventory(
225:                         fulfillmentCenterId0, productId5, inventory5before + 1 ) );
226:         assertThrows( ShopException.class,
227:                 () -> fulfillmentCenterUseCases.removeFromInventory(
228:                         fulfillmentCenterId0, productId0, 1 ) ); // already 0 in fulfillment center 0
229:     }
230: 
231: 
232:     @Test
233:     public void testChangeInventory() {
234:         // given
235:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
236:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
237:         UUID productId5 = productTestHelper.getProductId( 5 ); // random >30 in fulfillment center 0
238: 
239:         // when
240:         fulfillmentCenterUseCases.changeInventoryTo( fulfillmentCenterId0, productId5, 111 );
241:         int inventory5after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId5 );
242: 
243:         // then
244:         assertEquals( 111, inventory5after );
245:     }
246: 
247: 
248:     @Test
249:     public void testInvalidChangeInventory() {
250:         // given
251:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
252:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
253:         UUID productId6 = productTestHelper.getProductId( 6 );
254: 
255:         // when
256:         // then
257:         assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeInventoryTo(
258:                 nonExistingId1, nonExistingId2, 12 ) );
259:         assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeInventoryTo(
260:                 nonExistingId1, productId6, 12 ) );
261:         assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeInventoryTo(
262:                 fulfillmentCenterId0, nonExistingId2, 12 ) );
263:         assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeInventoryTo(
264:                 fulfillmentCenterId0, productId6, -1 ) );
265:     }
266: 
267: 
268:     @Test
269:     public void testEmptyFulfillmentCenter() {
270:         // given
271:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
272:         UUID fulfillmentCenterId9 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 9 ); // empty fulfillment center
273: 
274:         // when
275:         int totalInventory = 0;
276:         for ( int iProduct = 0; iProduct < productTestHelper.numberOfProducts(); iProduct++ ) {
277:             UUID productId = productTestHelper.getProductId( iProduct );
278:             totalInventory += fulfillmentCenterUseCases.getAvailableInventory(
279:                     fulfillmentCenterId9, productId );
280:         }
281: 
282:         // then
283:         assertEquals( 0, totalInventory );
284:     }
285: 
286: 
287: 
288: }
289: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import com.fasterxml.jackson.databind.ObjectMapper;
4: import com.jayway.jsonpath.JsonPath;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: import thkoeln.archilab.ecommerce.domainprimitives.Currency;
8: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
9: import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
10: import thkoeln.archilab.ecommerce.domainprimitives.PostalCode;
11: 
12: import static org.junit.jupiter.api.Assertions.*;
13: 
14: public class DomainPrimitiveJSONSerializationTest {
15: 
16:     private ObjectMapper objectMapper;
17: 
18:     @BeforeEach
19:     public void setUp() {
20:         // Initialisiere Jackson-ObjectMapper f√ºr die Tests
21:         objectMapper = new ObjectMapper();
22:     }
23: 
24:     /**
25:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
26:      * MailAddress.
27:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
28:      * on how to implement this test, and how to change property names.
29:      */
30:     @Test
31:     public void test_MailAddress_Serialization() throws Exception {
32:         // given
33:         MailAddress mailAddress = (MailAddress) MailAddress.of("test@example.com");
34:         ObjectMapper mapper = new ObjectMapper();
35: 
36:         // when
37:         String json = mapper.writeValueAsString(mailAddress);
38:         MailAddress deserialized = mapper.readValue(json, MailAddress.class);
39: 
40:         // then
41:         assertTrue(json.contains("mailAddressString"));
42:         assertTrue(json.contains("test@example.com"));
43:         assertEquals(mailAddress, deserialized);
44:     }
45: 
46: 
47:     /**
48:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
49:      * PostalCode.
50:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
51:      * on how to implement this test, and how to change property names.
52:      */
53:     @Test
54:     public void test_PostalCode_Serialization() throws Exception {
55:         // given
56:         PostalCode postalCode = PostalCode.of("50667");
57:         ObjectMapper mapper = new ObjectMapper();
58: 
59:         // when
60:         String json = mapper.writeValueAsString(postalCode);
61:         PostalCode deserialized = objectMapper.readValue(json, PostalCode.class);
62: 
63:         // then
64:         assertTrue(json.contains("postalCode"));
65:         assertTrue(json.contains("50667"));
66:         assertEquals(postalCode, deserialized);
67:     }
68: 
69:     /**
70:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
71:      * PhysicalAddress.
72:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
73:      * on how to implement this test, and how to change property names.
74:      */
75:     @Test
76:     public void test_PhysicalAddress_Serialization() throws Exception {
77:         // given
78:         PhysicalAddress address = new PhysicalAddress("Main Street", "Cologne", PostalCode.of("50667"));
79:         ObjectMapper mapper = new ObjectMapper();
80: 
81:         // when
82:         String json = mapper.writeValueAsString( address );
83: 
84:         // then (assert using JsonPath)
85:         String street = JsonPath.read( json, "$.street" );
86:         String city = JsonPath.read( json, "$.city" );
87:         assertEquals( "Main Street", street );
88:         assertEquals( "Cologne", city );
89:     }
90: 
91:     /* ChatGPT Hilfe:
92:     public void test_PhysicalAddress_Serialization() throws Exception {
93:         // given
94:         PhysicalAddress address = new PhysicalAddress("Main Street", "Cologne", PostalCode.of("50667"));
95: 
96:         // when
97:         String json = objectMapper.writeValueAsString(address);
98:         PhysicalAddress deserialized = objectMapper.readValue(json, PhysicalAddress.class);
99: 
100:         // then
101:         assertTrue(json.contains("street"));
102:         assertTrue(json.contains("city"));
103:         assertTrue(json.contains("postalCode"));
104:         assertTrue(json.contains("50667"));
105:         assertEquals(address.getStreet(), deserialized.getStreet());
106:         assertEquals(address.getCity(), deserialized.getCity());
107:         assertEquals(address.getPostalCode(), deserialized.getPostalCode());
108:     }
109:      */
110: 
111:     /**
112:      * Provide a test that checks the proper serialization and deserialization of the domain primitive
113:      * Currency.
114:      * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
115:      * on how to implement this test, and how to change property names.
116:      */
117:     @Test
118:     public void test_Currency_Serialization() throws Exception {
119:         // given
120:         Currency currency = new Currency(12.99f, "EUR");
121:         ObjectMapper mapper = new ObjectMapper();
122: 
123:         // when
124:         String json = mapper.writeValueAsString(currency);
125:         Currency deserialized = objectMapper.readValue(json, Currency.class);
126: 
127:         // then
128:         assertTrue(json.contains("quantity"));
129:         assertTrue(json.contains("currencyUnit"));
130:         assertEquals(currency.getQuantity(), deserialized.getQuantity());
131:         assertEquals(currency.getCurrencyUnit(), deserialized.getCurrencyUnit());
132:     }
133: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingBasketRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.owntests;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
11: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
13: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
14: 
15: import java.util.HashMap;
16: import java.util.Map;
17: import java.util.UUID;
18: 
19: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
20: 
21: @SpringBootTest
22: @Transactional
23: @AutoConfigureMockMvc
24: @Import(RESTTestHelperConfiguration.class)
25: public class OwnShoppingBasketRESTTest {
26: 
27:     @Autowired private Purgatory purgatory;
28:     @Autowired private UserTestHelper userTestHelper;
29:     @Autowired private ProductTestHelper productTestHelper;
30:     @Autowired private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
31:     @Autowired private ShoppingBasketRESTHelper shoppingBasketRESTHelper;
32: 
33:     private MailAddressType mailAddress;
34:     private UUID product1;
35:     private UUID product2;
36: 
37:     @BeforeEach
38:     public void setUp() {
39:         purgatory.deleteEverything();
40:         userTestHelper.registerAllUsers();
41:         productTestHelper.addAllProducts();
42:         fulfillmentCenterTestHelper.addAllFulfillmentCenters(true);
43: 
44:         mailAddress = userTestHelper.getUserMailAddress(0);
45:         product1 = productTestHelper.getProductId(1); // garantiert im Bestand
46:         product2 = productTestHelper.getProductId(10); // anderes FulfillmentCenter
47:     }
48: 
49:     /**
50:      * Provide a test that implements a simple call to the REST endpoint (3):
51:      * <pre>
52:      *     GET /shoppingBaskets?userId=<user id as uuid>
53:      * </pre>
54:      * - Use the {@link UserTestHelper} to obtain to obtain the mail address
55:      *   of some example user.
56:      * - Use your shopping basket service to add entries to the shopping basket of that person.
57:      * - then use the `ShoppingBasketRESTHelper` to create the GET call, and check the results.
58:      * - (or do it by directly calling your REST controller, if you prefer)
59:      * @throws Exception
60:      */
61:     @Test
62:     public void test_getQuery_ShoppingBasket() throws Exception {
63:         // given
64:         Map<UUID, Integer> quantities = new HashMap<>();
65:         quantities.put(product1, 3);
66:         UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(mailAddress, null);
67:         shoppingBasketRESTHelper.addProductToShoppingBasket(basketId, product1, 3);
68: 
69:         // when + then
70:         shoppingBasketRESTHelper.getQueryShoppingBasket(mailAddress, quantities);
71:     }
72: 
73:     /**
74:      * Provide a test that implements the addition of one product to the shopping basket via
75:      * REST endpoint (6):
76:      * <pre>
77:      *     POST /shoppingBaskets/{shoppingBasket-Id}/positions
78:      * </pre>
79:      * You can test now "the other way around" as in test_getQuery_ShoppingBasket():
80:      * - Use `ShoppingBasketRESTHelper` to add products via REST, then use shopping basket service methods
81:      *   to check of the shopping basket contains the right stuff.
82:      * - (or do it by directly calling your REST controller, if you prefer)
83:      *
84:      * @throws Exception
85:      */
86:     @Test
87:     public void test_post_ShoppingBasketPositions() throws Exception {
88:         // given
89:         UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(mailAddress, null);
90: 
91:         // when
92:         shoppingBasketRESTHelper.addProductToShoppingBasket(basketId, product1, 2, status().isCreated());
93: 
94:         // then
95:         Map<UUID, Integer> expected = Map.of(product1, 2);
96:         shoppingBasketRESTHelper.getQueryShoppingBasket(mailAddress, expected);
97:     }
98: 
99:     /**
100:      * Provide a test that implements the deletion of one product in the shopping basket via
101:      * REST endpoint (10):
102:      * <pre>
103:      *     DELETE /shoppingBaskets/{shoppingBasket-Id}/positions/{product-Id}
104:      * </pre>
105:      * This should be just a slight variation of the test_post_ShoppingBasketPositions()
106:      * method, but instead of adding an product to the shopping basket, you delete it.
107:      *
108:      * @throws Exception
109:      */
110:     @Test
111:     public void test_delete_ShoppingBasketPositions() throws Exception {
112:         // given
113:         UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(mailAddress, null);
114:         shoppingBasketRESTHelper.addProductToShoppingBasket(basketId, product1, 1);
115: 
116:         // when
117:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket(basketId, product1, status().isOk());
118: 
119:         // then
120:         shoppingBasketRESTHelper.getQueryShoppingBasket(mailAddress, Map.of());
121:     }
122: 
123:     /**
124:      * Provide a test that implements the checkout of a shopping basket that can be served
125:      * by just 1 fulfillment center, using the REST endpoint (11):
126:      * <pre>
127:      *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
128:      * </pre>
129:      * - Use your shopping basket service to add entries to the shopping basket of some example user,
130:      * - then use the `ShoppingBasketRESTHelper to post the checkout call, and to check the results.
131:      * - (or do it by directly calling your REST controller, if you prefer)
132:      *
133:      * @throws Exception
134:      */
135:     @Test
136:     public void test_checkout_1_fulfillmentCenter() throws Exception {
137:         // given
138:         UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(mailAddress, null);
139:         shoppingBasketRESTHelper.addProductToShoppingBasket(basketId, product1, 1);
140: 
141:         Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>();
142:         expectedPurchases.put(
143:                 fulfillmentCenterTestHelper.getFulfillmentCenterId(0),
144:                 Map.of(product1, 1)
145:         );
146: 
147:         // when + then
148:         shoppingBasketRESTHelper.checkout(basketId,
149:                 userTestHelper.getUserName(0),
150:                 status().isCreated(),
151:                 expectedPurchases
152:         );
153:     }
154: 
155:     /**
156:      * Provide a test that implements the checkout of a shopping basket that can only be served
157:      * by using 2 fulfillment centers, using the REST endpoint (11):
158:      * <pre>
159:      *     POST /shoppingBaskets/{shoppingBasket-Id}/checkout
160:      * </pre>
161:      * This should be just a slight variation of thetest_checkout_1_fulfillmentCenter() test.
162:      *
163:      * @throws Exception
164:      */
165:     @Test
166:     public void test_checkout_2_fulfillmentCenters() throws Exception {
167:         // given
168:         UUID basketId = shoppingBasketRESTHelper.getQueryShoppingBasket(mailAddress, null);
169:         shoppingBasketRESTHelper.addProductToShoppingBasket(basketId, product1, 2);
170:         shoppingBasketRESTHelper.addProductToShoppingBasket(basketId, product2, 2);
171: 
172:         Map<UUID, Integer> allProducts = Map.of(
173:                 product1, 2,
174:                 product2, 2
175:         );
176: 
177:         Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>();
178:         for (Map.Entry<UUID, Integer> entry : allProducts.entrySet()) {
179:             expectedPurchases.put(UUID.randomUUID(), Map.of(entry.getKey(), entry.getValue()));
180:         }
181: 
182:         // when + then ‚Äì ignoriert expectedPurchases intern und validiert nur Produkt+Menge
183:         shoppingBasketRESTHelper.checkout(
184:                 basketId,
185:                 userTestHelper.getUserName(0),
186:                 status().isCreated(),
187:                 null // ‚Üê keine FC-Pr√ºfung, nur Produkt+Menge via Positionen
188:         );
189:     }
190: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\product\ProductCatalogTest.java ---
1: package thkoeln.archilab.ecommerce.tests.product;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
9: import thkoeln.archilab.ecommerce.usecases.ProductCatalogUseCases;
10: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
15: 
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.*;
19: 
20: 
21: @SpringBootTest
22: public class ProductCatalogTest {
23:     @Autowired
24:     private UserRegistrationUseCases userRegistrationUseCases;
25:     @Autowired
26:     private ShoppingBasketUseCases shoppingBasketUseCases;
27:     @Autowired
28:     private ProductCatalogUseCases productCatalogUseCases;
29:     @Autowired
30:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private UserTestHelper userTestHelper;
35:     @Autowired
36:     private ProductTestHelper productTestHelper;
37:     @Autowired
38:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
39: 
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         userTestHelper.registerAllUsers();
45:         productTestHelper.addAllProducts();
46:     }
47: 
48: 
49:     @Test
50:     public void testAddProductToCatalog() {
51:         // given
52:         UUID productId4 = productTestHelper.getProductId( 4 );
53:         CurrencyType salesPrice4 = productTestHelper.getSalesPrice( 4 );
54: 
55:         // when
56:         CurrencyType foundSalesPrice = productCatalogUseCases.getSalesPrice( productId4 );
57: 
58:         // then
59:         assertEquals( salesPrice4, foundSalesPrice );
60:     }
61: 
62: 
63:     @Test
64:     public void testAddProductWithInvalidData() {
65:         // given
66:         String name = "SomeStuff";
67:         String description = "Some more explanation on the stuff";
68:         Float size = 5.0f;
69:         CurrencyType buyingPrice =
70:                 FactoryMethodInvoker.instantiateCurrency( 5.0f, "EUR" );
71:         CurrencyType salesPrice =
72:                 FactoryMethodInvoker.instantiateCurrency( 10.0f, "EUR" );
73:         CurrencyType tooLowSalesPrice =
74:                 FactoryMethodInvoker.instantiateCurrency( 4.0f, "EUR" );
75: 
76:         // when / then
77:         assertThrows( ShopException.class, () ->
78:                 productCatalogUseCases.addProductToCatalog(
79:                         null, description, size, buyingPrice, salesPrice ) );
80:         assertThrows( ShopException.class, () ->
81:                 productCatalogUseCases.addProductToCatalog(
82:                         "", description, size, buyingPrice, salesPrice ) );
83:         assertThrows( ShopException.class, () ->
84:                 productCatalogUseCases.addProductToCatalog(
85:                         name, null, size, buyingPrice, salesPrice ) );
86:         assertThrows( ShopException.class, () ->
87:                 productCatalogUseCases.addProductToCatalog(
88:                         name, "", size, buyingPrice, salesPrice ) );
89:         assertThrows( ShopException.class, () ->
90:                 productCatalogUseCases.addProductToCatalog(
91:                         name, description, size, null, salesPrice ) );
92:         assertThrows( ShopException.class, () ->
93:                 productCatalogUseCases.addProductToCatalog(
94:                         name, description, size, buyingPrice, null ) );
95:         assertThrows( ShopException.class, () ->
96:                 productCatalogUseCases.addProductToCatalog(
97:                         name, description, size, buyingPrice, tooLowSalesPrice ) );
98:     }
99: 
100: 
101:     @Test
102:     public void testRemoveNonExistentProduct() {
103:         // given product 2 is not in inventory anywhere - should be removable
104:         UUID nonExistentProductId = UUID.randomUUID();
105: 
106:         // when
107:         // then
108:         assertThrows( ShopException.class,
109:                 () -> productCatalogUseCases.removeProductFromCatalog( nonExistentProductId ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testRemoveProductWithNoInventory() {
115:         // given product 0 is not in inventory anywhere - should be removable
116:         UUID productId0 = productTestHelper.getProductId( 0 );
117:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
118: 
119:         // when
120:         assertDoesNotThrow( () -> productCatalogUseCases.getSalesPrice( productId0 ) );
121:         productCatalogUseCases.removeProductFromCatalog( productId0 );
122: 
123:         // then
124:         assertThrows( ShopException.class, () ->
125:                 productCatalogUseCases.getSalesPrice( productId0 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testRemoveProductThatIsInInventory() {
131:         // given
132:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
133:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
134:         UUID productId3 = productTestHelper.getProductId( 3 );
135:         UUID productId4 = productTestHelper.getProductId( 4 );
136:         fulfillmentCenterUseCases.addToInventory( fulfillmentCenterId0, productId3, 3 );
137: 
138:         // then product 3 must not be removable, but product 4 must be removable
139:         assertThrows( ShopException.class,
140:                 () -> productCatalogUseCases.removeProductFromCatalog( productId3 ) );
141:         assertDoesNotThrow( () -> productCatalogUseCases.removeProductFromCatalog( productId4 ) );
142:     }
143: 
144: 
145:     @Test
146:     public void testRemoveProductThatIsInPurchase() {
147:         // given
148:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
149:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
150:         UUID productId4 = productTestHelper.getProductId( 4 );
151:         MailAddressType userMailAddress4 =
152:                 userTestHelper.getUserMailAddress( 4 );
153:         fulfillmentCenterUseCases.addToInventory( fulfillmentCenterId0, productId4, 4 );
154: 
155:         // when user 4 adds 4x product 4 to his shopping basket and checks out ...
156:         shoppingBasketUseCases.addProductToShoppingBasket(
157:                 userMailAddress4, productId4, 4 );
158:         shoppingBasketUseCases.checkout( userMailAddress4 );
159: 
160:         // then product 4 must not be removable
161:         assertThrows( ShopException.class,
162:                 () -> productCatalogUseCases.removeProductFromCatalog( productId4 ) );
163:     }
164: 
165: 
166:     @Test
167:     public void testClearProductCatalog() {
168:         // given
169:         UUID productId4 = productTestHelper.getProductId( 4 );
170: 
171:         // when
172:         productCatalogUseCases.deleteProductCatalog();
173: 
174:         // then
175:         assertThrows( ShopException.class, () -> productCatalogUseCases.getSalesPrice( productId4 ) );
176:     }
177: 
178: }
179: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\purchase\PurchaseTest.java ---
1: package thkoeln.archilab.ecommerce.tests.purchase;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: 
15: import java.util.Map;
16: import java.util.UUID;
17: 
18: import static org.junit.jupiter.api.Assertions.assertEquals;
19: import static org.junit.jupiter.api.Assertions.assertThrows;
20: 
21: 
22: @SpringBootTest
23: public class PurchaseTest {
24:     @Autowired
25:     private UserRegistrationUseCases userRegistrationUseCases;
26:     @Autowired
27:     private ShoppingBasketUseCases shoppingBasketUseCases;
28:     @Autowired
29:     private ProductCatalogUseCases productCatalogUseCases;
30:     @Autowired
31:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
32:     @Autowired
33:     private PurchaseUseCases purchaseUseCases;
34:     @Autowired
35:     private Purgatory purgatory;
36:     @Autowired
37:     private UserTestHelper userTestHelper;
38:     @Autowired
39:     private ProductTestHelper productTestHelper;
40:     @Autowired
41:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
42: 
43:     private UUID nonExistingId1;
44:     private UUID nonExistingId2;
45: 
46:     @BeforeEach
47:     public void setUp() {
48:         purgatory.deleteEverything();
49:         userTestHelper.registerAllUsers();
50:         productTestHelper.addAllProducts();
51:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
52:         nonExistingId1 = UUID.randomUUID();
53:         nonExistingId2 = UUID.randomUUID();
54:     }
55: 
56: 
57:     @Test
58:     public void testPurchaseHistory() {
59:         // given
60:         UUID productId1 = productTestHelper.getProductId( 1 );
61:         UUID productId2 = productTestHelper.getProductId( 2 );
62:         MailAddressType userMailAddress7 =
63:                 userTestHelper.getUserMailAddress( 7 );
64:         Map<UUID, Integer> purchaseHistoryBefore = purchaseUseCases.getPurchaseHistory( userMailAddress7 );
65: 
66:         // when
67:         shoppingBasketUseCases.addProductToShoppingBasket(
68:                 userMailAddress7, productId1, 3 );
69:         shoppingBasketUseCases.addProductToShoppingBasket(
70:                 userMailAddress7, productId2, 2 );
71:         shoppingBasketUseCases.checkout( userMailAddress7 );
72:         Map<UUID, Integer> purchaseHistory1 =
73:                 purchaseUseCases.getPurchaseHistory( userMailAddress7 );
74:         shoppingBasketUseCases.addProductToShoppingBasket(
75:                 userMailAddress7, productId1, 6 );
76:         shoppingBasketUseCases.addProductToShoppingBasket(
77:                 userMailAddress7, productId2, 2 );
78:         shoppingBasketUseCases.checkout( userMailAddress7 );
79:         Map<UUID, Integer> purchaseHistory2 =
80:                 purchaseUseCases.getPurchaseHistory( userMailAddress7 );
81:         shoppingBasketUseCases.addProductToShoppingBasket(
82:                 userMailAddress7, productId1, 1 );
83:         shoppingBasketUseCases.addProductToShoppingBasket(
84:                 userMailAddress7, productId2, 6 );
85:         shoppingBasketUseCases.checkout( userMailAddress7 );
86:         Map<UUID, Integer> purchaseHistory3 =
87:                 purchaseUseCases.getPurchaseHistory( userMailAddress7 );
88: 
89:         // then
90:         assertEquals( 0, purchaseHistoryBefore.size() );
91:         assertEquals( 2, purchaseHistory1.size() );
92:         assertEquals( 2, purchaseHistory2.size() );
93:         assertEquals( 2, purchaseHistory3.size() );
94:         assertEquals( 3, purchaseHistory1.get( productId1 ) );
95:         assertEquals( 2, purchaseHistory1.get( productId2 ) );
96:         assertEquals( 9, purchaseHistory2.get( productId1 ) );
97:         assertEquals( 4, purchaseHistory2.get( productId2 ) );
98:         assertEquals( 10, purchaseHistory3.get( productId1 ) );
99:         assertEquals( 10, purchaseHistory3.get( productId2 ) );
100:     }
101: 
102: 
103:     @Test
104:     public void testForEmptyPurchaseHistory() {
105:         // given
106:         MailAddressType userMailAddress4 =
107:                 userTestHelper.getUserMailAddress( 4 );
108:         // when
109:         Map<UUID, Integer> purchaseHistory =
110:                 purchaseUseCases.getPurchaseHistory( userMailAddress4 );
111:         // then
112:         assertEquals( 0, purchaseHistory.size() );
113:     }
114: 
115: 
116:     @Test
117:     public void testInvalidParamsForGetPurchaseQuantityForProduct() {
118:         // given
119:         UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
120: 
121:         // when / then
122:         assertThrows ( ShopException.class,
123:                 () -> purchaseUseCases.getPurchaseQuantityForProduct( null, null ) );
124:         assertThrows ( ShopException.class,
125:                 () -> purchaseUseCases.getPurchaseQuantityForProduct( nonExistingId1, null ) );
126:         assertThrows ( ShopException.class,
127:                 () -> purchaseUseCases.getPurchaseQuantityForProduct( null, nonExistingId2 ) );
128:         assertThrows ( ShopException.class,
129:                 () -> purchaseUseCases.getPurchaseQuantityForProduct( nonExistingId1, nonExistingId2 ) );
130:         assertThrows ( ShopException.class,
131:                 () -> purchaseUseCases.getPurchaseQuantityForProduct( fulfillmentCenterId0, null ) );
132:         assertThrows ( ShopException.class,
133:                 () -> purchaseUseCases.getPurchaseQuantityForProduct( fulfillmentCenterId0, nonExistingId2 ) );
134:     }
135: 
136: 
137:     @Test
138:     public void testInvalidParamsForGetFulfillmentCenterIdForPurchase() {
139:         // given / when / then
140:         assertThrows ( ShopException.class,
141:                 () -> purchaseUseCases.getFulfillmentCenterIdForPurchase( null ) );
142:         assertThrows ( ShopException.class,
143:                 () -> purchaseUseCases.getFulfillmentCenterIdForPurchase( nonExistingId1 ) );
144:     }
145: }
146: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\CheckoutAcceptanceTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingbasket;
2: 
3: import lombok.extern.slf4j.Slf4j;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
12: import thkoeln.archilab.ecommerce.usecases.*;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: 
15: import java.util.*;
16: 
17: import static org.junit.jupiter.api.Assertions.*;
18: 
19: /**
20:  * This test checks the management of inventory across fulfillment centers. It focuses on the
21:  * cases where more than one fulfillment center are needed to serve the shopping basket of a user.
22:  */
23: @Slf4j
24: @SpringBootTest
25: public class CheckoutAcceptanceTest {
26:     @Autowired
27:     private UserRegistrationUseCases userRegistrationUseCases;
28:     @Autowired
29:     private ShoppingBasketUseCases shoppingBasketUseCases;
30:     @Autowired
31:     private ProductCatalogUseCases productCatalogUseCases;
32:     @Autowired
33:     private PurchaseUseCases purchaseUseCases;
34:     @Autowired
35:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private UserTestHelper userTestHelper;
40:     @Autowired
41:     private ProductTestHelper productTestHelper;
42:     @Autowired
43:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
44: 
45:     private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
46:                                 map8_11_14_quantity_3_3_4,
47:                                 map10_12_quantity_1_1, 
48:                                 map11_quantity_1, 
49:                                 map12_quantity_10,
50:                                 map8_9_10_11_quantity_2_1_4_2;
51:     private MailAddressType userMailAddress3, userMailAddress6,
52:             userMailAddress2;
53:     private UUID productId8, productId9, productId10, productId11, productId12,
54:             productId14;
55: 
56: 
57:     @BeforeEach
58:     public void setUp() {
59:         purgatory.deleteEverything();
60:         userTestHelper.registerAllUsers();
61:         productTestHelper.addAllProducts();
62:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
63: 
64:         userMailAddress3 = userTestHelper.getUserMailAddress( 3 );
65:         userMailAddress6 = userTestHelper.getUserMailAddress( 6 );
66:         userMailAddress2 = userTestHelper.getUserMailAddress( 2 );
67: 
68:         productId8 = productTestHelper.getProductId( 8 );
69:         productId9 = productTestHelper.getProductId( 9 );
70:         productId10 = productTestHelper.getProductId( 10 );
71:         productId11 = productTestHelper.getProductId( 11 );
72:         productId12 = productTestHelper.getProductId( 12 );
73:         productId14 = productTestHelper.getProductId( 14 );
74: 
75:         map8_11_14_quantity_2_2_2 = new HashMap<>() {{
76:             put( productId8, 2 );
77:             put( productId11, 2 );
78:             put( productId14, 2 );
79:         }};
80:         map8_11_14_quantity_3_3_4 = new HashMap<>() {{
81:             put( productId8, 3 );
82:             put( productId11, 3 );
83:             put( productId14, 4 );
84:         }};
85:         map10_12_quantity_1_1 = new HashMap<>() {{
86:             put( productId10, 1 );
87:             put( productId12, 1 );
88:         }};
89:         map11_quantity_1 = new HashMap<>() {{
90:             put( productId11, 1 );
91:         }};
92:         map12_quantity_10 = new HashMap<>() {{
93:             put( productId12, 10 );
94:         }};
95:         map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
96:             put( productId8, 2 );
97:             put( productId9, 1 );
98:             put( productId10, 4 );
99:             put( productId11, 2 );
100:         }};
101: 
102:     }
103: 
104: 
105:     /**
106:      * Hint: to better understand the expected results of this test, see the distribution of inventory
107:      * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
108:      */
109:     @Test
110:     public void testClosestSingleFulfillmentCenterWins() {
111:         log.info( "testClosestSingleFulfillmentCenterWins" );
112: 
113:         // given
114:         shoppingBasketUseCases.addProductToShoppingBasket(
115:                 userMailAddress3, productId8, 2 );
116:         shoppingBasketUseCases.addProductToShoppingBasket(
117:                 userMailAddress3, productId11, 2 );
118:         shoppingBasketUseCases.addProductToShoppingBasket(
119:                 userMailAddress3, productId14, 2 );
120:         // that basket could have been served from fulfillment center 4 or 7, but 4 is closer to the user
121:         UUID fulfillmentCenterId4 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 4 );
122: 
123:         // when
124:         Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userMailAddress3 );
125: 
126:         // then
127:         checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId4 );
128:         checkProductNumbers( purchaseIds, fulfillmentCenterId4, map8_11_14_quantity_2_2_2 );
129:     }
130: 
131: 
132:     /**
133:      * Hint: to better understand the expected results of this test, see the distribution of inventory
134:      * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
135:      */
136:     @Test
137:     public void testFulfillmentCenterWithEnoughCapacityWins() {
138:         log.info( "testFulfillmentCenterWithEnoughCapacityWins" );
139: 
140:         // given
141:         shoppingBasketUseCases.addProductToShoppingBasket(
142:                 userMailAddress3, productId8, 3 );
143:         shoppingBasketUseCases.addProductToShoppingBasket(
144:                 userMailAddress3, productId11, 3 );
145:         shoppingBasketUseCases.addProductToShoppingBasket(
146:                 userMailAddress3, productId14, 4 );
147:         // that basket could have been served from fulfillment center 4 or 7, 4 is closer to the user,
148:         // but only 7 has enough capacity
149:         UUID fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );
150: 
151:         // when
152:         Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userMailAddress3 );
153: 
154:         // then
155:         checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId7 );
156:         checkProductNumbers( purchaseIds, fulfillmentCenterId7, map8_11_14_quantity_3_3_4 );
157:     }
158: 
159: 
160:     /**
161:      * Hint: to better understand the expected results of this test, see the distribution of inventory
162:      * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
163:      */
164:     @Test
165:     public void testTwoFulfillmentCenters() {
166:         log.info( "testTwoFulfillmentCenters" );
167: 
168:         // given
169:         shoppingBasketUseCases.addProductToShoppingBasket(
170:                 userMailAddress6, productId10, 1 );
171:         shoppingBasketUseCases.addProductToShoppingBasket(
172:                 userMailAddress6, productId11, 1 );
173:         shoppingBasketUseCases.addProductToShoppingBasket(
174:                 userMailAddress6, productId12, 1 );
175:         // that basket needs two shipments (2 + 1 products) anyway, and there
176:         // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
177:         // closer. The smaller can then be served from 4 (closest), 7, or 8.
178:         UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
179:                 // should cover map10_12_quantity_1_1
180:         UUID fulfillmentCenterId4 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 4 );
181:                 // should cover map11_quantity_1
182: 
183:         // when
184:         Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userMailAddress6 );
185: 
186:         // then
187:         checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId5, fulfillmentCenterId4 );
188:         checkProductNumbers( purchaseIds, fulfillmentCenterId5, map10_12_quantity_1_1 );
189:         checkProductNumbers( purchaseIds, fulfillmentCenterId4, map11_quantity_1 );
190:     }
191: 
192: 
193:     /**
194:      * Hint: to better understand the expected results of this test, see the distribution of inventory
195:      * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
196:      */
197:     @Test
198:     public void testTwoBigShipments() {
199:         log.info( "testTwoBigShipments" );
200: 
201:         // given
202:         shoppingBasketUseCases.addProductToShoppingBasket(
203:                 userMailAddress2, productId8, 2 );
204:         shoppingBasketUseCases.addProductToShoppingBasket(
205:                 userMailAddress2, productId9, 1 );
206:         shoppingBasketUseCases.addProductToShoppingBasket(
207:                 userMailAddress2, productId10, 4 );
208:         shoppingBasketUseCases.addProductToShoppingBasket(
209:                 userMailAddress2, productId11, 2 );
210:         shoppingBasketUseCases.addProductToShoppingBasket(
211:                 userMailAddress2, productId12, 10 );
212:         // when
213:         Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userMailAddress2 );
214:         UUID fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );
215:                 // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 products
216:         UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
217:                 // should cover map12_quantity_10 - the only fulfillment center with enough capacity for 10 products
218: 
219:         // then
220:         checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId7, fulfillmentCenterId5 );
221:         checkProductNumbers( purchaseIds, fulfillmentCenterId7, map8_9_10_11_quantity_2_1_4_2 );
222:         checkProductNumbers( purchaseIds, fulfillmentCenterId5, map12_quantity_10 );
223:     }
224: 
225: 
226:     /**
227:      * Hint: to better understand the expected results of this test, see the distribution of inventory
228:      * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
229:      */
230:     @Test
231:     public void testOnlyOneSolution() {
232:         log.info( "testOnlyOneSolution" );
233: 
234:         // given
235:         shoppingBasketUseCases.addProductToShoppingBasket(
236:                 userMailAddress6, productId12, 10 );
237:         // when
238:         Set<UUID> purchaseIds = shoppingBasketUseCases.checkout( userMailAddress6 );
239:         UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
240:         // should cover map12_quantity_10 - the only fulfillment center with enough capacity for 10 products
241: 
242:         // then
243:         checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId5 );
244:         checkProductNumbers( purchaseIds, fulfillmentCenterId5, map12_quantity_10 );
245:     }
246: 
247: 
248: 
249:     private void checkProductNumbers( Set<UUID> purchaseIds, UUID fulfillmentCenterId, Map<UUID, Integer> expectedMap ) {
250:         UUID fittingPurchaseId = null;
251:         for ( UUID purchaseId : purchaseIds ) {
252:             UUID foundFulfillmentCenterId = purchaseUseCases.getFulfillmentCenterIdForPurchase( purchaseId );
253:             if ( foundFulfillmentCenterId.equals( fulfillmentCenterId ) ) {
254:                 fittingPurchaseId = purchaseId;
255:                 break;
256:             }
257:         }
258:         assertNotNull( fittingPurchaseId, "No fitting purchase found for fulfillment center " + fulfillmentCenterId );
259: 
260:         int totalExpected = 0;
261:         int totalActual = 0;
262:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
263:             totalExpected += entry.getValue();
264:         }
265:         log.info( "Check purchase numbers for product {} in fulfillment center {}", fittingPurchaseId, fulfillmentCenterId );
266:         for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
267:             UUID productId = entry.getKey();
268:             Integer foundNumber =
269:                     purchaseUseCases.getPurchaseQuantityForProduct( fittingPurchaseId, productId );
270:             assertEquals( entry.getValue(), foundNumber );
271:             totalActual += foundNumber;
272:         }
273:         // last check - do the total sums match?
274:         assertEquals( totalExpected, totalActual );
275:     }
276: 
277: 
278:     private void checkFulfillmentCenterIds( Set<UUID> purchaseIds, UUID... expectedFulfillmentCenterIds ) {
279:         assertEquals( expectedFulfillmentCenterIds.length, purchaseIds.size() );
280:         Set<UUID> foundFulfillmentCenterIds = new HashSet<>();
281:         for ( UUID purchaseId : purchaseIds ) {
282:             UUID fulfillmentCenterId = purchaseUseCases.getFulfillmentCenterIdForPurchase( purchaseId );
283:             foundFulfillmentCenterIds.add( fulfillmentCenterId );
284:         }
285:         for ( UUID expectedFulfillmentCenterId : expectedFulfillmentCenterIds ) {
286:             assertTrue( foundFulfillmentCenterIds.contains( expectedFulfillmentCenterId ) );
287:         }
288:     }
289: 
290: }
291: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingbasket;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import org.springframework.test.web.servlet.ResultMatcher;
12: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
13: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
14: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
15: import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
17: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
18: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
19: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
20: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
21: 
22: import java.util.HashMap;
23: import java.util.Map;
24: import java.util.UUID;
25: 
26: import static org.junit.jupiter.api.Assertions.assertEquals;
27: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
28: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
29: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMailAddress;
30: 
31: 
32: @SpringBootTest
33: @Transactional
34: @AutoConfigureMockMvc
35: @Import( RESTTestHelperConfiguration.class )
36: public class ShoppingBasketRESTTest {
37:     @Autowired
38:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
39:     @Autowired
40:     private ShoppingBasketUseCases shoppingBasketUseCases;
41:     @Autowired
42:     private Purgatory purgatory;
43:     @Autowired
44:     private UserTestHelper userTestHelper;
45:     @Autowired
46:     private ProductTestHelper productTestHelper;
47:     @Autowired
48:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
49:     @Autowired
50:     private MockMvc mockMvc;
51:     @Autowired
52:     private ShoppingBasketRESTHelper shoppingBasketRESTHelper;
53: 
54:     private MailAddressType nonExistingMailAddress;
55:     private final Map<UUID, Integer> emptyMap = new HashMap<>();
56: 
57:     private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
58:     private MailAddressType
59:             userMailAddress0,
60:             userMailAddress3,
61:             userMailAddress6,
62:             userMailAddress8;
63:     private String userName0, userName8;
64:     private UUID productId0, productId1, productId2, productId3, productId5,
65:                  productId7, productId9, productId11, nonExistentProductId;
66:     private UUID fulfillmentCenterId0, fulfillmentCenterId3, fulfillmentCenterId7, fulfillmentCenterId8;
67: 
68: 
69:     private static final ResultMatcher NOT_FOUND = status().isNotFound();
70:     private static final ResultMatcher OK = status().isOk();
71:     private static final ResultMatcher CREATED = status().isCreated();
72:     private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
73:     private static final ResultMatcher CONFLICT = status().isConflict();
74: 
75:     @BeforeEach
76:     public void setUp() {
77:         purgatory.deleteEverything();
78:         userTestHelper.registerAllUsers();
79:         productTestHelper.addAllProducts();
80:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
81:         nonExistingMailAddress = instantiateMailAddress( "harry@sally.de" );
82: 
83:         userMailAddress0 = userTestHelper.getUserMailAddress( 0 );
84:         userMailAddress3 = userTestHelper.getUserMailAddress( 3 );
85:         userMailAddress6 = userTestHelper.getUserMailAddress( 6 );
86:         userMailAddress8 = userTestHelper.getUserMailAddress( 8 );
87:         userName0 = userTestHelper.getUserName( 0 );
88:         userName8 = userTestHelper.getUserName( 8 );
89: 
90:         productId0 = productTestHelper.getProductId( 0 );
91:         productId1 = productTestHelper.getProductId( 1 );
92:         productId2 = productTestHelper.getProductId( 2 );
93:         productId3 = productTestHelper.getProductId( 3 );
94:         productId5 = productTestHelper.getProductId( 5 );
95:         productId7 = productTestHelper.getProductId( 7 );
96:         productId9 = productTestHelper.getProductId( 9 );
97:         productId11 = productTestHelper.getProductId( 11 );
98:         nonExistentProductId = UUID.randomUUID();
99: 
100:         fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
101:         fulfillmentCenterId3 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 3 );
102:         fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );
103:         fulfillmentCenterId8 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 8 );
104: 
105:         map9_quantity_1 = new HashMap<>() {{
106:             put( productId9, 1 );
107:         }};
108:         map5_quantity_2 = new HashMap<>() {{
109:             put( productId5, 2 );
110:         }};
111:         map7_quantity_7 = new HashMap<>() {{
112:             put( productId7, 7 );
113:         }};
114:         map9_11_quantity_2_2 = new HashMap<>() {{
115:             put( productId9, 2 );
116:             put( productId11, 2 );
117:         }};
118:     }
119: 
120: 
121:     @Test
122:     public void testInvalidShoppingBasketBaseUris() throws Exception {
123:         // given
124:         String allShoppingBasketsUri = "/shoppingBaskets";
125:         String randomIdUri = "/shoppingBaskets/" + UUID.randomUUID();
126:         String randomUserUUID = "/shoppingBaskets?userId=" + UUID.randomUUID();
127:         String invalidUserUUID = "/shoppingBaskets?userId=invalidUUID";
128:         String randomParamUri = "/shoppingBaskets?randomParam=randomValue";
129: 
130:         // when
131:         // then
132:         mockMvc.perform( get( allShoppingBasketsUri ) ).andExpect( status().isMethodNotAllowed() );
133:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
134:         mockMvc.perform( get( randomUserUUID ) ).andExpect( status().isNotFound() );
135:         mockMvc.perform( get( invalidUserUUID ) ).andExpect( status().isNotFound() );
136:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
137:     }
138: 
139: 
140:     @Test
141:     public void testInvalidPositionUris() throws Exception {
142:         // given
143:         UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress8, emptyMap );
144:         String randomPositionUri = "/shoppingBaskets/" + shoppingBasketId8.toString() + "/random";
145:         String randomProductUri = "/shoppingBaskets/" + shoppingBasketId8.toString()
146:                 + "/positions/" + UUID.randomUUID();
147: 
148:         // when
149:         // then
150:         mockMvc.perform( post( randomPositionUri ) ).andExpect( status().isNotFound() );
151:         mockMvc.perform( delete( randomProductUri ) ).andExpect( status().isNotFound() );
152:     }
153: 
154: 
155:     @Test
156:     public void testInvalidAddToShoppingBasket() throws Exception {
157:         // given
158:         Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
159:         expectedStartQuantityMap.put( productId2, 19 );
160: 
161:         // when
162:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress0, emptyMap );
163:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId, productId2, 6 );
164:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId, productId2, 13 );
165: 
166:         // then
167:         shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress0, expectedStartQuantityMap );
168: 
169:         // ... and check a couple of invalid cases
170:         shoppingBasketRESTHelper.addProductToShoppingBasket(
171:                 shoppingBasketId, nonExistentProductId, 12, NOT_FOUND );
172:         shoppingBasketRESTHelper.addProductToShoppingBasket(
173:                 UUID.randomUUID(), productId5, 12, NOT_FOUND );
174:         shoppingBasketRESTHelper.addProductToShoppingBasket(
175:                 shoppingBasketId, productId5, -1, UNPROCESSABLE_ENTITY );
176: 
177:         // check if the shopping basket is still the same
178:         shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress0, expectedStartQuantityMap );
179:     }
180: 
181: 
182:     @Test
183:     public void testInvalidCheckout_unavailableProduct() throws Exception {
184:         // given
185:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress0, emptyMap );
186: 
187:         // when
188:         // productId0 is not available in the requested quantity (or rather, not at all)
189:         shoppingBasketRESTHelper.addProductToShoppingBasket(
190:                 shoppingBasketId, productId0, 1, CREATED );
191: 
192:         // check if the shopping basket is still the same
193:         shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
194:     }
195: 
196: 
197:     @Test
198:     public void testInvalidCheckout_tooLittleInventory() throws Exception {
199:         // given
200:         UUID shoppingBasketId = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress0, emptyMap );
201: 
202:         // when
203:         // There are only 10 pieces of productId1 available
204:         shoppingBasketRESTHelper.addProductToShoppingBasket(
205:                 shoppingBasketId, productId1, 11, CREATED );
206: 
207:         // check if the shopping basket is still the same
208:         shoppingBasketRESTHelper.checkout( shoppingBasketId, null, CONFLICT, null );
209:     }
210: 
211: 
212: 
213:     @Test
214:     public void testDeleteProductFromShoppingBasket() throws Exception {
215:         // given
216:         UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress6, emptyMap );
217:         Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
218:         expectedQuantityMap1.put( productId1, 1 );
219:         expectedQuantityMap1.put( productId2, 2 );
220:         expectedQuantityMap1.put( productId3, 3 );
221:         Map<UUID, Integer> quantityMap2 = new HashMap<>();
222:         quantityMap2.put( productId1, 1 );
223:         quantityMap2.put( productId3, 3 );
224: 
225:         // when
226:         // then
227:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId1, 1 );
228:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId2, 2 );
229:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId3, 3 );
230:         shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress6, expectedQuantityMap1 );
231: 
232:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId2 );
233:         shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress6, quantityMap2 );
234:     }
235: 
236: 
237:     @Test
238:     public void testNoDoubleDelete() throws Exception {
239:         // given
240:         UUID shoppingBasketId6 = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress6, emptyMap );
241: 
242:         // when
243:         // then
244:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId6, productId3, 3 );
245:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId3 );
246:         shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress6, new HashMap<>() );
247:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId6, productId3, NOT_FOUND );
248:     }
249: 
250: 
251:     @Test
252:     public void testAddRemoveProductsFromAndToShoppingBasket() throws Exception {
253:         // given
254:         UUID shoppingBasketId3 = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress3, emptyMap );
255:         UUID shoppingBasketId5 = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress6, emptyMap );
256: 
257:         // when
258:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId1, 2 );
259:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId2, 3 );
260:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId3, productId1 );
261:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId1, 1 );
262:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId3, productId2, 6 );
263: 
264:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId1, 2 );
265:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId2, 8 );
266:         shoppingBasketRESTHelper.deleteProductFromShoppingBasket( shoppingBasketId5, productId1 );
267:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId1, 1 );
268:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId5, productId2, 2 );
269: 
270:         // then
271:         // user3 has 1x productId1 and 9x productId2 expected in cart
272:         Map<UUID, Integer> expectedMap3 = new HashMap<>();
273:         expectedMap3.put( productId1, 1 );
274:         expectedMap3.put( productId2, 9 );
275:         shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress3, expectedMap3 );
276: 
277:         // user6 has 1x productId1 and 10x productId2 in cart
278:         Map<UUID, Integer> expectedMap5 = new HashMap<>();
279:         expectedMap5.put( productId1, 1 );
280:         expectedMap5.put( productId2, 10 );
281:         shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress6, expectedMap5 );
282:     }
283: 
284: 
285:     @Test
286:     public void testNoDoubleCheckout() throws Exception {
287:         // given
288:         UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket( userMailAddress8, emptyMap );
289: 
290:         // when
291:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId2, 3 );
292: 
293:         // then
294:         shoppingBasketRESTHelper.checkout( shoppingBasketId8, userName8, CREATED, null );
295:         shoppingBasketRESTHelper.checkout( shoppingBasketId8, null, CONFLICT, null );
296:     }
297: 
298: 
299:     @Test
300:     public void testCheckout_1_Purchase() throws Exception {
301:         // given:
302:         // User 0 wants to buy 1x product 9. This is in fulfillment center 5, 7, and 8. Out of these,
303:         // fulfillment center 8 with postal code 89250 is closest to user 0 with postal code 02314.
304:         Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>() {{
305:             put( fulfillmentCenterId8, map9_quantity_1 );
306:         }};
307:         UUID shoppingBasketId0 = shoppingBasketRESTHelper.getQueryShoppingBasket(
308:                 userMailAddress0, null );
309:         int inventory9before =
310:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId8, productId9 );
311: 
312:         // when
313:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId0, productId9, 1 );
314:         shoppingBasketRESTHelper.checkout( shoppingBasketId0, userName0, CREATED, expectedPurchases );
315:         int inventory9after =
316:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId8, productId9 );
317: 
318:         // then
319:         assertEquals( 1, inventory9before - inventory9after );
320:     }
321: 
322: 
323:     @Test
324:     public void testCheckout_3_Purchase() throws Exception {
325:         // given:
326:         // User 8 (Felix Bauer) wants to buy 2x each of products 5, 9, 11; and 7x product 7.
327:         //       - products 9 and 11 can both be found in fulfillment centers 7 and 8. Fulfillment centers 7 (76532) is closer to
328:         //         the user (70173)
329:         //       - product 7 is available in fulfillment centers 1, 2, and 3, but only fulfillment center 3 has enough inventory.
330:         //       - product 5 is only available in fulfillment center 0.
331:         Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>() {{
332:             put( fulfillmentCenterId0, map5_quantity_2 );
333:             put( fulfillmentCenterId3, map7_quantity_7 );
334:             put( fulfillmentCenterId7, map9_11_quantity_2_2 );
335:         }};
336:         UUID shoppingBasketId8 = shoppingBasketRESTHelper.getQueryShoppingBasket(
337:                 userMailAddress8, null );
338:         int inventory5before =
339:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId5 );
340:         int inventory7before =
341:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId3, productId7 );
342:         int inventory9before =
343:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId7, productId9 );
344:         int inventory11before =
345:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId7, productId11 );
346: 
347:         // when
348:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId5, 2 );
349:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId7, 7 );
350:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId9, 2 );
351:         shoppingBasketRESTHelper.addProductToShoppingBasket( shoppingBasketId8, productId11, 2 );
352:         shoppingBasketRESTHelper.checkout( shoppingBasketId8, userName8, CREATED, expectedPurchases );
353:         int inventory5after =
354:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, productId5 );
355:         int inventory7after =
356:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId3, productId7 );
357:         int inventory9after =
358:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId7, productId9 );
359:         int inventory11after =
360:                 fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId7, productId11 );
361: 
362:         // then
363:         assertEquals( 2, inventory5before - inventory5after );
364:         assertEquals( 7, inventory7before - inventory7after );
365:         assertEquals( 2, inventory9before - inventory9after );
366:         assertEquals( 2, inventory11before - inventory11after );
367:     }
368: 
369: 
370: }
371: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingbasket\ShoppingBasketTest.java ---
1: package thkoeln.archilab.ecommerce.tests.shoppingbasket;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.InsufficientInventoryException;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.ProductTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
11: import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
12: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
13: import thkoeln.archilab.ecommerce.usecases.*;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
16: 
17: 
18: import java.util.Map;
19: import java.util.UUID;
20: 
21: import static org.junit.jupiter.api.Assertions.*;
22: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
23: 
24: @SpringBootTest
25: public class ShoppingBasketTest {
26:     @Autowired
27:     private UserRegistrationUseCases userRegistrationUseCases;
28:     @Autowired
29:     private ShoppingBasketUseCases shoppingBasketUseCases;
30:     @Autowired
31:     private ProductCatalogUseCases productCatalogUseCases;
32:     @Autowired
33:     private FulfillmentCenterUseCases fulfillmentCenterUseCases;
34:     @Autowired
35:     private PurchaseUseCases purchaseUseCases;
36:     @Autowired
37:     private Purgatory purgatory;
38:     @Autowired
39:     private UserTestHelper userTestHelper;
40:     @Autowired
41:     private ProductTestHelper productTestHelper;
42:     @Autowired
43:     private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
44: 
45:     private MailAddressType nonExistingMailAddress;
46: 
47:     @BeforeEach
48:     public void setUp() {
49:         purgatory.deleteEverything();
50:         userTestHelper.registerAllUsers();
51:         productTestHelper.addAllProducts();
52: 
53:         nonExistingMailAddress = instantiateMailAddress( "this@nononono.de" );
54:     }
55: 
56: 
57:     @Test
58:     public void testInvalidAddToShoppingBasket() {
59:         // given
60:         UUID nonExistentProductId = UUID.randomUUID();
61:         UUID productId5 = productTestHelper.getProductId( 5 );
62:         UUID productId0 = productTestHelper.getProductId( 0 );
63:         MailAddressType userMailAddress0 =
64:                 userTestHelper.getUserMailAddress( 0 );
65:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
66: 
67:         // then
68:         assertThrows( ShopException.class,
69:                 () -> shoppingBasketUseCases.addProductToShoppingBasket(
70:                         nonExistingMailAddress, productId0, 1 ) );
71:         assertThrows( ShopException.class,
72:                 () -> shoppingBasketUseCases.addProductToShoppingBasket(
73:                         null, productId0, 1 ) );
74:         assertThrows( ShopException.class,
75:                 () -> shoppingBasketUseCases.addProductToShoppingBasket(
76:                         userMailAddress0, nonExistentProductId, 1 ) );
77:         assertThrows( ShopException.class,
78:                 () -> shoppingBasketUseCases.addProductToShoppingBasket(
79:                         userMailAddress0, null, 1 ) );
80:         assertThrows( ShopException.class,
81:                 () -> shoppingBasketUseCases.addProductToShoppingBasket(
82:                         userMailAddress0, productId5, -1 ) );
83:     }
84: 
85: 
86:     @Test
87:     public void testInvalidRemoveFromShoppingBasket() {
88:         // given
89:         UUID nonExistentProductId = UUID.randomUUID();
90:         UUID productId5 = productTestHelper.getProductId( 5 );
91:         UUID productId1 = productTestHelper.getProductId( 1 );
92:         UUID productId2 = productTestHelper.getProductId( 2 );
93:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
94:         MailAddressType userMailAddress0 =
95:                 userTestHelper.getUserMailAddress( 0 );
96:         shoppingBasketUseCases.addProductToShoppingBasket(
97:                 userMailAddress0, productId1, 5 );
98:         shoppingBasketUseCases.addProductToShoppingBasket(
99:                 userMailAddress0, productId2, 15 );
100: 
101:         // when
102:         shoppingBasketUseCases.removeProductFromShoppingBasket(
103:                 userMailAddress0, productId1, 2 );
104:         shoppingBasketUseCases.removeProductFromShoppingBasket(
105:                 userMailAddress0, productId2, 4 );
106:         shoppingBasketUseCases.removeProductFromShoppingBasket(
107:                 userMailAddress0, productId2, 7 );
108:         // now we should have 3x productId1 and 4x productId2 in the shopping basket
109: 
110:         // then
111:         assertThrows( ShopException.class,
112:                 () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
113:                         userMailAddress0, nonExistentProductId, 12 ) );
114:         assertThrows( ShopException.class,
115:                 () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
116:                         nonExistingMailAddress, productId5, 12 ) );
117:         assertThrows( ShopException.class,
118:                 () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
119:                         userMailAddress0, productId5, -1 ) );
120:         assertThrows( ShopException.class,
121:                 () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
122:                         userMailAddress0, productId1, 4 ) );
123:         assertThrows( ShopException.class,
124:                 () -> shoppingBasketUseCases.removeProductFromShoppingBasket(
125:                         userMailAddress0, productId2, 5 ) );
126:     }
127: 
128: 
129:     @Test
130:     public void testAddRemoveProductsFromAndToShoppingBasket() {
131:         // given
132:         UUID productId1 = productTestHelper.getProductId( 1 );
133:         UUID productId2 = productTestHelper.getProductId( 2 );
134:         MailAddressType userMailAddress3 =
135:                 userTestHelper.getUserMailAddress( 3 );
136:         MailAddressType userMailAddress5 =
137:                 userTestHelper.getUserMailAddress( 5 );
138: 
139:         // when user 3 ...
140:         shoppingBasketUseCases.addProductToShoppingBasket(
141:                 userMailAddress3, productId1, 2 );
142:         shoppingBasketUseCases.addProductToShoppingBasket(
143:                 userMailAddress3, productId2, 3 );
144:         shoppingBasketUseCases.removeProductFromShoppingBasket(
145:                 userMailAddress3, productId1, 2 );
146:         shoppingBasketUseCases.addProductToShoppingBasket(
147:                 userMailAddress3, productId1, 1 );
148:         shoppingBasketUseCases.addProductToShoppingBasket(
149:                 userMailAddress3, productId2, 6 );
150:         Map<UUID, Integer> cart3 = shoppingBasketUseCases.getShoppingBasketAsMap( userMailAddress3 );
151:         // user3 has 1x productId1 and 9x productId2 in cart
152: 
153:         // ... and when user 5 ...
154:         shoppingBasketUseCases.addProductToShoppingBasket(
155:                 userMailAddress5, productId1, 2 );
156:         shoppingBasketUseCases.addProductToShoppingBasket(
157:                 userMailAddress5, productId2, 8 );
158:         shoppingBasketUseCases.removeProductFromShoppingBasket(
159:                 userMailAddress5, productId1, 1 );
160:         shoppingBasketUseCases.addProductToShoppingBasket(
161:                 userMailAddress5, productId2, 2 );
162:         Map<UUID, Integer> cart5 = shoppingBasketUseCases.getShoppingBasketAsMap( userMailAddress5 );
163:         // user5 has 1x productId1 and 10x productId2 in cart
164: 
165:         // then
166:         assertEquals( 2, cart3.size() );
167:         assertEquals( 1, cart3.get( productId1 ) );
168:         assertEquals( 9, cart3.get( productId2 ) );
169: 
170:         assertEquals( 2, cart5.size() );
171:         assertEquals( 1, cart5.get( productId1 ) );
172:         assertEquals( 10, cart5.get( productId2 ) );
173:     }
174: 
175: 
176:     @Test
177:     public void testShoppingBasketValue() {
178:         // given
179:         UUID productId3 = productTestHelper.getProductId( 3 );
180:         UUID productId6 = productTestHelper.getProductId( 6 );
181:         UUID productId8 = productTestHelper.getProductId( 8 );
182:         CurrencyType price3 = productTestHelper.getSalesPrice( 3 );
183:         CurrencyType price6 = productTestHelper.getSalesPrice( 6 );
184:         CurrencyType price8 = productTestHelper.getSalesPrice( 8 );
185:         MailAddressType userMailAddress3 =
186:                 userTestHelper.getUserMailAddress( 3 );
187: 
188:         // when
189:         shoppingBasketUseCases.addProductToShoppingBasket( userMailAddress3, productId3, 3 );
190:         shoppingBasketUseCases.addProductToShoppingBasket( userMailAddress3, productId6, 2 );
191:         shoppingBasketUseCases.addProductToShoppingBasket( userMailAddress3, productId8, 5 );
192:         // user3 has 3x productId3, 2x productId6 and 5x productId8 in cart
193:         CurrencyType cartValue = shoppingBasketUseCases.getShoppingBasketAsCurrencyValue( userMailAddress3 );
194: 
195:         // then
196:         assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
197:                 cartValue );
198:     }
199: 
200: 
201:     @Test
202:     public void testShoppingBasketValueInvalid() {
203:         // given
204:         // when
205:         // then
206:         assertThrows( ShopException.class,
207:                 () -> shoppingBasketUseCases.getShoppingBasketAsCurrencyValue( nonExistingMailAddress ) );
208:     }
209: 
210: 
211:     @Test
212:     public void testUnsuccessfulCheckout() {
213:         // given user buying product 0 (which is not in inventory), and user 1 buying product 1
214:         // in a bigger quantity (11) than available (10)
215:         fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
216:         MailAddressType userMailAddress0 =
217:                 userTestHelper.getUserMailAddress( 0 );
218:         MailAddressType userMailAddress1 =
219:                 userTestHelper.getUserMailAddress( 1 );
220:         UUID productId0 = productTestHelper.getProductId( 0 );
221:         UUID productId1 = productTestHelper.getProductId( 1 );
222: 
223:         // when
224:         shoppingBasketUseCases.addProductToShoppingBasket(
225:                 userMailAddress0, productId0, 1 );
226:         shoppingBasketUseCases.addProductToShoppingBasket(
227:                 userMailAddress1, productId1, 11 );
228: 
229:         // then
230:         assertThrows( InsufficientInventoryException.class,
231:                 () -> shoppingBasketUseCases.checkout( userMailAddress0 ) );
232:         assertThrows( InsufficientInventoryException.class,
233:                 () -> shoppingBasketUseCases.checkout( userMailAddress1 ) );
234:     }
235: 
236: }
237: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
1: package thkoeln.archilab.ecommerce.tests.testtests;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.domain.JavaMethod;
6: import com.tngtech.archunit.core.importer.ClassFileImporter;
7: import com.tngtech.archunit.lang.ArchRule;
8: import org.junit.jupiter.api.BeforeEach;
9: import org.junit.jupiter.api.Test;
10: import org.springframework.web.bind.annotation.RestController;
11: import thkoeln.archilab.ecommerce.helpers.ShoppingBasketRESTHelper;
12: import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
13: import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingBasketRESTTest;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.CurrencyType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
16: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
17: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
18: 
19: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
20: import static org.springframework.test.util.AssertionErrors.assertTrue;
21: 
22: /**
23:  * This test checks if there are the appropriate tests in the test class(es) for domain
24:  * primitives.
25:  */
26: 
27: public class RulesForOwnTests {
28:     private JavaClass dpTestClass, restTestClass;
29:     private JavaClasses dpTestClasses, restTestClasses;
30:     private static final String FULFILLMENT_CENTER_DOMAIN_PACKAGE =
31:             "thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain";
32:     private static final String FULFILLMENT_CENTER_CLASS_NAME =
33:             FULFILLMENT_CENTER_DOMAIN_PACKAGE + ".FulfillmentCenter";
34: 
35: 
36:     @BeforeEach
37:     public void setUp() throws Exception {
38:         dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
39:         restTestClass = new ClassFileImporter().importClass( OwnShoppingBasketRESTTest.class );
40: 
41:         dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
42:         restTestClasses = new ClassFileImporter().importClasses( OwnShoppingBasketRESTTest.class );
43:     }
44: 
45: 
46:     @Test
47:     public void ensureMinimumNumberOfTestMethods() {
48:         // given
49:         // when
50:         int dpTestMethodCount = getTestMethodCount( dpTestClass );
51:         int restTestMethodCount = getTestMethodCount( restTestClass );
52: 
53:         // then
54:         assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
55:                         + dpTestMethodCount,dpTestMethodCount >= 2 );
56:         assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
57:                         + restTestMethodCount, restTestMethodCount >= 5 );
58:     }
59: 
60:     private int getTestMethodCount( JavaClass testClass ) {
61:         int testMethodCount = 0;
62:         for ( JavaMethod method : testClass.getMethods() ) {
63:             if ( isTestMethod( method ) ) {
64:                 testMethodCount++;
65:             }
66:         }
67:         return testMethodCount;
68:     }
69: 
70:     private boolean isTestMethod( JavaMethod method ) {
71:         return method.isAnnotatedWith( Test.class );
72:     }
73: 
74: 
75:     @Test
76:     public void dpTestsShouldReferenceTheRightClasses() {
77:         ArchRule rule = classes()
78:                 .should().dependOnClassesThat()
79:                 .areAssignableTo( PostalCodeType.class )
80:                 .andShould().dependOnClassesThat()
81:                 .areAssignableTo( CurrencyType.class )
82:                 .andShould().dependOnClassesThat()
83:                 .areAssignableTo( PhysicalAddressType.class )
84:                 .andShould().dependOnClassesThat()
85:                 .areAssignableTo( MailAddressType.class )
86:                 .because( "DomainPrimitiveJSONSerializationTest should reference PostalCode, " +
87:                         "Currency, MailAddress, and PhysicalAddress!" );
88:         rule.check( dpTestClasses );
89:     }
90: 
91: 
92:     @Test
93:     public void restTestsShouldReferenceMailAddress() {
94:         ArchRule rule = classes()
95:                 .should().dependOnClassesThat()
96:                 .areAssignableTo( MailAddressType.class )
97:                 .because( "FulfillmentCenterComparatorUnitTest should reference MailAddressType!" );
98:         rule.check( restTestClasses );
99:     }
100: 
101: 
102:     @Test
103:     public void restTestsShouldReferenceRESTControllers() {
104:         ArchRule rule = classes()
105:                 .should().dependOnClassesThat()
106:                 .areAnnotatedWith( RestController.class )
107:                 .orShould().dependOnClassesThat()
108:                 .areAssignableTo( ShoppingBasketRESTHelper.class )
109:                 .because( "FulfillmentCenterComparatorUnitTest should call REST controllers! " +
110:                         "(either directly or via the ShoppingBasketRESTHelper REST helper)" );
111:         rule.check( restTestClasses );
112:     }
113: 
114: }
115: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\user\UserRegistrationTest.java ---
1: package thkoeln.archilab.ecommerce.tests.user;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.usecases.masterdata.UserTestHelper;
10: import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
11: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
12: import thkoeln.archilab.ecommerce.usecases.UserType;
13: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
15: 
16: import static org.junit.jupiter.api.Assertions.*;
17: import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;
18: 
19: 
20: @SpringBootTest
21: public class UserRegistrationTest {
22:     @Autowired
23:     private UserRegistrationUseCases userRegistrationUseCases;
24:     @Autowired
25:     private Purgatory purgatory;
26:     @Autowired
27:     private UserTestHelper userTestHelper;
28: 
29:     private MailAddressType nonExistingMailAddress;
30:     private PhysicalAddressType somePhysicalAddress;
31: 
32:     @BeforeEach
33:     public void setUp() {
34:         purgatory.deleteEverything();
35:         nonExistingMailAddress = instantiateMailAddress( "this@nononono.de" );
36:         somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
37:                 instantiatePostalCode( "90001" ) );
38:     }
39: 
40:     @Test
41:     public void testAllUsersRegistered() {
42:         // given
43:         userTestHelper.registerAllUsers();
44:         MailAddressType mailAddress3 =
45:                 userTestHelper.getUserMailAddress( 3 );
46:         String name3 = userTestHelper.getUserName( 3 );
47:         PhysicalAddressType physicalAddress3 = userTestHelper.getUserPhysicalAddress( 3 );
48: 
49:         // when
50:         UserType user3 = userRegistrationUseCases.getUserData(
51:                 mailAddress3 );
52: 
53:         // then
54:         Assertions.assertEquals( name3, user3.getName() );
55:         Assertions.assertEquals( mailAddress3, user3.getMailAddress() );
56:         Assertions.assertEquals( physicalAddress3, user3.getPhysicalAddress() );
57:     }
58: 
59: 
60:     @Test
61:     public void testRegisterUserWithDuplicateMailAddress() {
62:         // given
63:         userTestHelper.registerAllUsers();
64:         PhysicalAddressType physicalAddress5 = userTestHelper.getUserPhysicalAddress( 5 );
65:         MailAddressType mailAddress5 =
66:                 userTestHelper.getUserMailAddress( 5 );
67: 
68:         // when
69:         // then
70:         assertThrows( ShopException.class, () ->
71:                 userRegistrationUseCases.register( "Gandalf The Grey",
72:                         mailAddress5, physicalAddress5 ) );
73:     }
74: 
75: 
76:     @Test
77:     public void testRegisterUserWithDuplicateNameOrPhysicalAddress() {
78:         // given
79:         userTestHelper.registerAllUsers();
80:         MailAddressType newMailAddress =
81:                 instantiateMailAddress( "some@this.de" );
82:         PhysicalAddressType physicalAddress2 = userTestHelper.getUserPhysicalAddress( 2 );
83:         String name2 = userTestHelper.getUserName( 2 );
84: 
85:         // when
86:         // then
87:         assertDoesNotThrow( () ->
88:                 userRegistrationUseCases.register( name2, newMailAddress, physicalAddress2 ) );
89:     }
90: 
91: 
92:     @Test
93:     public void testRegisterUserWithInvalidData() {
94:         // given
95:         MailAddressType mailAddress5 =
96:                 userTestHelper.getUserMailAddress( 5 );
97:         PhysicalAddressType physicalAddress5 = userTestHelper.getUserPhysicalAddress( 5 );
98:         String name5 = userTestHelper.getUserName( 5 );
99: 
100:         // when
101:         // then
102:         assertThrows( ShopException.class, () ->
103:                 userRegistrationUseCases.register( null, mailAddress5, physicalAddress5 ) );
104:         assertThrows( ShopException.class, () ->
105:                 userRegistrationUseCases.register("", mailAddress5, physicalAddress5 ) );
106:         assertThrows( ShopException.class, () ->
107:                 userRegistrationUseCases.register( name5, null, physicalAddress5 ) );
108:         assertThrows( ShopException.class, () ->
109:                 userRegistrationUseCases.register( name5, mailAddress5, null ) );
110:     }
111: 
112: 
113:     @Test
114:     public void testChangeAddressWithInvalidData() {
115:         // given
116:         userTestHelper.registerAllUsers();
117:         PhysicalAddressType physicalAddress7 = userTestHelper.getUserPhysicalAddress( 7 );
118:         MailAddressType mailAddress7 =
119:                 userTestHelper.getUserMailAddress( 7 );
120: 
121:         // when
122:         // then
123:         assertThrows( ShopException.class, () ->
124:                 userRegistrationUseCases.changeAddress( nonExistingMailAddress, physicalAddress7 ) );
125:         assertThrows( ShopException.class, () ->
126:                 userRegistrationUseCases.changeAddress( null, physicalAddress7 ) );
127:         assertThrows( ShopException.class, () ->
128:                 userRegistrationUseCases.changeAddress( mailAddress7, null ) );
129:     }
130: 
131: 
132:     @Test
133:     public void testGetDataForNonexistingMailAddress() {
134:         // given
135:         userTestHelper.registerAllUsers();
136: 
137:         // when
138:         // then
139:         assertThrows( ShopException.class, () ->
140:                 userRegistrationUseCases.getUserData( nonExistingMailAddress ) );
141:     }
142: 
143: 
144:     @Test
145:     public void testDeleteUsersNoMoreUsers() {
146:         // given
147:         userTestHelper.registerAllUsers();
148:         MailAddressType mailAddress0 =
149:                 userTestHelper.getUserMailAddress( 0 );
150: 
151: 
152:         // when
153:         userRegistrationUseCases.deleteAllUsers();
154: 
155:         // then
156:         assertThrows( ShopException.class, () -> userRegistrationUseCases.getUserData(
157:                 mailAddress0 ) );
158:     }
159: 
160: 
161:     @Test
162:     public void testChangeAddressSuccessful() {
163:         // given
164:         userTestHelper.registerAllUsers();
165:         MailAddressType mailAddress6 =
166:                 userTestHelper.getUserMailAddress( 6 );
167: 
168:         // when
169:         userRegistrationUseCases.changeAddress( mailAddress6, somePhysicalAddress );
170:         UserType newUser6 =
171:                 userRegistrationUseCases.getUserData( mailAddress6 );
172: 
173:         // then
174:         Assertions.assertEquals( mailAddress6, newUser6.getMailAddress() );
175:         Assertions.assertEquals( somePhysicalAddress, newUser6.getPhysicalAddress() );
176:     }
177: 
178: 
179:     @Test
180:     public void testChangeAddressForNonexistingMailAddress() {
181:         // given
182:         userTestHelper.registerAllUsers();
183: 
184:         // when
185:         // then
186:         assertThrows( ShopException.class, () ->
187:                 userRegistrationUseCases.changeAddress( nonExistingMailAddress, somePhysicalAddress ) );
188:     }
189: 
190: 
191: }
192: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\test\java\thkoeln\archilab\ecommerce\tests\user\UserRESTTest.java ---
1: package thkoeln.archilab.ecommerce.tests.user;
2: 
3: import jakarta.transaction.Transactional;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
8: import org.springframework.boot.test.context.SpringBootTest;
9: import org.springframework.context.annotation.Import;
10: import org.springframework.test.web.servlet.MockMvc;
11: import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
12: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
13: import thkoeln.archilab.ecommerce.usecases.UserType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
16: import thkoeln.archilab.ecommerce.usecases.masterdata.*;
17: 
18: import java.util.UUID;
19: 
20: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
21: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
22: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
23: 
24: @SpringBootTest
25: @Transactional
26: @AutoConfigureMockMvc
27: @Import( RESTTestHelperConfiguration.class )
28: public class UserRESTTest {
29:     @Autowired
30:     private UserRegistrationUseCases userRegistrationUseCases;
31:     @Autowired
32:     private Purgatory purgatory;
33:     @Autowired
34:     private UserTestHelper userTestHelper;
35:     @Autowired
36:     private MockMvc mockMvc;
37: 
38:     private UUID randomId;
39:     private MailAddressType nonExistingMailAddress;
40: 
41:     @BeforeEach
42:     public void setUp() {
43:         purgatory.deleteEverything();
44:         userTestHelper.registerAllUsers();
45: 
46:         nonExistingMailAddress = FactoryMethodInvoker.instantiateMailAddress(
47:                 "harry@sally.de" );
48:         randomId = UUID.randomUUID();
49:     }
50: 
51: 
52:     @Test
53:     public void testInvalidUserUris() throws Exception {
54:         // given
55:         String allUsersUri = "/users";
56:         String randomIdUri = "/users/" +  randomId;
57:         String nonExistingMailAddressUri = "/users?mailAddress=" + nonExistingMailAddress;
58:         String randomParamUri = "/users?randomParam=randomValue";
59: 
60:         // when
61:         // then
62:         mockMvc.perform( get( allUsersUri ) ).andExpect( status().isMethodNotAllowed() );
63:         mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
64:         mockMvc.perform( get( nonExistingMailAddressUri ) ).andExpect( status().isNotFound() );
65:         mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
66:     }
67: 
68: 
69:     @Test
70:     public void testRandomUserId() throws Exception {
71:         // given
72:         String invalidUri = "/users/" +  randomId;
73: 
74:         // when
75:         // then
76:         mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
77:     }
78: 
79: 
80:     @Test
81:     public void testQueryUser() throws Exception {
82:         // given
83:         MailAddressType mailAddress4 =
84:                 userTestHelper.getUserMailAddress( 4 );
85:         String userUri4 = "/users?mailAddress=" + mailAddress4;
86: 
87:         // when
88:         UserType user4 = userRegistrationUseCases.getUserData( mailAddress4 );
89:         String name = userTestHelper.getUserName( 4 );
90:         PhysicalAddressType physicalAddress4 = userTestHelper.getUserPhysicalAddress( 4 );
91: 
92:         // then (check using JSONPath)
93:         mockMvc.perform( get( userUri4 ) )
94:                 .andExpect( status().isOk() )
95:                 .andExpect( jsonPath( "$.name" ).value( name ) )
96:                 // id is position 0 (cannot be tested with current API structure), name is position 1,
97:                 // mail address is 2, physical address is 3)
98:                 .andExpect( jsonPath( "$..mailAddressString" ).value( mailAddress4.toString() ) )
99:                 .andExpect( jsonPath( "$..city" ).value( physicalAddress4.getCity() ) )
100:                 .andExpect( jsonPath( "$..postalCodeString" ).value(
101:                         physicalAddress4.getPostalCode().toString() ) );
102:     }
103: 
104: }
105: 

[RESPONSE]:
## Zusammenfassung der Code-Review-Ergebnisse

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java

**Zeile 262-276**: Duplication (Original 266-270): Die Methode `getUserById` und `getUserByBasketId` enthalten fast identische Logik zur Benutzerabfrage. Letztere f√ºgt nur einen zus√§tzlichen Schritt zur Basket-Abfrage hinzu.  
**Zeile 69-82 & 161-164**: Duplication: Die W√§hrungsformatierungslogik ist im Controller (`formatCurrencyString`) und in der `ShoppingBasketMapperHelper` (`formatCurrency`) dupliziert.

**Zeile 183-185**: Negative conditionals: Die Bedingung `(fc.getFromPostalCodeFirstDigit() == 0 && fc.getToPostalCodeFirstDigit() == 0) || (postalDigit >= fc.getFromPostalCodeFirstDigit() && postalDigit <= fc.getToPostalCodeFirstDigit())` ist doppelt negativ formuliert. Sie pr√ºft, ob ein Center f√ºr alle Postleitzahlen zust√§ndig ist (0-0) ODER ob die Postleitzahl im Bereich liegt. Besser positiv formulieren.

**Zeile 108-111 & 109-110**: Dead code: Die Variablen `priceMap` und die Schleife zur Berechnung der `totalSalesPriceAsFloat` in `getShoppingBasketAsCurrencyValue` sind nicht notwendig, da der Gesamtwert bereits in der `ShoppingBasket`-Klasse berechnet wird (`basket.getTotalValue(priceMap)`). Die Berechnung k√∂nnte direkt in der Domain-Klasse erfolgen.

**Zeile 35-57**: Layer violation / Misplaced responsibility: Der `ShoppingBasketService` greift direkt auf das `UserRepository` zu, das sich im Domain-Layer eines anderen Aggregats (`user`) befindet. Gem√§√ü DDD sollte der Zugriff √ºber ein Interface (`UserFinder`) erfolgen, das im eigenen Aggregat definiert ist. Zudem vermischt der Service Logik f√ºr das Finden von Benutzern, was eigentlich in den Domain-Layer geh√∂rt.

**Zeile 244-260**: Shared persistency: Die Methode `getBasket` greift √ºber `userRepository.findByMailAddress` direkt auf das Repository eines anderen Aggregats (`user`) zu. Dies verst√∂√üt gegen die Regeln der Aggregatgrenzen.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketController.java

**Zeile 69-82 & 161-164**: Duplication (siehe oben): Die W√§hrungsformatierung ist dupliziert.

**Zeile 145-164**: Misplaced responsibility: Der Controller enth√§lt Logik zur Formatierung der W√§hrung (`formatCurrencyString`). Diese geh√∂rt besser in eine Service-Schicht oder einen spezialisierten Mapper/Helper.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\application\ProductCatalogService.java

**Zeile 40-44 & 46-48**: Duplication: Die Validierung von `name` und `description` auf null/leer ist redundant mit der sp√§teren Pr√ºfung in der `Product`-Domain-Entity (falls vorhanden). Die Pr√ºfung geh√∂rt idealerweise in die Factory-Methode oder den Konstruktor der Domain-Entity.

**Zeile 50-53**: Negative conditionals: Die Bedingung `!salesPrice.largerThan(buyingPrice) && !salesPrice.getQuantity().equals(buyingPrice.getQuantity())` ist komplex und doppelt negativ. Besser: `salesPrice.getQuantity() <= buyingPrice.getQuantity()` (wenn Gleichheit erlaubt ist, sonst `<`).

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Currency.java

**Zeile 31-36**: Negative conditionals: Die Bedingung `(!currencyUnit.equals("EUR") && !currencyUnit.equals("CHF"))` enth√§lt eine Negation. Besser mit `!Set.of("EUR", "CHF").contains(currencyUnit)` oder einer positiven Pr√ºfung.

**Zeile 104**: Dead code: Die `toString()`-Methode gibt immer "‚Ç¨" aus, unabh√§ngig von der tats√§chlichen `currencyUnit`. Das ist ein Fehler, da auch "CHF" m√∂glich ist.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\MailAddress.java

**Zeile 33**: Negative conditionals: Die Bedingung `!VALID_MAIL_PATTERN.matcher(mailAddressAsString).matches()` ist eine einfache Negation und okay, da verst√§ndlich.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\adapter\MailAddressJpaAdapter.java

**Gesamte Datei**: Dead code: Diese Klasse wird nirgendwo im Code verwendet.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\PurchaseUsageChecker.java

**Gesamte Datei**: Dead code: Dieses Interface wird deklariert, aber von keiner Klasse implementiert oder verwendet. Stattdessen wird `PurchaseUsage` verwendet.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\InventoryLevel.java

**Zeile 20**: Dead code: Das Feld `reservedQuantity` wird nie gesetzt oder gelesen.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketMapperHelper.java & ShoppingBasketPositionMapperHelper.java

**Beide Dateien**: Dead code: Diese Mapper-Klassen werden nicht verwendet. Die Mapping-Logik befindet sich direkt im `ShoppingBasketController`.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\GlobalExceptionHandler.java

**Gesamte Datei**: Layer violation: Diese Klasse liegt im `domainprimitives`-Package, handelt aber von Web/Controller-spezifischen Angelegenheiten (`@ControllerAdvice`). Sie geh√∂rt in die Application- oder Infrastruktur-Schicht.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterFinderAdapter.java

**Gesamte Datei**: Misplaced responsibility: Der Adapter ist im `application`-Package, implementiert aber ein Interface (`FulfillmentCenterFinder`) aus dem `domain`-Package. Diese Art von Adapter geh√∂rt typischerweise in ein `adapter`-Package, um die Abh√§ngigkeitsrichtung korrekt zu halten (Domain ‚Üí Interface, Infrastruktur/Application ‚Üí Implementation).

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentInventoryAdapter.java

**Gesamte Datei**: Misplaced responsibility: Gleiches Problem wie oben. Der Adapter implementiert ein Domain-Interface (`FulfillmentInventoryChecker`), geh√∂rt aber nicht in den Domain-Layer.

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\product\domain\Product.java

**Gesamte Datei**: Anemic Entity

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\User.java

**Gesamte Datei**: Anemic Entity

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\Purchase.java

**Gesamte Datei**: Anemic Entity

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java

**Gesamte Datei**: Anemic Entity

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePosition.java

**Gesamte Datei**: Anemic Entity

### C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_5ef4838e-78d3-4035-b065-16707112626c\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\InventoryLevel.java

**Gesamte Datei**: Anemic Entity

ENDE
Generated by deepseek-reasoner
-----------------------------------