--- DATE: 8.1.2026, 19:40:47 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
    Architektur: 4-Layer (Eric Evans).
    Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
    Regeln:
    1. Begründe kurz jeden Fund.
    4. Gruppiere nach Datei (mit Pfad). 
    2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
    3. Keine Code-Wiederholung, nur Referenzen.
    5. Wenn fertig, schreibe "ENDE".



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\CustomerNotFoundException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Customer not found")
public class CustomerNotFoundException extends ShopException {
    public CustomerNotFoundException(String message) {
        super(message);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\EmptyNameException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY, reason = "Customer name empty")
public class EmptyNameException extends ShopException {
    public EmptyNameException(String message) {
        super(message);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\InsufficientMerchandiseInventoryException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.InsufficientInventoryException;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.CONFLICT, reason = "Insufficient inventory")
public class InsufficientMerchandiseInventoryException extends InsufficientInventoryException {
    public InsufficientMerchandiseInventoryException(String message) {
        super(message);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\InvalidMailAddressException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY, reason = "Invalid mail address")
public class InvalidMailAddressException extends ShopException {
    public InvalidMailAddressException(String message) {
        super(message);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\InvalidPhysicalAddressException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY, reason = "Invalid physical address")
public class InvalidPhysicalAddressException extends ShopException {
    public InvalidPhysicalAddressException(String message) {
        super(message);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\MailAddressInUseException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.CONFLICT, reason = "Mail address already in use")
public class MailAddressInUseException extends ShopException {
    public MailAddressInUseException(String message) {
        super(message);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\MerchandiseNotFoundException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Merchandise not found")
public class MerchandiseNotFoundException extends ShopException {
    public MerchandiseNotFoundException(String message) {
        super(message);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\NegativeQuantityException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY, reason = "Negative quantity")
public class NegativeQuantityException extends ShopException {
    public NegativeQuantityException(String message) {
        super(message);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\PurchaseNotFoundException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Purchase not found")
public class PurchaseNotFoundException extends ShopException {
    public PurchaseNotFoundException(String message) {
        super(message);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\exceptions\ShoppingCartNotFoundException.java ---
package thkoeln.archilab.ecommerce.domainprimitives.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
import thkoeln.archilab.ecommerce.ShopException;

@ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Shopping cart not found")
public class ShoppingCartNotFoundException extends ShopException {
    public ShoppingCartNotFoundException(String message) {
        super(message);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\MailAddress.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonValue;
import jakarta.persistence.Embeddable;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

@Embeddable
@Getter
@EqualsAndHashCode
@NoArgsConstructor(access = lombok.AccessLevel.PROTECTED, force = true)
public class MailAddress implements MailAddressType {
    private final String mailAddressString;
    private final String identifier;
    private final String domain;

    private MailAddress(String identifier, String domain) {
        if(identifier == null || identifier.isEmpty() || identifier.contains(" ") || identifier.matches(".*\\.{2,}.*")
                || !identifier.matches("^[a-zA-Z0-9._-]+$")){
            throw new ShopException("Invalid mail address identifier");
        }

        if(domain == null || domain.isEmpty() || domain.contains(" ") || domain.matches(".*\\.{2,}.*")
                || !domain.matches(".*\\.(de|at|ch|com|org)")){
            throw new ShopException("Invalid mail address domain");
        }

        this.identifier = identifier;
        this.domain = domain;
        this.mailAddressString = identifier + "@" + domain;
    }

    public static MailAddress of( String mailAddressAsString ){
        if(mailAddressAsString == null || mailAddressAsString.isEmpty()){
            throw new ShopException("Mail address is null or empty");
        }

        if(!mailAddressAsString.contains("@")){
            throw new ShopException("Mail address is not a valid email address");
        }

        String[] mailAddressParts = mailAddressAsString.split("@");

        if(mailAddressParts.length != 2){
            throw new ShopException("Mail address is not a valid email address");
        }

        return new MailAddress(mailAddressParts[0], mailAddressParts[1]);
    }

    @Override
    public MailAddress sameIdentifyerDifferentDomain(String domainString) {
       return new MailAddress(identifier, domainString);
    }

    @Override
    public MailAddress sameDomainDifferentIdentifyer(String identifyerString) {
        return new MailAddress(identifyerString, domain);
    }

    @Override
    public String toString(){
        return identifier + "@" + domain;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import jakarta.persistence.Embeddable;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

@Embeddable
@Getter
@EqualsAndHashCode
@NoArgsConstructor(access = lombok.AccessLevel.PROTECTED, force = true)
public class Money implements MoneyType {
    private final Float amount;
    private final String currency;

    private Money(final Float amount, final String currency) {
        if(amount == null || amount < 0f){
            throw new ShopException("Amount must be greater than zero");
        }

        if(currency == null || currency.isEmpty() || !currency.matches("EUR|CHF")){
            throw new ShopException("Currency must be either EUR or CHF");
        }

        this.amount = amount;
        this.currency = currency;
    }

    public static Money of( Float amount, String currencyUnit ){
        return new Money( amount, currencyUnit );
    }

    @Override
    public Float getAmount() {
        return amount;
    }

    @Override
    public String getCurrencyUnit() {
        return currency;
    }

    @Override
    public Money add(MoneyType otherMoney) {
        if(otherMoney == null){
            throw new ShopException("Cannot add null to MoneyType");
        }

        if(!otherMoney.getCurrencyUnit().equals(currency)){
            throw new ShopException("Currency does not match");
        }
        return new Money(amount + otherMoney.getAmount(), currency);
    }

    @Override
    public Money subtract(MoneyType otherMoney) {
        if(otherMoney == null){
            throw new ShopException("Cannot add null to MoneyType");
        }

        if(!otherMoney.getCurrencyUnit().equals(currency)){
            throw new ShopException("Currency does not match");
        }

        if(amount < otherMoney.getAmount()){
            throw new ShopException("Cannot subtract from amount less than currency amount");
        }

        return new Money(amount - otherMoney.getAmount(), currency);
    }

    @Override
    public Money multiplyBy(int factor) {
        if(factor < 0){
            throw new ShopException("Factor must be greater than zero");
        }
        return new Money(amount * factor, currency);
    }

    @Override
    public boolean largerThan(MoneyType otherMoney) {
        if(otherMoney == null){
            throw new ShopException("Cannot add null to MoneyType");
        }

        if(!otherMoney.getCurrencyUnit().equals(currency)){
            throw new ShopException("Currency does not match");
        }

        return amount > otherMoney.getAmount();
    }

    @Override
    public String toString(){
        return String.format("%.2f %s", amount, switch (currency) {
            case "EUR": yield "€";
            case "CHF": yield "CHF";
            default:
                throw new ShopException("Currency not supported");
        });
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PhysicalAddress.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import jakarta.persistence.Embeddable;
import jakarta.persistence.Embedded;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

@Embeddable
@Getter
@EqualsAndHashCode
@NoArgsConstructor(access = lombok.AccessLevel.PROTECTED, force = true)
public class PhysicalAddress implements PhysicalAddressType {
    private final String street;
    private final String city;
    @Embedded
    private final ZipCode zipCode;

    private PhysicalAddress(String street, String city, ZipCode zipCode){
        if(street == null || street.isEmpty()){
            throw new ShopException("Street is null or empty");
        }

        if(city == null || city.isEmpty()){
            throw new ShopException("City is null or empty");
        }

        if(zipCode == null){
            throw new ShopException("ZipCode is null");
        }

        this.street = street;
        this.city = city;
        this.zipCode = zipCode;
    }

    public static PhysicalAddress of( String street, String city, ZipCodeType zipCode){
        return new PhysicalAddress(street, city, (ZipCode) zipCode);
    }

    @Override
    public String getStreet() {
        return street;
    }

    @Override
    public String getCity() {
        return city;
    }

    @Override
    public ZipCode getZipCode() {
        return zipCode;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.Embeddable;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

@Embeddable
@Getter
@EqualsAndHashCode
@NoArgsConstructor(access = lombok.AccessLevel.PROTECTED, force = true)
public class ZipCode implements ZipCodeType {
    @JsonProperty("zipCodeString")
    private final String zipCode;

    public ZipCode(String zipCode) {
        if(zipCode == null
                || !zipCode.matches("\\d{5}")
                || zipCode.matches(".*0000")){
            throw new ShopException("Zip code is not a valid zip code");
        }
        this.zipCode = zipCode;
    }

    public static ZipCode of( String zipCodeAsString ){
       return new ZipCode(zipCodeAsString);
    }

    @Override
    public int difference(ZipCodeType otherZipCode) {
        if(otherZipCode == null){
            throw new ShopException("Zip code is null");
        }

        if(zipCode.equals(otherZipCode.toString())){
            return 0;
        }

        int difference = 0;

        for(int i = 1; i < zipCode.length(); i++){
            if(zipCode.charAt(i) != otherZipCode.toString().charAt(i)){
                difference = zipCode.length() - i;
                break;
            }
        }

        int firstDigitDiff = Math.abs(zipCode.charAt(0) - otherZipCode.toString().charAt(0));

        if(firstDigitDiff > 5){
            firstDigitDiff = 10 - firstDigitDiff;
        }

        return difference + firstDigitDiff;
    }

    @Override
    public Integer getFirstDigitZipCode() {
        return Integer.parseInt(zipCode.substring(0, 1));
    }

    @Override
    public String toString(){
        return zipCode;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\GenericId.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */
package thkoeln.archilab.ecommerce;

import jakarta.persistence.Column;
import jakarta.persistence.MappedSuperclass;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

import java.io.Serializable;
import java.util.UUID;

@MappedSuperclass
@Getter
@EqualsAndHashCode(of = "id")
@ToString(of = "id")
public abstract class GenericId implements Serializable {
    @Column(nullable = false, updatable = false)
    private final UUID id;

    protected GenericId() {
        this( UUID.randomUUID() );
    }

    protected GenericId( UUID id ) {
        this.id = id;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\GenericIdConverter.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */
package thkoeln.archilab.ecommerce;

import jakarta.persistence.AttributeConverter;

import java.util.UUID;
import java.util.function.Function;


public abstract class GenericIdConverter<T extends GenericId> implements AttributeConverter<T, UUID> {
    private final Function<UUID, T> factory;

    protected GenericIdConverter( Function<UUID, T> factory ) {
        this.factory = factory;
    }

    @Override
    public UUID convertToDatabaseColumn( T attribute ) {
        return attribute == null ? null : attribute.getId();
    }

    @Override
    public T convertToEntityAttribute( UUID dbData ) {
        return dbData == null ? null : factory.apply( dbData );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\InsufficientInventoryException.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */
package thkoeln.archilab.ecommerce;

/**
 * Exception is thrown if the merchandise's inventory level is not sufficient to serve the purchase.
 */
public class InsufficientInventoryException extends ShopException {
    public InsufficientInventoryException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */
package thkoeln.archilab.ecommerce;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class ProjectApplication {

	/**
	 * Entry method
	 * @param args
	 */
	public static void main(String[] args) {
		SpringApplication.run(ProjectApplication.class, args);
	}
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */
package thkoeln.archilab.ecommerce;

public class ShopException extends RuntimeException {
    public ShopException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.customer.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.CustomerType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

@Service
public
class CustomerAdapterService implements CustomerRegistrationUseCases {
    private final CustomerRegistrationService customerRegistrationService;

    @Autowired
    public CustomerAdapterService(CustomerRegistrationService customerRegistrationService) {
        this.customerRegistrationService = customerRegistrationService;
    }

    @Override
    public void register(String name, MailAddressType mailAddress, PhysicalAddressType physicalAddress) {
        this.customerRegistrationService.register(
                name,
                (MailAddress) mailAddress,
                (PhysicalAddress) physicalAddress);
    }

    @Override
    public void changeAddress(MailAddressType customerMailAddress, PhysicalAddressType physicalAddress) {
        this.customerRegistrationService.changeAddress(
                (MailAddress) customerMailAddress,
                (PhysicalAddress) physicalAddress);
    }

    @Override
    public CustomerType getCustomerData(MailAddressType customerMailAddress) {
        return this.customerRegistrationService.getCustomerData(
                (MailAddress) customerMailAddress);
    }

    @Override
    public void deleteAllCustomers() {
        this.customerRegistrationService.deleteAllCustomers();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerController.java ---
package thkoeln.archilab.ecommerce.solution.customer.application;

import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.usecases.CustomerType;

@RestController
@RequestMapping("/customers")
public class CustomerController {
    private final CustomerRegistrationService customerRegistrationService;
    private static final ModelMapper MODEL_MAPPER = new ModelMapper();

    @Autowired
    public CustomerController(CustomerRegistrationService customerRegistrationService) {
        this.customerRegistrationService = customerRegistrationService;
    }

    @GetMapping(params = "mailAddress")
    public ResponseEntity<CustomerDTO> getOneCustomerByMailAddress(
            @RequestParam("mailAddress") String mailAddress) {
        CustomerType customer = customerRegistrationService.getCustomerData(MailAddress.of(mailAddress));
        CustomerDTO customerDTO = MODEL_MAPPER.map(customer, CustomerDTO.class);

        return new ResponseEntity<>( customerDTO, HttpStatus.OK);
    }

    @GetMapping
    public ResponseEntity<CustomerDTO> getAllCustomers() {
        return new ResponseEntity<>(HttpStatus.METHOD_NOT_ALLOWED);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerDTO.java ---
package thkoeln.archilab.ecommerce.solution.customer.application;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;

import java.util.UUID;

@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
public class CustomerDTO {
    private UUID id;
    private MailAddress mailAddress;
    private String name;
    private PhysicalAddress physicalAddress;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\application\CustomerRegistrationService.java ---
package thkoeln.archilab.ecommerce.solution.customer.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.*;
import thkoeln.archilab.ecommerce.solution.customer.domain.*;

@Service
public class CustomerRegistrationService{
    private final CustomerRepository customerRepository;

    @Autowired
    public CustomerRegistrationService(CustomerRepository customerRepository) {
        this.customerRepository = customerRepository;
    }

    public void register(String name, MailAddress mailAddress, PhysicalAddress physicalAddress) {
        if (name == null || name.isBlank()) {
            throw new EmptyNameException("Customer name can not be null or empty");
        }
        if (mailAddress == null ) {
            throw new InvalidMailAddressException("Customer mail address can not be null");
        }

        if(physicalAddress == null){
            throw new InvalidPhysicalAddressException("Customer physical address can not be null");
        }

        if (this.customerRepository.findByMailAddress(mailAddress).isPresent()) {
            throw new MailAddressInUseException("mailAddress already in use");
        }

        this.customerRepository.save(new Customer(mailAddress, name, physicalAddress));
    }

    public void changeAddress(MailAddress customerMailAddress, PhysicalAddress physicalAddress) {
        if (customerMailAddress == null) {
            throw new InvalidMailAddressException("Customer mail address can not be null or empty");
        }

        if (physicalAddress == null) {
            throw new InvalidPhysicalAddressException("Customer physical address can not be null or empty");
        }

        Customer customer = this.customerRepository.findByMailAddress(customerMailAddress)
                .orElseThrow(() -> new CustomerNotFoundException("customer not found"));

        customer.setPhysicalAddress(physicalAddress);
        customerRepository.save(customer);
    }

    public Customer getCustomerData(CustomerId customerId) {
        return this.customerRepository.findById(customerId)
                .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));
    }

    public Customer getCustomerData(MailAddress customerMailAddress) {
        if (customerMailAddress == null) {
            throw new InvalidMailAddressException("Customer mail address can not be null or empty");
        }

        return this.customerRepository.findByMailAddress(customerMailAddress)
                .orElseThrow(() -> new CustomerNotFoundException("customer not found"));
    }

    public void deleteAllCustomers() {
        this.customerRepository.deleteAll();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\Customer.java ---
package thkoeln.archilab.ecommerce.solution.customer.domain;

import jakarta.persistence.Column;
import jakarta.persistence.Embedded;
import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import lombok.*;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.usecases.CustomerType;

import java.util.UUID;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Customer implements CustomerType {
    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private CustomerId id;

    @Column(unique = true)
    @Embedded
    private MailAddress mailAddress;
    private String name;
    @Embedded
    private PhysicalAddress physicalAddress;

    public Customer(MailAddress mailAddress, String name, PhysicalAddress physicalAddress) {
        this.id = new CustomerId(UUID.randomUUID());
        this.mailAddress = mailAddress;
        this.name = name;
        this.physicalAddress = physicalAddress;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\CustomerId.java ---
package thkoeln.archilab.ecommerce.solution.customer.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "customer_id"))
public class CustomerId extends GenericId {
    public CustomerId(UUID uuid) {
        super(uuid);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\CustomerIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.customer.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class CustomerIdConverter extends GenericIdConverter<CustomerId> {
    public CustomerIdConverter() {
        super(CustomerId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\customer\domain\CustomerRepository.java ---
package thkoeln.archilab.ecommerce.solution.customer.domain;

import org.springframework.data.repository.CrudRepository;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.Optional;

public interface CustomerRepository extends CrudRepository<Customer, CustomerId> {
    // find by
    Optional<Customer> findByMailAddress(MailAddressType mailAddress);

    Iterable<Customer> findByName(String name);

    Iterable<Customer> findByPhysicalAddress(PhysicalAddressType physicalAddress);

    // existsBy
    boolean existsByName(String name);

    boolean existsByMailAddress(MailAddressType mailAddress);

    boolean existsByPhysicalAddress(PhysicalAddressType physicalAddress);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterId;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.UUID;

@Service
public class FulfillmentCenterAdapterService implements FulfillmentCenterUseCases {
    private final FulfillmentCenterService fulfillmentCenterService;

    @Autowired
    public FulfillmentCenterAdapterService(FulfillmentCenterService fulfillmentCenterService) {
        this.fulfillmentCenterService = fulfillmentCenterService;
    }

    @Override
    public UUID addNewFulfillmentCenter(String name, PhysicalAddressType physicalAddress) {
        return fulfillmentCenterService.addNewFulfillmentCenter(name, (PhysicalAddress) physicalAddress).getId();
    }

    @Override
    public void deleteAllFulfillmentCenters() {
        this.fulfillmentCenterService.deleteAllFulfillmentCenters();
    }

    @Override
    public void addToInventory(UUID fulfillmentCenterId, UUID merchandiseId, int addedQuantiOf) {
        this.fulfillmentCenterService.addToInventory(
                new FulfillmentCenterId(fulfillmentCenterId),
                new MerchandiseId(merchandiseId),
                addedQuantiOf);
    }

    @Override
    public void removeFromInventory(UUID fulfillmentCenterId, UUID merchandiseId, int removedQuantiOf) {
        this.fulfillmentCenterService.removeFromInventory(
                new FulfillmentCenterId(fulfillmentCenterId),
                new MerchandiseId(merchandiseId),
                removedQuantiOf
        );
    }

    @Override
    public void changeInventoryTo(UUID fulfillmentCenterId, UUID merchandiseId, int newTotalQuantiOf) {
        this.fulfillmentCenterService.changeInventoryTo(
                new FulfillmentCenterId(fulfillmentCenterId),
                new MerchandiseId(merchandiseId),
                newTotalQuantiOf
        );
    }

    @Override
    public int getAvailableInventory(UUID fulfillmentCenterId, UUID merchandiseId) {
        return this.fulfillmentCenterService.getAvailableInventory(
                new FulfillmentCenterId(fulfillmentCenterId),
                new MerchandiseId(merchandiseId)
        );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\FulfillmentCenterService.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenter;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterId;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterRepository;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseRepository;

@Service
public class FulfillmentCenterService {
    private final FulfillmentCenterRepository fulfillmentCenterRepository;
    private final MerchandiseRepository merchandiseRepository;

    @Autowired
    public FulfillmentCenterService(
            FulfillmentCenterRepository fulfillmentCenterRepository,
            MerchandiseRepository merchandiseRepository) {
        this.fulfillmentCenterRepository = fulfillmentCenterRepository;
        this.merchandiseRepository = merchandiseRepository;
    }

    public FulfillmentCenterId addNewFulfillmentCenter(
            String name,
            PhysicalAddress physicalAddress) {
        if (name == null || name.isEmpty())
            throw new ShopException("FulfillmentCenter name can not be null or empty");
        if (physicalAddress == null)
            throw new ShopException("FulfillmentCenter physicalAddress can not be null or empty");

        return this.fulfillmentCenterRepository.save(
                new FulfillmentCenter(name,physicalAddress)).getId();
    }

    public void deleteAllFulfillmentCenters() {
        this.fulfillmentCenterRepository.deleteAll();
    }

    public void addToInventory(FulfillmentCenterId fulfillmentCenterId, MerchandiseId merchandiseId, int addedQuantiOf) {
        FulfillmentCenter fulfillmentCenter = this.fulfillmentCenterRepository.findById(fulfillmentCenterId)
                .orElseThrow(() -> new ShopException("FulfillmentCenter not found"));

        if(addedQuantiOf < 0) throw new ShopException("Quantity must be greater than zero");

        if(!this.merchandiseRepository.existsById(merchandiseId))
                throw new ShopException("Merchandise not found");

        fulfillmentCenter.addToInventory(merchandiseId, addedQuantiOf);
        this.fulfillmentCenterRepository.save(fulfillmentCenter);
    }

    public void removeFromInventory(FulfillmentCenterId fulfillmentCenterId, MerchandiseId merchandiseId, int removedQuantiOf) {
        FulfillmentCenter fulfillmentCenter = this.fulfillmentCenterRepository.findById(fulfillmentCenterId)
                .orElseThrow(() -> new ShopException("FulfillmentCenter not found"));

        if(removedQuantiOf < 0) throw new ShopException("Quantity must be greater than zero");

        if(!this.merchandiseRepository.existsById(merchandiseId))
            throw new ShopException("Merchandise not found");

        fulfillmentCenter.removeFromInventory(merchandiseId, removedQuantiOf);
        this.fulfillmentCenterRepository.save(fulfillmentCenter);
    }

    public void changeInventoryTo(FulfillmentCenterId fulfillmentCenterId, MerchandiseId merchandiseId, int newTotalQuantiOf) {
        FulfillmentCenter fulfillmentCenter = this.fulfillmentCenterRepository.findById(fulfillmentCenterId)
                .orElseThrow(() -> new ShopException("FulfillmentCenter not found"));

        if(newTotalQuantiOf < 0) throw new ShopException("Quantity must be greater than zero");

        if(!this.merchandiseRepository.existsById(merchandiseId))
            throw new ShopException("Merchandise not found");

        fulfillmentCenter.setInventoryQuantity(merchandiseId, newTotalQuantiOf);
        this.fulfillmentCenterRepository.save(fulfillmentCenter);
    }

    public int getAvailableInventory(FulfillmentCenterId fulfillmentCenterId, MerchandiseId merchandiseId) {
        FulfillmentCenter fulfillmentCenter = this.fulfillmentCenterRepository.findById(fulfillmentCenterId)
                .orElseThrow(() -> new ShopException("FulfillmentCenter not found"));

        if(!this.merchandiseRepository.existsById(merchandiseId))
            throw new ShopException("Merchandise not found");

        return fulfillmentCenter.getInventoryLevel(merchandiseId);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\application\StorableService.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenter;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterRepository;
import thkoeln.archilab.ecommerce.solution.merchandise.application.StorableServiceInterface;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;

@Service
public class StorableService implements StorableServiceInterface {
    private final FulfillmentCenterRepository fulfillmentCenterRepository;

    @Autowired
    public StorableService(FulfillmentCenterRepository fulfillmentCenterRepository) {
        this.fulfillmentCenterRepository = fulfillmentCenterRepository;
    }

    @Override
    public boolean isMerchandiseInStock(MerchandiseId merchandiseId) {
        for(FulfillmentCenter fulfillmentCenter : this.fulfillmentCenterRepository.findAll())
            if(fulfillmentCenter.getInventoryLevel(merchandiseId) != 0)
                return true;
        return false;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenter.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.*;
import lombok.*;
import thkoeln.archilab.ecommerce.InsufficientInventoryException;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;

import java.util.*;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class FulfillmentCenter {
    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private FulfillmentCenterId id;

    private String name;
    @Embedded
    private PhysicalAddress physicalAddress;

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
    private List<InventoryLevel> inventoryLevelList;

    public FulfillmentCenter(
            String name,
            PhysicalAddress physicalAddress) {

        this.id = new FulfillmentCenterId(UUID.randomUUID());
        this.name = name;
        this.physicalAddress = physicalAddress;
        this.inventoryLevelList = new ArrayList<>();
    }

    public Set<MerchandiseId> fulfillableShoppingCartParts(Map<MerchandiseId, Integer> merchandiseQuantityMap ){
        Set<MerchandiseId> fulfillable = new HashSet<>();

        for(InventoryLevel inventoryLevel : inventoryLevelList){
            MerchandiseId merchandiseId = inventoryLevel.getMerchandiseId();

            if(merchandiseQuantityMap.containsKey(merchandiseId)
                && inventoryLevel.getQuantity() >= merchandiseQuantityMap.get(merchandiseId)){
                fulfillable.add(merchandiseId);
            }
        }
        return fulfillable;
    }

    public void setInventoryQuantity(MerchandiseId merchandiseId, int quantity) {
        if(quantity < 0) throw new ShopException("Quantity must be greater than zero");

        inventoryLevelList.stream()
                .filter(inventoryLevel -> inventoryLevel.getMerchandiseId().equals(merchandiseId))
                .findFirst()
                .ifPresentOrElse(
                        inventoryLevel -> inventoryLevel.setQuantity(quantity),
                        () -> inventoryLevelList.add(new InventoryLevel(merchandiseId, quantity))
                );
    }

    public void addToInventory(Map<MerchandiseId, Integer> merchandiseQuantityMap) {
        for(MerchandiseId merchandiseId : merchandiseQuantityMap.keySet()){
            addToInventory(merchandiseId, merchandiseQuantityMap.get(merchandiseId));
        }
    }

    public void addToInventory(MerchandiseId merchandiseId, int quantity) {
        if(quantity == 0) return;
        else if(quantity < 0) throw new ShopException("Quantity must be greater than zero");

        inventoryLevelList.stream()
                .filter(inventoryLevel -> inventoryLevel.getMerchandiseId().equals(merchandiseId))
                .findFirst()
                .ifPresentOrElse(
                        inventoryLevel -> inventoryLevel.setQuantity(
                                inventoryLevel.getQuantity() + quantity),
                        () -> inventoryLevelList.add(
                                new InventoryLevel(merchandiseId, quantity))
                );
    }

    public void removeFromInventory(MerchandiseId merchandiseId, int quantity) {
        if(quantity == 0) return;
        else if(quantity < 0) throw new ShopException("Quantity must be greater than zero");

        Optional<InventoryLevel> optionalIL = inventoryLevelList.stream()
                .filter(inventoryLevel -> inventoryLevel.getMerchandiseId().equals(merchandiseId))
                .findFirst();

        if(optionalIL.isPresent()){
            InventoryLevel inventoryLevel = optionalIL.get();
            int newQuantity = inventoryLevel.getQuantity() - quantity;
            if (newQuantity < 0)
                throw new InsufficientInventoryException(
                        "Cannot remove " + quantity
                                + " of merchandise " + merchandiseId +
                                ". Only " + inventoryLevel.getQuantity()
                                + " available in this fulfillment center");
            inventoryLevel.setQuantity(newQuantity);
        }
        else{
            throw new InsufficientInventoryException("Cannot remove " + quantity
                    + " of merchandise " + merchandiseId + ". No inventory found");
        }
    }

    public Integer getInventoryLevel(MerchandiseId merchandiseId) {
        return inventoryLevelList.stream()
                .filter(il -> il.getMerchandiseId().equals(merchandiseId))
                .findFirst()
                .map(InventoryLevel::getQuantity)
                .orElse(0);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterComparator.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;

import java.util.Comparator;
import java.util.Map;
import java.util.Set;

public class FulfillmentCenterComparator implements Comparator<FulfillmentCenter> {

    private final Map<MerchandiseId, Integer> merchandiseMap;
    private final ZipCode zipCode;

    public FulfillmentCenterComparator(final Map<MerchandiseId, Integer> merchandiseMap, final ZipCode zipCode) {
        this.merchandiseMap = merchandiseMap;
        this.zipCode = zipCode;
    }

    public int compare(FulfillmentCenter c1, FulfillmentCenter c2) {
        Set<MerchandiseId> c1Merchandises =  c1.fulfillableShoppingCartParts(merchandiseMap);
        Set<MerchandiseId> c2Merchandises =  c2.fulfillableShoppingCartParts(merchandiseMap);

        int compare = Integer.compare(c2Merchandises.size(), c1Merchandises.size());

        if(compare != 0) return compare;
        else {
            ZipCode c1ZipCode = c1.getPhysicalAddress().getZipCode();
            ZipCode c2ZipCode = c2.getPhysicalAddress().getZipCode();

            return Integer.compare(c1ZipCode.difference(zipCode), c2ZipCode.difference(zipCode));
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterId.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "fulfillmentcenter_id"))
public class FulfillmentCenterId extends GenericId {
    public FulfillmentCenterId(UUID id) {
        super(id);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class FulfillmentCenterIdConverter extends GenericIdConverter<FulfillmentCenterId> {
    public FulfillmentCenterIdConverter() {
        super(FulfillmentCenterId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\FulfillmentCenterRepository.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;


import org.springframework.data.repository.CrudRepository;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;

public interface FulfillmentCenterRepository extends CrudRepository<FulfillmentCenter, FulfillmentCenterId> {
    // find by
    Iterable<FulfillmentCenter> findByName(String name);

    Iterable<FulfillmentCenter> findByPhysicalAddress(PhysicalAddress physicalAddress);

    // exists by
    boolean existsByName(String name);

    boolean existsByPhysicalAddress(PhysicalAddress physicalAddress);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\InventoryLevel.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.Storable;

import java.util.UUID;

@Entity
@Inheritance (strategy = InheritanceType.SINGLE_TABLE)
@Getter
@Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class InventoryLevel extends Storable {
    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private InventoryLevelId id;

    @Column(nullable = false)
    private MerchandiseId merchandiseId;

    private int quantity;

    public InventoryLevel(MerchandiseId merchandiseId, int quantity) {
        this.id = new InventoryLevelId(UUID.randomUUID());
        this.merchandiseId = merchandiseId;
        this.quantity = quantity;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\InventoryLevelId.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "inventorylevel_id"))
public class InventoryLevelId extends GenericId {
    public InventoryLevelId(UUID id) {
        super(id);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\fulfillmentcenter\domain\InventoryLevelIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class InventoryLevelIdConverter extends GenericIdConverter<InventoryLevelId> {
    public InventoryLevelIdConverter() {
        super(InventoryLevelId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\application\MerchandiseCatalogAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.merchandise.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;

@Service
public class MerchandiseCatalogAdapterService implements MerchandiseCatalogUseCases {
    private final MerchandiseCatalogService merchandiseCatalogService;

    @Autowired
    public MerchandiseCatalogAdapterService(MerchandiseCatalogService merchandiseCatalogService) {
        this.merchandiseCatalogService = merchandiseCatalogService;
    }

    @Override
    public UUID addMerchandiseToCatalog(String name, String descriptFor, Float size, MoneyType buyingPrice, MoneyType salesPrice) {
        return this.merchandiseCatalogService.addMerchandiseToCatalog(
                name,
                descriptFor,
                size,
                (Money) buyingPrice,
                (Money) salesPrice).getId();
    }

    @Override
    public void removeMerchandiseFromCatalog(UUID merchandiseId) {
        this.merchandiseCatalogService.removeMerchandiseFromCatalog(
                new MerchandiseId(merchandiseId));
    }

    @Override
    public MoneyType getSalesPrice(UUID merchandiseId) {
        return this.merchandiseCatalogService.getSalesPrice(new MerchandiseId(merchandiseId));
    }

    @Override
    public void deleteMerchandiseCatalog() {
        this.merchandiseCatalogService.deleteMerchandiseCatalog();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\application\MerchandiseCatalogService.java ---
package thkoeln.archilab.ecommerce.solution.merchandise.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.Merchandise;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseRepository;

@Service
public class MerchandiseCatalogService{
    private final MerchandiseRepository merchandiseRepository;

    private final StorableServiceInterface storableServiceInterface;
    private final PurchasableServiceInterface purchasableServiceInterface;

    @Autowired
    public MerchandiseCatalogService(MerchandiseRepository merchandiseRepository,
                                     StorableServiceInterface storableServiceInterface,
                                     PurchasableServiceInterface purchasableServiceInterface) {
        this.merchandiseRepository = merchandiseRepository;
        this.storableServiceInterface = storableServiceInterface;
        this.purchasableServiceInterface = purchasableServiceInterface;
    }

    public MerchandiseId addMerchandiseToCatalog(
            String name,
            String descriptFor,
            Float size,
            Money buyingPrice,
            Money salesPrice) {
        if (name == null || name.isEmpty())
            throw new ShopException("Merchandise name can not be null or empty");
        if (descriptFor == null || descriptFor.isEmpty())
            throw new ShopException("Merchandise description can not be null or empty");
        if (buyingPrice == null)
            throw new ShopException("Merchandise buyingPrice can not be null or <= 0");
        if (salesPrice == null || salesPrice.getAmount() < buyingPrice.getAmount())
            throw new ShopException("Merchandise salesPrice can not be null or lower than buyingPrice");

        return this.merchandiseRepository.save(
                new Merchandise(name, descriptFor, size, buyingPrice, salesPrice)).getId();
    }

    public void removeMerchandiseFromCatalog(MerchandiseId merchandiseId) {
        if (!this.merchandiseRepository.existsById(merchandiseId))
            throw new ShopException("Merchandise not found");

        if(storableServiceInterface.isMerchandiseInStock(merchandiseId))
            throw new ShopException("Unable to delete merchandise: still in inventory");

        if(purchasableServiceInterface.isMerchandiseInPurchase(merchandiseId))
            throw new ShopException("Unable to delete merchandise: already purchased");

        this.merchandiseRepository.deleteById(merchandiseId);
    }

    public Money getSalesPrice(MerchandiseId merchandiseId) {
        return this.merchandiseRepository.findById(merchandiseId)
                .orElseThrow(() -> new ShopException("Merchandise not found"))
                .getSalesPrice();
    }

    public void deleteMerchandiseCatalog() {
        this.merchandiseRepository.deleteAll();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\application\PurchasableServiceInterface.java ---
package thkoeln.archilab.ecommerce.solution.merchandise.application;

import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;

public interface PurchasableServiceInterface {
    public boolean isMerchandiseInPurchase(MerchandiseId merchandiseId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\application\StorableServiceInterface.java ---
package thkoeln.archilab.ecommerce.solution.merchandise.application;

import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;

public interface StorableServiceInterface {
    public boolean isMerchandiseInStock(MerchandiseId merchandiseId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\Merchandise.java ---
package thkoeln.archilab.ecommerce.solution.merchandise.domain;

import jakarta.persistence.*;
import lombok.*;
import thkoeln.archilab.ecommerce.domainprimitives.Money;

import java.util.UUID;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Merchandise {
    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private MerchandiseId id;

    private String name;
    private String description;
    private Float size;
    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "amount", column = @Column(name = "buyingPrice_amount")),
            @AttributeOverride(name = "currency", column = @Column(name = "buyingPrice_currency"))
    })
    private Money buyingPrice;
    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "amount", column = @Column(name = "salesPrice_amount")),
            @AttributeOverride(name = "currency", column = @Column(name = "salesPrice_currency"))
    })
    private Money salesPrice;

    public Merchandise(
            String name,
            String description,
            Float size,
            Money buyingPrice,
            Money salesPrice){
        this.id = new MerchandiseId(UUID.randomUUID());
        this.name = name;
        this.description = description;
        this.size = size;
        this.buyingPrice = buyingPrice;
        this.salesPrice = salesPrice;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\MerchandiseId.java ---
package thkoeln.archilab.ecommerce.solution.merchandise.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "merchandise_id"))
public class MerchandiseId extends GenericId {
    public MerchandiseId(UUID uuid) {
        super(uuid);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\MerchandiseIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.merchandise.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class MerchandiseIdConverter extends GenericIdConverter<MerchandiseId> {
    public MerchandiseIdConverter() {
        super(MerchandiseId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\MerchandiseRepository.java ---
package thkoeln.archilab.ecommerce.solution.merchandise.domain;

import org.springframework.data.repository.CrudRepository;
import thkoeln.archilab.ecommerce.domainprimitives.Money;

public interface MerchandiseRepository extends CrudRepository<Merchandise, MerchandiseId> {
    // find by
    Iterable<Merchandise> findByName(String name);

    Iterable<Merchandise> findByDescription(String description);

    Iterable<Merchandise> findBySize(Float size);

    Iterable<Merchandise> findByBuyingPrice(Money buyingPrice);

    Iterable<Merchandise> findBySalesPrice(Money salesPrice);

    // exists by
    boolean existsByName(String name);

    boolean existsByDescription(String description);

    boolean existsBySize(Float size);

    boolean existsByBuyingPrice(Money buyingPrice);

    boolean existsBySalesPrice(Money salesPrice);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\Purchasable.java ---
package thkoeln.archilab.ecommerce.solution.merchandise.domain;

import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;

@MappedSuperclass
@Setter
@Getter
public abstract class Purchasable {}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\merchandise\domain\Storable.java ---
package thkoeln.archilab.ecommerce.solution.merchandise.domain;

import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;

@MappedSuperclass
@Setter
@Getter
public abstract class Storable {}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchasableService.java ---
package thkoeln.archilab.ecommerce.solution.purchase.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.merchandise.application.PurchasableServiceInterface;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;

@Service
public class PurchasableService implements PurchasableServiceInterface {
    private final PurchaseRepository purchaseRepository;

    @Autowired
    public PurchasableService(PurchaseRepository purchaseRepository) {
        this.purchaseRepository = purchaseRepository;
    }

    @Override
    public boolean isMerchandiseInPurchase(MerchandiseId merchandiseId) {
        for (Purchase purchase : this.purchaseRepository.findAll())
            if (purchase.getQuantity(merchandiseId) != 0)
                return true;
        return false;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.purchase.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
import thkoeln.archilab.ecommerce.usecases.PurchaseUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class PurchaseAdapterService implements PurchaseUseCases {
    private final PurchaseService purchaseService;

    @Autowired
    public PurchaseAdapterService(PurchaseService purchaseService) {
        this.purchaseService = purchaseService;
    }

    @Override
    public Map<UUID, Integer> getPurchaseHistory(MailAddressType customerMailAddress) {
        return this.purchaseService.getPurchaseHistory((MailAddress) customerMailAddress)
                .entrySet()
                .stream()
                .collect(Collectors.toMap(
                        entry -> entry.getKey().getId(),
                        Map.Entry::getValue));
    }

    @Override
    public Integer getPurchaseQuantiOfMerchandise(UUID purchaseId, UUID merchandiseId) {
        return this.purchaseService.getPurchaseQuantiOfMerchandise(
                new PurchaseId(purchaseId),
                new MerchandiseId(merchandiseId));
    }

    @Override
    public UUID getFulfillmentCenterIdForPurchase(UUID purchaseId) {
        return this.purchaseService.getFulfillmentCenterIdForPurchase(
                new PurchaseId(purchaseId)).getId();
    }

    @Override
    public void deleteAllPurchases() {
        this.purchaseService.deleteAllPurchases();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseDTO.java ---
package thkoeln.archilab.ecommerce.solution.purchase.application;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.UUID;

@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
public class PurchaseDTO {
    UUID id;
    String customerName;
    UUID fulfillmentCenterId;
    PurchasePartDTO[] parts;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchasePartDTO.java ---
package thkoeln.archilab.ecommerce.solution.purchase.application;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.UUID;

@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
public class PurchasePartDTO {
    UUID merchandiseId;
    int quantity;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\application\PurchaseService.java ---
package thkoeln.archilab.ecommerce.solution.purchase.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.CustomerNotFoundException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.PurchaseNotFoundException;
import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerRepository;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterId;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;

import java.util.HashMap;
import java.util.Map;

@Service
public class PurchaseService {
    private final PurchaseRepository purchaseRepository;
    private final CustomerRepository customerRepository;

    @Autowired
    public PurchaseService(
            PurchaseRepository purchaseRepository,
            CustomerRepository customerRepository) {
        this.purchaseRepository = purchaseRepository;
        this.customerRepository = customerRepository;
    }

    public Purchase getPurchase(PurchaseId purchaseId){
        return purchaseRepository.findById(purchaseId)
                .orElseThrow(() -> new PurchaseNotFoundException("Purchase not found"));
    }

    public Map<MerchandiseId, Integer> getPurchaseHistory(MailAddress customerMailAddress) {
        Customer customer = this.customerRepository.findByMailAddress(customerMailAddress)
                .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));

        Map<MerchandiseId, Integer> purchaseHistory = new HashMap<>();

        for (Purchase purchase : this.purchaseRepository.findByCustomerId(customer.getId())){
            for (Map.Entry<MerchandiseId, Integer> entry : purchase.getPurchaseAsMap().entrySet()) {
                purchaseHistory.merge(
                        entry.getKey(),
                        entry.getValue(),
                        Integer::sum
                );
            }
        }


        return purchaseHistory;
    }

    public Integer getPurchaseQuantiOfMerchandise(PurchaseId purchaseId, MerchandiseId merchandiseId) {
        Purchase purchase = this.purchaseRepository.findById(purchaseId)
                .orElseThrow(() -> new PurchaseNotFoundException("Purchase not found"));

        return purchase.getQuantity(merchandiseId);
    }

    public FulfillmentCenterId getFulfillmentCenterIdForPurchase(PurchaseId purchaseId) {
        Purchase purchase = this.purchaseRepository.findById(purchaseId)
                .orElseThrow(() -> new PurchaseNotFoundException("Purchase not found"));

        return purchase.getFulfillmentCenterId();
    }

    public void deleteAllPurchases() {
        this.purchaseRepository.deleteAll();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\Purchase.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.*;
import lombok.*;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterId;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Purchase {
    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private PurchaseId id;

    @Column(nullable = false)
    private CustomerId customerId;

    @Column(nullable = false)
    private FulfillmentCenterId fulfillmentCenterId;

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
    private List<PurchasePart> purchasePartList;

    public Purchase(
            CustomerId customerId,
            FulfillmentCenterId fulfillmentCenterId) {
        this.id = new PurchaseId(UUID.randomUUID());
        this.customerId = customerId;
        this.fulfillmentCenterId = fulfillmentCenterId;
        this.purchasePartList = new ArrayList<>();
    }

    public void addPurchasePart(MerchandiseId merchandiseId, int quantity) {
        for(PurchasePart purchasePart : purchasePartList) {
            if(purchasePart.getMerchandiseId().equals(merchandiseId)) {
                purchasePart.setQuantity(purchasePart.getQuantity() + quantity);
                return;
            }
        }
        purchasePartList.add(new PurchasePart(
                merchandiseId,
                quantity
        ));
    }

    public void removePurchasePart(MerchandiseId merchandiseId) {
        purchasePartList.stream()
                .filter(purchasePart ->
                        purchasePart.getMerchandiseId().equals(merchandiseId))
                .findFirst()
                .ifPresent(purchasePart -> purchasePartList.remove(purchasePart));
    }

    public Integer getQuantity(MerchandiseId merchandiseId) {
        return purchasePartList.stream()
                .filter(purchasePart ->
                        purchasePart.getMerchandiseId().equals(merchandiseId))
                .findFirst()
                .map(PurchasePart::getQuantity)
                .orElse(0);
    }

    public Map<MerchandiseId, Integer> getPurchaseAsMap() {
        return purchasePartList.stream()
                .collect(Collectors.toMap(
                        PurchasePart::getMerchandiseId,
                        PurchasePart::getQuantity
                ));
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseId.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;
@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "purchase_id"))
public class PurchaseId extends GenericId {
    public PurchaseId(UUID uuid) {
        super(uuid);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import thkoeln.archilab.ecommerce.GenericIdConverter;

public class PurchaseIdConverter extends GenericIdConverter<PurchaseId> {
    public PurchaseIdConverter() {
        super(PurchaseId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePart.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.Purchasable;

import java.util.UUID;

@Entity
@Inheritance (strategy = InheritanceType.SINGLE_TABLE)
@Getter
@Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class PurchasePart extends Purchasable {
    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private PurchasePartId id;

    @Column(nullable = false)
    private MerchandiseId merchandiseId;

    private Integer quantity;

    public PurchasePart(MerchandiseId merchandiseId, int quantity) {
        this.id = new PurchasePartId(UUID.randomUUID());
        this.merchandiseId = merchandiseId;
        this.quantity = quantity;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePartId.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "customer_id"))
public class PurchasePartId extends GenericId {
    public PurchasePartId(UUID uuid) {
        super(uuid);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchasePartIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class PurchasePartIdConverter extends GenericIdConverter<PurchasePartId> {
    public PurchasePartIdConverter() {
        super(PurchasePartId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\purchase\domain\PurchaseRepository.java ---
package thkoeln.archilab.ecommerce.solution.purchase.domain;

import org.springframework.data.repository.CrudRepository;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterId;

public interface PurchaseRepository extends CrudRepository<Purchase, PurchaseId> {
    // find by
    Iterable<Purchase> findByCustomerId(CustomerId customerId);

    Iterable<Purchase> findByFulfillmentCenterId(FulfillmentCenterId fulfillmentCenterId);


    // exists by
    boolean existsByCustomerId(CustomerId customerId);

    boolean existsByFulfillmentCenterId(FulfillmentCenterId fulfillmentCenterId);

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartAdapterService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.GenericId;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class ShoppingCartAdapterService implements ShoppingCartUseCases {
    private final ShoppingCartService shoppingCartService;

    @Autowired
    public ShoppingCartAdapterService(ShoppingCartService shoppingCartService) {
        this.shoppingCartService = shoppingCartService;
    }

    @Override
    public void addMerchandiseToShoppingCart(MailAddressType customerMailAddress, UUID merchandiseId, int quantiOf) {
        this.shoppingCartService.addMerchandiseToShoppingCart(
                (MailAddress) customerMailAddress,
                new MerchandiseId(merchandiseId),
                quantiOf);
    }

    @Override
    public void removeMerchandiseFromShoppingCart(MailAddressType customerMailAddress, UUID merchandiseId, int quantiOf) {
        this.shoppingCartService.removeMerchandiseFromShoppingCart(
                (MailAddress) customerMailAddress,
                new MerchandiseId(merchandiseId),
                quantiOf);
    }

    @Override
    public Map<UUID, Integer> getShoppingCartAsMap(MailAddressType customerMailAddress) {
        return this.shoppingCartService.getShoppingCartAsMap((MailAddress) customerMailAddress);
    }

    @Override
    public MoneyType getShoppingCartAsMoneyValue(MailAddressType customerMailAddress) {
        return this.shoppingCartService.getShoppingCartAsMoneyValue(
                        (MailAddress) customerMailAddress);
    }

    @Override
    public Set<UUID> checkout(MailAddressType customerMailAddress) {
        return this.shoppingCartService.checkout((MailAddress) customerMailAddress)
                .stream()
                .map(GenericId::getId)
                .collect(Collectors.toSet());
    }

    @Override
    public void emptyAllShoppingCarts() {
        this.shoppingCartService.emptyAllShoppingCarts();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartController.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.application;

import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.customer.application.CustomerRegistrationService;
import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
import thkoeln.archilab.ecommerce.solution.purchase.application.PurchaseDTO;
import thkoeln.archilab.ecommerce.solution.purchase.application.PurchasePartDTO;
import thkoeln.archilab.ecommerce.solution.purchase.application.PurchaseService;
import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartId;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartPart;

import java.util.Map;
import java.util.Set;
import java.util.UUID;

@RestController
@RequestMapping("/shoppingCarts")
public class ShoppingCartController {
    private final ShoppingCartService shoppingCartService;
    private final PurchaseService purchaseService;

    private static final ModelMapper MODEL_MAPPER = new ModelMapper();
    private final CustomerRegistrationService customerRegistrationService;

    @Autowired
    public ShoppingCartController(
            ShoppingCartService shoppingCartService,
            PurchaseService purchaseService, CustomerRegistrationService customerRegistrationService) {
        this.shoppingCartService = shoppingCartService;
        this.purchaseService = purchaseService;
        this.customerRegistrationService = customerRegistrationService;
    }

    @GetMapping(params = "customerId")
    public ResponseEntity<ShoppingCartDTO> getShoppingCart(
            @RequestParam("customerId") String customerId) {
        UUID customerUUID;
        try {
            customerUUID = UUID.fromString( customerId );
        } catch ( IllegalArgumentException e ) {
            return new ResponseEntity<>( HttpStatus.NOT_FOUND );
        }

        Customer customer = customerRegistrationService.getCustomerData(new CustomerId(customerUUID));
        ShoppingCart shoppingCart = shoppingCartService.getShoppingCart(customer.getId());

        Money totalSalesPrice = shoppingCartService.getShoppingCartAsMoneyValue(customer.getId());

        ShoppingCartPartDTO[] partDTOS = new ShoppingCartPartDTO[shoppingCart.getShoppingCartPartList().size()];

        for(int i = 0; i < shoppingCart.getShoppingCartPartList().size(); i++){
            ShoppingCartPart shoppingCartPart = shoppingCart.getShoppingCartPartList().get(i);
            partDTOS[i] = MODEL_MAPPER.map(shoppingCartPart, ShoppingCartPartDTO.class);
        }

        ShoppingCartDTO shoppingCartDTO = new ShoppingCartDTO(
                shoppingCart.getId().getId(),
                totalSalesPrice.toString(),
                partDTOS
        );

        return new ResponseEntity<>(shoppingCartDTO, HttpStatus.OK);
    }

    @GetMapping()
    public ResponseEntity<ShoppingCartDTO> getShoppingCarts(){
        return new ResponseEntity<>(HttpStatus.METHOD_NOT_ALLOWED);
    }

    @PostMapping("/{shoppingCartId}/parts")
    public ResponseEntity addMerchandiseToShoppingCart(
            @PathVariable String shoppingCartId,
            @RequestBody ShoppingCartPartDTO shoppingCartPartDTO){
        UUID shoppingCartUUID;
        try {
            shoppingCartUUID = UUID.fromString( shoppingCartId );
        } catch ( IllegalArgumentException e ) {
            return new ResponseEntity<>( HttpStatus.NOT_FOUND );
        }

        ShoppingCart shoppingCart = shoppingCartService.getShoppingCart(
                new ShoppingCartId(shoppingCartUUID));

        shoppingCartService.addMerchandiseToShoppingCart(
                shoppingCart.getCustomerId(),
                new MerchandiseId(shoppingCartPartDTO.getMerchandiseId()),
                shoppingCartPartDTO.getQuantity()
        );
        
        return new ResponseEntity(HttpStatus.CREATED);
    }

    @PostMapping("/{shoppingCartId}/checkout")
    public ResponseEntity<PurchaseDTO[]> checkout(
            @PathVariable String shoppingCartId){
        UUID shoppingCartUUID;
        try {
            shoppingCartUUID = UUID.fromString( shoppingCartId );
        } catch ( IllegalArgumentException e ) {
            return new ResponseEntity<>( HttpStatus.NOT_FOUND );
        }

        Set<PurchaseId> purchaseIds = shoppingCartService.checkout(new ShoppingCartId(shoppingCartUUID));
        PurchaseDTO[] purchaseDTOS = new PurchaseDTO[purchaseIds.size()];

        if(purchaseIds.isEmpty()) return new ResponseEntity<>( HttpStatus.CONFLICT );

        int i = 0;
        for(PurchaseId purchaseId : purchaseIds){
            Purchase purchase = purchaseService.getPurchase(purchaseId);
            Customer customer = customerRegistrationService.getCustomerData(purchase.getCustomerId());
            Map<MerchandiseId, Integer> purchaseMap = purchase.getPurchaseAsMap();

            PurchasePartDTO[] purchasePartDTOS = new PurchasePartDTO[purchaseMap.size()];

            int j = 0;
            for(MerchandiseId merchandiseId : purchaseMap.keySet()){
                PurchasePartDTO purchasePartDTO = new PurchasePartDTO(
                        merchandiseId.getId(),
                        purchaseMap.get(merchandiseId));
                purchasePartDTOS[j] = purchasePartDTO;
                j++;
            }

            MODEL_MAPPER.map(purchaseMap, purchasePartDTOS);

            purchaseDTOS[i] =  new PurchaseDTO(
                purchaseId.getId(),
                customer.getName(),
                    purchase.getFulfillmentCenterId().getId(),
                    purchasePartDTOS
            );
            i++;
        }

        return new ResponseEntity<>(purchaseDTOS, HttpStatus.CREATED);
    }

    @DeleteMapping("/{shoppingCartId}/parts/{merchandiseId}")
    public ResponseEntity removeMerchandiseFromShoppingCart(
            @PathVariable String shoppingCartId,
            @PathVariable String merchandiseId)
    {
        UUID shoppingCartUUID;
        try {
            shoppingCartUUID = UUID.fromString( shoppingCartId );
        } catch ( IllegalArgumentException e ) {
            return new ResponseEntity<>( HttpStatus.NOT_FOUND );
        }

        UUID merchandiseUUID;
        try {
            merchandiseUUID = UUID.fromString( merchandiseId );
        } catch ( IllegalArgumentException e ) {
            return new ResponseEntity<>( HttpStatus.NOT_FOUND );
        }

        ShoppingCart shoppingCart = shoppingCartService.getShoppingCart(
                new ShoppingCartId(shoppingCartUUID));

        shoppingCartService.removeMerchandiseFromShoppingCart(
                shoppingCart.getCustomerId(),
                new MerchandiseId(merchandiseUUID));

        return new ResponseEntity(HttpStatus.OK);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.application;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.UUID;

@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
public class ShoppingCartDTO {
    UUID id;
    String totalSalesPrice;
    ShoppingCartPartDTO[] parts ;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartPartDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.application;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.UUID;

@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
public class ShoppingCartPartDTO {
    UUID merchandiseId;
    int quantity;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\application\ShoppingCartService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.InsufficientInventoryException;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.*;
import thkoeln.archilab.ecommerce.solution.customer.domain.Customer;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerRepository;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenter;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterComparator;
import thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain.FulfillmentCenterRepository;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.Merchandise;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseRepository;
import thkoeln.archilab.ecommerce.solution.purchase.domain.Purchase;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseId;
import thkoeln.archilab.ecommerce.solution.purchase.domain.PurchaseRepository;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartId;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartPart;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCartRepository;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class ShoppingCartService{
    private final ShoppingCartRepository shoppingCartRepository;
    private final CustomerRepository customerRepository;
    private final MerchandiseRepository merchandiseRepository;
    private final FulfillmentCenterRepository fulfillmentCenterRepository;
    private final PurchaseRepository purchaseRepository;

    @Autowired
    public ShoppingCartService(
            ShoppingCartRepository shoppingCartRepository,
            CustomerRepository customerRepository,
            MerchandiseRepository merchandiseRepository,
            FulfillmentCenterRepository fulfillmentCenterRepository,
            PurchaseRepository purchaseRepository) {
        this.shoppingCartRepository = shoppingCartRepository;
        this.customerRepository = customerRepository;
        this.merchandiseRepository = merchandiseRepository;
        this.fulfillmentCenterRepository = fulfillmentCenterRepository;
        this.purchaseRepository = purchaseRepository;
    }

    public void addMerchandiseToShoppingCart(
            Customer customer,
            MerchandiseId merchandiseId,
            int quantiOf) {
        if (quantiOf <= 0) throw new NegativeQuantityException("Quantity must be positive");

        if(!merchandiseRepository.existsById(merchandiseId))
            throw new MerchandiseNotFoundException("Merchandise not found");

        ShoppingCart shoppingCart = shoppingCartRepository.findByCustomerId(customer.getId())
                .orElseGet(() -> shoppingCartRepository.save(new ShoppingCart(customer.getId())));

        shoppingCart.addToShoppingCart(merchandiseId, quantiOf);
        shoppingCartRepository.save(shoppingCart);
    }

    public void addMerchandiseToShoppingCart(
            CustomerId customerId,
            MerchandiseId merchandiseId,
            int quantiOf) {
        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));

        addMerchandiseToShoppingCart(customer, merchandiseId, quantiOf);
    }

    public void addMerchandiseToShoppingCart(
            MailAddress customerMailAddress,
            MerchandiseId merchandiseId,
            int quantiOf) {
        if (customerMailAddress == null || merchandiseId == null)
            throw new InvalidMailAddressException("Customer mail address and merchandise ID must not be null");

        Customer customer = customerRepository.findByMailAddress(customerMailAddress)
                .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));

        addMerchandiseToShoppingCart(customer, merchandiseId, quantiOf);
    }

    public void removeMerchandiseFromShoppingCart(
            MailAddress customerMailAddress,
            MerchandiseId merchandiseId){
        if (customerMailAddress == null || merchandiseId == null)
            throw new InvalidMailAddressException("Customer mail address and merchandise ID must not be null");

        Customer customer = customerRepository.findByMailAddress(customerMailAddress)
                .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));

        removeMerchandiseFromShoppingCart(customer.getId(), merchandiseId);
    }

    public void removeMerchandiseFromShoppingCart(
            CustomerId customerId,
            MerchandiseId merchandiseId){
        ShoppingCart shoppingCart = this.shoppingCartRepository.findByCustomerId(customerId)
                .orElseThrow(() -> new ShoppingCartNotFoundException("Shopping cart of customer not found"));

        shoppingCart.removeFromShoppingCart(merchandiseId);
        shoppingCartRepository.save(shoppingCart);
    }

    public void removeMerchandiseFromShoppingCart(
            MailAddress customerMailAddress,
            MerchandiseId merchandiseId,
            int quantiOf) {
        if (customerMailAddress == null || merchandiseId == null)
            throw new InvalidMailAddressException("Customer mail address and merchandise ID must not be null");

        Customer customer = customerRepository.findByMailAddress(customerMailAddress)
                .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));

        removeMerchandiseFromShoppingCart(customer.getId(), merchandiseId, quantiOf);
    }

    public void removeMerchandiseFromShoppingCart(
            CustomerId customerId,
            MerchandiseId merchandiseId,
            int quantiOf) {
        if (quantiOf <= 0) throw new NegativeQuantityException("Quantity must be positive");

        if (!merchandiseRepository.existsById(merchandiseId))
            throw new MerchandiseNotFoundException("Merchandise not found");

        ShoppingCart shoppingCart = this.shoppingCartRepository.findByCustomerId(customerId)
                .orElseThrow(() -> new ShoppingCartNotFoundException("Shopping cart of customer not found"));

        shoppingCart.removeFromShoppingCart(merchandiseId, quantiOf);
        shoppingCartRepository.save(shoppingCart);
    }

    public ShoppingCart getShoppingCart(CustomerId customerId) {
        Customer customer = this.customerRepository.findById(customerId)
                .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));

        return getShoppingCart(customer);
    }

    public ShoppingCart getShoppingCart(MailAddress customerMailAddress) {
        Customer customer = this.customerRepository.findByMailAddress(customerMailAddress)
                .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));

        return getShoppingCart(customer);
    }

    public ShoppingCart getShoppingCart(Customer customer) {
        return this.shoppingCartRepository.findByCustomerId(customer.getId())
                .orElseGet(() -> {
                    ShoppingCart shoppingCart = new ShoppingCart(customer.getId());
                    this.shoppingCartRepository.save(shoppingCart);
                    return shoppingCart;
                });
    }

    public ShoppingCart getShoppingCart(ShoppingCartId shoppingCartId) {
        return this.shoppingCartRepository.findById(shoppingCartId)
                .orElseThrow(() -> new ShoppingCartNotFoundException("Shopping cart not found"));
    }

    public Map<UUID, Integer> getShoppingCartAsMap(MailAddress customerMailAddress) {
        return getShoppingCart(customerMailAddress)
                .toMap()
                .entrySet()
                .stream()
                .collect(Collectors.toMap(
                        entry -> entry.getKey().getId(),
                        Map.Entry::getValue));
    }

    public Money getShoppingCartAsMoneyValue(MailAddress customerMailAddress) {
        Customer customer = this.customerRepository.findByMailAddress(customerMailAddress)
                .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));

        return getShoppingCartAsMoneyValue(customer.getId());
    }

    public Money getShoppingCartAsMoneyValue(CustomerId customerId) {
        ShoppingCart shoppingCart = this.shoppingCartRepository.findByCustomerId(customerId)
                .orElseThrow(() -> new ShoppingCartNotFoundException("Shopping cart of customer not found"));

        if(shoppingCart.getShoppingCartPartList().isEmpty()) return Money.of(0f, "EUR");

        Merchandise firstItem = this.merchandiseRepository.findById(
                        shoppingCart.getShoppingCartPartList().getFirst().getMerchandiseId())
                .orElseThrow(() -> new MerchandiseNotFoundException("First merchandise not found"));

        String currency = firstItem.getSalesPrice().getCurrencyUnit();

        Money total = Money.of(0f, currency);

        for(ShoppingCartPart shoppingCartPart : shoppingCart.getShoppingCartPartList()) {
            Merchandise merchandise = this.merchandiseRepository.findById(shoppingCartPart.getMerchandiseId())
                    .orElseThrow(() -> new MerchandiseNotFoundException("Merchandise not found"));

            total = total.add(merchandise.getSalesPrice().multiplyBy(shoppingCartPart.getQuantity()));
        }

        return total;
    }

    public Set<PurchaseId> checkout(MailAddress customerMailAddress) {
        if (customerMailAddress == null)
            throw new InvalidMailAddressException("Customer mail address can not be null");

        // get customer
        Customer customer = this.customerRepository.findByMailAddress(customerMailAddress)
                .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));

        return checkout(customer);
    }

    public Set<PurchaseId> checkout(CustomerId customerId) {
        // get customer
        Customer customer = this.customerRepository.findById(customerId)
                .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));

        return checkout(customer);
    }

    public Set<PurchaseId> checkout(Customer customer) {
        // get shoppingCart
        ShoppingCart shoppingCart = shoppingCartRepository.findByCustomerId(customer.getId())
                .orElseThrow(() -> new ShoppingCartNotFoundException("Shopping cart not found"));

        return checkout(customer, shoppingCart);
    }

    public Set<PurchaseId> checkout(ShoppingCartId shoppingCartId) {
        // get shoppingCart
        ShoppingCart shoppingCart = shoppingCartRepository.findById(shoppingCartId)
                .orElseThrow(() -> new ShoppingCartNotFoundException("Shopping cart not found"));

        // get customer
        Customer customer = this.customerRepository.findById(shoppingCart.getCustomerId())
                .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));

        return checkout(customer, shoppingCart);
    }

    public Set<PurchaseId> checkout(ShoppingCart shoppingCart) {
        // get customer
        Customer customer = this.customerRepository.findById(shoppingCart.getCustomerId())
                .orElseThrow(() -> new CustomerNotFoundException("Customer not found"));

        return checkout(customer, shoppingCart);
    }

    private Set<PurchaseId> checkout(Customer customer, ShoppingCart shoppingCart) {
        List<FulfillmentCenter> fulfillmentCenters = (List<FulfillmentCenter>) this.fulfillmentCenterRepository.findAll();

        Set<PurchaseId> purchaseIds = new HashSet<>();

        while(!shoppingCart.getShoppingCartPartList().isEmpty()) {
            fulfillmentCenters.sort(new FulfillmentCenterComparator(
                    shoppingCart.toMap(),
                    customer.getPhysicalAddress().getZipCode()));

            FulfillmentCenter selectedFulfillmentCenter = fulfillmentCenters.getFirst();
            Set<MerchandiseId> selectedMerchandise = selectedFulfillmentCenter
                    .fulfillableShoppingCartParts(shoppingCart.toMap());

            if(selectedMerchandise.isEmpty()) {
                throw new InsufficientMerchandiseInventoryException("Checkout failed: Merchandise not in stock");
            }

            Purchase purchase = new Purchase(customer.getId(), selectedFulfillmentCenter.getId());
            this.purchaseRepository.save(purchase);

            purchaseIds.add(purchase.getId());

            for(MerchandiseId merchandiseId :selectedMerchandise){
                int quantity = shoppingCart.getQuantity(merchandiseId);

                purchase.addPurchasePart(merchandiseId, quantity);
                this.purchaseRepository.save(purchase);

                shoppingCart.removeFromShoppingCart(merchandiseId, quantity);
                selectedFulfillmentCenter.removeFromInventory(merchandiseId, quantity);
            }
        }

        // clear shopping cart
        shoppingCart.clear();
        this.shoppingCartRepository.save(shoppingCart);

        return purchaseIds;
    }

    public void emptyAllShoppingCarts() {
        this.shoppingCartRepository.findAll().forEach(ShoppingCart::clear);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCart.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;

import jakarta.persistence.*;
import lombok.*;
import thkoeln.archilab.ecommerce.InsufficientInventoryException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.InsufficientMerchandiseInventoryException;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.MerchandiseNotFoundException;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ShoppingCart {
    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private ShoppingCartId id;

    @Column(nullable = false, unique = true)
    private CustomerId customerId;

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)
    private List<ShoppingCartPart> shoppingCartPartList;

    public ShoppingCart(CustomerId customerId) {
        this.id = new ShoppingCartId(UUID.randomUUID());
        this.customerId = customerId;
        this.shoppingCartPartList = new ArrayList<>();
    }

    public void addToShoppingCart(MerchandiseId merchandiseId, int quantity) {
        shoppingCartPartList.stream()
                .filter(shoppingCartPart -> shoppingCartPart.getMerchandiseId().equals(merchandiseId))
                .findFirst()
                .ifPresentOrElse(
                        shoppingCartPart -> shoppingCartPart.setQuantity(
                                shoppingCartPart.getQuantity() + quantity),
                        () -> shoppingCartPartList.add(
                                new ShoppingCartPart(merchandiseId, quantity))
                );
    }

    public void removeFromShoppingCart(MerchandiseId merchandiseId) {
        shoppingCartPartList
                .stream()
                .filter(shoppingCartPart -> shoppingCartPart.getMerchandiseId().equals(merchandiseId))
                .findFirst()
                .ifPresentOrElse(
                        shoppingCartPart -> shoppingCartPartList.remove(shoppingCartPart),
                        () -> {
                            throw new MerchandiseNotFoundException("Merchandise not found");
                        }
                );
    }

    public void removeFromShoppingCart(MerchandiseId merchandiseId, int quantity) {
        shoppingCartPartList.stream()
                .filter(shoppingCartPart -> shoppingCartPart.getMerchandiseId().equals(merchandiseId))
                .findFirst()
                .ifPresent(shoppingCartPart -> {
                    int newQuantity = shoppingCartPart.getQuantity() - quantity;
                    if (newQuantity < 0)
                        throw new InsufficientMerchandiseInventoryException(
                                "Cannot remove " + quantity
                                        + " of merchandise " + merchandiseId +
                                        ". Only " + shoppingCartPart.getQuantity()
                                        + " in shopping cart");
                    else if(newQuantity == 0) shoppingCartPartList.remove(shoppingCartPart);
                    else shoppingCartPart.setQuantity(newQuantity);
                });
    }

    public Integer getQuantity(MerchandiseId merchandiseId) {
        return shoppingCartPartList.stream()
                .filter(shoppingCartPart ->
                        shoppingCartPart.getMerchandiseId().equals(merchandiseId))
                .findFirst()
                .map(ShoppingCartPart::getQuantity)
                .orElseThrow(() -> new MerchandiseNotFoundException(
                        "Merchandise not found in shopping cart"));
    }

    public Map<MerchandiseId, Integer> toMap() {
        return shoppingCartPartList.stream()
                .collect(Collectors.toMap(
                        ShoppingCartPart::getMerchandiseId,
                        ShoppingCartPart::getQuantity
                ));
    }

    public void clear(){
        shoppingCartPartList.clear();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartId.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;


import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "shoppingcart_id"))
public class ShoppingCartId extends GenericId {
    public ShoppingCartId(UUID id) {
        super(id);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;

@Converter(autoApply = true)
public class ShoppingCartIdConverter extends GenericIdConverter<ShoppingCartId> {
    public ShoppingCartIdConverter() {
        super(ShoppingCartId::new);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPart.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;

import jakarta.persistence.Column;
import jakarta.persistence.EmbeddedId;
import jakarta.persistence.Entity;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;

import java.util.UUID;

@Entity
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class ShoppingCartPart {
    @Setter(AccessLevel.PRIVATE)
    @EmbeddedId
    private ShoppingCartPartId id;

    @Column(nullable = false)
    private MerchandiseId merchandiseId;

    @Setter
    private int quantity;

    public ShoppingCartPart(MerchandiseId merchandiseId, int quantity) {
        this.id = new ShoppingCartPartId(UUID.randomUUID());
        this.merchandiseId = merchandiseId;
        this.quantity = quantity;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPartId.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;

import jakarta.persistence.AttributeOverride;
import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.UUID;

@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AttributeOverride(name = "id", column = @Column(name = "shoppingcartpart_id"))
public class ShoppingCartPartId extends GenericId {
    public ShoppingCartPartId(UUID id) {
        super(id);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartPartIdConverter.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;

import jakarta.persistence.Converter;
import thkoeln.archilab.ecommerce.GenericIdConverter;


@Converter(autoApply = true)
public class ShoppingCartPartIdConverter extends GenericIdConverter<ShoppingCartPartId> {
    public ShoppingCartPartIdConverter() {
        super(ShoppingCartPartId::new);
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingcart\domain\ShoppingCartRepository.java ---
package thkoeln.archilab.ecommerce.solution.shoppingcart.domain;

import org.springframework.data.repository.CrudRepository;
import thkoeln.archilab.ecommerce.solution.customer.domain.CustomerId;

import java.util.Optional;

public interface ShoppingCartRepository extends CrudRepository<ShoppingCart, ShoppingCartId> {
    // find by
    Optional<ShoppingCart> findByCustomerId(CustomerId customerId);

    // exists by
    boolean existsByCustomerId(CustomerId customerId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\CustomerRegistrationUseCases.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

/**
 * This interface contains methods needed in the context of use cases concerning the registration of a customer.
 * The interface is probably incomplete, and will grow over time ...
 */
public interface CustomerRegistrationUseCases {
    /**
     * Registers a new customer
     *
     * @param name
     * @param mailAddress
     * @param physicalAddress
     * @throws ShopException if ...
     *      - the customer with the given mail address already exists
     *      - physicalAddress is null
     */
    public void register( String name, MailAddressType mailAddress, PhysicalAddressType physicalAddress );


    /**
     * Changes the address of a customer
     *
     * @param customerMailAddress
     * @param customerMailAddress
     * @param physicalAddress
     * @throws ShopException if ...
     *      - the customer with the given mail address does not exist,
     *      - physicalAddress is null
     */
    public void changeAddress( MailAddressType customerMailAddress,
                               PhysicalAddressType physicalAddress );


    /**
     * Returns the data of a customer as an array of strings (name, mailAddress, street, city, zipCode)
     * @param customerMailAddress
     * @return the customer data
     * @throws ShopException the customer with the given mail address does not exist,
     */
    public CustomerType getCustomerData( MailAddressType customerMailAddress );



    /**
     * Clears all customers, including all purchases and shopping carts
     */
    public void deleteAllCustomers();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\CustomerType.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

/**
 * This interface expresses the essence of a shop customer
 */
public interface CustomerType {
    String getName();
    MailAddressType getMailAddress();
    PhysicalAddressType getPhysicalAddress();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MailAddressType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface MailAddressType {
    /**
     * @return the mail address as a string
     */
    public String toString();


    /**
     * A special kind of "copy constructor": Returns a new mail address object with
     * the same identifyer (the substring left of the "@" sign) as the current one, but
     * with a new domain substring (right of the "@" sign).
     * @param domainString - the new domain for the copied mail address
     * @return the new mail address
     * @throws ShopException if ...
     *     - domainString is null
     *     - the new mail address would not be valid (see `of(...)` method)
     */
    public MailAddressType sameIdentifyerDifferentDomain( String domainString );

    /**
     * Another special kind of "copy constructor": Returns a new mail address object
     * with the same domain (the substring right of the "@" sign) as the current one, but
     * with a new identifyer substring (left of the "@" sign).
     * @param identifyerString - the new identifyer for the copied mail address
     * @return the new mail address
     * @throws ShopException if ...
     *     - identifyerString is null
     *     - the new mail address would not be valid (see `of(...)` method)
     */
    public MailAddressType sameDomainDifferentIdentifyer( String identifyerString );


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an mail address, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param mailAddressAsString - the mail address as a string.
     *      We will use a much simplified validation method to check if the mail address is valid:
     *      - it must contain exactly one '@' character.
     *      - the substring before the '@' and the substring after the '@' must not be empty, contain of
     *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
     *      - the substrings before and after the '@' may contain one or several '.' as separators
     *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
     *      - the substrings after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
     *        (for simplicity we do not allow any other domains)
     * @return a new MailAddressType object matching the given mail address
     * @throws ShopException if ...
     *      - mailAddressAsString is null
     *      - mailAddressAsString is not a valid mail address (see above)
     */
     // public static MailAddressType of( String mailAddressAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MoneyType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface MoneyType {
    /**
     * @return the amount of money
     */
    public Float getAmount();


    /**
     * @return the currency unit of the money
     */
    public String getCurrencyUnit();


    /**
     * @param otherMoney
     * @return this + otherMoney, as a new object
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currencyUnit != this.currencyUnit
     */
    public MoneyType add( MoneyType otherMoney );


    /**
     * @param otherMoney
     * @return this - otherMoney, as a new object
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currencyUnit != this.currencyUnit
     *      - otherMoney > this
     */
    public MoneyType subtract( MoneyType otherMoney );


    /**
     * @param factor
     * @return this * factor, as a new object
     * @throws ShopException if ...
     *     - factor < 0
     */
    public MoneyType multiplyBy( int factor );

    /**
     * @param otherMoney
     * @return true, if this > otherMoney
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currencyUnit != this.currencyUnit
     */
    public boolean largerThan( MoneyType otherMoney );


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates a money object from an amount and a currency unit (as string).
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param amount the amount of money (must be >= 0)
     * @param currencyUnit the currency unit of the money (allowed values: "EUR", "CHF")
     * @return a new Money object with the given amount and currency unit
     * @throws ShopException if ...
     *   - amount is null
     *   - amount < 0
     *   - currency unit is null
     *   - currency unit is not one of the allowed values
     */
     // public static MoneyType of( Float amount, String currencyUnit );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PhysicalAddressType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface PhysicalAddressType {
    /**
     * @return the street as a string
     */
    public String getStreet();

    /**
     * @return the city as a string
     */
    public String getCity();

    /**
     * @return the zip code
     */
    public ZipCodeType getZipCode();

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an zip code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param street the street as a string
     * @param city the city as a string
     * @param zipCode the zip code
     * @return the physical address object matching the parameters
     * @throws ShopException if ...
     *      - street is null or empty
     *      - city is null or empty
     *      - zipCode is null
     */
     // public static PhysicalAddressType of( String street, String city, ZipCodeType zipCode );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\ZipCodeType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import com.fasterxml.jackson.annotation.JsonIgnore;
import thkoeln.archilab.ecommerce.ShopException;

public interface ZipCodeType {
    /**
     * @return the zip code as a string
     */
    public String toString();

    /**
     * You will need some idea of "imprecise difference" between two zip codes for properly
     * implementing fulfillment centers in your shopping platform. This method calculates such a
     * difference. You can decide for yourself what values you return, unless you comply
     * with the following rules.
     * - The return value is 0 if both zip codes are the same
     * - If not:
     *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
     *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
     *        So, 56733 and 56734 have the same difference as 56733 and 56739.
     *      - The difference grows if more digits (counted from the right side) differ.
     *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
     *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
     *        53876 and 54876 have the same difference as 53876 and 57261.
     *      - However, the difference between 5abcd and 6rstu must be smaller than the one
     *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
     *        one between 5abcd and 9rstu.
     *      - This last condition reflects the fact the first digits of a zip code marks a region
     *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
     *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
     *        other.
     * @param otherZipCode
     * @return the calculated difference
     * @throws ShopException if otherZipCode is null
     */
    public int difference( ZipCodeType otherZipCode );


    /**
     * For the currently used way of deciding on the best fitting fulfillment center for a purchase,
     * we need to know the first digit of the zip code.
     */
    @JsonIgnore
    public Integer getFirstDigitZipCode();


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an zip code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param zipCodeAsString - the zip code as a string.
     *      We will use a much simplified validation method to check if the zip code is valid:
     *      - It must contain exactly 5 digits.
     *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid zip code, but 20001 is valid)
     * @return a new zip code object matching the given string
     * @throws ShopException if ...
     *      - zipCodeAsString is null
     *      - zipCodeAsString is not a valid zip code (see above)
     */
     // public static ZipCodeType of( String zipCodeAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\FulfillmentCenterUseCases.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.UUID;

/**
 * This interface contains methods needed in the context of handling the shop inventory,
 * i.e. managing fulfillment centers, and adding / removing merchandises in the fulfillment center.
 */
public interface FulfillmentCenterUseCases {
    /**
     *
     * @param name
     * @param physicalAddress
     * @return the id of the new fulfillment center
     * @throws ShopException if ...
     *      - name is null or empty
     *      - physicalAddress is null
     */
    public UUID addNewFulfillmentCenter( String name, PhysicalAddressType physicalAddress );


    /**
     * Deletes all fulfillment centers from the shop. Intended for testing purposes.
     */
    public void deleteAllFulfillmentCenters();


    /**
     * Adds a certain Quantity of a given merchandise to the inventory
     * @param fulfillmentCenterId
     * @param merchandiseId
     * @param addedQuantiOf
     * @throws ShopException if ...
     *      - fulfillmentCenterId is null
     *      - the fulfillment center with that id does not exist
     *      - merchandiseId is null
     *      - the merchandise with that id does not exist
     *      - addedQuantiOf < 0
     */
    public void addToInventory( UUID fulfillmentCenterId, UUID merchandiseId, int addedQuantiOf );


    /**
     * Removes a certain Quantity of a given merchandise from the inventory.
     * @param fulfillmentCenterId
     * @param merchandiseId
     * @param removedQuantiOf
     * @throws ShopException if ...
     *      - fulfillmentCenterId is null
     *      - the fulfillment center with that id does not exist
     *      - merchandiseId is null
     *      - the merchandise with that id does not exist
     *      - removedQuantiOf < 0
     */
    public void removeFromInventory( UUID fulfillmentCenterId, UUID merchandiseId, int removedQuantiOf );


    /**
     * Changes the total Quantity of a given merchandise in the inventory.
     * @param fulfillmentCenterId
     * @param merchandiseId
     * @param newTotalQuantiOf
     * @throws ShopException if ...
     *      - fulfillmentCenterId is null
     *      - the fulfillment center with that id does not exist
     *      - merchandiseId is null
     *      - the merchandise with that id does not exist
     *      - newTotalQuantiOf < 0
     */
    public void changeInventoryTo( UUID fulfillmentCenterId, UUID merchandiseId, int newTotalQuantiOf );


    /**
     * Get the current inventory of a given merchandise in one specific fulfillment center.
     * @param fulfillmentCenterId
     * @param merchandiseId
     * @return the current total inventory of the merchandise
     * @throws ShopException if ...
     *      - fulfillmentCenterId is null
     *      - the fulfillment center with that id does not exist
     *      - merchandiseId is null
     *      - the merchandise with that id does not exist
     */
    public int getAvailableInventory( UUID fulfillmentCenterId, UUID merchandiseId );


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\CustomerTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;


import thkoeln.archilab.ecommerce.usecases.CustomerType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

/**
 * This is a test helper interface provides access to predefined test data for
 * customers.
 */
public interface CustomerTestHelper {
    /**
     * This method calls the use case implementation to register all customers specified in the
     * test data set.
     * If you use the debugger and want to identify _which_ test customer you currently look at:
     * The indices are coded into the house number (in the customer's physical address) and in the first
     * cipher of the zip code. This is the list of customers:
     *
     * +-------+-------------------+--------+---------------------
     * | Index | Name              | PLZ    | MailAddress
     * +-------+-------------------+--------+---------------------
     * | 0     | Max Mueller       | 02314  | 99Z@example.com
     * | 1     | Sophie Schmitz    | 02368  | a@4.com
     * | 2     | Irene Mihalic     | 12345  | irene@wearefreedomnow.com
     * | 3     | Emilia Fischer    | 31463  | emilia.fischer@example.com
     * | 4     | Filiz Polat       | 72162  | j877d3@example.this.com
     * | 5     | Lina Wagner       | 82195  | lina.marie.wagner@example.com
     * | 6     | Leon Becker       | 50667  | 0.1.2.3.4.5.6.7.8.becker@example.com
     * | 7     | Agnieszka Kalterer| 60311  | agna@here.ch
     * | 8     | Felix Bauer       | 70173  | felix.bauer@example.org
     * | 9     | Lara Schulz       | 80331  | lara.schulz@example.at
     * +-------+-------------------+--------+---------------------
     */
    void registerAllCustomers();


    /**
     * @return the number of test customers in the test data set.
     */
    int getNumberOfCustomers();


    /**
     * @param index the index of the customer in the test data set.
     * @return the name of the test customer with the given index.
     */
    String getCustomerName( int index );


    /**
     * @param index the index of the customer in the test data set.
     * @return the mail address of the test customer with the given index.
     */
    MailAddressType getCustomerMailAddress( int index );


    /**
     * @param index the index of the customer in the test data set.
     * @return the physical address of the test customer with the given index.
     */
    PhysicalAddressType getCustomerPhysicalAddress( int index );


    /**
     * @param index the index of the customer in the test data set.
     * @return the test customer with the given index.
     */
    CustomerType getCustomer( int index );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FactoryMethodInvoker.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.Enumeration;

import static org.junit.jupiter.api.Assertions.*;

public class FactoryMethodInvoker {

    public static MailAddressType instantiateMailAddress( String mailAddressAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for MailAddressType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, mailAddressAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + mailAddressAsString + "'", e );
        }
        assertNotNull( instance );
        return (MailAddressType) instance;
    }


    public static PhysicalAddressType instantiatePhysicalAddress(
            String street, String city, ZipCodeType zipCode ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of",
                    String.class, String.class, ZipCodeType.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for PhysicalAddressType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, street, city, zipCode );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" +
                    street + "', '" + city + "', '" + zipCode + "'", e );
        }
        assertNotNull( instance );
        return (PhysicalAddressType) instance;
    }


    public static ZipCodeType instantiateZipCode( String zipCodeAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for ZipCodeType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, zipCodeAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + zipCodeAsString + "'", e );
        }
        assertNotNull( instance );
        return (ZipCodeType) instance;
    }


    public static MoneyType instantiateMoney( Float amount, String currencyUnit ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for MoneyType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, amount, currencyUnit );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + amount + "', '" + currencyUnit + "'", e );
        }
        assertNotNull( instance );
        return (MoneyType) instance;
    }


    private static Class<?> findImplementation( Class<?> interfaceClass ) {
        Method factoryMethod = null;
        try {
            String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
            Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
            assertNotNull( implementingClass );
            return implementingClass;
        } catch (Exception e) {
            fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
            return null; // This line will never be reached, but it's necessary to satisfy the compiler
        }
    }


    private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
            throws ClassNotFoundException, IOException {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        String path = packageName.replace( '.', '/' );
        Enumeration<URL> resources = classLoader.getResources( path );
        int count = 0;
        Class<?> result = null;
        while (resources.hasMoreElements()) {
            URL resource = resources.nextElement();
            File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
            File[] files = directory.listFiles();
            for ( File file : files ) {
                if ( file.getName().endsWith( ".class" ) ) {
                    String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
                    Class<?> clazz = Class.forName( className );
                    if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
                        count++;
                        result = clazz;
                    }
                }
            }
        }
        assertEquals( 1, count, "There should be exactly one implementing class" );
        return result;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\FulfillmentCenterTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import java.util.UUID;

public interface FulfillmentCenterTestHelper {
    /**
     * Adds the test fulfillment centers to the system.
     * If you want to use the fulfillment centers, or want to know which index the fulfillment center has that you see
     * in the debugger, the following rules apply:
     * - The fulfillment center name will equal the street name of the physical address of the fulfillment center.
     * - The index number is visible in the house number. Example: fulfillment center 3 is located at
     *   "Ablageweg 3", and that is also its name.
     *
     *  The fulfillment centers are used in the tests as follows:
     *  - fulfillment center 0 holds all merchandises 0 - 6, and is used for all tests where it is not relevant
     *    to split one shopping cart into several purchases.
     *  - fulfillment centers 1 - 3 are used for the proximity tests, where you can deliver merchandise 7 to
     *    to a customer from the closest fulfillment center.
     *  - fulfillment centers 4 - 8 are used for the tests where you need to deliver merchandises 8 - 14 in
     *    the most cost-efficient way, as multiple shipments.
     *  - fulfillment center 9 is empty.
     *
     *  If withInventory is true, then the fulfillment centers are filled with merchandises. This happens
     *  according to the following rules:
     *  - merchandises 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30, respectively. They are
     *    ONLY available in fulfillment center 0. (This means that merchandise 0 out of inventory everywhere.)
     *  - merchandises 4, 5, 6 have a random inventory between 30 and 130, also all ONLY in fulfillment center 0
          (these are the merchandises used for tests on how to add and remove inventory)
     *  - merchandise 7 has a random inventory between 30 and 130, distributed over
     *    fulfillment centers 1, 2, and 3. You can use this to test if the appropriate fulfillment center is found
     *    for a shopping cart with only merchandise 7 in it, but with different quantities (<= 3, or > 3).
     *  - The other merchandises (8 - 14) have also a random inventory between 30 and 130, all distributed
     *    over several fulfillment centers. The distribution is done as follows:
     *    Assume that the merchandise is available in <n> fulfillment centers. Then the first <n-1> fulfillment centers
     *    in the list (in ascending sequence) contain 3, and all the remaining inventory is in the
     *    last fulfillment center.
     *
     *    This is how the inventory of merchandises could be distributed
     *    (Wx = fulfillment center x with its zip code, Px = merchandise x,
     *    numbers marked with (*) are random large numbers):
     *
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *    |      | W0   | W1  | W2  | W3   | W4  | W5   | W6  | W7    | W8   | W9  |
     *    |      |14476 |02345|02313|44923 |40588|52355 |68519|76532  |89250 |97618|
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *    | P0   |      |     |     |      |     |      |     |       |      |     |
     *    | P1   | 10   |     |     |      |     |      |     |       |      |     |
     *    | P2   | 20   |     |     |      |     |      |     |       |      |     |
     *    | P3   | 30   |     |     |      |     |      |     |       |      |     |
     *    | P4   | 65(*)|     |     |      |     |      |     |       |      |     |
     *    | P5   | 87(*)|     |     |      |     |      |     |       |      |     |
     *    | P6   | 43(*)|     |     |      |     |      |     |       |      |     |
     *    | P7   |      | 3   | 3   | 81(*)|     |      |     |       |      |     |
     *    | P8   |      |     |     |      | 3   |      | 3   | 110(*)|      |     |
     *    | P9   |      |     |     |      |     | 3    |     | 3     | 71(*)|     |
     *    | P10  |      |     |     |      |     | 3    | 3   | 43(*) |      |     |
     *    | P11  |      |     |     |      | 3   |      |     | 3     | 81(*)|     |
     *    | P12  |      |     |     |      |     | 92(*)|     |       |      |     |
     *    | P13  |      |     |     |      |     |      |     | 3     | 51(*)|     |
     *    | P14  |      |     |     |      | 3   | 3    |     | 78(*) |      |     |
     *    +------+------+-----+-----+------+-----+------+-----+-------+------+-----+
     *
     * @param withInventory if true, the inventory of the merchandises is added to the fulfillment center. Otherwise, the
     *                           the inventory is not added and the fulfillment center is empty.
     */
    public void addAllFulfillmentCenters( boolean withInventory );


    /**
     * @return the number of test fulfillment centers in the database
     */
    int numberOfFulfillmentCenters();


    /**
     * @param index
     * @return the id of the test fulfillment center at the given index
     */
    UUID getFulfillmentCenterId( int index );


    /**
     * @param fulfillmentCenterId - the id of the fulfillment center in the test data
     * @return the index of the test fulfillment center with that id
     */
    int findFulfillmentCenterIndex( UUID fulfillmentCenterId );


    /**
     * @param merchandiseIndex - the index of the merchandise in the test data
     * @param fulfillmentCenterIndex - the index of the fulfillment center in the test data
     * @return the number of merchandises (inventory) available in the fulfillment center at the given index
     */
    Integer getFulfillmentCenterInventory( int fulfillmentCenterIndex, int merchandiseIndex );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\CustomerTestHelperImpl.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.CustomerType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
import thkoeln.archilab.ecommerce.usecases.masterdata.MockCustomer;

import static org.junit.jupiter.api.Assertions.assertThrows;

/**
 * This is a test helper class that initializes and registers customers in the system,
 * using the given interface(s).
 */
@Component
@SuppressWarnings("PMD")
public class CustomerTestHelperImpl implements CustomerTestHelper {

    private CustomerRegistrationUseCases customerRegistrationUseCases;

    @Autowired
    public CustomerTestHelperImpl( CustomerRegistrationUseCases customerRegistrationUseCases ) {
        this.customerRegistrationUseCases = customerRegistrationUseCases;
    }

    private final static String[] CUSTOMER_NAME = new String[]{
            "Max Mueller",
            "Sophie Schmitz",
            "Irene Mihalic",
            "Emilia Fischer",
            "Filiz Polat",
            "Lina Wagner",
            "Leon Becker",
            "Agnieszka Kalterer",
            "Felix Bauer",
            "Lara Schulz"
    };

    private final static MailAddressType[] CUSTOMER_EMAIL = new MailAddressType[]{
            FactoryMethodInvoker.instantiateMailAddress( "99Z@example.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "a@4.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "irene@wearefreedomnow.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "emilia.fischer@example.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "j877d3@example.this.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "lina.marie.wagner@example.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "0.1.2.3.4.5.6.7.8.becker@example.com" ),
            FactoryMethodInvoker.instantiateMailAddress( "agna@here.ch" ),
            FactoryMethodInvoker.instantiateMailAddress( "felix.bauer@example.org" ),
            FactoryMethodInvoker.instantiateMailAddress( "lara.schulz@example.at" )
    };

    // The following array is used to create a list of physicalAddresss for the customers.
    // The indices are coded into the house number.
    // - Persons 0 - 5 are used for proximity tests with one fulfillment center.
    private final static PhysicalAddressType[] CUSTOMER_ADDRESS = new PhysicalAddressType[]{
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Marktstraße 0", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02314" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Hauptstraße 1", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02368" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Kirchplatz 2", "Niemandstown",
                    FactoryMethodInvoker.instantiateZipCode( "12345" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Schulstraße 3", "Geisterhausen",
                    FactoryMethodInvoker.instantiateZipCode( "31463" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Rosenweg 4", "Kuhhausen",
                    FactoryMethodInvoker.instantiateZipCode( "72162" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Wiesenstraße 5", "Waldschenkensdorf",
                    FactoryMethodInvoker.instantiateZipCode( "82195" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Muehlenweg 6", "Koeln",
                    FactoryMethodInvoker.instantiateZipCode( "50667" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Goethestraße 7", "Frankfurt am Main",
                    FactoryMethodInvoker.instantiateZipCode( "60311" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Dorfstraße 8", "Stuttgart",
                    FactoryMethodInvoker.instantiateZipCode( "70173" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Bahnhofstraße 9", "Muenchen",
                    FactoryMethodInvoker.instantiateZipCode( "80331" ) )
    };

    private final static CustomerType[] mockCustomers;

    static {
        mockCustomers = new CustomerType[CUSTOMER_NAME.length];
        for ( int i = 0; i < CUSTOMER_NAME.length; i++ ) {
            mockCustomers[i] = new MockCustomer(
                    CUSTOMER_NAME[i], CUSTOMER_EMAIL[i], CUSTOMER_ADDRESS[i] );
        }
    }


    @Override
    public void registerAllCustomers() {
        for ( int i = 0; i < CUSTOMER_NAME.length; i++ ) {
            registerCustomer( CUSTOMER_NAME[i], CUSTOMER_EMAIL[i], CUSTOMER_ADDRESS[i] );
        }
    }


    private void registerCustomer( String name, MailAddressType mailAddress, PhysicalAddressType physicalAddress ) {
        customerRegistrationUseCases.register( name, mailAddress, physicalAddress );
    }


    @Override
    public int getNumberOfCustomers() {
        return CUSTOMER_NAME.length;
    }


    @Override
    public String getCustomerName( int index ) {
        if ( index < 0 || index >= CUSTOMER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return CUSTOMER_NAME[index];
    }


    @Override
    public MailAddressType getCustomerMailAddress( int index ) {
        if ( index < 0 || index >= CUSTOMER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return CUSTOMER_EMAIL[index];
    }


    @Override
    public PhysicalAddressType getCustomerPhysicalAddress( int index ) {
        if ( index < 0 || index >= CUSTOMER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return CUSTOMER_ADDRESS[index];
    }


    @Override
    public CustomerType getCustomer( int index ) {
        if ( index < 0 || index >= CUSTOMER_NAME.length ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return mockCustomers[index];
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\impl\InventoryTestHelperImpl.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;

import java.util.*;

/**
 * This is a test helper class that initializes and registers merchandises (but without inventory)
 * in the system, using the given interface(s).
 */
@Component
@SuppressWarnings("PMD")
public class InventoryTestHelperImpl
                        implements MerchandiseTestHelper, FulfillmentCenterTestHelper {
    private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    private static Random random = new Random();

    private static final String EUR = "EUR";
    private static final int MERCHANDISE_NUMOF = 15;
    private static final Object[][] MERCHANDISE_DATA = new Object[][]{
            {null, "0-TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
                    1.5f, FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 10.0f, EUR ),
                    "0"},
            {null, "1-EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
                    0.3f, FactoryMethodInvoker.instantiateMoney( 2.5f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 4.0f, EUR ),
                    "0"},
            {null, "2-MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
                    7.2f, FactoryMethodInvoker.instantiateMoney( 50.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
                    "0"},
            {null, "3-Gh-25", "Kompakter und leichter Akku für mobile Geräte",
                    null, FactoryMethodInvoker.instantiateMoney( 6.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 8.0f, EUR ),
                    "0"},
            {null, "4-MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
                    null, FactoryMethodInvoker.instantiateMoney( 0.6f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
                    "0"},
            {null, "5-ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
                    1.0f, FactoryMethodInvoker.instantiateMoney( 150.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 250.0f, EUR ),
                    "0"},
            {null, "6-Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
                    null, FactoryMethodInvoker.instantiateMoney( 0.3f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 0.5f, EUR ),
                    "0"},
            {null, "7-Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
                    6.0f, FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 120.0f, EUR ),
                    "123"},
            {null, "8-JKL-67", "Wasserdichtes Gehäuse",
                    3.0f, FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 1.2f, EUR ),
                    "467"},
            {null, "9-MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
                    5.5f, FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 45.0f, EUR ),
                    "578"},
            {null, "10-PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
                    4.0f, FactoryMethodInvoker.instantiateMoney( 20.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 35.0f, EUR ),
                    "567"},
            {null, "11-STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
                    null, FactoryMethodInvoker.instantiateMoney( 200.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 350.0f, EUR ),
                    "478"},
            {null, "12-VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
                    null, FactoryMethodInvoker.instantiateMoney( 15.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
                    "5"},
            {null, "13-YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
                    3.5f, FactoryMethodInvoker.instantiateMoney( 60.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 100.0f, EUR ),
                    "78"},
            {null, "14-Nosedive", "Klammer zum Verschließen der Nase beim Tauchen",
                    5.0f, FactoryMethodInvoker.instantiateMoney( 2.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
                    "457"}
    };
    

    // These physical addresss are used for the fulfillment centers. The fulfillment center name will equal
    // the zip code of the site. Their index number will be visible in the house number.
    // The fulfillment centers are used as such:
    // - fulfillment center 0 is holds all merchandises 0 - 6, and is used for all tests where multiple
    //   shipments are irrelevant.
    // - fulfillment centers 1 - 3 are used for the proximity tests, where you can deliver merchandises 7 to
    //   to a customer from the closest fulfillment center.
    // - fulfillment centers 4 - 8 are used for the tests where you need to deliver merchandises 8 - 14 in
    //   the most cost-efficient way, as multiple shipments.
    // - fulfillment center 9 is empty.
    private final static int FULFILLMENT_CENTER_NUMOF = 10;
    private final static PhysicalAddressType[] FULFILLMENT_CENTER_PHYSICAL_ADDRESS = new PhysicalAddressType[]{
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Stapelallee 0", "Potsdam",
                    FactoryMethodInvoker.instantiateZipCode( "14476" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Lagerhausstr. 1", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02345" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Speicherplatz 2", "Viertelstadt",
                    FactoryMethodInvoker.instantiateZipCode( "02313" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Ablageweg 3", "Reichswürgen",
                    FactoryMethodInvoker.instantiateZipCode( "44923" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Paketstellenallee 4", "Düsseldorf",
                    FactoryMethodInvoker.instantiateZipCode( "40588" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Kaputte-Sachen-Straße 5", "Düren",
                    FactoryMethodInvoker.instantiateZipCode( "52355" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Aufbewahrungsweg 6", "Viernheim",
                    FactoryMethodInvoker.instantiateZipCode( "68519" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Paketallee 7", "Baden-Baden",
                    FactoryMethodInvoker.instantiateZipCode( "76532" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Sendenstr. 8", "Senden",
                    FactoryMethodInvoker.instantiateZipCode( "89250" ) ),
            FactoryMethodInvoker.instantiatePhysicalAddress(
                    "Schickweg 9", "Hohenroth",
                    FactoryMethodInvoker.instantiateZipCode( "97618" ) )
    };
    private final static UUID[] FULFILLMENT_CENTER_ID = new UUID[FULFILLMENT_CENTER_NUMOF];


    // These data structures contain the inventory of the merchandises in the fulfillment centers.
    // MERCHANDISE_INVENTORY is a map merchandise name -> Integer[FULFILLMENT_CENTER_NUMOF].
    // The Integer[FULFILLMENT_CENTER_NUMOF] contains the inventory of the merchandise in each of
    // the fulfillment centers.
    //
    // The following rules apply:
    // - merchandise 0 is out of inventory
    // - merchandise 1 / 2 / 3 have fixed quantities of 10 / 20 / 30 respectively, all ONLY in fulfillment center 0
    // - merchandise 4 / 5 / 6 have a random inventory between 30 and 130, also all ONLY in fulfillment center 0
    //   (these are the merchandises used for tests on how to add and remove inventory)
    // - the others have a random inventory between 30 and 130, distributed over several
    //   fulfillment centers. Here we follow this convention for simplicity:
    //   - Assume that the merchandise is available in <n> fulfillment centers. Then the first <n-1> fulfillment centers
    //     in the list (in ascending sequence) contain 3, and all the remaining inventory is in the
    //     last fulfillment center.

    private static final Map<String, Integer[]> MERCHANDISE_INVENTORY = new HashMap<>();

    static {
        // merchandises 0, 1, 2, and 3 have fixed quantities of 0, 10, 20, and 30.
        MERCHANDISE_INVENTORY.put( (String) MERCHANDISE_DATA[0][1],
                getInventoryDistribution( 0, (String) MERCHANDISE_DATA[0][6] ) );
        MERCHANDISE_INVENTORY.put( (String) MERCHANDISE_DATA[1][1],
                getInventoryDistribution( 10, (String) MERCHANDISE_DATA[1][6] ) );
        MERCHANDISE_INVENTORY.put( (String) MERCHANDISE_DATA[2][1],
                getInventoryDistribution( 20, (String) MERCHANDISE_DATA[2][6] ) );
        MERCHANDISE_INVENTORY.put( (String) MERCHANDISE_DATA[3][1],
                getInventoryDistribution( 30, (String) MERCHANDISE_DATA[3][6] ) );

        // The other merchandises have a random inventory between 30 and 130,
        for ( int i = 4; i < MERCHANDISE_NUMOF; i++ ) {
            Integer totalNumber = random.nextInt( 100 ) + 30;
            Integer[] inventoryInFulfillmentCenters =
                    getInventoryDistribution( totalNumber, (String) MERCHANDISE_DATA[i][6] );
            MERCHANDISE_INVENTORY.put( (String) MERCHANDISE_DATA[i][1], inventoryInFulfillmentCenters );
        }
    }

    /**
     * This method creates a random inventory distribution for the given merchandise.
     *
     * @param totalQuantity - the total number of merchandises in the fulfillment centers
     * @param zeroToNine  - a string with numbers between 0 and 9, representing the fulfillment centers
     * @return an Integer array with the inventory distribution for the merchandise, according to
     * the rules described above.
     */
    private static Integer[] getInventoryDistribution( Integer totalQuantity, String zeroToNine ) {
        Integer[] inventoryInFulfillmentCenters = new Integer[FULFILLMENT_CENTER_NUMOF];
        for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) inventoryInFulfillmentCenters[i] = 0;
        TreeSet<Integer> fulfillmentCenterIndices = getFulfillmentCenterIndices( zeroToNine );
        int numOfIndices = fulfillmentCenterIndices.size();
        int currentIndexNumber = 0;
        int currentQuantity = totalQuantity;
        for ( Integer fulfillmentCenterIndex : fulfillmentCenterIndices ) {
            currentIndexNumber++;
            if ( currentIndexNumber < numOfIndices ) {
                inventoryInFulfillmentCenters[fulfillmentCenterIndex] = 3;
                currentQuantity -= 3;
            } else {
                inventoryInFulfillmentCenters[fulfillmentCenterIndex] = currentQuantity;
            }
        }
        return inventoryInFulfillmentCenters;
    }

    private static TreeSet<Integer> getFulfillmentCenterIndices( String zeroToNine ) {
        TreeSet<Integer> fulfillmentCenterIndices = new TreeSet<>();
        for ( int i = 0; i < zeroToNine.length(); i++ ) {
            fulfillmentCenterIndices.add( Integer.parseInt( zeroToNine.substring( i, i + 1 ) ) );
        }
        return fulfillmentCenterIndices;
    }


    @Autowired
    public InventoryTestHelperImpl( MerchandiseCatalogUseCases merchandiseCatalogUseCases,
                                         FulfillmentCenterUseCases fulfillmentCenterUseCases ) {
        this.merchandiseCatalogUseCases = merchandiseCatalogUseCases;
        this.fulfillmentCenterUseCases = fulfillmentCenterUseCases;
    }


    @Override
    public void addAllMerchandises() {
        int i = 0;
        for ( Object[] merchandiseData : MERCHANDISE_DATA ) {
            UUID newId = merchandiseCatalogUseCases.addMerchandiseToCatalog(
                    (String) merchandiseData[1], (String) merchandiseData[2],
                    (Float) merchandiseData[3], (MoneyType) merchandiseData[4],
                    (MoneyType) merchandiseData[5] );
            // The first element of the merchandise data is the id, which was initialized with null before, but can now be set
            MERCHANDISE_DATA[i][0] = newId;
            i++;
        }
    }


    @Override
    public int numberOfMerchandises() {
        return MERCHANDISE_NUMOF;
    }


    @Override
    public UUID getMerchandiseId( int index ) {
        if ( index < 0 || index >= MERCHANDISE_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (UUID) MERCHANDISE_DATA[index][0];
    }


    @Override
    public MoneyType getBuyingPrice( int index ) {
        if ( index < 0 || index >= MERCHANDISE_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (MoneyType) MERCHANDISE_DATA[index][4];
    }


    @Override
    public MoneyType getSalesPrice( int index ) {
        if ( index < 0 || index >= MERCHANDISE_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return (MoneyType) MERCHANDISE_DATA[index][5];
    }


    @Override
    public void addAllFulfillmentCenters( boolean withInventory ) {
        for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) {
            FULFILLMENT_CENTER_ID[i] = fulfillmentCenterUseCases.addNewFulfillmentCenter(
                    FULFILLMENT_CENTER_PHYSICAL_ADDRESS[i].getStreet(),
                    FULFILLMENT_CENTER_PHYSICAL_ADDRESS[i] );
        }
        if ( withInventory ) {
            addAllInventory();
        }
    }


    private void addAllInventory() {
        for ( Object[] merchandiseData : MERCHANDISE_DATA ) {
            Integer[] inventoryInFulfillmentCenters =
                    MERCHANDISE_INVENTORY.get( merchandiseData[1] );
            for ( int iFulfillmentCenter = 0; iFulfillmentCenter < FULFILLMENT_CENTER_NUMOF; iFulfillmentCenter++ ) {
                if ( inventoryInFulfillmentCenters[iFulfillmentCenter] > 0 )
                    fulfillmentCenterUseCases.addToInventory(
                            FULFILLMENT_CENTER_ID[iFulfillmentCenter], (UUID) merchandiseData[0],
                            inventoryInFulfillmentCenters[iFulfillmentCenter] );
            }
        }
    }


    @Override
    public int numberOfFulfillmentCenters() {
        return FULFILLMENT_CENTER_NUMOF;
    }


    @Override
    public UUID getFulfillmentCenterId( int index ) {
        if ( index < 0 || index >= FULFILLMENT_CENTER_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + index );
        }
        return FULFILLMENT_CENTER_ID[index];
    }


    @Override
    public Integer getFulfillmentCenterInventory( int fulfillmentCenterIndex, int merchandiseIndex ) {
        if ( fulfillmentCenterIndex < 0 || fulfillmentCenterIndex >= FULFILLMENT_CENTER_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + fulfillmentCenterIndex );
        }
        if ( merchandiseIndex < 0 || merchandiseIndex >= MERCHANDISE_NUMOF ) {
            throw new IndexOutOfBoundsException( "Index out of bounds: " + merchandiseIndex );
        }
        String merchandiseName = (String) MERCHANDISE_DATA[merchandiseIndex][1];
        Integer[] inventoryInFulfillmentCenters = MERCHANDISE_INVENTORY.get( merchandiseName );
        Integer foundInventory = inventoryInFulfillmentCenters[fulfillmentCenterIndex];
        return foundInventory == null ? 0 : foundInventory;
    }


    @Override
    public int findFulfillmentCenterIndex( UUID fulfillmentCenterId ) {
        for ( int i = 0; i < FULFILLMENT_CENTER_NUMOF; i++ ) {
            if ( FULFILLMENT_CENTER_ID[i].equals( fulfillmentCenterId ) ) {
                return i;
            }
        }
        throw new IllegalArgumentException( "No test fulfillment center with UUID id " + fulfillmentCenterId );
    }


    @Override
    public int findMerchandiseIndex( UUID merchandiseId ) {
        for ( int iMerchandiseData = 0; iMerchandiseData < FULFILLMENT_CENTER_NUMOF; iMerchandiseData++ ) {
            Object[] merchandiseData = MERCHANDISE_DATA[iMerchandiseData];
            if ( merchandiseData[0].equals( merchandiseId ) ) {
                return iMerchandiseData;
            }
        }
        throw new IllegalArgumentException( "No test merchandise with UUID id " + merchandiseId );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MerchandiseTestHelper.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;

public interface MerchandiseTestHelper {
    /**
     * Adds all test merchandises to the database.
     * If you use the debugger and want to identify _which_ test merchandise you currently look at:
     * The indices are coded into the first number in the name string of the merchandise, like e.g.
     * "1-EFG-56" (index 1) or "12-VWX-90 FastWupps" (index 12).
     */
    void addAllMerchandises();


    /**
     * @return the number of test merchandises in the database
     */
    int numberOfMerchandises();


    /**
     * @param index
     * @return the id of the test merchandise at the given index
     */
    UUID getMerchandiseId( int index );


    /**
     * @param merchandiseId - the id of the merchandise in the test data
     * @return the index of the test merchandise with that id
     */
    int findMerchandiseIndex( UUID merchandiseId );


    /**
     * @param index
     * @return the buying price of test merchandise at the given index
     */
    MoneyType getBuyingPrice( int index );


    /**
     * @param index
     * @return the sales price of test merchandise at the given index
     */
    MoneyType getSalesPrice( int index );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\MockCustomer.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import lombok.Setter;
import thkoeln.archilab.ecommerce.usecases.CustomerType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.*;


import java.util.Objects;

@Setter
public class MockCustomer implements CustomerType {
    private String name;
    private MailAddressType mailAddressType;
    private PhysicalAddressType physicalAddressType;


    public MockCustomer( String name, MailAddressType mailAddressType, PhysicalAddressType physicalAddressType) {
        this.name = name;
        this.mailAddressType = mailAddressType;
        this.physicalAddressType = physicalAddressType;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public MailAddressType getMailAddress() {
        return mailAddressType;
    }

    @Override
    public PhysicalAddressType getPhysicalAddress() {
        return physicalAddressType;
    }

    @Override
    public boolean equals( Object o ) {
        if ( this == o ) return true;
        if ( !( o instanceof MockCustomer ) ) return false;
        MockCustomer that = (MockCustomer) o;
        return Objects.equals( getName(), that.getName() ) &&
                Objects.equals( mailAddressType, that.mailAddressType ) &&
                Objects.equals( physicalAddressType, that.physicalAddressType );
    }

    @Override
    public int hashCode() {
        return Objects.hash( getName(), mailAddressType, physicalAddressType );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\Purgatory.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.usecases.*;

/**
 * Removes everything :-)
 */
@Service
public class Purgatory {
    @Autowired
    private CustomerRegistrationUseCases customerRegistrationUseCases;
    @Autowired
    private ShoppingCartUseCases shoppingCartUseCases;
    @Autowired
    private PurchaseUseCases purchaseUseCases;
    @Autowired
    private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;

    public void deleteEverything() {
        purchaseUseCases.deleteAllPurchases();
        shoppingCartUseCases.emptyAllShoppingCarts();
        fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
        customerRegistrationUseCases.deleteAllCustomers();
        merchandiseCatalogUseCases.deleteMerchandiseCatalog();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\masterdata\StartupListener.java ---
package thkoeln.archilab.ecommerce.usecases.masterdata;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;

@Component
@Slf4j
@Profile("!test")
@SuppressWarnings("PMD")
public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
    private Purgatory purgatory;
    private CustomerTestHelper customerTestHelper;
    private MerchandiseTestHelper merchandiseTestHelper;
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;


    @Autowired
    public StartupListener( Purgatory purgatory,
                            CustomerTestHelper customerTestHelper,
                            MerchandiseTestHelper merchandiseTestHelper,
                            FulfillmentCenterTestHelper fulfillmentCenterTestHelper ) {
        this.purgatory = purgatory;
        this.customerTestHelper = customerTestHelper;
        this.merchandiseTestHelper = merchandiseTestHelper;
        this.fulfillmentCenterTestHelper = fulfillmentCenterTestHelper;
    }

    @Override
    public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
        log.info( "StartupListener initializing master data ..." );
        purgatory.deleteEverything();
        customerTestHelper.registerAllCustomers();
        merchandiseTestHelper.addAllMerchandises();
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\MerchandiseCatalogUseCases.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;


/**
 * This interface contains methods needed in the context of use cases concerning the merchandise catalog.
 * The interface is probably incomplete, and will grow over time ...
 */

public interface MerchandiseCatalogUseCases {
    /**
     * Adds a new merchandise to the shop catalog
     * @param name
     * @param descriptFor
     * @param size
     * @param buyingPrice
     * @param salesPrice
     * @return the id of the new merchandise
     * @throws ShopException if ...
     *      - the merchandise id already exists,
     *      - name or description are null or empty,
     *      - the size is <= 0 (but can be null!),
     *      - the buying price is null or <= 0,
     *      - the buyingPrice is null,
     *      - the sales price is null,
     *      - the sales price is lower than the buyingPrice
     */
    public UUID addMerchandiseToCatalog( String name, String descriptFor, Float size,
                                           MoneyType buyingPrice, MoneyType salesPrice );


    /**
     * Removes a merchandise from the shop catalog
     * @param merchandiseId
     * @throws ShopException if
     *      - merchandiseId is null
     *      - the merchandise id does not exist
     *      - the merchandise is still in inventory
     *      - the merchandise is still in a shopping cart, or referenced by a completed purchase
     */
    public void removeMerchandiseFromCatalog( UUID merchandiseId );


    /**
     * Get the sales price of a given merchandise
     * @param merchandiseId
     * @return the sales price
     * @throws ShopException if ...
     *      - merchandiseId is null,
     *      - the merchandise with that id does not exist
     */
    public MoneyType getSalesPrice( UUID merchandiseId );


    /**
     * Clears the merchandise catalog, i.e. removes all merchandises from the catalog, including all the inventory,
     * all the reservations and all the purchases.
     */
    public void deleteMerchandiseCatalog();

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\PurchaseUseCases.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */
package thkoeln.archilab.ecommerce.usecases;


import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.Map;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of the purchase history of a customer.
 */
public interface PurchaseUseCases {

    /**
     * Returns a map showing which merchandises have been purchased by a customer and how many of each merchandise
     *
     * @param customerMailAddress
     * @return the purchase history of the customer (map is empty if the customer has not purchased anything yet)
     * @throws ShopException if
     *      - customerMailAddress is null
     *      - the customer with the given mail address does not exist
     */
    public Map<UUID, Integer> getPurchaseHistory( MailAddressType customerMailAddress );



    /**
     * @return the number of merchandises in a given purchase. If the merchandise is not a part of the purchase, the method
     *         returns 0. No exception is thrown.
     * @param purchaseId - the id of the purchase to be checked
     * @param merchandiseId - the id of the merchandise for which we want to know the quantity
     * @throws ShopException if
     *     - purchaseId is null, or doesn't exist in the system
     *     - merchandiseId is null, or doesn't exist in the system
     */
    public Integer getPurchaseQuantiOfMerchandise( UUID purchaseId, UUID merchandiseId );


    /**
     * @return the id of the fulfillment center that is responsible for the given purchase
     * @param purchaseId - the id of the purchase to be checked
     * @throws ShopException if
     *      - purchaseId is null, or doesn't exist in the system
     */
    public UUID getFulfillmentCenterIdForPurchase( UUID purchaseId );


    /**
     * Deletes all purchases in the system
     */
    public void deleteAllPurchases();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingCartUseCases.java ---
/*
 * Copyright ArchiLab 2025. All rights reserved.
 */

package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.Map;
import java.util.Set;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of use cases handling the shopping cart.
 * The interface is probably incomplete, and will grow over time ...
 */
public interface ShoppingCartUseCases {
    /**
     * Adds a merchandise to the cart of a customer
     *
     * @param customerMailAddress
     * @param merchandiseId
     * @param quantiOf
     * @throws ShopException if ...
     *          - customerMailAddress is null,
     *          - the customer with the given mail address does not exist,
     *          - merchandiseId is null,
     *          - the merchandise with merchandiseId does not exist
     *          - the Quantity is negative,
     */
    public void addMerchandiseToShoppingCart( MailAddressType customerMailAddress,
                                                 UUID merchandiseId, int quantiOf );


    /**
     * Removes a merchandise from the cart of a customer
     *
     * @param customerMailAddress
     * @param merchandiseId
     * @param quantiOf
     * @throws ShopException if ...
     *          - customerMailAddress is null,
     *          - the customer with the given mail address does not exist,
     *          - merchandiseId is null,
     *          - the merchandise with merchandiseId does not exist
     *          - the Quantity is negative
     *          - the merchandise is not in the shopping cart in the requested Quantity
     */
    public void removeMerchandiseFromShoppingCart( MailAddressType customerMailAddress,
                                                      UUID merchandiseId, int quantiOf );


    /**
     * Returns a map showing which merchandises are in the cart of a customer and how many of each merchandise
     *
     * @param customerMailAddress
     * @return the cart of the customer (map is empty if the cart is empty)
     * @throws ShopException if
     *          - customerMailAddress is null,
     *          - the customer with the given mail address does not exist
     */
    public Map<UUID, Integer> getShoppingCartAsMap( MailAddressType customerMailAddress );


    /**
     * Returns the current value of all merchandises in the cart of a customer
     *
     * @param customerMailAddress
     * @return the cart of the customer
     * @throws ShopException if
     *          - customerMailAddress is null,
     *          - the customer with the given mail address does not exist
     */
    public MoneyType getShoppingCartAsMoneyValue( MailAddressType customerMailAddress );




    /**
     * Checks out the cart of a customer
     *
     * @param customerMailAddress
     * @return A set of ids belonging to purchases that were created during the checkout. If the shopping cart can
     *         only be served from more than one fulfillment center, each shipment from a fulfillment center gets a
     *         dedicated purchase. I.e. if there is just one shipment, then the set will contain just one purchase id.
     *         If there are multiple shipments, the set will contain multiple purchase ids.
     * @throws ShopException if
     *      - customerMailAddress is null or empty
     *      - the customer with the given mail address does not exist, or if the cart is empty
     * @throws
     *      - ShopException if customerMailAddress is null
     *      - InsufficientInventoryException if there is not enough inventory level for to serve the purchase
     *        for all merchandises in the shopping cart
     */
    public Set<UUID> checkout( MailAddressType customerMailAddress );


    /**
     * Empties all shopping carts in the system
     */
    public void emptyAllShoppingCarts();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\RESTTestHelperConfiguration.java ---
package thkoeln.archilab.ecommerce.helpers.impl;

import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.test.web.servlet.MockMvc;
import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;


@TestConfiguration
public class RESTTestHelperConfiguration {

    @Bean
    public ShoppingCartRESTHelper shoppingCartRESTHelper(
            MockMvc mockMvc, MerchandiseCatalogUseCases merchandiseCatalogUseCases ) {
        return new ShoppingCartRESTHelperImpl( mockMvc, merchandiseCatalogUseCases );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\helpers\impl\ShoppingCartRESTHelperImpl.java ---
package thkoeln.archilab.ecommerce.helpers.impl;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.Map;
import java.util.UUID;

import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@Slf4j
public class ShoppingCartRESTHelperImpl implements ShoppingCartRESTHelper {
    private MockMvc mockMvc;
    private MerchandiseCatalogUseCases merchandiseCatalogUseCases;

    private static final ResultMatcher CREATED = status().isCreated();
    private static final ResultMatcher OK = status().isOk();

    public ShoppingCartRESTHelperImpl( MockMvc mockMvc, MerchandiseCatalogUseCases merchandiseCatalogUseCases ) {
        this.mockMvc = mockMvc;
        this.merchandiseCatalogUseCases = merchandiseCatalogUseCases;
    }


    @Override
    public UUID getQueryShoppingCart( MailAddressType mailAddress, Map<UUID, Integer> quantityMap )
            throws Exception {
        // first query the customers API to get the proper customerId
        UUID customerId;
        String customerUri = "/customers?mailAddress=" + mailAddress.toString();
        MvcResult customerGetResult = mockMvc.perform( get( customerUri ) )
                .andExpect( status().isOk() )
                .andReturn();
        ObjectMapper objectMapper = new ObjectMapper();
        IdDTO idDTO = objectMapper.readValue( customerGetResult.getResponse().getContentAsString(), IdDTO.class );
        customerId = idDTO.getId();

        // then query the shopping cart API and extract the shopping cart id
        String shoppingCartUri = "/shoppingCarts?customerId=" + customerId.toString();
        ResultActions resultActions = mockMvc.perform( get( shoppingCartUri ) )
                .andExpect( status().isOk() );
        idDTO = objectMapper.readValue( resultActions.andReturn().getResponse().getContentAsString(), IdDTO.class );
        UUID shoppingCartId = idDTO.getId();

        // additional checks, if desired
        if ( quantityMap != null ) checkQuantityMap( quantityMap, resultActions );
        return shoppingCartId;
    }


    private void checkQuantityMap( Map<UUID, Integer> quantityMap, ResultActions resultActions ) throws Exception {
        if ( quantityMap == null ) return;
        int numOfMerchandises = quantityMap.size();
        resultActions.andExpect( jsonPath( "$.parts.length()" ).value( numOfMerchandises ) );
        float totalSalesPriceAsFloat = 0f;
        for ( Map.Entry<UUID, Integer> entry : quantityMap.entrySet() ) {
            UUID merchandiseId = entry.getKey();
            Integer quantity = entry.getValue();
            resultActions.andExpect( jsonPath( "$.parts.[?(@.merchandiseId == '" + merchandiseId + "')].quantity" )
                    .value( quantity ) );
            MoneyType salesPrice = merchandiseCatalogUseCases.getSalesPrice( merchandiseId );
            totalSalesPriceAsFloat += salesPrice.getAmount() * quantity;
        }
        // last thing - check the total sales price
        String totalSalesPriceString = String.format( "%.2f €", totalSalesPriceAsFloat );
        resultActions
                .andExpect( jsonPath( "$.totalSalesPrice" ).value( totalSalesPriceString ) );
    }


    @Override
    public void addMerchandiseToShoppingCart( UUID shoppingCartId, UUID merchandiseId, Integer quantity )
            throws Exception {
        addMerchandiseToShoppingCart( shoppingCartId, merchandiseId, quantity, null );
    }


    @Override
    public void addMerchandiseToShoppingCart( UUID shoppingCartId, UUID merchandiseId, Integer quantity,
                                                  ResultMatcher expectedStatus ) throws Exception {
        ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
        ObjectMapper objectMapper = new ObjectMapper();
        QuantityDTO dto = new QuantityDTO( merchandiseId, quantity );
        String quantityJson = objectMapper.writeValueAsString( dto );
        mockMvc.perform( post( "/shoppingCarts/" + shoppingCartId + "/parts" )
                        .contentType( APPLICATION_JSON ).content( quantityJson ) )
                .andExpect( status );
    }



    @Override
    public void deleteMerchandiseFromShoppingCart( UUID shoppingCartId, UUID merchandiseId )
            throws Exception {
        deleteMerchandiseFromShoppingCart( shoppingCartId, merchandiseId, null );
    }



    @Override
    public void deleteMerchandiseFromShoppingCart( UUID shoppingCartId, UUID merchandiseId,
                                                      ResultMatcher expectedStatus ) throws Exception {
        ResultMatcher status = expectedStatus == null ? OK : expectedStatus;
        String uri = "/shoppingCarts/" + shoppingCartId + "/parts/" + merchandiseId;
        mockMvc.perform( delete( uri ) ).andExpect( status );
    }


    @Override
    public void checkout( UUID shoppingCartId, String expectedCustomerName,
                          ResultMatcher expectedStatus,
                          Map<UUID, Map<UUID, Integer>> expectedPurchases ) throws Exception {
        ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
        String uri = "/shoppingCarts/" + shoppingCartId + "/checkout";
        MvcResult result = mockMvc.perform( post( uri ) ).andExpect( status ).andReturn();
        ObjectMapper objectMapper = new ObjectMapper();

        // check the response content
        if ( expectedPurchases != null || expectedCustomerName != null ) {
            String responseContent = result.getResponse().getContentAsString();
            log.info( "ShoppingCartRESTHelperImpl - checkout: found response content " + responseContent );
            PurchaseDTO[] purchases = objectMapper.readValue( responseContent, PurchaseDTO[].class );
            checkExpectedCustomerName( expectedCustomerName, purchases );
            checkExpectedPurchases( expectedPurchases, purchases );
        }
    }


    private void checkExpectedCustomerName( String expectedCustomerName, PurchaseDTO[] purchases ) {
        if ( expectedCustomerName == null ) return;
        for ( PurchaseDTO purchase : purchases ) {
            if ( !purchase.getCustomerName().equals( expectedCustomerName ) ) {
                throw new AssertionError( "Expected customerName '" + expectedCustomerName +
                        "' but got '" + purchase.getCustomerName() + "'" );
            }
        }
    }


    private void checkExpectedPurchases( Map<UUID, Map<UUID, Integer>> expectedPurchases,
                                            PurchaseDTO[] purchases ) {
        if ( expectedPurchases == null ) return;
        for ( PurchaseDTO purchase : purchases ) {
            UUID fulfillmentCenterId = purchase.getFulfillmentCenterId();
            Map<UUID, Integer> expectedQuantities = expectedPurchases.get( fulfillmentCenterId );
            if ( expectedQuantities == null ) {
                throw new AssertionError( "No expected quantities for fulfillment center " + fulfillmentCenterId );
            }
            QuantityDTO[] parts = purchase.getParts();
            for ( QuantityDTO quantityDTO : parts ) {
                UUID merchandiseId = quantityDTO.getMerchandiseId();
                Integer expectedQuantity = expectedQuantities.get( merchandiseId );
                if ( expectedQuantity == null ) {
                    throw new AssertionError( "No expected quantity for merchandise " + merchandiseId +
                            " in fulfillment center " + fulfillmentCenterId );
                }
                if ( !quantityDTO.getQuantity().equals( expectedQuantity ) ) {
                    throw new AssertionError( "Expected quantity " + expectedQuantity + " for merchandise " +
                            merchandiseId + " in fulfillment center " + fulfillmentCenterId +
                            ", but got " + quantityDTO.getQuantity() );
                }
            }
        }
    }


    /**
     * A DTO containing just a quantity, used in testing.
     * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
     * Therefore, constructors and getters/setters are manually defined.
     */
    @NoArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class QuantityDTO {
        private UUID merchandiseId;
        private Integer quantity;

        public QuantityDTO( UUID merchandiseId, Integer quantity ) {
            this.merchandiseId = merchandiseId;
            this.quantity = quantity;
        }
        public UUID getMerchandiseId() {
            return merchandiseId;
        }
        public Integer getQuantity() {
            return quantity;
        }
        public void setMerchandiseId( UUID merchandiseId ) {
            this.merchandiseId = merchandiseId;
        }
        public void setQuantity( Integer quantity ) {
            this.quantity = quantity;
        }
    }


    /**
     * A DTO containing just the id of an entity, used in testing.
     */
    @AllArgsConstructor
    @NoArgsConstructor
    @Getter
    @Setter
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class IdDTO {
        private UUID id;
    }


    /**
     * A DTO containing the purchase data, used in testing.
     * In the origin repo, variables can have dollar signs in their names, which makes Lombok annotations fail.
     * Therefore, constructors and getters/setters are manually defined.
     */
    @NoArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    private static class PurchaseDTO {
        private UUID id;
        private String customerName;
        private UUID fulfillmentCenterId;
        private QuantityDTO[] parts;

        public UUID getId() {
            return id;
        }
        public String getCustomerName() {
            return customerName;
        }
        public UUID getFulfillmentCenterId() {
            return fulfillmentCenterId;
        }
        public QuantityDTO[] getParts() {
            return parts;
        }
        public void setId( UUID id ) {
            this.id = id;
        }
        public void setCustomerName( String customerName ) {
            this.customerName = customerName;
        }
        public void setFulfillmentCenterId( UUID fulfillmentCenterId ) {
            this.fulfillmentCenterId = fulfillmentCenterId;
        }
        public void setParts( QuantityDTO[] parts ) {
            this.parts = parts;
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\helpers\ShoppingCartRESTHelper.java ---
package thkoeln.archilab.ecommerce.helpers;

import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.Map;
import java.util.UUID;

/**
 * A REST helper for shopping cart-related operations.
 * This interface defines methods to interact with a shopping cart via REST calls, such as querying, adding,
 * deleting, and checking out.
 */
public interface ShoppingCartRESTHelper {
    /**
     * Executes a REST GET query on a shopping cart and returns its id, with the customer's mail address as a
     * starting point. The resulting shopping cart is checked against the given expected quantity map.
     * @param mailAddress The mailAddress of the customer whose shopping cart is queried.
     * @param expectedQuantityMap A map of merchandises and their quantities in the shopping cart. (If null, then don't check.)
     * @return The id of the customer's shopping cart.
     * @throws Exception (whenever the REST call fails, or the shopping cart does not match the expected quantity map)
     */
    public UUID getQueryShoppingCart( MailAddressType mailAddress,
                                       Map<UUID, Integer> expectedQuantityMap ) throws Exception;


    /**
     * Adds a merchandise to a shopping cart via a REST call.
     * @param shoppingCartId Id of the shopping cart.
     * @param merchandiseId Id of the merchandise.
     * @param quantity Quantity of the merchandise.
     * @throws Exception (whenever the REST call fails)
     */
    public void addMerchandiseToShoppingCart( UUID shoppingCartId, UUID merchandiseId, Integer quantity )
            throws Exception;


    /**
     * Adds a merchandise to a shopping cart via a REST call.
     * @param shoppingCartId Id of the shopping cart.
     * @param merchandiseId Id of the merchandise.
     * @param quantity Quantity of the merchandise.
     * @param expectedStatus expected status of the operation (null = CREATED)
     * @throws Exception (whenever the REST call fails or the status does not match)
     */
    public void addMerchandiseToShoppingCart( UUID shoppingCartId, UUID merchandiseId, Integer quantity,
                                                  ResultMatcher expectedStatus ) throws Exception;


    /**
     * Deletes a merchandise from a shopping cart via a REST call.
     * @param shoppingCartId Id of the shopping cart.
     * @param merchandiseId Id of the merchandise.
     * @throws Exception (whenever the REST call fails)
     */
    public void deleteMerchandiseFromShoppingCart( UUID shoppingCartId, UUID merchandiseId )
            throws Exception;


    /**
     * Deletes a merchandise from a shopping cart via a REST call.
     * @param shoppingCartId Id of the shopping cart.
     * @param merchandiseId Id of the merchandise.
     * @param expectedStatus expected status of the operation (null = OK)
     * @throws Exception (whenever the REST call fails or the status does not match)
     */
    public void deleteMerchandiseFromShoppingCart( UUID shoppingCartId, UUID merchandiseId,
                                                      ResultMatcher expectedStatus ) throws Exception;


    /**
     * Checks out a shopping cart via REST call, and returns the id of the created purchase.
     * @param shoppingCartId
     * @param expectedCustomerName expected name of the customer who owns the shopping cart (null = don't check)
     * @param expectedStatus expected status of the operation (null = don't check)
     * @param expectedPurchases the expected purchases to be created as a result of the checkout. This is
     *                            a map of the following form:
     *                            <pre>
     *                               fulfillmentCenterId -> Map<merchandiseId,Integer>
     *                            </pre>
     *                            where the inner map contains the merchandises and their quantities
     * @return
     * @throws Exception
     */
    public void checkout( UUID shoppingCartId, String expectedCustomerName,
                          ResultMatcher expectedStatus, Map<UUID, Map<UUID, Integer>> expectedPurchases )
           throws Exception;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\customer\CustomerRegistrationTest.java ---
package thkoeln.archilab.ecommerce.tests.customer;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.CustomerType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;


@SpringBootTest
public class CustomerRegistrationTest {
    @Autowired
    private CustomerRegistrationUseCases customerRegistrationUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private CustomerTestHelper customerTestHelper;

    private MailAddressType nonExistingMailAddress;
    private PhysicalAddressType somePhysicalAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        nonExistingMailAddress = instantiateMailAddress( "this@nononono.de" );
        somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
                instantiateZipCode( "90001" ) );
    }

    @Test
    public void testAllCustomersRegistered() {
        // given
        customerTestHelper.registerAllCustomers();
        MailAddressType mailAddress3 =
                customerTestHelper.getCustomerMailAddress( 3 );
        String name3 = customerTestHelper.getCustomerName( 3 );
        PhysicalAddressType physicalAddress3 = customerTestHelper.getCustomerPhysicalAddress( 3 );

        // when
        CustomerType customer3 = customerRegistrationUseCases.getCustomerData(
                mailAddress3 );

        // then
        Assertions.assertEquals( name3, customer3.getName() );
        Assertions.assertEquals( mailAddress3, customer3.getMailAddress() );
        Assertions.assertEquals( physicalAddress3, customer3.getPhysicalAddress() );
    }


    @Test
    public void testRegisterCustomerWithDuplicateMailAddress() {
        // given
        customerTestHelper.registerAllCustomers();
        PhysicalAddressType physicalAddress5 = customerTestHelper.getCustomerPhysicalAddress( 5 );
        MailAddressType mailAddress5 =
                customerTestHelper.getCustomerMailAddress( 5 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.register( "Gandalf The Grey",
                        mailAddress5, physicalAddress5 ) );
    }


    @Test
    public void testRegisterCustomerWithDuplicateNameOrPhysicalAddress() {
        // given
        customerTestHelper.registerAllCustomers();
        MailAddressType newMailAddress =
                instantiateMailAddress( "some@this.de" );
        PhysicalAddressType physicalAddress2 = customerTestHelper.getCustomerPhysicalAddress( 2 );
        String name2 = customerTestHelper.getCustomerName( 2 );

        // when
        // then
        assertDoesNotThrow( () ->
                customerRegistrationUseCases.register( name2, newMailAddress, physicalAddress2 ) );
    }


    @Test
    public void testRegisterCustomerWithInvalidData() {
        // given
        MailAddressType mailAddress5 =
                customerTestHelper.getCustomerMailAddress( 5 );
        PhysicalAddressType physicalAddress5 = customerTestHelper.getCustomerPhysicalAddress( 5 );
        String name5 = customerTestHelper.getCustomerName( 5 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.register( null, mailAddress5, physicalAddress5 ) );
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.register("", mailAddress5, physicalAddress5 ) );
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.register( name5, null, physicalAddress5 ) );
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.register( name5, mailAddress5, null ) );
    }


    @Test
    public void testChangeAddressWithInvalidData() {
        // given
        customerTestHelper.registerAllCustomers();
        PhysicalAddressType physicalAddress7 = customerTestHelper.getCustomerPhysicalAddress( 7 );
        MailAddressType mailAddress7 =
                customerTestHelper.getCustomerMailAddress( 7 );

        // when
        // then
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.changeAddress( nonExistingMailAddress, physicalAddress7 ) );
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.changeAddress( null, physicalAddress7 ) );
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.changeAddress( mailAddress7, null ) );
    }


    @Test
    public void testGetDataForNonexistingMailAddress() {
        // given
        customerTestHelper.registerAllCustomers();

        // when
        // then
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.getCustomerData( nonExistingMailAddress ) );
    }


    @Test
    public void testDeleteCustomersNoMoreCustomers() {
        // given
        customerTestHelper.registerAllCustomers();
        MailAddressType mailAddress0 =
                customerTestHelper.getCustomerMailAddress( 0 );


        // when
        customerRegistrationUseCases.deleteAllCustomers();

        // then
        assertThrows( ShopException.class, () -> customerRegistrationUseCases.getCustomerData(
                mailAddress0 ) );
    }


    @Test
    public void testChangeAddressSuccessful() {
        // given
        customerTestHelper.registerAllCustomers();
        MailAddressType mailAddress6 =
                customerTestHelper.getCustomerMailAddress( 6 );

        // when
        customerRegistrationUseCases.changeAddress( mailAddress6, somePhysicalAddress );
        CustomerType newCustomer6 =
                customerRegistrationUseCases.getCustomerData( mailAddress6 );

        // then
        Assertions.assertEquals( mailAddress6, newCustomer6.getMailAddress() );
        Assertions.assertEquals( somePhysicalAddress, newCustomer6.getPhysicalAddress() );
    }


    @Test
    public void testChangeAddressForNonexistingMailAddress() {
        // given
        customerTestHelper.registerAllCustomers();

        // when
        // then
        assertThrows( ShopException.class, () ->
                customerRegistrationUseCases.changeAddress( nonExistingMailAddress, somePhysicalAddress ) );
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\customer\CustomerRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.customer;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.web.servlet.MockMvc;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.CustomerType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.*;

import java.util.UUID;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class CustomerRESTTest {
    @Autowired
    private CustomerRegistrationUseCases customerRegistrationUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private CustomerTestHelper customerTestHelper;
    @Autowired
    private MockMvc mockMvc;

    private UUID randomId;
    private MailAddressType nonExistingMailAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        customerTestHelper.registerAllCustomers();

        nonExistingMailAddress = FactoryMethodInvoker.instantiateMailAddress(
                "harry@sally.de" );
        randomId = UUID.randomUUID();
    }


    @Test
    public void testInvalidCustomerUris() throws Exception {
        // given
        String allCustomersUri = "/customers";
        String randomIdUri = "/customers/" +  randomId;
        String nonExistingMailAddressUri = "/customers?mailAddress=" + nonExistingMailAddress;
        String randomParamUri = "/customers?randomParam=randomValue";

        // when
        // then
        mockMvc.perform( get( allCustomersUri ) ).andExpect( status().isMethodNotAllowed() );
        mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( nonExistingMailAddressUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
    }


    @Test
    public void testRandomCustomerId() throws Exception {
        // given
        String invalidUri = "/customers/" +  randomId;

        // when
        // then
        mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testQueryCustomer() throws Exception {
        // given
        MailAddressType mailAddress4 =
                customerTestHelper.getCustomerMailAddress( 4 );
        String customerUri4 = "/customers?mailAddress=" + mailAddress4;

        // when
        CustomerType customer4 = customerRegistrationUseCases.getCustomerData( mailAddress4 );
        String name = customerTestHelper.getCustomerName( 4 );
        PhysicalAddressType physicalAddress4 = customerTestHelper.getCustomerPhysicalAddress( 4 );

        // then (check using JSONPath)
        mockMvc.perform( get( customerUri4 ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.name" ).value( name ) )
                // id is position 0 (cannot be tested with current API structure), name is position 1,
                // mail address is 2, physical address is 3)
                .andExpect( jsonPath( "$..mailAddressString" ).value( mailAddress4.toString() ) )
                .andExpect( jsonPath( "$..city" ).value( physicalAddress4.getCity() ) )
                .andExpect( jsonPath( "$..zipCodeString" ).value(
                        physicalAddress4.getZipCode().toString() ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicNoOutsideSolutionRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class BasicNoOutsideSolutionRulesTest {

    @ArchTest
    static final ArchRule noClassesOnTopLevel =
            classes().should().resideInAPackage( "..solution.*.." )
                    .allowEmptyShould( true );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicProperDependenciesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.library.Architectures.layeredArchitecture;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln")
@SuppressWarnings("PMD")
public class BasicProperDependenciesTest {

    @ArchTest
    static final ArchRule properDependencies =
            layeredArchitecture()
                    .consideringAllDependencies()
                    //.layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
                    .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
                    .layer( "Tests" ).definedBy( "thkoeln.archilab.ecommerce.tests.." )

                    //.whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers("SolutionClasses", "Tests" )
                    .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Tests" )
                    .allowEmptyShould( true );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicRequiredClassesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import org.junit.jupiter.api.Test;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.MetadataReaderFactory;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertTrue;

public class BasicRequiredClassesTest {
    private static final String[] REQUIRED_CLASSES = {
            "Customer",
            "CustomerRepository",
            "Merchandise",
            "MerchandiseRepository",
            "Purchase",
            "PurchaseRepository",
            "InventoryLevel",
            "ShoppingCart",
            "ShoppingCartRepository",
            "FulfillmentCenterRepository",
            "ShoppingCartPart",
            "PurchasePart",
            "FulfillmentCenter",
    };

    @Test
    public void testRequiredClassesDeclared() throws IOException {
        String basePackage = "thkoeln.archilab.ecommerce";
        String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";

        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );

        Set<String> foundClasses = new HashSet<>();

        Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
            try {
                MetadataReader reader = readerFactory.getMetadataReader( resource );
                foundClasses.add( reader.getClassMetadata().getClassName() );
            } catch (IOException e) {
                e.printStackTrace();
            }
        } );

        Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
            boolean found = foundClasses.stream().anyMatch(className ->
                    className.startsWith(basePackage) && className.endsWith("." + requiredClass)
            );
            assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
        });
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\BasicUseCaseImplementationPackageTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.ApplicationContext;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
public class BasicUseCaseImplementationPackageTest {

    @Autowired
    private ApplicationContext applicationContext;

    private static final Map<String, List<String>> USECASE_INTERFACES = new HashMap<String, List<String>>() {{
        put("CustomerRegistrationUseCases", Arrays.asList("customer"));
        put("FulfillmentCenterUseCases", Arrays.asList("fulfillmentcenter"));
        put("MerchandiseCatalogUseCases", Arrays.asList("merchandise"));
        put("ShoppingCartUseCases", Arrays.asList("shoppingcart"));
        put("PurchaseUseCases", Arrays.asList("purchase"));
    }};
    private static final String USECASE_PATH = "thkoeln.archilab.ecommerce.usecases";
    private static final String SOLUTION_PATH = "thkoeln.archilab.ecommerce.solution";

    @Test
    public void testRequiredClassesDeclared() {
        for ( Map.Entry<String, List<String>> entry : USECASE_INTERFACES.entrySet() ) {
            String interfaceName = USECASE_PATH + "." + entry.getKey();
            List<String> correctTopLevelPackages = entry.getValue();
            Class<?> useCaseInterfaceClass = null;
            try {
                useCaseInterfaceClass = Class.forName( interfaceName );
            } catch (ClassNotFoundException e) {
                fail( "Use case interface " + interfaceName + " not found.", e );
                continue;
            }
            String[] beans = applicationContext.getBeanNamesForType( useCaseInterfaceClass );
            assertEquals( 1, beans.length,
                    "There should be exactly 1 service implementation for the interface " +
                            entry.getKey() + ", but found " + beans.length );
            Object bean = applicationContext.getBean( beans[0] );
            boolean isValid = false;
            for ( String correctTopLevelPackage : correctTopLevelPackages ) {
                String expectedPath = SOLUTION_PATH + "." + correctTopLevelPackage;
                if ( bean.getClass().getPackage().getName().startsWith( expectedPath ) ) {
                    isValid = true;
                    break;
                }
            }
            assertTrue( isValid,
                    "Service " + bean.getClass().getSimpleName() + " should be located somewhere below "
                            + SOLUTION_PATH + " and any of " + correctTopLevelPackages );
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\DDDRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Service;

import jakarta.persistence.Entity;
import org.springframework.web.bind.annotation.RestController;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class DDDRulesTest {

    @ArchTest
    static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
            noClasses().that().resideInAPackage( "..domain.." )
                    .should().dependOnClassesThat().resideInAPackage( "..application.." )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule entitiesMustResideInADomainPackage =
            classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage( "..domain.." )
                    .as( "Entities must reside in a package '..domain..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule entitiesMustNotAccessRepositories =
            noClasses().that().areAnnotatedWith( Entity.class )
                    .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule repositoriesMustResideInADomainPackage =
            classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage( "..domain.." )
                    .as( "Repositories must reside in a package '..domain..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule repositoryNamesMustHaveProperSuffix =
            classes().that().areAssignableTo( CrudRepository.class )
                    .should().haveSimpleNameEndingWith( "Repository" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule servicesMustResideInAnApplicationPackage =
            classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage( "..application.." )
                    .as( "Application Services must reside in a package '..application..'" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule serviceNamesMustHaveProperSuffix =
            classes().that().areAnnotatedWith( Service.class )
                    .should().haveSimpleNameEndingWith( "Service" )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule controllersMustResideInAnApplicationPackage =
            classes().that().areAnnotatedWith( RestController.class ).should().resideInAPackage( "..application.." )
                    .as( "Application Services must reside in a package '..application..'" ).allowEmptyShould( false );

    @ArchTest
    static final ArchRule controllersNamesMustHaveProperSuffix =
            classes().that().areAnnotatedWith( RestController.class )
                    .should().haveSimpleNameEndingWith( "Controller" ).allowEmptyShould( false );

    @ArchTest
    static final ArchRule controllersMustNotAccessRepositories =
            noClasses().that().areAnnotatedWith( RestController.class )
                    .should().dependOnClassesThat().areAssignableTo( CrudRepository.class )
                    .allowEmptyShould( false );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\NoCycleTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.library.dependencies.SliceAssignment;
import com.tngtech.archunit.library.dependencies.SliceIdentifier;
import org.junit.jupiter.api.Test;

import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;

public class NoCycleTest {
    private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");

    private SliceAssignment inAllClasses() {
        return new SliceAssignment() {
            @Override
            public String getDescription() {
                return "every class in it's own slice";
            }

            @Override
            public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
                return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
            }
        };
    }

    @Test
    public void testNoCyclicDependenciesBetweenClasses() {
        slices().assignedFrom(inAllClasses())
                .namingSlices("$1[$2.$3]")
                .should().beFreeOfCycles()
                .check(importedClasses);
    }

    @Test
    public void testNoCyclicDependenciesBetweenPackages() {
        ArchRule rule = slices().matching("..solution.(*)..")
                .should().beFreeOfCycles().allowEmptyShould( true );
        rule.check(importedClasses);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OnlyReferenceViaIDTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.base.DescribedPredicate;
import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaField;
import com.tngtech.archunit.core.domain.JavaParameterizedType;
import com.tngtech.archunit.core.domain.JavaType;
import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchCondition;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.lang.ConditionEvents;
import com.tngtech.archunit.lang.SimpleConditionEvent;
import jakarta.persistence.*;
import lombok.extern.slf4j.Slf4j;
import thkoeln.archilab.ecommerce.GenericId;

import java.util.List;

import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.fields;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
@Slf4j
public class OnlyReferenceViaIDTest { //FULFILLMENT_CENTER
    private static final String SHOPPING_CART_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.shoppingcart.domain";
    private static final String CUSTOMER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.customer.domain";
    private static final String MERCHANDISE_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.merchandise.domain";
    private static final String PURCHASE_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.purchase.domain";
    private static final String FULFILLMENT_CENTER_DOMAIN_PACKAGE = "thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain";

    @ArchTest
    static final ArchRule idFieldsMustUseGenericId =
            fields()
                    .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
                    .and().areAnnotatedWith( Id.class )
                    .should().haveRawType( assignableTo( GenericId.class ) )
                    .because( "All entity IDs must be derived from thkoeln.archilab.ecommerce.GenericId" )
                    .allowEmptyShould( true );


    private static final DescribedPredicate<CanBeAnnotated> isToOneAnnotation =
            annotatedWith( ManyToOne.class )
                    .or( annotatedWith( OneToOne.class ) )
                    .or( annotatedWith( Embedded.class ) )
                    .as( "a field annotated with a 'xxxToOne' JPA relationship (@OneToOne, @ManyToOne, @Embedded)" );

    private static final DescribedPredicate<CanBeAnnotated> isToManyAnnotation =
            annotatedWith( OneToMany.class )
                    .or( annotatedWith( ManyToMany.class ) )
                    .or( annotatedWith( ElementCollection.class ) )
                    .as( "a field annotated with a 'xxxToMany' JPA relationship (@ManyToOne, @ManyToMany, @ElementCollection)" );


    private static DescribedPredicate<JavaClass> entityOrValueObjectFromSamePackageOrDomainPrimitive( String allowedPackage ) {
        String description = "an entity or value object from same aggregate, or a domain primitive";
        return new DescribedPredicate<>( description ) {
            @Override
            public boolean test( JavaClass type ) {
                // check if the class is an entity or value object, and resides in the allowed package
                if ( !type.isAnnotatedWith( Entity.class ) && !type.isAnnotatedWith( Embeddable.class ) ) {
                    return false;
                }
                // a GenericId is always allowed
                if ( type.isAssignableTo( GenericId.class ) ) {
                    return true;
                }
                // a domain primitive is also always allowed
                if ( type.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" ) ) {
                    return true;
                }
                return type.getPackageName().startsWith( allowedPackage );
            }
        };
    }


    @ArchTest
    static final ArchRule shoppingCartToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_CART_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_CART_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule customerToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( CUSTOMER_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( CUSTOMER_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule merchandiseToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( MERCHANDISE_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( MERCHANDISE_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule purchaseToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( PURCHASE_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( PURCHASE_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule fulfillmentCenterToOneReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( FULFILLMENT_CENTER_DOMAIN_PACKAGE )
                    .and( isToOneAnnotation )
                    .should().haveRawType( assignableTo( entityOrValueObjectFromSamePackageOrDomainPrimitive( FULFILLMENT_CENTER_DOMAIN_PACKAGE ) ) )
                    .allowEmptyShould( true );


    private static ArchCondition<JavaField> beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( final String allowedPackage ) {
        return new ArchCondition<JavaField>(
                "reference a List or Set of entities or value objects from same aggregate, or DPs" ) {
            @Override
            public void check( JavaField field, ConditionEvents events ) {
                JavaClass rawType = field.getRawType();
                String rawTypeName = rawType.getFullName();
                if ( !rawTypeName.equals( "java.util.List" ) && !rawTypeName.equals( "java.util.Set" ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " is not a List or Set (actual: " + rawTypeName + ")" ) );
                    return;
                }
                JavaType fieldType = field.getType();
                if ( !( fieldType instanceof JavaParameterizedType ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " is a raw List/Set without a type argument" ) );
                    return;
                }
                List<JavaType> typeArguments = ( (JavaParameterizedType) fieldType ).getActualTypeArguments();
                if ( typeArguments.isEmpty() ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " has no type arguments" ) );
                    return;
                }
                JavaType elementType = typeArguments.get( 0 );
                if ( !( elementType instanceof JavaClass ) ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " has an unknown element type" ) );
                    return;
                }
                JavaClass elementClass = (JavaClass) elementType;
                boolean hasAnnotation =
                        elementClass.isAnnotatedWith( Entity.class ) || elementClass.isAnnotatedWith( Embeddable.class );
                boolean inSamePackage = elementClass.getPackageName().startsWith( allowedPackage );
                boolean isGenericId = elementClass.isAssignableTo( GenericId.class );
                boolean isDomainPrimitive = elementClass.getPackageName().startsWith( "thkoeln.archilab.ecommerce.domainprimitives" );
                boolean ok = ( isGenericId || ( hasAnnotation && inSamePackage ) || isDomainPrimitive );
                if ( !ok ) {
                    events.add( SimpleConditionEvent.violated( field,
                            field.getFullName() + " refers to " + elementClass.getFullName()
                                    + " which is not a DP, or an entity/value object in " + allowedPackage ) );
                }
            }
        };
    }


    @ArchTest
    static final ArchRule shoppingCartToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( SHOPPING_CART_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( SHOPPING_CART_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule customerToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( CUSTOMER_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( CUSTOMER_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule merchandiseToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( MERCHANDISE_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( MERCHANDISE_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule purchaseToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( PURCHASE_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( PURCHASE_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

    @ArchTest
    static final ArchRule fulfillmentCenterToManyReferences =
            fields()
                    .that().areDeclaredInClassesThat().resideInAPackage( FULFILLMENT_CENTER_DOMAIN_PACKAGE )
                    .and( isToManyAnnotation )
                    .should( beCollectionOfEntityOrValueObjectFromSamePackageOrDomainPrimitive( FULFILLMENT_CENTER_DOMAIN_PACKAGE ) )
                    .allowEmptyShould( true );

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\OwnTestsTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

/**
 * OBSOLETE - just kept here since the patch utility cannot remote classes, just change them.
 */

public class OwnTestsTest {
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\dddtests\PackageStructureTest.java ---
package thkoeln.archilab.ecommerce.tests.dddtests;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

public class PackageStructureTest {

    private static final String[] REQUIRED_PACKAGES = {"customer", "shoppingcart", "merchandise", "purchase", "fulfillmentcenter"};
    private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
    private JavaClasses importedClasses;


    @BeforeEach
    public void setUp() {
        importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
    }

    @Test
    void testRequiredPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage;
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredDomainPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected domain sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredApplicationPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected application sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\DomainPrimitivesUsageRulesTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

@ArchTag("domainPrimitivesUsageRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class DomainPrimitivesUsageRulesTest {
    private static final String MAIL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.MailAddress";
    private static final String MONEY_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.Money";
    private static final String PHYSICAL_ADDRESS_CLASS = "thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress";

    @ArchTest
    static final ArchRule customerShouldReferenceMailAddress =
            classes()
                    .that().haveSimpleName( "Customer" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( MAIL_ADDRESS_CLASS )
                    .because( "Customer should use MailAddress instead of String" );

    @ArchTest
    static final ArchRule customerShouldReferencePhysicalAddress =
            classes()
                    .that().haveSimpleName( "Customer" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
                    .because( "Customer should use PhysicalAddress instead of whatever else" );

    @ArchTest
    static final ArchRule fulfillmentCenterShouldReferencePhysicalAddress =
            classes()
                    .that().haveSimpleName( "FulfillmentCenter" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( PHYSICAL_ADDRESS_CLASS )
                    .because( "Customer should use PhysicalAddress instead of whatever else" );

    @ArchTest
    static final ArchRule merchandiseShouldReferenceMoney =
            classes()
                    .that().haveSimpleName( "Merchandise" )
                    .should().dependOnClassesThat().haveFullyQualifiedName( MONEY_CLASS )
                    .because( "Merchandise should use Money instead of float or whatever else" );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\MailAddressTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMailAddress;

class MailAddressTest {

    @Test
    public void testToStringMailAddress() {
        // given
        String input = "test@example.com";

        // when
        MailAddressType instance = instantiateMailAddress( input );

        // then
        assertEquals( input, instance.toString() );
    }

    @Test
    public void testEqualityMailAddress() {
        // given
        // when
        MailAddressType instance1 = instantiateMailAddress( "test@example.com" );
        MailAddressType instance2 = instantiateMailAddress( "test@example.com" );
        MailAddressType instance3 = instantiateMailAddress( "different@example.com" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutabilityMailAddress() {
        // given
        // when
        MailAddressType instance = instantiateMailAddress( "test@example.com" );

        // then
        try {
            instance.getClass().getMethod( "setMailAddress", String.class );
            fail( "setMailAddress method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }



    @Test
    public void smokeTestForCopyConstructors() {
        // given
        MailAddressType mailAddress =
                instantiateMailAddress( "peter.schmidt@web.de" );

        // when
        MailAddressType mailAddressOtherIdentifyer =
                mailAddress.sameDomainDifferentIdentifyer( "p.e.t.e.r" );
        assertThrows( ShopException.class, () ->
                mailAddress.sameDomainDifferentIdentifyer( "p...eter" ) );
        MailAddressType mailAddressOtherDomain =
                mailAddress.sameIdentifyerDifferentDomain( "web.ch" );
        assertThrows( ShopException.class, () ->
                mailAddress.sameIdentifyerDifferentDomain( "web.edu" ) );

        // then
        assertEquals( "p.e.t.e.r@web.de", mailAddressOtherIdentifyer.toString() );
        assertEquals( "peter.schmidt@web.ch", mailAddressOtherDomain.toString() );
    }


    @Test
    public void testFactoryValidMailAddress() {
        // given
        // when
        // then
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "99Z@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "GGGhh@s77.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "a@4.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "Max.Hammer@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "Max.Gideon.Hammer@example.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.this.com" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.de" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.at" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.ch" ) );
        Assertions.assertDoesNotThrow( () -> instantiateMailAddress( "test@example.org" ) );
    }


    @Test
    public void testFactoryInvalidMailAddress() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateMailAddress( null ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "testexample.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "Max..Gideon.Hammer@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@examplecom" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example..com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test#example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateMailAddress( "test@example.42" ) );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\MoneyTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMoney;

class MoneyTest {

    @Test
    public void testGetAmountMoney() {
        // given
        Float inputAmount = 10.0f;

        // when
        MoneyType instance = instantiateMoney( inputAmount, "EUR" );

        // then
        assertEquals( inputAmount, instance.getAmount() );
    }

    @Test
    public void testGetCurrencyUnitMoney() {
        // given
        String inputCurrencyUnit = "EUR";

        // when
        MoneyType instance = instantiateMoney( 10.0f, inputCurrencyUnit );

        // then
        assertEquals( inputCurrencyUnit, instance.getCurrencyUnit() );
    }

    @Test
    public void testAddToMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );

        // when
        MoneyType result12 = instance1.add( instance2 );
        MoneyType result13 = instance1.add( instance3 );

        // then
        assertEquals( 30.0f, result12.getAmount() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
        assertEquals( 10.0f, result13.getAmount() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
    }

    @Test
    public void testInvalidAddToMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
    }

    @Test
    public void testSubtractFromMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 30.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
        MoneyType instance4 = instantiateMoney( 30.0f, "EUR" );

        // when
        MoneyType result12 = instance1.subtract( instance2 );
        MoneyType result13 = instance1.subtract( instance3 );
        MoneyType result14 = instance1.subtract( instance4 );

        // then
        assertEquals( 10.0f, result12.getAmount() );
        assertEquals( "EUR", result12.getCurrencyUnit() );
        assertEquals( 30.0f, result13.getAmount() );
        assertEquals( "EUR", result13.getCurrencyUnit() );
        assertEquals( 0.0f, result14.getAmount() );
        assertEquals( "EUR", result14.getCurrencyUnit() );
    }

    @Test
    public void testInvalidSubtractFromMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 5.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
        assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
    }

    @Test
    public void testMultiplyByMoney() {
        // given
        MoneyType instance = instantiateMoney( 10.0f, "EUR" );

        // when
        MoneyType result = instance.multiplyBy( 3 );

        // then
        assertEquals( 30.0f, result.getAmount() );
        assertEquals( "EUR", result.getCurrencyUnit() );
    }

    @Test
    public void testFactoryValidCurrencyUnitMoney() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiateMoney( 10.0f, "EUR" ) );
    }

    @Test
    public void testFactoryInvalidCurrencyUnitMoney() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateMoney( -10.0f, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, "USD" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( null, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, null ) );
    }

    @Test
    public void testLargerThanCurrencyUnitMoney() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance4 = instantiateMoney( 10.0f, "CHF" );

        // when
        // then
        assertTrue( instance2.largerThan( instance1 ) );
        assertFalse( instance1.largerThan( instance2 ) );
        assertFalse( instance1.largerThan( instance3 ) );
        assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
    }


    @Test
    public void testEqualityCurrencyUnitMoney() {
        // given
        // when
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 20.0f, "EUR" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutabilityCurrencyUnitMoney() {
        // given
        // when
        MoneyType instance = instantiateMoney( 10.0f, "EUR" );

        // then
        try {
            instance.getClass().getMethod( "setAmount", Float.class );
            fail( "setAmount method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }

        try {
            instance.getClass().getMethod( "setCurrencyUnit", String.class );
            fail( "setCurrencyUnit method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\PhysicalAddressTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;

class PhysicalAddressTest {

    @Test
    public void testGetterPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );

        // then
        assertEquals( street, instance.getStreet() );
        assertEquals( city, instance.getCity() );
        assertEquals( plz, instance.getZipCode() );
    }

    @Test
    public void testFactoryValidPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        // then
        assertDoesNotThrow( () -> instantiatePhysicalAddress( street, city, plz ) );
    }

    @Test
    public void testFactoryInvalidPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        // then
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( null, city, plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( "", city, plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, null, plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, "", plz ) );
        assertThrows( ShopException.class, () -> instantiatePhysicalAddress( street, city, null ) );
    }

    @Test
    public void testEqualityPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        PhysicalAddressType instance1 = instantiatePhysicalAddress( street, city, plz );
        PhysicalAddressType instance2 = instantiatePhysicalAddress( street, city, plz );
        PhysicalAddressType instance3 = instantiatePhysicalAddress( "Anderestr. 12", city, plz );
        PhysicalAddressType instance4 = instantiatePhysicalAddress( street, "AndereStadt", plz );
        PhysicalAddressType instance5 = instantiatePhysicalAddress( street, city, instantiateZipCode( "54321" ) );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
        assertNotEquals( instance1, instance4 );
        assertNotEquals( instance1, instance5 );
    }

    @Test
    public void testImmutabilityPhysicalAddress() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        ZipCodeType plz = instantiateZipCode( "12345" );

        // when
        PhysicalAddressType instance = instantiatePhysicalAddress( street, city, plz );

        // then
        try {
            instance.getClass().getMethod( "setStreet", String.class );
            fail( "setStreet method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setCity", String.class );
            fail( "setCity method should not exist" );

        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setZipCode", ZipCodeType.class );
            fail( "setZipCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\domainprimitives\ZipCodeTest.java ---
package thkoeln.archilab.ecommerce.tests.domainprimitives;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;

class ZipCodeTest {

    private String input1, input4;
    private ZipCodeType _12345, _12345b, _23455, _01234, _01235, _01238, _01263, _01213, _01823, _01312, 
            _04233, _02544, _99123, _56323, _79332;


    @BeforeEach
    public void setUp() {
        input1 = "12345";
        input4 = "49188";
        _12345 = FactoryMethodInvoker.instantiateZipCode( "12345" );
        _12345b = FactoryMethodInvoker.instantiateZipCode( "12345" );
        _23455 = FactoryMethodInvoker.instantiateZipCode( "23455" );
        _01234 = FactoryMethodInvoker.instantiateZipCode( "01234" );
        _01235 = FactoryMethodInvoker.instantiateZipCode( "01235" );
        _01238 = FactoryMethodInvoker.instantiateZipCode( "01238" );
        _01263 = FactoryMethodInvoker.instantiateZipCode( "01263" );
        _01213 = FactoryMethodInvoker.instantiateZipCode( "01213" );
        _01823 = FactoryMethodInvoker.instantiateZipCode( "01823" );
        _01312 = FactoryMethodInvoker.instantiateZipCode( "01312" );
        _04233 = FactoryMethodInvoker.instantiateZipCode( "04233" );
        _02544 = FactoryMethodInvoker.instantiateZipCode( "02544" );
        _99123 = FactoryMethodInvoker.instantiateZipCode( "99123" );
        _56323 = FactoryMethodInvoker.instantiateZipCode( "56323" );
        _79332 = FactoryMethodInvoker.instantiateZipCode( "79332" );

    }


    @Test
    public void testToStringZipCode() {
        // given
        // when
        ZipCodeType instance = instantiateZipCode( input1 );

        // then
        assertEquals( input1, instance.toString() );
    }

    @Test
    public void testFactoryValidZipCode() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiateZipCode( input1 ) );
    }

    @Test
    public void testFactoryInvalidZipCode() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateZipCode( "123456" ) );
        assertThrows( ShopException.class, () -> instantiateZipCode( "1234" ) );
        assertThrows( ShopException.class, () -> instantiateZipCode( "20000" ) );
        assertThrows( ShopException.class, () -> instantiateZipCode( null ) );
    }

    @Test
    public void testEqualityZipCode() {
        // given
        // when
        ZipCodeType instance1a = instantiateZipCode( input1 );
        ZipCodeType instance1b = instantiateZipCode( input1 );
        ZipCodeType instance4 = instantiateZipCode( input4 );

        // then
        assertEquals( instance1a, instance1b );
        assertNotEquals( instance1a, instance4 );
    }

    @Test
    public void testImmutabilityZipCode() {
        // given
        // when
        ZipCodeType instance = instantiateZipCode( input1 );

        // then
        try {
            instance.getClass().getMethod( "setzipCode", String.class );
            fail( "setzipCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }


    @Test
    public void smokeTestForDifference() {
        // given
        ZipCodeType instance1a = instantiateZipCode( input1 );
        ZipCodeType instance1b = instantiateZipCode( input1 );
        ZipCodeType instance12479 = instantiateZipCode( "12479" );
        ZipCodeType instance21456 = instantiateZipCode( "21456" );

        // when
        int differenceAB = instance1a.difference( instance1b );
        int difference12 = instance1a.difference( instance12479 );
        int difference23 = instance12479.difference( instance21456 );

        // then
        assertEquals( 0, differenceAB );
        assertTrue( difference12 > 0 );
        assertTrue( difference23 > difference12 );
    }


    @Test
    public void testZipCodeFirstDigit() {
        // given
        ZipCodeType instance1 = instantiateZipCode( input1 );
        ZipCodeType instance4 = instantiateZipCode( input4 );

        // when
        // then
        assertEquals( 1, instance1.getFirstDigitZipCode() );
        assertEquals( 4, instance4.getFirstDigitZipCode() );
    }



    @Test
    public void testInvalidParameters() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () ->
                _12345.difference( null ) );
    }


    @Test
    public void testSameZipCode() {
        // given
        // when
        int diff = _12345.difference( _12345b );

        // then
        assertEquals( 0, diff );
    }


    /**
     *      - The difference is > 0 if both zip codes differ in the last digit, like 5673x
     *        and 5673y (with x != y). However, the exact numbers for x and y don't matter.
     *        So, 56733 and 56734 have the same difference as 56733 and 56739.
     *      - The difference grows if more digits (counted from the right side) differ.
     *        So, 5abcd and 5rstu have a larger difference than 53bcd and 53stu (if abcd
     *        and rstu are not the same). Again, the precise numbers don't matter. Therefore,
     *        53876 and 54876 have the same difference as 53876 and 57261.
     */
    @Test
    public void testZipCodeDifferenceInAllButFirstDigit() {
        // given
        // when
        int diff5a = _01234.difference( _01235 );
        int diff5b = _01234.difference( _01238 );
        int diff4a = _01234.difference( _01263 );
        int diff4b = _01234.difference( _01213 );
        int diff3a = _01234.difference( _01823 );
        int diff3b = _01234.difference( _01312 );
        int diff2a = _01234.difference( _04233 );
        int diff2b = _01234.difference( _02544 );

        // then
        assertEquals( diff5a, diff5b, "difference 01234-01235 must be the same as difference 01234-01238" );
        assertEquals( diff4a, diff4b, "difference 01234-01263 must be the same as difference 01234-01213" );
        assertEquals( diff3a, diff3b, "difference 01234-01823 must be the same as difference 01234-01312" );
        assertEquals( diff2a, diff2b, "difference 01234-04233 must be the same as difference 01234-02544" );

        assertTrue( diff5a < diff4a,
                "difference 01234-01235 must be smaller than difference 01234-01263" );
        assertTrue( diff4a < diff3a,
                "difference 01234-01263 must be smaller than difference 01234-01823" );
        assertTrue( diff3a < diff2a,
                "difference 01234-01823 must be smaller than difference 01234-04233" );
    }


    /**
     *      - However, the difference between 5abcd and 6rstu must be smaller than the one
     *        between 5abcd and 7rstu, and this difference in turn must be smaller than the
     *        one between 5abcd and 9rstu.
     *      - This last condition reflects the fact the first digits of a zip code marks a region
     *        that is (usually) next to the region for an adjacent number. I.e. the "4" region
     *        is next to the "5" number. Same applies to "0" and "9", they are also next to each
     *        other.
     */
    @Test
    public void testZipCodedifferenceInFirstDigit() {
        // given
        // when
        int diff1_1 = _01234.difference( _99123 );
        int diff1_2 = _01234.difference( _23455 );
        int diff1_5 = _01234.difference( _56323 );
        int diff1_3 = _01234.difference( _79332 );

        // then
        assertTrue( diff1_1 < diff1_2,
                "difference 01234-99123 must be smaller than difference 01234-23455"  );
        assertTrue( diff1_2 < diff1_3,
                "difference 01234-23455 must be smaller than difference 01234-79332" );
        assertTrue( diff1_3 < diff1_5,
                "difference 01234-79332 must be smaller than difference 01234-56323"  );
    }



}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\e1restcalls\E1RestCallTableTest.java ---
package thkoeln.archilab.ecommerce.tests.e1restcalls;

import org.junit.jupiter.api.Test;
import thkoeln.st.springtestlib.specification.table.GenericTableSpecificationTests;


public class E1RestCallTableTest {

    private GenericTableSpecificationTests genericTableSpecificationTests = null;


    public E1RestCallTableTest() {
        this.genericTableSpecificationTests = new GenericTableSpecificationTests();
    }

    @Test
    public void restTest() throws Exception {
        genericTableSpecificationTests.testTableSpecification("E1" );
    }
}



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\fulfillmentcenter\FulfillmentCenterManagementTest.java ---
package thkoeln.archilab.ecommerce.tests.fulfillmentcenter;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateZipCode;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiatePhysicalAddress;


/**
 * This test checks the management and lifecycle of fulfillment centers.
 */
@SpringBootTest
public class FulfillmentCenterManagementTest {
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private MerchandiseTestHelper merchandiseTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;

    private PhysicalAddressType somePhysicalAddress;
    private UUID nonExistingId1;
    private UUID nonExistingId2;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        merchandiseTestHelper.addAllMerchandises();

        somePhysicalAddress = instantiatePhysicalAddress( "Some Street", "Some City",
                instantiateZipCode( "90001" ) );
        nonExistingId1 = UUID.randomUUID();
        nonExistingId2 = UUID.randomUUID();
    }


    @Test
    public void testAddInvalidFulfillmentCenter() {
        // given
        String name = "Lager1";

        // when
        // then
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
                        null, somePhysicalAddress ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
                        "", somePhysicalAddress ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addNewFulfillmentCenter(
                        name, null ) );
    }


    @Test
    public void testDeleteAllFulfillmentCentersWhenEmpty() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
        UUID merchandiseId9 = merchandiseTestHelper.getMerchandiseId( 9 );
        UUID fulfillmentCenterId1 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 1 );
        UUID fulfillmentCenterId2 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 2 );

        // when
        int numOf1 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId1, merchandiseId9 );
        int numOf2 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId2, merchandiseId9 );

        // then
        assertEquals( 0, numOf1 );
        assertEquals( 0, numOf2 );
        fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
        // ... ids must be invalid now
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId1, merchandiseId9 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId2, merchandiseId9 ) );
    }


    @Test
    public void testDeleteAllFulfillmentCentersWhenFull() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID merchandiseId7 = merchandiseTestHelper.getMerchandiseId( 7 );
        UUID fulfillmentCenterId1 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 1 );
        UUID fulfillmentCenterId2 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 2 );

        // when
        int numOf1 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId1, merchandiseId7 );
        int numOf2 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId2, merchandiseId7 );

        // then
        assertTrue( numOf1 == 3 );
        assertTrue( numOf2 == 3 );
        fulfillmentCenterUseCases.deleteAllFulfillmentCenters();
        // ... ids must be invalid now
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId1, merchandiseId7 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId2, merchandiseId7 ) );
    }



    @Test
    public void testAddToInventory() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 ); // random >30 in fulfillment center 0
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        int originalInventory5 =
                fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 5 );

        // when
        int inventory5before = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId5 );
        fulfillmentCenterUseCases.addToInventory( fulfillmentCenterId0, merchandiseId5, 23 );
        int inventory5after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId5 );
        fulfillmentCenterUseCases.addToInventory( fulfillmentCenterId0, merchandiseId5, 0 );
        int inventory5after2 = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId5 );

        // then
        assertEquals( originalInventory5, inventory5before );
        assertEquals( inventory5before + 23, inventory5after );
        assertEquals( inventory5after, inventory5after2 );
    }


    @Test
    public void testInvalidAddToInventory() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID merchandiseId2 = merchandiseTestHelper.getMerchandiseId( 2 );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );

        // when
        // then
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addToInventory( nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addToInventory(
                        fulfillmentCenterId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addToInventory(
                        nonExistingId1, merchandiseId2, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.addToInventory(
                        fulfillmentCenterId0, merchandiseId2, -1 ) );
    }


    @Test
    public void testRemoveFromInventory() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 ); // 0 in fulfillment center 0
        UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 ); // random >30 in fulfillment center 0
        UUID merchandiseId6 = merchandiseTestHelper.getMerchandiseId( 6 ); // random >30 in fulfillment center 0
        int inventory0before =
                fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 0 );
        int inventory5before =
                fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 5 );
        int inventory6before =
                fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 6 );

        // when
        fulfillmentCenterUseCases.removeFromInventory( fulfillmentCenterId0, merchandiseId5, 1 );
        int inventory5after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId5 );
        fulfillmentCenterUseCases.removeFromInventory( fulfillmentCenterId0, merchandiseId0, 0 );
        int inventory0after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId0 );
        fulfillmentCenterUseCases.removeFromInventory(
                fulfillmentCenterId0, merchandiseId6, inventory6before );
        int inventory6after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId6 );

        // then
        assertEquals( inventory5before - 1, inventory5after );
        assertEquals( inventory0before, inventory0after );
        assertEquals( 0, inventory6after );
    }


    @Test
    public void testInvalidRemoveFromInventory() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 ); // 0 in fulfillment center 0
        UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 ); // random >30 in fulfillment center 0
        int inventory5before =
                fulfillmentCenterTestHelper.getFulfillmentCenterInventory( 0, 5 );

        // when
        // then
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromInventory( nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromInventory(
                        fulfillmentCenterId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromInventory(
                        nonExistingId1, merchandiseId5, 12 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromInventory(
                        fulfillmentCenterId0, merchandiseId5, -1 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromInventory(
                        fulfillmentCenterId0, merchandiseId5, inventory5before + 1 ) );
        assertThrows( ShopException.class,
                () -> fulfillmentCenterUseCases.removeFromInventory(
                        fulfillmentCenterId0, merchandiseId0, 1 ) ); // already 0 in fulfillment center 0
    }


    @Test
    public void testChangeInventory() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 ); // random >30 in fulfillment center 0

        // when
        fulfillmentCenterUseCases.changeInventoryTo( fulfillmentCenterId0, merchandiseId5, 111 );
        int inventory5after = fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId5 );

        // then
        assertEquals( 111, inventory5after );
    }


    @Test
    public void testInvalidChangeInventory() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID merchandiseId6 = merchandiseTestHelper.getMerchandiseId( 6 );

        // when
        // then
        assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeInventoryTo(
                nonExistingId1, nonExistingId2, 12 ) );
        assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeInventoryTo(
                nonExistingId1, merchandiseId6, 12 ) );
        assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeInventoryTo(
                fulfillmentCenterId0, nonExistingId2, 12 ) );
        assertThrows( ShopException.class, () -> fulfillmentCenterUseCases.changeInventoryTo(
                fulfillmentCenterId0, merchandiseId6, -1 ) );
    }


    @Test
    public void testEmptyFulfillmentCenter() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        UUID fulfillmentCenterId9 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 9 ); // empty fulfillment center

        // when
        int totalInventory = 0;
        for ( int iMerchandise = 0; iMerchandise < merchandiseTestHelper.numberOfMerchandises(); iMerchandise++ ) {
            UUID merchandiseId = merchandiseTestHelper.getMerchandiseId( iMerchandise );
            totalInventory += fulfillmentCenterUseCases.getAvailableInventory(
                    fulfillmentCenterId9, merchandiseId );
        }

        // then
        assertEquals( 0, totalInventory );
    }



}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\merchandise\MerchandiseCatalogTest.java ---
package thkoeln.archilab.ecommerce.tests.merchandise;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
import thkoeln.archilab.ecommerce.usecases.MerchandiseCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.CustomerRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.*;

import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;


@SpringBootTest
public class MerchandiseCatalogTest {
    @Autowired
    private CustomerRegistrationUseCases customerRegistrationUseCases;
    @Autowired
    private ShoppingCartUseCases shoppingCartUseCases;
    @Autowired
    private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private CustomerTestHelper customerTestHelper;
    @Autowired
    private MerchandiseTestHelper merchandiseTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        customerTestHelper.registerAllCustomers();
        merchandiseTestHelper.addAllMerchandises();
    }


    @Test
    public void testAddMerchandiseToCatalog() {
        // given
        UUID merchandiseId4 = merchandiseTestHelper.getMerchandiseId( 4 );
        MoneyType salesPrice4 = merchandiseTestHelper.getSalesPrice( 4 );

        // when
        MoneyType foundSalesPrice = merchandiseCatalogUseCases.getSalesPrice( merchandiseId4 );

        // then
        assertEquals( salesPrice4, foundSalesPrice );
    }


    @Test
    public void testAddMerchandiseWithInvalidData() {
        // given
        String name = "SomeStuff";
        String description = "Some more explanation on the stuff";
        Float size = 5.0f;
        MoneyType buyingPrice =
                FactoryMethodInvoker.instantiateMoney( 5.0f, "EUR" );
        MoneyType salesPrice =
                FactoryMethodInvoker.instantiateMoney( 10.0f, "EUR" );
        MoneyType tooLowSalesPrice =
                FactoryMethodInvoker.instantiateMoney( 4.0f, "EUR" );

        // when / then
        assertThrows( ShopException.class, () ->
                merchandiseCatalogUseCases.addMerchandiseToCatalog(
                        null, description, size, buyingPrice, salesPrice ) );
        assertThrows( ShopException.class, () ->
                merchandiseCatalogUseCases.addMerchandiseToCatalog(
                        "", description, size, buyingPrice, salesPrice ) );
        assertThrows( ShopException.class, () ->
                merchandiseCatalogUseCases.addMerchandiseToCatalog(
                        name, null, size, buyingPrice, salesPrice ) );
        assertThrows( ShopException.class, () ->
                merchandiseCatalogUseCases.addMerchandiseToCatalog(
                        name, "", size, buyingPrice, salesPrice ) );
        assertThrows( ShopException.class, () ->
                merchandiseCatalogUseCases.addMerchandiseToCatalog(
                        name, description, size, null, salesPrice ) );
        assertThrows( ShopException.class, () ->
                merchandiseCatalogUseCases.addMerchandiseToCatalog(
                        name, description, size, buyingPrice, null ) );
        assertThrows( ShopException.class, () ->
                merchandiseCatalogUseCases.addMerchandiseToCatalog(
                        name, description, size, buyingPrice, tooLowSalesPrice ) );
    }


    @Test
    public void testRemoveNonExistentMerchandise() {
        // given merchandise 2 is not in inventory anywhere - should be removable
        UUID nonExistentMerchandiseId = UUID.randomUUID();

        // when
        // then
        assertThrows( ShopException.class,
                () -> merchandiseCatalogUseCases.removeMerchandiseFromCatalog( nonExistentMerchandiseId ) );
    }


    @Test
    public void testRemoveMerchandiseWithNoInventory() {
        // given merchandise 0 is not in inventory anywhere - should be removable
        UUID merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 );
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );

        // when
        assertDoesNotThrow( () -> merchandiseCatalogUseCases.getSalesPrice( merchandiseId0 ) );
        merchandiseCatalogUseCases.removeMerchandiseFromCatalog( merchandiseId0 );

        // then
        assertThrows( ShopException.class, () ->
                merchandiseCatalogUseCases.getSalesPrice( merchandiseId0 ) );
    }


    @Test
    public void testRemoveMerchandiseThatIsInInventory() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID merchandiseId3 = merchandiseTestHelper.getMerchandiseId( 3 );
        UUID merchandiseId4 = merchandiseTestHelper.getMerchandiseId( 4 );
        fulfillmentCenterUseCases.addToInventory( fulfillmentCenterId0, merchandiseId3, 3 );

        // then merchandise 3 must not be removable, but merchandise 4 must be removable
        assertThrows( ShopException.class,
                () -> merchandiseCatalogUseCases.removeMerchandiseFromCatalog( merchandiseId3 ) );
        assertDoesNotThrow( () -> merchandiseCatalogUseCases.removeMerchandiseFromCatalog( merchandiseId4 ) );
    }


    @Test
    public void testRemoveMerchandiseThatIsInPurchase() {
        // given
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( false );
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        UUID merchandiseId4 = merchandiseTestHelper.getMerchandiseId( 4 );
        MailAddressType customerMailAddress4 =
                customerTestHelper.getCustomerMailAddress( 4 );
        fulfillmentCenterUseCases.addToInventory( fulfillmentCenterId0, merchandiseId4, 4 );

        // when customer 4 adds 4x merchandise 4 to his shopping cart and checks out ...
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress4, merchandiseId4, 4 );
        shoppingCartUseCases.checkout( customerMailAddress4 );

        // then merchandise 4 must not be removable
        assertThrows( ShopException.class,
                () -> merchandiseCatalogUseCases.removeMerchandiseFromCatalog( merchandiseId4 ) );
    }


    @Test
    public void testClearMerchandiseCatalog() {
        // given
        UUID merchandiseId4 = merchandiseTestHelper.getMerchandiseId( 4 );

        // when
        merchandiseCatalogUseCases.deleteMerchandiseCatalog();

        // then
        assertThrows( ShopException.class, () -> merchandiseCatalogUseCases.getSalesPrice( merchandiseId4 ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\DomainPrimitiveJSONSerializationTest.java ---
package thkoeln.archilab.ecommerce.tests.owntests;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.jayway.jsonpath.JsonPath;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.domainprimitives.PhysicalAddress;
import thkoeln.archilab.ecommerce.domainprimitives.ZipCode;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import static org.junit.jupiter.api.Assertions.assertEquals;


public class DomainPrimitiveJSONSerializationTest {

    @BeforeEach
    public void setUp() {
        // ... add own setup code here
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * MailAddress.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_MailAddress_Serialization() throws Exception {
        // given
        MailAddressType mailAddress = MailAddress.of("test@gmail.com");
        ObjectMapper mapper = new ObjectMapper();

        // when
        String json = mapper.writeValueAsString(mailAddress);

        // then (assert using JsonPath)
        String identifier = JsonPath.read( json, "$.identifier" );
        String domain = JsonPath.read( json, "$.domain" );
        assertEquals( "test", identifier);
        assertEquals( "gmail.com", domain );
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * ZipCode.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_ZipCode_Serialization() throws Exception {
        // given
        ZipCode zipCode = ZipCode.of("12345");
        ObjectMapper mapper = new ObjectMapper();

        // when
        String json = mapper.writeValueAsString(zipCode);

        // then
        String zipCodeString = JsonPath.read( json, "$.zipCodeString" );
        assertEquals( "12345", zipCodeString);
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * PhysicalAddress.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_PhysicalAddress_Serialization() throws Exception {
        // given
        ZipCode zipCode = ZipCode.of("12345");
        PhysicalAddress physicalAddress = PhysicalAddress.of("testStreet", "testCity", zipCode);
        ObjectMapper mapper = new ObjectMapper();

        // when
        String json = mapper.writeValueAsString(physicalAddress);

        // then
        String street = JsonPath.read( json, "$.street" );
        String city = JsonPath.read( json, "$.city" );
        String zipCodeString = JsonPath.read( json, "$.zipCode.zipCodeString" );

        assertEquals( "testStreet", street);
        assertEquals( "testCity", city);
        assertEquals( "12345", zipCodeString);
    }


    /**
     * Provide a test that checks the proper serialization and deserialization of the domain primitive
     * Money.
     * See https://www.archi-lab.io/infopages/coding/testing-json-serialization.html for a guide
     * on how to implement this test, and how to change property names.
     * @throws Exception
     */
    @Test
    public void test_Money_Serialization() throws Exception {
        // given
        Money money = Money.of(132.25f, "EUR");
        ObjectMapper mapper = new ObjectMapper();

        // when
        String json = mapper.writeValueAsString(money);

        // then
        Double amount = JsonPath.read( json, "$.amount" );
        String currency = JsonPath.read( json, "$.currency" );

        assertEquals( 132.25f, amount);
        assertEquals( "EUR", currency);
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\owntests\OwnShoppingCartRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.owntests;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
import thkoeln.archilab.ecommerce.domainprimitives.exceptions.MerchandiseNotFoundException;
import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.solution.merchandise.domain.MerchandiseId;
import thkoeln.archilab.ecommerce.solution.shoppingcart.application.ShoppingCartService;
import thkoeln.archilab.ecommerce.solution.shoppingcart.domain.ShoppingCart;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;


@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class OwnShoppingCartRESTTest {
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private CustomerTestHelper customerTestHelper;
    @Autowired
    private MerchandiseTestHelper merchandiseTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
    @Autowired
    private ShoppingCartService shoppingCartService;
    @Autowired
    private ShoppingCartRESTHelper shoppingCartRESTHelper;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        customerTestHelper.registerAllCustomers();
        merchandiseTestHelper.addAllMerchandises();
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );

        // ... add own setup code here

        // necessary for test restTestsShouldReferenceMailAddress() to go green,
        // because calling customerTestHelper.getCustomerMailAddress() is not recognised by the test
        MailAddress.of("test@test.com");
    }


    /**
     * Provide a test that implements a simple call to the REST endpoint (3):
     * <pre>
     *     GET /shoppingCarts?customerId=<customer id as uuid>
     * </pre>
     * - Use the {@link CustomerTestHelper} to obtain to obtain the mail address
     *   of some example customer.
     * - Use your shopping cart service to add entries to the shopping cart of that person.
     * - then use the `ShoppingCartRESTHelper` to create the GET call, and check the results.
     * - (or do it by directly calling your REST controller, if you prefer)
     * @throws Exception
     */
    @Test
    public void test_getQuery_ShoppingCart() throws Exception {
        // given
        MailAddress mailAddress = (MailAddress) customerTestHelper.getCustomerMailAddress(0);

        // when
        shoppingCartService.addMerchandiseToShoppingCart(
                mailAddress,
                new MerchandiseId( merchandiseTestHelper.getMerchandiseId(0)),
                7);

        shoppingCartService.addMerchandiseToShoppingCart(
                mailAddress,
                new MerchandiseId( merchandiseTestHelper.getMerchandiseId(1)),
                80);

        shoppingCartService.addMerchandiseToShoppingCart(
                mailAddress,
                new MerchandiseId( merchandiseTestHelper.getMerchandiseId(2)),
                53);

        // then
        shoppingCartRESTHelper.getQueryShoppingCart(
                mailAddress,
                shoppingCartService.getShoppingCartAsMap(mailAddress));
    }



    /**
     * Provide a test that implements the addition of one merchandise to the shopping cart via
     * REST endpoint (6):
     * <pre>
     *     POST /shoppingCarts/{shoppingCart-Id}/parts
     * </pre>
     * You can test now "the other way around" as in test_getQuery_ShoppingCart():
     * - Use `ShoppingCartRESTHelper` to add merchandises via REST, then use shopping cart service methods
     *   to check of the shopping cart contains the right stuff.
     * - (or do it by directly calling your REST controller, if you prefer)
     *
     * @throws Exception
     */
    @Test
    public void test_post_ShoppingCartParts() throws Exception {
        // given
        MailAddress mailAddress = (MailAddress) customerTestHelper.getCustomerMailAddress(0);

        shoppingCartService.addMerchandiseToShoppingCart(
                mailAddress,
                new MerchandiseId( merchandiseTestHelper.getMerchandiseId(0)),
                7);

        // when
        UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart(
                mailAddress,
                shoppingCartService.getShoppingCartAsMap(mailAddress));


        shoppingCartRESTHelper.addMerchandiseToShoppingCart(
                shoppingCartId,
                merchandiseTestHelper.getMerchandiseId(1),
                80
        );

        // then
        ShoppingCart shoppingCart = shoppingCartService.getShoppingCart(mailAddress);
        int quantity = shoppingCart.getQuantity(
                new MerchandiseId(merchandiseTestHelper.getMerchandiseId(1)));

        assertEquals(80, quantity);
    }



    /**
     * Provide a test that implements the deletion of one merchandise in the shopping cart via
     * REST endpoint (10):
     * <pre>
     *     DELETE /shoppingCarts/{shoppingCart-Id}/parts/{merchandise-Id}
     * </pre>
     * This should be just a slight variation of the test_post_ShoppingCartParts()
     * method, but instead of adding an merchandise to the shopping cart, you delete it.
     *
     * @throws Exception
     */
    @Test
    public void test_delete_ShoppingCartParts() throws Exception {
        // given /when
        MailAddress mailAddress = (MailAddress) customerTestHelper.getCustomerMailAddress(0);

        shoppingCartService.addMerchandiseToShoppingCart(
                mailAddress,
                new MerchandiseId( merchandiseTestHelper.getMerchandiseId(1)),
                7);

        UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart(
                mailAddress,
                shoppingCartService.getShoppingCartAsMap(mailAddress));


        // then
        shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart(
                shoppingCartId,
                merchandiseTestHelper.getMerchandiseId(1)
        );

        ShoppingCart shoppingCart = shoppingCartService.getShoppingCart(mailAddress);
        assertThrows(
                MerchandiseNotFoundException.class,
                () -> shoppingCart.getQuantity(
                    new MerchandiseId(merchandiseTestHelper.getMerchandiseId(1))));
    }



    /**
     * Provide a test that implements the checkout of a shopping cart that can be served
     * by just 1 fulfillment center, using the REST endpoint (11):
     * <pre>
     *     POST /shoppingCarts/{shoppingCart-Id}/checkout
     * </pre>
     * - Use your shopping cart service to add entries to the shopping cart of some example customer,
     * - then use the `ShoppingCartRESTHelper to post the checkout call, and to check the results.
     * - (or do it by directly calling your REST controller, if you prefer)
     *
     * @throws Exception
     */
    @Test
    public void test_checkout_1_fulfillmentCenter() throws Exception {
        // given
        MailAddress mailAddress = (MailAddress) customerTestHelper.getCustomerMailAddress(0);
        String customerName = customerTestHelper.getCustomerName(0);

        // when
        shoppingCartService.addMerchandiseToShoppingCart(
                mailAddress,
                new MerchandiseId(merchandiseTestHelper.getMerchandiseId(1)),
                10);

        shoppingCartService.addMerchandiseToShoppingCart(
                mailAddress,
                new MerchandiseId(merchandiseTestHelper.getMerchandiseId(2)),
                20);

        shoppingCartService.addMerchandiseToShoppingCart(
                mailAddress,
                new MerchandiseId(merchandiseTestHelper.getMerchandiseId(3)),
                30);

        Map<UUID, Integer> merchandiseMap = shoppingCartService.getShoppingCartAsMap(mailAddress);

        Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>();
        expectedPurchases.put(fulfillmentCenterTestHelper.getFulfillmentCenterId(0), merchandiseMap);

        ShoppingCart shoppingCart = shoppingCartService.getShoppingCart(mailAddress);

        // then
        shoppingCartRESTHelper.checkout(
                shoppingCart.getId().getId(),
                customerName,
                status().isCreated(),
                expectedPurchases
        );
    }



    /**
     * Provide a test that implements the checkout of a shopping cart that can only be served
     * by using 2 fulfillment centers, using the REST endpoint (11):
     * <pre>
     *     POST /shoppingCarts/{shoppingCart-Id}/checkout
     * </pre>
     * This should be just a slight variation of thetest_checkout_1_fulfillmentCenter() test.
     *
     * @throws Exception
     */
    @Test
    public void test_checkout_2_fulfillmentCenters() throws Exception {
        // given
        MailAddress mailAddress = (MailAddress) customerTestHelper.getCustomerMailAddress(0);
        String customerName = customerTestHelper.getCustomerName(0);

        // when
        MerchandiseId merchandiseId1 = new MerchandiseId(merchandiseTestHelper.getMerchandiseId(1));
        shoppingCartService.addMerchandiseToShoppingCart(
                mailAddress,
                merchandiseId1,
                10);
        Map<UUID, Integer> merchandiseMap1 = new HashMap<>();
        merchandiseMap1.put(merchandiseId1.getId(), 10);

        MerchandiseId merchandiseId12 = new MerchandiseId(merchandiseTestHelper.getMerchandiseId(12));
        shoppingCartService.addMerchandiseToShoppingCart(
                mailAddress,
                merchandiseId12,
                1);
        Map<UUID, Integer> merchandiseMap12 = new HashMap<>();
        merchandiseMap12.put(merchandiseId12.getId(), 1);

        Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>();

        expectedPurchases.put(fulfillmentCenterTestHelper.getFulfillmentCenterId(0), merchandiseMap1);
        expectedPurchases.put(fulfillmentCenterTestHelper.getFulfillmentCenterId(5), merchandiseMap12);

        ShoppingCart shoppingCart = shoppingCartService.getShoppingCart(mailAddress);

        // then
        shoppingCartRESTHelper.checkout(
                shoppingCart.getId().getId(),
                customerName,
                status().isCreated(),
                expectedPurchases
        );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\purchase\PurchaseTest.java ---
package thkoeln.archilab.ecommerce.tests.purchase;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;


@SpringBootTest
public class PurchaseTest {
    @Autowired
    private CustomerRegistrationUseCases customerRegistrationUseCases;
    @Autowired
    private ShoppingCartUseCases shoppingCartUseCases;
    @Autowired
    private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private PurchaseUseCases purchaseUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private CustomerTestHelper customerTestHelper;
    @Autowired
    private MerchandiseTestHelper merchandiseTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;

    private UUID nonExistingId1;
    private UUID nonExistingId2;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        customerTestHelper.registerAllCustomers();
        merchandiseTestHelper.addAllMerchandises();
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        nonExistingId1 = UUID.randomUUID();
        nonExistingId2 = UUID.randomUUID();
    }


    @Test
    public void testPurchaseHistory() {
        // given
        UUID merchandiseId1 = merchandiseTestHelper.getMerchandiseId( 1 );
        UUID merchandiseId2 = merchandiseTestHelper.getMerchandiseId( 2 );
        MailAddressType customerMailAddress7 =
                customerTestHelper.getCustomerMailAddress( 7 );
        Map<UUID, Integer> purchaseHistoryBefore = purchaseUseCases.getPurchaseHistory( customerMailAddress7 );

        // when
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress7, merchandiseId1, 3 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress7, merchandiseId2, 2 );
        shoppingCartUseCases.checkout( customerMailAddress7 );
        Map<UUID, Integer> purchaseHistory1 =
                purchaseUseCases.getPurchaseHistory( customerMailAddress7 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress7, merchandiseId1, 6 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress7, merchandiseId2, 2 );
        shoppingCartUseCases.checkout( customerMailAddress7 );
        Map<UUID, Integer> purchaseHistory2 =
                purchaseUseCases.getPurchaseHistory( customerMailAddress7 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress7, merchandiseId1, 1 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress7, merchandiseId2, 6 );
        shoppingCartUseCases.checkout( customerMailAddress7 );
        Map<UUID, Integer> purchaseHistory3 =
                purchaseUseCases.getPurchaseHistory( customerMailAddress7 );

        // then
        assertEquals( 0, purchaseHistoryBefore.size() );
        assertEquals( 2, purchaseHistory1.size() );
        assertEquals( 2, purchaseHistory2.size() );
        assertEquals( 2, purchaseHistory3.size() );
        assertEquals( 3, purchaseHistory1.get( merchandiseId1 ) );
        assertEquals( 2, purchaseHistory1.get( merchandiseId2 ) );
        assertEquals( 9, purchaseHistory2.get( merchandiseId1 ) );
        assertEquals( 4, purchaseHistory2.get( merchandiseId2 ) );
        assertEquals( 10, purchaseHistory3.get( merchandiseId1 ) );
        assertEquals( 10, purchaseHistory3.get( merchandiseId2 ) );
    }


    @Test
    public void testForEmptyPurchaseHistory() {
        // given
        MailAddressType customerMailAddress4 =
                customerTestHelper.getCustomerMailAddress( 4 );
        // when
        Map<UUID, Integer> purchaseHistory =
                purchaseUseCases.getPurchaseHistory( customerMailAddress4 );
        // then
        assertEquals( 0, purchaseHistory.size() );
    }


    @Test
    public void testInvalidParamsForGetPurchaseQuantiOfMerchandise() {
        // given
        UUID fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );

        // when / then
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantiOfMerchandise( null, null ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantiOfMerchandise( nonExistingId1, null ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantiOfMerchandise( null, nonExistingId2 ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantiOfMerchandise( nonExistingId1, nonExistingId2 ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantiOfMerchandise( fulfillmentCenterId0, null ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getPurchaseQuantiOfMerchandise( fulfillmentCenterId0, nonExistingId2 ) );
    }


    @Test
    public void testInvalidParamsForGetFulfillmentCenterIdForPurchase() {
        // given / when / then
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getFulfillmentCenterIdForPurchase( null ) );
        assertThrows ( ShopException.class,
                () -> purchaseUseCases.getFulfillmentCenterIdForPurchase( nonExistingId1 ) );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\CheckoutAcceptanceTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingcart;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * This test checks the management of inventory across fulfillment centers. It focuses on the
 * cases where more than one fulfillment center are needed to serve the shopping cart of a customer.
 */
@Slf4j
@SpringBootTest
public class CheckoutAcceptanceTest {
    @Autowired
    private CustomerRegistrationUseCases customerRegistrationUseCases;
    @Autowired
    private ShoppingCartUseCases shoppingCartUseCases;
    @Autowired
    private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
    @Autowired
    private PurchaseUseCases purchaseUseCases;
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private CustomerTestHelper customerTestHelper;
    @Autowired
    private MerchandiseTestHelper merchandiseTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;

    private Map<UUID, Integer>  map8_11_14_quantity_2_2_2, 
                                map8_11_14_quantity_3_3_4,
                                map10_12_quantity_1_1, 
                                map11_quantity_1, 
                                map12_quantity_10,
                                map8_9_10_11_quantity_2_1_4_2;
    private MailAddressType customerMailAddress3, customerMailAddress6,
            customerMailAddress2;
    private UUID merchandiseId8, merchandiseId9, merchandiseId10, merchandiseId11, merchandiseId12,
            merchandiseId14;


    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        customerTestHelper.registerAllCustomers();
        merchandiseTestHelper.addAllMerchandises();
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );

        customerMailAddress3 = customerTestHelper.getCustomerMailAddress( 3 );
        customerMailAddress6 = customerTestHelper.getCustomerMailAddress( 6 );
        customerMailAddress2 = customerTestHelper.getCustomerMailAddress( 2 );

        merchandiseId8 = merchandiseTestHelper.getMerchandiseId( 8 );
        merchandiseId9 = merchandiseTestHelper.getMerchandiseId( 9 );
        merchandiseId10 = merchandiseTestHelper.getMerchandiseId( 10 );
        merchandiseId11 = merchandiseTestHelper.getMerchandiseId( 11 );
        merchandiseId12 = merchandiseTestHelper.getMerchandiseId( 12 );
        merchandiseId14 = merchandiseTestHelper.getMerchandiseId( 14 );

        map8_11_14_quantity_2_2_2 = new HashMap<>() {{
            put( merchandiseId8, 2 );
            put( merchandiseId11, 2 );
            put( merchandiseId14, 2 );
        }};
        map8_11_14_quantity_3_3_4 = new HashMap<>() {{
            put( merchandiseId8, 3 );
            put( merchandiseId11, 3 );
            put( merchandiseId14, 4 );
        }};
        map10_12_quantity_1_1 = new HashMap<>() {{
            put( merchandiseId10, 1 );
            put( merchandiseId12, 1 );
        }};
        map11_quantity_1 = new HashMap<>() {{
            put( merchandiseId11, 1 );
        }};
        map12_quantity_10 = new HashMap<>() {{
            put( merchandiseId12, 10 );
        }};
        map8_9_10_11_quantity_2_1_4_2 = new HashMap<>() {{
            put( merchandiseId8, 2 );
            put( merchandiseId9, 1 );
            put( merchandiseId10, 4 );
            put( merchandiseId11, 2 );
        }};

    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of inventory
     * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
     */
    @Test
    public void testClosestSingleFulfillmentCenterWins() {
        log.info( "testClosestSingleFulfillmentCenterWins" );

        // given
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress3, merchandiseId8, 2 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress3, merchandiseId11, 2 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress3, merchandiseId14, 2 );
        // that basket could have been served from fulfillment center 4 or 7, but 4 is closer to the customer
        UUID fulfillmentCenterId4 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 4 );

        // when
        Set<UUID> purchaseIds = shoppingCartUseCases.checkout( customerMailAddress3 );

        // then
        checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId4 );
        checkMerchandiseNumbers( purchaseIds, fulfillmentCenterId4, map8_11_14_quantity_2_2_2 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of inventory
     * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
     */
    @Test
    public void testFulfillmentCenterWithEnoughCapacityWins() {
        log.info( "testFulfillmentCenterWithEnoughCapacityWins" );

        // given
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress3, merchandiseId8, 3 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress3, merchandiseId11, 3 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress3, merchandiseId14, 4 );
        // that basket could have been served from fulfillment center 4 or 7, 4 is closer to the customer,
        // but only 7 has enough capacity
        UUID fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );

        // when
        Set<UUID> purchaseIds = shoppingCartUseCases.checkout( customerMailAddress3 );

        // then
        checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId7 );
        checkMerchandiseNumbers( purchaseIds, fulfillmentCenterId7, map8_11_14_quantity_3_3_4 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of inventory
     * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
     */
    @Test
    public void testTwoFulfillmentCenters() {
        log.info( "testTwoFulfillmentCenters" );

        // given
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress6, merchandiseId10, 1 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress6, merchandiseId11, 1 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress6, merchandiseId12, 1 );
        // that basket needs two shipments (2 + 1 merchandises) anyway, and there
        // are 2 options for the bigger one: 10+12 from 5, or 10+11 from 7. The first one is
        // closer. The smaller can then be served from 4 (closest), 7, or 8.
        UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
                // should cover map10_12_quantity_1_1
        UUID fulfillmentCenterId4 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 4 );
                // should cover map11_quantity_1

        // when
        Set<UUID> purchaseIds = shoppingCartUseCases.checkout( customerMailAddress6 );

        // then
        checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId5, fulfillmentCenterId4 );
        checkMerchandiseNumbers( purchaseIds, fulfillmentCenterId5, map10_12_quantity_1_1 );
        checkMerchandiseNumbers( purchaseIds, fulfillmentCenterId4, map11_quantity_1 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of inventory
     * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
     */
    @Test
    public void testTwoBigShipments() {
        log.info( "testTwoBigShipments" );

        // given
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress2, merchandiseId8, 2 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress2, merchandiseId9, 1 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress2, merchandiseId10, 4 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress2, merchandiseId11, 2 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress2, merchandiseId12, 10 );
        // when
        Set<UUID> purchaseIds = shoppingCartUseCases.checkout( customerMailAddress2 );
        UUID fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );
                // should cover map8_9_10_11_quantity_2_1_4_2 - the only option to cover 4 out of 5 merchandises
        UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
                // should cover map12_quantity_10 - the only fulfillment center with enough capacity for 10 merchandises

        // then
        checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId7, fulfillmentCenterId5 );
        checkMerchandiseNumbers( purchaseIds, fulfillmentCenterId7, map8_9_10_11_quantity_2_1_4_2 );
        checkMerchandiseNumbers( purchaseIds, fulfillmentCenterId5, map12_quantity_10 );
    }


    /**
     * Hint: to better understand the expected results of this test, see the distribution of inventory
     * across fulfillment centers, as specified in the FulfillmentCenterTestHelper and in the README file.
     */
    @Test
    public void testOnlyOneSolution() {
        log.info( "testOnlyOneSolution" );

        // given
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress6, merchandiseId12, 10 );
        // when
        Set<UUID> purchaseIds = shoppingCartUseCases.checkout( customerMailAddress6 );
        UUID fulfillmentCenterId5 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 5 );
        // should cover map12_quantity_10 - the only fulfillment center with enough capacity for 10 merchandises

        // then
        checkFulfillmentCenterIds( purchaseIds, fulfillmentCenterId5 );
        checkMerchandiseNumbers( purchaseIds, fulfillmentCenterId5, map12_quantity_10 );
    }



    private void checkMerchandiseNumbers( Set<UUID> purchaseIds, UUID fulfillmentCenterId, Map<UUID, Integer> expectedMap ) {
        UUID fittingPurchaseId = null;
        for ( UUID purchaseId : purchaseIds ) {
            UUID foundFulfillmentCenterId = purchaseUseCases.getFulfillmentCenterIdForPurchase( purchaseId );
            if ( foundFulfillmentCenterId.equals( fulfillmentCenterId ) ) {
                fittingPurchaseId = purchaseId;
                break;
            }
        }
        assertNotNull( fittingPurchaseId, "No fitting purchase found for fulfillment center " + fulfillmentCenterId );

        int totalExpected = 0;
        int totalActual = 0;
        for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
            totalExpected += entry.getValue();
        }
        log.info( "Check purchase numbers for merchandise {} in fulfillment center {}", fittingPurchaseId, fulfillmentCenterId );
        for ( Map.Entry<UUID, Integer> entry : expectedMap.entrySet() ) {
            UUID merchandiseId = entry.getKey();
            Integer foundNumber =
                    purchaseUseCases.getPurchaseQuantiOfMerchandise( fittingPurchaseId, merchandiseId );
            assertEquals( entry.getValue(), foundNumber );
            totalActual += foundNumber;
        }
        // last check - do the total sums match?
        assertEquals( totalExpected, totalActual );
    }


    private void checkFulfillmentCenterIds( Set<UUID> purchaseIds, UUID... expectedFulfillmentCenterIds ) {
        assertEquals( expectedFulfillmentCenterIds.length, purchaseIds.size() );
        Set<UUID> foundFulfillmentCenterIds = new HashSet<>();
        for ( UUID purchaseId : purchaseIds ) {
            UUID fulfillmentCenterId = purchaseUseCases.getFulfillmentCenterIdForPurchase( purchaseId );
            foundFulfillmentCenterIds.add( fulfillmentCenterId );
        }
        for ( UUID expectedFulfillmentCenterId : expectedFulfillmentCenterIds ) {
            assertTrue( foundFulfillmentCenterIds.contains( expectedFulfillmentCenterId ) );
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\ShoppingCartRESTTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingcart;

import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
import thkoeln.archilab.ecommerce.helpers.impl.RESTTestHelperConfiguration;
import thkoeln.archilab.ecommerce.usecases.ShoppingCartUseCases;
import thkoeln.archilab.ecommerce.usecases.FulfillmentCenterUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.instantiateMailAddress;


@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@Import( RESTTestHelperConfiguration.class )
public class ShoppingCartRESTTest {
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private ShoppingCartUseCases shoppingCartUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private CustomerTestHelper customerTestHelper;
    @Autowired
    private MerchandiseTestHelper merchandiseTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;
    @Autowired
    private MockMvc mockMvc;
    @Autowired
    private ShoppingCartRESTHelper shoppingCartRESTHelper;

    private MailAddressType nonExistingMailAddress;
    private final Map<UUID, Integer> emptyMap = new HashMap<>();

    private Map<UUID, Integer> map9_quantity_1, map5_quantity_2, map7_quantity_7, map9_11_quantity_2_2;
    private MailAddressType
            customerMailAddress0,
            customerMailAddress3,
            customerMailAddress6,
            customerMailAddress8;
    private String customerName0, customerName8;
    private UUID merchandiseId0, merchandiseId1, merchandiseId2, merchandiseId3, merchandiseId5,
                 merchandiseId7, merchandiseId9, merchandiseId11, nonExistentMerchandiseId;
    private UUID fulfillmentCenterId0, fulfillmentCenterId3, fulfillmentCenterId7, fulfillmentCenterId8;


    private static final ResultMatcher NOT_FOUND = status().isNotFound();
    private static final ResultMatcher OK = status().isOk();
    private static final ResultMatcher CREATED = status().isCreated();
    private static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
    private static final ResultMatcher CONFLICT = status().isConflict();

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        customerTestHelper.registerAllCustomers();
        merchandiseTestHelper.addAllMerchandises();
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        nonExistingMailAddress = instantiateMailAddress( "harry@sally.de" );

        customerMailAddress0 = customerTestHelper.getCustomerMailAddress( 0 );
        customerMailAddress3 = customerTestHelper.getCustomerMailAddress( 3 );
        customerMailAddress6 = customerTestHelper.getCustomerMailAddress( 6 );
        customerMailAddress8 = customerTestHelper.getCustomerMailAddress( 8 );
        customerName0 = customerTestHelper.getCustomerName( 0 );
        customerName8 = customerTestHelper.getCustomerName( 8 );

        merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 );
        merchandiseId1 = merchandiseTestHelper.getMerchandiseId( 1 );
        merchandiseId2 = merchandiseTestHelper.getMerchandiseId( 2 );
        merchandiseId3 = merchandiseTestHelper.getMerchandiseId( 3 );
        merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 );
        merchandiseId7 = merchandiseTestHelper.getMerchandiseId( 7 );
        merchandiseId9 = merchandiseTestHelper.getMerchandiseId( 9 );
        merchandiseId11 = merchandiseTestHelper.getMerchandiseId( 11 );
        nonExistentMerchandiseId = UUID.randomUUID();

        fulfillmentCenterId0 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 0 );
        fulfillmentCenterId3 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 3 );
        fulfillmentCenterId7 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 7 );
        fulfillmentCenterId8 = fulfillmentCenterTestHelper.getFulfillmentCenterId( 8 );

        map9_quantity_1 = new HashMap<>() {{
            put( merchandiseId9, 1 );
        }};
        map5_quantity_2 = new HashMap<>() {{
            put( merchandiseId5, 2 );
        }};
        map7_quantity_7 = new HashMap<>() {{
            put( merchandiseId7, 7 );
        }};
        map9_11_quantity_2_2 = new HashMap<>() {{
            put( merchandiseId9, 2 );
            put( merchandiseId11, 2 );
        }};
    }


    @Test
    public void testInvalidShoppingCartBaseUris() throws Exception {
        // given
        String allShoppingCartsUri = "/shoppingCarts";
        String randomIdUri = "/shoppingCarts/" + UUID.randomUUID();
        String randomCustomerUUID = "/shoppingCarts?customerId=" + UUID.randomUUID();
        String invalidCustomerUUID = "/shoppingCarts?customerId=invalidUUID";
        String randomParamUri = "/shoppingCarts?randomParam=randomValue";

        // when
        // then
        mockMvc.perform( get( allShoppingCartsUri ) ).andExpect( status().isMethodNotAllowed() );
        mockMvc.perform( get( randomIdUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomCustomerUUID ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( invalidCustomerUUID ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( randomParamUri ) ).andExpect( status().is4xxClientError() );
    }


    @Test
    public void testInvalidPartUris() throws Exception {
        // given
        UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress8, emptyMap );
        String randomPartUri = "/shoppingCarts/" + shoppingCartId8.toString() + "/random";
        String randomMerchandiseUri = "/shoppingCarts/" + shoppingCartId8.toString()
                + "/parts/" + UUID.randomUUID();

        // when
        // then
        mockMvc.perform( post( randomPartUri ) ).andExpect( status().isNotFound() );
        mockMvc.perform( delete( randomMerchandiseUri ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testInvalidAddToShoppingCart() throws Exception {
        // given
        Map<UUID, Integer> expectedStartQuantityMap = new HashMap<>();
        expectedStartQuantityMap.put( merchandiseId2, 19 );

        // when
        UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress0, emptyMap );
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId, merchandiseId2, 6 );
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId, merchandiseId2, 13 );

        // then
        shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress0, expectedStartQuantityMap );

        // ... and check a couple of invalid cases
        shoppingCartRESTHelper.addMerchandiseToShoppingCart(
                shoppingCartId, nonExistentMerchandiseId, 12, NOT_FOUND );
        shoppingCartRESTHelper.addMerchandiseToShoppingCart(
                UUID.randomUUID(), merchandiseId5, 12, NOT_FOUND );
        shoppingCartRESTHelper.addMerchandiseToShoppingCart(
                shoppingCartId, merchandiseId5, -1, UNPROCESSABLE_ENTITY );

        // check if the shopping cart is still the same
        shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress0, expectedStartQuantityMap );
    }


    @Test
    public void testInvalidCheckout_unavailableMerchandise() throws Exception {
        // given
        UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress0, emptyMap );

        // when
        // productId0 is not available in the requested quantity (or rather, not at all)
        shoppingCartRESTHelper.addMerchandiseToShoppingCart(
                shoppingCartId, merchandiseId0, 1, CREATED );

        // check if the shopping cart is still the same
        shoppingCartRESTHelper.checkout( shoppingCartId, null, CONFLICT, null );
    }


    @Test
    public void testInvalidCheckout_tooLittleInventory() throws Exception {
        // given
        UUID shoppingCartId = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress0, emptyMap );

        // when
        // There are only 10 pieces of productId1 available
        shoppingCartRESTHelper.addMerchandiseToShoppingCart(
                shoppingCartId, merchandiseId1, 11, CREATED );

        // check if the shopping cart is still the same
        shoppingCartRESTHelper.checkout( shoppingCartId, null, CONFLICT, null );
    }



    @Test
    public void testDeleteMerchandiseFromShoppingCart() throws Exception {
        // given
        UUID shoppingCartId6 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, emptyMap );
        Map<UUID, Integer> expectedQuantityMap1 = new HashMap<>();
        expectedQuantityMap1.put( merchandiseId1, 1 );
        expectedQuantityMap1.put( merchandiseId2, 2 );
        expectedQuantityMap1.put( merchandiseId3, 3 );
        Map<UUID, Integer> quantityMap2 = new HashMap<>();
        quantityMap2.put( merchandiseId1, 1 );
        quantityMap2.put( merchandiseId3, 3 );

        // when
        // then
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId6, merchandiseId1, 1 );
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId6, merchandiseId2, 2 );
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId6, merchandiseId3, 3 );
        shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, expectedQuantityMap1 );

        shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart( shoppingCartId6, merchandiseId2 );
        shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, quantityMap2 );
    }


    @Test
    public void testNoDoubleDelete() throws Exception {
        // given
        UUID shoppingCartId6 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, emptyMap );

        // when
        // then
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId6, merchandiseId3, 3 );
        shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart( shoppingCartId6, merchandiseId3 );
        shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, new HashMap<>() );
        shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart( shoppingCartId6, merchandiseId3, NOT_FOUND );
    }


    @Test
    public void testAddRemoveMerchandisesFromAndToShoppingCart() throws Exception {
        // given
        UUID shoppingCartId3 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress3, emptyMap );
        UUID shoppingCartId5 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, emptyMap );

        // when
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId3, merchandiseId1, 2 );
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId3, merchandiseId2, 3 );
        shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart( shoppingCartId3, merchandiseId1 );
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId3, merchandiseId1, 1 );
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId3, merchandiseId2, 6 );

        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId5, merchandiseId1, 2 );
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId5, merchandiseId2, 8 );
        shoppingCartRESTHelper.deleteMerchandiseFromShoppingCart( shoppingCartId5, merchandiseId1 );
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId5, merchandiseId1, 1 );
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId5, merchandiseId2, 2 );

        // then
        // customer3 has 1x merchandiseId1 and 9x merchandiseId2 expected in cart
        Map<UUID, Integer> expectedMap3 = new HashMap<>();
        expectedMap3.put( merchandiseId1, 1 );
        expectedMap3.put( merchandiseId2, 9 );
        shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress3, expectedMap3 );

        // customer6 has 1x merchandiseId1 and 10x merchandiseId2 in cart
        Map<UUID, Integer> expectedMap5 = new HashMap<>();
        expectedMap5.put( merchandiseId1, 1 );
        expectedMap5.put( merchandiseId2, 10 );
        shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress6, expectedMap5 );
    }


    @Test
    public void testNoDoubleCheckout() throws Exception {
        // given
        UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart( customerMailAddress8, emptyMap );

        // when
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId8, merchandiseId2, 3 );

        // then
        shoppingCartRESTHelper.checkout( shoppingCartId8, customerName8, CREATED, null );
        shoppingCartRESTHelper.checkout( shoppingCartId8, null, CONFLICT, null );
    }


    @Test
    public void testCheckout_1_Purchase() throws Exception {
        // given:
        // Customer 0 wants to buy 1x merchandise 9. This is in fulfillment center 5, 7, and 8. Out of these,
        // fulfillment center 8 with zip code 89250 is closest to customer 0 with zip code 02314.
        Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>() {{
            put( fulfillmentCenterId8, map9_quantity_1 );
        }};
        UUID shoppingCartId0 = shoppingCartRESTHelper.getQueryShoppingCart(
                customerMailAddress0, null );
        int inventory9before =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId8, merchandiseId9 );

        // when
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId0, merchandiseId9, 1 );
        shoppingCartRESTHelper.checkout( shoppingCartId0, customerName0, CREATED, expectedPurchases );
        int inventory9after =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId8, merchandiseId9 );

        // then
        assertEquals( 1, inventory9before - inventory9after );
    }


    @Test
    public void testCheckout_3_Purchase() throws Exception {
        // given:
        // Customer 8 (Felix Bauer) wants to buy 2x each of merchandises 5, 9, 11; and 7x merchandise 7.
        //       - merchandises 9 and 11 can both be found in fulfillment centers 7 and 8. Fulfillment centers 7 (76532) is closer to
        //         the customer (70173)
        //       - merchandise 7 is available in fulfillment centers 1, 2, and 3, but only fulfillment center 3 has enough inventory.
        //       - merchandise 5 is only available in fulfillment center 0.
        Map<UUID, Map<UUID, Integer>> expectedPurchases = new HashMap<>() {{
            put( fulfillmentCenterId0, map5_quantity_2 );
            put( fulfillmentCenterId3, map7_quantity_7 );
            put( fulfillmentCenterId7, map9_11_quantity_2_2 );
        }};
        UUID shoppingCartId8 = shoppingCartRESTHelper.getQueryShoppingCart(
                customerMailAddress8, null );
        int inventory5before =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId5 );
        int inventory7before =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId3, merchandiseId7 );
        int inventory9before =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId7, merchandiseId9 );
        int inventory11before =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId7, merchandiseId11 );

        // when
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId8, merchandiseId5, 2 );
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId8, merchandiseId7, 7 );
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId8, merchandiseId9, 2 );
        shoppingCartRESTHelper.addMerchandiseToShoppingCart( shoppingCartId8, merchandiseId11, 2 );
        shoppingCartRESTHelper.checkout( shoppingCartId8, customerName8, CREATED, expectedPurchases );
        int inventory5after =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId0, merchandiseId5 );
        int inventory7after =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId3, merchandiseId7 );
        int inventory9after =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId7, merchandiseId9 );
        int inventory11after =
                fulfillmentCenterUseCases.getAvailableInventory( fulfillmentCenterId7, merchandiseId11 );

        // then
        assertEquals( 2, inventory5before - inventory5after );
        assertEquals( 7, inventory7before - inventory7after );
        assertEquals( 2, inventory9before - inventory9after );
        assertEquals( 2, inventory11before - inventory11after );
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\shoppingcart\ShoppingCartTest.java ---
package thkoeln.archilab.ecommerce.tests.shoppingcart;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.InsufficientInventoryException;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.masterdata.MerchandiseTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.CustomerTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.FulfillmentCenterTestHelper;
import thkoeln.archilab.ecommerce.usecases.masterdata.Purgatory;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;


import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.usecases.masterdata.FactoryMethodInvoker.*;

@SpringBootTest
public class ShoppingCartTest {
    @Autowired
    private CustomerRegistrationUseCases customerRegistrationUseCases;
    @Autowired
    private ShoppingCartUseCases shoppingCartUseCases;
    @Autowired
    private MerchandiseCatalogUseCases merchandiseCatalogUseCases;
    @Autowired
    private FulfillmentCenterUseCases fulfillmentCenterUseCases;
    @Autowired
    private PurchaseUseCases purchaseUseCases;
    @Autowired
    private Purgatory purgatory;
    @Autowired
    private CustomerTestHelper customerTestHelper;
    @Autowired
    private MerchandiseTestHelper merchandiseTestHelper;
    @Autowired
    private FulfillmentCenterTestHelper fulfillmentCenterTestHelper;

    private MailAddressType nonExistingMailAddress;

    @BeforeEach
    public void setUp() {
        purgatory.deleteEverything();
        customerTestHelper.registerAllCustomers();
        merchandiseTestHelper.addAllMerchandises();

        nonExistingMailAddress = instantiateMailAddress( "this@nononono.de" );
    }


    @Test
    public void testInvalidAddToShoppingCart() {
        // given
        UUID nonExistentMerchandiseId = UUID.randomUUID();
        UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 );
        UUID merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 );
        MailAddressType customerMailAddress0 =
                customerTestHelper.getCustomerMailAddress( 0 );
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );

        // then
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.addMerchandiseToShoppingCart(
                        nonExistingMailAddress, merchandiseId0, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.addMerchandiseToShoppingCart(
                        null, merchandiseId0, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.addMerchandiseToShoppingCart(
                        customerMailAddress0, nonExistentMerchandiseId, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.addMerchandiseToShoppingCart(
                        customerMailAddress0, null, 1 ) );
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.addMerchandiseToShoppingCart(
                        customerMailAddress0, merchandiseId5, -1 ) );
    }


    @Test
    public void testInvalidRemoveFromShoppingCart() {
        // given
        UUID nonExistentMerchandiseId = UUID.randomUUID();
        UUID merchandiseId5 = merchandiseTestHelper.getMerchandiseId( 5 );
        UUID merchandiseId1 = merchandiseTestHelper.getMerchandiseId( 1 );
        UUID merchandiseId2 = merchandiseTestHelper.getMerchandiseId( 2 );
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        MailAddressType customerMailAddress0 =
                customerTestHelper.getCustomerMailAddress( 0 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress0, merchandiseId1, 5 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress0, merchandiseId2, 15 );

        // when
        shoppingCartUseCases.removeMerchandiseFromShoppingCart(
                customerMailAddress0, merchandiseId1, 2 );
        shoppingCartUseCases.removeMerchandiseFromShoppingCart(
                customerMailAddress0, merchandiseId2, 4 );
        shoppingCartUseCases.removeMerchandiseFromShoppingCart(
                customerMailAddress0, merchandiseId2, 7 );
        // now we should have 3x merchandiseId1 and 4x merchandiseId2 in the shopping cart

        // then
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.removeMerchandiseFromShoppingCart(
                        customerMailAddress0, nonExistentMerchandiseId, 12 ) );
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.removeMerchandiseFromShoppingCart(
                        nonExistingMailAddress, merchandiseId5, 12 ) );
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.removeMerchandiseFromShoppingCart(
                        customerMailAddress0, merchandiseId5, -1 ) );
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.removeMerchandiseFromShoppingCart(
                        customerMailAddress0, merchandiseId1, 4 ) );
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.removeMerchandiseFromShoppingCart(
                        customerMailAddress0, merchandiseId2, 5 ) );
    }


    @Test
    public void testAddRemoveMerchandisesFromAndToShoppingCart() {
        // given
        UUID merchandiseId1 = merchandiseTestHelper.getMerchandiseId( 1 );
        UUID merchandiseId2 = merchandiseTestHelper.getMerchandiseId( 2 );
        MailAddressType customerMailAddress3 =
                customerTestHelper.getCustomerMailAddress( 3 );
        MailAddressType customerMailAddress5 =
                customerTestHelper.getCustomerMailAddress( 5 );

        // when customer 3 ...
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress3, merchandiseId1, 2 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress3, merchandiseId2, 3 );
        shoppingCartUseCases.removeMerchandiseFromShoppingCart(
                customerMailAddress3, merchandiseId1, 2 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress3, merchandiseId1, 1 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress3, merchandiseId2, 6 );
        Map<UUID, Integer> cart3 = shoppingCartUseCases.getShoppingCartAsMap( customerMailAddress3 );
        // customer3 has 1x merchandiseId1 and 9x merchandiseId2 in cart

        // ... and when customer 5 ...
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress5, merchandiseId1, 2 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress5, merchandiseId2, 8 );
        shoppingCartUseCases.removeMerchandiseFromShoppingCart(
                customerMailAddress5, merchandiseId1, 1 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress5, merchandiseId2, 2 );
        Map<UUID, Integer> cart5 = shoppingCartUseCases.getShoppingCartAsMap( customerMailAddress5 );
        // customer5 has 1x merchandiseId1 and 10x merchandiseId2 in cart

        // then
        assertEquals( 2, cart3.size() );
        assertEquals( 1, cart3.get( merchandiseId1 ) );
        assertEquals( 9, cart3.get( merchandiseId2 ) );

        assertEquals( 2, cart5.size() );
        assertEquals( 1, cart5.get( merchandiseId1 ) );
        assertEquals( 10, cart5.get( merchandiseId2 ) );
    }


    @Test
    public void testShoppingCartValue() {
        // given
        UUID merchandiseId3 = merchandiseTestHelper.getMerchandiseId( 3 );
        UUID merchandiseId6 = merchandiseTestHelper.getMerchandiseId( 6 );
        UUID merchandiseId8 = merchandiseTestHelper.getMerchandiseId( 8 );
        MoneyType price3 = merchandiseTestHelper.getSalesPrice( 3 );
        MoneyType price6 = merchandiseTestHelper.getSalesPrice( 6 );
        MoneyType price8 = merchandiseTestHelper.getSalesPrice( 8 );
        MailAddressType customerMailAddress3 =
                customerTestHelper.getCustomerMailAddress( 3 );

        // when
        shoppingCartUseCases.addMerchandiseToShoppingCart( customerMailAddress3, merchandiseId3, 3 );
        shoppingCartUseCases.addMerchandiseToShoppingCart( customerMailAddress3, merchandiseId6, 2 );
        shoppingCartUseCases.addMerchandiseToShoppingCart( customerMailAddress3, merchandiseId8, 5 );
        // customer3 has 3x merchandiseId3, 2x merchandiseId6 and 5x merchandiseId8 in cart
        MoneyType cartValue = shoppingCartUseCases.getShoppingCartAsMoneyValue( customerMailAddress3 );

        // then
        assertEquals( price3.multiplyBy( 3 ).add( price6.multiplyBy( 2 ) ).add( price8.multiplyBy( 5 ) ),
                cartValue );
    }


    @Test
    public void testShoppingCartValueInvalid() {
        // given
        // when
        // then
        assertThrows( ShopException.class,
                () -> shoppingCartUseCases.getShoppingCartAsMoneyValue( nonExistingMailAddress ) );
    }


    @Test
    public void testUnsuccessfulCheckout() {
        // given customer buying merchandise 0 (which is not in inventory), and customer 1 buying merchandise 1
        // in a bigger quantity (11) than available (10)
        fulfillmentCenterTestHelper.addAllFulfillmentCenters( true );
        MailAddressType customerMailAddress0 =
                customerTestHelper.getCustomerMailAddress( 0 );
        MailAddressType customerMailAddress1 =
                customerTestHelper.getCustomerMailAddress( 1 );
        UUID merchandiseId0 = merchandiseTestHelper.getMerchandiseId( 0 );
        UUID merchandiseId1 = merchandiseTestHelper.getMerchandiseId( 1 );

        // when
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress0, merchandiseId0, 1 );
        shoppingCartUseCases.addMerchandiseToShoppingCart(
                customerMailAddress1, merchandiseId1, 11 );

        // then
        assertThrows( InsufficientInventoryException.class,
                () -> shoppingCartUseCases.checkout( customerMailAddress0 ) );
        assertThrows( InsufficientInventoryException.class,
                () -> shoppingCartUseCases.checkout( customerMailAddress1 ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_45bf5393-b059-4cbe-9bd4-04e7fe19c122\src\test\java\thkoeln\archilab\ecommerce\tests\testtests\RulesForOwnTests.java ---
package thkoeln.archilab.ecommerce.tests.testtests;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.domain.JavaMethod;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.web.bind.annotation.RestController;
import thkoeln.archilab.ecommerce.helpers.ShoppingCartRESTHelper;
import thkoeln.archilab.ecommerce.tests.owntests.DomainPrimitiveJSONSerializationTest;
import thkoeln.archilab.ecommerce.tests.owntests.OwnShoppingCartRESTTest;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PhysicalAddressType;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static org.springframework.test.util.AssertionErrors.assertTrue;

/**
 * This test checks if there are the appropriate tests in the test class(es) for domain
 * primitives.
 */

public class RulesForOwnTests {
    private JavaClass dpTestClass, restTestClass;
    private JavaClasses dpTestClasses, restTestClasses;
    private static final String FULFILLMENT_CENTER_DOMAIN_PACKAGE =
            "thkoeln.archilab.ecommerce.solution.fulfillmentcenter.domain";
    private static final String FULFILLMENT_CENTER_CLASS_NAME =
            FULFILLMENT_CENTER_DOMAIN_PACKAGE + ".FulfillmentCenter";


    @BeforeEach
    public void setUp() throws Exception {
        dpTestClass = new ClassFileImporter().importClass( DomainPrimitiveJSONSerializationTest.class );
        restTestClass = new ClassFileImporter().importClass( OwnShoppingCartRESTTest.class );

        dpTestClasses = new ClassFileImporter().importClasses( DomainPrimitiveJSONSerializationTest.class );
        restTestClasses = new ClassFileImporter().importClasses( OwnShoppingCartRESTTest.class );
    }


    @Test
    public void ensureMinimumNumberOfTestMethods() {
        // given
        // when
        int dpTestMethodCount = getTestMethodCount( dpTestClass );
        int restTestMethodCount = getTestMethodCount( restTestClass );

        // then
        assertTrue( "There should be at least 4 test methods in the dp test class, but there are only "
                        + dpTestMethodCount,dpTestMethodCount >= 2 );
        assertTrue( "There should be at least 5 test methods in the rest test class, but there are only "
                        + restTestMethodCount, restTestMethodCount >= 5 );
    }

    private int getTestMethodCount( JavaClass testClass ) {
        int testMethodCount = 0;
        for ( JavaMethod method : testClass.getMethods() ) {
            if ( isTestMethod( method ) ) {
                testMethodCount++;
            }
        }
        return testMethodCount;
    }

    private boolean isTestMethod( JavaMethod method ) {
        return method.isAnnotatedWith( Test.class );
    }


    @Test
    public void dpTestsShouldReferenceTheRightClasses() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAssignableTo( ZipCodeType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( MoneyType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( PhysicalAddressType.class )
                .andShould().dependOnClassesThat()
                .areAssignableTo( MailAddressType.class )
                .because( "DomainPrimitiveJSONSerializationTest should reference ZipCode, " +
                        "Money, MailAddress, and PhysicalAddress!" );
        rule.check( dpTestClasses );
    }


    @Test
    public void restTestsShouldReferenceMailAddress() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAssignableTo( MailAddressType.class )
                .because( "FulfillmentCenterComparatorUnitTest should reference MailAddressType!" );
        rule.check( restTestClasses );
    }


    @Test
    public void restTestsShouldReferenceRESTControllers() {
        ArchRule rule = classes()
                .should().dependOnClassesThat()
                .areAnnotatedWith( RestController.class )
                .orShould().dependOnClassesThat()
                .areAssignableTo( ShoppingCartRESTHelper.class )
                .because( "FulfillmentCenterComparatorUnitTest should call REST controllers! " +
                        "(either directly or via the ShoppingCartRESTHelper REST helper)" );
        rule.check( restTestClasses );
    }

}


[RESPONSE]:

Generated by deepseek-reasoner
-----------------------------------