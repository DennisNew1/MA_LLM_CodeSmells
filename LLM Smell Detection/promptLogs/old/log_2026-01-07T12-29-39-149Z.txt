--- DATE: 7.1.2026, 13:29:39 ---

[PROMPT]:
Du bist Javaentwickler und musst diese Code Smells finden: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl das duplizierte als auch die originale Zeile an. Bei duplizierten codeblöcken die Blöcke angeben, auch jeweils original Block und kopierter. ,negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind. ,dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden. ,layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets.,missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse.,Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages.,Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst unter die enstrechende Datei.
    Es wird die 4 schichtige Architektur nach Eric Evans genutzt. 
    Liste mir jeden Verstoß nur mit Smellname und Zeile pro Datei auf. Liste nicht das Codestück selber. 
    Gibt Gründe an warum du die jeweiligen Smells ausgewählt hast.
    Gruppiere nach Datei. Schreibe "Ende" ganz am Ende wenn du fertig bist. 
    Das ist der Code:



--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Address.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

import javax.persistence.Embeddable;
import javax.persistence.Embedded;

@NoArgsConstructor
@AllArgsConstructor
@Embeddable //ValueObject
@EqualsAndHashCode
public class Address implements HomeAddressType {
    @Embedded
    private PostalCode postcode;
    private String city;
    private String street;

    public Address(PostalCodeType postcode, String city, String street) {
        if (postcode == null || city == null || city.isEmpty() || street == null || street.isEmpty()) {
            throw new ShopException("Address parameter is empty! Invalid!");
        }
        this.postcode = (PostalCode) postcode;
        this.city = city;
        this.street = street;
    }

    public static HomeAddressType of(String street, String city, PostalCodeType postalCode) {
        return new Address(postalCode, city, street);
    }

    /**
     * @return the street as a string
     */
    @Override
    public String getStreet() {
        return this.street;
    }

    /**
     * @return the city as a string
     */
    @Override
    public String getCity() {
        return this.city;
    }

    /**
     * @return the postal code
     */
    @Override
    public PostalCodeType getPostalCode() {
        return this.postcode;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\AllowedCurrencies.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

public enum AllowedCurrencies {
    EUR("EUR"),
    CHF("CHF");

    private final String value;

    AllowedCurrencies(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }
}



--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Email.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import javax.persistence.Embeddable;

@NoArgsConstructor
@AllArgsConstructor
@Embeddable
//ValueObject as Domain primitve
@EqualsAndHashCode
public class Email implements EmailType {
    @JsonProperty
    private String emailString;

    //Factory Method
    public static EmailType of(String emailString) {
        String regexPattern = "^[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*\\.(de|at|ch|com|org)$";
        if (emailString == null || emailString.isEmpty() || !emailString.matches(regexPattern)) {
            throw new ShopException("Invalid Email! Format does not match requirements");
        }
        return new Email(emailString);
    }

    public static String asString(EmailType emailType) {
        return emailType.toString();
    }

    @Override
    public String toString() {
        return String.format(emailString);
    }

    public static boolean isValidFormat(String emailString){
        String regexPattern = "^[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*\\.(de|at|ch|com|org)$";
        if (emailString.matches(regexPattern)) {
            return true;
        } else {
            return false;
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import javax.persistence.Embeddable;
import javax.persistence.Transient;
import java.util.Arrays;

@NoArgsConstructor
@AllArgsConstructor
@Embeddable
//ValueObject as Domain primitve
@EqualsAndHashCode
public class Money implements MoneyType {

    private Float amount;

    private String currency;

    public static MoneyType of(Float amount, String currency) {
        if (amount == null || currency == null || amount < 0 || !Arrays.stream(AllowedCurrencies.values()).anyMatch(c -> c.getValue().equals(currency))) {
            throw new ShopException("Can not create negative/null MoneyType!");
        } else {
            return new Money(amount, currency);
        }
    }

    /**
     * @return the amount of money
     */
    @Transient
    @Override
    public Float getAmount() {
        return this.amount;
    }

    /**
     * @return the currency of the money
     */
    @Transient
    @Override
    public String getCurrency() {
        return this.currency;
    }

    /**
     * @param otherMoney
     * @return this + otherMoney, as a new object
     * @throws ShopException if ...
     *                       - otherMoney is null
     *                       - otherMoney.currency != this.currency
     */
    @Override
    public MoneyType add(MoneyType otherMoney) {
        if (otherMoney == null || !otherMoney.getCurrency().equals(this.getCurrency())) {
            throw new ShopException("The amount to be added does not match a number or the right currency");
        }
        Money newMoneyType = new Money();
        Float newAmount = this.getAmount() + otherMoney.getAmount();
        newMoneyType.amount = newAmount;
        newMoneyType.currency = this.currency;
        return newMoneyType;
    }

    /**
     * @param otherMoney
     * @return this - otherMoney, as a new object
     * @throws ShopException if ...
     *                       - otherMoney is null
     *                       - otherMoney.currency != this.currency
     *                       - otherMoney > this
     */
    @Override
    public MoneyType subtract(MoneyType otherMoney) {
        if (otherMoney == null || !otherMoney.getCurrency().equals(this.getCurrency()) ||
                otherMoney.getAmount() > this.getAmount()) {
            throw new ShopException("The amount to be removed is larger as it can to be removed or" +
                    "does not match the given currency!");
        }
        Money newMoneyType = new Money();
        Float newAmount = this.getAmount() - otherMoney.getAmount();
        newMoneyType.amount = newAmount;
        newMoneyType.currency = this.currency;
        return newMoneyType;
    }

    /**
     * @param factor
     * @return this * factor, as a new object
     * @throws ShopException if ...
     *                       - factor < 0
     */
    @Override
    public MoneyType multiplyBy(int factor) {
        if (factor < 0) {
            throw new ShopException("The given factor is to low! (Factor < 0)");
        }
        Money newMoneyType = new Money();
        Float newAmount = this.getAmount() * factor;
        newMoneyType.amount = newAmount;
        newMoneyType.currency = this.currency;
        return newMoneyType;
    }

    /**
     * @param otherMoney
     * @return true, if this > otherMoney
     * @throws ShopException if ...
     *                       - otherMoney is null
     *                       - otherMoney.currency != this.currency
     */
    @Override
    public boolean largerThan(MoneyType otherMoney) {
        if (otherMoney == null || !this.getCurrency().equals(otherMoney.getCurrency())) {
            throw new ShopException("The given MoneyType is null or does not match the same currency!");
        }
        return this.getAmount() > otherMoney.getAmount();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PostalCode.java ---
package thkoeln.archilab.ecommerce.domainprimitives;

import lombok.*;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

import javax.persistence.Embeddable;

@NoArgsConstructor
@AllArgsConstructor
@Setter
@Getter
@Embeddable
//ValueObject as Domain primitve
@EqualsAndHashCode
public class PostalCode implements PostalCodeType {
    private String postalCode;

    /*We will use a much simplified validation method to check if the postal code is valid:
     *      - It must contain exactly 5 digits.
     *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid postal code, but 20001 is valid)
     * */

    public static PostalCode of(String postalCode) {
        String regexPattern = "^[0-9][0-9]{3}[1-9]|[1-9][0-9]{2}[1-9][0-9]$";
        if (postalCode == null || !postalCode.matches(regexPattern) || postalCode.length() != 5) {
            throw new ShopException("Invalid PostalCode!");
        }
        return new PostalCode(postalCode);
    }

    @Override
    public String toString() {
        return String.format(postalCode);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\masterdata\FactoryMethodInvoker.java ---
package thkoeln.archilab.ecommerce.masterdata;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.Enumeration;

import static org.junit.jupiter.api.Assertions.*;

public class FactoryMethodInvoker {

    public static EmailType instantiateEmail( String emailAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for EmailType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, emailAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + emailAsString + "'", e );
        }
        assertNotNull( instance );
        return (EmailType) instance;
    }


    public static HomeAddressType instantiateHomeAddress(
            String street, String city, PostalCodeType postalCode ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of",
                    String.class, String.class, PostalCodeType.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for HomeAddressType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, street, city, postalCode );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" +
                    street + "', '" + city + "', '" + postalCode + "'", e );
        }
        assertNotNull( instance );
        return (HomeAddressType) instance;
    }


    public static PostalCodeType instantiatePostalCode( String postalCodeAsString ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for PostalCodeType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, postalCodeAsString );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + postalCodeAsString + "'", e );
        }
        assertNotNull( instance );
        return (PostalCodeType) instance;
    }


    public static MoneyType instantiateMoney( Float amount, String currency ) {
        Method factoryMethod = null;
        try {
            Class<?> interfaceClass = Class.forName(
                    "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType" );
            Class<?> implementingClass = findImplementation( interfaceClass );

            factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
            assertNotNull( factoryMethod );
            int modifiers = factoryMethod.getModifiers();
            assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
        } catch (Exception e) {
            fail( "Failed to find implementation for MoneyType", e );
        }

        Object instance = null;
        try {
            instance = factoryMethod.invoke( null, amount, currency );
        } catch (Exception e) {
            if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                    instanceof ShopException ) throw new ShopException( e.getMessage() );
            fail( "Failed to invoke factory method 'of' for '" + amount + "', '" + currency + "'", e );
        }
        assertNotNull( instance );
        return (MoneyType) instance;
    }


    private static Class<?> findImplementation( Class<?> interfaceClass ) {
        Method factoryMethod = null;
        try {
            String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
            Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
            assertNotNull( implementingClass );
            return implementingClass;
        } catch (Exception e) {
            fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
            return null; // This line will never be reached, but it's necessary to satisfy the compiler
        }
    }


    private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
            throws ClassNotFoundException, IOException {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        String path = packageName.replace( '.', '/' );
        Enumeration<URL> resources = classLoader.getResources( path );
        int count = 0;
        Class<?> result = null;
        while (resources.hasMoreElements()) {
            URL resource = resources.nextElement();
            File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
            File[] files = directory.listFiles();
            for ( File file : files ) {
                if ( file.getName().endsWith( ".class" ) ) {
                    String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
                    Class<?> clazz = Class.forName( className );
                    if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
                        count++;
                        result = clazz;
                    }
                }
            }
        }
        assertEquals( 1, count, "There should be exactly one implementing class" );
        return result;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\masterdata\InitialMasterDataCreator.java ---
package thkoeln.archilab.ecommerce.masterdata;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;
import thkoeln.archilab.ecommerce.usecases.*;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.UUID;


/**
 * This class is used to create the initial master data for the application. This includes
 * clients and goods. It is executed on application startup, and is used for testing purposes.
 */
@Component
@SuppressWarnings("PMD")
public class InitialMasterDataCreator {

    public final static String[] CLIENT_NAME = new String[]{
            "Max Müller",
            "Sophie Schmitz",
            "Irene Mihalic",
            "Emilia Fischer",
            "Filiz Polat",
            "Lina Wagner",
            "Leon Becker",
            "Agnieszka Kalterer",
            "Felix Bauer",
            "Lara Schulz"
    };
    public final static EmailType[] CLIENT_EMAIL = new EmailType[] {
            FactoryMethodInvoker.instantiateEmail( "max.mueller@example.com" ),
            FactoryMethodInvoker.instantiateEmail( "sophie.schmitz@example.com" ),
            FactoryMethodInvoker.instantiateEmail( "irene@wearefreedomnow.com" ),
            FactoryMethodInvoker.instantiateEmail( "emilia.fischer@example.com" ),
            FactoryMethodInvoker.instantiateEmail( "j877d3@gmail.com" ),
            FactoryMethodInvoker.instantiateEmail( "lina.wagner@example.com" ),
            FactoryMethodInvoker.instantiateEmail( "leon.becker@example.com" ),
            FactoryMethodInvoker.instantiateEmail( "agna@here.com" ),
            FactoryMethodInvoker.instantiateEmail( "felix.bauer@example.com" ),
            FactoryMethodInvoker.instantiateEmail( "lara.schulz@example.com" )
    };

    public final static HomeAddressType[] CLIENT_ADDRESS = new HomeAddressType[] {
            FactoryMethodInvoker.instantiateHomeAddress(
                    "Hauptstraße 1", "Berlin",
                    FactoryMethodInvoker.instantiatePostalCode( "10115" ) ),
            FactoryMethodInvoker.instantiateHomeAddress(
                    "Bahnhofstraße 12", "München",
                    FactoryMethodInvoker.instantiatePostalCode( "80331" ) ),
            FactoryMethodInvoker.instantiateHomeAddress(
                    "Kirchplatz 3", "Hamburg",
                    FactoryMethodInvoker.instantiatePostalCode( "20095" ) ),
            FactoryMethodInvoker.instantiateHomeAddress(
                    "Goethestraße 7", "Frankfurt am Main",
                    FactoryMethodInvoker.instantiatePostalCode( "60311" ) ),
            FactoryMethodInvoker.instantiateHomeAddress(
                    "Mühlenweg 15", "Köln",
                    FactoryMethodInvoker.instantiatePostalCode( "50667" ) ),
            FactoryMethodInvoker.instantiateHomeAddress(
                    "Schulstraße 9", "Düsseldorf",
                    FactoryMethodInvoker.instantiatePostalCode( "40213" ) ),
            FactoryMethodInvoker.instantiateHomeAddress(
                    "Dorfstraße 21", "Stuttgart",
                    FactoryMethodInvoker.instantiatePostalCode( "70173" ) ),
            FactoryMethodInvoker.instantiateHomeAddress(
                    "Marktstraße 5", "Leipzig",
                    FactoryMethodInvoker.instantiatePostalCode( "04109" ) ),
            FactoryMethodInvoker.instantiateHomeAddress(
                    "Rosenweg 14", "Dortmund",
                    FactoryMethodInvoker.instantiatePostalCode( "44135" ) ),
            FactoryMethodInvoker.instantiateHomeAddress(
                    "Wiesenstraße 6", "Essen",
                    FactoryMethodInvoker.instantiatePostalCode( "45127" ) )
    };

    public final static ClientType[] mockClients;

    public static final String EUR = "EUR";

    public static final Object[][] GOOD_DATA = new Object[][]{
            {UUID.randomUUID(), "TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
                    1.5f, FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 10.0f, EUR )},
            {UUID.randomUUID(), "EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
                    0.3f, FactoryMethodInvoker.instantiateMoney( 2.5f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 4.0f, EUR )},
            {UUID.randomUUID(), "MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
                    7.2f, FactoryMethodInvoker.instantiateMoney( 50.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 80.0f, EUR )},
            {UUID.randomUUID(), "Gh-25", "Kompakter und leichter Akku für mobile Geräte",
                    null, FactoryMethodInvoker.instantiateMoney( 6.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 8.0f, EUR )},
            {UUID.randomUUID(), "MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
                    null, FactoryMethodInvoker.instantiateMoney( 0.6f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 1.0f, EUR )},
            {UUID.randomUUID(), "ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
                    1.0f, FactoryMethodInvoker.instantiateMoney( 150.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 250.0f, EUR )},
            {UUID.randomUUID(), "Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
                    null, FactoryMethodInvoker.instantiateMoney( 0.3f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 0.5f, EUR )},
            {UUID.randomUUID(), "Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
                    6.0f, FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 120.0f, EUR )},
            {UUID.randomUUID(), "JKL-67", "Wasserdichtes Gehäuse",
                    3.0f, FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 1.2f, EUR )},
            {UUID.randomUUID(), "MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
                    5.5f, FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 45.0f, EUR )},
            {UUID.randomUUID(), "PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
                    4.0f, FactoryMethodInvoker.instantiateMoney( 20.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 35.0f, EUR )},
            {UUID.randomUUID(), "STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
                    null, FactoryMethodInvoker.instantiateMoney( 200.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 350.0f, EUR )},
            {UUID.randomUUID(), "VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
                    null, FactoryMethodInvoker.instantiateMoney( 15.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 25.0f, EUR )},
            {UUID.randomUUID(), "YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
                    3.5f, FactoryMethodInvoker.instantiateMoney( 60.0f, EUR ),
                    FactoryMethodInvoker.instantiateMoney( 100.0f, EUR )}
    };

    private ClientRegistrationUseCases clientRegistrationUseCases;
    private GoodCatalogUseCases goodCatalogUseCases;
    private StockManagementUseCases stockManagementUseCases;
    private ShoppingBasketUseCases shoppingBasketUseCases;


    // good 0 is out of stock, good 1 and 2 have fixed quantities of 10 and 20, respectively, and the
    // others have a random stock between 5 and 100
    public static final Map<UUID, Integer> GOOD_STOCK = new HashMap<>();

    static {
        mockClients = new ClientType[CLIENT_NAME.length];
        for ( int i = 0; i < CLIENT_NAME.length; i++ ) {
            mockClients[i] = new MockClient(
                    CLIENT_NAME[i], CLIENT_EMAIL[i], CLIENT_ADDRESS[i]);
        }
        Random random = new Random();
        for ( Object[] goodData : GOOD_DATA ) {
            GOOD_STOCK.put( (UUID) goodData[0], random.nextInt( 100 ) + 20 );
        }
        GOOD_STOCK.put( (UUID) GOOD_DATA[0][0], 0 );
        GOOD_STOCK.put( (UUID) GOOD_DATA[1][0], 10 );
        GOOD_STOCK.put( (UUID) GOOD_DATA[2][0], 20 );
        GOOD_STOCK.put( (UUID) GOOD_DATA[3][0], 30 );

    }


    public enum InvalidReason {
        NULL, EMPTY;

        public Object getInvalidValue( Object originalValue ) {
            switch (this) {
                case NULL:
                    return null;
                case EMPTY:
                    return "";
                default:
                    return null;
            }
        }
    }


    @Autowired
    public InitialMasterDataCreator(
            ClientRegistrationUseCases clientRegistrationUseCases,
            GoodCatalogUseCases goodCatalogUseCases,
            StockManagementUseCases stockManagementUseCases,
            ShoppingBasketUseCases shoppingBasketUseCases ) {
        this.clientRegistrationUseCases = clientRegistrationUseCases;
        this.goodCatalogUseCases = goodCatalogUseCases;
        this.stockManagementUseCases = stockManagementUseCases;
        this.shoppingBasketUseCases = shoppingBasketUseCases;
    }


    public void deleteAll() {
        shoppingBasketUseCases.deleteAllOrders();
        goodCatalogUseCases.deleteGoodCatalog();
        clientRegistrationUseCases.deleteAllClients();
    }


    public void registerAllClients() {
        for ( int i = 0; i < InitialMasterDataCreator.CLIENT_NAME.length; i++ ) {
            registerClient( InitialMasterDataCreator.CLIENT_NAME[i], CLIENT_EMAIL[i], CLIENT_ADDRESS[i] );
        }
    }


    public void registerClient( String name, EmailType email, HomeAddressType homeAddress ) {
        clientRegistrationUseCases.register( name, email, homeAddress );
    }

    public void addAllGoods() {
        for ( Object[] goodData : GOOD_DATA ) {
            addGoodDataToCatalog( goodData );
        }
    }

    public void addGoodDataToCatalog( Object[] goodData ) {
        goodCatalogUseCases.addGoodToCatalog( (UUID) goodData[0], (String) goodData[1], (String) goodData[2],
                (Float) goodData[3], (MoneyType) goodData[4], (MoneyType) goodData[5] );
    }


    public Object[] getGoodDataInvalidAtIndex( int index, InvalidReason reason ) {
        Object[] goodData = GOOD_DATA[1];
        Object[] goodDataInvalid = new Object[goodData.length];
        System.arraycopy( goodData, 0, goodDataInvalid, 0, goodData.length );
        goodDataInvalid[index] = goodData[index].getClass().cast(
                reason.getInvalidValue( goodData[index] ) );
        return goodDataInvalid;
    }


    public void stockUpAllGoods() {
        for ( Object[] goodData : GOOD_DATA ) {
            if ( GOOD_STOCK.get( goodData[0] ) > 0 )
                stockManagementUseCases.addToStock( (UUID) goodData[0], GOOD_STOCK.get( goodData[0] ) );
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\masterdata\MockClient.java ---
package thkoeln.archilab.ecommerce.masterdata;

import lombok.Setter;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;

import java.util.Objects;

@Setter
public class MockClient implements ClientType {
    private String name;
    private EmailType email;
    private HomeAddressType homeAddress;


    public MockClient( String name, EmailType email, HomeAddressType homeAddress) {
        this.name = name;
        this.email = email;
        this.homeAddress = homeAddress;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public EmailType getEmail() {
        return email;
    }

    @Override
    public HomeAddressType getHomeAddress() {
        return homeAddress;
    }

    @Override
    public boolean equals( Object o ) {
        if ( this == o ) return true;
        if ( !( o instanceof MockClient ) ) return false;
        MockClient that = (MockClient) o;
        return Objects.equals( getName(), that.getName() ) && Objects.equals( email, that.email ) && Objects.equals( homeAddress, that.homeAddress );
    }

    @Override
    public int hashCode() {
        return Objects.hash( getName(), email, homeAddress );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\masterdata\StartupListener.java ---
package thkoeln.archilab.ecommerce.masterdata;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;

@Component
@Profile("!test")
public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
    private Logger logger = LoggerFactory.getLogger( StartupListener.class );

    private InitialMasterDataCreator initialMasterDataCreator;

    @Autowired
    public StartupListener( InitialMasterDataCreator initialMasterDataCreator ) {
        this.initialMasterDataCreator = initialMasterDataCreator;
    }

    @Override
    public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
        logger.info( "Initializing master data..." );
        initialMasterDataCreator.registerAllClients();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
package thkoeln.archilab.ecommerce;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class ProjectApplication {

	/**
	 * Entry method
	 * @param args
	 */
	public static void main(String[] args) {
		SpringApplication.run(ProjectApplication.class, args);
	}
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
package thkoeln.archilab.ecommerce;

public class ShopException extends RuntimeException {
    public ShopException( String message ) {
        super( message );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientRegistrationService.java ---
package thkoeln.archilab.ecommerce.solution.client.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;

import java.util.ArrayList;
import java.util.List;

@Service
public class ClientRegistrationService implements ClientRegistrationUseCases {

    private final ClientRepository clientRepository;
    List<Email> registeredMails = new ArrayList<>();

    @Autowired
    public ClientRegistrationService(@Lazy ClientRepository clientRepository) {
        this.clientRepository = clientRepository;
    }

    @Override
    public void register(String name, EmailType email, HomeAddressType homeAddress) {
        Client client = new Client();
        //Check if any of the Parameters is not valid else create client
        if (name == null || name.isEmpty()) {
            throw new ShopException("Name is missing or Null");
        }
        if (homeAddress == null) {
            throw new ShopException("HomeAddress of client can not be null");
        }
        if (email == null) {
            throw new ShopException("Email is missing or Null");
        } else if (clientRepository.findByEmail((Email) email) == null) {
            client.setEmail((Email) email);
            registeredMails.add((Email) email);
        } else {
            throw new ShopException("Email is in Use");
        }

        client.setName(name);
        client.setAddress((Address) homeAddress);
        clientRepository.save(client);
    }


    @Override
    public void changeAddress(EmailType clientEmail, HomeAddressType homeAddress) {
        for (Client client : clientRepository.findAll()) {
            if (client.getEmail().equals(clientEmail) && homeAddress != null) {
                Address newAddress = (Address) homeAddress;
                client.setAddress(newAddress);
                return;
            }
        }
        throw new ShopException("Can not change Address for non existing Email");
    }

    @Override
    public ClientType getClientData(EmailType clientEmail) {
        for (Client client : clientRepository.findAll()) {
            if (client.getEmail().equals(clientEmail)) {
                return client;//TODO cannot be cast to class ClientType????
            }
        }
        throw new ShopException("There is no client in the system with this email. NO DATA!");
    }

    @Override
    public void deleteAllClients() {
        clientRepository.deleteAll();
        registeredMails.clear();
    }

    public Client findByEmail(Email email){
        return clientRepository.findByEmail(email);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\Client.java ---
package thkoeln.archilab.ecommerce.solution.client.domain;

import lombok.*;
import org.dom4j.tree.AbstractEntity;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;

import javax.persistence.*;
import java.util.UUID;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
public class Client extends AbstractEntity implements ClientType {
    @Id
    @Setter(AccessLevel.NONE)
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID clientId = UUID.randomUUID();

    private String name;

    @Embedded
    private Email email;

    @Embedded
    private Address address;

    public EmailType getEmail() {
        return email;
    }

    @Override
    public HomeAddressType getHomeAddress() {
        return address;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\ClientRepository.java ---
package thkoeln.archilab.ecommerce.solution.client.domain;


import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.domainprimitives.Email;

import java.util.UUID;

@Repository
public interface ClientRepository extends CrudRepository<Client, UUID> {
    @Query("SELECT c FROM Client c WHERE c.email = :email")
    Client findByEmail(Email email);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\DeliveryRecipientClient.java ---
package thkoeln.archilab.ecommerce.solution.client.domain;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.Address;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;

import javax.persistence.Entity;

@Entity
@Getter
@Setter
@NoArgsConstructor
public class DeliveryRecipientClient extends Client implements ClientType {

    public static DeliveryRecipientClient create(ClientType deliveryRecipient) {
        DeliveryRecipientClient deliveryRecipientClient = new DeliveryRecipientClient();
        deliveryRecipientClient.setName(deliveryRecipient.getName());
        Address address = new Address(
                deliveryRecipient.getHomeAddress().getPostalCode(),
                deliveryRecipient.getHomeAddress().getCity(),
                deliveryRecipient.getHomeAddress().getStreet()
        );
        deliveryRecipientClient.setAddress(address);
        return deliveryRecipientClient;
    }

    @Override
    public EmailType getEmail() {
        return super.getEmail();
    }

    @Override
    public HomeAddressType getHomeAddress() {
        return super.getAddress();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\DeliveryRecipientClientRepository.java ---
package thkoeln.archilab.ecommerce.solution.client.domain;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import thkoeln.archilab.ecommerce.domainprimitives.Email;

import java.util.UUID;

public interface DeliveryRecipientClientRepository extends CrudRepository<DeliveryRecipientClient, UUID> {
    @Query("SELECT d FROM DeliveryRecipientClient d WHERE d.email = :email")
    DeliveryRecipientClient findByEmail(Email email);

}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\application\DeliveryService.java ---
package thkoeln.archilab.ecommerce.solution.delivery.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.solution.client.domain.DeliveryRecipientClient;
import thkoeln.archilab.ecommerce.solution.client.domain.DeliveryRecipientClientRepository;
import thkoeln.archilab.ecommerce.solution.delivery.domain.Delivery;
import thkoeln.archilab.ecommerce.solution.delivery.domain.DeliveryRepository;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.DeliveryUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@Service
public class DeliveryService implements DeliveryUseCases {

    private final DeliveryRepository deliveryRepository;

    private final DeliveryRecipientClientRepository deliveryRecipientClientRepository;

    @Autowired
    public DeliveryService(
            @Lazy DeliveryRepository deliveryRepository,
            @Lazy DeliveryRecipientClientRepository deliveryRecipientClientRepository
    ) {
        this.deliveryRepository = deliveryRepository;
        this.deliveryRecipientClientRepository = deliveryRecipientClientRepository;
    }

    public void checkDeliveryQuantity(DeliveryRecipientClient deliveryRecipientClient, Map<UUID, Integer> deliveryContent) {
        int totalDeliveryQuantity = deliveryRepository.findAllByClientEmail((Email) deliveryRecipientClient.getEmail()).stream()
                .flatMap(delivery -> delivery.getGoods().values().stream())
                .reduce(0, Integer::sum);

        totalDeliveryQuantity += deliveryContent.values().stream().reduce(0, Integer::sum);

        if (totalDeliveryQuantity >= 21) {
            throw new ShopException("Delivery of Client exceeds maximum quantity of 21 items");
        }
    }

    private DeliveryRecipientClient createDeliveryRecipientClient(ClientType deliveryRecipient) {
        DeliveryRecipientClient deliveryRecipientClient;
        if (deliveryRecipientClientRepository.findByEmail((Email) deliveryRecipient.getEmail()) == null) {
            deliveryRecipientClient = DeliveryRecipientClient.create(deliveryRecipient);
            deliveryRecipientClientRepository.save(deliveryRecipientClient);
        } else {
            deliveryRecipientClient = deliveryRecipientClientRepository.findByEmail((Email) deliveryRecipient.getEmail());
        }
        return deliveryRecipientClient;
    }

    private void validateDeliveryRecipient(ClientType deliveryRecipient) {
        if (deliveryRecipient == null) {
            throw new ShopException("DeliveryRecipient email is missing");
        }
        if (deliveryRecipient.getName() == null || deliveryRecipient.getName().isEmpty()) {
            throw new ShopException("DeliveryRecipient name is missing");
        }
    }

    private void validateDeliverRecipientEmail(EmailType clientEmail) {
        if (clientEmail == null) {
            throw new ShopException("Client email is null or empty");
        }
    }

    @Override
    public UUID triggerDelivery(ClientType deliveryRecipient, Map<UUID, Integer> deliveryContent) {
        validateDeliveryRecipient(deliveryRecipient);
        //Create delivery if not exists
        DeliveryRecipientClient deliveryRecipientClient = createDeliveryRecipientClient(deliveryRecipient);
        checkDeliveryQuantity(deliveryRecipientClient, deliveryContent);
        Delivery delivery = new Delivery();
        delivery.setEmail((Email) deliveryRecipient.getEmail());
        delivery.setGoods(deliveryContent);
        deliveryRepository.save(delivery);
        return delivery.getDeliveryId();
    }

    @Override
    public Map<UUID, Integer> getDeliveryHistory(EmailType clientEmail) {
        validateDeliverRecipientEmail(clientEmail);
        Map<UUID, Integer> deliveryHistory = new HashMap<>();
        List<Delivery> deliveries = deliveryRepository.findAllByClientEmail((Email) clientEmail);
        for (Delivery delivery : deliveries) {
            Map<UUID, Integer> goods = delivery.getGoods();
            for (Map.Entry<UUID, Integer> entry : goods.entrySet()) {
                UUID goodId = entry.getKey();
                int quantity = entry.getValue();
                if (deliveryHistory.containsKey(goodId)) {
                    quantity += deliveryHistory.get(goodId);
                }
                deliveryHistory.put(goodId, quantity);
            }
        }
        return deliveryHistory;
    }

    @Override
    public void deleteDeliveryHistory() {
        deliveryRepository.deleteAll();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\Delivery.java ---
package thkoeln.archilab.ecommerce.solution.delivery.domain;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.dom4j.tree.AbstractEntity;
import thkoeln.archilab.ecommerce.domainprimitives.Email;

import javax.persistence.*;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Entity
@Getter
@Setter
@NoArgsConstructor
public class Delivery extends AbstractEntity {
    @Id
    @Setter(AccessLevel.NONE)
    @Column(name = "delivery_id", nullable = false)
    private UUID deliveryId = UUID.randomUUID();

    @Embedded
    private Email email;

    @ElementCollection
    @CollectionTable(name = "good_Delivery", joinColumns = {@JoinColumn(name = "deliveryId")})
    @MapKeyColumn(name = "good")
    @Column(name = "delivery")
    private Map<UUID, Integer> goods = new HashMap<>();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\DeliveryRepository.java ---
package thkoeln.archilab.ecommerce.solution.delivery.domain;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import thkoeln.archilab.ecommerce.domainprimitives.Email;

import java.util.List;
import java.util.UUID;

public interface DeliveryRepository extends CrudRepository<Delivery, UUID> {
    @Query("SELECT d FROM Delivery d WHERE d.email = :email")
    List<Delivery> findAllByClientEmail(Email email);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\application\GoodBuyableInterface.java ---
package thkoeln.archilab.ecommerce.solution.good.application;

import thkoeln.archilab.ecommerce.solution.good.domain.Good;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;

public interface GoodBuyableInterface {

    boolean goodNotExists(UUID goodId);

    Good getGoodByGoodId(UUID goodId);

    MoneyType getSalesPrice(UUID goodId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\application\GoodCatalogService.java ---
package thkoeln.archilab.ecommerce.solution.good.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.solution.good.domain.*;
import thkoeln.archilab.ecommerce.usecases.GoodCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.*;


@Service
public class GoodCatalogService implements GoodCatalogUseCases {

    private final CatalogRepository catalogRepository;

    private final GoodRepository goodRepository;

    private final WarehouseRepository warehouseRepository;

    @Autowired
    private GoodCatalogService(@Lazy CatalogRepository catalogRepository, @Lazy GoodRepository goodRepository, @Lazy WarehouseRepository warehouseRepository) {
        this.catalogRepository = catalogRepository;
        this.goodRepository = goodRepository;
        this.warehouseRepository = warehouseRepository;
    }

    @Override
    public void addGoodToCatalog(UUID goodId, String name, String description, Float size, MoneyType purchasePrice, MoneyType salesPrice) {
        validateGoodInformation(goodId, name, description, size, purchasePrice, salesPrice);
        Catalog catalog;
        Warehouse warehouse;
        List<Good> goodList = new ArrayList<>();

        if (warehouseRepository.count() == 0) {
            warehouse = new Warehouse();
            warehouseRepository.save(warehouse);
        } else {
            warehouse = warehouseRepository.findFirstByOrderByWarehouseIdAsc();
        }

        Good newGood = new Good(goodId, name, description, size, purchasePrice, salesPrice);
        newGood.setWarehouse(warehouse);
        goodRepository.save(newGood);
        //List<Good> test = goodRepository.findAll();
        if (catalogRepository.count() == 0) {
            catalog = new Catalog();
        } else {
            catalog = catalogRepository.findFirstByOrderByCatalogIdAsc();
            goodList = catalog.getGoods();
        }
        if (!goodList.contains(newGood)){
            goodList.add(newGood);
        }
        catalog.setGoods(goodList);
        catalogRepository.save(catalog);
        Map<UUID, Integer> goodIntegerMap = new HashMap<>();
        goodIntegerMap.put(newGood.getGoodId(), 0);
        warehouse.setGoods(goodIntegerMap);
        warehouseRepository.save(warehouse);

    }

    private void validateGoodInformation(UUID goodId, String name, String description, Float size, MoneyType purchasePrice, MoneyType salesPrice) {
        if (goodId == null) {
            throw new ShopException("GoodId is Null");
        }
        if (name == null || name.isEmpty()) {
            throw new ShopException("Good name is missing or Null");
        }
        if (description == null || description.isEmpty()) {
            throw new ShopException("Good description is missing or Null");
        }
        if (purchasePrice == null || purchasePrice.getAmount().isNaN()) {
            throw new ShopException("Good purchasePrice is missing or Null");
        }
        if (salesPrice == null || salesPrice.getAmount().isNaN() ) {
            throw new ShopException("Good salesPrice is missing or Null");
        }
     }

    @Override
    public void removeGoodFromCatalog(UUID goodId) {
        Good good = goodRepository.findById(goodId).orElseThrow(() -> new ShopException("The good id does not exist"));
        boolean goodInStock = warehouseRepository.findFirstByOrderByWarehouseIdAsc().getGoods().containsKey(good.getGoodId());
        if (goodInStock) {
            throw new ShopException("Good is still in Stock!");
        }
        warehouseRepository.findFirstByOrderByWarehouseIdAsc().getGoods().keySet().remove(good.getGoodId());
        goodRepository.deleteById(goodId);
    }

    @Override
    public MoneyType getSalesPrice(UUID goodId) {
        Good good = goodRepository.findById(goodId).orElseThrow(() -> new ShopException("There is no good with the given goodId"));
        return good.getSalesPrice();
    }

    @Override
    public void deleteGoodCatalog() {
        if (goodRepository.count() > 0) {
            goodRepository.deleteAll();
            catalogRepository.deleteAll();
        }
    }

    public boolean goodExists(UUID goodId) {
        for (Good good : goodRepository.findAll()) {
            if (good.getGoodId().equals(goodId)) {
                return true;
            }
        }
        return false;
    }

    public Good getGoodByGoodId(UUID goodId) {
        for (Good good : goodRepository.findAll()) {
            if (good.getGoodId().equals(goodId)) {
                return good;
            }
        }
        return null;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\application\ShoppingBasketreservableInterface.java ---
package thkoeln.archilab.ecommerce.solution.good.application;

import java.util.UUID;

public interface ShoppingBasketreservableInterface {
    int getAllReservedGoods(UUID goodId);

    void adjustReservedGoodInShoppingbaskets(UUID goodId, int warehouseQuantityRemoved, int currentlyReservedGoods);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\application\StockmanageableInterface.java ---
package thkoeln.archilab.ecommerce.solution.good.application;

import java.util.UUID;

public interface StockmanageableInterface {
    int getAvailableStock(UUID goodId);

    void checkGoodQuantityInWarehouse(UUID goodId, int quantity);

    void removeFromStock(UUID goodId, int quantity);

    void addToStock(UUID goodId, int quantity);

}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\application\StockManagementService.java ---
package thkoeln.archilab.ecommerce.solution.good.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.solution.good.domain.Warehouse;
import thkoeln.archilab.ecommerce.solution.good.domain.WarehouseRepository;
import thkoeln.archilab.ecommerce.usecases.StockManagementUseCases;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Service
public class StockManagementService implements StockManagementUseCases {

    private final ShoppingBasketreservableInterface shoppingBasketreservableInterface;
    @Autowired
    GoodCatalogService goodCatalogService;
    Warehouse warehouse = new Warehouse();
    @Autowired
    private WarehouseRepository warehouseRepository;

    private StockManagementService(WarehouseRepository warehouseRepository,
                                   ShoppingBasketreservableInterface shoppingBasketreservableInterface) {
        this.warehouseRepository = warehouseRepository;
        this.shoppingBasketreservableInterface = shoppingBasketreservableInterface;
    }


    @Override
    public void addToStock(UUID goodId, int addedQuantity) {
        if (addedQuantity == 0) {
            throw new ShopException("Can not add 0 to Stock!");
        }
        Map<UUID, Integer> goodIntegerMap = new HashMap<>();

        //Create Warehouse if there is no Warehouse
        if (warehouseRepository.count() == 0) {
            warehouse.setGoods(goodIntegerMap);
            warehouseRepository.save(warehouse);
        }
        warehouse = warehouseRepository.findFirstByOrderByWarehouseIdAsc();

        //Check if GoodId is valid if so add else throw Exception
        if (!goodCatalogService.goodExists(goodId) || addedQuantity < 0) {
            throw new ShopException("The good with goodId " + goodId + " does not exist");
        }
        addGood(goodId, addedQuantity);
    }

    public void addGood(UUID goodId, int quantity) {
        Map<UUID, Integer> stock = warehouse.getGoods();

        //Check if good already exists in Map
        if (warehouse.getGoods().containsKey(goodId)) {
            int currentQuantityOfGood = warehouse.getLagerbestand(goodId);
            currentQuantityOfGood += quantity;
            stock.put(goodId, currentQuantityOfGood);
        } else {
            stock.put(goodId, quantity);
        }
        warehouse.setGoods(stock);
        warehouseRepository.save(warehouse);
    }

    @Override
    public void removeFromStock(UUID goodId, int removedQuantity) {
        //Check if Good exists and removed quantity is not negative
        if (!goodCatalogService.goodExists(goodId)) {
            throw new ShopException("Good does not exist in Stock! not Valid Good");
        }
        if (removedQuantity <= 0) {
            throw new ShopException("RemovedQuantity: " + removedQuantity + " is not valid");
        }
        int totalQuantityOfGoodInWarehouse = warehouse.getLagerbestand(goodId);
        int warehouseQuantityRemoved = totalQuantityOfGoodInWarehouse - removedQuantity;

        int currentlyReservedGoods = shoppingBasketreservableInterface.getAllReservedGoods(goodId);

        //Mange clientbaskets and change quantity if must
        shoppingBasketreservableInterface.adjustReservedGoodInShoppingbaskets(goodId, warehouseQuantityRemoved, currentlyReservedGoods);
        if (warehouse.getLagerbestand(goodId) >= removedQuantity) {
            warehouse.getGoods().put(goodId, warehouseQuantityRemoved);
            warehouseRepository.save(warehouse);
        } else if (warehouse.getLagerbestand(goodId) == 0) {
            throw new ShopException("Warehouse has no more Stock of Good: " + goodId);
        } else {
            throw new ShopException("Can not remove: " + removedQuantity + " while having: " + totalQuantityOfGoodInWarehouse);
        }
    }

    @Override
    public void changeStockTo(UUID goodId, int newTotalQuantity) {
        //Check if Good exsist and removed qantity is not negative
        if (!goodCatalogService.goodExists(goodId)) {
            throw new ShopException("Good does not exist in Stock not Valid Good");
        }
        if (newTotalQuantity < 0) {
            throw new ShopException("NewTotalQuantity: " + newTotalQuantity + " is not valid");
        }

        int currentlyReservedGoods = shoppingBasketreservableInterface.getAllReservedGoods(goodId);
        shoppingBasketreservableInterface.adjustReservedGoodInShoppingbaskets(goodId, newTotalQuantity, currentlyReservedGoods);
        warehouse.getGoods().put(goodId, newTotalQuantity);
        warehouseRepository.save(warehouse);
    }

    @Override
    public int getAvailableStock(UUID goodId) {
        Integer quantity = warehouse.getLagerbestand(goodId);
        if (quantity == null) {
            throw new ShopException("Could not find Good in Stock");
        }
        return quantity;
    }
}

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\application\WarehouseGetableInterface.java ---
package thkoeln.archilab.ecommerce.solution.good.application;

import java.util.UUID;

public interface WarehouseGetableInterface {

    int getStorageOfGood(UUID goodId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\domain\Catalog.java ---
package thkoeln.archilab.ecommerce.solution.good.domain;

import lombok.*;
import org.dom4j.tree.AbstractEntity;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Catalog extends AbstractEntity {
    @Id
    @Setter(AccessLevel.NONE)
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID catalogId = UUID.randomUUID();

    @OneToMany(cascade = CascadeType.ALL)
    private List<Good> goods = new ArrayList<>();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\domain\CatalogRepository.java ---
package thkoeln.archilab.ecommerce.solution.good.domain;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.UUID;

@Repository
public interface CatalogRepository extends CrudRepository<Catalog, UUID> {
    Catalog findFirstByOrderByCatalogIdAsc();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\domain\Good.java ---
package thkoeln.archilab.ecommerce.solution.good.domain;


import lombok.*;
import org.dom4j.tree.AbstractEntity;
import org.springframework.lang.Nullable;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.delivery.domain.Delivery;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import javax.persistence.*;
import java.util.UUID;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Good extends AbstractEntity {
    @Id
    @Setter(AccessLevel.NONE)
    private UUID goodId = UUID.randomUUID();

    private String name;

    private String description;

    private Float size = 0.0f;

    @Embedded
    private Money purchasePrice;

    @Embedded
    private Money salesPrice;

    @ManyToOne(cascade = {CascadeType.MERGE})
    private Warehouse warehouse;

    public Good(UUID goodId, String name, String description, Float size,
                MoneyType purchasePrice, MoneyType salesPrice){
        this.goodId = goodId;
        this.name = name;
        this.description = description;
        this.size = size;
        this.purchasePrice = (Money) purchasePrice;
        this.salesPrice = (Money) salesPrice;
    }

    public Float getSalesPriceAmount() {
        return salesPrice.getAmount();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\domain\GoodRepository.java ---
package thkoeln.archilab.ecommerce.solution.good.domain;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.List;
import java.util.UUID;

@Repository
public interface GoodRepository extends CrudRepository<Good, UUID> {
    @Query("SELECT g FROM Good g WHERE g.goodId = :goodId")
    MoneyType findByGoodId(UUID goodId);

    List<Good> findAll();

    @Query("SELECT g FROM Good g WHERE g.goodId = :goodId")
    Good findGoodByGoodId(UUID goodId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\domain\Warehouse.java ---
package thkoeln.archilab.ecommerce.solution.good.domain;

import lombok.*;
import org.dom4j.tree.AbstractEntity;

import javax.persistence.*;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Warehouse extends AbstractEntity {
    @Id
    @Setter(AccessLevel.NONE)
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID warehouseId = UUID.randomUUID();

    @ElementCollection
    @CollectionTable(name = "good_quantity", joinColumns = {@JoinColumn(name = "warehouseId")})
    @MapKeyColumn(name = "good")
    @Column(name = "quantity")
    private Map<UUID, Integer> goods = new HashMap<>();

    public int getLagerbestand(UUID goodId) {
        return goods.getOrDefault(goodId, 0);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\domain\WarehouseRepository.java ---
package thkoeln.archilab.ecommerce.solution.good.domain;


import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.UUID;

@Repository
public interface WarehouseRepository extends CrudRepository<Warehouse, UUID> {
    Warehouse findFirstByOrderByWarehouseIdAsc();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderDTO.java ---
package thkoeln.archilab.ecommerce.solution.order.application;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;
import thkoeln.archilab.ecommerce.solution.orderPosition.application.OrderPositionDTO;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class OrderDTO {
    private UUID orderId;
    private Client client;
    private EmailType email;
    private Money price;
    private LocalDateTime submissionDate;
    private List<OrderPositionDTO> orderPositions = new ArrayList<>();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderDTOMapperService.java ---
package thkoeln.archilab.ecommerce.solution.order.application;

import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.solution.orderPosition.application.OrderPostionDTOMapperService;
import thkoeln.archilab.ecommerce.solution.orderPosition.domain.OrderPosition;

import java.time.LocalDateTime;

@Service
public class OrderDTOMapperService {
    @Autowired
    OrderPostionDTOMapperService orderPostionDTOMapperService;

    ModelMapper modelMapper = new ModelMapper();

    public OrderDTO mapToDTO(Order order){
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(order.getOrderId());
        orderDTO.setClient(order.getClient());
        Money price = new Money(order.getTotalOrderPrice().getAmount(), order.getTotalOrderPrice().getCurrency());
        orderDTO.setPrice(price);
        orderDTO.setEmail(order.getClient().getEmail());
        for (OrderPosition orderPosition : order.getOrderPositions()) {
            orderDTO.getOrderPositions().add(orderPostionDTOMapperService.mapToDTO(orderPosition));
        }
        orderDTO.setSubmissionDate(LocalDateTime.now());
        return orderDTO;
    }

    public Order mapToEntity(OrderDTO orderDTO) {
        Order order = new Order(orderDTO.getOrderId(),
                orderDTO.getClient(),
                orderDTO.getPrice(),
                orderPostionDTOMapperService.mapListToEntity(orderDTO.getOrderPositions()));
        return order;
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderRESTController.java ---
package thkoeln.archilab.ecommerce.solution.order.application;

import lombok.AllArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;

import javax.transaction.Transactional;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@RestController
@Transactional
public class OrderRESTController {

    @Autowired
    OrderService orderService;
    @Autowired
    OrderDTOMapperService orderDTOMapper;

    /*
    * (1) Find all orders for client with emailId, ordered by time	GET	/orders?email=...*/
    @GetMapping("/orders")
    public ResponseEntity<List<OrderDTO>> getOrdersByEmail(@RequestParam(value = "email", required = false) String email, @RequestParam(required = false) String filter ) {

        List<Order> orders = new ArrayList<>();
        List<OrderDTO> orderDTOs = new ArrayList<>();

        //check if email is valid
        if (email != null && Email.isValidFormat(email) ){
            orders = orderService.findAllByClientEmail(Email.of(email));
        } else if (email != null && !Email.isValidFormat(email) ){
            return new ResponseEntity(orderDTOs, HttpStatus.OK);
        }

        for (Order order: orders) {
           orderDTOs.add(orderDTOMapper.mapToDTO(order));
        }

        if ("latest".equals(filter)) {
            OrderDTO latestOrder = getLatestOrder(orderDTOs);
            List<OrderDTO> hier = new ArrayList<>();
            hier.add(latestOrder);
            return new ResponseEntity(hier, HttpStatus.OK);
        }

        // Return an empty array if no orders or an invalid filter is provided
        return new ResponseEntity(orderDTOs, HttpStatus.OK);
    }

    public OrderDTO getLatestOrder(List<OrderDTO> orderDTOs) {
        OrderDTO latestOrder = null;
        LocalDateTime latestDate = null;

        for (OrderDTO order : orderDTOs) {
            LocalDateTime submissionDate = order.getSubmissionDate();

            if (latestDate == null || submissionDate.isAfter(latestDate)) {
                latestDate = submissionDate;
                latestOrder = order;
            }
        }

        return latestOrder;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderService.java ---
package thkoeln.archilab.ecommerce.solution.order.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.List;

@Service
public class OrderService {

    private final OrderRepository orderRepository;
    private final ClientRepository clientRepository;

    @Autowired
    public OrderService(@Lazy OrderRepository orderRepository, @Lazy ClientRepository clientRepository) {
        this.orderRepository = orderRepository;
        this.clientRepository = clientRepository;
    }

    public List<Order> findAllByClientEmail(EmailType clientEmail){
        List<Order> allOrders = orderRepository.findAllByClientEmail(clientEmail);
        return allOrders;
    }
    public List<Order> findLatestForClient(EmailType clientEmail){
        List<Order> allOrders = orderRepository.findTopByClientEmailOrderByOrderIdAsc(clientEmail);
        return allOrders;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import org.dom4j.tree.AbstractEntity;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;
import thkoeln.archilab.ecommerce.solution.orderPosition.domain.OrderPosition;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "order_table")
public class Order extends AbstractEntity {
    @Id
    @Setter(AccessLevel.NONE)
    @GeneratedValue(strategy = GenerationType.AUTO)
    public UUID orderId = UUID.randomUUID();

    @ManyToOne(fetch = FetchType.LAZY)
    public Client client;

    @JsonProperty
    public Money totalOrderPrice;

    @OneToMany(cascade = CascadeType.ALL)
    public List<OrderPosition> orderPositions = new ArrayList<>();

    public Money getTotalOrderPrice() {
        // Check if the total order price is null and return a default value if necessary
        if (totalOrderPrice == null) {
            return new Money(0.0f, "EUR");
        }
        return totalOrderPrice;
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderRepository.java ---
package thkoeln.archilab.ecommerce.solution.order.domain;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.List;
import java.util.UUID;

@Repository
public interface OrderRepository extends CrudRepository<Order, UUID> {
    @Query("SELECT o FROM Order o WHERE o.client.clientId = :clientId")
    Order findByClientId(UUID clientId);

    @Query("SELECT o FROM Order o WHERE o.client.email = :email")
    Order findByClientEmail(EmailType email);

    @Query("SELECT o FROM Order o WHERE o.client.clientId = :clientId")
    List<Order> findAllByClientId(UUID clientId);

    @Query("SELECT o FROM Order o WHERE o.client.email = :email")
    List<Order> findAllByClientEmail(EmailType email);

    List<Order> findAllByClientEmailOrderByOrderId(EmailType email);

    List<Order> findTopByClientEmailOrderByOrderIdAsc(EmailType email);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\orderPosition\application\OrderPositionDTO.java ---
package thkoeln.archilab.ecommerce.solution.orderPosition.application;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.Money;

import java.util.Map;
import java.util.UUID;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class OrderPositionDTO {
    private UUID goodId;
    private Integer quantity;
    private Money totalAmount;
    private String comment;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\orderPosition\application\OrderPositionService.java ---
package thkoeln.archilab.ecommerce.solution.orderPosition.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.good.application.GoodCatalogService;
import thkoeln.archilab.ecommerce.solution.good.domain.GoodRepository;
import thkoeln.archilab.ecommerce.solution.orderPosition.domain.OrderPosition;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Service
public class OrderPositionService {

    @Autowired
    GoodCatalogService goodCatalogService;

    private final GoodRepository goodRepository;

    public OrderPositionService(GoodRepository goodRepository){
        this.goodRepository = goodRepository;
    }

    public OrderPosition createOrderPosition(UUID goodId, int quantity, String comment) {
        OrderPosition orderPosition = new OrderPosition();
        orderPosition.setComment(comment);
        Map<UUID, Integer> goods = new HashMap<>();
        goods.put(goodId, quantity);
        Float result = quantity * goodCatalogService.getSalesPrice(goodId).getAmount();
        Money totalPrice = new Money(result, "EUR");
        orderPosition.setTotalAmount(totalPrice);
        orderPosition.setGoods(goods);
        return orderPosition;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\orderPosition\application\OrderPostionDTOMapperService.java ---
package thkoeln.archilab.ecommerce.solution.orderPosition.application;

import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.orderPosition.domain.OrderPosition;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.application.ShoppingBasketPositionDTO;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.domain.ShoppingBasketPosition;

import java.util.*;

@Service
public class OrderPostionDTOMapperService {
    private ModelMapper modelMapper = new ModelMapper();

    public OrderPositionDTO mapToDTO(OrderPosition orderPosition){
        OrderPositionDTO orderPositionDTO = new OrderPositionDTO();
        orderPositionDTO.setGoodId(orderPosition.getGoods().entrySet().stream().findFirst().get().getKey());
        orderPositionDTO.setComment(orderPosition.getComment());
        orderPositionDTO.setQuantity(orderPosition.getGoods().entrySet().stream().findFirst().get().getValue());
        orderPositionDTO.setTotalAmount(orderPosition.getTotalAmount());
        return orderPositionDTO;
    }

    public OrderPosition mapToEntity(OrderPositionDTO orderPositionDTO) {
        Map<UUID, Integer> goods = new HashMap<>();
        goods.put(orderPositionDTO.getGoodId(), orderPositionDTO.getQuantity());
        OrderPosition orderPosition = new OrderPosition(
                orderPositionDTO.getGoodId(),
                orderPositionDTO.getTotalAmount(),
                orderPositionDTO.getComment(),
                goods
                );
        modelMapper.map(orderPositionDTO, orderPosition);
        return orderPosition;
    }


    public List<OrderPositionDTO> mapListToDTO(List<OrderPosition> orderPositions){
        if (orderPositions.size() == 0){
            return new ArrayList<>();
        }
        List<OrderPositionDTO> orderPositionDTOS = new ArrayList<>();
        for (OrderPosition orderPosition : orderPositions) {
            OrderPositionDTO orderPositionDTO = new OrderPositionDTO();
            orderPositionDTO.setGoodId(orderPosition.getGoods().entrySet().stream().findFirst().get().getKey());
            orderPositionDTO.setQuantity(orderPosition.getGoods().entrySet().stream().findFirst().get().getValue());
            orderPositionDTO.setComment(orderPosition.getComment());
            orderPositionDTO.setTotalAmount(orderPosition.getTotalAmount());
        }
        return orderPositionDTOS;
    }

    public List<OrderPosition> mapListToEntity(List<OrderPositionDTO> orderPositionDTOS){
        if (orderPositionDTOS.size() == 0){
            return new ArrayList<>();
        }
        List<OrderPosition> orderPositions = new ArrayList<>();
        for (OrderPositionDTO orderPositionDTO : orderPositionDTOS) {
            Map<UUID, Integer> goods = new HashMap<>();
            goods.put(orderPositionDTO.getGoodId(), orderPositionDTO.getQuantity());
            OrderPosition orderPosition = new OrderPosition(
                    orderPositionDTO.getGoodId(),
                    orderPositionDTO.getTotalAmount(),
                    orderPositionDTO.getComment(),
                    goods
                    );
            orderPositions.add(orderPosition);
        }
        return orderPositions;
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\orderPosition\domain\OrderPosition.java ---
package thkoeln.archilab.ecommerce.solution.orderPosition.domain;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import org.dom4j.tree.AbstractEntity;
import thkoeln.archilab.ecommerce.domainprimitives.Money;

import javax.persistence.*;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class OrderPosition extends AbstractEntity {
    @Id
    @Setter(AccessLevel.NONE)
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID orderPositionId = UUID.randomUUID();

    @JsonProperty
    private Money totalAmount;

    @JsonProperty
    private String comment;

    @ElementCollection
    @CollectionTable(name = "good_orderPosition", joinColumns = {@JoinColumn(name = "orderPositionId")})
    @MapKeyColumn(name = "good")
    @Column(name = "orderPosition")
    private Map<UUID, Integer> goods = new HashMap<>();

}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\orderPosition\domain\OrderPositionRepository.java ---
package thkoeln.archilab.ecommerce.solution.orderPosition.domain;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.List;
import java.util.UUID;

@Repository
public interface OrderPositionRepository extends CrudRepository<OrderPosition, UUID> {
    //@Query("SELECT op FROM OrderPosition op WHERE op.order.client.email = :email")
    //List<OrderPosition> findAllByOrderClientEmail(EmailType email);

}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\payment\application\AuthorizablePaymentService.java ---
package thkoeln.archilab.ecommerce.solution.payment.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.application.AuthorizablePaymentInterface;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

@Service
public class AuthorizablePaymentService implements AuthorizablePaymentInterface {
    @Autowired
    PaymentService paymentService;

    @Override
    public void authorizePayment(EmailType email, MoneyType cartValue) {
        paymentService.authorizePayment(email, cartValue);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\payment\application\PaymentService.java ---
package thkoeln.archilab.ecommerce.solution.payment.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
import thkoeln.archilab.ecommerce.solution.payment.domain.Payment;
import thkoeln.archilab.ecommerce.solution.payment.domain.PaymentRepository;
import thkoeln.archilab.ecommerce.usecases.PaymentUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;

@Service
public class PaymentService implements PaymentUseCases {

    private final ClientRepository clientRepository;

    private final PaymentRepository paymentRepository;

    @Autowired
    public PaymentService(
            @Lazy ClientRepository clientRepository,
            @Lazy PaymentRepository paymentRepository) {
        this.clientRepository = clientRepository;
        this.paymentRepository = paymentRepository;
    }

    @Override
    public UUID authorizePayment(EmailType clientEmail, MoneyType amount) {
        //Check all payment information
        if (clientEmail == null) {
            throw new ShopException("Client Email is invalid!");
        }
        if (clientRepository.findByEmail((Email) clientEmail) == null) {
            throw new ShopException("Client does not exist in our System!");
        }

        if (amount == null || amount.getAmount() <= 0.00f || amount.getAmount() > 500.00f) {
            throw new ShopException("Can not authorize payment. Invalid amount: " + amount);
        }

        //Create and save the Delivery
        Payment payment = new Payment();
        payment.setEmail((Email) clientEmail);
        payment.setAmount(amount.getAmount());
        paymentRepository.save(payment);
        return payment.getPaymentId();
    }

    @Override
    public MoneyType getPaymentTotal(EmailType clientEmail) {
        if (clientEmail == null) {
            throw new ShopException("Client Email is invalid!");
        }
        if (clientRepository.findByEmail((Email) clientEmail) == null) {
            throw new ShopException("Client does not exist in our System!");
        }
        Float totalAmount = 0.00f;
        for (Payment payment : paymentRepository.findAll()) {
            if (payment.getEmail().equals(clientEmail)) {
                totalAmount += payment.getAmount();
            }
        }
        return new Money(totalAmount, "EUR");
    }

    @Override
    public void deletePaymentHistory() {
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\payment\domain\Payment.java ---
package thkoeln.archilab.ecommerce.solution.payment.domain;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.dom4j.tree.AbstractEntity;
import thkoeln.archilab.ecommerce.domainprimitives.Email;

import javax.persistence.Column;
import javax.persistence.Embedded;
import javax.persistence.Entity;
import javax.persistence.Id;
import java.util.UUID;

@Entity
@Getter
@Setter
@NoArgsConstructor
public class Payment extends AbstractEntity {
    @Id
    @Setter(AccessLevel.NONE)
    @Column(name = "payment_id", nullable = false)
    private UUID paymentId = UUID.randomUUID();

    @Embedded
    private Email email;

    private Float amount;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\payment\domain\PaymentRepository.java ---
package thkoeln.archilab.ecommerce.solution.payment.domain;

import org.springframework.data.repository.CrudRepository;

import java.util.UUID;

public interface PaymentRepository extends CrudRepository<Payment, UUID> {
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\AuthorizablePaymentInterface.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

public interface AuthorizablePaymentInterface {
    void authorizePayment(EmailType email, MoneyType cartValue);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\GoodBuyableService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.good.application.GoodBuyableInterface;
import thkoeln.archilab.ecommerce.solution.good.application.GoodCatalogService;
import thkoeln.archilab.ecommerce.solution.good.domain.Good;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;

@Service
public class GoodBuyableService implements GoodBuyableInterface {

    @Autowired
    GoodCatalogService goodCatalogService;

    public boolean goodNotExists(UUID goodId) {
        return !goodCatalogService.goodExists(goodId);
    }

    @Override
    public Good getGoodByGoodId(UUID goodId) {
        return goodCatalogService.getGoodByGoodId(goodId);
    }


    public MoneyType getSalesPrice(UUID goodId) {
        return goodCatalogService.getSalesPrice(goodId);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingbasketDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.application.ShoppingBasketPositionDTO;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ShoppingbasketDTO {
    private UUID id;
    private Email email;
    private Integer totalQuantity;
    private Money totalPrice;
    private List<ShoppingBasketPositionDTO> orderPositions = new ArrayList<>();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingbasketDTOMapperService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.solution.client.application.ClientRegistrationService;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.domain.ShoppingBasketPosition;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.application.ShoppingBasketPositionDTOMapperService;

@Service
public class ShoppingbasketDTOMapperService {

    @Autowired
    ClientRegistrationService clientRegistrationService;
    @Autowired
    ShoppingBasketService shoppingBasketService;
    @Autowired
    public ShoppingBasketPositionDTOMapperService shoppingBasketPositionDTOMapper;

    public ShoppingbasketDTO mapToDTO(ShoppingBasket shoppingBasket){
        ShoppingbasketDTO shoppingbasketDTO = new ShoppingbasketDTO();
        shoppingbasketDTO.setId(shoppingBasket.getShoppingBasketId());
        shoppingbasketDTO.setEmail((Email) shoppingBasket.getClient().getEmail());
        shoppingbasketDTO.setTotalQuantity(shoppingBasket.getTotalAmount());
        shoppingbasketDTO.setTotalPrice(shoppingBasket.getTotalCost());
        for (ShoppingBasketPosition shoppingBasketPosition : shoppingBasket.getShoppingBasketPositions()) {
            shoppingbasketDTO.getOrderPositions().add(shoppingBasketPositionDTOMapper.mapToDTO(shoppingBasketPosition));
        }
        return shoppingbasketDTO;
    }

    public ShoppingBasket mapToEntity(ShoppingbasketDTO shoppingbasketDTO) {
        ShoppingBasket shoppingBasket = new ShoppingBasket(
                shoppingbasketDTO.getId(),
                clientRegistrationService.findByEmail(shoppingbasketDTO.getEmail()),
                shoppingbasketDTO.getTotalQuantity(),
                shoppingbasketDTO.getTotalPrice(),
                shoppingBasketPositionDTOMapper.mapListToEntity(shoppingbasketDTO.getOrderPositions())
        );
        return shoppingBasket;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketHelperClassCleanCodeService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
import thkoeln.archilab.ecommerce.solution.good.application.GoodBuyableInterface;
import thkoeln.archilab.ecommerce.solution.good.application.StockmanageableInterface;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.solution.orderPosition.domain.OrderPosition;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.application.ShoppingBasketPositionableInterface;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.domain.ShoppingBasketPosition;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.CheckOutState;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Service
public class ShoppingBasketHelperClassCleanCodeService {

    private final ClientRepository clientRepository;
    private final ShoppingBasketRepository shoppingBasketRepository;
    private final StockmanageableInterface stockmanageableInterface;
    private final ShoppingBasketPositionableInterface shoppingBasketPositionableInterface;
    private final GoodBuyableInterface goodBuyableInterface;



    public ShoppingBasketHelperClassCleanCodeService(ClientRepository clientRepository, ShoppingBasketRepository shoppingBasketRepository, StockmanageableInterface stockmanageableInterface, ShoppingBasketPositionableInterface shoppingBasketPositionableInterface, GoodBuyableInterface goodBuyableInterface) {
        this.clientRepository = clientRepository;
        this.shoppingBasketRepository = shoppingBasketRepository;
        this.stockmanageableInterface = stockmanageableInterface;
        this.shoppingBasketPositionableInterface = shoppingBasketPositionableInterface;
        this.goodBuyableInterface = goodBuyableInterface;
    }


    public ShoppingBasket createShoppingBasket(Client client) {
        ShoppingBasket shoppingBasket = new ShoppingBasket();
        List<ShoppingBasketPosition> shoppingBasketPositions = new ArrayList<>();
        //Check if client has a Basket, if so use existing Basket else create a new Basket
        if (shoppingBasketRepository.findByClientId(client.getClientId()) == null) {
            shoppingBasket.setClient(client);
            shoppingBasket.setTotalQuantity(0);
            shoppingBasket.setTotalCost(new Money(0.0f, "EUR"));
            shoppingBasket.setShoppingBasketPositions(shoppingBasketPositions);
            shoppingBasket.setState(CheckOutState.UNDEFINED_EMPTY);
            shoppingBasketRepository.save(shoppingBasket);
            clientRepository.save(client);
        }
        return shoppingBasket;
    }

    public void addToShoppingBasket(EmailType email, UUID goodId, int quantity) {
        ShoppingBasket shoppingBasket = shoppingBasketRepository.findByEmail(email);
        List<ShoppingBasketPosition> shoppingBasketPositions = shoppingBasket.getShoppingBasketPositions();
        ShoppingBasketPosition shoppingBasketPosition = null;

        for (ShoppingBasketPosition position : shoppingBasketPositions) {
            if (position.getGood().getGoodId().equals(goodId)) {
                shoppingBasketPosition = position;
                break;
            }
        }
        int availableStock = stockmanageableInterface.getAvailableStock(goodId);
        int newQuantity = quantity;
        if (shoppingBasketPosition != null) {
            newQuantity += shoppingBasketPosition.getQuantity();
        }
        if (shoppingBasketPosition == null) {
            shoppingBasketPosition = shoppingBasketPositionableInterface.createShoppingBasketPosition(goodBuyableInterface.getGoodByGoodId(goodId), newQuantity, null);
            shoppingBasketPositions.add(shoppingBasketPosition);
        } else {
            shoppingBasketPosition.setQuantity(newQuantity);
        }

        shoppingBasket.setShoppingBasketPositions(shoppingBasketPositions);

        // Berechnung des Gesamtpreises
        float f = 0.0f;
        for (ShoppingBasketPosition position : shoppingBasketPositions) {
            Float positionTotalPrice = position.getQuantity() * position.getGood().getSalesPrice().getAmount();
            f += positionTotalPrice;
        }
        Money totalPrice = new Money(f, "EUR");
        shoppingBasket.setTotalCost(totalPrice);
        shoppingBasket.setTotalQuantity(shoppingBasket.getTotalQuantity() + quantity);
        shoppingBasket.setState(CheckOutState.FILLED);
        shoppingBasketRepository.save(shoppingBasket);
    }

    public void removeGoodFromShoppingBasket(EmailType clientEmail, UUID goodId) {
        checkIfClientExsists((Email) clientEmail);
        if (goodBuyableInterface.goodNotExists(goodId) || stockmanageableInterface.getAvailableStock(goodId) < 0) {
            throw new ShopException("Con not remove nonexistent Good to clientShoppingBasket");
        }
        if (goodBuyableInterface.goodNotExists(goodId)) {
            throw new ShopException("Can not remove " + goodId + " good is not in basket");
        }

        Client client = clientRepository.findByEmail((Email) clientEmail);
        ShoppingBasket shoppingBasket = shoppingBasketRepository.findByClientId(client.getClientId());
        List<ShoppingBasketPosition> goodsFromBasket = shoppingBasket.getShoppingBasketPositions();
        boolean goodExists = false;
        for (ShoppingBasketPosition shoppingBasketPosition : goodsFromBasket) {
            if (shoppingBasketPosition.getGood().getGoodId().equals(goodId)) {
                goodExists = true;
                break;
            }
        }

        if (!goodExists) {
            throw new ShopException("Cannot remove Good which is not in clientShoppingBasket");
        }

        shoppingBasket.getShoppingBasketPositions().removeIf(shoppingBasketPosition -> shoppingBasketPosition.getGood().getGoodId().equals(goodId));

        // Update totalQuantity of the shopping basket
        int totalQuantity = shoppingBasket.getShoppingBasketPositions().stream()
                .mapToInt(ShoppingBasketPosition::getQuantity)
                .sum();
        shoppingBasket.setTotalQuantity(totalQuantity);
        shoppingBasketRepository.save(shoppingBasket);
    }


    public void checkIfClientExsists(Email clientEmail) {
        if (clientRepository.findByEmail(clientEmail) == null) {
            throw new ShopException("ShoppingBasket is empty or does not exist!");
        }
    }

    public void checkIfClientShoppingBasketExsists(EmailType clientEmail) {
        if (shoppingBasketRepository.findByEmail(clientEmail) == null) {
            throw new ShopException("ShoppingBasket is empty or does not exist!");
        }
    }

    public String getCommentForShoppingBasketPosition(ShoppingBasketPosition shoppingBasketPosition, UUID goodId, int quantity) {
        String comment = "";
        if (shoppingBasketPosition.getGood().getGoodId().equals(goodId) && shoppingBasketPosition.getQuantity().equals(quantity)){
            comment = shoppingBasketPosition.getComment();
        }
        return comment;
    }

    public void setShoppingBasketToInitalState(ShoppingBasket shoppingBasket) {
        shoppingBasket.setState(CheckOutState.UNDEFINED_EMPTY);
        shoppingBasket.getShoppingBasketPositions().clear();
        shoppingBasket.setTotalQuantity(0);
        shoppingBasketRepository.save(shoppingBasket);
    }

    public Order getOrCreateOrderForClientOrderPositions(Client client, List<OrderPosition> clientOrderPositions) {
        //Create a new Order for the Client
        Order order = new Order();
        order.setClient(client);
        order.setOrderPositions(clientOrderPositions);//27.06.23
        checkIfClientShoppingBasketExsists(client.getEmail());
        clientRepository.save(client);
        return order;
    }

    public int getGoodQuantityOfBasket(ShoppingBasket shoppingBasket) {
        int totalGoods = 0;
        for (ShoppingBasketPosition shoppingBasketPosition: shoppingBasket.getShoppingBasketPositions()) {
            totalGoods += shoppingBasketPosition.getQuantity();
        }
        return totalGoods;
    }

    public ShoppingBasket getShoppingBasketForMail(String email) {
        Email searchEmail = new Email(email);
        if (clientRepository.findByEmail(searchEmail) == null){
            return null;
        }
        if (clientRepository.findByEmail(searchEmail) != null && shoppingBasketRepository.findByEmail(searchEmail) == null ){
            ShoppingBasket shoppingbasket = createShoppingBasket(clientRepository.findByEmail(searchEmail));
            return shoppingBasketRepository.findByEmail(searchEmail);
        }
        return shoppingBasketRepository.findByEmail(searchEmail);
    }

    public ShoppingBasket saveShoppingBasket(ShoppingBasket shoppingBasket){
        return shoppingBasketRepository.save(shoppingBasket);
    }

    public ShoppingBasket getShoppingBasketById(UUID shoppingBasketId){
        return shoppingBasketRepository.findByShoppingBasketId(shoppingBasketId);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketPositionableService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.good.domain.Good;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.application.ShoppingBasketPositionService;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.application.ShoppingBasketPositionableInterface;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.domain.ShoppingBasketPosition;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;

import java.util.List;
import java.util.UUID;

@Service
public class ShoppingBasketPositionableService implements ShoppingBasketPositionableInterface {
    private final ShoppingBasketRepository shoppingBasketRepository;
    @Autowired
    ShoppingBasketPositionService shoppingBasketPositionService;

    public ShoppingBasketPositionableService(ShoppingBasketRepository shoppingBasketRepository) {
        this.shoppingBasketRepository = shoppingBasketRepository;
    }

    public ShoppingBasketPosition createShoppingBasketPosition(Good good, int quantity, String comment) {
        return shoppingBasketPositionService.createShoppingBasketPosition(good, quantity, comment);
    }

    @Override
    public List<ShoppingBasketPosition> getAllShoppingBasketPositionsForBasket(UUID shoppingBasketId) {
        return shoppingBasketRepository.findAllByShoppingBasketId(shoppingBasketId);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingbasketreservableService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.good.application.ShoppingBasketreservableInterface;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.domain.ShoppingBasketPosition;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@Service
public class ShoppingbasketreservableService implements ShoppingBasketreservableInterface {

    private final ShoppingBasketRepository shoppingBasketRepository;

    public ShoppingbasketreservableService(ShoppingBasketRepository shoppingBasketRepository) {
        this.shoppingBasketRepository = shoppingBasketRepository;
    }

    @Override
    public int getAllReservedGoods(UUID goodId) {
        Iterable<ShoppingBasket> shoppingBaskets = shoppingBasketRepository.findAll();
        int currentlyReservedGoods = 0;
        for (ShoppingBasket shoppingBasket : shoppingBaskets) {
            for (ShoppingBasketPosition shoppingBasketPosition: shoppingBasket.getShoppingBasketPositions()) {
                if (shoppingBasketPosition.getGood().getGoodId().equals(goodId)) {
                    currentlyReservedGoods += shoppingBasketPosition.getQuantity();
                }
            }
        }
        return currentlyReservedGoods;
    }

    @Override
    public void adjustReservedGoodInShoppingbaskets(UUID goodId, int warehouseQuantityRemoved, int currentlyReservedGoods) {
        Iterable<ShoppingBasket> shoppingBaskets = shoppingBasketRepository.findAll();
        int newAvailableQuantity = warehouseQuantityRemoved;
        if (warehouseQuantityRemoved < currentlyReservedGoods) {
            for (ShoppingBasket basket : shoppingBaskets) {
                List<ShoppingBasketPosition> goodsFromBasket = basket.getShoppingBasketPositions();
                for (ShoppingBasketPosition shoppingBasketPosition: goodsFromBasket) {
                    if (shoppingBasketPosition.getGood().getGoodId().equals(goodId)) {
                        int goodQuantityInBasket = shoppingBasketPosition.getQuantity();
                        if (newAvailableQuantity >= goodQuantityInBasket) {
                            newAvailableQuantity -= goodQuantityInBasket;
                            shoppingBasketPosition.setQuantity(goodQuantityInBasket);
                            //basket.setGoods(goodsFromBasket);
                            shoppingBasketRepository.save(basket);
                        } else {
                            shoppingBasketPosition.setQuantity(newAvailableQuantity);
                            //basket.setGoods(goodsFromBasket);
                            shoppingBasketRepository.save(basket);
                        }
                    }
                }
            }
        }
    }
}





--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketRESTController.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.good.application.GoodCatalogService;
import thkoeln.archilab.ecommerce.solution.good.domain.Good;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.application.ShoppingBasketPositionDTO;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.application.ShoppingBasketPositionDTOMapperService;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.application.ShoppingBasketPositionService;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;


import javax.transaction.Transactional;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@RestController
@Transactional
public class ShoppingBasketRESTController {

    @Autowired
    ShoppingBasketService shoppingBasketService;
    @Autowired
    ShoppingBasketHelperClassCleanCodeService shoppingBasketHelperClassCleanCode;
    @Autowired
    ShoppingBasketPositionService shoppingBasketPositionService;
    @Autowired
    GoodCatalogService goodCatalogService;
    @Autowired
    StockmanageableService stockmanageableService;
    @Autowired
    ShoppingbasketDTOMapperService shoppingbasketDTOMapper;
    @Autowired
    ShoppingBasketPositionDTOMapperService shoppingBasketPositionDTOMapperService;

    @GetMapping("/shoppingBaskets")
    public ResponseEntity<ShoppingbasketDTO> getShoppingBasketsByEmail(@RequestParam(name = "email", required = false) String email) {
        if (!Email.isValidFormat(email)) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
        ShoppingBasket shoppingBasket = shoppingBasketHelperClassCleanCode.getShoppingBasketForMail(email);
        if (shoppingBasket != null) {
            ShoppingbasketDTO shoppingbasketDTO = shoppingbasketDTOMapper.mapToDTO(shoppingBasket);
            return new ResponseEntity<>(shoppingbasketDTO, HttpStatus.OK);
        } else {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }


    @GetMapping("/shoppingBaskets/{shoppingBasketId}/shoppingBasketPositions/{goodId}")
    public ResponseEntity<ShoppingBasketPositionDTO> getShoppingBasketPosition(
            @PathVariable("shoppingBasketId") String shoppingBasketId,
            @PathVariable("goodId") String goodId) {

        if (shoppingBasketHelperClassCleanCode.getShoppingBasketById(UUID.fromString(shoppingBasketId)) == null) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }


        ShoppingbasketDTO shoppingBasket = shoppingbasketDTOMapper.mapToDTO(shoppingBasketHelperClassCleanCode.getShoppingBasketById(UUID.fromString(shoppingBasketId)));
        ShoppingBasketPositionDTO positionDTO = null;
        for (ShoppingBasketPositionDTO shoppingBasketPositionDTO : shoppingBasket.getOrderPositions()) {
            if (shoppingBasketPositionDTO.getGoodId().equals(UUID.fromString(goodId))) {
                positionDTO = shoppingBasketPositionDTO;
                break;
            }
        }
        if (positionDTO != null) {
            if (positionDTO.getQuantity() == 0) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
            }
            return new ResponseEntity<>(positionDTO, HttpStatus.OK);
        } else {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }

    @PostMapping("/shoppingBaskets/{shoppingBasketId}/shoppingBasketPositions")
    public ResponseEntity<ShoppingbasketDTO> addRemoveQuantityOfGoods(
            @PathVariable("shoppingBasketId") String shoppingBasketId,
            @RequestBody ShoppingBasketPositionDTO shoppingBasketPositionDTO) {
        ShoppingBasket shoppingBasket = shoppingBasketHelperClassCleanCode.getShoppingBasketById(UUID.fromString(shoppingBasketId));
        if (shoppingBasket == null) {// Überprüfen, ob der Einkaufswagen existiert
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
        Good good = goodCatalogService.getGoodByGoodId(shoppingBasketPositionDTO.getGoodId());
        if (good == null) {//Kontrolliere ob es das Good überhaupt gibt
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
        ShoppingbasketDTO shoppingBasketDTO = shoppingbasketDTOMapper.mapToDTO(shoppingBasket);
        List<ShoppingBasketPositionDTO> shoppingBasketPositionDTOS = shoppingBasketDTO.getOrderPositions();
        boolean found = false;
        // Durchsuchen der Liste der Einkaufswagenpositionen
        if (shoppingBasketPositionDTOS != null) {
            for (ShoppingBasketPositionDTO sho : shoppingBasketPositionDTOS) {
                if (sho.getGoodId().equals(good.getGoodId())) {
                    if(sho.getGoodId().equals(good.getGoodId()) && sho.getQuantity() + shoppingBasketPositionDTO.getQuantity() > stockmanageableService.getAvailableStock(good.getGoodId())  ){
                        return ResponseEntity.status(HttpStatus.CONFLICT).body(shoppingBasketDTO);
                    }
                    ResponseEntity<ShoppingbasketDTO> responseOrDTO = getShoppingbasketDTOResponseEntity(shoppingBasketPositionDTO, shoppingBasketDTO, sho, sho.getQuantity() + shoppingBasketPositionDTO.getQuantity());
                    if (responseOrDTO != null) return responseOrDTO;
                    found = true;
                    break;
                }
            }
        }
        if (!found && shoppingBasketPositionDTO.getQuantity() > 0) {// Position nicht gefunden und Menge ist größer als 0
            if (stockmanageableService.getAvailableStock(good.getGoodId()) < shoppingBasketPositionDTO.getQuantity()) {// Überprüfen, ob ausreichend Bestand verfügbar ist
                return ResponseEntity.status(HttpStatus.CONFLICT).body(shoppingBasketDTO);
            }
            ShoppingBasketPositionDTO newShoppingBasketPositionDTO = createNewShoppingBasketPositionDTO(shoppingBasketPositionDTO);
            if (shoppingBasketPositionDTOS == null) {
                shoppingBasketPositionDTOS = new ArrayList<>();
            }
            shoppingBasketPositionDTOS.add(newShoppingBasketPositionDTO);
        }
        float totalPrice = 0.0f;
        int totalQuantity = 0;
        for (ShoppingBasketPositionDTO basketPositionDTO : shoppingBasketDTO.getOrderPositions()) {
            totalPrice += basketPositionDTO.getQuantity() * getSalesPriceForPositionGood(basketPositionDTO);
            totalQuantity += basketPositionDTO.getQuantity();
        }
        shoppingBasketDTO.setTotalPrice(new Money(totalPrice, "EUR"));
        shoppingBasketDTO.setTotalQuantity(totalQuantity);
        shoppingBasketHelperClassCleanCode.saveShoppingBasket(shoppingbasketDTOMapper.mapToEntity(shoppingBasketDTO));
        return new ResponseEntity<>(shoppingBasketDTO, HttpStatus.CREATED);
    }


    @DeleteMapping("/shoppingBaskets/{shoppingBasketId}/shoppingBasketPositions/{goodId}")
    public ResponseEntity<String> deleteShoppingBasketPosition(
            @PathVariable("shoppingBasketId") String shoppingBasketId,
            @PathVariable("goodId") UUID goodId) {

        if (shoppingBasketHelperClassCleanCode.getShoppingBasketById(UUID.fromString(shoppingBasketId)) == null) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
        ShoppingBasket shoppingBasket = shoppingBasketHelperClassCleanCode.getShoppingBasketById(UUID.fromString(shoppingBasketId));
        // Überprüfen, ob das Produkt im Warenkorb vorhanden ist
        if (shoppingBasket.getShoppingBasketPositions().stream().noneMatch(shoppingBasketPosition -> shoppingBasketPosition.getGood().getGoodId().equals(goodId))) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Product not found in shopping basket");
        }
        shoppingBasketHelperClassCleanCode.removeGoodFromShoppingBasket(shoppingBasket.getClient().getEmail(),goodId);
        int test = shoppingBasket.getShoppingBasketQuantity(goodId);
        return new ResponseEntity(shoppingbasketDTOMapper.mapToDTO(shoppingBasket), HttpStatus.OK);
    }



    @PutMapping("/shoppingBaskets/{shoppingBasketId}/checkout")
    public ResponseEntity<String> checkoutShoppingBasket(@PathVariable("shoppingBasketId") String shoppingBasketId) {
        ShoppingBasket shoppingBasket = shoppingBasketHelperClassCleanCode.getShoppingBasketById(UUID.fromString(shoppingBasketId));

        //Überprüfen ob der Basket leer oder null ist
        if (shoppingBasket == null) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("ShoppingBasket does not exists!");
        } else if (shoppingBasket.getShoppingBasketPositions().isEmpty()) {
            return ResponseEntity.status(HttpStatus.CONFLICT).body("ShoppingBasket has no Positions to checkout");
        }

        // Überprüfen, ob der Gesamtbetrag das Zahlungslimit überschreitet
        if (!shoppingBasketService.isPaymentAuthorized(shoppingBasket.getClient().getEmail()) && shoppingBasket.getTotalQuantity() > 20) {
            return ResponseEntity.status(HttpStatus.CONFLICT).body("Der Warenkorb überschreitet das Zahlungslimit / Bestelllimit.");
        }

        ////////////

        if (shoppingBasket.getTotalCost().getAmount() > 500.0f) {
            return ResponseEntity.status(HttpStatus.CONFLICT).body("Der Warenkorb überschreitet das Zahlungslimit");
        } else {
            // return ResponseEntity.status(HttpStatus.CONFLICT).build();
        }
        //Wenn quantity von good == 0 dann löschen
        shoppingBasket.getShoppingBasketPositions().removeIf(position -> position.getQuantity() <= 0);
        ShoppingbasketDTO shoppingbasketDTO = shoppingbasketDTOMapper.mapToDTO(shoppingBasket);
        /////
        float totalCost = 0.0f;
        for (ShoppingBasketPositionDTO position: shoppingbasketDTO.getOrderPositions()) {
            totalCost += position.getQuantity() * goodCatalogService.getSalesPrice(position.getGoodId()).getAmount();
        }
        if (totalCost > 500) {
            return ResponseEntity.status(HttpStatus.CONFLICT).build();
        }
        shoppingBasketService.checkout(shoppingbasketDTO.getEmail());
        return new ResponseEntity(shoppingbasketDTO, HttpStatus.OK);
    }


    private float getSalesPriceForPositionGood(ShoppingBasketPositionDTO basketPositionDTO) {
        float salesPrice = goodCatalogService.getSalesPrice(basketPositionDTO.getGoodId()).getAmount();
        return salesPrice;
    }

    private ShoppingBasketPositionDTO createNewShoppingBasketPositionDTO(ShoppingBasketPositionDTO shoppingBasketPositionDTO) {
        ShoppingBasketPositionDTO newShoppingBasketPositionDTO = new ShoppingBasketPositionDTO(
                shoppingBasketPositionDTO.getGoodId(),
                shoppingBasketPositionDTO.getQuantity(),
                shoppingBasketPositionDTO.getComment());
        return newShoppingBasketPositionDTO;
    }

    private ResponseEntity<ShoppingbasketDTO> getShoppingbasketDTOResponseEntity(ShoppingBasketPositionDTO shoppingBasketPositionDTO, ShoppingbasketDTO shoppingBasketDTO, ShoppingBasketPositionDTO sho, int newQuantity) {
        if (newQuantity == 0) {// Neue Menge ist 0, die Position wird entfernt
            sho.setQuantity(0);
            sho.setComment(null);
        } else if (newQuantity < 0) {// Neue Menge ist negativ, es gibt einen Konflikt
            sho.setQuantity(0);
            sho.setComment(null);
            return ResponseEntity.status(HttpStatus.CONFLICT).body(shoppingBasketDTO);
        } else {// Neue Menge wird gesetzt und Kommentar aktualisiert
            sho.setQuantity(newQuantity);
            sho.setComment(shoppingBasketPositionDTO.getComment());
        }
        return null;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.domainprimitives.Email;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;
import thkoeln.archilab.ecommerce.solution.client.domain.ClientRepository;
import thkoeln.archilab.ecommerce.solution.good.application.GoodBuyableInterface;
import thkoeln.archilab.ecommerce.solution.good.application.StockmanageableInterface;
import thkoeln.archilab.ecommerce.solution.good.application.WarehouseGetableInterface;
import thkoeln.archilab.ecommerce.solution.order.domain.Order;
import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
import thkoeln.archilab.ecommerce.solution.orderPosition.application.OrderPositionService;
import thkoeln.archilab.ecommerce.solution.orderPosition.domain.OrderPosition;
import thkoeln.archilab.ecommerce.solution.orderPosition.domain.OrderPositionRepository;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.application.ShoppingBasketPositionableInterface;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.domain.ShoppingBasketPosition;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.CheckOutState;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.*;

@Service
public class ShoppingBasketService implements ShoppingBasketUseCases {
    private final ClientRepository clientRepository;
    private final ShoppingBasketRepository shoppingBasketRepository;
    private final OrderPositionRepository orderPositionRepository;
    private final OrderRepository orderRepository;
    private final StockmanageableInterface stockmanageableInterface;
    private final AuthorizablePaymentInterface authorizablePaymentInterface;
    private final GoodBuyableInterface goodBuyableInterface;
    private final WarehouseGetableInterface warehouseGetableInterface;
    private final ShoppingBasketPositionableInterface shoppingBasketPositionableInterface;
    @Autowired
    private OrderPositionService orderPositionService;
    @Autowired
    private ShoppingBasketHelperClassCleanCodeService shoppingBasketHelperClassCleanCode;

    @Autowired
    private ShoppingBasketService(@Lazy ClientRepository clientRepository,
                                  @Lazy ShoppingBasketRepository shoppingBasketRepository,
                                  @Lazy OrderRepository orderRepository,
                                  @Lazy OrderPositionRepository orderPositionRepository,
                                  StockmanageableInterface stockmanageableInterface,
                                  AuthorizablePaymentInterface authorizablePaymentInterface,
                                  GoodBuyableInterface goodBuyableInterface,
                                  WarehouseGetableInterface warehouseGetableInterface,
                                  ShoppingBasketPositionableInterface shoppingBasketPositionableInterface) {
        this.clientRepository = clientRepository;
        this.shoppingBasketRepository = shoppingBasketRepository;
        this.orderRepository = orderRepository;
        this.orderPositionRepository = orderPositionRepository;
        this.stockmanageableInterface = stockmanageableInterface;
        this.authorizablePaymentInterface = authorizablePaymentInterface;
        this.goodBuyableInterface = goodBuyableInterface;
        this.warehouseGetableInterface = warehouseGetableInterface;
        this.shoppingBasketPositionableInterface = shoppingBasketPositionableInterface;
    }

    @Override
    public void addGoodToShoppingBasket(EmailType clientEmail, UUID goodId, int quantity) {
        shoppingBasketHelperClassCleanCode.checkIfClientExsists((Email) clientEmail);
        if (goodBuyableInterface.goodNotExists(goodId) || stockmanageableInterface.getAvailableStock(goodId) < 0) {
            throw new ShopException("Can not add nonExisting Good to clientShoppingBasket");
        }
        if (stockmanageableInterface.getAvailableStock(goodId) == 0) {
            throw new ShopException("Good is outOfStock: " + stockmanageableInterface.getAvailableStock(goodId));
        }
        if (warehouseGetableInterface.getStorageOfGood(goodId) < quantity) {
            throw new ShopException("Can not add " + quantity + " of " + goodId + "to clientShoppingBasket, stock is to low");
        }
        if (quantity < 0) {
            throw new ShopException("Can not reserve " + quantity + "to ShoppingBasket");
        }
        //Get client and clientBasket
        Client client = clientRepository.findByEmail((Email) clientEmail);
        shoppingBasketHelperClassCleanCode.createShoppingBasket(client);

        if (goodBuyableInterface.getGoodByGoodId(goodId) == null) {
            throw new ShopException("The good with goodId " + goodId + " does not exist");
        }
        shoppingBasketHelperClassCleanCode.addToShoppingBasket(clientEmail, goodId, quantity);
    }

    @Override
    public void removeGoodFromShoppingBasket(EmailType clientEmail, UUID goodId, int quantity) {
        shoppingBasketHelperClassCleanCode.checkIfClientExsists((Email) clientEmail);
        if (goodBuyableInterface.goodNotExists(goodId) || stockmanageableInterface.getAvailableStock(goodId) < 0) {
            throw new ShopException("Con not add nonexistent Good to clientShoppingBasket");
        }
        if (goodBuyableInterface.goodNotExists(goodId) && stockmanageableInterface.getAvailableStock(goodId) < quantity) {
            throw new ShopException("Can not add " + quantity + " of " + goodId + " to clientShoppingBasket, stock is too low");
        }
        if (quantity < 0) {
            throw new ShopException("Can not reserve " + quantity + " to ShoppingBasket");
        }
        if (goodBuyableInterface.goodNotExists(goodId) || stockmanageableInterface.getAvailableStock(goodId) < 0) {
            throw new ShopException("Can not add nonexistent Good to clientShoppingBasket");
        }

        Client client = clientRepository.findByEmail((Email) clientEmail);
        ShoppingBasket shoppingBasket = shoppingBasketRepository.findByClientId(client.getClientId());
        List<ShoppingBasketPosition> goodsFromBasket = shoppingBasket.getShoppingBasketPositions();
        boolean goodExists = false;
        ShoppingBasketPosition lookingFor = null;
        for (ShoppingBasketPosition shoppingBasketPosition : goodsFromBasket) {
            if (shoppingBasketPosition.getGood().getGoodId().equals(goodId)) {
                goodExists = true;
                lookingFor = shoppingBasketPosition;
                break;
            }
        }

        if (!goodExists) {
            throw new ShopException("Cannot remove Good which is not in clientShoppingBasket");
        }

        // Check if Quantity of the Good is not < removedQuantity if so throw exception
        int updatedQuantity = 0;
        if (lookingFor.getGood().getGoodId().equals(goodId) && lookingFor.getQuantity() < quantity) {
            throw new ShopException("Can not remove " + quantity + " from good in basket having " + lookingFor.getQuantity() + " Reserved");
        }
        updatedQuantity = lookingFor.getQuantity() - quantity;
        lookingFor.setQuantity(updatedQuantity);
        for (ShoppingBasketPosition shoppingBasketPosition : goodsFromBasket) {
            if (shoppingBasketPosition.getGood().getGoodId().equals(goodId)) {
                shoppingBasketPosition.setQuantity(updatedQuantity);
            }
        }

        // Update totalQuantity of the shopping basket
        int totalQuantity = shoppingBasket.getShoppingBasketPositions().stream().mapToInt(ShoppingBasketPosition::getQuantity).sum();
        shoppingBasket.setTotalQuantity(totalQuantity);
        shoppingBasketRepository.save(shoppingBasket);
    }

    @Override
    public void setCommentForShoppingBasketPosition(EmailType clientEmail, UUID goodId, String comment) {
        validateClientEmail(clientEmail);
        validateGoodId(goodId);
        //check if good is in shoppingbasket else throw
        List<ShoppingBasketPosition> shoppingBasketPositions = shoppingBasketRepository.findByEmail(clientEmail).getShoppingBasketPositions();
        boolean found = false;
        for (ShoppingBasketPosition shoppingBasketPosition : shoppingBasketPositions) {
            if (shoppingBasketPosition.getGood().getGoodId().equals(goodId)) {
                shoppingBasketPosition.setComment(comment);
                found = true;
                break;
            }
        }
        if (!found) {
            throw new ShopException("There is no Good in the Basket");
        }
    }

    @Override
    public String getCommentForShoppingBasketPosition(EmailType clientEmail, UUID goodId) {
        validateClientEmail(clientEmail);
        validateGoodId(goodId);
        List<ShoppingBasketPosition> positions = shoppingBasketRepository.findByEmail(clientEmail).getShoppingBasketPositions();
        ShoppingBasketPosition matchingPosition = null;
        for (ShoppingBasketPosition shoppingBasketPosition : positions) {
            if (shoppingBasketPosition.getGood().getGoodId().equals(goodId)) {
                matchingPosition = shoppingBasketPosition;
                break;
            }
        }

        if (matchingPosition == null || !positions.contains(matchingPosition)) {
            throw new ShopException("There is no Good in the Basket or it was removed!");
        }
        return matchingPosition.getComment();
    }


    @Override
    public Map<UUID, Integer> getShoppingBasketAsMap(EmailType clientEmail) {
        ShoppingBasket shoppingBasket = shoppingBasketRepository.findByEmail(clientEmail);
        Map<UUID, Integer> basketAsMap = new HashMap<>();
        for (ShoppingBasketPosition shoppingBasketPosition:  shoppingBasket.getShoppingBasketPositions()) {
            basketAsMap.put(shoppingBasketPosition.getGood().getGoodId(), shoppingBasketPosition.getQuantity());
        }
        return basketAsMap;
    }

    private void validateClientEmail(EmailType clientEmail) {
        if (clientRepository.findByEmail((Email) clientEmail) == null) {
            throw new ShopException("ClientEmail / Client does not exist!");
        }
    }

    private void validateGoodId(UUID goodId) {
        if (goodId == null) {
            throw new ShopException("There is no Good with the goodId: "+ goodId);
        }
        if (goodBuyableInterface.goodNotExists(goodId)) {
            throw new ShopException("There is no Good with the given GoodId: "+ goodId);
        }
    }

    public MoneyType getCartValue(EmailType clientEmail) {
        validateClientEmail(clientEmail);
        ShoppingBasket shoppingBasket = shoppingBasketRepository.findByEmail(clientEmail);
        float totalAmountOfBasket = 0.0f;
        String currency = "EUR";
        for (ShoppingBasketPosition shoppingBasketPosition : shoppingBasket.getShoppingBasketPositions()) {
            UUID goodId = shoppingBasketPosition.getGood().getGoodId();
            Integer quantity = shoppingBasketPosition.getQuantity();
            MoneyType salesPriceOfGood = goodBuyableInterface.getSalesPrice(goodId);
            totalAmountOfBasket += quantity * salesPriceOfGood.getAmount();
            currency = salesPriceOfGood.getCurrency();
        }
        return new Money(totalAmountOfBasket, currency);
    }

    @Override
    public MoneyType getShoppingBasketAsMoneyValue(EmailType clientEmail) {
        //Check if client exists
        validateClientEmail(clientEmail);
        Client client = clientRepository.findByEmail((Email) clientEmail);
        ShoppingBasket shoppingBasket = shoppingBasketRepository.findByClientId(client.getClientId());
        List<ShoppingBasketPosition> goodsFromBasket = shoppingBasket.getShoppingBasketPositions();

        //Check if client shoppingBasket has goods
        if (shoppingBasket.getShoppingBasketPositions().isEmpty()) {
            throw new ShopException("Client has no Goods in shoppingBasket");
        }

        //Check if client has basket, if so use existing basket else create new one
        if (goodsFromBasket.isEmpty()) {
            shoppingBasket.setClient(client);
            Money initalCosts = new Money(0.0f, "EUR");
            shoppingBasket.setTotalCost(initalCosts);
            shoppingBasket.setShoppingBasketPositions(goodsFromBasket);
            shoppingBasketRepository.save(shoppingBasket);
            clientRepository.save(client);
        }

        goodsFromBasket = shoppingBasket.getShoppingBasketPositions();
        float sumOfBasket = 0.0f;
        String currency = "EUR";
        //foreach good in basket get salesPrice and sumOfBasket += g.salesPrice
        for (ShoppingBasketPosition shoppingBasketPosition : goodsFromBasket) {
            UUID goodId = shoppingBasketPosition.getGood().getGoodId();
            int quantity = shoppingBasketPosition.getQuantity();
            sumOfBasket += quantity * goodBuyableInterface.getSalesPrice(goodId).getAmount();
            currency = goodBuyableInterface.getSalesPrice(goodId).getCurrency();
        }
        return new Money(sumOfBasket, currency);
    }

    @Override
    public int getReservedStockInShoppingBaskets(UUID goodId) {
        validateGoodId(goodId);
        int quantityOfGood = 0;
        // calculate the quantity of the good in all shopping baskets
        for (ShoppingBasket shoppingBasket : shoppingBasketRepository.findAll()) {
            quantityOfGood += shoppingBasket.getShoppingBasketQuantity(goodId);
        }
        return quantityOfGood;
    }

    @Override
    public boolean isEmpty(EmailType clientEmail) {
        //Check if client exists
        validateClientEmail(clientEmail);
        ShoppingBasket shoppingBasket = shoppingBasketRepository.findByEmail(clientEmail);
        return shoppingBasket == null || shoppingBasket.getShoppingBasketPositions().isEmpty();
    }

    @Override
    public boolean isPaymentAuthorized(EmailType clientEmail) {
        //Check if client exists
        validateClientEmail(clientEmail);
        ShoppingBasket shoppingBasket = shoppingBasketRepository.findByEmail(clientEmail);
        return shoppingBasket != null && shoppingBasket.getState() == CheckOutState.PAYMENT_AUTHORIZED
                && getCartValue(clientEmail).getAmount() <= 500.0f;
    }

    @Override
    public void checkout(EmailType clientEmail) {
        validateClientEmail(clientEmail);
        shoppingBasketHelperClassCleanCode.checkIfClientExsists((Email) clientEmail);
        shoppingBasketHelperClassCleanCode.checkIfClientShoppingBasketExsists(clientEmail);
        if (shoppingBasketRepository.findByEmail(clientEmail).getState().equals(CheckOutState.FILLED)) {
            authorizablePaymentInterface.authorizePayment(clientEmail, getCartValue(clientEmail));
            shoppingBasketRepository.findByEmail(clientEmail).setState(CheckOutState.PAYMENT_AUTHORIZED);
        }
        if (shoppingBasketHelperClassCleanCode.getGoodQuantityOfBasket(shoppingBasketRepository.findByEmail(clientEmail)) <= 20) {
            shoppingBasketRepository.findByEmail(clientEmail).setState(CheckOutState.PAYMENT_AUTHORIZED);
        } else {
            throw new ShopException("Can not check out more than 20!");
        }
        ShoppingBasket shoppingBasket = shoppingBasketRepository.findByClientId(clientRepository.findByEmail((Email) clientEmail).getClientId());
        List<OrderPosition> clientOrderPositions = new ArrayList<>();
        Order order = shoppingBasketHelperClassCleanCode.getOrCreateOrderForClientOrderPositions(clientRepository.findByEmail((Email) clientEmail), clientOrderPositions);
        List<ShoppingBasketPosition> shoppingBasketPositions = shoppingBasket.getShoppingBasketPositions();
        if (shoppingBasketRepository.findByEmail(clientEmail).getState().equals(CheckOutState.PAYMENT_AUTHORIZED)) {
            shoppingBasket.getShoppingBasketPositions().removeIf(entry -> entry.getQuantity() == 0);
        }
        float total = 0.0f;
        for (ShoppingBasketPosition shoppingBasketPosition: shoppingBasketPositions) {
            UUID goodId = shoppingBasketPosition.getGood().getGoodId();
            int quantity = shoppingBasketPosition.getQuantity();
            stockmanageableInterface.checkGoodQuantityInWarehouse(goodId, quantity);
            String comment = shoppingBasketHelperClassCleanCode.getCommentForShoppingBasketPosition(shoppingBasketPosition, goodId, quantity);
            OrderPosition orderPosition = orderPositionService.createOrderPosition(goodId, quantity, comment );
            orderPositionRepository.save(orderPosition);
            order.getOrderPositions().add(orderPosition);
            total = order.getTotalOrderPrice().getAmount();
            for (OrderPosition position: order.getOrderPositions()) {
                total += position.getTotalAmount().getAmount();
            }
            stockmanageableInterface.removeFromStock(goodId, quantity);
        }
        Money totalOrderPrice = new Money(total,"EUR");
        order.setTotalOrderPrice(totalOrderPrice);
        orderRepository.save(order);
        clientRepository.save(clientRepository.findByEmail((Email) clientEmail));
        shoppingBasketHelperClassCleanCode.setShoppingBasketToInitalState(shoppingBasket);
    }

    @Override
    public Map<UUID, Integer> getOrderHistory(EmailType clientEmail) {
        validateClientEmail(clientEmail);
        Map<UUID, Integer> orderedGood = new HashMap<>();
        List<Order> ordersOfClient = orderRepository.findAllByClientEmail(clientEmail);
        List<OrderPosition> orderPositions = new ArrayList<>();
        for (Order order: ordersOfClient) {
            orderPositions.addAll(order.getOrderPositions());
        }
        for (OrderPosition orderPosition : orderPositions) {
            Map<UUID, Integer> temp = new HashMap<>(orderPosition.getGoods());
            //If the Good already exists, add the new quantity to it else add new Good with its quantity
            for (Map.Entry<UUID, Integer> goodInPosition : temp.entrySet()) {
                UUID goodId = goodInPosition.getKey();
                Integer quantity = goodInPosition.getValue();
                if (orderedGood.containsKey(goodId)) {
                    int oldVal = orderedGood.get(goodId);
                    orderedGood.put(goodId, oldVal + quantity);
                }
                orderedGood.put(goodId, quantity);
            }
        }
        return orderedGood;
    }

    @Override
    public void deleteAllOrders() {
        orderRepository.deleteAll();
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\StockmanageableService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.solution.good.application.StockManagementService;
import thkoeln.archilab.ecommerce.solution.good.application.StockmanageableInterface;
import thkoeln.archilab.ecommerce.solution.good.domain.WarehouseRepository;

import java.util.UUID;

@Service
public class StockmanageableService implements StockmanageableInterface {
    private final WarehouseRepository warehouseRepository;
    @Autowired
    private StockManagementService stockManagementService;

    public StockmanageableService(WarehouseRepository warehouseRepository) {
        this.warehouseRepository = warehouseRepository;
    }

    @Override
    public int getAvailableStock(UUID goodId) {
        Integer quantity = warehouseRepository.findFirstByOrderByWarehouseIdAsc().getLagerbestand(goodId);
        if (quantity == null) {
            throw new ShopException("Could not find Good in Stock");
        }
        return quantity;
    }

    @Override
    public void checkGoodQuantityInWarehouse(UUID goodId, int quantity) {
        int availableStock = getAvailableStock(goodId);
        if (availableStock < quantity) {
            throw new ShopException("Not enough stock available for good with id " + goodId);
        }
    }

    @Override
    public void removeFromStock(UUID goodId, int quantity) {
        stockManagementService.removeFromStock(goodId, quantity);
    }

    @Override
    public void addToStock(UUID goodId, int quantity) {
        stockManagementService.addToStock(goodId, quantity);
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\WarehouseGetableService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;

import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.good.application.WarehouseGetableInterface;
import thkoeln.archilab.ecommerce.solution.good.domain.WarehouseRepository;

import java.util.UUID;

@Service
public class WarehouseGetableService implements WarehouseGetableInterface {

    WarehouseRepository warehouseRepository;

    public WarehouseGetableService(WarehouseRepository warehouseRepository) {
        this.warehouseRepository = warehouseRepository;
    }

    @Override
    public int getStorageOfGood(UUID goodId) {
        return warehouseRepository.findFirstByOrderByWarehouseIdAsc().getLagerbestand(goodId);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\CheckOutState.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

public enum CheckOutState {
    UNDEFINED_EMPTY,
    FILLED,
    PAYMENT_AUTHORIZED,
    DELIVERY_TRIGGERED
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import org.dom4j.tree.AbstractEntity;
import thkoeln.archilab.ecommerce.domainprimitives.Money;
import thkoeln.archilab.ecommerce.solution.client.domain.Client;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.domain.ShoppingBasketPosition;

import javax.persistence.*;
import java.util.*;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ShoppingBasket extends AbstractEntity {
    @Id
    @Setter(AccessLevel.NONE)
    @GeneratedValue(strategy = GenerationType.AUTO)
    @JsonProperty
    private UUID shoppingBasketId = UUID.randomUUID();

    @JsonProperty
    private Integer totalQuantity = 0;

    @JsonProperty
    private Money totalCost;

    @OneToMany(cascade = CascadeType.ALL)
    public List<ShoppingBasketPosition> shoppingBasketPositions = new ArrayList<>();

    private CheckOutState state = CheckOutState.UNDEFINED_EMPTY;
    @OneToOne(cascade = CascadeType.ALL)
    private Client client;

    public ShoppingBasket(UUID shoppingBasketId, Client client, Integer totalCost,Money totalPrice, List<ShoppingBasketPosition> shoppingBasketPositions){
        this.shoppingBasketId = shoppingBasketId;
        this.client = client;
        this.totalQuantity = totalCost;
        this.totalCost = totalPrice;
        this.shoppingBasketPositions = shoppingBasketPositions;
    }

    public int getShoppingBasketQuantity(UUID goodId) {
        int quantity = 0;
        for (ShoppingBasketPosition sho: shoppingBasketPositions) {
            if (sho.getGood().getGoodId().equals(goodId)){
                quantity += sho.getQuantity();
            }
            return quantity;
        }
        return 0;
    }

    public int getTotalAmount() {
        int sum = 0;
        for (ShoppingBasketPosition shoppingBasketPosition: shoppingBasketPositions) {
            sum += shoppingBasketPosition.getQuantity();
        }
        return sum;
    }


}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketRepository.java ---
package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.domain.ShoppingBasketPosition;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.ArrayList;
import java.util.UUID;

@Repository
public interface ShoppingBasketRepository extends CrudRepository<ShoppingBasket, UUID> {
    @Query("SELECT b FROM ShoppingBasket b WHERE b.client.clientId = :clientId")
    ShoppingBasket findByClientId(UUID clientId);

    @Query("SELECT b FROM ShoppingBasket b WHERE b.client.email = :email")
    ShoppingBasket findByEmail(EmailType email);

    ShoppingBasket findByShoppingBasketId(UUID shoppingBasketId);

    @Query("SELECT sbp FROM ShoppingBasket sbp WHERE sbp.shoppingBasketId  = :shoppingbasketId")
    ArrayList<ShoppingBasketPosition> findAllByShoppingBasketId(UUID shoppingbasketId);

}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingBasketPosition\application\ShoppingBasketPositionableInterface.java ---
package thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.application;

import thkoeln.archilab.ecommerce.solution.good.domain.Good;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.domain.ShoppingBasketPosition;

import java.util.List;
import java.util.UUID;

public interface ShoppingBasketPositionableInterface {
    ShoppingBasketPosition createShoppingBasketPosition(Good good, int quantity, String comment);

    List<ShoppingBasketPosition> getAllShoppingBasketPositionsForBasket(UUID shoppingBasketId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingBasketPosition\application\ShoppingBasketPositionDTO.java ---
package thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.application;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.UUID;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ShoppingBasketPositionDTO {
    private UUID goodId;
    private Integer quantity;
    private String comment;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingBasketPosition\application\ShoppingBasketPositionDTOMapperService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.application;

import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.good.domain.GoodRepository;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.domain.ShoppingBasketPosition;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Service
public class ShoppingBasketPositionDTOMapperService {

    private final GoodRepository goodRepository;

    @Autowired
    ShoppingBasketPositionService shoppingBasketPositionService;

    private ShoppingBasketPositionDTOMapperService(GoodRepository goodRepository){
        this.goodRepository = goodRepository;
    }
    public ShoppingBasketPositionDTO mapToDTO(ShoppingBasketPosition shoppingBasketPosition){
        ShoppingBasketPositionDTO shoppingBasketPositionDTO = new ShoppingBasketPositionDTO();
        shoppingBasketPositionDTO.setQuantity(shoppingBasketPosition.getQuantity());
        shoppingBasketPositionDTO.setGoodId(shoppingBasketPosition.getGood().getGoodId());
        shoppingBasketPositionDTO.setComment(shoppingBasketPosition.getComment());
        return shoppingBasketPositionDTO;
    }

    public List<ShoppingBasketPositionDTO> mapListToDTO(List<ShoppingBasketPosition> shoppingBasketPositions){
        if (shoppingBasketPositions.size() == 0){
            return new ArrayList<>();
        }
        List<ShoppingBasketPositionDTO> shoppingBasketPositionDTOS = new ArrayList<>();
        for (ShoppingBasketPosition shoppingBasketPosition : shoppingBasketPositions) {
            ShoppingBasketPositionDTO shoppingBasketPositionDTO = new ShoppingBasketPositionDTO();
            shoppingBasketPositionDTO.setQuantity(shoppingBasketPosition.getQuantity());
            shoppingBasketPositionDTO.setGoodId(shoppingBasketPosition.getGood().getGoodId());
            shoppingBasketPositionDTO.setComment(shoppingBasketPosition.getComment());
            shoppingBasketPositionDTOS.add(shoppingBasketPositionDTO);
        }
        return shoppingBasketPositionDTOS;
    }

    public ShoppingBasketPosition mapToEntity(ShoppingBasketPositionDTO shoppingBasketPositionDTO){
        ShoppingBasketPosition shoppingBasketPosition = new ShoppingBasketPosition(
                UUID.randomUUID(),
                shoppingBasketPositionDTO.getQuantity(),
                shoppingBasketPositionDTO.getComment(),
                goodRepository.findGoodByGoodId(shoppingBasketPositionDTO.getGoodId()));
        return  shoppingBasketPosition;
    }

    public List<ShoppingBasketPosition> mapListToEntity(List<ShoppingBasketPositionDTO> shoppingBasketPositionDTOS){
        if (shoppingBasketPositionDTOS.size() == 0){
            return new ArrayList<>();
        }
        List<ShoppingBasketPosition> shoppingBasketPositions = new ArrayList<>();
        for (ShoppingBasketPositionDTO shoppingBasketPositionDTO : shoppingBasketPositionDTOS) {
            ShoppingBasketPosition shoppingBasketPosition = new ShoppingBasketPosition(
                    UUID.randomUUID(),
                    shoppingBasketPositionDTO.getQuantity(),
                    shoppingBasketPositionDTO.getComment(),
                    goodRepository.findGoodByGoodId(shoppingBasketPositionDTO.getGoodId()));
            shoppingBasketPositions.add(shoppingBasketPosition);
            shoppingBasketPositionService.safeShoppingbasketPosition(shoppingBasketPosition);
        }
        return shoppingBasketPositions;
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingBasketPosition\application\ShoppingBasketPositionService.java ---
package thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.application;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;
import thkoeln.archilab.ecommerce.solution.good.domain.Good;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.domain.ShoppingBasketPosition;
import thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.domain.ShoppingBasketPositionRepository;


@Service
public class ShoppingBasketPositionService {

    private final ShoppingBasketPositionRepository shoppingBasketPositionRepository;

    @Autowired
    public ShoppingBasketPositionService(@Lazy ShoppingBasketPositionRepository shoppingBasketPositionRepository) {
        this.shoppingBasketPositionRepository = shoppingBasketPositionRepository;
    }

    public ShoppingBasketPosition createShoppingBasketPosition(Good good, int quantity, String comment) {
        ShoppingBasketPosition shoppingBasketPosition = new ShoppingBasketPosition();
        shoppingBasketPosition.setGood(good);
        shoppingBasketPosition.setQuantity(quantity);
        shoppingBasketPosition.setComment(comment);
        shoppingBasketPositionRepository.save(shoppingBasketPosition);
        return shoppingBasketPosition;
    }

    public void safeShoppingbasketPosition(ShoppingBasketPosition shoppingBasketPosition){
        shoppingBasketPositionRepository.save(shoppingBasketPosition);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingBasketPosition\domain\ShoppingBasketPosition.java ---
package thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.domain;

import lombok.*;
import org.dom4j.tree.AbstractEntity;
import thkoeln.archilab.ecommerce.solution.good.domain.Good;

import javax.persistence.*;
import java.util.UUID;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ShoppingBasketPosition extends AbstractEntity {
    @Id
    @Setter(AccessLevel.NONE)
    private UUID shoppingBasketPositionId = UUID.randomUUID();

    private Integer quantity;

    private String comment;

    @ManyToOne(cascade = {CascadeType.MERGE})
    private Good good;
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingBasketPosition\domain\ShoppingBasketPositionRepository.java ---
package thkoeln.archilab.ecommerce.solution.shoppingBasketPosition.domain;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.UUID;

@Repository
public interface ShoppingBasketPositionRepository extends CrudRepository<ShoppingBasketPosition, UUID> {
    @Query("SELECT sp FROM ShoppingBasketPosition sp WHERE sp.good.goodId = :goodId")
    ShoppingBasketPosition findByGoodId(UUID goodId);
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\usecases\ClientRegistrationUseCases.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;

/**
 * This interface contains methods needed in the context of use cases dealing with registering a client.
 * The interface is probably incomplete, and will grow over time.
 */
public interface ClientRegistrationUseCases {
    /**
     * Registers a new client
     *
     * @param name
     * @param email
     * @param homeAddress
     * @throws ShopException if ...
     *      - name is null or empty
     *      - email is null
     *      - client with the given email already exists
     *      - homeAddress is null
     */
    public void register( String name, EmailType email, HomeAddressType homeAddress );


    /**
     * Changes the homeAddress of a client
     *
     * @param clientEmail
     * @param homeAddress
     * @throws ShopException if ...
     *      - email is null
     *      - client with the given email already exists
     *      - homeAddress is null
     */
    public void changeAddress( EmailType clientEmail, HomeAddressType homeAddress );


    /**
     * Returns the data of a client
     * @param clientEmail
     * @return the client data
     * @throws ShopException if ...
     *      - email is null
     *      - the client with the given email does not exist
     */
    public ClientType getClientData( EmailType clientEmail );



    /**
     * Deletes all clients, including all orders and shopping baskets
     */
    public void deleteAllClients();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\usecases\ClientType.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;

/**
 * This interface expresses the essence of a shop client
 */
public interface ClientType {
    public String getName();
    public EmailType getEmail();
    public HomeAddressType getHomeAddress();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\usecases\DeliveryUseCases.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import java.util.Map;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of use cases dealing with logistics,
 * i.e. the delivery of goods to a client. It is probably incomplete, and will grow over time.
 */
public interface DeliveryUseCases {
    /**
     * Delivers a good to a client. The good is identified by its id, and the client by
     * his/her name, street, city and postal code.
     * @param deliveryRecipient
     * @param deliveryContent - a map of good ids and quantities
     * @return the id of the delivery, if successfully triggered
     * @throws ShopException if ...
     *      - deliveryRecipient is null
     *      - any of the properties in deliveryRecipient (the getXxx(...) methods) return null or empty strings
     *      - deliveryContent is null or empty
     *      - the total number of goods in the delivery is > 20
     */
    public UUID triggerDelivery( ClientType deliveryRecipient, Map<UUID, Integer> deliveryContent );


    /**
     * Returns a map showing which goods have been delivered to a client, and how many of each good
     *
     * @param clientEmail
     * @return the delivery history of the client (map is empty if the client has not had any deliveries yet)
     * @throws ShopException if
     *      - email is null
     *      - the client with the given email does not exist
     */
    public Map<UUID, Integer> getDeliveryHistory( EmailType clientEmail );



    /**
     *  Deletes all delivery history.
     */
    public void deleteDeliveryHistory();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\EmailType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface EmailType {
    /**
     * @return the email as a string
     */
    public String toString();

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an email, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param emailAsString - the email as a string.
     *      We will use a much simplified validation method to check if the email is valid:
     *      - it must contain exactly one '@' character.
     *      - the part before the '@' and the part after the '@' must not be empty, contain of
     *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
     *      - the parts before and after the '@' may contain one or several '.' as separators
     *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
     *      - the part after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
     *        (for simplicity we do not allow any other domains)
     * @return a new EmailType object matching the given email
     * @throws ShopException if ...
     *      - emailAsString is null
     *      - emailAsString is not a valid email (see above)
     */
     // public static EmailType of( String emailAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\HomeAddressType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface HomeAddressType {
    /**
     * @return the street as a string
     */
    public String getStreet();

    /**
     * @return the city as a string
     */
    public String getCity();

    /**
     * @return the postal code
     */
    public PostalCodeType getPostalCode();

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an postal code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param street the street as a string
     * @param city the city as a string
     * @param postalCode the postal code
     * @return the homeAddress object matching the parameters
     * @throws ShopException if ...
     *      - street is null or empty
     *      - city is null or empty
     *      - postalCode is null
     */
     // public static HomeAddressType of( String street, String city, PostalCodeType postalCode );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MoneyType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface MoneyType {
    /**
     * @return the amount of money
     */
    public Float getAmount();


    /**
     * @return the currency of the money
     */
    public String getCurrency();


    /**
     * @param otherMoney
     * @return this + otherMoney, as a new object
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currency != this.currency
     */
    public MoneyType add( MoneyType otherMoney );


    /**
     * @param otherMoney
     * @return this - otherMoney, as a new object
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currency != this.currency
     *      - otherMoney > this
     */
    public MoneyType subtract( MoneyType otherMoney );


    /**
     * @param factor
     * @return this * factor, as a new object
     * @throws ShopException if ...
     *     - factor < 0
     */
    public MoneyType multiplyBy( int factor );

    /**
     * @param otherMoney
     * @return true, if this > otherMoney
     * @throws ShopException if ...
     *      - otherMoney is null
     *      - otherMoney.currency != this.currency
     */
    public boolean largerThan( MoneyType otherMoney );


    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates a money object from an amount and a currency (as string).
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param amount the amount of money (must be >= 0)
     * @param currency the currency of the money (allowed values: "EUR", "CHF")
     * @return a new Money object with the given amount and currency
     * @throws ShopException if ...
     *   - amount is null
     *   - amount < 0
     *   - currency is null
     *   - currency is not one of the allowed values
     */
     // public static MoneyType of( Float amount, String currency );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PostalCodeType.java ---
package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;

import thkoeln.archilab.ecommerce.ShopException;

public interface PostalCodeType {
    /**
     * @return the postal code as a string
     */
    public String toString();

    /**
     * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
     * implementing class to provide a static factory method (simply named "of(...)"),
     * which creates an postal code, given as a string.
     * We specify this factory method here as a comment, using the Javadoc documentation style.
     *
     * @param postalCodeAsString - the postal code as a string.
     *      We will use a much simplified validation method to check if the postal code is valid:
     *      - It must contain exactly 5 digits.
     *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid postal code, but 20001 is valid)
     * @return a new postal code object matching the given string
     * @throws ShopException if ...
     *      - postalCodeAsString is null
     *      - postalCodeAsString is not a valid postal code (see above)
     */
     // public static PostalCodeType of( String postalCodeAsString );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\usecases\GoodCatalogUseCases.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;


/**
 * This interface contains methods needed in the context of use cases dealing with managing the good catalog.
 * The interface is probably incomplete, and will grow over time.
 */

public interface GoodCatalogUseCases {
    /**
     * Adds a new good to the shop catalog
     * @param goodId
     * @param name
     * @param description
     * @param size
     * @param purchasePrice
     * @param salesPrice
     * @throws ShopException if ...
     *      - goodId is null,
     *      - the good with that id already exists,
     *      - name or description are null or empty,
     *      - the size is <= 0 (but can be null!),
     *      - the purchase price is null,
     *      - the sales price is null,
     *      - the sales price is lower than the purchase price
     */
    public void addGoodToCatalog( UUID goodId, String name, String description, Float size,
                                           MoneyType purchasePrice, MoneyType salesPrice );


    /**
     * Removes a good from the shop catalog
     * @param goodId
     * @throws ShopException if
     *      - goodId is null,
     *      - the good with that id does not exist
     *      - the good is still in stock
     *      - the good is still reserved in a shopping basket, or part of a completed order
     */
    public void removeGoodFromCatalog( UUID goodId );


    /**
     * Get the sales price of a given good
     * @param goodId
     * @return the sales price
     * @throws ShopException if ...
     *      - goodId is null,
     *      - the good with that id does not exist
     */
    public MoneyType getSalesPrice( UUID goodId );


    /**
     * Clears the good catalog, i.e. removes all goods from the catalog, including all the stock,
     * all the reservations and all the orders.
     */
    public void deleteGoodCatalog();

}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\usecases\PaymentUseCases.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.UUID;

/**
 * This interface contains methods needed in the context of use cases dealing with payments.
 */
public interface PaymentUseCases {

    /**
     * Authorizes a payment from a credit card for a given amount
     *
     * @param clientEmail
     * @param moneyAmount
     * @return the id of the payment, if successfully authorized
     * @throws ShopException if ...
     *      - clientEmail is null
     *      - the amount is null
     *      - the amount is 0.00 EUR
     *      - the payment cannot be processed, because it is over the limit of 500.00 EUR
     */
    public UUID authorizePayment( EmailType clientEmail, MoneyType moneyAmount );


    /**
     * Returns the total amount of payments (over the complete history) for a client
     * (identified by his/her email)
     *
     * @param clientEmail
     * @return the total amount of payments made using this credit card, or 0.00 EUR if there
     *         weren't any payments yet.
     * @throws ShopException if ...
     *      - clientEmail is null
     */
    public MoneyType getPaymentTotal( EmailType clientEmail );


    /**
     * Deletes all payment history, for all clients.
     */
    public void deletePaymentHistory();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingBasketUseCases.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.Map;
import java.util.UUID;

/**
 * This interface contains methods needed in the context of use cases dealing with the shopping basket.
 * The interface is probably incomplete, and will grow over time.
 */
public interface ShoppingBasketUseCases {
    /**
     * Adds a good to the shopping basket of a client
     *
     * @param clientEmail
     * @param goodId
     * @param quantity
     * @throws ShopException if ...
     *      - the client with the given email does not exist,
     *      - the good does not exist,
     *      - the quantity <= 0,
     *      - the good is not available in the requested quantity
     */
    public void addGoodToShoppingBasket( EmailType clientEmail, UUID goodId, int quantity );


    /**
     * Removes a good from the shopping basket of a client
     *
     * @param clientEmail
     * @param goodId
     * @param quantity
     * @throws ShopException if ...
     *      - clientEmail is null,
     *      - the client with the given email does not exist,
     *      - the good does not exist
     *      - the quantity <= 0,
     *      - the good is not in the shopping basket in the requested quantity
     */
    public void removeGoodFromShoppingBasket( EmailType clientEmail, UUID goodId, int quantity );


    /**
     * Sets a comment in the shopping basket position containing a good
     *
     * @param clientEmail
     * @param goodId
     * @param comment (can be null)
     * @throws ShopException if ...
     *      - clientEmail is null,
     *      - the client with the given email does not exist,
     *      - the good does not exist
     *      - the good is not in the shopping basket
     */
    public void setCommentForShoppingBasketPosition( EmailType clientEmail, UUID goodId, String comment );


    /**
     * Returns the comment in the shopping basket position containing a good
     *
     * @param clientEmail
     * @param goodId
     * @return the comment (can be null)
     * @throws ShopException if ...
     *      - clientEmail is null,
     *      - the client with the given email does not exist,
     *      - the good does not exist
     *      - the good is not in the shopping basket
     */
    public String getCommentForShoppingBasketPosition( EmailType clientEmail, UUID goodId );


    /**
     * Returns a map showing which goods are in the shopping basket of a client and how many of each good
     *
     * @param clientEmail
     * @return the shopping basket of the client (map is empty if the shopping basket is empty)
     * @throws ShopException if ...
     *      - clientEmail is null,
     *      - the client with the given email does not exist
     */
    public Map<UUID, Integer> getShoppingBasketAsMap( EmailType clientEmail );


    /**
     * Returns the current value of all goods in the shopping basket of a client
     *
     * @param clientEmail
     * @return the value of shopping basket of the client
     * @throws ShopException if ...
     *      - clientEmail is null,
     *      - the client with the given email does not exist
     */
    public MoneyType getShoppingBasketAsMoneyValue( EmailType clientEmail );



    /**
     * Get the number units of a specific good that are currently reserved in the shopping baskets of all clients
     * @param goodId
     * @return the number of reserved goods of that type in all shopping baskets
     * @throws ShopException
     *      - goodId is null
     *      - if the good id does not exist
     */
    public int getReservedStockInShoppingBaskets( UUID goodId );


    /**
     * Checks if the shopping basket of a client is empty
     *
     * @param clientEmail
     * @return true if the shopping basket is empty, false otherwise
     * @throws ShopException if ...
     *    - clientEmail is null
     *    - the client with the given email does not exist
     */
    public boolean isEmpty( EmailType clientEmail );


    /**
     * Checks if the payment for a specific shopping basket of a client has been authorized to be paid,
     * i.e. the shopping basket is not empty, the client has given his/her payment details, and the payment
     * has been authorized (under the limits of the client's credit card). However, the order
     * has not yet been placed yet, and the logistics details have not yet been given.
     *
     * @param clientEmail
     * @return true if the payment has been authorized, false otherwise
     * @throws ShopException if ...
     *      - clientEmail is null
     *      - the client with the given email does not exist
     */
    public boolean isPaymentAuthorized( EmailType clientEmail );


    /**
     * Checks out the shopping basket of a client
     *
     * @param clientEmail
     * @throws ShopException if ... 
     * @throws ShopException if ...
     *      - clientEmail is null
     *      - the client with the given email does not exist
     *      - the shopping basket is empty
     */
    public void checkout( EmailType clientEmail );




    /**
     * Returns a map showing which goods have been ordered by a client, and how many of each good
     *
     * @param clientEmail
     * @return the order history of the client (map is empty if the client has not ordered anything yet)
     * @Deprecated Might be split into a dedicated OrderUseCases interface later (but still valid in this milestone)
     * @throws ShopException if
     *      - the email is null
     *      - the client with the given email does not exist
     */
    public Map<UUID, Integer> getOrderHistory( EmailType clientEmail );



    /**
     * Deletes all orders and shopping baskets in the system
     * @Deprecated Might be split into two methods later (delete orders and delete shopping baskets), with
     *             the order deletion moved to a dedicated OrderUseCases interface later
     *             (but still valid in this milestone)
     */
    public void deleteAllOrders();
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\usecases\StockManagementUseCases.java ---
package thkoeln.archilab.ecommerce.usecases;

import thkoeln.archilab.ecommerce.ShopException;

import java.util.UUID;


/**
 * This interface contains methods needed in the context of use cases dealing with managing the shop stock,
 * i.e. adding and removing goods in the warehouse. The interface is probably incomplete, and
 * will grow over time.
 */
public interface StockManagementUseCases {
    /**
     * Adds a certain quantity of a given good to the stock
     * @param goodId
     * @param addedQuantity
     * @throws ShopException if ...
     *      - goodId is null
     *      - the good with that id does not exist
     *      - addedQuantity <= 0
     */
    public void addToStock( UUID goodId, int addedQuantity );


    /**
     * Removes a certain quantity of a given good from the stock.
     * If the new total quantity is lower than the currently reserved goods, some of currently reserved goods
     * (in the clients' shopping baskets) are removed. This means that some of the reserved goods are lost for
     * the client. (This is necessary because there probably was a mistake in the stock management, a mis-counting,
     * or some of the goods were stolen from the warehouse, are broken, etc.)
     * @param goodId
     * @param removedQuantity
     * @throws ShopException if ...
     *      - goodId is null
     *      - the good with that id does not exist
     *      - removedQuantity <= 0
     *      - the removed quantity is greater than the current stock and the currently reserved goods together
     */
    public void removeFromStock( UUID goodId, int removedQuantity );


    /**
     * Changes the total quantity of a given good in the stock.
     * If the new total quantity is lower than the currently reserved goods, some of currently reserved goods
     * (in the clients' shopping baskets) are removed. This means that some of the reserved goods are lost for
     * the client. (This is necessary because there probably was a mistake in the stock management, a mis-counting,
     * or some of the goods were stolen from the warehouse, are broken, etc.)
     * @param goodId
     * @param newTotalQuantity
     * @throws ShopException if ...
     *      - goodId is null
     *      - the good with that id does not exist
     *      - newTotalQuantity < 0
     */
    public void changeStockTo( UUID goodId, int newTotalQuantity );


    /**
     * Get the current total stock of a given good, including the currently reserved goods
     * @param goodId
     * @return the current total stock of the good
     * @throws ShopException if ...
     *      - goodId is null
     *      - the good with that id does not exist
     */
    public int getAvailableStock( UUID goodId );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\codereview\E3DDDOutsideSolutionRulesTest.java ---
package thkoeln.archilab.ecommerce.codereview;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;

import static com.tngtech.archunit.library.Architectures.layeredArchitecture;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln")
@SuppressWarnings("PMD")
public class E3DDDOutsideSolutionRulesTest {

    @ArchTest
    static final ArchRule noClassesOutsideSolutionAndDomainprimitives =
            layeredArchitecture()
                    .consideringAllDependencies()
                    .layer( "Domainprimitives" ).definedBy( "thkoeln.archilab.ecommerce.domainprimitives.." )
                    .layer( "SolutionClasses" ).definedBy( "thkoeln.archilab.ecommerce.solution.." )
                    .layer( "Test1" ).definedBy( "thkoeln.archilab.ecommerce.codereview.." )
                    .layer( "Test2" ).definedBy( "thkoeln.archilab.ecommerce.e1e2resttests.." )
                    .layer( "Test3" ).definedBy( "thkoeln.archilab.ecommerce.regression.." )

                    .whereLayer( "Domainprimitives" ).mayOnlyBeAccessedByLayers( "SolutionClasses", "Test1", "Test2", "Test3" )
                    .whereLayer( "SolutionClasses" ).mayOnlyBeAccessedByLayers( "Test1", "Test2", "Test3" );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\codereview\E3DDDRulesTest.java ---
package thkoeln.archilab.ecommerce.codereview;

import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTag;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.ArchRule;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Service;

import javax.persistence.Entity;
import javax.persistence.Id;

import java.util.UUID;

import static com.tngtech.archunit.core.domain.JavaMember.Predicates.declaredIn;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.*;

@ArchTag("layerRules")
@AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
@SuppressWarnings("PMD")
public class E3DDDRulesTest {

    @ArchTest
    static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
            noClasses().that().resideInAPackage("..domain..")
                    .should().dependOnClassesThat().resideInAPackage("..application..");

    @ArchTest
    static final ArchRule entitiesMustResideInADomainPackage =
            classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage("..domain..")
                    .as("Entities must reside in a package '..domain..'");

    @ArchTest
    static final ArchRule entitiesMustNotAccessRepositories =
            noClasses().that().areAnnotatedWith( Entity.class )
                    .should().dependOnClassesThat().areAssignableTo( CrudRepository.class );

    @ArchTest
    static final ArchRule repositoriesMustResideInADomainPackage =
            classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage("..domain..")
                    .as("Repositories must reside in a package '..domain..'");

    @ArchTest
    static final ArchRule repositoryNamesMustHaveProperSuffix =
            classes().that().areAssignableTo( CrudRepository.class )
                    .should().haveSimpleNameEndingWith("Repository");

    @ArchTest
    static final ArchRule servicesMustResideInAnApplicationPackage =
            classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage("..application..")
                    .as("Application Services must reside in a package '..application..'");

    @ArchTest
    static final ArchRule serviceNamesMustHaveProperSuffix =
            classes().that().areAnnotatedWith( Service.class )
                    .should().haveSimpleNameEndingWith("Service");

    @ArchTest
    static final ArchRule noClassesOnTopLevel =
            classes().should().resideInAPackage( "..solution.*.." );

    @ArchTest
    static final ArchRule noNonIdFieldsOfTypeIUUID =
            fields()
                    .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
                    .and().areNotAnnotatedWith( Id.class )
                    .and().areDeclaredInClassesThat().doNotHaveSimpleName( "Good" )
                    .should().notHaveRawType( UUID.class );
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\codereview\E3NoCycleTest.java ---
package thkoeln.archilab.ecommerce.codereview;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.library.dependencies.SliceAssignment;
import com.tngtech.archunit.library.dependencies.SliceIdentifier;
import org.junit.jupiter.api.Test;

import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;

public class E3NoCycleTest {
    private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");

    private SliceAssignment inAllClasses() {
        return new SliceAssignment() {
            @Override
            public String getDescription() {
                return "every class in it's own slice";
            }

            @Override
            public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
                return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
            }
        };
    }

    @Test
    public void testNoCyclicDependenciesBetweenClasses() {
        slices().assignedFrom(inAllClasses())
                .namingSlices("$1[$2.$3]")
                .should().beFreeOfCycles()
                .check(importedClasses);
    }

    @Test
    public void testNoCyclicDependenciesBetweenPackages() {
        ArchRule rule = slices().matching("..solution.(*)..").should().beFreeOfCycles();
        rule.check(importedClasses);
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\codereview\E3PackageStructureTest.java ---
package thkoeln.archilab.ecommerce.codereview;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class E3PackageStructureTest {

    private static final String[] REQUIRED_PACKAGES = {"client", "shoppingbasket", "good", "order"};
    private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
    private JavaClasses importedClasses;


    @BeforeEach
    public void setUp() {
        importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
    }

    @Test
    void testRequiredPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage;
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredDomainPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected domain sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

    @Test
    void testRequiredApplicationPackagesAreThere() {
        for ( String requiredPackage : REQUIRED_PACKAGES ) {
            String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
            assertThat( importedClasses.containPackage( packageName ) )
                    .as( "Expected application sub-package %s not found!", packageName )
                    .isTrue();
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\codereview\E3RequiredClassesTest.java ---
package thkoeln.archilab.ecommerce.codereview;

import org.junit.jupiter.api.Test;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.MetadataReaderFactory;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertTrue;

public class E3RequiredClassesTest {


    private static final String[] REQUIRED_CLASSES = {
            "Client",
            "ClientRepository",
            "Order",
            "OrderRepository",
            "ShoppingBasket",
            "ShoppingBasketRepository",
            "Good",
            "GoodRepository"
    };

    @Test
    public void testRequiredClassesDeclared() throws IOException {
        String basePackage = "thkoeln.archilab.ecommerce";
        String packageSearchPath = "classpath*:" + basePackage.replace( '.', '/' ) + "/**/*.class";

        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory( resolver );

        Set<String> foundClasses = new HashSet<>();

        Arrays.stream( resolver.getResources( packageSearchPath ) ).forEach( resource -> {
            try {
                MetadataReader reader = readerFactory.getMetadataReader( resource );
                foundClasses.add( reader.getClassMetadata().getClassName() );
            } catch (IOException e) {
                e.printStackTrace();
            }
        } );

        Arrays.stream(REQUIRED_CLASSES).forEach(requiredClass -> {
            boolean found = foundClasses.stream().anyMatch(className ->
                    className.startsWith(basePackage) && className.endsWith("." + requiredClass)
            );
            assertTrue(found, "Expected class not found: " + basePackage + ".*." + requiredClass);
        });
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\E1OrdertRESTTest.java ---
package thkoeln.archilab.ecommerce.e1e2resttests;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import javax.transaction.Transactional;
import java.util.UUID;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.instantiateEmail;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.GOOD_DATA;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.CLIENT_EMAIL;

@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@ActiveProfiles("test")
public class E1OrdertRESTTest {

    @Autowired
    private InitialMasterDataCreator initialMasterDataCreator;
    @Autowired
    private MockMvc mockMvc;

    private RESTHelper restHelper;
    private EmailType nonExistingEmail;


    @BeforeEach
    public void setUp() {
        initialMasterDataCreator.deleteAll();

        initialMasterDataCreator.addAllGoods();
        initialMasterDataCreator.stockUpAllGoods();
        initialMasterDataCreator.registerAllClients();

        restHelper = new RESTHelper( mockMvc );
        nonExistingEmail = instantiateEmail( "harry@sally.de" );
    }


    @Test
    public void testGetNoOrders() throws Exception {
        // given
        // when
        // then
        mockMvc.perform( get( "/orders" ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.length()" ).value( 0 ) );
        mockMvc.perform( get( "/orders?email=" + nonExistingEmail ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.length()" ).value( 0 ) );
        mockMvc.perform( get( "/orders?email=invalidEmailString" ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.length()" ).value( 0 ) );
        mockMvc.perform( get( "/orders?email=" + CLIENT_EMAIL[3].toString() ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.length()" ).value( 0 ) );
    }


    @Test void testMakeThreeOrders() throws Exception {
        // given
        String emailString = CLIENT_EMAIL[6].toString();

        UUID goodId2 = (UUID) GOOD_DATA[2][0];
        UUID goodId4 = (UUID) GOOD_DATA[4][0];
        UUID goodId6 = (UUID) GOOD_DATA[6][0];
        Float goodMoneyAmount2 = ((MoneyType) GOOD_DATA[2][5]).getAmount() * 2;
        Float goodMoneyAmount4 = ((MoneyType) GOOD_DATA[4][5]).getAmount() * 4;
        Float goodMoneyAmount6 = ((MoneyType) GOOD_DATA[6][5]).getAmount() * 6;

        String uriAllOrders = "/orders?email=" + emailString;
        String uriLatestOrder = uriAllOrders + "&filter=latest";

        // when
        restHelper.makeOrderForClient( emailString, goodId2, 2 );
        restHelper.makeOrderForClient( emailString, goodId4, 4 );
        restHelper.makeOrderForClient( emailString, goodId6, 6 );

        // then get all orders ...
        mockMvc.perform( get( uriAllOrders ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.length()" ).value( 3 ) )

                .andExpect( jsonPath( "$[0].email.emailString" ).value( emailString ) )
                .andExpect( jsonPath( "$[0].price.amount" ).value( goodMoneyAmount2 ) )

                .andExpect( jsonPath( "$[1].email.emailString" ).value( emailString ) )
                .andExpect( jsonPath( "$[1].price.amount" ).value( goodMoneyAmount4 ) )

                .andExpect( jsonPath( "$[2].email.emailString" ).value( emailString ) )
                .andExpect( jsonPath( "$[2].price.amount" ).value( goodMoneyAmount6 ) );

        // ... and the latest order
        mockMvc.perform( get( uriLatestOrder ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.length()" ).value( 1 ) );
                //.andExpect( jsonPath( "$[0].price.amount" ).value( goodMoneyAmount6 ) );
    }


    @Test
    public void testIfMoneySumInOrderIsCorrect() throws Exception {
        // given
        String emailString = CLIENT_EMAIL[3].toString();
        UUID goodId3 = (UUID) GOOD_DATA[3][0];
        UUID goodId4 = (UUID) GOOD_DATA[4][0];
        Integer quantity3 = 14;
        Integer quantity4 = 5;
        Float goodMoneyAmount =
                ((MoneyType) GOOD_DATA[3][5]).getAmount() * quantity3 +
                ((MoneyType) GOOD_DATA[4][5]).getAmount() * quantity4;

        // when
        UUID shoppingBasketId = restHelper.getShoppingBasketId( emailString );
        restHelper.addGoodToShoppingBasket( shoppingBasketId, goodId3, quantity3 );
        restHelper.addGoodToShoppingBasket( shoppingBasketId, goodId4, quantity4 );
        mockMvc.perform( put( "/shoppingBaskets/" + shoppingBasketId.toString() + "/checkout" ) )
                .andExpect( status().isOk() );

        // then
        mockMvc.perform( get(
                "/orders?email=" + emailString + "&filter=latest") )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.length()" ).value( 1 ) )
                .andExpect( jsonPath( "$[0].price.amount" ).value( goodMoneyAmount ) );
    }



}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\E2ShoppingBasketRESTTest.java ---
package thkoeln.archilab.ecommerce.e1e2resttests;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import javax.transaction.Transactional;
import java.util.UUID;

import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static thkoeln.archilab.ecommerce.e1e2resttests.RESTHelper.CONFLICT;
import static thkoeln.archilab.ecommerce.e1e2resttests.RESTHelper.CREATED;
import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.instantiateEmail;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.GOOD_DATA;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.CLIENT_EMAIL;

@SpringBootTest
@Transactional
@AutoConfigureMockMvc
@ActiveProfiles("test")
public class E2ShoppingBasketRESTTest {

    @Autowired
    private InitialMasterDataCreator initialMasterDataCreator;
    @Autowired
    private MockMvc mockMvc;

    private RESTHelper restHelper;
    private EmailType nonExistingEmail;


    @BeforeEach
    public void setUp() {
        initialMasterDataCreator.deleteAll();

        initialMasterDataCreator.addAllGoods();
        initialMasterDataCreator.stockUpAllGoods();
        initialMasterDataCreator.registerAllClients();

        restHelper = new RESTHelper( mockMvc );
        nonExistingEmail = instantiateEmail( "harry@sally.de" );
    }


    @Test
    public void testEmptyShoppingBasket() throws Exception {
        // given
        String validUri = "/shoppingBaskets?email=" + CLIENT_EMAIL[4].toString();
        String invalidUri1 = "/shoppingBaskets?email=" + nonExistingEmail.toString();
        String invalidUri2 = "/shoppingBaskets?email=justaninvalidemailaddress";

        // when
        // then
        mockMvc.perform( get( validUri ) )
                .andExpect( status().isOk() )
                .andExpect( jsonPath( "$.totalQuantity" ).value( 0 ) );
        mockMvc.perform( get( invalidUri1 ) )
                .andExpect( status().isNotFound() );
        mockMvc.perform( get( invalidUri2 ) )
                .andExpect( status().isNotFound() );
    }


    @Test
    public void testInvalidUris() throws Exception {
        // given
        UUID goodId = (UUID) GOOD_DATA[3][0];
        String clientEmailString = CLIENT_EMAIL[4].toString();
        UUID shoppingBasketId = restHelper.getShoppingBasketId( clientEmailString );

        String invalidPostUri = "/shoppingBaskets/" + UUID.randomUUID() + "/shoppingBasketPositions";
        String invalidPatchGetDeleteUri1 =
                "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions/" + UUID.randomUUID();
        String invalidPatchGetDeleteUri2 =
                "/shoppingBaskets/" + UUID.randomUUID().toString() + "/shoppingBasketPositions/" + goodId;
        String invalidCheckoutUri1 = "/shoppingBaskets/" + shoppingBasketId + "/chekkout";
        String invalidCheckoutUri2 = "/shoppingBaskets/" + UUID.randomUUID() + "/checkout";

        // when
        // then
        mockMvc.perform( post( invalidPostUri )
                .contentType( APPLICATION_JSON ).content( "[]" ) ).andExpect( status().is4xxClientError() );

        mockMvc.perform( delete( invalidPatchGetDeleteUri1 ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( invalidPatchGetDeleteUri1 ) ).andExpect( status().isNotFound() );

        mockMvc.perform( delete( invalidPatchGetDeleteUri2 ) ).andExpect( status().isNotFound() );
        mockMvc.perform( get( invalidPatchGetDeleteUri2 ) ).andExpect( status().isNotFound() );

        mockMvc.perform( put( invalidCheckoutUri1 ) ).andExpect( status().isNotFound() );
        mockMvc.perform( put( invalidCheckoutUri2 ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testQueryNonExistingGood() throws Exception {
        // given
        UUID goodId = (UUID) GOOD_DATA[3][0];
        String clientEmailString = CLIENT_EMAIL[7].toString();
        UUID shoppingBasketId = restHelper.getShoppingBasketId( clientEmailString );
        String invalidUri = "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions/" + goodId;

        // when
        // then
        mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
    }


    @Test
    public void testDeleteFromShoppingBasket() throws Exception {
        // given
        UUID goodId1 = (UUID) GOOD_DATA[1][0];
        String clientEmailString9 = CLIENT_EMAIL[9].toString();
        String clientEmailString7 = CLIENT_EMAIL[7].toString();

        UUID shoppingBasketId9 = restHelper.getShoppingBasketId( clientEmailString9 );
        UUID shoppingBasketId7 = restHelper.getShoppingBasketId( clientEmailString7 );

        String baseUri9 = "/shoppingBaskets/" + shoppingBasketId9 + "/shoppingBasketPositions/";
        String checkoutUri9 = "/shoppingBaskets/" + shoppingBasketId9 + "/checkout";
        String checkoutUri7 = "/shoppingBaskets/" + shoppingBasketId7 + "/checkout";

        // when
        restHelper.addMultipleGoodsToShoppingBasket( clientEmailString9,
                new Integer[]{1, 4, 6}, new Integer[]{1, 4, 6}, new String[]{"c1", "c4", "c6"} );
        restHelper.checkMultipleShoppingBasketPositions(
                clientEmailString9, new Integer[]{1, 4, 6}, new Integer[]{1, 4, 6},
                new String[]{"c1", "c4", "c6"} );
        mockMvc.perform( delete( baseUri9 + goodId1 ) )
                .andExpect( status().isOk() );
        restHelper.checkMultipleShoppingBasketPositions(
                clientEmailString9, new Integer[]{1, 4, 6}, new Integer[]{null, 4, 6},
                new String[]{null, "c4", "c6"}, new Boolean[]{false, true, true} );
        // ... and another customer can still buy 10 of the "Nr. 1" good
        restHelper.addGoodToShoppingBasket( shoppingBasketId7, goodId1, 10,
                "still10", null );

        // then
        mockMvc.perform( put( checkoutUri9 ) ).andExpect( status().isOk() );
        restHelper.checkMultipleOrderPositionsInLatestOrder( clientEmailString9,
                new Integer[]{4, 6}, new Integer[]{4, 6}, new String[]{"c4", "c6"} );
        mockMvc.perform( put( checkoutUri7 ) ).andExpect( status().isOk() );
        restHelper.checkMultipleOrderPositionsInLatestOrder( clientEmailString7,
                new Integer[]{1}, new Integer[]{10}, new String[]{"still10"} );
    }


    @Test
    public void testAddToAndRemoveFromShoppingBasket() throws Exception {
        // given
        String clientEmailString = CLIENT_EMAIL[2].toString();
        UUID shoppingBasketId = restHelper.getShoppingBasketId( clientEmailString );
        String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";

        // when
        restHelper.addMultipleGoodsToShoppingBasket( clientEmailString,
                new Integer[]{2, 4, 2, 4, 6, 2}, new Integer[]{2, 3, 4, -1, 3, -6},
                new String[]{null, "c4a", "c2a", "c4b", "c6", null} );
        restHelper.checkMultipleShoppingBasketPositions(
                clientEmailString, new Integer[]{2, 4, 6}, new Integer[]{null, 2, 3},
                new String[]{null, "c4b", "c6"}, new Boolean[]{false, true, true} );

        // then
        mockMvc.perform( put( checkoutUri ) ).andExpect( status().isOk() );
        restHelper.checkMultipleOrderPositionsInLatestOrder( clientEmailString,
                new Integer[]{4, 6}, new Integer[]{2, 3}, new String[]{"c4b", "c6"} );
    }


    @Test
    public void testRemoveMoreThanThereIsInShoppingBasket() throws Exception {
        // given
        String clientEmailString = CLIENT_EMAIL[2].toString();

        // when
        // then
        restHelper.addMultipleGoodsToShoppingBasket( clientEmailString,
                new Integer[]{2, 4, 2}, new Integer[]{2, 3, -3}, new String[]{null, null, null},
                new ResultMatcher[]{CREATED, CREATED, CONFLICT} );
    }


    @Test
    public void testAddMoreThanIsInStock() throws Exception {
        // given
        String clientEmailString = CLIENT_EMAIL[7].toString();

        // when
        // then
        restHelper.addMultipleGoodsToShoppingBasket( clientEmailString,
                new Integer[]{1, 1, 1, 1}, new Integer[]{2, 3, 4, 2}, new String[]{null, null, null, null},
                new ResultMatcher[]{CREATED, CREATED, CREATED, CONFLICT} );
    }


    @Test
    public void testSuccessfulCheckoutJustWithinPaymentLimit() throws Exception {
        // given
        String clientEmailString = CLIENT_EMAIL[5].toString();
        UUID shoppingBasketId = restHelper.getShoppingBasketId( clientEmailString );
        String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";

        // when
        restHelper.addMultipleGoodsToShoppingBasket( clientEmailString,
                new Integer[]{11, 13, 10, 6}, new Integer[]{1, 1, 1, 17}, new String[]{"350€", "100€", "35€", "8.50€"} );

        // then
        mockMvc.perform( put( checkoutUri ) ).andExpect( status().isOk() );
        restHelper.checkMultipleOrderPositionsInLatestOrder( clientEmailString,
                new Integer[]{11, 13, 10, 6}, new Integer[]{1, 1, 1, 17}, new String[]{"350€", "100€", "35€", "8.50€"} );
    }



    @Test
    public void testUnsuccessfulCheckoutAbovePaymentLimit() throws Exception {
        // given
        String clientEmailString = CLIENT_EMAIL[1].toString();
        UUID shoppingBasketId = restHelper.getShoppingBasketId( clientEmailString );
        String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";

        // when
        restHelper.addMultipleGoodsToShoppingBasket( clientEmailString,
                new Integer[]{13, 10}, new Integer[]{4, 3}, new String[]{"400€", "105€"} );

        // then
        mockMvc.perform( put( checkoutUri ) ).andExpect( status().isConflict() );
    }


    @Test
    public void testUnsuccessfulCheckoutAboveDeliveryLimit() throws Exception {
        // given
        String clientEmailString = CLIENT_EMAIL[8].toString();
        UUID shoppingBasketId = restHelper.getShoppingBasketId( clientEmailString );
        String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";

        // when
        restHelper.addMultipleGoodsToShoppingBasket( clientEmailString,
                new Integer[]{13, 6}, new Integer[]{3, 18}, new String[]{"300€", "9€"} );

        // then
        mockMvc.perform( put( checkoutUri ) ).andExpect( status().isConflict() );
    }


    @Test
    public void testNoCheckoutForEmptyShoppingBasket() throws Exception {
        // given
        String clientEmailString = CLIENT_EMAIL[9].toString();
        UUID shoppingBasketId = restHelper.getShoppingBasketId( clientEmailString );
        String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";

        // when
        // then
        mockMvc.perform( put( checkoutUri ) ).andExpect( status().isConflict() );
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\RESTHelper.java ---
package thkoeln.archilab.ecommerce.e1e2resttests;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.test.web.servlet.ResultMatcher;
import thkoeln.archilab.ecommerce.e1e2resttests.testdtos.IdDTO;
import thkoeln.archilab.ecommerce.e1e2resttests.testdtos.QuantityAndCommentDTO;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.GOOD_DATA;

public class RESTHelper {
    private MockMvc mockMvc;

    public static final ResultMatcher NOT_FOUND = status().isNotFound();
    public static final ResultMatcher OK = status().isOk();
    public static final ResultMatcher CREATED = status().isCreated();
    public static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
    public static final ResultMatcher CONFLICT = status().isConflict();

    public RESTHelper( MockMvc mockMvc ) {
        this.mockMvc = mockMvc;
    }

    public void makeOrderForClient( String emailString, UUID goodId, Integer quantity ) throws Exception {
        UUID shoppingBasketId = getShoppingBasketId( emailString );
        addGoodToShoppingBasket( shoppingBasketId, goodId, quantity );
        mockMvc.perform( put( "/shoppingBaskets/" + shoppingBasketId.toString() + "/checkout" ) )
                .andExpect( OK );
    }

    public UUID getShoppingBasketId( String emailString ) throws Exception {
        // get the shopping basket and extract its id ...
        MvcResult shoppingBasket = mockMvc.perform( get( "/shoppingBaskets?email=" + emailString ) )
                .andExpect( OK )
                .andExpect( jsonPath( "$.id" ).isNotEmpty() )
                .andReturn();
        ObjectMapper objectMapper = new ObjectMapper();
        IdDTO idDTO = objectMapper.readValue( shoppingBasket.getResponse().getContentAsString(), IdDTO.class );
        return idDTO.getId();
    }

    public void addGoodToShoppingBasket( UUID shoppingBasketId, UUID goodId, Integer quantity,
                                                 String comment, ResultMatcher expectedStatus )
                                                throws Exception {
        ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
        ObjectMapper objectMapper = new ObjectMapper();
        QuantityAndCommentDTO dto = new QuantityAndCommentDTO( goodId, quantity, comment );
        String quantityJson = objectMapper.writeValueAsString( dto );
        mockMvc.perform( post( "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions" )
                .contentType( APPLICATION_JSON ).content( quantityJson ) )
                .andExpect( status );
    }


    public void addGoodToShoppingBasket( UUID shoppingBasketId, UUID goodId, Integer quantity )
            throws Exception {
        addGoodToShoppingBasket( shoppingBasketId, goodId, quantity, null, null );
    }



    public void addMultipleGoodsToShoppingBasket(
            String clientEmailString, Integer[] goodIndices, Integer[] quantities, String[] comments,
            ResultMatcher[] expectedAddStatuses ) throws Exception {
        UUID shoppingBasketId = getShoppingBasketId( clientEmailString );
        String shoppingBasketUri = "shoppingBaskets?email=" + clientEmailString;
        String baseUri = "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions/";

        // add all the goods to the shopping basket ...
        Map<Integer, Integer> quantityMap = new HashMap<>();
        Map<Integer, String> commentMap = new HashMap<>();
        for ( int i = 0; i < goodIndices.length; i++ ) {
            UUID goodId = (UUID) GOOD_DATA[goodIndices[i]][0];
            addGoodToShoppingBasket( shoppingBasketId, goodId, quantities[i], comments[i], expectedAddStatuses[i] );
            if ( expectedAddStatuses[i] != null || expectedAddStatuses[i] == CREATED || expectedAddStatuses[i] == OK ) {
                quantityMap.put( goodIndices[i],
                        quantities[i] + quantityMap.getOrDefault( goodIndices[i], 0 ) );
                commentMap.put( goodIndices[i], comments[i] );
            }
        }
    }


    public void addMultipleGoodsToShoppingBasket(
            String clientEmailString, Integer[] goodIndices, Integer[] quantities,
            String[] comments ) throws Exception {
        ResultMatcher[] expectedAddStatuses = new ResultMatcher[goodIndices.length];
        for ( int i = 0; i < goodIndices.length; i++ ) {
            expectedAddStatuses[i] = CREATED;
        }
        addMultipleGoodsToShoppingBasket( clientEmailString, goodIndices, quantities,
                comments, expectedAddStatuses );
    }


    public void checkMultipleShoppingBasketPositions( String clientEmailString,
                                                         Integer[] goodIndices, Integer[] expectedQuantities,
                                                         String[] expectedComments, Boolean[] expectedToBeFound ) throws Exception {
        UUID shoppingBasketId = getShoppingBasketId( clientEmailString );
        String shoppingBasketUri = "/shoppingBaskets?email=" + clientEmailString;
        String baseUri = "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions/";

        // check that the shopping basket contains all the goods ...
        int totalQuantity = 0;
        for ( int i = 0; i < goodIndices.length; i++ ) {
            if ( expectedQuantities[i] != null ) {
                totalQuantity += expectedQuantities[i];
            }
        }
        mockMvc.perform( get( shoppingBasketUri ) )
                .andExpect( OK )
                .andExpect( jsonPath( "$.totalQuantity" ).value( totalQuantity ) );

        // check that each good has the correct quantity and comment ...
        for ( int i = 0; i < goodIndices.length; i++ ) {
            UUID goodId = (UUID) GOOD_DATA[goodIndices[i]][0];
            if ( expectedToBeFound[i] ) {
                mockMvc.perform( get( baseUri + goodId ) )
                        .andExpect( OK )
                        .andExpect( jsonPath( "$.quantity" ).value( expectedQuantities[i] ) )
                        .andExpect( jsonPath( "$.comment" ).value( expectedComments[i] ) );
            } else {
                mockMvc.perform( get( baseUri + goodId ) )
                        .andExpect( NOT_FOUND );
            }
        }
    }


    public void checkMultipleShoppingBasketPositions( String clientEmailString,
                                                         Integer[] goodIndices, Integer[] expectedQuantities,
                                                         String[] expectedComments ) throws Exception {
        Boolean[] expectedToBeFound = new Boolean[goodIndices.length];
        for ( int i = 0; i < goodIndices.length; i++ ) {
            expectedToBeFound[i] = true;
        }
        checkMultipleShoppingBasketPositions( clientEmailString, goodIndices, expectedQuantities,
                expectedComments, expectedToBeFound );
    }



    public void checkMultipleOrderPositionsInLatestOrder(
            String clientEmailString, Integer[] goodIndices, Integer[] expectedQuantities,
            String[] expectedComments ) throws Exception {
        String latestOrderUri = "/orders?email=" + clientEmailString + "&filter=latest";

        // Calculate the total price of the order ...
        float totalPrice = 0f;
        for ( int i = 0; i < goodIndices.length; i++ ) {
            totalPrice += expectedQuantities[i] * ((MoneyType) GOOD_DATA[goodIndices[i]][5]).getAmount();
        }

        // ... and check that the order has the correct total price (and other data)
        ResultActions resultActions = mockMvc.perform( get( latestOrderUri ) ).andExpect( OK )
                .andExpect( jsonPath( "$.length()" ).value( 1 ) )
                .andExpect( jsonPath( "$[0].price.amount" ).value( totalPrice ) )
                .andExpect( jsonPath( "$[0].email.emailString" ).value( clientEmailString ) );

        // Now check that all the expected parts are there
        for ( int i = 0; i < goodIndices.length; i++ ) {
            UUID goodId = (UUID) GOOD_DATA[goodIndices[i]][0];
            resultActions.andExpect(
                    jsonPath( "$[0].orderPositions.length()" ).value( goodIndices.length ) );
            resultActions.andExpect(
                    jsonPath( "$[0].orderPositions[?(@.goodId == '" + goodId + "')].quantity" )
                            .value( expectedQuantities[i] ) );
            if ( expectedComments[i] != null ) {
                resultActions.andExpect(
                        jsonPath( "$[0].orderPositions[?(@.goodId == '" + goodId + "')].comment" )
                                .value( expectedComments[i] ) );
            }
        }
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\testdtos\CommentDTO.java ---
package thkoeln.archilab.ecommerce.e1e2resttests.testdtos;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.*;

import java.util.UUID;

/**
 * A DTO containing just a comment, used in testing.
 */

@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
@ToString
@JsonIgnoreProperties(ignoreUnknown = true)
public class CommentDTO {
    private UUID goodId;
    private String comment;
}



--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\testdtos\IdDTO.java ---
package thkoeln.archilab.ecommerce.e1e2resttests.testdtos;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.*;

import java.util.UUID;

/**
 * A DTO containing just the id of an entity, used in testing.
 */

@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
@ToString
@JsonIgnoreProperties(ignoreUnknown = true)
public class IdDTO {
    private UUID id;
}



--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\testdtos\QuantityAndCommentDTO.java ---
package thkoeln.archilab.ecommerce.e1e2resttests.testdtos;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.*;

import java.util.UUID;

/**
 * A DTO containing just a quantity, used in testing.
 */


@NoArgsConstructor
@Setter
@Getter
@ToString
@JsonIgnoreProperties(ignoreUnknown = true)
public class QuantityAndCommentDTO {
    private UUID goodId;
    private Integer quantity;
    private String comment;

    public QuantityAndCommentDTO( UUID goodId, Integer quantity, String comment ) {
        this.goodId = goodId;
        this.quantity = quantity;
        this.comment = comment;
    }
}



--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionEmailTest.java ---
package thkoeln.archilab.ecommerce.regression.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;

class RegressionEmailTest {

    @Test
    public void testToString() {
        // given
        String input = "test@example.com";

        // when
        EmailType instance = instantiateEmail( input );

        // then
        assertEquals( input, instance.toString() );
    }

    @Test
    public void testFactoryMethodValid() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiateEmail( "test@example.com" ) );
        assertDoesNotThrow( () -> instantiateEmail( "99Z@example.com" ) );
        assertDoesNotThrow( () -> instantiateEmail( "GGGhh@s77.com" ) );
        assertDoesNotThrow( () -> instantiateEmail( "a@4.com" ) );
        assertDoesNotThrow( () -> instantiateEmail( "Max.Hammer@example.com" ) );
        assertDoesNotThrow( () -> instantiateEmail( "Max.Gideon.Hammer@example.com" ) );
        assertDoesNotThrow( () -> instantiateEmail( "test@example.this.com" ) );
        assertDoesNotThrow( () -> instantiateEmail( "test@example.de" ) );
        assertDoesNotThrow( () -> instantiateEmail( "test@example.at" ) );
        assertDoesNotThrow( () -> instantiateEmail( "test@example.ch" ) );
        assertDoesNotThrow( () -> instantiateEmail( "test@example.org" ) );
    }

    @Test
    public void testFactoryMethodInvalid() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateEmail( null ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "testexample.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "Max..Gideon.Hammer@example.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@examplecom" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@example..com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test#example@that.com" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@example.biz" ) );
        assertThrows( ShopException.class, () -> instantiateEmail( "test@example.42" ) );
    }

    @Test
    public void testValueObjectEquality() {
        // given
        // when
        EmailType instance1 = instantiateEmail( "test@example.com" );
        EmailType instance2 = instantiateEmail( "test@example.com" );
        EmailType instance3 = instantiateEmail( "different@example.com" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutability() {
        // given
        // when
        EmailType instance = instantiateEmail( "test@example.com" );

        // then
        try {
            instance.getClass().getMethod( "setEmail", String.class );
            fail( "setEmail method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionHomeAddressTest.java ---
package thkoeln.archilab.ecommerce.regression.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;

class RegressionHomeAddressTest {

    @Test
    public void testGetterMethods() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        HomeAddressType instance = instantiateHomeAddress( street, city, plz );

        // then
        assertEquals( street, instance.getStreet() );
        assertEquals( city, instance.getCity() );
        assertEquals( plz, instance.getPostalCode() );
    }

    @Test
    public void testFactoryMethodValid() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        // then
        assertDoesNotThrow( () -> instantiateHomeAddress( street, city, plz ) );
    }

    @Test
    public void testFactoryMethodInvalid() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        // then
        assertThrows( ShopException.class, () -> instantiateHomeAddress( null, city, plz ) );
        assertThrows( ShopException.class, () -> instantiateHomeAddress( "", city, plz ) );
        assertThrows( ShopException.class, () -> instantiateHomeAddress( street, null, plz ) );
        assertThrows( ShopException.class, () -> instantiateHomeAddress( street, "", plz ) );
        assertThrows( ShopException.class, () -> instantiateHomeAddress( street, city, null ) );
    }

    @Test
    public void testValueObjectEquality() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        HomeAddressType instance1 = instantiateHomeAddress( street, city, plz );
        HomeAddressType instance2 = instantiateHomeAddress( street, city, plz );
        HomeAddressType instance3 = instantiateHomeAddress( "Anderestr. 12", city, plz );
        HomeAddressType instance4 = instantiateHomeAddress( street, "AndereStadt", plz );
        HomeAddressType instance5 = instantiateHomeAddress( street, city, instantiatePostalCode( "54321" ) );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
        assertNotEquals( instance1, instance4 );
        assertNotEquals( instance1, instance5 );
    }

    @Test
    public void testImmutability() {
        // given
        String street = "Irgendeinestraße 42";
        String city = "Irgendeinestadt";
        PostalCodeType plz = instantiatePostalCode( "12345" );

        // when
        HomeAddressType instance = instantiateHomeAddress( street, city, plz );

        // then
        try {
            instance.getClass().getMethod( "setStreet", String.class );
            fail( "setStreet method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setCity", String.class );
            fail( "setCity method should not exist" );

        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
        try {
            instance.getClass().getMethod( "setPostalCode", PostalCodeType.class );
            fail( "setPostalCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionMoneyTest.java ---
package thkoeln.archilab.ecommerce.regression.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;

class RegressionMoneyTest {

    @Test
    public void testGetAmount() {
        // given
        Float inputAmount = 10.0f;

        // when
        MoneyType instance = instantiateMoney( inputAmount, "EUR" );

        // then
        assertEquals( inputAmount, instance.getAmount() );
    }

    @Test
    public void testGetCurrency() {
        // given
        String inputCurrency = "EUR";

        // when
        MoneyType instance = instantiateMoney( 10.0f, inputCurrency );

        // then
        assertEquals( inputCurrency, instance.getCurrency() );
    }

    @Test
    public void testAddTo() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );

        // when
        MoneyType result12 = instance1.add( instance2 );
        MoneyType result13 = instance1.add( instance3 );

        // then
        assertEquals( 30.0f, result12.getAmount() );
        assertEquals( "EUR", result12.getCurrency() );
        assertEquals( 10.0f, result13.getAmount() );
        assertEquals( "EUR", result12.getCurrency() );
    }

    @Test
    public void testInvalidAddTo() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
    }

    @Test
    public void testSubtractFrom() {
        // given
        MoneyType instance1 = instantiateMoney( 30.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
        MoneyType instance4 = instantiateMoney( 30.0f, "EUR" );

        // when
        MoneyType result12 = instance1.subtract( instance2 );
        MoneyType result13 = instance1.subtract( instance3 );
        MoneyType result14 = instance1.subtract( instance4 );

        // then
        assertEquals( 10.0f, result12.getAmount() );
        assertEquals( "EUR", result12.getCurrency() );
        assertEquals( 30.0f, result13.getAmount() );
        assertEquals( "EUR", result13.getCurrency() );
        assertEquals( 0.0f, result14.getAmount() );
        assertEquals( "EUR", result14.getCurrency() );
    }

    @Test
    public void testInvalidSubtractFrom() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 5.0f, "CHF" );

        // when
        // then
        assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
        assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
    }

    @Test
    public void testMultiplyBy() {
        // given
        MoneyType instance = instantiateMoney( 10.0f, "EUR" );

        // when
        MoneyType result = instance.multiplyBy( 3 );

        // then
        assertEquals( 30.0f, result.getAmount() );
        assertEquals( "EUR", result.getCurrency() );
    }

    @Test
    public void testFactoryMethodValid() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiateMoney( 10.0f, "EUR" ) );
    }

    @Test
    public void testFactoryMethodInvalid() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiateMoney( -10.0f, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, "USD" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( null, "EUR" ) );
        assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, null ) );
    }

    @Test
    public void testLargerThan() {
        // given
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance4 = instantiateMoney( 10.0f, "CHF" );

        // when
        // then
        assertTrue( instance2.largerThan( instance1 ) );
        assertFalse( instance1.largerThan( instance2 ) );
        assertFalse( instance1.largerThan( instance3 ) );
        assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
    }


    @Test
    public void testValueObjectEquality() {
        // given
        // when
        MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance2 = instantiateMoney( 10.0f, "EUR" );
        MoneyType instance3 = instantiateMoney( 20.0f, "EUR" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutability() {
        // given
        // when
        MoneyType instance = instantiateMoney( 10.0f, "EUR" );

        // then
        try {
            instance.getClass().getMethod( "setAmount", Float.class );
            fail( "setAmount method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }

        try {
            instance.getClass().getMethod( "setCurrency", String.class );
            fail( "setCurrency method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionPostalCodeTest.java ---
package thkoeln.archilab.ecommerce.regression.domainprimitives;

import org.junit.jupiter.api.Test;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;

class RegressionPostalCodeTest {

    @Test
    public void testToString() {
        // given
        String input = "12345";

        // when
        PostalCodeType instance = instantiatePostalCode( input );

        // then
        assertEquals( input, instance.toString() );
    }

    @Test
    public void testFactoryMethodValid() {
        // given
        // when
        // then
        assertDoesNotThrow( () -> instantiatePostalCode( "12345" ) );
    }

    @Test
    public void testFactoryMethodInvalid() {
        // given
        // when
        // then
        assertThrows( ShopException.class, () -> instantiatePostalCode( "123456" ) );
        assertThrows( ShopException.class, () -> instantiatePostalCode( "1234" ) );
        assertThrows( ShopException.class, () -> instantiatePostalCode( "20000" ) );
        assertThrows( ShopException.class, () -> instantiatePostalCode( null ) );
    }

    @Test
    public void testValueObjectEquality() {
        // given
        // when
        PostalCodeType instance1 = instantiatePostalCode( "12345" );
        PostalCodeType instance2 = instantiatePostalCode( "12345" );
        PostalCodeType instance3 = instantiatePostalCode( "54321" );

        // then
        assertEquals( instance1, instance2 );
        assertNotEquals( instance1, instance3 );
    }

    @Test
    public void testImmutability() {
        // given
        // when
        PostalCodeType instance = instantiatePostalCode( "12345" );

        // then
        try {
            instance.getClass().getMethod( "setpostalCode", String.class );
            fail( "setpostalCode method should not exist" );
        } catch (NoSuchMethodException e) {
            // Success: the object is immutable
        }
    }
}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\regression\RegressionClientRegistrationTest.java ---
package thkoeln.archilab.ecommerce.regression;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
import thkoeln.archilab.ecommerce.usecases.ClientRegistrationUseCases;
import thkoeln.archilab.ecommerce.usecases.ClientType;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType;

import javax.transaction.Transactional;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.instantiateEmail;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.CLIENT_ADDRESS;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.CLIENT_EMAIL;

@SpringBootTest
@Transactional
public class RegressionClientRegistrationTest {

    @Autowired
    private ClientRegistrationUseCases clientRegistrationUseCases;
    @Autowired
    private InitialMasterDataCreator initialMasterDataCreator;

    private EmailType nonExistingEmail;

    @BeforeEach
    public void setUp() {
        initialMasterDataCreator.deleteAll();
        nonExistingEmail = instantiateEmail( "this@nononono.de" );
    }


    @Test
    public void testAllClientsRegistered() {
        // given
        initialMasterDataCreator.registerAllClients();

        // when
        ClientType client3 = clientRegistrationUseCases.getClientData( CLIENT_EMAIL[3] );

        // then
        Assertions.assertEquals( initialMasterDataCreator.CLIENT_NAME[3], client3.getName() );
        Assertions.assertEquals( CLIENT_EMAIL[3], client3.getEmail() );
        Assertions.assertEquals( CLIENT_ADDRESS[3], client3.getHomeAddress() );
    }


    @Test
    public void testRegisterClientWithDuplicateEmail() {
        // given
        initialMasterDataCreator.registerAllClients();

        // when
        // then
        assertThrows( ShopException.class, () ->
                clientRegistrationUseCases.register( "Gandalf The Grey", CLIENT_EMAIL[5],
                        CLIENT_ADDRESS[5] ) );
    }

    @Test
    public void testRegisterClientWithDuplicateNameOrHomeAddress() {
        // given
        initialMasterDataCreator.registerAllClients();
        EmailType newEmail = instantiateEmail( "some@this.de" );

        // when
        // then
        assertDoesNotThrow(() ->
                clientRegistrationUseCases.register( initialMasterDataCreator.CLIENT_NAME[2], newEmail,
                        CLIENT_ADDRESS[2] ) );
    }


    @Test
    public void testDeleteClientsNoMoreClients() {
        // given
        initialMasterDataCreator.registerAllClients();

        // when
        clientRegistrationUseCases.deleteAllClients();

        // then
        assertThrows( ShopException.class, () -> clientRegistrationUseCases.getClientData( CLIENT_EMAIL[0] ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\regression\RegressionGoodCatalogTest.java ---
package thkoeln.archilab.ecommerce.regression;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.ShopException;
import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
import thkoeln.archilab.ecommerce.usecases.StockManagementUseCases;
import thkoeln.archilab.ecommerce.usecases.GoodCatalogUseCases;
import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;

import javax.transaction.Transactional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.GOOD_DATA;

@SpringBootTest
@Transactional
public class RegressionGoodCatalogTest {

    @Autowired
    private GoodCatalogUseCases goodCatalogUseCases;
    @Autowired
    private StockManagementUseCases stockManagementUseCases;
    @Autowired
    private InitialMasterDataCreator initialMasterDataCreator;

    @BeforeEach
    public void setUp() {
        initialMasterDataCreator.deleteAll();
    }



    @Test
    public void testAddGoodToCatalog() {
        // given
        initialMasterDataCreator.addAllGoods();

        // when
        MoneyType salesPrice = goodCatalogUseCases.getSalesPrice( (UUID) GOOD_DATA[4][0] );

        // then
        assertEquals( GOOD_DATA[4][5], salesPrice );
    }

    @Test
    public void testRemoveGoodFromCatalog() {
        // given
        initialMasterDataCreator.addAllGoods();
        UUID goodId = (UUID) GOOD_DATA[4][0];

        // when
        assertDoesNotThrow( () -> goodCatalogUseCases.getSalesPrice( goodId ) );
        goodCatalogUseCases.removeGoodFromCatalog( goodId );

        // then
        assertThrows( ShopException.class, () -> goodCatalogUseCases.getSalesPrice( goodId ) );
    }




    @Test
    public void testRemoveGoodThatIsInStock() {
        // given
        initialMasterDataCreator.addAllGoods();
        UUID goodId = (UUID) GOOD_DATA[4][0];
        stockManagementUseCases.addToStock( goodId, 3 );

        // when
        // then
        assertThrows( ShopException.class, () -> goodCatalogUseCases.removeGoodFromCatalog( goodId ) );
    }


    @Test
    public void testClearGoodCatalog() {
        // given
        initialMasterDataCreator.addAllGoods();

        // when
        goodCatalogUseCases.deleteGoodCatalog();

        // then
        assertThrows( ShopException.class, () -> goodCatalogUseCases.getSalesPrice( (UUID) GOOD_DATA[4][0] ) );
    }

}


--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\test\java\thkoeln\archilab\ecommerce\regression\RegressionStockManagementTest.java ---
package thkoeln.archilab.ecommerce.regression;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
import thkoeln.archilab.ecommerce.usecases.StockManagementUseCases;

import javax.transaction.Transactional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.GOOD_STOCK;
import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.GOOD_DATA;

@SpringBootTest
@Transactional
public class RegressionStockManagementTest {

    @Autowired
    private StockManagementUseCases stockManagementUseCases;
    @Autowired
    private InitialMasterDataCreator initialMasterDataCreator;


    @BeforeEach
    public void setUp() {
        initialMasterDataCreator.deleteAll();
        initialMasterDataCreator.addAllGoods();
    }



    @Test
    public void testAddToStock() {
        // given
        initialMasterDataCreator.stockUpAllGoods();
        UUID goodId8 = (UUID) GOOD_DATA[8][0];

        // when
        int stock8before = stockManagementUseCases.getAvailableStock( goodId8 );
        assertEquals( GOOD_STOCK.get( goodId8 ), stock8before );
        stockManagementUseCases.addToStock( goodId8, 22 );
        int stock8after = stockManagementUseCases.getAvailableStock( goodId8 );
        stockManagementUseCases.addToStock( goodId8, 1 );
        int stock8after2 = stockManagementUseCases.getAvailableStock( goodId8 );

        // then
        assertEquals( stock8before + 22, stock8after );
        assertEquals( stock8after + 1, stock8after2 );
    }


    @Test
    public void testRemoveFromStock() {
        // given
        initialMasterDataCreator.stockUpAllGoods();
        UUID goodId6 = (UUID) GOOD_DATA[6][0];
        int stock6before = GOOD_STOCK.get( goodId6 );
        UUID goodId9 = (UUID) GOOD_DATA[9][0];
        int stock9before = GOOD_STOCK.get( goodId9 );
        UUID goodId1 = (UUID) GOOD_DATA[1][0];
        int stock1before = GOOD_STOCK.get( goodId1 );

        // when
        stockManagementUseCases.removeFromStock( goodId6, 1 );
        int stock6after = stockManagementUseCases.getAvailableStock( goodId6 );
        stockManagementUseCases.removeFromStock( goodId1, 3 );
        int stock1after = stockManagementUseCases.getAvailableStock( goodId1 );
        stockManagementUseCases.removeFromStock( goodId9, stock9before );
        int stock9after = stockManagementUseCases.getAvailableStock( goodId9 );

        // then
        assertEquals( stock6before - 1, stock6after );
        assertEquals( stock1before - 3, stock1after );
        assertEquals( 0, stock9after );
    }

}


[RESPONSE]:
Hier sind die gefundenen Code Smells, gruppiert nach Datei:

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Email.java ---
Duplication:
- Original: Zeile 20: `String regexPattern = "^[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*\\.(de|at|ch|com|org)$";`
- Dupliziert: Zeile 34: `String regexPattern = "^[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*\\.(de|at|ch|com|org)$";`
Grund: Der reguläre Ausdruck für die E-Mail-Validierung wird an zwei Stellen hartkodiert. Dies sollte in einer Konstante oder einer wiederverwendbaren Validierungsmethode zentralisiert werden.

Negative conditionals:
- Zeile 35: `if (emailString.matches(regexPattern)) { return true; } else { return false; }`
Grund: Die Bedingung ist unnötig doppelt negativ/komplex. Es kann direkt `return emailString.matches(regexPattern);` geschrieben werden.

Dead code:
- Zeile 28: `public static String asString(EmailType emailType)`
Grund: Die Methode `asString` wird innerhalb des bereitgestellten Codes nirgends aufgerufen.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
Duplication:
- Original: Zeile 70-71: `newMoneyType.amount = newAmount; newMoneyType.currency = this.currency;`
- Dupliziert: Zeile 90-91: `newMoneyType.amount = newAmount; newMoneyType.currency = this.currency;`
- Dupliziert: Zeile 108-109: `newMoneyType.amount = newAmount; newMoneyType.currency = this.currency;`
Grund: Die Zuweisung von Betrag und Währung an ein neues Money-Objekt ist in den Methoden `add`, `subtract` und `multiplyBy` dupliziert. Dies könnte durch eine private Hilfsmethode oder einen geeigneten Konstruktor vereinfacht werden.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\masterdata\FactoryMethodInvoker.java ---
Duplication:
- Original Block 1: Zeilen 20-30
    ```java
    try {
        Class<?> interfaceClass = Class.forName(
                "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.EmailType" );
        Class<?> implementingClass = findImplementation( interfaceClass );

        factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
        assertNotNull( factoryMethod );
        int modifiers = factoryMethod.getModifiers();
        assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
    } catch (Exception e) {
        fail( "Failed to find implementation for EmailType", e );
    }
    ```
- Duplizierter Block 1: Zeilen 42-52
    ```java
    try {
        Class<?> interfaceClass = Class.forName(
                "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.HomeAddressType" );
        Class<?> implementingClass = findImplementation( interfaceClass );

        factoryMethod = implementingClass.getDeclaredMethod( "of",
                String.class, String.class, PostalCodeType.class );
        assertNotNull( factoryMethod );
        int modifiers = factoryMethod.getModifiers();
        assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
    } catch (Exception e) {
        fail( "Failed to find implementation for HomeAddressType", e );
    }
    ```
- Duplizierter Block 2: Zeilen 64-74
    ```java
    try {
        Class<?> interfaceClass = Class.forName(
                "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PostalCodeType" );
        Class<?> implementingClass = findImplementation( interfaceClass );

        factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
        assertNotNull( factoryMethod );
        int modifiers = factoryMethod.getModifiers();
        assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
    } catch (Exception e) {
        fail( "Failed to find implementation for PostalCodeType", e );
    }
    ```
- Duplizierter Block 3: Zeilen 86-96
    ```java
    try {
        Class<?> interfaceClass = Class.forName(
                "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType" );
        Class<?> implementingClass = findImplementation( interfaceClass );

        factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
        assertNotNull( factoryMethod );
        int modifiers = factoryMethod.getModifiers();
        assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
    } catch (Exception e) {
        fail( "Failed to find implementation for MoneyType", e );
    }
    ```
Grund: Der Code-Block zum Auffinden der Implementierungsklasse und der Factory-Methode sowie zur Validierung der Methode ist in allen `instantiateX` Methoden fast identisch. Dies sollte in eine generische Hilfsmethode extrahiert werden.

Duplication:
- Original Block 1: Zeilen 31-36
    ```java
    Object instance = null;
    try {
        instance = factoryMethod.invoke( null, emailAsString );
    } catch (Exception e) {
        if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                instanceof ShopException ) throw new ShopException( e.getMessage() );
        fail( "Failed to invoke factory method 'of' for '" + emailAsString + "'", e );
    }
    ```
- Duplizierter Block 1: Zeilen 53-59
    ```java
    Object instance = null;
    try {
        instance = factoryMethod.invoke( null, street, city, postalCode );
    } catch (Exception e) {
        if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                instanceof ShopException ) throw new ShopException( e.getMessage() );
        fail( "Failed to invoke factory method 'of' for '" +
                street + "', '" + city + "', '" + postalCode + "'", e );
    }
    ```
- Duplizierter Block 2: Zeilen 75-80
    ```java
    Object instance = null;
    try {
        instance = factoryMethod.invoke( null, postalCodeAsString );
    } catch (Exception e) {
        if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                instanceof ShopException ) throw new ShopException( e.getMessage() );
        fail( "Failed to invoke factory method 'of' for '" + postalCodeAsString + "'", e );
    }
    ```
- Duplizierter Block 3: Zeilen 97-102
    ```java
    Object instance = null;
    try {
        instance = factoryMethod.invoke( null, amount, currency );
    } catch (Exception e) {
        if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
                instanceof ShopException ) throw new ShopException( e.getMessage() );
        fail( "Failed to invoke factory method 'of' for '" + amount + "', '" + currency + "'", e );
    }
    ```
Grund: Der Code-Block zum Aufruf der Factory-Methode und zur Fehlerbehandlung ist in allen `instantiateX` Methoden fast identisch. Dies sollte in eine generische Hilfsmethode extrahiert werden.

Misplaced responsibility:
- Zeilen 16, 26, 35, 48, 58, 70, 79, 92, 101, 116, 120
Grund: Die Klasse `FactoryMethodInvoker` befindet sich im `main/java`-Verzeichnis, verwendet aber JUnit-Assertions (`assertNotNull`, `assertTrue`, `fail`). Dies deutet darauf hin, dass es sich um eine Test-Hilfsklasse handelt, die in `test/java` verschoben werden sollte.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\masterdata\InitialMasterDataCreator.java ---
Misplaced responsibility:
- Zeile 163: `public enum InvalidReason`
Grund: Die `InvalidReason` Enum ist in einer MasterData-Erstellungsklasse definiert. Dies ist eine generische Hilfs-Enum, die besser in ein Utility-Paket oder ein gemeinsam genutztes Domain-Primitive-Paket passen würde, wenn sie außerhalb dieses Kontexts wiederverwendbar ist. Wenn sie nur hier verwendet wird, ist die Verschachtelung in der Klasse in Ordnung, aber sie fühlt sich generisch genug an, um an anderer Stelle besser aufgehoben zu sein.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\masterdata\MockClient.java ---
Misplaced responsibility:
- Zeile 1: `package thkoeln.archilab.ecommerce.masterdata;`
Grund: `MockClient` ist eine Mock-Implementierung von `ClientType`. Mocks und Test-Utilities sollten im `test/java`-Verzeichnis liegen, nicht im `main/java`-Verzeichnis.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\client\application\ClientRegistrationService.java ---
Duplication:
- Original: Zeile 38-39: `if (email == null) { throw new ShopException("Email is missing or Null"); }`
- Dupliziert: Zeile 68-69 (in `PaymentService.java`): `if (clientEmail == null) { throw new ShopException("Client Email is invalid!"); }`
- Dupliziert: Zeile 272-273 (in `PaymentService.java`): `if (clientEmail == null) { throw new ShopException("Client Email is invalid!"); }`
- Dupliziert: Zeile 342-343 (in `ShoppingBasketService.java`): `if (clientEmail == null) { throw new ShopException("ClientEmail / Client does not exist!"); }`
Grund: Die Null-Prüfung für E-Mail-Objekte ist an mehreren Stellen in verschiedenen Services dupliziert. Diese Validierung sollte in einer zentralen Methode oder direkt im `Email` Domain Primitive erfolgen.

Shared persistency:
- Zeile 35: `List<Email> registeredMails = new ArrayList<>();`
Grund: Die `registeredMails`-Liste in `ClientRegistrationService` dupliziert die Funktionalität des `ClientRepository` zur Überprüfung existierender E-Mails. Dies ist eine redundante In-Memory-Verwaltung von Persistenzdaten und kann zu Inkonsistenzen führen. Die Überprüfung sollte ausschließlich über das Repository erfolgen.

Misplaced responsibility:
- Zeile 65: `public Client findByEmail(Email email)`
Grund: Die Methode `findByEmail` in einem Anwendungsservice gibt direkt ein Domain-Entität (`Client`) zurück und agiert als einfacher Proxy für das Repository. Anwendungsservices sollten idealerweise DTOs oder Domain-Primitive-Interfaces zurückgeben, um die Kapselung der Domain-Schicht zu wahren.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\Client.java ---
Anemic Entity:
-Anemic Entity-
Grund: Die `Client`-Entität besteht hauptsächlich aus Gettern und Settern (generiert durch Lombok) und enthält keine nennenswerte Domänenlogik oder Verhalten. Sie dient primär als Datenhalter.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\client\domain\DeliveryRecipientClient.java ---
Anemic Entity:
-Anemic Entity-
Grund: Die `DeliveryRecipientClient`-Entität erbt die anämische Struktur von `Client` und fügt keine signifikante Domänenlogik hinzu. Die `create`-Methode ist eine Factory, aber die Entität selbst bleibt ein reiner Datenhalter.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\application\DeliveryService.java ---
Shared persistency:
- Zeile 40: `deliveryRecipientClientRepository.findByEmail((Email) deliveryRecipient.getEmail())`
Grund: Der `DeliveryService` (Anwendungsschicht) greift direkt auf das `DeliveryRecipientClientRepository` (Domänenschicht eines *anderen* Pakets `client`) zu. Ein Anwendungsservice sollte über Use Case-Interfaces mit anderen Domänen kommunizieren, nicht deren Repositories direkt abfragen.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\Delivery.java ---
Anemic Entity:
-Anemic Entity-
Grund: Die `Delivery`-Entität besteht hauptsächlich aus Gettern und Settern (generiert durch Lombok) und enthält keine nennenswerte Domänenlogik oder Verhalten. Sie dient primär als Datenhalter.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\application\GoodBuyableInterface.java ---
Negative conditionals:
- Zeile 8: `boolean goodNotExists(UUID goodId);`
Grund: Der Methodenname enthält eine Negation (`goodNotExists`), was die Lesbarkeit und das Verständnis erschweren kann. `boolean goodExists(UUID goodId);` wäre klarer und würde die umgekehrte Logik im Implementierungscode behandeln.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\application\GoodCatalogService.java ---
Dead code:
- Zeile 42: `List<Good> test = goodRepository.findAll();`
Grund: Die Variable `test` wird deklariert und initialisiert, aber anschließend nie verwendet.

Shared persistency:
- Zeile 36: `if (warehouseRepository.count() == 0)`
- Zeile 38: `warehouseRepository.save(warehouse);`
- Zeile 40: `warehouse = warehouseRepository.findFirstByOrderByWarehouseIdAsc();`
- Zeile 49: `warehouse.setGoods(goodIntegerMap);`
- Zeile 50: `warehouseRepository.save(warehouse);`
Grund: Der `GoodCatalogService` verwaltet direkt das `Warehouse`-Repository und die `Warehouse`-Entität. Die Verwaltung des Lagerbestands (`Warehouse`) sollte in der Verantwortung des `StockManagementUseCases` liegen, nicht des `GoodCatalogService`. Dies ist ein Verstoß gegen die Kapselung und eine Verletzung der Zuständigkeit.

Misplaced responsibility:
- Zeile 54: `for (Good good : goodRepository.findAll()) { ... }`
- Zeile 61: `for (Good good : goodRepository.findAll()) { ... }`
Grund: Die Methoden `goodExists` und `getGoodByGoodId` durchlaufen alle Güter im Repository, anstatt spezifische Repository-Methoden wie `findById` oder eine benutzerdefinierte Query zu verwenden. Dies ist ineffizient und eine Fehlplatzierung der Verantwortung, da die Anwendungsschicht die Datenzugriffsschicht nicht auf diese Weise durchsuchen sollte.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\application\StockManagementService.java ---
Shared persistency:
- Zeile 26: `Warehouse warehouse = new Warehouse();`
- Zeile 28: `warehouseRepository.save(warehouse);`
- Zeile 30: `warehouse = warehouseRepository.findFirstByOrderByWarehouseIdAsc();`
Grund: Der `StockManagementService` verwaltet direkt die `Warehouse`-Entität und das `WarehouseRepository`. Die `warehouse`-Instanz ist ein Zustand in einem Singleton-Service, was zu Problemen in Mehrbenutzerumgebungen führen kann. Die Erstellung und Verwaltung der `Warehouse`-Entität sollte besser in der Domänenschicht des `good`-Moduls gekapselt sein, eventuell durch eine Factory oder Domänen-Service-Methode, die vom Repository verwaltet wird.

Misplaced responsibility:
- Zeile 69: `shoppingBasketreservableInterface.adjustReservedGoodInShoppingbaskets(goodId, warehouseQuantityRemoved, currentlyReservedGoods);`
- Zeile 87: `shoppingBasketreservableInterface.adjustReservedGoodInShoppingbaskets(goodId, newTotalQuantity, currentlyReservedGoods);`
Grund: Der `StockManagementService` greift direkt auf die `ShoppingBasketreservableInterface` zu, um Reservierungen in Einkaufskörben anzupassen. Die Bestandsverwaltung sollte keine direkte Kenntnis von den Details der Einkaufskörbe haben. Stattdessen sollte sie ein Domänenereignis auslösen (z. B. `StockAdjustedEvent`), auf das der `ShoppingBasketService` reagiert, um seine Reservierungen anzupassen. Dies verletzt die Kapselung und die Domänengrenzen.

Negative conditionals:
- Zeile 36: `if (!goodCatalogService.goodExists(goodId) || addedQuantity < 0)`
Grund: Die Verwendung von `!goodCatalogService.goodExists(goodId)` ist eine verständliche Negation, aber `goodExists` wäre ein klarerer Methodenname.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\domain\Catalog.java ---
Anemic Entity:
-Anemic Entity-
Grund: Die `Catalog`-Entität besteht hauptsächlich aus Gettern und Settern (generiert durch Lombok) und enthält keine nennenswerte Domänenlogik oder Verhalten. Sie dient primär als Datenhalter.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\domain\Good.java ---
Anemic Entity:
-Anemic Entity-
Grund: Die `Good`-Entität besteht hauptsächlich aus Gettern und Settern (generiert durch Lombok) und enthält keine nennenswerte Domänenlogik oder Verhalten. Sie dient primär als Datenhalter. `getSalesPriceAmount()` ist ein einfacher Getter.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\domain\GoodRepository.java ---
Dead code:
- Zeile 15: `MoneyType findByGoodId(UUID goodId);`
Grund: Die Methode `findByGoodId` wird innerhalb des bereitgestellten Codes nirgends aufgerufen und hat einen ungewöhnlichen Rückgabetyp (`MoneyType`) für ein Repository, das normalerweise Entitäten zurückgibt.

Duplication:
- Original: Zeile 19: `Good findGoodByGoodId(UUID goodId);`
- Dupliziert: `findById(UUID goodId)` (standard JPA CrudRepository Methode)
Grund: Die Methode `findGoodByGoodId` ist eine Duplikation der von `CrudRepository` bereitgestellten `findById`-Methode.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\good\domain\Warehouse.java ---
Anemic Entity:
-Anemic Entity-
Grund: Die `Warehouse`-Entität besteht hauptsächlich aus Gettern und Settern (generiert durch Lombok) und enthält keine nennenswerte Domänenlogik oder Verhalten. `getLagerbestand` ist eine einfache Map-Abfrage. Sie kapselt keine Geschäftsregeln für die Bestandsverwaltung.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderDTOMapperService.java ---
Misplaced responsibility:
- Zeile 23: `orderDTO.setClient(order.getClient());`
Grund: Ein DTO sollte in der Regel keine vollständigen Domänenentitäten (`Client`) enthalten, da dies die Kapselung der Domänenschicht verletzt und zu unerwünschten Abhängigkeiten führen kann. Stattdessen sollte ein `ClientDTO` oder nur relevante Client-Attribute im `OrderDTO` verwendet werden.

Misplaced responsibility:
- Zeile 31: `orderDTO.setSubmissionDate(LocalDateTime.now());`
Grund: Das Setzen des aktuellen Zeitstempels (`LocalDateTime.now()`) ist ein Seiteneffekt und eine Geschäftslogik, die nicht in einem Mapper stattfinden sollte. Der `submissionDate` sollte zum Zeitpunkt der Erstellung oder Übermittlung des Auftrags in der Domänen- oder Anwendungsschicht festgelegt werden.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderRESTController.java ---
Misplaced responsibility:
- Zeilen 43-52: `public OrderDTO getLatestOrder(List<OrderDTO> orderDTOs) { ... }`
Grund: Die Logik zum Auffinden der neuesten Bestellung gehört in die Anwendungsschicht (`OrderService`) oder sogar in das `OrderRepository`, um die Kapselung der Geschäftslogik zu verbessern und die REST-Controller schlank zu halten.

Negative conditionals:
- Zeile 29: `if (email != null && !Email.isValidFormat(email))`
Grund: Die Bedingung `!Email.isValidFormat(email)` ist eine verständliche Negation.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderService.java ---
Dead code:
- Zeile 24: `public List<Order> findLatestForClient(EmailType clientEmail)`
Grund: Die Methode `findLatestForClient` wird innerhalb des bereitgestellten Codes nirgends aufgerufen.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java ---
Anemic Entity:
-Anemic Entity-
Grund: Die `Order`-Entität besteht hauptsächlich aus Gettern und Settern (generiert durch Lombok) und enthält keine nennenswerte Domänenlogik oder Verhalten. `getTotalOrderPrice()` bietet einen Standardwert, aber es fehlen Methoden, die Geschäftsregeln kapseln.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderRepository.java ---
Dead code:
- Zeile 16: `Order findByClientId(UUID clientId);`
- Zeile 22: `List<Order> findAllByClientId(UUID clientId);`
Grund: Die Methoden `findByClientId` und `findAllByClientId` werden innerhalb des bereitgestellten Codes nirgends aufgerufen.

Duplication:
- Original: Zeile 19: `Order findByClientEmail(EmailType email);`
- Dupliziert: Zeile 25: `List<Order> findAllByClientEmail(EmailType email);`
Grund: Die Methode `findByClientEmail` ist redundant, da `findAllByClientEmail` bereits alle Bestellungen für eine E-Mail zurückgibt, und der Singularfall einfach durch das Abrufen des ersten Elements der Liste behandelt werden könnte, falls dies die Absicht war.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\orderPosition\application\OrderPositionService.java ---
Misplaced responsibility:
- Zeile 22: `Float result = quantity * goodCatalogService.getSalesPrice(goodId).getAmount();`
Grund: Die Berechnung des Gesamtpreises für eine Bestellposition ist Geschäftslogik, die idealerweise in der Domänenentität `OrderPosition` selbst (wenn diese nicht anämisch wäre) oder einem Domänendienst gekapselt sein sollte. Im Anwendungsservice ist sie fehl am Platz und trägt zur Anämie der Entitäten bei.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\orderPosition\application\OrderPostionDTOMapperService.java ---
Duplication:
- Original Block 1: Zeilen 14-19
    ```java
    public OrderPositionDTO mapToDTO(OrderPosition orderPosition){
        OrderPositionDTO orderPositionDTO = new OrderPositionDTO();
        orderPositionDTO.setGoodId(orderPosition.getGoods().entrySet().stream().findFirst().get().getKey());
        orderPositionDTO.setComment(orderPosition.getComment());
        orderPositionDTO.setQuantity(orderPosition.getGoods().entrySet().stream().findFirst().get().getValue());
        orderPositionDTO.setTotalAmount(orderPosition.getTotalAmount());
        return orderPositionDTO;
    }
    ```
- Duplizierter Block 1: Zeilen 32-37
    ```java
    for (OrderPosition orderPosition : orderPositions) {
        OrderPositionDTO orderPositionDTO = new OrderPositionDTO();
        orderPositionDTO.setGoodId(orderPosition.getGoods().entrySet().stream().findFirst().get().getKey());
        orderPositionDTO.setQuantity(orderPosition.getGoods().entrySet().stream().findFirst().get().getValue());
        orderPositionDTO.setComment(orderPosition.getComment());
        orderPositionDTO.setTotalAmount(orderPosition.getTotalAmount());
    }
    ```
Grund: Die Mapping-Logik von `OrderPosition` zu `OrderPositionDTO` wird in `mapToDTO` und `mapListToDTO` dupliziert. Die `mapListToDTO`-Methode ist zudem fehlerhaft, da sie immer eine leere Liste zurückgibt.

Dead code:
- Zeilen 30-38: `public List<OrderPositionDTO> mapListToDTO(List<OrderPosition> orderPositions){ ... return new ArrayList<>(); }`
Grund: Die Methode `mapListToDTO` enthält eine Schleife, die `OrderPositionDTO`-Objekte erstellt und konfiguriert, aber am Ende immer eine leere `ArrayList` zurückgibt. Der gesamte Code innerhalb der Schleife ist effektiv tot, da seine Ergebnisse verworfen werden.

Duplication:
- Original Block 1: Zeilen 22-29
    ```java
    public Order mapToEntity(OrderDTO orderDTO) {
        Order order = new Order(orderDTO.getOrderId(),
                orderDTO.getClient(),
                orderDTO.getPrice(),
                orderPostionDTOMapperService.mapListToEntity(orderDTO.getOrderPositions()));
        return order;
    }
    ```
- Duplizierter Block 1: Zeilen 44-52
    ```java
    for (OrderPositionDTO orderPositionDTO : orderPositionDTOS) {
        Map<UUID, Integer> goods = new HashMap<>();
        goods.put(orderPositionDTO.getGoodId(), orderPositionDTO.getQuantity());
        OrderPosition orderPosition = new OrderPosition(
                orderPositionDTO.getGoodId(),
                orderPositionDTO.getTotalAmount(),
                orderPositionDTO.getComment(),
                goods
                );
            orderPositions.add(orderPosition);
    }
    ```
Grund: Die Mapping-Logik von `OrderPositionDTO` zu `OrderPosition` wird in `mapToEntity` und `mapListToEntity` dupliziert.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\orderPosition\domain\OrderPosition.java ---
Anemic Entity:
-Anemic Entity-
Grund: Die `OrderPosition`-Entität besteht hauptsächlich aus Gettern und Settern (generiert durch Lombok) und enthält keine nennenswerte Domänenlogik oder Verhalten. Sie dient primär als Datenhalter.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\orderPosition\domain\OrderPositionRepository.java ---
Dead code:
- Zeile 14: `//@Query("SELECT op FROM OrderPosition op WHERE op.order.client.email = :email") //List<OrderPosition> findAllByOrderClientEmail(EmailType email);`
Grund: Die auskommentierte Query-Methode deutet auf eine nicht genutzte oder entfernte Funktionalität hin.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\payment\application\AuthorizablePaymentService.java ---
Misplaced responsibility:
- Zeile 12: `paymentService.authorizePayment(email, cartValue);`
Grund: `AuthorizablePaymentService` ist ein einfacher Proxy-Service, der die Anfrage direkt an `PaymentService` weiterleitet. Wenn `PaymentService` bereits das `AuthorizablePaymentInterface` implementieren könnte, wäre diese Wrapper-Klasse redundant.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\payment\application\PaymentService.java ---
Shared persistency:
- Zeile 40: `if (clientRepository.findByEmail((Email) clientEmail) == null)`
- Zeile 51: `if (clientRepository.findByEmail((Email) clientEmail) == null)`
Grund: Der `PaymentService` (Anwendungsschicht) greift direkt auf das `ClientRepository` (Domänenschicht eines *anderen* Pakets `client`) zu. Ein Anwendungsservice sollte über Use Case-Interfaces mit anderen Domänen kommunizieren, nicht deren Repositories direkt abfragen.

Duplication:
- Original: Zeile 37-39: `if (clientEmail == null) { throw new ShopException("Client Email is invalid!"); }`
- Dupliziert: Zeile 49-51: `if (clientEmail == null) { throw new ShopException("Client Email is invalid!"); }`
Grund: Die Validierung des `clientEmail` auf Null und Existenz ist in den Methoden `authorizePayment` und `getPaymentTotal` dupliziert. Diese Logik sollte in eine private Hilfsmethode extrahiert werden.

Dead code:
- Zeile 70: `public void deletePaymentHistory()`
Grund: Die Methode `deletePaymentHistory` ist leer und führt keine Operationen aus.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\payment\domain\Payment.java ---
Anemic Entity:
-Anemic Entity-
Grund: Die `Payment`-Entität besteht hauptsächlich aus Gettern und Settern (generiert durch Lombok) und enthält keine nennenswerte Domänenlogik oder Verhalten. Sie dient primär als Datenhalter.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\GoodBuyableService.java ---
Negative conditionals:
- Zeile 14: `public boolean goodNotExists(UUID goodId) { return !goodCatalogService.goodExists(goodId); }`
Grund: Der Methodenname `goodNotExists` ist eine Negation, was die Lesbarkeit erschwert. Es wäre klarer, eine Methode `goodExists` zu verwenden und die Negation an der Aufrufstelle zu handhaben.

Misplaced responsibility:
- Zeile 11: `@Autowired GoodCatalogService goodCatalogService;`
Grund: `GoodBuyableService` dient als einfacher Proxy für `GoodCatalogService`. Wenn `GoodCatalogService` das `GoodBuyableInterface` implementieren könnte, wäre diese Wrapper-Klasse redundant. Dies ist eine unnötige Schicht der Indirektion.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingbasketDTOMapperService.java ---
Misplaced responsibility:
- Zeile 20: `clientRegistrationService.findByEmail(shoppingbasketDTO.getEmail())`
Grund: Ein Mapper sollte primär für die Transformation von Objekten zuständig sein und keine Geschäftslogik oder Datenabrufe durchführen. Der Aufruf von `clientRegistrationService.findByEmail` innerhalb des Mappers ist eine Fehlplatzierung der Verantwortung und führt zu einer Abhängigkeit von einem Anwendungsservice.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketHelperClassCleanCodeService.java ---
Misplaced responsibility:
- Zeile 25: `public class ShoppingBasketHelperClassCleanCodeService`
Grund: Der Name der Klasse ("HelperClassCleanCodeService") deutet auf eine "God Class" hin, die zu viele Verantwortlichkeiten bündelt. Solche Klassen sind schwer zu warten und zu testen.

Shared persistency:
- Zeile 31: `if (shoppingBasketRepository.findByClientId(client.getClientId()) == null)`
- Zeile 36: `clientRepository.save(client);`
- Zeile 81: `if (clientRepository.findByEmail(clientEmail) == null)`
- Zeile 89: `if (clientRepository.findByEmail(searchEmail) == null)`
- Zeile 92: `if (clientRepository.findByEmail(searchEmail) != null && shoppingBasketRepository.findByEmail(searchEmail) == null )`
Grund: Die `ShoppingBasketHelperClassCleanCodeService` greift direkt auf das `ClientRepository` zu, um Client-Daten abzurufen und zu speichern. Dies ist ein Verstoß gegen die Kapselung und eine Shared Persistency, da die Dienstklasse eines anderen Domänenmoduls (Client) direkt in die Persistenzschicht eingreift. Dies sollte über die `ClientRegistrationUseCases` erfolgen.

Duplication:
- Original: Zeile 79-82: `public void checkIfClientExsists(Email clientEmail) { if (clientRepository.findByEmail(clientEmail) == null) { throw new ShopException("ShoppingBasket is empty or does not exist!"); } }`
- Dupliziert: Zeile 84-87: `public void checkIfClientShoppingBasketExsists(EmailType clientEmail) { if (shoppingBasketRepository.findByEmail(clientEmail) == null) { throw new ShopException("ShoppingBasket is empty or does not exist!"); } }`
Grund: Die Validierung, ob ein Client oder ein Warenkorb existiert, ist in `checkIfClientExsists` und `checkIfClientShoppingBasketExsists` sehr ähnlich. Die Fehlerbehandlung und die Meldung sind identisch, obwohl sie sich auf verschiedene Entitäten beziehen. Dies könnte zu Verwirrung führen und sollte in generische Validierungsmethoden mit spezifischeren Nachrichten ausgelagert werden.

Misplaced responsibility:
- Zeilen 61-65: `float f = 0.0f; for (ShoppingBasketPosition position : shoppingBasketPositions) { Float positionTotalPrice = position.getQuantity() * position.getGood().getSalesPrice().getAmount(); f += positionTotalPrice; } Money totalPrice = new Money(f, "EUR");`
Grund: Die Logik zur Berechnung des Gesamtpreises des Warenkorbs sollte in der `ShoppingBasket`-Entität selbst gekapselt sein, anstatt in einer externen Hilfsklasse. Dies ist ein Zeichen für eine anämische Domänenentität und eine Fehlplatzierung der Verantwortung.

Misplaced responsibility:
- Zeile 66: `shoppingBasket.setTotalQuantity(shoppingBasket.getTotalQuantity() + quantity);`
Grund: Die direkte Manipulation der `totalQuantity` in der `ShoppingBasket`-Entität von außen ist eine Fehlplatzierung der Verantwortung. `ShoppingBasket` sollte Methoden bereitstellen, die solche Änderungen intern verwalten, um seine Konsistenz zu gewährleisten.

Misplaced responsibility:
- Zeile 105: `public Order getOrCreateOrderForClientOrderPositions(Client client, List<OrderPosition> clientOrderPositions)`
Grund: Die Erstellung oder Aktualisierung einer Bestellung gehört in den `OrderService` (Anwendungsschicht des Order-Moduls) oder in eine dedizierte Factory, nicht in eine Hilfsklasse des ShoppingBasket-Moduls. Dies verletzt die Kapselung und die Domänengrenzen.

Misplaced responsibility:
- Zeile 119: `public ShoppingBasket getShoppingBasketForMail(String email)`
Grund: Die Logik zum Abrufen oder Erstellen eines Warenkorbs für eine E-Mail, einschließlich der Interaktion mit dem `ClientRepository`, sollte im `ShoppingBasketService` gekapselt sein, da dies eine Kernfunktionalität der Warenkorbverwaltung ist.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketPositionableService.java ---
Misplaced responsibility:
- Zeile 12: `public class ShoppingBasketPositionableService implements ShoppingBasketPositionableInterface`
Grund: `ShoppingBasketPositionableService` ist ein einfacher Proxy-Service für `ShoppingBasketPositionService` und `ShoppingBasketRepository`. Wenn `ShoppingBasketPositionService` bereits das `ShoppingBasketPositionableInterface` implementieren könnte, wäre diese Wrapper-Klasse redundant.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingbasketreservableService.java ---
Misplaced responsibility:
- Zeilen 30-38: `public int getAllReservedGoods(UUID goodId) { ... }`
- Zeilen 40-58: `public void adjustReservedGoodInShoppingbaskets(UUID goodId, int warehouseQuantityRemoved, int currentlyReservedGoods) { ... }`
Grund: Die Logik zum Abrufen und Anpassen reservierter Güter in *allen* Einkaufskörben ist komplex und involviert eine domänenübergreifende Iteration. Dies sollte nicht direkt in einem Anwendungsservice erfolgen. Stattdessen könnte ein Domänenereignis im `StockManagementService` ausgelöst werden, das dann von den einzelnen `ShoppingBasket`-Aggregaten (oder einem entsprechenden Domänen-Service) verarbeitet wird, um ihre eigenen Reservierungen anzupassen.

Duplication:
- Original Block 1: Zeilen 30-38
    ```java
    Iterable<ShoppingBasket> shoppingBaskets = shoppingBasketRepository.findAll();
    int currentlyReservedGoods = 0;
    for (ShoppingBasket shoppingBasket : shoppingBaskets) {
        for (ShoppingBasketPosition shoppingBasketPosition: shoppingBasket.getShoppingBasketPositions()) {
            if (shoppingBasketPosition.getGood().getGoodId().equals(goodId)) {
                currentlyReservedGoods += shoppingBasketPosition.getQuantity();
            }
        }
    }
    return currentlyReservedGoods;
    ```
- Duplizierter Block 1: Zeilen 43-58
    ```java
    for (ShoppingBasket basket : shoppingBaskets) {
        List<ShoppingBasketPosition> goodsFromBasket = basket.getShoppingBasketPositions();
        for (ShoppingBasketPosition shoppingBasketPosition: goodsFromBasket) {
            if (shoppingBasketPosition.getGood().getGoodId().equals(goodId)) {
                int goodQuantityInBasket = shoppingBasketPosition.getQuantity();
                if (newAvailableQuantity >= goodQuantityInBasket) {
                    newAvailableQuantity -= goodQuantityInBasket;
                    shoppingBasketPosition.setQuantity(goodQuantityInBasket);
                    //basket.setGoods(goodsFromBasket);
                    shoppingBasketRepository.save(basket);
                } else {
                    shoppingBasketPosition.setQuantity(newAvailableQuantity);
                    //basket.setGoods(goodsFromBasket);
                    shoppingBasketRepository.save(basket);
                }
            }
        }
    }
    ```
Grund: Die Schleifen zum Iterieren über alle `ShoppingBasket`s und deren `ShoppingBasketPosition`s sind in `getAllReservedGoods` und `adjustReservedGoodInShoppingbaskets` sehr ähnlich. Dies deutet auf eine fehlende Kapselung der Logik im `ShoppingBasket` selbst hin.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketRESTController.java ---
Negative conditionals:
- Zeile 40: `if (!Email.isValidFormat(email))`
Grund: Die Bedingung `!Email.isValidFormat(email)` ist eine verständliche Negation.

Misplaced responsibility:
- Zeile 83: `public ResponseEntity<ShoppingbasketDTO> addRemoveQuantityOfGoods(...)`
Grund: Die Methode `addRemoveQuantityOfGoods` im REST-Controller enthält komplexe Geschäftslogik zur Bestandsprüfung, Mengenaktualisierung und Preisberechnung. Diese Logik sollte in der Anwendungsschicht (`ShoppingBasketService`) oder der Domänenschicht (`ShoppingBasket`-Entität) gekapselt sein, anstatt direkt im Controller.

Dead code:
- Zeile 125: `int test = shoppingBasket.getShoppingBasketQuantity(goodId);`
Grund: Die Variable `test` wird deklariert und initialisiert, aber anschließend nie verwendet.

Misplaced responsibility:
- Zeilen 132-135: `if (shoppingBasket == null) { return ResponseEntity.status(HttpStatus.NOT_FOUND).body("ShoppingBasket does not exists!"); } else if (shoppingBasket.getShoppingBasketPositions().isEmpty()) { return ResponseEntity.status(HttpStatus.CONFLICT).body("ShoppingBasket has no Positions to checkout"); }`
- Zeilen 138-140: `if (!shoppingBasketService.isPaymentAuthorized(shoppingBasket.getClient().getEmail()) && shoppingBasket.getTotalQuantity() > 20) { return ResponseEntity.status(HttpStatus.CONFLICT).body("Der Warenkorb überschreitet das Zahlungslimit / Bestelllimit."); }`
- Zeilen 142-145: `if (shoppingBasket.getTotalCost().getAmount() > 500.0f) { return ResponseEntity.status(HttpStatus.CONFLICT).body("Der Warenkorb überschreitet das Zahlungslimit"); }`
- Zeilen 148-150: `if (totalCost > 500) { return ResponseEntity.status(HttpStatus.CONFLICT).build(); }`
Grund: Die Methode `checkoutShoppingBasket` enthält umfangreiche Validierungs- und Geschäftslogik, die in die Anwendungsschicht (`ShoppingBasketService`) oder Domänenschicht (`ShoppingBasket`-Entität) ausgelagert werden sollte. REST-Controller sollten sich auf die Entgegennahme von Anfragen, Validierung von Eingabeformaten und Delegierung an Anwendungsservices beschränken.

Duplication:
- Original Block 1: Zeilen 104-106
    ```java
    float totalPrice = 0.0f;
    int totalQuantity = 0;
    for (ShoppingBasketPositionDTO basketPositionDTO : shoppingBasketDTO.getOrderPositions()) {
        totalPrice += basketPositionDTO.getQuantity() * getSalesPriceForPositionGood(basketPositionDTO);
        totalQuantity += basketPositionDTO.getQuantity();
    }
    ```
- Duplizierter Block 1: Zeilen 142-145
    ```java
    float totalCost = 0.0f;
    for (ShoppingBasketPositionDTO position: shoppingbasketDTO.getOrderPositions()) {
        totalCost += position.getQuantity() * goodCatalogService.getSalesPrice(position.getGoodId()).getAmount();
    }
    ```
Grund: Die Logik zur Berechnung des Gesamtpreises des Warenkorbs ist in `addRemoveQuantityOfGoods` und `checkoutShoppingBasket` dupliziert. Diese Berechnung sollte eine Methode der `ShoppingBasket`-Entität oder des `ShoppingBasketService` sein.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java ---
Shared persistency:
- Zeile 97: `shoppingBasketHelperClassCleanCode.checkIfClientExsists((Email) clientEmail);`
- Zeile 114: `Client client = clientRepository.findByEmail((Email) clientEmail);`
- Zeile 126: `ShoppingBasket shoppingBasket = shoppingBasketRepository.findByClientId(client.getClientId());`
- Zeile 137: `Client client = clientRepository.findByEmail((Email) clientEmail);`
- Zeile 145: `validateClientEmail(clientEmail);` (intern ruft es `clientRepository.findByEmail` auf)
- Zeile 154: `validateClientEmail(clientEmail);` (intern ruft es `clientRepository.findByEmail` auf)
- Zeile 169: `validateClientEmail(clientEmail);` (intern ruft es `clientRepository.findByEmail` auf)
- Zeile 172: `validateClientEmail(clientEmail);` (intern ruft es `clientRepository.findByEmail` auf)
- Zeile 175: `Client client = clientRepository.findByEmail((Email) clientEmail);`
- Zeile 203: `clientRepository.save(clientRepository.findByEmail((Email) clientEmail));`
- Zeile 220: `validateClientEmail(clientEmail);` (intern ruft es `clientRepository.findByEmail` auf)
Grund: Der `ShoppingBasketService` greift direkt auf das `ClientRepository` zu, um Client-Daten abzurufen und zu validieren. Dies ist eine Shared Persistency und eine Layer Violation, da ein Service eines Domänenmoduls (ShoppingBasket) direkt in die Persistenzschicht eines anderen Domänenmoduls (Client) eingreift. Die Interaktion sollte über die `ClientRegistrationUseCases` erfolgen.

Duplication:
- Original Block 1: Zeilen 98-99
    ```java
    if (goodBuyableInterface.goodNotExists(goodId) || stockmanageableInterface.getAvailableStock(goodId) < 0) {
        throw new ShopException("Can not add nonExisting Good to clientShoppingBasket");
    }
    ```
- Duplizierter Block 1: Zeilen 107-108
    ```java
    if (goodBuyableInterface.goodNotExists(goodId) || stockmanageableInterface.getAvailableStock(goodId) < 0) {
        throw new ShopException("Can not add nonExisting Good to clientShoppingBasket");
    }
    ```
- Duplizierter Block 2: Zeilen 110-111
    ```java
    if (goodBuyableInterface.goodNotExists(goodId) && stockmanageableInterface.getAvailableStock(goodId) < quantity) {
        throw new ShopException("Can not add " + quantity + " of " + goodId + " to clientShoppingBasket, stock is too low");
    }
    ```
Grund: Die Validierung der Existenz eines Gutes und der Verfügbarkeit des Lagerbestands ist an mehreren Stellen in `addGoodToShoppingBasket` und `removeGoodFromShoppingBasket` dupliziert. Diese Logik sollte in einer zentralen Validierungsmethode gekapselt werden.

Duplication:
- Original Block 1: Zeilen 150-163 (`getCartValue`)
    ```java
    public MoneyType getCartValue(EmailType clientEmail) {
        validateClientEmail(clientEmail);
        ShoppingBasket shoppingBasket = shoppingBasketRepository.findByEmail(clientEmail);
        float totalAmountOfBasket = 0.0f;
        String currency = "EUR";
        for (ShoppingBasketPosition shoppingBasketPosition : shoppingBasket.getShoppingBasketPositions()) {
            UUID goodId = shoppingBasketPosition.getGood().getGoodId();
            Integer quantity = shoppingBasketPosition.getQuantity();
            MoneyType salesPriceOfGood = goodBuyableInterface.getSalesPrice(goodId);
            totalAmountOfBasket += quantity * salesPriceOfGood.getAmount();
            currency = salesPriceOfGood.getCurrency();
        }
        return new Money(totalAmountOfBasket, currency);
    }
    ```
- Duplizierter Block 1: Zeilen 166-187 (`getShoppingBasketAsMoneyValue`)
    ```java
    @Override
    public MoneyType getShoppingBasketAsMoneyValue(EmailType clientEmail) {
        //Check if client exists
        validateClientEmail(clientEmail);
        Client client = clientRepository.findByEmail((Email) clientEmail);
        ShoppingBasket shoppingBasket = shoppingBasketRepository.findByClientId(client.getClientId());
        List<ShoppingBasketPosition> goodsFromBasket = shoppingBasket.getShoppingBasketPositions();

        //Check if client shoppingBasket has goods
        if (shoppingBasket.getShoppingBasketPositions().isEmpty()) {
            throw new ShopException("Client has no Goods in shoppingBasket");
        }

        //Check if client has basket, if so use existing basket else create new one
        if (goodsFromBasket.isEmpty()) {
            shoppingBasket.setClient(client);
            Money initalCosts = new Money(0.0f, "EUR");
            shoppingBasket.setTotalCost(initalCosts);
            shoppingBasket.setShoppingBasketPositions(goodsFromBasket);
            shoppingBasketRepository.save(shoppingBasket);
            clientRepository.save(client);
        }

        goodsFromBasket = shoppingBasket.getShoppingBasketPositions();
        float sumOfBasket = 0.0f;
        String currency = "EUR";
        //foreach good in basket get salesPrice and sumOfBasket += g.salesPrice
        for (ShoppingBasketPosition shoppingBasketPosition : goodsFromBasket) {
            UUID goodId = shoppingBasketPosition.getGood().getGoodId();
            int quantity = shoppingBasketPosition.getQuantity();
            sumOfBasket += quantity * goodBuyableInterface.getSalesPrice(goodId).getAmount();
            currency = goodBuyableInterface.getSalesPrice(goodId).getCurrency();
        }
        return new Money(sumOfBasket, currency);
    }
    ```
Grund: Die Methoden `getCartValue` und `getShoppingBasketAsMoneyValue` haben eine fast identische Logik zur Berechnung des Gesamtwerts des Warenkorbs. Dies sollte in einer einzigen, wiederverwendbaren Methode gekapselt werden.

Misplaced responsibility:
- Zeilen 178-218: `public void checkout(EmailType clientEmail)`
Grund: Die `checkout`-Methode ist eine "God Method", die eine Vielzahl von Verantwortlichkeiten bündelt: Validierung, Zahlungsautorisierung, Bestandsverwaltung, Bestellungs- und Bestellpositionserstellung, sowie das Zurücksetzen des Warenkorbs. Diese komplexe Orchestrierung sollte in kleinere, fokussierte Methoden oder Domänendienste aufgeteilt werden, um die Lesbarkeit, Wartbarkeit und Testbarkeit zu verbessern.

Dead code:
- Zeile 238: `public void deleteAllOrders()`
Grund: Die Methode `deleteAllOrders` ist leer und führt keine Operationen aus.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\StockmanageableService.java ---
Misplaced responsibility:
- Zeile 15: `public class StockmanageableService implements StockmanageableInterface`
Grund: `StockmanageableService` ist ein einfacher Proxy-Service für `StockManagementService`. Wenn `StockManagementService` bereits das `StockmanageableInterface` implementieren könnte, wäre diese Wrapper-Klasse redundant. Dies ist eine unnötige Schicht der Indirektion.

Shared persistency:
- Zeile 20: `Integer quantity = warehouseRepository.findFirstByOrderByWarehouseIdAsc().getLagerbestand(goodId);`
Grund: Der `StockmanageableService` greift direkt auf das `WarehouseRepository` zu, um den Lagerbestand abzurufen. Dies ist ein Verstoß gegen die Kapselung und eine Shared Persistency, da ein Service eines Domänenmoduls (ShoppingBasket) direkt in die Persistenzschicht eines anderen Domänenmoduls (Good) eingreift.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\WarehouseGetableService.java ---
Misplaced responsibility:
- Zeile 10: `public class WarehouseGetableService implements WarehouseGetableInterface`
Grund: `WarehouseGetableService` ist ein einfacher Proxy-Service für `WarehouseRepository`. Wenn `WarehouseRepository` bereits die Methode `getLagerbestand` bereitstellt, wäre diese Wrapper-Klasse redundant. Dies ist eine unnötige Schicht der Indirektion.

Shared persistency:
- Zeile 15: `return warehouseRepository.findFirstByOrderByWarehouseIdAsc().getLagerbestand(goodId);`
Grund: Der `WarehouseGetableService` greift direkt auf das `WarehouseRepository` zu, um den Lagerbestand abzurufen. Dies ist ein Verstoß gegen die Kapselung und eine Shared Persistency, da ein Service eines Domänenmoduls (ShoppingBasket) direkt in die Persistenzschicht eines anderen Domänenmoduls (Good) eingreift.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java ---
Anemic Entity:
-Anemic Entity-
Grund: Die `ShoppingBasket`-Entität besteht hauptsächlich aus Gettern und Settern (generiert durch Lombok) und enthält nur minimale Geschäftslogik (`getShoppingBasketQuantity`, `getTotalAmount`). Sie sollte Methoden haben, die das Hinzufügen/Entfernen von Elementen, die Aktualisierung des Gesamtpreises und der Menge sowie Zustandsübergänge kapseln.

Layer violation:
- Zeile 53: `@Query("SELECT sbp FROM ShoppingBasket sbp WHERE sbp.shoppingBasketId = :shoppingbasketId") ArrayList<ShoppingBasketPosition> findAllByShoppingBasketId(UUID shoppingbasketId);` (in ShoppingBasketRepository.java)
Grund: Eine Methode in einem Repository für `ShoppingBasket` sollte `ShoppingBasket`-Entitäten verwalten und zurückgeben. Die Abfrage, die direkt `ShoppingBasketPosition`-Entitäten abruft, verletzt das Prinzip, dass Repositories Aggregate Roots verwalten sollten und die inneren Entitäten eines Aggregats nicht direkt exponieren sollten. Dies ist eine Layer Violation, da das Repository die Struktur des Aggregats durchbricht.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingBasketPosition\application\ShoppingBasketPositionDTOMapperService.java ---
Duplication:
- Original Block 1: Zeilen 17-21
    ```java
    public ShoppingBasketPositionDTO mapToDTO(ShoppingBasketPosition shoppingBasketPosition){
        ShoppingBasketPositionDTO shoppingBasketPositionDTO = new ShoppingBasketPositionDTO();
        shoppingBasketPositionDTO.setQuantity(shoppingBasketPosition.getQuantity());
        shoppingBasketPositionDTO.setGoodId(shoppingBasketPosition.getGood().getGoodId());
        shoppingBasketPositionDTO.setComment(shoppingBasketPosition.getComment());
        return shoppingBasketPositionDTO;
    }
    ```
- Duplizierter Block 1: Zeilen 28-32
    ```java
    for (ShoppingBasketPosition shoppingBasketPosition : shoppingBasketPositions) {
        ShoppingBasketPositionDTO shoppingBasketPositionDTO = new ShoppingBasketPositionDTO();
        shoppingBasketPositionDTO.setQuantity(shoppingBasketPosition.getQuantity());
        shoppingBasketPositionDTO.setGoodId(shoppingBasketPosition.getGood().getGoodId());
        shoppingBasketPositionDTO.setComment(shoppingBasketPosition.getComment());
        shoppingBasketPositionDTOS.add(shoppingBasketPositionDTO);
    }
    ```
Grund: Die Mapping-Logik von `ShoppingBasketPosition` zu `ShoppingBasketPositionDTO` ist in `mapToDTO` und `mapListToDTO` dupliziert.

Shared persistency:
- Zeile 39: `goodRepository.findGoodByGoodId(shoppingBasketPositionDTO.getGoodId())`
- Zeile 49: `goodRepository.findGoodByGoodId(shoppingBasketPositionDTO.getGoodId())`
Grund: Der Mapper greift direkt auf das `GoodRepository` zu, um eine `Good`-Entität abzurufen. Mapper sollten zustandslos sein und keine Datenabrufe durchführen. Dies ist eine Shared Persistency und eine Fehlplatzierung der Verantwortung.

Misplaced responsibility:
- Zeile 36: `UUID.randomUUID(),`
- Zeile 46: `UUID.randomUUID(),`
Grund: Die Generierung einer neuen UUID für die `shoppingBasketPositionId` sollte nicht im Mapper erfolgen. Dies ist eine Verantwortung der Entität selbst (z. B. im Konstruktor) oder des Persistenzmechanismus, um sicherzustellen, dass IDs korrekt und konsistent zugewiesen werden.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingBasketPosition\application\ShoppingBasketPositionService.java ---
Misplaced responsibility:
- Zeile 25: `public void safeShoppingbasketPosition(ShoppingBasketPosition shoppingBasketPosition)`
Grund: Der Methodenname `safeShoppingbasketPosition` enthält einen Tippfehler. Er sollte `saveShoppingBasketPosition` lauten.

--- FILE: C:\workspace\Masterarbeit\Repositories\ST2M4_group_13fb5450-bcb2-4392-bce6-c331d6d2b317\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingBasketPosition\domain\ShoppingBasketPosition.java ---
Anemic Entity:
-Anemic Entity-
Grund: Die `ShoppingBasketPosition`-Entität besteht hauptsächlich aus Gettern und Settern (generiert durch Lombok) und enthält keine nennenswerte Domänenlogik oder Verhalten. Sie dient primär als Datenhalter.

Ende
-----------------------------------