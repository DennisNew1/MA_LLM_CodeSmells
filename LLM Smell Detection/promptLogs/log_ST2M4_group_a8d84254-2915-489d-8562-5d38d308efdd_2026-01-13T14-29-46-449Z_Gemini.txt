--- DATE: 13.1.2026, 15:29:46 ---

[PROMPT]:
Du bist ein erfahrener Java-Reviewer.
        Architektur: 4-Layer (Eric Evans).
        Aufgabe: Finde folgende Smells: Duplication: duplizierte Codestücke die mehrmals vorkommen und eingespart werden könnten. Gib hierbei sowohl die duplizierte als auch die originale Zeile an. Bei längeren kopierten Abschnitten gib auch hier die Zeilen als Bereich an.  negative conditionals: Es handelt sich hierbei um negativ oder doppelt negativ formulierte Bedingungen und Variablen. Einfach formulierte Negierungen in if-Anweisungen sind okay solange sie verständlich sind.  dead code: Nicht genutzer Code. Klassen, Methoden und Variablen die nie aufgerufen werden.  layer violation: Es wurde sich nicht an die Package und Ebenenstruktur gehalten. Zum Beispiel Zugriff auf den Domainlayer eines anderen Pakets. missplaced resonsibility: Dieser Code ist an der falschen Stelle. Entweder gehört er in ein anderes Package oder in einen andere Schicht oder in eine andere Klasse. Shared persistency: Zugriff auf die Repositories der Domainschicht eines anderen Packages. Anemic Entity: Domain Entities in der Domainschicht die nur über Getter oder Setter verfügen aber sonst keine Funktionen. Ausgenommen sind Repositories. Für diesen Smell brauchst du keinen Zeilenangabe, da er für die gesamte Klasse gilt. Schreib einfach nur einmal -Anemic Entity- sonst zu der enstrechenden Datei.
        Regeln:
        1. Begründe kurz jeden Fund.
        4. Gruppiere nach Datei (mit Pfad). 
        2. Format unter der Datei je Smell: [Dateiname (ohne Pfad)] [Zeile(n) X]: [Smell] [Nur bei Duplizierung: die original Zeile(n)] : [Begründung].
        3. Keine Code-Wiederholung, nur Referenzen.
        5. Wenn fertig, schreibe "ENDE". 
        6. Nutze die Zeilenangaben die mitgeschickt worden sind.



--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\MailAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import lombok.*;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
6: 
7: import javax.persistence.Embeddable;
8: import javax.persistence.GeneratedValue;
9: 
10: @AllArgsConstructor
11: @NoArgsConstructor
12: @Getter
13: @Setter(AccessLevel.PROTECTED)
14: @Embeddable
15: @EqualsAndHashCode
16: public class MailAddress implements MailAddressType {
17: 
18:     @Getter
19:     private String mailAddressString;
20: 
21:     /**
22:      * @return the mail address as a string
23:      */
24:     public String toString() {
25:         return this.mailAddressString;
26:     }
27: 
28:     /**
29:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
30:      * implementing class to provide a static factory method (simply named "of(...)"),
31:      * which creates an mail address, given as a string.
32:      * We specify this factory method here as a comment, using the Javadoc documentation style.
33:      *
34:      * @param mailAddressAsString - the mail address as a string.
35:      *                            We will use a much simplified validation method to check if the mail address is valid:
36:      *                            - it must contain exactly one '@' character.
37:      *                            - the part before the '@' and the part after the '@' must not be empty, contain of
38:      *                            at least one of these characters (A..Z, a..z, or 0..9) and !must not contain any whitespace characters
39:      *                            - the parts before and after the '@' may contain one or several '.' as separators
40:      *                            - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
41:      *                            - the part after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
42:      *                            (for simplicity we do not allow any other domains)
43:      * @return a new MailAddressType object matching the given mail address
44:      * @throws ShopException if ...
45:      *                       - mailAddressAsString is null
46:      *                       - mailAddressAsString is not a valid mail address (see above)
47:      */
48:     public static MailAddressType of(String mailAddressAsString) {
49: 
50:         if (mailAddressAsString == null) {
51:             throw new ShopException("mailAddressAsString is null");
52:         }
53: 
54:         String[] vorATundNachAT = mailAddressAsString.split("@");
55: 
56:         if (vorATundNachAT.length != 2 || vorATundNachAT[0].isEmpty() || vorATundNachAT[1].isEmpty()) {
57:             throw new ShopException("the part before the '@' and the part after the '@' must not be empty");
58:         }
59: 
60:         if (mailAddressAsString.contains("..") || mailAddressAsString.contains(" ")) {
61:             throw new ShopException("two '.' characters must not be directly next to each other or contain any whitespace characters the vorATundNachAT before and after the '@'");
62:         }
63: 
64:         if (!vorATundNachAT[1].matches(".*\\.(de|at|ch|com|org)$")) {
65:             throw new ShopException("the part after the '@' must end with \".de\", \".at\", \".ch\", \".com\", or \".org\"");
66:         }
67: 
68:         if (!mailAddressAsString.matches("[a-zA-Z0-9.@]+")) {
69:             throw new ShopException("Email must contain letters, digits, '.', and '@'");
70:         }
71: 
72:         return new MailAddress(mailAddressAsString);
73: 
74:     }
75: }
76: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\Money.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import lombok.*;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import javax.persistence.Column;
8: import javax.persistence.Embeddable;
9: 
10: @AllArgsConstructor
11: @NoArgsConstructor
12: @Getter
13: @Setter(AccessLevel.PROTECTED)
14: @Embeddable
15: @EqualsAndHashCode
16: public class Money implements MoneyType {
17: 
18:     private Float amount;
19:     private String currency;
20:     /**
21:      * @return the amount of money
22:      */
23:     @Override
24:     public Float getAmount() {
25:         return amount;
26:     }
27: 
28:     /**
29:      * @return the currency of the money
30:      */
31:     @Override
32:     public String getCurrency() {
33:         return currency;
34:     }
35: 
36:     /**
37:      * @param otherMoney
38:      * @return this + otherMoney, as a new object
39:      * @throws ShopException if ...
40:      *                       - otherMoney is null
41:      *                       - otherMoney.currency != this.currency
42:      */
43:     @Override
44:     public MoneyType add(MoneyType otherMoney) {
45: 
46:         if(otherMoney == null){
47:             throw new ShopException("otherMoney is null");
48:         }
49:         if(otherMoney.getCurrency() != this.currency){
50:             throw new ShopException("otherMoney.currency != this.currency");
51:         }
52:         return new Money(amount + otherMoney.getAmount(),this.currency);
53:     }
54: 
55:     /**
56:      * @param otherMoney
57:      * @return this - otherMoney, as a new object
58:      * @throws ShopException if ...
59:      *                       - otherMoney is null
60:      *                       - otherMoney.currency != this.currency
61:      *                       - otherMoney > this
62:      */
63:     @Override
64:     public MoneyType subtract(MoneyType otherMoney) {
65:         if (otherMoney == null) {
66:             throw new ShopException("otherMoney is null");
67:         }
68:         if (otherMoney.getCurrency() != this.currency) {
69:             throw new ShopException("otherMoney.currency != this.currency");
70:         }
71: 
72:         if (this.amount < otherMoney.getAmount()) {
73:             throw new ShopException("otherMoney > this");
74:         }
75: 
76:         return new Money(amount - otherMoney.getAmount(), this.currency);
77:     }
78: 
79: 
80: 
81: 
82:     /**
83:      * @param factor
84:      * @return this * factor, as a new object
85:      * @throws ShopException if ...
86:      *                       - factor < 0
87:      */
88:     @Override
89:     public MoneyType multiplyBy(int factor) {
90:         if(factor < 0){
91:             throw new ShopException("factor < 0");
92:         }
93:         return new Money(this.amount * factor, currency);
94:     }
95: 
96:     /**
97:      * @param otherMoney
98:      * @return true, if this > otherMoney
99:      * @throws ShopException if ...
100:      *                       - otherMoney is null
101:      *                       - otherMoney.currency != this.currency
102:      */
103:     @Override
104:     public boolean largerThan(MoneyType otherMoney) {
105:         if(otherMoney == null){
106:             throw new ShopException("otherMoney is null");
107:         }
108:         if(otherMoney.getCurrency() != currency){
109:             throw new ShopException("otherMoney.currency != this.currency");
110:         }
111:         return this.amount > otherMoney.getAmount();
112:     }
113: 
114:     /**
115:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
116:      * implementing class to provide a static factory method (simply named "of(...)"),
117:      * which creates a money object from an amount and a currency (as string).
118:      * We specify this factory method here as a comment, using the Javadoc documentation style.
119:      *
120:      * @param amount the amount of money (must be >= 0)
121:      * @param currency the currency of the money (allowed values: "EUR", "CHF")
122:      * @return a new Money object with the given amount and currency
123:      * @throws ShopException if ...
124:      *   - amount is null
125:      *   - amount < 0
126:      *   - currency is null
127:      *   - currency is not one of the allowed values
128:      */
129:      public static MoneyType of( Float amount, String currency ){
130: 
131:          if(amount == null || amount < 0 || currency == null || (currency != "EUR" && currency != "CHF")){
132:              throw new ShopException("- amount is null\n" +
133:                      "     *   - amount < 0\n" +
134:                      "     *   - currency is null\n" +
135:                      "     *   - currency is not one of the allowed values");
136:          }
137:          return new Money(amount,currency);
138: 
139: }
140: }
141: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\PersonalAddress.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import lombok.*;
4: import org.springframework.data.annotation.Persistent;
5: import thkoeln.archilab.ecommerce.ShopException;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
8: 
9: import javax.persistence.Embeddable;
10: 
11: @AllArgsConstructor
12: @NoArgsConstructor
13: @Getter
14: @Setter(AccessLevel.PROTECTED)
15: @Embeddable
16: @EqualsAndHashCode
17: public class PersonalAddress implements PersonalAddressType {
18: 
19:     private String street;
20: 
21:     private String city;
22: 
23:     private ZipCode zipcode;
24: 
25:     /**
26:      * ##@return the street as a string
27:      */
28:     @Override
29:     public String getStreet() {
30:         return street;
31:     }
32: 
33:     /**
34:      * @return the city as a string
35:      */
36:     @Override
37:     public String getCity() {
38:         return city;
39:     }
40: 
41:     /**
42:      * @return the zip code
43:      */
44:     @Override
45:     public ZipCodeType getZipCode() {
46:         return zipcode;
47:     }
48: 
49:     /**
50:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
51:      * implementing class to provide a static factory method (simply named "of(...)"),
52:      * which creates an zip code, given as a string.
53:      * We specify this factory method here as a comment, using the Javadoc documentation style.
54:      *
55:      * @param street the street as a string
56:      * @param city the city as a string
57:      * @param zipCode the zip code
58:      * @return the personalAddress object matching the parameters
59:      * @throws ShopException if ...
60:      *      - street is null or empty
61:      *      - city is null or empty
62:      *      - zipCode is null
63:      */
64:      public static PersonalAddressType of( String street, String city, ZipCodeType zipCode ){
65: 
66:          if(street == null || street.isEmpty() ){
67:              throw new ShopException("street is null or empty");
68:          }
69: 
70:          if(city == null || city.isEmpty()){
71:              throw new ShopException("city is null or empty");
72: 
73:          }
74: 
75:          if(zipCode == null){
76:              throw new ShopException("zipCode is null");
77:          }
78: 
79:          return new PersonalAddress(street,city,(ZipCode) zipCode);
80: 
81: 
82:      }
83: }
84: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\domainprimitives\ZipCode.java ---
1: package thkoeln.archilab.ecommerce.domainprimitives;
2: 
3: import lombok.*;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
6: 
7: import javax.persistence.Embeddable;
8: 
9: @AllArgsConstructor
10: @NoArgsConstructor
11: @Getter
12: @Setter(AccessLevel.PROTECTED)
13: @Embeddable
14: @EqualsAndHashCode
15: public class ZipCode implements ZipCodeType {
16:     private String zipCodeAsString;
17: 
18:     public String toString() {
19:         return zipCodeAsString;
20:     }
21: 
22:     /**
23:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
24:      * implementing class to provide a static factory method (simply named "of(...)"),
25:      * which creates an zip code, given as a string.
26:      * We specify this factory method here as a comment, using the Javadoc documentation style.
27:      *
28:      * @param zipCodeAsString - the zip code as a string.
29:      *                        We will use a much simplified validation method to check if the postal code is valid:
30:      *                        - It must contain exactly 5 digits.
31:      *                        - The last 4 digits must not be 0000 (i.e. 20000 is not a valid postal code, but 20001 is valid)
32:      * @return a new zip code object matching the given string
33:      * @throws ShopException if ...
34:      *                       - zipCodeAsString is null
35:      *                       - zipCodeAsString is not a valid zip code (see above)
36:      */
37:     public static ZipCodeType of(String zipCodeAsString) {
38:         if (zipCodeAsString == null) {
39:             throw new ShopException("zipCodeAsString is null");
40:         }
41: 
42:         if (!(zipCodeAsString.length() == 5)){
43:             throw new ShopException("It must contain exactly 5 digits.");
44:         }
45: 
46:         if(zipCodeAsString.endsWith("0000")){
47:             throw new ShopException("The last 4 digits must not be 0000 (i.e. 20000 is not a valid postal code, but 20001 is valid)");
48:         }
49: 
50:         return new ZipCode(zipCodeAsString);
51:     }
52: 
53: }
54: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\masterdata\FactoryMethodInvoker.java ---
1: package thkoeln.archilab.ecommerce.masterdata;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType;
7: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
8: 
9: import java.io.File;
10: import java.io.IOException;
11: import java.lang.reflect.InvocationTargetException;
12: import java.lang.reflect.Method;
13: import java.lang.reflect.Modifier;
14: import java.net.URL;
15: import java.net.URLDecoder;
16: import java.nio.charset.StandardCharsets;
17: import java.util.Enumeration;
18: 
19: import static org.junit.jupiter.api.Assertions.*;
20: 
21: public class FactoryMethodInvoker {
22: 
23:     public static MailAddressType instantiateMailAddress( String mailAddressAsString ) {
24:         Method factoryMethod = null;
25:         try {
26:             Class<?> interfaceClass = Class.forName(
27:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType" );
28:             Class<?> implementingClass = findImplementation( interfaceClass );
29: 
30:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
31:             assertNotNull( factoryMethod );
32:             int modifiers = factoryMethod.getModifiers();
33:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
34:         } catch (Exception e) {
35:             fail( "Failed to find implementation for MailAddressType", e );
36:         }
37: 
38:         Object instance = null;
39:         try {
40:             instance = factoryMethod.invoke( null, mailAddressAsString );
41:         } catch (Exception e) {
42:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
43:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
44:             fail( "Failed to invoke factory method 'of' for '" + mailAddressAsString + "'", e );
45:         }
46:         assertNotNull( instance );
47:         return (MailAddressType) instance;
48:     }
49: 
50: 
51:     public static PersonalAddressType instantiatePersonalAddress(
52:             String street, String city, ZipCodeType zipCode ) {
53:         Method factoryMethod = null;
54:         try {
55:             Class<?> interfaceClass = Class.forName(
56:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType" );
57:             Class<?> implementingClass = findImplementation( interfaceClass );
58: 
59:             factoryMethod = implementingClass.getDeclaredMethod( "of",
60:                     String.class, String.class, ZipCodeType.class );
61:             assertNotNull( factoryMethod );
62:             int modifiers = factoryMethod.getModifiers();
63:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
64:         } catch (Exception e) {
65:             fail( "Failed to find implementation for PersonalAddressType", e );
66:         }
67: 
68:         Object instance = null;
69:         try {
70:             instance = factoryMethod.invoke( null, street, city, zipCode );
71:         } catch (Exception e) {
72:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
73:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
74:             fail( "Failed to invoke factory method 'of' for '" +
75:                     street + "', '" + city + "', '" + zipCode + "'", e );
76:         }
77:         assertNotNull( instance );
78:         return (PersonalAddressType) instance;
79:     }
80: 
81: 
82:     public static ZipCodeType instantiateZipCode( String zipCodeAsString ) {
83:         Method factoryMethod = null;
84:         try {
85:             Class<?> interfaceClass = Class.forName(
86:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.ZipCodeType" );
87:             Class<?> implementingClass = findImplementation( interfaceClass );
88: 
89:             factoryMethod = implementingClass.getDeclaredMethod( "of", String.class );
90:             assertNotNull( factoryMethod );
91:             int modifiers = factoryMethod.getModifiers();
92:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
93:         } catch (Exception e) {
94:             fail( "Failed to find implementation for ZipCodeType", e );
95:         }
96: 
97:         Object instance = null;
98:         try {
99:             instance = factoryMethod.invoke( null, zipCodeAsString );
100:         } catch (Exception e) {
101:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
102:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
103:             fail( "Failed to invoke factory method 'of' for '" + zipCodeAsString + "'", e );
104:         }
105:         assertNotNull( instance );
106:         return (ZipCodeType) instance;
107:     }
108: 
109: 
110:     public static MoneyType instantiateMoney( Float amount, String currency ) {
111:         Method factoryMethod = null;
112:         try {
113:             Class<?> interfaceClass = Class.forName(
114:                     "thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType" );
115:             Class<?> implementingClass = findImplementation( interfaceClass );
116: 
117:             factoryMethod = implementingClass.getDeclaredMethod( "of", Float.class, String.class );
118:             assertNotNull( factoryMethod );
119:             int modifiers = factoryMethod.getModifiers();
120:             assertTrue( Modifier.isStatic( modifiers ), "The method 'of' should be static" );
121:         } catch (Exception e) {
122:             fail( "Failed to find implementation for MoneyType", e );
123:         }
124: 
125:         Object instance = null;
126:         try {
127:             instance = factoryMethod.invoke( null, amount, currency );
128:         } catch (Exception e) {
129:             if ( e instanceof InvocationTargetException && ( (InvocationTargetException) e ).getTargetException()
130:                     instanceof ShopException ) throw new ShopException( e.getMessage() );
131:             fail( "Failed to invoke factory method 'of' for '" + amount + "', '" + currency + "'", e );
132:         }
133:         assertNotNull( instance );
134:         return (MoneyType) instance;
135:     }
136: 
137: 
138:     private static Class<?> findImplementation( Class<?> interfaceClass ) {
139:         Method factoryMethod = null;
140:         try {
141:             String packageName = "thkoeln.archilab.ecommerce.domainprimitives";
142:             Class<?> implementingClass = findImplementingClass( packageName, interfaceClass );
143:             assertNotNull( implementingClass );
144:             return implementingClass;
145:         } catch (Exception e) {
146:             fail( "Cannot find implementation for " + interfaceClass.getSimpleName(), e );
147:             return null; // This line will never be reached, but it's necessary to satisfy the compiler
148:         }
149:     }
150: 
151: 
152:     private static Class<?> findImplementingClass( String packageName, Class<?> interfaceClass )
153:             throws ClassNotFoundException, IOException {
154:         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
155:         String path = packageName.replace( '.', '/' );
156:         Enumeration<URL> resources = classLoader.getResources( path );
157:         int count = 0;
158:         Class<?> result = null;
159:         while (resources.hasMoreElements()) {
160:             URL resource = resources.nextElement();
161:             File directory = new File( URLDecoder.decode( resource.getFile(), StandardCharsets.UTF_8 ) );
162:             File[] files = directory.listFiles();
163:             for ( File file : files ) {
164:                 if ( file.getName().endsWith( ".class" ) ) {
165:                     String className = packageName + '.' + file.getName().substring( 0, file.getName().length() - 6 );
166:                     Class<?> clazz = Class.forName( className );
167:                     if ( interfaceClass.isAssignableFrom( clazz ) && !clazz.isInterface() && !Modifier.isAbstract( clazz.getModifiers() ) ) {
168:                         count++;
169:                         result = clazz;
170:                     }
171:                 }
172:             }
173:         }
174:         assertEquals( 1, count, "There should be exactly one implementing class" );
175:         return result;
176:     }
177: }
178: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\masterdata\InitialMasterDataCreator.java ---
1: package thkoeln.archilab.ecommerce.masterdata;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.context.ApplicationListener;
5: import org.springframework.context.annotation.Profile;
6: import org.springframework.context.event.ContextRefreshedEvent;
7: import org.springframework.stereotype.Component;
8: import thkoeln.archilab.ecommerce.usecases.*;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
12: 
13: import java.util.HashMap;
14: import java.util.Map;
15: import java.util.Random;
16: import java.util.UUID;
17: 
18: 
19: /**
20:  * This class is used to create the initial master data for the application. This includes
21:  * users and goods. It is executed on application startup, and is used for testing purposes.
22:  */
23: @Component
24: @SuppressWarnings("PMD")
25: public class InitialMasterDataCreator {
26: 
27:     public final static String[] USER_NAME = new String[]{
28:             "Max Müller",
29:             "Sophie Schmitz",
30:             "Irene Mihalic",
31:             "Emilia Fischer",
32:             "Filiz Polat",
33:             "Lina Wagner",
34:             "Leon Becker",
35:             "Agnieszka Kalterer",
36:             "Felix Bauer",
37:             "Lara Schulz"
38:     };
39:     public final static MailAddressType[] USER_EMAIL = new MailAddressType[] {
40:             FactoryMethodInvoker.instantiateMailAddress( "max.mueller@example.com" ),
41:             FactoryMethodInvoker.instantiateMailAddress( "sophie.schmitz@example.com" ),
42:             FactoryMethodInvoker.instantiateMailAddress( "irene@wearefreedomnow.com" ),
43:             FactoryMethodInvoker.instantiateMailAddress( "emilia.fischer@example.com" ),
44:             FactoryMethodInvoker.instantiateMailAddress( "j877d3@gmail.com" ),
45:             FactoryMethodInvoker.instantiateMailAddress( "lina.wagner@example.com" ),
46:             FactoryMethodInvoker.instantiateMailAddress( "leon.becker@example.com" ),
47:             FactoryMethodInvoker.instantiateMailAddress( "agna@here.com" ),
48:             FactoryMethodInvoker.instantiateMailAddress( "felix.bauer@example.com" ),
49:             FactoryMethodInvoker.instantiateMailAddress( "lara.schulz@example.com" )
50:     };
51: 
52:     public final static PersonalAddressType[] USER_ADDRESS = new PersonalAddressType[] {
53:             FactoryMethodInvoker.instantiatePersonalAddress(
54:                     "Hauptstraße 1", "Berlin",
55:                     FactoryMethodInvoker.instantiateZipCode( "10115" ) ),
56:             FactoryMethodInvoker.instantiatePersonalAddress(
57:                     "Bahnhofstraße 12", "München",
58:                     FactoryMethodInvoker.instantiateZipCode( "80331" ) ),
59:             FactoryMethodInvoker.instantiatePersonalAddress(
60:                     "Kirchplatz 3", "Hamburg",
61:                     FactoryMethodInvoker.instantiateZipCode( "20095" ) ),
62:             FactoryMethodInvoker.instantiatePersonalAddress(
63:                     "Goethestraße 7", "Frankfurt am Main",
64:                     FactoryMethodInvoker.instantiateZipCode( "60311" ) ),
65:             FactoryMethodInvoker.instantiatePersonalAddress(
66:                     "Mühlenweg 15", "Köln",
67:                     FactoryMethodInvoker.instantiateZipCode( "50667" ) ),
68:             FactoryMethodInvoker.instantiatePersonalAddress(
69:                     "Schulstraße 9", "Düsseldorf",
70:                     FactoryMethodInvoker.instantiateZipCode( "40213" ) ),
71:             FactoryMethodInvoker.instantiatePersonalAddress(
72:                     "Dorfstraße 21", "Stuttgart",
73:                     FactoryMethodInvoker.instantiateZipCode( "70173" ) ),
74:             FactoryMethodInvoker.instantiatePersonalAddress(
75:                     "Marktstraße 5", "Leipzig",
76:                     FactoryMethodInvoker.instantiateZipCode( "04109" ) ),
77:             FactoryMethodInvoker.instantiatePersonalAddress(
78:                     "Rosenweg 14", "Dortmund",
79:                     FactoryMethodInvoker.instantiateZipCode( "44135" ) ),
80:             FactoryMethodInvoker.instantiatePersonalAddress(
81:                     "Wiesenstraße 6", "Essen",
82:                     FactoryMethodInvoker.instantiateZipCode( "45127" ) )
83:     };
84: 
85:     public final static UserType[] mockUsers;
86: 
87:     public static final String EUR = "EUR";
88: 
89:     public static final Object[][] GOOD_DATA = new Object[][]{
90:             {UUID.randomUUID(), "TCD-34 v2.1", "Universelles Verbindungsstück für den einfachen Hausgebrauch bei der Schnellmontage",
91:                     1.5f, FactoryMethodInvoker.instantiateMoney( 5.0f, EUR ),
92:                     FactoryMethodInvoker.instantiateMoney( 10.0f, EUR )},
93:             {UUID.randomUUID(), "EFG-56", "Hochleistungsfähiger Kondensator für elektronische Schaltungen",
94:                     0.3f, FactoryMethodInvoker.instantiateMoney( 2.5f, EUR ),
95:                     FactoryMethodInvoker.instantiateMoney( 4.0f, EUR )},
96:             {UUID.randomUUID(), "MNP-89ff", "Langlebiger und robuster Motor für industrielle Anwendungen",
97:                     7.2f, FactoryMethodInvoker.instantiateMoney( 50.0f, EUR ),
98:                     FactoryMethodInvoker.instantiateMoney( 80.0f, EUR )},
99:             {UUID.randomUUID(), "Gh-25", "Kompakter und leichter Akku für mobile Geräte",
100:                     null, FactoryMethodInvoker.instantiateMoney( 6.0f, EUR ),
101:                     FactoryMethodInvoker.instantiateMoney( 8.0f, EUR )},
102:             {UUID.randomUUID(), "MultiBeast2", "Vielseitiger Adapter für verschiedene Steckertypen",
103:                     null, FactoryMethodInvoker.instantiateMoney( 0.6f, EUR ),
104:                     FactoryMethodInvoker.instantiateMoney( 1.0f, EUR )},
105:             {UUID.randomUUID(), "ABC-99 v4.2", "Leistungsstarker Prozessor für Computer und Server",
106:                     1.0f, FactoryMethodInvoker.instantiateMoney( 150.0f, EUR ),
107:                     FactoryMethodInvoker.instantiateMoney( 250.0f, EUR )},
108:             {UUID.randomUUID(), "Stuko22", "Ersatzteil Spitze für Präzisionswerkzeug zum Löten und Schrauben",
109:                     null, FactoryMethodInvoker.instantiateMoney( 0.3f, EUR ),
110:                     FactoryMethodInvoker.instantiateMoney( 0.5f, EUR )},
111:             {UUID.randomUUID(), "Btt2-Ah67", "Kraftstoffeffiziente und umweltfreundliche Hochleistungsbatterie",
112:                     6.0f, FactoryMethodInvoker.instantiateMoney( 80.0f, EUR ),
113:                     FactoryMethodInvoker.instantiateMoney( 120.0f, EUR )},
114:             {UUID.randomUUID(), "JKL-67", "Wasserdichtes Gehäuse",
115:                     3.0f, FactoryMethodInvoker.instantiateMoney( 1.0f, EUR ),
116:                     FactoryMethodInvoker.instantiateMoney( 1.2f, EUR )},
117:             {UUID.randomUUID(), "MNO-55-33", "Modulares Netzteil für flexible Stromversorgung",
118:                     5.5f, FactoryMethodInvoker.instantiateMoney( 25.0f, EUR ),
119:                     FactoryMethodInvoker.instantiateMoney( 45.0f, EUR )},
120:             {UUID.randomUUID(), "PQR-80", "Effizienter Kühler für verbesserte Wärmeableitung",
121:                     4.0f, FactoryMethodInvoker.instantiateMoney( 20.0f, EUR ),
122:                     FactoryMethodInvoker.instantiateMoney( 35.0f, EUR )},
123:             {UUID.randomUUID(), "STU-11 Ld", "Hochwertiger Grafikchip für leistungsstarke PCs",
124:                     null, FactoryMethodInvoker.instantiateMoney( 200.0f, EUR ),
125:                     FactoryMethodInvoker.instantiateMoney( 350.0f, EUR )},
126:             {UUID.randomUUID(), "VWX-90 FastWupps", "Schnellladegerät für eine Vielzahl von Geräten",
127:                     null, FactoryMethodInvoker.instantiateMoney( 15.0f, EUR ),
128:                     FactoryMethodInvoker.instantiateMoney( 25.0f, EUR )},
129:             {UUID.randomUUID(), "YZZ-22 v1.8", "Leichter und stabiler Rahmen aus Aluminium",
130:                     3.5f, FactoryMethodInvoker.instantiateMoney( 60.0f, EUR ),
131:                     FactoryMethodInvoker.instantiateMoney( 100.0f, EUR )}
132:     };
133: 
134:     private UserRegistrationUseCases userRegistrationUseCases;
135:     private GoodCatalogUseCases goodCatalogUseCases;
136:     private InventoryManagementUseCases inventoryManagementUseCases;
137:     private ShoppingBasketUseCases shoppingBasketUseCases;
138: 
139: 
140:     // good 0 is out of inventory, good 1 and 2 have fixed quantities of 10 and 20, respectively, and the
141:     // others have a random inventory between 5 and 100
142:     public static final Map<UUID, Integer> GOOD_INVENTORY = new HashMap<>();
143: 
144:     static {
145:         mockUsers = new UserType[USER_NAME.length];
146:         for ( int i = 0; i < USER_NAME.length; i++ ) {
147:             mockUsers[i] = new MockUser(
148:                     USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i]);
149:         }
150:         Random random = new Random();
151:         for ( Object[] goodData : GOOD_DATA ) {
152:             GOOD_INVENTORY.put( (UUID) goodData[0], random.nextInt( 100 ) + 20 );
153:         }
154:         GOOD_INVENTORY.put( (UUID) GOOD_DATA[0][0], 0 );
155:         GOOD_INVENTORY.put( (UUID) GOOD_DATA[1][0], 10 );
156:         GOOD_INVENTORY.put( (UUID) GOOD_DATA[2][0], 20 );
157:         GOOD_INVENTORY.put( (UUID) GOOD_DATA[3][0], 30 );
158: 
159:     }
160: 
161: 
162:     public enum InvalidReason {
163:         NULL, EMPTY;
164: 
165:         public Object getInvalidValue( Object originalValue ) {
166:             switch (this) {
167:                 case NULL:
168:                     return null;
169:                 case EMPTY:
170:                     return "";
171:                 default:
172:                     return null;
173:             }
174:         }
175:     }
176: 
177: 
178:     @Autowired
179:     public InitialMasterDataCreator(
180:             UserRegistrationUseCases userRegistrationUseCases,
181:             GoodCatalogUseCases goodCatalogUseCases,
182:             InventoryManagementUseCases inventoryManagementUseCases,
183:             ShoppingBasketUseCases shoppingBasketUseCases ) {
184:         this.userRegistrationUseCases = userRegistrationUseCases;
185:         this.goodCatalogUseCases = goodCatalogUseCases;
186:         this.inventoryManagementUseCases = inventoryManagementUseCases;
187:         this.shoppingBasketUseCases = shoppingBasketUseCases;
188:     }
189: 
190: 
191:     public void deleteAll() {
192:         shoppingBasketUseCases.deleteAllOrders();
193:         goodCatalogUseCases.deleteGoodCatalog();
194:         userRegistrationUseCases.deleteAllUsers();
195:     }
196: 
197: 
198:     public void registerAllUsers() {
199:         for ( int i = 0; i < InitialMasterDataCreator.USER_NAME.length; i++ ) {
200:             registerUser( InitialMasterDataCreator.USER_NAME[i], USER_EMAIL[i], USER_ADDRESS[i] );
201:         }
202:     }
203: 
204: 
205:     public void registerUser( String name, MailAddressType mailAddress, PersonalAddressType personalAddress ) {
206:         userRegistrationUseCases.register( name, mailAddress, personalAddress );
207:     }
208: 
209:     public void addAllGoods() {
210:         for ( Object[] goodData : GOOD_DATA ) {
211:             addGoodDataToCatalog( goodData );
212:         }
213:     }
214: 
215:     public void addGoodDataToCatalog( Object[] goodData ) {
216:         goodCatalogUseCases.addGoodToCatalog( (UUID) goodData[0], (String) goodData[1], (String) goodData[2],
217:                 (Float) goodData[3], (MoneyType) goodData[4], (MoneyType) goodData[5] );
218:     }
219: 
220: 
221:     public Object[] getGoodDataInvalidAtIndex( int index, InvalidReason reason ) {
222:         Object[] goodData = GOOD_DATA[1];
223:         Object[] goodDataInvalid = new Object[goodData.length];
224:         System.arraycopy( goodData, 0, goodDataInvalid, 0, goodData.length );
225:         goodDataInvalid[index] = goodData[index].getClass().cast(
226:                 reason.getInvalidValue( goodData[index] ) );
227:         return goodDataInvalid;
228:     }
229: 
230: 
231:     public void inventoryUpAllGoods() {
232:         for ( Object[] goodData : GOOD_DATA ) {
233:             if ( GOOD_INVENTORY.get( goodData[0] ) > 0 )
234:                 inventoryManagementUseCases.addToInventory( (UUID) goodData[0], GOOD_INVENTORY.get( goodData[0] ) );
235:         }
236:     }
237: }
238: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\masterdata\MockUser.java ---
1: package thkoeln.archilab.ecommerce.masterdata;
2: 
3: import lombok.Setter;
4: import thkoeln.archilab.ecommerce.usecases.UserType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
6: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
7: 
8: import java.util.Objects;
9: 
10: @Setter
11: public class MockUser implements UserType {
12:     private String name;
13:     private MailAddressType mailAddress;
14:     private PersonalAddressType personalAddress;
15: 
16: 
17:     public MockUser( String name, MailAddressType mailAddress, PersonalAddressType personalAddress) {
18:         this.name = name;
19:         this.mailAddress = mailAddress;
20:         this.personalAddress = personalAddress;
21:     }
22: 
23:     @Override
24:     public String getName() {
25:         return name;
26:     }
27: 
28:     @Override
29:     public MailAddressType getMailAddress() {
30:         return mailAddress;
31:     }
32: 
33:     @Override
34:     public PersonalAddressType getPersonalAddress() {
35:         return personalAddress;
36:     }
37: 
38:     @Override
39:     public boolean equals( Object o ) {
40:         if ( this == o ) return true;
41:         if ( !( o instanceof MockUser ) ) return false;
42:         MockUser that = (MockUser) o;
43:         return Objects.equals( getName(), that.getName() ) && Objects.equals( mailAddress, that.mailAddress ) && Objects.equals( personalAddress, that.personalAddress );
44:     }
45: 
46:     @Override
47:     public int hashCode() {
48:         return Objects.hash( getName(), mailAddress, personalAddress );
49:     }
50: }
51: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\masterdata\StartupListener.java ---
1: package thkoeln.archilab.ecommerce.masterdata;
2: 
3: import org.slf4j.Logger;
4: import org.slf4j.LoggerFactory;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.context.ApplicationListener;
7: import org.springframework.context.annotation.Profile;
8: import org.springframework.context.event.ContextRefreshedEvent;
9: import org.springframework.stereotype.Component;
10: 
11: @Component
12: @Profile("!test")
13: public class StartupListener implements ApplicationListener<ContextRefreshedEvent>  {
14:     private Logger logger = LoggerFactory.getLogger( StartupListener.class );
15: 
16:     private InitialMasterDataCreator initialMasterDataCreator;
17: 
18:     @Autowired
19:     public StartupListener( InitialMasterDataCreator initialMasterDataCreator ) {
20:         this.initialMasterDataCreator = initialMasterDataCreator;
21:     }
22: 
23:     @Override
24:     public void onApplicationEvent( ContextRefreshedEvent contextRefreshedEvent ) {
25:         logger.info( "Initializing master data..." );
26:         initialMasterDataCreator.registerAllUsers();
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\ProjectApplication.java ---
1: package thkoeln.archilab.ecommerce;
2: 
3: import org.springframework.boot.SpringApplication;
4: import org.springframework.boot.autoconfigure.SpringBootApplication;
5: 
6: 
7: @SpringBootApplication
8: public class ProjectApplication {
9: 
10: 	/**
11: 	 * Entry method
12: 	 * @param args
13: 	 */
14: 	public static void main(String[] args) {
15: 		SpringApplication.run(ProjectApplication.class, args);
16: 	}
17: }
18: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\ShopException.java ---
1: package thkoeln.archilab.ecommerce;
2: 
3: public class ShopException extends RuntimeException {
4:     public ShopException( String message ) {
5:         super( message );
6:     }
7: }
8: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\application\DeliveryService.java ---
1: package thkoeln.archilab.ecommerce.solution.delivery.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.usecases.DeliveryUseCases;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.usecases.UserType;
9: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
10: 
11: 
12: import java.util.HashMap;
13: import java.util.Map;
14: import java.util.UUID;
15: 
16: @Service
17: public class DeliveryService implements DeliveryUseCases {
18: 
19:     private final UserDeliveryInterface userDeliveryInterface;
20:         @Autowired
21:     public DeliveryService(
22:                UserDeliveryInterface userDeliveryInterface) {
23: 
24:             this.userDeliveryInterface = userDeliveryInterface;
25: 
26: 
27:     }
28: 
29:     /**
30:      * Delivers a good to a user. The good is identified by its id, and the user by
31:      * his/her name, street, city and zip code.
32:      *
33:  ##
34:      * @param deliveryContent   - a map of good ids and quantities
35:      * @return the id of the delivery, if successfully triggered
36:      * @throws ShopException if ...
37:      *                       - deliveryRecipient is null
38:      *                       - any of the properties in deliveryRecipient (the getXxx(...) methods) return null or empty strings
39:      *                       - deliveryContent is null or empty
40:      *                       - the total number of goods in the delivery is > 20
41:      */
42: 
43: 
44:     public void findRecipientByMailAddress(MailAddress userMailAddress,Map<UUID, Integer> deliveryContent){
45:          triggerDelivery(userDeliveryInterface.findUser(userMailAddress),deliveryContent);
46:     }
47:     @Override
48:     public UUID triggerDelivery(UserType deliveryRecipient, Map<UUID, Integer> deliveryContent) {
49: 
50:         if (deliveryRecipient == null) {
51:             throw new ShopException("deliveryRecipient is null");
52:         }
53:         if (deliveryRecipient.getPersonalAddress().getCity() == null || deliveryRecipient.getPersonalAddress().getCity().isEmpty()) {
54:             throw new ShopException("any of the properties in deliveryRecipient (the getXxx(...) methods) return null or empty strings");
55:         }
56:         if (deliveryRecipient.getName() == null || deliveryRecipient.getName().isEmpty()) {
57:             throw new ShopException("any of the properties in deliveryRecipient (the getXxx(...) methods) return null or empty strings");
58:         }
59:         if (deliveryRecipient.getPersonalAddress().getStreet() == null || deliveryRecipient.getPersonalAddress().getStreet().isEmpty()) {
60:             throw new ShopException("any of the properties in deliveryRecipient (the getXxx(...) methods) return null or empty strings");
61:         }
62:         if (deliveryRecipient.getPersonalAddress().getZipCode() == null) {
63:             throw new ShopException("any of the properties in deliveryRecipient (the getXxx(...) methods) return null or empty strings");
64:         }
65:         if (deliveryRecipient.getMailAddress() == null ) {
66:             throw new ShopException("any of the properties in deliveryRecipient (the getXxx(...) methods) return null or empty strings");
67:         }
68: 
69:         if (deliveryContent == null || deliveryContent.isEmpty()) {
70:             throw new ShopException("deliveryContent is null or empty");
71:         }
72: 
73:         int goodsQuantity = 0;
74:         for (int quantity : deliveryContent.values()) {
75:             goodsQuantity += quantity;
76:         }
77:         if (goodsQuantity > 20) {
78:             throw new ShopException("the total number of goods in the delivery is > 20");
79:         }
80: 
81: 
82: 
83: 
84:     return userDeliveryInterface.putInDeliveryMap((MailAddress) deliveryRecipient.getMailAddress(), deliveryContent);
85:     }
86: 
87:     /**
88:      * Returns a map showing which goods have been delivered to a user, and how many of each good
89:      *
90:      * @param userMailAddress
91:      * @return the delivery history of the user (map is empty if the user has not had any deliveries yet)
92:      * @throws ShopException if
93:      *                       - the mail address is null or empty
94:      *                       - the user with the given mail address does not exist
95:      */
96:     @Override
97:     public Map<UUID, Integer> getDeliveryHistory(MailAddressType userMailAddress) {
98:         if(userMailAddress == null){
99:             throw new ShopException("the mail address is null or empty");
100:         }
101:         if(!userDeliveryInterface.existsByMailAddress((MailAddress) userMailAddress)){
102:             throw new ShopException("the user with the given mail address does not exist");
103:         }
104: 
105: 
106:         return new HashMap<>(userDeliveryInterface.returnDeliveryMap((MailAddress) userMailAddress));
107:     }
108: 
109:     /**
110:      * Deletes all delivery history.
111:      */
112:     @Override
113:     public void deleteDeliveryHistory() {
114: 
115:     }
116: }
117: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\application\DeliveryServiceInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.delivery.application;
2: 
3: public interface DeliveryServiceInterface {
4: }
5: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\application\UserDeliveryInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.delivery.application;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
4: import thkoeln.archilab.ecommerce.solution.user.domain.User;
5: import thkoeln.archilab.ecommerce.usecases.UserType;
6: 
7: import java.util.HashMap;
8: import java.util.Map;
9: import java.util.UUID;
10: 
11: public interface UserDeliveryInterface {
12:      boolean existsByMailAddress(MailAddress userMailAddress);
13: 
14:     UUID putInDeliveryMap(MailAddress userMailAddress, Map<UUID, Integer> deliveryContent);
15: 
16:     HashMap<UUID, Integer> returnDeliveryMap(MailAddress userMailAddress);
17:     UserType findUser(MailAddress userMailAddress);
18: 
19: 
20: 
21: }
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\Delivery.java ---
1: package thkoeln.archilab.ecommerce.solution.delivery.domain;
2: 
3: import lombok.Getter;
4: import lombok.Setter;
5: 
6: import javax.persistence.*;
7: import java.util.HashMap;
8: import java.util.UUID;
9: 
10: @Getter
11: @Entity
12: @Table(name = "delivery")
13: public class Delivery {
14:     @Id
15:     @GeneratedValue(strategy = GenerationType.AUTO)
16:     @Column(name = "deliveryID", nullable = false)
17:     public UUID deliveryID;
18: 
19: 
20:     @SuppressWarnings("JpaAttributeTypeInspection")
21:     @Column(columnDefinition = "TEXT", length = 2048)
22:     private HashMap<UUID, Integer> deliveryMap = new HashMap<>();
23: 
24: 
25: }
26: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\delivery\domain\DeliveryPosition.java ---
1: package thkoeln.archilab.ecommerce.solution.delivery.domain;
2: 
3: 
4: import lombok.AllArgsConstructor;
5: import lombok.Getter;
6: import lombok.NoArgsConstructor;
7: import lombok.Setter;
8: import thkoeln.archilab.ecommerce.solution.good.domain.Good;
9: 
10: import javax.persistence.*;
11: import java.util.UUID;
12: 
13: @Getter
14: @Entity
15: @NoArgsConstructor
16: @Table(name = "deliveryposition")
17: @AllArgsConstructor
18: public class DeliveryPosition {
19:     @GeneratedValue(strategy = GenerationType.AUTO)
20:     @Id
21:     private UUID id;
22: 
23: 
24: 
25: 
26:     private Integer quantity;
27: 
28: 
29: 
30: 
31: }
32: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\good\application\GoodService.java ---
1: package thkoeln.archilab.ecommerce.solution.good.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.Money;
6: import thkoeln.archilab.ecommerce.solution.good.domain.Good;
7: import thkoeln.archilab.ecommerce.solution.good.domain.GoodRepository;
8: import thkoeln.archilab.ecommerce.usecases.GoodCatalogUseCases;
9: import thkoeln.archilab.ecommerce.ShopException;
10: import thkoeln.archilab.ecommerce.usecases.InventoryManagementUseCases;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
12: 
13: import java.util.UUID;
14: 
15: @Service
16: public class GoodService implements GoodCatalogUseCases, InventoryManagementUseCases {
17: 
18:     private final GoodRepository goodRepository;
19: 
20:     private final InventoryToUserBasketServiceInterface userService;
21: 
22: 
23: 
24:     @Autowired
25:     public GoodService(GoodRepository goodRepository, InventoryToUserBasketServiceInterface userService) {
26:         this.goodRepository = goodRepository;
27: 
28:         this.userService = userService;
29:     }
30: 
31:     public GoodRepository getGoodRepository(){
32:         return goodRepository;
33:     }
34: 
35:     /**
36:      * Adds a new good to the shop catalog
37:      *
38:      * @param goodId
39:      * @param name
40:      * @param description
41:      * @param size
42:      * @param purchasePrice
43:      * @param sellingPrice
44:      * @throws ShopException if ...
45:      *                       - the good id already exists,
46:      *                       - name or description are null or empty,
47:      *                       - the size is <= 0 (but can be null!),
48:      *                       - the purchase price is null or negative,
49:      *                       - the selling price is null or negative
50:      *                       - the selling price is lower than the purchase price
51:      */
52:     @Override
53:     public void addGoodToCatalog(UUID goodId, String name, String description, Float size, MoneyType purchasePrice, MoneyType sellingPrice) {
54: 
55:         if (goodId == null) {
56:             throw new ShopException("");
57:         }
58:         if (goodRepository.existsById(goodId)) {
59:             throw new ShopException("the good id already exists");
60:         }
61:         if (name == null || name.isBlank()) {
62:             throw new ShopException("name or description are null or empty");
63:         }
64:         if (description == null || description.isBlank()) {
65:             throw new ShopException("name or description are null or empty");
66:         }
67:         if (size != null) {
68: 
69:             if (size < 0) {
70:                 throw new ShopException("the size is <= 0 (but can be null!)");
71: 
72: 
73:             }
74:         }
75:         if (purchasePrice == null || purchasePrice.getAmount() <= 0) {
76:             throw new ShopException("the purchase price is null or negative");
77:         }
78:         if (sellingPrice == null || sellingPrice.getAmount() <= 0) {
79:             throw new ShopException("the selling price is null or negative");
80:         }
81:         if (sellingPrice.getAmount() < purchasePrice.getAmount()) {
82:             throw new ShopException("the selling price is lower than the purchase price");
83:         }
84: 
85:         Good good = new Good(goodId, name, description, size, (Money) purchasePrice, (Money) sellingPrice);
86:         goodRepository.save(good);
87: 
88: 
89:     }
90: 
91:     /**
92:      * Adds a new good to the shop catalog
93:      *
94:      * @param goodId
95:      * @param name
96:      * @param description
97:      * @param size
98:      * @param purchasePrice
99:      * @param sellingPrice
100:      * @throws ShopException if ...
101:      *                       - goodId is null,
102:      *                       - the good with that id already exists,
103:      *                       - name or description are null or empty,
104:      *                       - the size is <= 0 (but can be null!),
105:      *                       - the purchase price is null,
106:      *                       - the selling price is null,
107:      *                       - the selling price is lower than the purchase price
108:      */
109: 
110: 
111:     /**
112:      * Removes a good from the shop catalog
113:      *
114:      * @param goodId
115:      * @throws ShopException if
116:      *                       - the good id does not exist
117:      *                       - the good is still in inventory
118:      *                       - the good is still reserved in a shopping basket, or part of a completed order
119:      */
120:     @Override
121:     public void removeGoodFromCatalog(UUID goodId) {
122:         if (!goodRepository.existsById(goodId)) {
123:             throw new ShopException("the good id does not exist");
124:         }
125: 
126:         if (goodRepository.findById(goodId).get().getInventoryQuantity() != 0) {
127:             throw new ShopException("the good is still in inventory");
128:         }
129:         if (goodRepository.findById(goodId).get().getReserved() != 0 || goodRepository.findById(goodId).get().getOrdered() != 0) {
130:             throw new ShopException("the good is still reserved in a shopping basket, or part of a completed order");
131:         }
132: 
133: 
134: 
135:         goodRepository.deleteById(goodId);
136: 
137: 
138:     }
139: 
140:     /**
141:      * Get the selling price of a given good
142:      *
143:      * @param goodId
144:      * @return the selling price
145:      * @throws ShopException if the good id does not exist
146:      */
147:     @Override
148:     public MoneyType getSellingPrice(UUID goodId) {
149:         if (goodRepository.existsById(goodId)) {
150:             return goodRepository.findById(goodId).get().sellingPrice;
151:         }
152:         throw new ShopException("goodId not found");
153: 
154:     }
155: 
156:     /**
157:      * Clears the good catalog, i.e. removes all goods from the catalog, including all the inventory,
158:      * all the reservations and all the orders.
159:      */
160:     @Override
161:     public void deleteGoodCatalog() {
162:         goodRepository.deleteAll();
163: 
164:     }
165: 
166:     @Override
167:     public void addToInventory(UUID goodId, int addedQuantity) {
168:         if (!this.getGoodRepository().existsById(goodId)) {
169:             throw new ShopException("if the good id does not exist, or if the added quantity is negative");
170:         }
171:         if (addedQuantity <= 0) {
172:             throw new ShopException("if the good id does not exist, or if the added quantity is negative");
173:         }
174:         this.getGoodRepository().findById(goodId).get().setInventoryQuantity(this.getGoodRepository().findById(goodId).get().getInventoryQuantity() + addedQuantity);
175: 
176:     }
177: 
178:     /**
179:      * Removes a certain quantity of a given good from the inventory.
180:      * If the new total quantity is lower than the currently reserved goods, some of currently reserved goods
181:      * (in the users' shopping baskets) are removed. This means that some of the reserved goods are lost for
182:      * the user. (This is necessary because there probably was a mistake in the inventory management, a mis-counting,
183:      * or some of the goods were stolen from the warehouse, are broken, etc.)
184:      *
185:      * @param goodId
186:      * @param removedQuantity
187:      * @throws ShopException if ...
188:      *                       - the good id does not exist
189:      *                       - if the removed quantity is negative
190:      *                       - if the removed quantity is greater than the current inventory and the currently reserved goods together
191:      */
192:     @Override
193:     public void removeFromInventory(UUID goodId, int removedQuantity) {
194:         if (!this.getGoodRepository().existsById(goodId) || removedQuantity <= 0) {
195:             throw new ShopException("the good id does not exist,if the removed quantity is negative ");
196:         }
197: 
198:         if ((this.getGoodRepository().findById(goodId).get().totalQuantity()) < removedQuantity) { //reserved goods ready machen
199:             throw new ShopException("if the removed quantity is greater than the current inventory and the currently reserved goods together");
200:         }
201: 
202:         Good good = this.getGoodRepository().findById(goodId).get();
203:         int rest = good.totalQuantity() - removedQuantity;
204:         int difference = good.changeAmountGlobal(rest);
205:         userService.changeAmountGlobalInBasket(good, difference);
206: 
207: 
208: 
209:     }
210: 
211: 
212:     /**
213:      * Changes the total quantity of a given good in the inventory.
214:      * If the new total quantity is lower than the currently reserved goods, some of currently reserved goods
215:      * (in the users' shopping baskets) are removed. This means that some of the reserved goods are lost for
216:      * the user. (This is necessary because there probably was a mistake in the inventory management, a mis-counting,
217:      * or some of the goods were stolen from the warehouse, are broken, etc.)
218:      *
219:      * @param goodId
220:      * @param newTotalQuantity
221:      * @throws ShopException if ...
222:      *                       - the good id does not exist
223:      *                       - if the new total quantity is negative
224:      */
225:     @Override
226:     public void changeInventoryTo(UUID goodId, int newTotalQuantity) {
227:         if (!this.getGoodRepository().existsById(goodId) || newTotalQuantity < 0) {
228:             throw new ShopException("if the new total quantity is negative");
229:         }
230: 
231:         Good good = this.getGoodRepository().findById(goodId).get();
232:         int diff = good.changeAmountGlobal(newTotalQuantity);
233: 
234:         this.getGoodRepository().findById(goodId).get().changeAmountGlobal(newTotalQuantity);
235:         userService.changeAmountGlobalInBasket(good, diff);
236: 
237:     }
238: 
239:     /**
240:      * Get the current total inventory of a given good, including the currently reserved goods
241:      *
242:      * @param goodId
243:      * @throws ShopException if the good id does not exist
244:      */
245:     @Override
246:     public int getAvailableInventory(UUID goodId) {
247:         if (!this.getGoodRepository().existsById(goodId)) {
248:             throw new ShopException("if the good id does not exist");
249:         }
250:         return this.getGoodRepository().findById(goodId).get().getInventoryQuantity();
251:     }
252: 
253: 
254: }
255: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\good\application\InventoryToUserBasketServiceInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.good.application;
2: 
3: import thkoeln.archilab.ecommerce.solution.good.domain.Good;
4: 
5: public interface InventoryToUserBasketServiceInterface {
6: 
7:      void changeAmountGlobalInBasket(Good good, int difference);
8: 
9: }
10: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\good\domain\Good.java ---
1: package thkoeln.archilab.ecommerce.solution.good.domain;
2: 
3: import lombok.*;
4: import thkoeln.archilab.ecommerce.domainprimitives.Money;
5: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
6: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
7: 
8: import javax.persistence.*;
9: import java.util.ArrayList;
10: import java.util.List;
11: import java.util.UUID;
12: 
13: 
14: @Entity
15: @Table(name = "goods")
16: @AllArgsConstructor
17: @Getter
18: @EqualsAndHashCode
19: public class Good {
20:     @Id
21:     public UUID goodId;
22: 
23:     public String name;
24:     public String description;
25:     public Float size;
26: 
27:     @Embedded
28:     @AttributeOverrides({
29:             @AttributeOverride(name="amount", column= @Column(name="purchasePrice")),
30:             @AttributeOverride(name="currency", column= @Column(name="purchaseCurrency")),
31: 
32:     })
33:     public Money purchasePrice;
34:     @Embedded
35:     @AttributeOverrides({
36:             @AttributeOverride(name="amount", column= @Column(name="sellingPrice")),
37:             @AttributeOverride(name="currency", column= @Column(name="sellingCurrency"))
38:     })
39:     public Money sellingPrice;
40: 
41: 
42:     @Setter
43:     public Integer inventoryQuantity = 0;
44:     @Setter
45:     public Integer reserved = 0;
46:     @Setter
47:     public Integer ordered = 0;
48: 
49:     public void addOrdered(int i) {
50:         reserved -= i;
51:         ordered += i;
52:     }
53: 
54:     public Good(UUID goodId, String name, String description, Float size, Money purchasePrice, Money sellingPrice) {
55:         this.goodId = goodId;
56:         this.name = name;
57:         this.description = description;
58:         this.size = size;
59:         this.purchasePrice = purchasePrice;
60:         this.sellingPrice = sellingPrice;
61:     }
62: 
63: 
64:     public Good() {
65: 
66:     }
67: 
68: 
69: 
70:     public int totalQuantity() {
71:         return inventoryQuantity + reserved;
72:     }
73: 
74:     public void addInventoryQuantity (int quantity) {
75:         inventoryQuantity += quantity;
76:     }
77: 
78:     public void addReserved (int quantity) {
79:         reserved += quantity;
80:     }
81: 
82: 
83:     public int changeAmountGlobal(int i) {
84:         if (i < reserved) { // testt
85:             int temp = reserved - i;
86:             inventoryQuantity = 0;
87:             reserved -= temp;
88: 
89:            return temp;
90: 
91:         } else {
92:             inventoryQuantity = i - reserved;
93:         }
94:         return 0;
95: 
96:     }
97: 
98: 
99: 
100: 
101: 
102: 
103: 
104: }
105: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\good\domain\GoodRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.good.domain;
2: 
3: 
4: import org.springframework.data.jpa.repository.JpaRepository;
5: import org.springframework.data.repository.CrudRepository;
6: import org.springframework.data.repository.RepositoryDefinition;
7: import org.springframework.stereotype.Repository;
8: 
9: import java.util.UUID;
10: 
11: @Repository
12: public interface GoodRepository extends JpaRepository<Good, UUID> {
13: 
14:     public default boolean existsGoodById(UUID goodID){
15:         return this.existsById(goodID);
16:     }
17: 
18:     public default Integer getInventoryQuantityOfGood(UUID goodID){
19:         return this.findById(goodID).get().getInventoryQuantity();
20:     }
21: 
22:     public default void setReservedOfGood(UUID goodID, Integer quantity){
23:         this.findById(goodID).get().setReserved(this.findById(goodID).get().getReserved() + quantity);
24:     }
25: 
26:     public default void setInventoryQuantity(UUID goodID, Integer quantity){
27:         this.findById(goodID).get().setInventoryQuantity(this.findById(goodID).get().getInventoryQuantity() - quantity);
28:     }
29: 
30: 
31:     public default void setReservedOfGoodMinus(UUID goodID, Integer quantity){
32:         this.findById(goodID).get().setReserved(this.findById(goodID).get().getReserved() - quantity);
33:     }
34: 
35:     public default  void setInventoryQuantityPlus(UUID goodID, Integer quantity){
36:         this.findById(goodID).get().setInventoryQuantity(this.findById(goodID).get().getInventoryQuantity() + quantity);
37:     }
38: 
39:     public default float getSellingPriceOfGood(UUID goodID){
40:         return this.findById(goodID).get().getSellingPrice().getAmount();
41:     }
42: 
43:     public default  int getReservedOfGoodID(UUID goodID){
44:         return this.findById(goodID).get().getReserved();
45:     }
46: 
47: 
48:     public default void setReserved(UUID goodID,Integer value){
49:         this.findById(goodID).get().setReserved(this.findById(goodID).get().getReserved() - value);
50:     }
51: 
52:     public default Good getGoodById(UUID goodId) {
53:         return this.findById(goodId).get();
54:     }
55: 
56:     public default void setInventoryQuantityOfGood(UUID goodID, Integer quantity){
57:         this.findById(goodID).get().setInventoryQuantity(quantity);
58:     }
59: 
60: 
61: }
62: 
63: 
64: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import lombok.*;
4: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
5: import thkoeln.archilab.ecommerce.domainprimitives.Money;
6: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
7: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
8: 
9: import java.time.LocalDateTime;
10: import java.util.ArrayList;
11: import java.util.List;
12: import java.util.UUID;
13: 
14: @Setter
15: @Getter
16: @Data
17: public class OrderDTO {
18:     private UUID id;
19:     private List<OrderPosition> orderPositions; //TODO: OrderPositionDTO?
20:     private MailAddress mailAddress;
21:     private Money price;
22:     private LocalDateTime submissionDate;
23: 
24: 
25: }
26: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderDTOMapperService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import org.modelmapper.ModelMapper;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
6: 
7: @Service
8: public class OrderDTOMapperService {
9: 
10:     private final ModelMapper modelMapper = new ModelMapper();
11: 
12:     public OrderDTO mapToDto(Order order) {
13:         OrderDTO orderDTO = modelMapper.map(order, OrderDTO.class);
14:         return orderDTO;
15:     }
16: 
17: 
18: }
19: 
20: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderPositionDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import lombok.Data;
4: import lombok.Getter;
5: import lombok.Setter;
6: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
7: import thkoeln.archilab.ecommerce.domainprimitives.Money;
8: import thkoeln.archilab.ecommerce.solution.good.domain.Good;
9: 
10: import javax.persistence.ManyToOne;
11: import java.time.LocalDateTime;
12: import java.util.List;
13: import java.util.UUID;
14: 
15: @Setter
16: @Getter
17: @Data
18: public class OrderPositionDTO {
19: 
20: 
21: 
22: 
23:     private UUID good;
24: 
25:     private int quantity;
26: 
27:     private String comment;
28: 
29: 
30: 
31: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderRestController.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.http.HttpStatus;
5: import org.springframework.http.ResponseEntity;
6: import org.springframework.web.bind.annotation.GetMapping;
7: import org.springframework.web.bind.annotation.RequestParam;
8: import org.springframework.web.bind.annotation.RestController;
9: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
10: 
11: import java.util.ArrayList;
12: import java.util.List;
13: 
14: @RestController
15: public class OrderRestController {
16:     @Autowired
17:     private final OrderService orderService;
18: 
19: 
20:     private final OrderDTOMapperService mapper;
21: 
22: 
23: 
24:     @Autowired
25:     public OrderRestController(OrderService orderService, OrderDTOMapperService mapper) {
26:         this.orderService = orderService;
27:         this.mapper = mapper;
28:     }
29: 
30:     @GetMapping("/orders")
31:     public ResponseEntity<List<OrderDTO>> getAllOrders(@RequestParam(required = false) String mailAddress,@RequestParam(required = false) String filter) {
32:             List<OrderDTO> orderdtos = new ArrayList<>();
33: 
34:             List<Order> orders = orderService.findOrdersByMailAddressString(mailAddress);
35: 
36:             if (mailAddress == null || !orderService.existsByMailAddressString(mailAddress)) {
37:                 return new ResponseEntity<>(orderdtos, HttpStatus.OK);
38:             }
39: 
40:             for (Order order : orders) {//price
41:                 orderdtos.add(mapper.mapToDto(order));
42:             }
43:             List<OrderDTO> latestOrderDto = new ArrayList<>();
44: 
45:             if (filter != null && filter.equals("latest")) {
46:                 latestOrderDto.add(orderdtos.get(orderdtos.size() - 1 ));
47:                 return new ResponseEntity<>( latestOrderDto, HttpStatus.OK);
48:             }
49:             return new ResponseEntity<>(orderdtos, HttpStatus.OK);
50:         }
51: }
52: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\order\application\OrderService.java ---
1: package thkoeln.archilab.ecommerce.solution.order.application;
2: 
3: import org.modelmapper.ModelMapper;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
7: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
8: import thkoeln.archilab.ecommerce.solution.order.domain.OrderRepository;
9: import thkoeln.archilab.ecommerce.solution.user.domain.User;
10: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
11: 
12: import java.util.ArrayList;
13: import java.util.List;
14: 
15: @Service
16: public class OrderService {
17: 
18:     private ModelMapper modelMapper = new ModelMapper();
19: 
20: 
21:     private OrderRepository orderRepository;
22: 
23:     public OrderService(OrderRepository orderRepository) {
24:         this.orderRepository = orderRepository;
25:     }
26: 
27: 
28: 
29:     public List<Order> findOrdersByMailAddressString(String mailAddress) {
30:         List<Order> order = new ArrayList<>();
31:         for (Order i : orderRepository.findAll()) {
32:             if (i.getMailAddress().toString().equals(mailAddress)) {
33:                 order.add(i);
34:             }
35: 
36:         }
37:         return order;
38:     }
39: 
40:     public OrderRepository getOrderRepository() {
41:         return orderRepository;
42:     }
43: 
44: 
45:     public boolean existsByMailAddressString(String mailAddress) {
46:         for (Order order : orderRepository.findAll()) {
47:             if (order.getMailAddress().toString().equals(mailAddress)) {
48:                 return true;
49:             }
50:         }
51:         return false;
52:     }
53: }
54: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\Order.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
8: import thkoeln.archilab.ecommerce.domainprimitives.Money;
9: import thkoeln.archilab.ecommerce.solution.order.application.OrderPositionDTO;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
12: 
13: import javax.persistence.*;
14: import java.time.LocalDateTime;
15: import java.util.ArrayList;
16: import java.util.List;
17: import java.util.UUID;
18: 
19: @Getter
20: @Entity
21: @NoArgsConstructor
22: @AllArgsConstructor
23: @Table(name = "orders")
24: public class Order {
25: 
26:     @Id
27:     @GeneratedValue(strategy = GenerationType.AUTO)
28:     public UUID orderId;
29: 
30: 
31:     @Embedded
32:     private MailAddress mailAddress;
33: 
34:     @Embedded
35:     @Setter
36:     private Money price;
37: 
38:     private LocalDateTime submissionDate;
39: 
40: 
41: 
42: 
43:     @Embedded
44:     @ElementCollection
45:     private final List<OrderPosition> orderPositions = new ArrayList<>();
46: 
47: 
48:     public Order(UUID id, List<OrderPosition> orderPositions, MailAddress mailAddress) {
49:         this.orderId = id;
50:         this.orderPositions.addAll(orderPositions);
51:         this.mailAddress = mailAddress;
52:     }
53: 
54:     public Order(MailAddressType userMailAddress) {
55:         this.mailAddress = (MailAddress) userMailAddress;
56:     }
57: 
58: 
59:     public Order(MailAddressType userMailAddress, LocalDateTime now) {
60:         this.mailAddress = (MailAddress) userMailAddress;
61:         this.submissionDate = now;
62:     }
63: 
64:     public Order(UUID id, List<OrderPosition> orderPositions, MailAddress mailAddress, Money price) {
65:         this.orderId = id;
66:         this.orderPositions.addAll(orderPositions);
67:         this.mailAddress = mailAddress;
68:         this.price = price;
69:     }
70: 
71:     public Order(UUID id, List<OrderPosition> orderPositions, MailAddress mailAddress, Money price, LocalDateTime submissionDate) {
72:         this.orderId = id;
73:         this.orderPositions.addAll(orderPositions);
74:         this.mailAddress = mailAddress;
75:         this.price = price;
76:         this.submissionDate = submissionDate;
77:     }
78: }
79: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderPosition.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.solution.good.domain.Good;
8: 
9: import javax.persistence.*;
10: import java.util.Collections;
11: import java.util.List;
12: import java.util.UUID;
13: 
14: @Getter
15: @NoArgsConstructor
16: @Table(name = "orderpositions")
17: @Embeddable
18: public class OrderPosition {
19: 
20: 
21: 
22:     private UUID goodId;
23:     @Setter
24:     @Getter
25:     private int quantity;
26: 
27:     private String comment;
28: 
29: 
30: 
31:     public OrderPosition(UUID goodId, int quantity, String comment) {
32:         this.goodId = goodId;
33:         this.quantity = quantity;
34:         this.comment = comment;
35:     }
36: 
37: 
38: 
39: 
40: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\order\domain\OrderRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.order.domain;
2: 
3: 
4: import org.springframework.data.repository.CrudRepository;
5: import org.springframework.stereotype.Repository;
6: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
7: 
8: import java.util.UUID;
9: 
10: @Repository
11: public interface OrderRepository extends CrudRepository<Order, UUID> {
12: 
13: 
14: 
15: }
16: 
17: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\payment\application\PaymentService.java ---
1: package thkoeln.archilab.ecommerce.solution.payment.application;
2: 
3: import org.springframework.stereotype.Service;
4: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
5: import thkoeln.archilab.ecommerce.domainprimitives.Money;
6: import thkoeln.archilab.ecommerce.solution.payment.domain.Payment;
7: import thkoeln.archilab.ecommerce.solution.payment.domain.PaymentRepository;
8: import thkoeln.archilab.ecommerce.usecases.PaymentUseCases;
9: import thkoeln.archilab.ecommerce.ShopException;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
12: 
13: 
14: import java.util.List;
15: import java.util.UUID;
16: 
17: @Service
18: public class PaymentService implements PaymentUseCases {
19:     private final UserPaymentInterface userService;
20:     private final PaymentRepository paymentRepository;
21: 
22:     public PaymentService(
23:             UserPaymentInterface userService, PaymentRepository paymentRepository) {
24:         this.userService = userService;
25:         this.paymentRepository = paymentRepository;
26:     }
27: 
28:     /**
29:      * Authorizes a payment for a user (identified by his/her mail address) for a given amount
30:      *
31:      * @param userMailAddress
32:      * @param amount
33:      * @return the id of the payment, if successfully authorized
34:      * @throws ShopException if ...
35:      *                       - userMailAddress is null or empty
36:      *                       - the user with the given mail address does not exist
37:      *                       - the amount is <= 0.00 EUR
38:      *                       - the payment cannot be processed, because it is over the limit of 500.00 EUR
39:      */
40:     @Override
41:     public UUID authorizePayment(MailAddressType userMailAddress, MoneyType amount) {
42:         if (userMailAddress == null ) {
43:             throw new ShopException("userMailAddress is null or empty");
44:         }
45: 
46:         if (!userService.existsByMailAddress((MailAddress) userMailAddress)) {
47:             throw new ShopException("the user with the given mail address does not exist");
48:         }
49:         if (amount == null) {
50:             throw new ShopException("amount is null");
51:         }
52:         if (amount.getAmount() <= 0.00F || amount.getAmount() > 500.00F) {
53:             throw new ShopException("the payment cannot be processed, because it is over the limit of 500.00 EUR");
54:         }
55:         Payment newPayment = new Payment(amount);
56:         userService.addNewPayment((MailAddress) userMailAddress,newPayment);
57:         paymentRepository.save(newPayment);
58:         return newPayment.paymentID;
59:     }
60: 
61: 
62:     /**
63:      * Returns the total amount of payments (over the complete history) for a user
64:      * (identified by his/her mail address)
65:      *
66:      * @param userMailAddress
67:      * @return the total amount of payments for the user with the given mailAddress,
68:      * or 0.00 EUR if the user has not made any payments yet.
69:      * @throws ShopException if ...
70:      *                       - userMailAddress is null or empty
71:      *                       - the user with the given mailAddress does not exist
72:      */
73:     @Override
74:     public MoneyType getPaymentTotal(MailAddressType userMailAddress) {
75: 
76: 
77:         List<Payment> payments = userService.returnPaymentMap((MailAddress) userMailAddress);
78:         Float total = 0.00F;
79: 
80:         for (Payment payment : payments) {
81:             total += payment.getMoney().getAmount();
82:         }
83:         return new Money(total,"EUR");
84:     }
85: 
86:     /**
87:      * Deletes all payment history, for all users.
88:      */
89:     @Override
90:     public void deletePaymentHistory() {
91: 
92:     }
93: }
94: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\payment\application\PaymentServiceInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.payment.application;
2: 
3: public interface PaymentServiceInterface {
4: }
5: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\payment\application\UserPaymentInterface.java ---
1: package thkoeln.archilab.ecommerce.solution.payment.application;
2: 
3: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
4: import thkoeln.archilab.ecommerce.solution.payment.domain.Payment;
5: 
6: import java.util.List;
7: 
8: public interface UserPaymentInterface {
9:     boolean existsByMailAddress(MailAddress userMailAddress);
10: 
11:     void addNewPayment(MailAddress userMailAddress, Payment payment);
12: 
13:     List<Payment> returnPaymentMap(MailAddress userMailAddress);
14: 
15: 
16: }
17: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\payment\domain\Payment.java ---
1: package thkoeln.archilab.ecommerce.solution.payment.domain;
2: 
3: import lombok.Getter;
4: import lombok.NoArgsConstructor;
5: import lombok.Setter;
6: import thkoeln.archilab.ecommerce.domainprimitives.Money;
7: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
8: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
9: 
10: import javax.persistence.*;
11: import java.util.ArrayList;
12: import java.util.List;
13: import java.util.UUID;
14: 
15: @Getter
16: @NoArgsConstructor
17: @Entity
18: @Table(name = "payment")
19: public class Payment {
20: 
21:     @GeneratedValue(strategy = GenerationType.AUTO)
22:     @Column(name = "paymentID", nullable = false)
23:     @Id
24:     public UUID paymentID;
25: 
26: 
27:     @Embedded
28:     @AttributeOverrides({
29:             @AttributeOverride(name="amount", column= @Column(name="purchasePrice")),
30:             @AttributeOverride(name="currency", column= @Column(name="purchaseCurrency"))
31:     })
32:     private Money money;
33: 
34: 
35: 
36: 
37: 
38:     public Payment(MoneyType money){
39:         this.money = (Money)money;
40:     }
41: 
42: 
43: }
44: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\payment\domain\PaymentRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.payment.domain;
2: 
3: import org.springframework.data.repository.CrudRepository;
4: 
5: import java.util.UUID;
6: 
7: public interface PaymentRepository extends CrudRepository<Payment, UUID> {
8: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import com.fasterxml.jackson.annotation.JsonProperty;
4: import lombok.Data;
5: import lombok.Getter;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
8: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
9: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
10: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketStateType;
11: 
12: import java.util.HashMap;
13: import java.util.List;
14: import java.util.UUID;
15: 
16: @Setter
17: @Getter
18: @Data
19: public class ShoppingBasketDTO {
20:     private UUID id;
21: 
22:     @JsonProperty
23:     private MailAddress mailAddress;
24:     private int totalQuantity;
25: 
26: }
27: 
28: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketDTOMapperService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.modelmapper.ModelMapper;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
6: 
7: @Service
8: public class ShoppingBasketDTOMapperService {
9: 
10: 
11:         private ModelMapper modelMapper = new ModelMapper();
12: 
13:         public ShoppingBasketDTO mapToDto(ShoppingBasket shoppingBasket) {
14:             ShoppingBasketDTO shoppingBasketDTO = modelMapper.map(shoppingBasket, ShoppingBasketDTO.class);
15:             return shoppingBasketDTO;
16:         }
17: 
18:         public ShoppingBasket mapToEntity(ShoppingBasketDTO shoppingBasketDto) {
19:             ShoppingBasket shoppingBasket = new ShoppingBasket(shoppingBasketDto.getId(), shoppingBasketDto.getMailAddress(), shoppingBasketDto.getTotalQuantity());
20:             modelMapper.map(shoppingBasketDto, shoppingBasket);
21:             return shoppingBasket;
22:         }
23:     }
24: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketPositionDTO.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import lombok.*;
5: import thkoeln.archilab.ecommerce.solution.good.domain.Good;
6: 
7: import javax.persistence.ManyToOne;
8: import java.util.UUID;
9: 
10: @AllArgsConstructor
11: @NoArgsConstructor
12: @Setter
13: @Getter
14: @ToString
15: @JsonIgnoreProperties(ignoreUnknown = true)
16: public class ShoppingBasketPositionDTO {
17: 
18:     private UUID goodId;
19: 
20:     private int quantity;
21: 
22:     private String comment;
23: }
24: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketPositionDTOMapperService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.modelmapper.ModelMapper;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
6: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
7: 
8: @Service
9: public class ShoppingBasketPositionDTOMapperService {
10:     private ModelMapper modelMapper = new ModelMapper();
11: 
12:     public ShoppingBasketPositionDTO mapToDto(ShoppingBasketPosition shoppingBasketPosition) {
13:         ShoppingBasketPositionDTO shoppingBasketDTO = modelMapper.map(shoppingBasketPosition, ShoppingBasketPositionDTO.class);
14:         return shoppingBasketDTO;
15:     }
16: 
17: 
18: 
19: 
20: }
21: 
22: 
23: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketRestController.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import com.fasterxml.jackson.core.JsonProcessingException;
4: import com.fasterxml.jackson.databind.ObjectMapper;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.http.HttpStatus;
7: import org.springframework.http.ResponseEntity;
8: import org.springframework.web.bind.annotation.*;
9: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
10: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
11: 
12: import java.util.UUID;
13: 
14: @RestController
15: public class ShoppingBasketRestController {
16:     private final ShoppingBasketService shoppingBasketService;
17: 
18:     private final ShoppingBasketDTOMapperService dtoMapper = new ShoppingBasketDTOMapperService();
19: 
20:     private final ShoppingBasketPositionDTOMapperService shoppingBasketPositionDTOMapperService = new ShoppingBasketPositionDTOMapperService();
21: 
22: 
23:     @Autowired
24:     public ShoppingBasketRestController(ShoppingBasketService shoppingBasketService) {
25:         this.shoppingBasketService = shoppingBasketService;
26: 
27: 
28:     }
29: 
30:     @GetMapping("/shoppingBaskets")
31:     public ResponseEntity<ShoppingBasket> getShoppingBasket(@RequestParam(required = false) String mailAddress) {
32:         try {
33:             ShoppingBasket shoppingBasket = shoppingBasketService.findByMailAddress(mailAddress);
34:             shoppingBasket.totalQuantityBerechnenn();
35:             return new ResponseEntity(shoppingBasket, HttpStatus.OK);
36:         } catch (Exception e) {
37:             return new ResponseEntity(HttpStatus.NOT_FOUND);
38:         }
39:     }
40: 
41:     @PostMapping("/shoppingBaskets/{id}/shoppingBasketPositions")
42:     public ResponseEntity<ShoppingBasket> addShoppingBasketPosition(@PathVariable UUID id, @RequestBody String newShoppingBasketPosition) throws JsonProcessingException {
43:         try {
44:             ShoppingBasket shoppingBasket = shoppingBasketService.getShoppingBasketRepository().findById(id).orElse(null);
45:             if (shoppingBasket == null) {
46:                 return new ResponseEntity(HttpStatus.CONFLICT);
47:             }
48: 
49:             ObjectMapper mapper = new ObjectMapper();
50: 
51:             ShoppingBasketPositionDTO shoppingBasketPosition = mapper.readValue(newShoppingBasketPosition, ShoppingBasketPositionDTO.class);
52:             if (shoppingBasketPosition.getQuantity() < 0) {
53: 
54:                 shoppingBasketService.setCommentForShoppingBasketPosition(shoppingBasket.getMailAddress(), shoppingBasketPosition.getGoodId(), shoppingBasketPosition.getComment());
55:                 //shoppingBasketService.addQuantity(id,shoppingBasketPosition.getQuantity());
56:                // shoppingBasketService.addShoppingBasketPosition(id,shoppingBasketPosition);
57: 
58:                 shoppingBasketService.removeGoodFromShoppingBasket(shoppingBasket.getMailAddress(), shoppingBasketPosition.getGoodId(), (shoppingBasketPosition.getQuantity() * -1));
59: 
60:             } else {
61: 
62:                 shoppingBasketService.addGoodToShoppingBasket(shoppingBasket.getMailAddress(), shoppingBasketPosition.getGoodId(), shoppingBasketPosition.getQuantity());
63:                 //shoppingBasketService.addQuantity(id,shoppingBasketPosition.getQuantity());
64:                 shoppingBasketService.setCommentForShoppingBasketPosition(shoppingBasket.getMailAddress(), shoppingBasketPosition.getGoodId(), shoppingBasketPosition.getComment());
65: 
66:             }
67:             return new ResponseEntity(shoppingBasket,HttpStatus.CREATED);
68:         } catch (Exception e) {
69:             return new ResponseEntity(HttpStatus.CONFLICT);
70:         }
71:     }
72: 
73: 
74:     @PutMapping("/shoppingBaskets/{id}/checkout")
75:     public ResponseEntity checkoutShoppingBasket(@PathVariable UUID id) {
76:         try {
77:             ShoppingBasket shoppingBasket = shoppingBasketService.getShoppingBasketRepository().findById(id).orElse(null);
78: 
79:             if (shoppingBasket == null) {
80:                 return new ResponseEntity(HttpStatus.NOT_FOUND);
81:             }
82:             shoppingBasketService.checkout(shoppingBasket.getMailAddress());
83: 
84: 
85:             return new ResponseEntity<>(HttpStatus.OK);
86:         } catch (Exception e) {
87:             return new ResponseEntity(HttpStatus.CONFLICT);
88:         }
89:     }
90: 
91:     @DeleteMapping("/shoppingBaskets/{shoppingBasketId}/shoppingBasketPositions/{goodId}")
92:     public ResponseEntity deleteShoppingBasketPosition(@PathVariable UUID shoppingBasketId, @PathVariable UUID goodId) {
93:        ShoppingBasket shoppingBasket = shoppingBasketService.getShoppingBasketRepository().findById(shoppingBasketId).orElse(null);
94: 
95:        if (shoppingBasket == null || goodId == null || shoppingBasketService.goodInShoppingBasketPositionns(shoppingBasketId, goodId) == 0) {
96:                 return new ResponseEntity(HttpStatus.NOT_FOUND);
97:             }
98:         try {
99:         ShoppingBasketPosition shoppingBasketPosition = new ShoppingBasketPosition();
100: 
101:         for(ShoppingBasketPosition findShoppingBasketPosition : shoppingBasket.getShoppingBasketPositions()){
102:             if(findShoppingBasketPosition.getGood().getGoodId().equals(goodId)){
103:                 shoppingBasketPosition = findShoppingBasketPosition;
104:             }
105:         }
106:         shoppingBasket.getShoppingBasketPositions().remove(shoppingBasketPosition);
107:         shoppingBasketService.updateReservedQuantity(goodId, shoppingBasketPosition.getQuantity());
108:             return new ResponseEntity(HttpStatus.OK);
109: 
110: 
111:         } catch (Exception e) {
112:             return new ResponseEntity(HttpStatus.NOT_FOUND);
113:         }
114:     }
115: 
116:     @GetMapping("/shoppingBaskets/{shoppingBasketId}/shoppingBasketPositions/{goodId}")
117:     public ResponseEntity<ShoppingBasketPosition> addShoppingBasketPosition(@PathVariable UUID shoppingBasketId, @PathVariable UUID goodId) {
118: 
119:         ShoppingBasket shoppingBasket = shoppingBasketService.getShoppingBasketRepository().findById(shoppingBasketId).orElse(null);
120: 
121:         if (shoppingBasket == null || goodId == null || shoppingBasketService.goodInShoppingBasketPositionns(shoppingBasketId, goodId) == 0) {
122:             return new ResponseEntity(HttpStatus.NOT_FOUND);
123:         }
124:          try {
125:                 ShoppingBasketPosition shoppingBasketPosition = new ShoppingBasketPosition();
126:                 for (ShoppingBasketPosition findShoppingBasketPosition : shoppingBasket.getShoppingBasketPositions()) {
127:                     if (findShoppingBasketPosition.getGood().getGoodId().equals(goodId)) {
128:                         shoppingBasketPosition = findShoppingBasketPosition;
129:                     }
130:                 }
131: 
132: 
133:                 return new ResponseEntity( shoppingBasketPosition,HttpStatus.OK);
134:           } catch (Exception e) {
135:                 return new ResponseEntity(HttpStatus.NOT_FOUND);
136:           }
137:      }
138:     }
139: 
140: 
141: 
142: 
143: 
144: 
145: 
146: 
147: 
148: 
149: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\ShoppingBasketService.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.domainprimitives.Money;
7: import thkoeln.archilab.ecommerce.solution.delivery.application.DeliveryService;
8: import thkoeln.archilab.ecommerce.solution.good.application.GoodService;
9: import thkoeln.archilab.ecommerce.solution.good.domain.Good;
10: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
11: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
12: import thkoeln.archilab.ecommerce.solution.payment.application.PaymentService;
13: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
14: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketPosition;
15: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketRepository;
16: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketStateType;
17: import thkoeln.archilab.ecommerce.ShopException;
18: 
19: import thkoeln.archilab.ecommerce.solution.user.application.UserService;
20: import thkoeln.archilab.ecommerce.usecases.ShoppingBasketUseCases;
21: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
22: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
23: 
24: import java.time.LocalDateTime;
25: import java.util.HashMap;
26: import java.util.List;
27: import java.util.Map;
28: import java.util.UUID;
29: 
30: @Service
31: public class ShoppingBasketService implements ShoppingBasketUseCases {
32: 
33:     private final ShoppingBasketRepository shoppingBasketRepository;
34: 
35:     private final UserServiceInterface userService;
36: 
37:     private final PaymentService paymentService;
38:     private final GoodService goodService;
39: 
40:     private final DeliveryService deliveryService;
41: 
42: 
43: 
44: 
45:     @Autowired
46:     public ShoppingBasketService(UserServiceInterface userService,
47:                                  ShoppingBasketRepository shoppingBasketRepository, GoodService goodService, PaymentService paymentService, DeliveryService deliveryService) {
48:         this.userService = userService;
49:         this.shoppingBasketRepository = shoppingBasketRepository;
50:         this.goodService = goodService;
51:         this.paymentService = paymentService;
52:         this.deliveryService = deliveryService;
53: 
54:     }
55: 
56:     public ShoppingBasketRepository getShoppingBasketRepository() {
57:         return shoppingBasketRepository;
58:     }
59: 
60:     /**
61:      * Adds a good to the cart of a user
62:      *
63:      * @param userMailAddress
64:      * @param goodId
65:      * @param quantity
66:      * @throws ShopException if ...
67:      *                       - the user with the given mailAddress does not exist,
68:      *                       - the good does not exist,
69:      *                       - the quantity is negative,
70:      *                       - the good is not available in the requested quantity
71:      */
72:     @Override
73:     public void addGoodToShoppingBasket(MailAddressType userMailAddress, UUID goodId, int quantity ) {
74: 
75:         if (!userService.existsByMailAddress((MailAddress) userMailAddress)) {
76:             throw new ShopException("the user with the given mailAddress does not exist");
77:         }
78:         if (!goodService.getGoodRepository().existsGoodById(goodId)) {
79:             throw new ShopException("the good does not exist");
80:         }
81:         if (quantity < 0) {
82:             throw new ShopException("the quantity is negative");
83:         }
84:         if (goodService.getGoodRepository().getInventoryQuantityOfGood(goodId) < quantity) {// = gemacht
85:             throw new ShopException("the good is not available in the requested quantity");
86:         }
87: 
88:         if(goodService.getGoodRepository().getGoodById(goodId).totalQuantity() - quantity <0){
89:             throw new ShopException("the good is not available in the requested quantity");
90:     }
91:         Good good = goodService.getGoodRepository().getGoodById(goodId);
92: 
93:         userService.addToShoppingBasket((MailAddress) userMailAddress, good, quantity);
94:         goodService.getGoodRepository().setReservedOfGood(goodId, quantity);
95: 
96:         goodService.getGoodRepository().setInventoryQuantity(goodId, quantity);
97: 
98: 
99: 
100:     }
101: 
102: 
103:     /**
104:      * Removes a good from the cart of a user
105:      *
106:      * @param userMailAddress
107:      * @param goodId
108:      * @param quantity
109:      * @throws ShopException if ...
110:      *                       - the user with the given mailAddress does not exist,
111:      *                       - the good does not exist
112:      *                       - the quantity is negative
113:      *                       - the good is not in the cart in the requested quantity
114:      */
115:     @Override
116:     public void removeGoodFromShoppingBasket(MailAddressType userMailAddress, UUID goodId, int quantity) {
117:         if (!userService.existsByMailAddress((MailAddress) userMailAddress)) {
118:             throw new ShopException("the user with the given mailAddress does not exist");
119:         }
120:         if (!goodService.getGoodRepository().existsGoodById(goodId)) {
121:             throw new ShopException("the good does not exist");
122:         }
123:         if (quantity < 0) {
124:             throw new ShopException("the quantity is negative");
125:         }
126:         Good good = goodService.getGoodRepository().getGoodById(goodId);
127:         if (!userService.enoughInUserShoppingBasket((MailAddress) userMailAddress, good, quantity)) {
128:             throw new ShopException("the good is not in the cart in the requested quantity");
129:         }
130:         userService.removeGoodFromUsersShoppingBasket((MailAddress) userMailAddress, good, quantity);
131:         goodService.getGoodRepository().setReservedOfGoodMinus(goodId, quantity);
132:         goodService.getGoodRepository().setInventoryQuantityPlus(goodId, quantity);
133: 
134: 
135:     }
136: 
137:     /**
138:      * Sets a comment in the shopping basket position containing a good
139:      *
140:      * @param userMailAddress
141:      * @param goodId
142:      * @param comment         (can be null)
143:      * @throws ShopException if ...
144:      *                       - userMailAddress is null,
145:      *                       - the user with the given mailAddress does not exist,
146:      *                       - the good does not exist
147:      *                       - the good is not in the shopping basket
148:      */
149:     @Override
150:     public void setCommentForShoppingBasketPosition(MailAddressType userMailAddress, UUID goodId, String comment) {
151:         if(userMailAddress == null || goodId == null){
152:             throw new ShopException("userMailAddress is null");
153:         }
154:         if (!userService.existsByMailAddress((MailAddress) userMailAddress)) {
155:             throw new ShopException("the user with the given mailAddress does not exist");
156:         }
157:         if (!goodService.getGoodRepository().existsGoodById(goodId)) {
158:             throw new ShopException("the good does not exist");
159:         }
160:         Good good = goodService.getGoodRepository().getGoodById(goodId);
161:         if (!userService.enoughInUserShoppingBasket((MailAddress) userMailAddress, good, 1)) {
162:             throw new ShopException("the good is not in the shopping basket");
163:         }
164:         userService.setCommentForShoppingBasketPosition((MailAddress) userMailAddress, good, comment);
165: 
166:     }
167: 
168:     /**
169:      * Returns the comment in the shopping basket position containing a good
170:      *
171:      * @param userMailAddress
172:      * @param goodId
173:      * @return the comment (can be null)
174:      * @throws ShopException if ...
175:      *                       - userMailAddress is null,
176:      *                       - the user with the given mailAddress does not exist,
177:      *                       - the good does not exist
178:      *                       - the good is not in the shopping basket
179:      */
180:     @Override
181:     public String getCommentForShoppingBasketPosition(MailAddressType userMailAddress, UUID goodId) {
182: 
183:         if(userMailAddress == null || goodId == null){
184:             throw new ShopException("userMailAddress is null");
185:         }
186:         if (!userService.existsByMailAddress((MailAddress) userMailAddress)) {
187:             throw new ShopException("the user with the given mailAddress does not exist");
188:         }
189:         if (!goodService.getGoodRepository().existsGoodById(goodId)) {
190:             throw new ShopException("the good does not exist");
191:         }
192:         Good good = goodService.getGoodRepository().getGoodById(goodId);
193:         if (!userService.enoughInUserShoppingBasket((MailAddress) userMailAddress, good, 1)) {
194:             throw new ShopException("the good is not in the shopping basket");
195:         }
196:         return userService.getCommentForShoppingBasketPosition((MailAddress) userMailAddress, good);
197:     }
198: 
199: 
200:     @Override
201:     public Map<UUID, Integer> getShoppingBasketAsMap(MailAddressType userMailAddress) {
202:         if (!userService.existsByMailAddress((MailAddress) userMailAddress)) {
203:             throw new ShopException("if the user with the given mailAddress does not exist");
204:         }
205:         ShoppingBasket shoppingBasket = userService.getBasket((MailAddress) userMailAddress);
206:         HashMap<UUID,Integer> basket = new HashMap<>();
207:         for (ShoppingBasketPosition shoppingBasketPosition : shoppingBasket.getShoppingBasketPositions()) {
208:             basket.put(shoppingBasketPosition.getGood().getGoodId(), shoppingBasketPosition.getQuantity());
209:         }
210: 
211: 
212:         return basket;
213: 
214:     }
215: 
216:     /**
217:      * Returns the current value of all goods in the cart of a user
218:      *
219:      * @param userMailAddress
220:      * @return the cart of the user
221:      * @throws ShopException if the user with the given mailAddress does not exist
222:      */
223:     @Override
224:     public MoneyType getShoppingBasketAsMoneyValue(MailAddressType userMailAddress) {
225:         if (!userService.existsByMailAddress((MailAddress) userMailAddress)) {
226:             throw new ShopException("if the user with the given mailAddress does not exist");
227:         }
228: 
229:         float ret = 0.00F;
230:         for (Map.Entry<UUID, Integer> basket : getShoppingBasketAsMap((MailAddress) userMailAddress).entrySet()) {
231:             UUID goodId = basket.getKey();
232:             int quantity = basket.getValue();
233:             ret += goodService.getGoodRepository().getSellingPriceOfGood(goodId) * quantity;
234:         }
235: 
236:         return new Money(ret, "EUR");
237:     }
238: 
239: 
240: 
241: 
242: 
243: 
244: 
245:     /**
246:      * Get the number units of a specific good that are currently reserved in the shopping baskets of all users
247:      *
248:      * @param goodId
249:      * @throws ShopException if the good id does not exist
250:      */
251:     @Override
252:     public int getReservedInventoryInShoppingBaskets(UUID goodId) {
253:         if (!goodService.getGoodRepository().existsGoodById(goodId)) {
254:             throw new ShopException("if the good id does not exist");
255:         }
256:         return goodService.getGoodRepository().getReservedOfGoodID(goodId);
257:     }
258: 
259: 
260: 
261: 
262: 
263:     /**
264:      * Checks if the shopping basket of a user is empty
265:      *
266:      * @param userMailAddress
267:      * @return true if the shopping basket is empty, false otherwise
268:      * @throws ShopException if ...
269:      *                       - the mail address is null or empty
270:      *                       - the user with the given mail address does not exist
271:      */
272:     @Override
273:     public boolean isEmpty(MailAddressType userMailAddress) {
274:         if (userMailAddress == null ) {
275:             throw new ShopException("the user with the given mail address does not exist");
276:         }
277:         if (!userService.existsByMailAddress((MailAddress) userMailAddress)) {
278:             throw new ShopException("the mail address is null or empty");
279:         }
280:         return userService.getStateOfShoppingBasket((MailAddress) userMailAddress) == ShoppingBasketStateType.EMPTY;
281:     }
282: 
283:     /**
284:      * Checks if the payment for a specific shopping basket of a user has been authorized to be paid,
285:      * i.e. the shopping basket is not empty, the user has given his/her payment details, and the payment
286:      * has been authorized (under the limits of the user's credit card). However, the order
287:      * has not yet been placed yet, and the logistics details (delivery address) have not yet been given.
288:      *
289:      * @param userMailAddress
290:      * @return true if the payment has been authorized, false otherwise
291:      * @throws ShopException if ...
292:      *                       - the mail address is null or empty
293:      *                       - the user with the given mail address does not exist
294:      */
295:     @Override
296:     public boolean isPaymentAuthorized(MailAddressType userMailAddress) {
297: 
298:         if (userMailAddress == null ) {
299:             throw new ShopException("the user with the given mail address does not exist");
300:         }
301:         if (!userService.existsByMailAddress((MailAddress) userMailAddress)) {
302:             throw new ShopException("the mail address is null or empty");
303:         }
304: 
305: 
306:         return userService.getStateOfShoppingBasket((MailAddress) userMailAddress) == ShoppingBasketStateType.PAYMENT_AUTHORIZED;
307:     }
308: 
309:     /**
310:      * Checks out the cart of a user
311:      *
312:      * @param userMailAddress
313:      * @throws ShopException if the user with the given mailAddress does not exist, or if the cart is empty
314:      */
315:     @Override
316:     public void checkout(MailAddressType userMailAddress) {// alle goods vom shoppingbasket in order und anzahl von reserved ändern
317: 
318: 
319:         if (!userService.existsByMailAddress((MailAddress) userMailAddress) || userService.isBasketEmpty((MailAddress) userMailAddress)) {
320:             throw new ShopException("if the user with the given mailAddress does not exist, or if the cart is empty");
321:         }
322: 
323:         List<Order> orders = userService.returnOrderOfUser((MailAddress)userMailAddress);
324:         Order order = new Order(userMailAddress, LocalDateTime.now());
325: 
326: 
327:         paymentService.authorizePayment(userMailAddress, getShoppingBasketAsMoneyValue(userMailAddress));
328:         userService.basketUserPaymentAuth((MailAddress)userMailAddress);
329: 
330: 
331:         deliveryService.findRecipientByMailAddress((MailAddress) userMailAddress, getShoppingBasketAsMap(userMailAddress));
332:         ShoppingBasket shoppingBasket = userService.getBasket((MailAddress) userMailAddress);
333: 
334: 
335: 
336:         for (ShoppingBasketPosition basket : shoppingBasket.getShoppingBasketPositions()) {
337: 
338: 
339:             OrderPosition orderPosition = new OrderPosition(basket.getGood().getGoodId(), basket.getQuantity(),basket.getComment());
340:             order.getOrderPositions().add(orderPosition);
341:             goodService.getGoodRepository().setReserved(basket.getGood().goodId, basket.getQuantity());
342:             goodService.getGoodRepository().getGoodById(basket.getGood().getGoodId()).addOrdered(basket.getQuantity());
343: 
344:         }
345:         order.setPrice((Money) getShoppingBasketAsMoneyValue(userMailAddress));
346:         orders.add(order);
347: 
348: 
349: 
350:         userService.clearBasketOfUser((MailAddress)userMailAddress);
351:         userService.emptyBasketOfUser((MailAddress)userMailAddress);
352:     }
353: 
354: 
355:     /**
356:      * Returns a map showing which goods have been ordered by a user and how many of each good
357:      *
358:      * @param userMailAddress
359:      * @return the order history of the user (map is empty if the user has not ordered anything yet)
360:      * @throws ShopException if the user with the given mailAddress does not exist
361:      */
362:     @Override
363:     public Map<UUID, Integer> getOrderHistory(MailAddressType userMailAddress) {
364:         if (!userService.existsByMailAddress((MailAddress) userMailAddress)) {
365:             throw new ShopException("if the user with the given mailAddress does not exist");
366:         }
367:         List<Order> orders = userService.getOrdersOfUser((MailAddress)userMailAddress);
368:         Map<UUID, Integer> history = new HashMap<>();
369: 
370:         for (Order order : orders) {
371:             for (OrderPosition orderPosition : order.getOrderPositions()) {
372:                 UUID goodId = orderPosition.getGoodId();
373:                 int quantity = orderPosition.getQuantity();
374: 
375:                 if (history.containsKey(goodId)) {
376:                     history.replace(goodId, history.get(goodId) + quantity);
377:                 } else {
378:                     history.put(goodId, quantity);
379:                 }
380:             }
381:         }
382: 
383: 
384:         return history;
385:     }
386: 
387:     /**
388:      * Deletes all orders and shopping baskets in the system
389:      */
390:     @Override
391:     public void deleteAllOrders() {
392:         userService.deleteAllOrders();
393: 
394: 
395:     }
396: 
397: 
398: 
399: 
400:      ShoppingBasket findByMailAddress(String mailAddress) {
401:         for (ShoppingBasket shoppingBasket : shoppingBasketRepository.findAll()) {
402:                if (shoppingBasket.getMailAddress().toString().equals(mailAddress)) {
403:                     return shoppingBasket;
404:                 }
405: 
406:         }
407:         return null;
408: 
409:     }
410: 
411:      int goodInShoppingBasketPositionns(UUID shoppingBasketId, UUID goodId) {
412:         ShoppingBasket shoppingBasket = shoppingBasketRepository.findById(shoppingBasketId).get();
413:         for (ShoppingBasketPosition shoppingBasketPosition : shoppingBasket.getShoppingBasketPositions()) {
414:             if (shoppingBasketPosition.getGood().getGoodId().equals(goodId)) {
415:                 return 1;
416:             }
417:         }
418:         return 0;
419:     }
420: 
421:      void updateReservedQuantity(UUID goodId, int quantity) {
422:         goodService.getGoodRepository().findById(goodId).get().addInventoryQuantity(quantity);
423:         goodService.getGoodRepository().findById(goodId).get().addReserved(quantity);
424: 
425: 
426:     }
427: 
428: 
429: }
430: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\application\UserServiceInterface.java ---
1: 
2: package thkoeln.archilab.ecommerce.solution.shoppingbasket.application;
3: 
4: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
5: import thkoeln.archilab.ecommerce.solution.good.domain.Good;
6: import thkoeln.archilab.ecommerce.solution.good.domain.GoodRepository;
7: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
8: import thkoeln.archilab.ecommerce.solution.order.domain.OrderPosition;
9: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
10: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketStateType;
11: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
12: 
13: import java.util.HashMap;
14: import java.util.List;
15: import java.util.Map;
16: import java.util.UUID;
17: 
18: public interface UserServiceInterface {
19: 
20: 
21:     void setCommentForShoppingBasketPosition(MailAddress userMailAddress, Good goodId, String comment);
22: 
23:     String getCommentForShoppingBasketPosition(MailAddress userMailAddress, Good goodId);
24: 
25:     boolean existsByMailAddress(MailAddress userMailAddress);
26: 
27:     void addToShoppingBasket(MailAddress userMailAddress, Good good, int quantity);
28: 
29:     boolean enoughInUserShoppingBasket(MailAddress userMailAddress, Good good,int quantity);
30: 
31:     void removeGoodFromUsersShoppingBasket(MailAddress userMailAddress, Good good, int quantity);
32: 
33:     ShoppingBasket getBasket (MailAddress userMailAddress);
34: 
35:     ShoppingBasketStateType getStateOfShoppingBasket(MailAddress userMailAddress);
36: 
37:     boolean  isBasketEmpty(MailAddress userMailAddress);
38: 
39:     List<Order> returnOrderOfUser(MailAddress userMailAddress);
40: 
41:     void basketUserPaymentAuth(MailAddress userMailAddress);
42: 
43:      void clearBasketOfUser(MailAddress userMailAddress);
44:      void emptyBasketOfUser(MailAddress userMailAddress);
45: 
46:      List<Order> getOrdersOfUser(MailAddress userMailAddress);
47: 
48: 
49:      void deleteAllOrders();
50: 
51: 
52: 
53: 
54: 
55: }
56: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasket.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.NoArgsConstructor;
6: import lombok.Setter;
7: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
8: import thkoeln.archilab.ecommerce.solution.good.domain.Good;
9: import thkoeln.archilab.ecommerce.solution.user.domain.User;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
11: 
12: import javax.persistence.*;
13: import java.util.ArrayList;
14: import java.util.HashMap;
15: import java.util.List;
16: import java.util.UUID;
17: 
18: @Getter
19: @Entity
20: @NoArgsConstructor
21: @AllArgsConstructor
22: @Table(name = "ShoppingBaskets")
23: public class ShoppingBasket {
24: 
25: 
26:     @Id
27:     @GeneratedValue(strategy = GenerationType.AUTO)
28:     public UUID id;
29: 
30:     public int totalQuantity;
31:     
32: 
33:     @Getter
34:     private MailAddress mailAddress;
35:     private ShoppingBasketStateType state = ShoppingBasketStateType.EMPTY;
36:     @CollectionTable
37:     @ElementCollection(fetch = FetchType.EAGER)
38:     private List<ShoppingBasketPosition> shoppingBasketPositions = new ArrayList<>();
39: 
40:     @SuppressWarnings("JpaAttributeTypeInspection")
41:     @Column(columnDefinition = "TEXT", length = 2048)
42:     private HashMap<UUID, String> commentToBasketPosition = new HashMap<>();
43: 
44: 
45: 
46:     public ShoppingBasket(MailAddress mailAddress) {
47:         this.mailAddress = mailAddress;
48:     }
49: 
50: 
51: 
52: 
53:     //@SuppressWarnings("JpaAttributeTypeInspection")
54:     //@Column(columnDefinition = "TEXT", length = 2048)
55:     //private HashMap<UUID, Integer> basket = new HashMap<>();
56: 
57: 
58: 
59:     public ShoppingBasket(UUID id, MailAddress mailAddress, int totalQuantity) {
60:         this.id = id;
61:         this.mailAddress = mailAddress;
62:         this.totalQuantity = totalQuantity;
63:     }
64: 
65: 
66:     public boolean goodInShoppingBasket(Good good){
67: 
68:         for(ShoppingBasketPosition position : shoppingBasketPositions){
69:             if(position.getGood() == good) {
70:                 return true;
71:             }
72:         }
73:         return false;
74:     }
75: 
76:     public ShoppingBasketPosition findShoppingBasketPosition(Good good){
77:         for(ShoppingBasketPosition position : shoppingBasketPositions){
78:             if(position.getGood() == good) {
79:                 return position;
80:             }
81:         }
82:         return null;
83:     }
84:     public void addToShoppingBasketPosition(ShoppingBasketPosition shoppingBasketPosition) {
85:         this.shoppingBasketPositions.add(shoppingBasketPosition);
86:     }
87: 
88:     public void addGoodToShoppingBasket(Good good, int quantity) {
89:         state = ShoppingBasketStateType.FILLED;
90:         if (goodInShoppingBasket(good)) {
91:             findShoppingBasketPosition(good).setQuantity(findShoppingBasketPosition(good).getQuantity() + quantity);
92:         } else {
93:             ShoppingBasketPosition newPosition = new ShoppingBasketPosition(good,quantity,"");
94:             addToShoppingBasketPosition(newPosition);
95:         }
96: 
97: 
98:     }
99: 
100: 
101:     public void removeGoodFromShoppingBasket(Good goodId, int quantity) {
102:         if (findShoppingBasketPosition(goodId).getQuantity() - quantity <= 0) {
103:             shoppingBasketPositions.remove(findShoppingBasketPosition(goodId));
104:         } else {
105:             findShoppingBasketPosition(goodId).setQuantity(findShoppingBasketPosition(goodId).getQuantity() - quantity);
106: 
107:         }
108:         basketEmptyCheck();
109:     }
110: 
111:     public boolean enoughInShoppingBasket(Good goodId, int quantity) {
112: 
113: 
114:         if (goodInShoppingBasket(goodId)) {
115:             return findShoppingBasketPosition(goodId).getQuantity() >= quantity;
116:         }
117:         basketEmptyCheck();
118:         return false;
119: 
120: 
121:     }
122:     public void deleteAllOrders(){
123:         shoppingBasketPositions.clear();
124:         basketEmptyCheck();
125:     }
126: 
127:     public int changeGoodQuantitiy(Good goodID, int quantity) {
128:         while (quantity != 0) {
129: 
130:             int temp = findShoppingBasketPosition(goodID).getQuantity();
131:             changeGoodQuantitiyID(goodID, temp - 1);
132:             quantity = quantity - 1;
133:             if (findShoppingBasketPosition(goodID).getQuantity() == 0) {
134:                 return quantity;
135:             }
136:         }
137:         basketEmptyCheck();
138:         return quantity;
139: 
140: 
141:     }
142: 
143:     public void changeGoodQuantitiyID(Good goodId, int quantity) {
144:         findShoppingBasketPosition(goodId).setQuantity(quantity);
145: 
146: 
147: 
148:     }
149:     public void basketEmptyCheck(){
150:         if(shoppingBasketPositions.isEmpty()) {
151:             state = ShoppingBasketStateType.EMPTY;
152:         }
153:     }
154: 
155:     public void basketPaymentAuth(){
156:         state = ShoppingBasketStateType.PAYMENT_AUTHORIZED;
157: 
158:     }
159: 
160:     public HashMap<Good, Integer> shoppingBasketAsMap() {
161:         HashMap<Good, Integer> shoppingBasket = new HashMap<>();
162:         for (ShoppingBasketPosition position : shoppingBasketPositions) {
163:             shoppingBasket.put(position.getGood(), position.getQuantity());
164:         }
165:         return shoppingBasket;
166:     }
167: 
168: 
169:     public void setCommentForShoppingBasketPosition(UUID goodId, String comment) {
170:         commentToBasketPosition.put(goodId, comment);
171: 
172:     }
173: 
174:     public String getCommentForShoppingBasketPosition(UUID goodId) {
175:         return commentToBasketPosition.get(goodId);
176:     }
177: 
178:     public void totalQuantityBerechnenn() {
179:         totalQuantity = 0;
180: 
181:         for (ShoppingBasketPosition position : shoppingBasketPositions) {
182:             totalQuantity = totalQuantity + position.getQuantity();
183:         }
184:     }
185: }
186: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketPosition.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: import lombok.*;
4: import thkoeln.archilab.ecommerce.solution.good.domain.Good;
5: 
6: import javax.persistence.Embeddable;
7: import javax.persistence.ManyToOne;
8: import java.util.UUID;
9: 
10: @Getter
11: @Setter
12: @AllArgsConstructor
13: @NoArgsConstructor(access = AccessLevel.PUBLIC)
14: @Embeddable
15: public class ShoppingBasketPosition {
16: 
17:    // private UUID good;
18: 
19:     @ManyToOne
20:     private Good good;
21: 
22:     private int quantity;
23: 
24:     private String comment;
25: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: 
4: import org.springframework.data.repository.CrudRepository;
5: 
6: import java.util.UUID;
7: 
8: public interface ShoppingBasketRepository extends CrudRepository<ShoppingBasket, UUID> {
9: }
10: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\shoppingbasket\domain\ShoppingBasketStateType.java ---
1: package thkoeln.archilab.ecommerce.solution.shoppingbasket.domain;
2: 
3: public enum ShoppingBasketStateType {
4:     EMPTY,
5:     FILLED,
6:     PAYMENT_AUTHORIZED,
7:     DELIVERY_TRIGGERED
8: }
9: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserDeliveryPaymentService.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.domainprimitives.Money;
7: import thkoeln.archilab.ecommerce.solution.delivery.application.UserDeliveryInterface;
8: import thkoeln.archilab.ecommerce.solution.payment.application.UserPaymentInterface;
9: import thkoeln.archilab.ecommerce.solution.payment.domain.Payment;
10: import thkoeln.archilab.ecommerce.solution.user.domain.User;
11: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
12: import thkoeln.archilab.ecommerce.usecases.UserType;
13: 
14: import java.util.HashMap;
15: import java.util.List;
16: import java.util.Map;
17: import java.util.UUID;
18: 
19: @Service
20: public class UserDeliveryPaymentService implements UserPaymentInterface, UserDeliveryInterface {
21:     private final UserRepository userRepository;
22:     @Autowired
23:     public UserDeliveryPaymentService(UserRepository userRepository) {
24:         this.userRepository = userRepository;
25:     }
26: 
27:     @Override
28:     public boolean existsByMailAddress(MailAddress userMailAddress) {
29:         return userRepository.existsByMailAddress(userMailAddress);
30:     }
31: 
32:     @Override
33:     public void addNewPayment(MailAddress userMailAddress, Payment payment) {
34:         userRepository.findByMailAddress(userMailAddress).addPayment(payment);
35: 
36:     }
37: 
38:     @Override
39:     public List<Payment> returnPaymentMap(MailAddress userMailAddress) {
40:         return userRepository.findByMailAddress(userMailAddress).getPayments();
41: 
42:     }
43:     @Override
44:     public UUID putInDeliveryMap(MailAddress userMailAddress, Map<UUID, Integer> deliveryContent) {
45:         User user = userRepository.findByMailAddress(userMailAddress);
46:         for (Map.Entry<UUID, Integer> entry : deliveryContent.entrySet()) {
47:             UUID goodID = entry.getKey();
48:             Integer quantity = entry.getValue();
49: 
50:             if(user.getDelivery().getDeliveryMap().containsKey(goodID)){
51:                 user.getDelivery().getDeliveryMap().replace(goodID,user.getDelivery().getDeliveryMap().get(goodID)+ quantity);
52: 
53:             }else{
54: 
55:                 user.getDelivery().getDeliveryMap().put(goodID,quantity);}
56:         }
57:         return user.getDelivery().getDeliveryID();
58:     }
59: 
60:     @Override
61:     public HashMap<UUID, Integer> returnDeliveryMap(MailAddress userMailAddress) {
62:         return userRepository.findByMailAddress(userMailAddress).getDelivery().getDeliveryMap();
63:     }
64: 
65:     @Override
66:     public UserType findUser(MailAddress userMailAddress) {
67:         return userRepository.findByMailAddress(userMailAddress);
68:     }
69: 
70: }
71: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserLessService.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.solution.good.domain.Good;
7: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
8: import thkoeln.archilab.ecommerce.solution.shoppingbasket.application.UserServiceInterface;
9: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
10: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketStateType;
11: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
12: 
13: import java.util.List;
14: 
15: @Service
16: public class UserLessService implements UserServiceInterface {
17:     private final UserRepository userRepository;
18: 
19: 
20:     @Autowired
21:     public UserLessService(UserRepository userRepository                       ) {
22:         this.userRepository = userRepository;
23: 
24:     }
25:     @Override
26:     public void setCommentForShoppingBasketPosition(MailAddress userMailAddress, Good goodId, String comment) {
27:         ShoppingBasket shoppingBasket = userRepository.findByMailAddress(userMailAddress).getShoppingBasket();
28:         shoppingBasket.findShoppingBasketPosition(goodId).setComment(comment);
29:     }
30: 
31:     @Override
32:     public String getCommentForShoppingBasketPosition(MailAddress userMailAddress, Good goodId) {
33:         ShoppingBasket shoppingBasket = userRepository.findByMailAddress(userMailAddress).getShoppingBasket();
34:         return shoppingBasket.findShoppingBasketPosition(goodId).getComment();
35:     }
36: 
37:     @Override
38:     public boolean existsByMailAddress(MailAddress userMailAddress) {
39:         return this.userRepository.existsByMailAddress(userMailAddress);
40:     }
41: 
42:     @Override
43:     public void addToShoppingBasket(MailAddress userMailAddress, Good good, int quantity) {
44:         userRepository.addToShoppingBasket(userMailAddress,good,quantity);
45: 
46:     }
47: 
48:     @Override
49:     public boolean enoughInUserShoppingBasket(MailAddress userMailAddress, Good good, int quantity) {
50:         return userRepository.enoughInUserShoppingBasket(userMailAddress,good,quantity);
51:     }
52: 
53:     @Override
54:     public void removeGoodFromUsersShoppingBasket(MailAddress userMailAddress, Good good, int quantity) {
55:         userRepository.removeGoodFromUsersShoppingBasket(userMailAddress,good,quantity);
56: 
57:     }
58: 
59:     @Override
60:     public ShoppingBasket getBasket(MailAddress userMailAddress) {
61:         return userRepository.getBasket(userMailAddress);
62:     }
63: 
64:     @Override
65:     public ShoppingBasketStateType getStateOfShoppingBasket(MailAddress userMailAddress) {
66:         return userRepository.getStateOfShoppingBasket(userMailAddress);
67:     }
68: 
69:     @Override
70:     public boolean isBasketEmpty(MailAddress userMailAddress) {
71:         return userRepository.isBasketEmpty(userMailAddress);
72:     }
73: 
74:     @Override
75:     public List<Order> returnOrderOfUser(MailAddress userMailAddress) {
76:         return userRepository.returnOrderOfUser(userMailAddress);
77:     }
78: 
79:     @Override
80:     public void basketUserPaymentAuth(MailAddress userMailAddress) {
81:         userRepository.basketUserPaymentAuth(userMailAddress);
82: 
83:     }
84: 
85:     @Override
86:     public void clearBasketOfUser(MailAddress userMailAddress) {
87:         userRepository.clearBasketOfUser(userMailAddress);
88: 
89:     }
90: 
91:     @Override
92:     public void emptyBasketOfUser(MailAddress userMailAddress) {
93:         userRepository.emptyBasketOfUser(userMailAddress);
94: 
95:     }
96: 
97:     @Override
98:     public List<Order> getOrdersOfUser(MailAddress userMailAddress) {
99:         return userRepository.getOrdersOfUser(userMailAddress);
100:     }
101: 
102:     @Override
103:     public void deleteAllOrders() {
104:         userRepository.deleteAllOrders();
105: 
106: 
107:     }
108: }
109: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\user\application\UserService.java ---
1: package thkoeln.archilab.ecommerce.solution.user.application;
2: 
3: import org.springframework.beans.factory.annotation.Autowired;
4: import org.springframework.stereotype.Service;
5: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
6: import thkoeln.archilab.ecommerce.domainprimitives.PersonalAddress;
7: import thkoeln.archilab.ecommerce.solution.good.application.InventoryToUserBasketServiceInterface;
8: import thkoeln.archilab.ecommerce.solution.good.domain.Good;
9: import thkoeln.archilab.ecommerce.solution.good.domain.GoodRepository;
10: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
11: import thkoeln.archilab.ecommerce.solution.shoppingbasket.application.UserServiceInterface;
12: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
13: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketStateType;
14: import thkoeln.archilab.ecommerce.solution.user.domain.User;
15: import thkoeln.archilab.ecommerce.solution.user.domain.UserRepository;
16: import thkoeln.archilab.ecommerce.ShopException;
17: 
18: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
19: import thkoeln.archilab.ecommerce.usecases.UserType;
20: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
21: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
22: 
23: import java.util.List;
24: 
25: @Service
26: public class UserService implements UserRegistrationUseCases, InventoryToUserBasketServiceInterface {
27:     private final UserRepository userRepository;
28: 
29: 
30:     @Autowired
31:     public UserService(UserRepository userRepository                       ) {
32:         this.userRepository = userRepository;
33: 
34:     }
35: 
36: 
37:     /**
38:      * Registers a new user
39:      *
40:      * @param name
41:      * @param mailAddress
42:      * @throws ShopException if ...
43:      *                       - user with the given mailAddress already exists
44:      *                       - if the data are invalid (name, mailAddress, street, city, zipCode empty or null)
45:      */
46:     @Override
47:     public void register(String name, MailAddressType mailAddress, PersonalAddressType personalAddress) {
48:         if (mailAddress == null || name == null || personalAddress == null || name.isEmpty()) {
49:             throw new ShopException("if the data are invalid (name, mailAddress, street, city, zipCode empty or null)");
50:         }
51:         if (userRepository.existsByMailAddress((MailAddress) mailAddress)) {
52:             throw new ShopException("user with the given mailAddress already exists");
53: 
54:         }
55: 
56: 
57:         User user = new User(name, mailAddress, personalAddress);
58:         userRepository.save(user);
59: 
60: 
61:     }
62: 
63:     /**
64:      * Changes the address of a user
65:      *
66:      * @param userMailAddress
67:      * @throws ShopException if ...
68:      *                       - the user with the given mailAddress does not exist,
69:      *                       - the address data are invalid (street, city, zipCode empty or null)
70:      */
71:     @Override
72:     public void changeAddress(MailAddressType userMailAddress, PersonalAddressType personalAddress) {
73:         if (userMailAddress == null || personalAddress == null) {
74:             throw new ShopException("he address data are invalid (street, city, zipCode empty or null)");
75:         }
76: 
77: 
78:         if (personalAddress.getCity() == null || personalAddress.getCity().isEmpty() || personalAddress.getStreet() == null || personalAddress.getStreet().isEmpty()) {
79:             throw new ShopException("the address data are invalid (street, city, zipCode empty or null)");
80:         }
81:         if (!userRepository.existsByMailAddress((MailAddress) userMailAddress)) {
82:             throw new ShopException("the user with the given mailAddress does not exist");
83:         }
84: 
85:         User clientfromdb = userRepository.findByMailAddress((MailAddress) userMailAddress);
86:         clientfromdb.setAddress((PersonalAddress) personalAddress);
87: 
88:     }
89: 
90:     /**
91:      * Returns the data of a user as an array of strings (name, mailAddress, street, city, zipCode)
92:      *
93:      * @param userMailAddress
94:      * @return the user data
95:      * @throws ShopException if ...
96:      *                       - mailAddress is null
97:      *                       - the user with the given mail address does not exist
98:      */
99:     @Override
100:     public UserType getUserData(MailAddressType userMailAddress) {
101:         if (userMailAddress == null) {
102:             throw new ShopException("mailAddress is null");
103:         }
104:         if (!userRepository.existsByMailAddress((MailAddress) userMailAddress)) {
105:             throw new ShopException("the user with the given mail address does not exist");
106:         }
107: 
108:         return userRepository.findByMailAddress((MailAddress) userMailAddress);
109:     }
110: 
111:     /**
112:      * Clears all users, including all orders and carts
113:      */
114:     @Override
115:     public void deleteAllUsers() {
116:         userRepository.deleteAll();
117:     }
118: 
119: 
120: 
121: 
122: 
123:     @Override
124:     public void changeAmountGlobalInBasket(Good good, int difference) {
125:         for (User user : userRepository.findAll()) {
126:             if (user.getShoppingBasket().goodInShoppingBasket(good)) {
127:                 difference = user.getShoppingBasket().changeGoodQuantitiy(good, difference);
128:             }
129:             if (difference == 0) {
130:                 break;
131:             }
132:         }
133:     }
134: 
135: }
136: 
137: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\Address.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: 
4: import lombok.EqualsAndHashCode;
5: 
6: import javax.persistence.Embeddable;
7: 
8: @Embeddable
9: @EqualsAndHashCode
10: public class Address {
11:     public String street;
12:     public String city;
13:     public String zipCode;
14: 
15: 
16: 
17: 
18:     public Address(String street, String city, String zipCode) {
19:             this.street = street;
20:             this.city = city;
21:             this.zipCode = zipCode;
22:         }
23: 
24: 
25:     public Address() {
26: 
27:     }
28: }
29: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\User.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: import lombok.AllArgsConstructor;
4: import lombok.Getter;
5: import lombok.Setter;
6: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
7: import thkoeln.archilab.ecommerce.domainprimitives.PersonalAddress;
8: import thkoeln.archilab.ecommerce.solution.delivery.domain.Delivery;
9: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
10: import thkoeln.archilab.ecommerce.solution.payment.domain.Payment;
11: 
12: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
13: import thkoeln.archilab.ecommerce.usecases.UserType;
14: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
15: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
16: 
17: import javax.persistence.*;
18: import java.util.ArrayList;
19: import java.util.List;
20: import java.util.UUID;
21: 
22: @Getter
23: @Entity
24: @AllArgsConstructor
25: @Table(name = "users")
26: public class User implements UserType {
27:     public String name;
28:     @Id
29:     @Column(name = "id", nullable = false)
30:     @GeneratedValue(strategy = GenerationType.AUTO)
31:     private UUID id;
32: 
33: 
34:     @Embedded
35:     public MailAddress mailAddress;
36: 
37: 
38:     @Embedded
39:     public PersonalAddress personalAddress;
40: 
41:     @OneToMany(cascade = CascadeType.ALL)
42:     private List<Order> orders = new ArrayList<>();
43: 
44:     @OneToOne(cascade = CascadeType.ALL)
45:     private ShoppingBasket shoppingBasket;
46: 
47:     @OneToOne(cascade = CascadeType.ALL)
48:     private Delivery delivery = new Delivery();
49: 
50:     @OneToMany
51:     private final List<Payment> payments = new ArrayList<>();
52: 
53:     public void addPayment(Payment payment){
54:         payments.add(payment);
55:     }
56: 
57:     public void setShoppingBasket(ShoppingBasket shoppingBasket) {
58:         this.shoppingBasket = shoppingBasket;
59:     }
60: 
61: 
62:     public User(String name, MailAddressType mailAddress, PersonalAddressType personalAddress) {
63:         this.name = name;
64:         this.mailAddress = (MailAddress) mailAddress;
65:         this.personalAddress = (PersonalAddress) personalAddress;
66:         this.shoppingBasket = new ShoppingBasket(this.mailAddress);  // Set the shopping basket here
67:     }
68: 
69:     public User() {
70: 
71:     }
72: 
73: 
74: 
75: 
76:     public void setAddress(PersonalAddress personalAddress) {
77:         this.personalAddress = personalAddress;
78:     }
79: 
80: 
81: }
82: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\solution\user\domain\UserRepository.java ---
1: package thkoeln.archilab.ecommerce.solution.user.domain;
2: 
3: 
4: import org.springframework.data.jpa.repository.JpaRepository;
5: import org.springframework.data.repository.CrudRepository;
6: import org.springframework.stereotype.Repository;
7: import thkoeln.archilab.ecommerce.domainprimitives.MailAddress;
8: import thkoeln.archilab.ecommerce.solution.good.domain.Good;
9: import thkoeln.archilab.ecommerce.solution.order.domain.Order;
10: import thkoeln.archilab.ecommerce.solution.payment.domain.Payment;
11: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasket;
12: import thkoeln.archilab.ecommerce.solution.shoppingbasket.domain.ShoppingBasketStateType;
13: import thkoeln.archilab.ecommerce.usecases.UserType;
14: 
15: import java.util.HashMap;
16: import java.util.List;
17: import java.util.Map;
18: import java.util.UUID;
19: 
20: @Repository
21: public
22: interface UserRepository extends JpaRepository<User, String> {
23: 
24:     User findByMailAddress(MailAddress mailAddress);
25: 
26: 
27:     boolean existsByMailAddress(MailAddress mailAddress);
28: 
29:     default void addToShoppingBasket(MailAddress userMailAddress, Good goodID, int quantity) {
30:         this.findByMailAddress(userMailAddress).getShoppingBasket().addGoodToShoppingBasket(goodID, quantity);
31:     }
32: 
33:     default ShoppingBasket getBasket(MailAddress userMailAddress) {
34:         return this.findByMailAddress(userMailAddress).getShoppingBasket();
35:     }
36: 
37: 
38: 
39:     default void deleteAllOrders() {
40:         for (User user : this.findAll()) {
41:             user.getShoppingBasket().deleteAllOrders();
42:             user.getOrders().clear();
43:         }
44:     }
45: 
46: 
47:     default boolean enoughInUserShoppingBasket(MailAddress userMailAddress, Good goodId, Integer quantity) {
48:         return this.findByMailAddress(userMailAddress).getShoppingBasket().enoughInShoppingBasket(goodId, quantity);
49: 
50:     }
51: 
52:     default void removeGoodFromUsersShoppingBasket(MailAddress userMailAddress, Good goodId, Integer quantity) {
53:         this.findByMailAddress(userMailAddress).getShoppingBasket().removeGoodFromShoppingBasket(goodId, quantity);
54: 
55:     }
56: 
57:     default ShoppingBasketStateType getStateOfShoppingBasket(MailAddress userMailAddress) {
58:         return this.findByMailAddress(userMailAddress).getShoppingBasket().getState();
59: 
60:     }
61: 
62:     default boolean isBasketEmpty(MailAddress userMailAddress) {
63:         return this.findByMailAddress(userMailAddress).getShoppingBasket().getShoppingBasketPositions().isEmpty();
64: 
65:     }
66: 
67:     default List<Order> returnOrderOfUser(MailAddress userMailAddress) {
68:         return this.findByMailAddress(userMailAddress).getOrders();
69: 
70:     }
71: 
72:     default void basketUserPaymentAuth(MailAddress userMailAddress) {
73:         this.findByMailAddress((MailAddress) userMailAddress).getShoppingBasket().basketPaymentAuth();
74: 
75:     }
76: 
77: 
78:     default void clearBasketOfUser(MailAddress userMailAddress) {
79:         this.findByMailAddress(userMailAddress).getShoppingBasket().getShoppingBasketPositions().clear();
80: 
81:     }
82: 
83:     default void emptyBasketOfUser(MailAddress userMailAddress) {
84:         this.findByMailAddress(userMailAddress).getShoppingBasket().basketEmptyCheck();
85: 
86:     }
87: 
88:     default List<Order> getOrdersOfUser(MailAddress userMailAddress) {
89:         return this.findByMailAddress(userMailAddress).getOrders();
90: 
91:     }
92: 
93: }

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\usecases\DeliveryUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: 
6: import java.util.Map;
7: import java.util.UUID;
8: 
9: /**
10:  * This interface contains methods needed in the context of use cases dealing with logistics,
11:  * i.e. the delivery of goods to a user. It is probably incomplete, and will grow over time.
12:  */
13: public interface DeliveryUseCases {
14:     /**
15:      * Delivers a good to a user. The good is identified by its id, and the user by
16:      * his/her name, street, city and zip code.
17:      * @param deliveryRecipient
18:      * @param deliveryContent - a map of good ids and quantities
19:      * @return the id of the delivery, if successfully triggered
20:      * @throws ShopException if ...
21:      *      - deliveryRecipient is null
22:      *      - any of the properties in deliveryRecipient (the getXxx(...) methods) return null or empty strings
23:      *      - deliveryContent is null or empty
24:      *      - the total number of goods in the delivery is > 20
25:      */
26:     public UUID triggerDelivery( UserType deliveryRecipient, Map<UUID, Integer> deliveryContent );
27: 
28: 
29:     /**
30:      * Returns a map showing which goods have been delivered to a user, and how many of each good
31:      *
32:      * @param userMailAddress
33:      * @return the delivery history of the user (map is empty if the user has not had any deliveries yet)
34:      * @throws ShopException if
35:      *      - mailAddress is null
36:      *      - the user with the given mail address does not exist
37:      */
38:     public Map<UUID, Integer> getDeliveryHistory( MailAddressType userMailAddress );
39: 
40: 
41: 
42:     /**
43:      *  Deletes all delivery history.
44:      */
45:     public void deleteDeliveryHistory();
46: }
47: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MailAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface MailAddressType {
6:     /**
7:      * @return the mail address as a string
8:      */
9:     public String toString();
10: 
11:     /**
12:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
13:      * implementing class to provide a static factory method (simply named "of(...)"),
14:      * which creates an mail address, given as a string.
15:      * We specify this factory method here as a comment, using the Javadoc documentation style.
16:      *
17:      * @param mailAddressAsString - the mail address as a string.
18:      *      We will use a much simplified validation method to check if the mail address is valid:
19:      *      - it must contain exactly one '@' character.
20:      *      - the part before the '@' and the part after the '@' must not be empty, contain of
21:      *        at least one of these characters (A..Z, a..z, or 0..9) and must not contain any whitespace characters
22:      *      - the parts before and after the '@' may contain one or several '.' as separators
23:      *      - two '.' characters must not be directly next to each other (so "test@this..example.com" is invalid)
24:      *      - the part after the '@' must end with ".de", ".at", ".ch", ".com", ".org"
25:      *        (for simplicity we do not allow any other domains)
26:      * @return a new MailAddressType object matching the given mail address
27:      * @throws ShopException if ...
28:      *      - mailAddressAsString is null
29:      *      - mailAddressAsString is not a valid mail address (see above)
30:      */
31:      // public static MailAddressType of( String mailAddressAsString );
32: }
33: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\MoneyType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface MoneyType {
6:     /**
7:      * @return the amount of money
8:      */
9:     public Float getAmount();
10: 
11: 
12:     /**
13:      * @return the currency of the money
14:      */
15:     public String getCurrency();
16: 
17: 
18:     /**
19:      * @param otherMoney
20:      * @return this + otherMoney, as a new object
21:      * @throws ShopException if ...
22:      *      - otherMoney is null
23:      *      - otherMoney.currency != this.currency
24:      */
25:     public MoneyType add( MoneyType otherMoney );
26: 
27: 
28:     /**
29:      * @param otherMoney
30:      * @return this - otherMoney, as a new object
31:      * @throws ShopException if ...
32:      *      - otherMoney is null
33:      *      - otherMoney.currency != this.currency
34:      *      - otherMoney > this
35:      */
36:     public MoneyType subtract( MoneyType otherMoney );
37: 
38: 
39:     /**
40:      * @param factor
41:      * @return this * factor, as a new object
42:      * @throws ShopException if ...
43:      *     - factor < 0
44:      */
45:     public MoneyType multiplyBy( int factor );
46: 
47:     /**
48:      * @param otherMoney
49:      * @return true, if this > otherMoney
50:      * @throws ShopException if ...
51:      *      - otherMoney is null
52:      *      - otherMoney.currency != this.currency
53:      */
54:     public boolean largerThan( MoneyType otherMoney );
55: 
56: 
57:     /**
58:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
59:      * implementing class to provide a static factory method (simply named "of(...)"),
60:      * which creates a money object from an amount and a currency (as string).
61:      * We specify this factory method here as a comment, using the Javadoc documentation style.
62:      *
63:      * @param amount the amount of money (must be >= 0)
64:      * @param currency the currency of the money (allowed values: "EUR", "CHF")
65:      * @return a new Money object with the given amount and currency
66:      * @throws ShopException if ...
67:      *   - amount is null
68:      *   - amount < 0
69:      *   - currency is null
70:      *   - currency is not one of the allowed values
71:      */
72:      // public static MoneyType of( Float amount, String currency );
73: }
74: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\PersonalAddressType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface PersonalAddressType {
6:     /**
7:      * @return the street as a string
8:      */
9:     public String getStreet();
10: 
11:     /**
12:      * @return the city as a string
13:      */
14:     public String getCity();
15: 
16:     /**
17:      * @return the zip code
18:      */
19:     public ZipCodeType getZipCode();
20: 
21:     /**
22:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
23:      * implementing class to provide a static factory method (simply named "of(...)"),
24:      * which creates an zip code, given as a string.
25:      * We specify this factory method here as a comment, using the Javadoc documentation style.
26:      *
27:      * @param street the street as a string
28:      * @param city the city as a string
29:      * @param zipCode the zip code
30:      * @return the personalAddress object matching the parameters
31:      * @throws ShopException if ...
32:      *      - street is null or empty
33:      *      - city is null or empty
34:      *      - zipCode is null
35:      */
36:      // public static PersonalAddressType of( String street, String city, ZipCodeType zipCode );
37: }
38: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\usecases\domainprimitivetypes\ZipCodeType.java ---
1: package thkoeln.archilab.ecommerce.usecases.domainprimitivetypes;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: public interface ZipCodeType {
6:     /**
7:      * @return the zip code as a string
8:      */
9:     public String toString();
10: 
11:     /**
12:      * Unfortunately, Java interfaces cannot contain static methods. However, we expect the
13:      * implementing class to provide a static factory method (simply named "of(...)"),
14:      * which creates an zip code, given as a string.
15:      * We specify this factory method here as a comment, using the Javadoc documentation style.
16:      *
17:      * @param zipCodeAsString - the zip code as a string.
18:      *      We will use a much simplified validation method to check if the postal code is valid:
19:      *      - It must contain exactly 5 digits.
20:      *      - The last 4 digits must not be 0000 (i.e. 20000 is not a valid postal code, but 20001 is valid)
21:      * @return a new zip code object matching the given string
22:      * @throws ShopException if ...
23:      *      - zipCodeAsString is null
24:      *      - zipCodeAsString is not a valid zip code (see above)
25:      */
26:      // public static ZipCodeType of( String zipCodeAsString );
27: }
28: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\usecases\GoodCatalogUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
5: 
6: import java.util.UUID;
7: 
8: 
9: /**
10:  * This interface contains methods needed in the context of use cases dealing with managing the good catalog.
11:  * The interface is probably incomplete, and will grow over time.
12:  */
13: 
14: public interface GoodCatalogUseCases {
15:     /**
16:      * Adds a new good to the shop catalog
17:      * @param goodId
18:      * @param name
19:      * @param description
20:      * @param size
21:      * @param purchasePrice
22:      * @param sellingPrice
23:      * @throws ShopException if ...
24:      *      - goodId is null,
25:      *      - the good with that id already exists,
26:      *      - name or description are null or empty,
27:      *      - the size is <= 0 (but can be null!),
28:      *      - the purchase price is null,
29:      *      - the selling price is null,
30:      *      - the selling price is lower than the purchase price
31:      */
32:     public void addGoodToCatalog( UUID goodId, String name, String description, Float size,
33:                                            MoneyType purchasePrice, MoneyType sellingPrice );
34: 
35: 
36:     /**
37:      * Removes a good from the shop catalog
38:      * @param goodId
39:      * @throws ShopException if
40:      *      - goodId is null,
41:      *      - the good with that id does not exist
42:      *      - the good is still in inventory
43:      *      - the good is still reserved in a shopping basket, or part of a completed order
44:      */
45:     public void removeGoodFromCatalog( UUID goodId );
46: 
47: 
48:     /**
49:      * Get the selling price of a given good
50:      * @param goodId
51:      * @return the selling price
52:      * @throws ShopException if ...
53:      *      - goodId is null,
54:      *      - the good with that id does not exist
55:      */
56:     public MoneyType getSellingPrice( UUID goodId );
57: 
58: 
59:     /**
60:      * Clears the good catalog, i.e. removes all goods from the catalog, including all the inventory,
61:      * all the reservations and all the orders.
62:      */
63:     public void deleteGoodCatalog();
64: 
65: }
66: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\usecases\InventoryManagementUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: 
5: import java.util.UUID;
6: 
7: 
8: /**
9:  * This interface contains methods needed in the context of use cases dealing with managing the shop inventory,
10:  * i.e. adding and removing goods in the warehouse. The interface is probably incomplete, and
11:  * will grow over time.
12:  */
13: public interface InventoryManagementUseCases {
14:     /**
15:      * Adds a certain quantity of a given good to the inventory
16:      * @param goodId
17:      * @param addedQuantity
18:      * @throws ShopException if ...
19:      *      - goodId is null
20:      *      - the good with that id does not exist
21:      *      - addedQuantity <= 0
22:      */
23:     public void addToInventory( UUID goodId, int addedQuantity );
24: 
25: 
26:     /**
27:      * Removes a certain quantity of a given good from the inventory.
28:      * If the new total quantity is lower than the currently reserved goods, some of currently reserved goods
29:      * (in the users' shopping baskets) are removed. This means that some of the reserved goods are lost for
30:      * the user. (This is necessary because there probably was a mistake in the inventory management, a mis-counting,
31:      * or some of the goods were stolen from the warehouse, are broken, etc.)
32:      * @param goodId
33:      * @param removedQuantity
34:      * @throws ShopException if ...
35:      *      - goodId is null
36:      *      - the good with that id does not exist
37:      *      - removedQuantity <= 0
38:      *      - the removed quantity is greater than the current inventory and the currently reserved goods together
39:      */
40:     public void removeFromInventory( UUID goodId, int removedQuantity );
41: 
42: 
43:     /**
44:      * Changes the total quantity of a given good in the inventory.
45:      * If the new total quantity is lower than the currently reserved goods, some of currently reserved goods
46:      * (in the users' shopping baskets) are removed. This means that some of the reserved goods are lost for
47:      * the user. (This is necessary because there probably was a mistake in the inventory management, a mis-counting,
48:      * or some of the goods were stolen from the warehouse, are broken, etc.)
49:      * @param goodId
50:      * @param newTotalQuantity
51:      * @throws ShopException if ...
52:      *      - goodId is null
53:      *      - the good with that id does not exist
54:      *      - newTotalQuantity < 0
55:      */
56:     public void changeInventoryTo( UUID goodId, int newTotalQuantity );
57: 
58: 
59:     /**
60:      * Get the current total inventory of a given good, including the currently reserved goods
61:      * @param goodId
62:      * @return the current total inventory of the good
63:      * @throws ShopException if ...
64:      *      - goodId is null
65:      *      - the good with that id does not exist
66:      */
67:     public int getAvailableInventory( UUID goodId );
68: }
69: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\usecases\PaymentUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import java.util.UUID;
8: 
9: /**
10:  * This interface contains methods needed in the context of use cases dealing with payments.
11:  */
12: public interface PaymentUseCases {
13: 
14:     /**
15:      * Authorizes a payment from a bank card for a given amount
16:      *
17:      * @param userMailAddress
18:      * @param moneyAmount
19:      * @return the id of the payment, if successfully authorized
20:      * @throws ShopException if ...
21:      *      - userMailAddress is null
22:      *      - the amount is null
23:      *      - the amount is 0.00 EUR
24:      *      - the payment cannot be processed, because it is over the limit of 500.00 EUR
25:      */
26:     public UUID authorizePayment( MailAddressType userMailAddress, MoneyType moneyAmount );
27: 
28: 
29:     /**
30:      * Returns the total amount of payments (over the complete history) for a user
31:      * (identified by his/her mail address)
32:      *
33:      * @param userMailAddress
34:      * @return the total amount of payments made using this bank card, or 0.00 EUR if there
35:      *         weren't any payments yet.
36:      * @throws ShopException if ...
37:      *      - userMailAddress is null
38:      */
39:     public MoneyType getPaymentTotal( MailAddressType userMailAddress );
40: 
41: 
42:     /**
43:      * Deletes all payment history, for all users.
44:      */
45:     public void deletePaymentHistory();
46: }
47: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\usecases\ShoppingBasketUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import java.util.Map;
8: import java.util.UUID;
9: 
10: /**
11:  * This interface contains methods needed in the context of use cases dealing with the shopping basket.
12:  * The interface is probably incomplete, and will grow over time.
13:  */
14: public interface ShoppingBasketUseCases {
15:     /**
16:      * Adds a good to the shopping basket of a user
17:      *
18:      * @param userMailAddress
19:      * @param goodId
20:      * @param quantity
21:      * @throws ShopException if ...
22:      *      - the user with the given mailAddress does not exist,
23:      *      - the good does not exist,
24:      *      - the quantity <= 0,
25:      *      - the good is not available in the requested quantity
26:      */
27:     public void addGoodToShoppingBasket( MailAddressType userMailAddress, UUID goodId, int quantity );
28: 
29: 
30:     /**
31:      * Removes a good from the shopping basket of a user
32:      *
33:      * @param userMailAddress
34:      * @param goodId
35:      * @param quantity
36:      * @throws ShopException if ...
37:      *      - userMailAddress is null,
38:      *      - the user with the given mailAddress does not exist,
39:      *      - the good does not exist
40:      *      - the quantity <= 0,
41:      *      - the good is not in the shopping basket in the requested quantity
42:      */
43:     public void removeGoodFromShoppingBasket( MailAddressType userMailAddress, UUID goodId, int quantity );
44: 
45: 
46:     /**
47:      * Sets a comment in the shopping basket position containing a good
48:      *
49:      * @param userMailAddress
50:      * @param goodId
51:      * @param comment (can be null)
52:      * @throws ShopException if ...
53:      *      - userMailAddress is null,
54:      *      - the user with the given mailAddress does not exist,
55:      *      - the good does not exist
56:      *      - the good is not in the shopping basket
57:      */
58:     public void setCommentForShoppingBasketPosition( MailAddressType userMailAddress, UUID goodId, String comment );
59: 
60: 
61:     /**
62:      * Returns the comment in the shopping basket position containing a good
63:      *
64:      * @param userMailAddress
65:      * @param goodId
66:      * @return the comment (can be null)
67:      * @throws ShopException if ...
68:      *      - userMailAddress is null,
69:      *      - the user with the given mailAddress does not exist,
70:      *      - the good does not exist
71:      *      - the good is not in the shopping basket
72:      */
73:     public String getCommentForShoppingBasketPosition( MailAddressType userMailAddress, UUID goodId );
74: 
75: 
76:     /**
77:      * Returns a map showing which goods are in the shopping basket of a user and how many of each good
78:      *
79:      * @param userMailAddress
80:      * @return the shopping basket of the user (map is empty if the shopping basket is empty)
81:      * @throws ShopException if ...
82:      *      - userMailAddress is null,
83:      *      - the user with the given mailAddress does not exist
84:      */
85:     public Map<UUID, Integer> getShoppingBasketAsMap( MailAddressType userMailAddress );
86: 
87: 
88:     /**
89:      * Returns the current value of all goods in the shopping basket of a user
90:      *
91:      * @param userMailAddress
92:      * @return the value of shopping basket of the user
93:      * @throws ShopException if ...
94:      *      - userMailAddress is null,
95:      *      - the user with the given mailAddress does not exist
96:      */
97:     public MoneyType getShoppingBasketAsMoneyValue( MailAddressType userMailAddress );
98: 
99: 
100: 
101:     /**
102:      * Get the number units of a specific good that are currently reserved in the shopping baskets of all users
103:      * @param goodId
104:      * @return the number of reserved goods of that type in all shopping baskets
105:      * @throws ShopException
106:      *      - goodId is null
107:      *      - if the good id does not exist
108:      */
109:     public int getReservedInventoryInShoppingBaskets( UUID goodId );
110: 
111: 
112:     /**
113:      * Checks if the shopping basket of a user is empty
114:      *
115:      * @param userMailAddress
116:      * @return true if the shopping basket is empty, false otherwise
117:      * @throws ShopException if ...
118:      *    - userMailAddress is null
119:      *    - the user with the given mail address does not exist
120:      */
121:     public boolean isEmpty( MailAddressType userMailAddress );
122: 
123: 
124:     /**
125:      * Checks if the payment for a specific shopping basket of a user has been authorized to be paid,
126:      * i.e. the shopping basket is not empty, the user has given his/her payment details, and the payment
127:      * has been authorized (under the limits of the user's credit card). However, the order
128:      * has not yet been placed yet, and the logistics details have not yet been given.
129:      *
130:      * @param userMailAddress
131:      * @return true if the payment has been authorized, false otherwise
132:      * @throws ShopException if ...
133:      *      - userMailAddress is null
134:      *      - the user with the given mail address does not exist
135:      */
136:     public boolean isPaymentAuthorized( MailAddressType userMailAddress );
137: 
138: 
139:     /**
140:      * Checks out the shopping basket of a user
141:      *
142:      * @param userMailAddress
143:      * @throws ShopException if ... 
144:      * @throws ShopException if ...
145:      *      - userMailAddress is null
146:      *      - the user with the given mail address does not exist
147:      *      - the shopping basket is empty
148:      */
149:     public void checkout( MailAddressType userMailAddress );
150: 
151: 
152: 
153: 
154:     /**
155:      * Returns a map showing which goods have been ordered by a user, and how many of each good
156:      *
157:      * @param userMailAddress
158:      * @return the order history of the user (map is empty if the user has not ordered anything yet)
159:      * @Deprecated Might be split into a dedicated OrderUseCases interface later (but still valid in this milestone)
160:      * @throws ShopException if
161:      *      - the mail address is null
162:      *      - the user with the given mail address does not exist
163:      */
164:     public Map<UUID, Integer> getOrderHistory( MailAddressType userMailAddress );
165: 
166: 
167: 
168:     /**
169:      * Deletes all orders and shopping baskets in the system
170:      * @Deprecated Might be split into two methods later (delete orders and delete shopping baskets), with
171:      *             the order deletion moved to a dedicated OrderUseCases interface later
172:      *             (but still valid in this milestone)
173:      */
174:     public void deleteAllOrders();
175: }
176: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\usecases\UserRegistrationUseCases.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.ShopException;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
6: 
7: /**
8:  * This interface contains methods needed in the context of use cases dealing with registering a user.
9:  * The interface is probably incomplete, and will grow over time.
10:  */
11: public interface UserRegistrationUseCases {
12:     /**
13:      * Registers a new user
14:      *
15:      * @param name
16:      * @param mailAddress
17:      * @param personalAddress
18:      * @throws ShopException if ...
19:      *      - name is null or empty
20:      *      - mailAddress is null
21:      *      - user with the given mail address already exists
22:      *      - personalAddress is null
23:      */
24:     public void register( String name, MailAddressType mailAddress, PersonalAddressType personalAddress );
25: 
26: 
27:     /**
28:      * Changes the personalAddress of a user
29:      *
30:      * @param userMailAddress
31:      * @param personalAddress
32:      * @throws ShopException if ...
33:      *      - mailAddress is null
34:      *      - user with the given mail address already exists
35:      *      - personalAddress is null
36:      */
37:     public void changeAddress( MailAddressType userMailAddress, PersonalAddressType personalAddress );
38: 
39: 
40:     /**
41:      * Returns the data of a user
42:      * @param userMailAddress
43:      * @return the user data
44:      * @throws ShopException if ...
45:      *      - mailAddress is null
46:      *      - the user with the given mail address does not exist
47:      */
48:     public UserType getUserData( MailAddressType userMailAddress );
49: 
50: 
51: 
52:     /**
53:      * Deletes all users, including all orders and shopping baskets
54:      */
55:     public void deleteAllUsers();
56: }
57: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\main\java\thkoeln\archilab\ecommerce\usecases\UserType.java ---
1: package thkoeln.archilab.ecommerce.usecases;
2: 
3: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
4: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.PersonalAddressType;
5: 
6: /**
7:  * This interface expresses the essence of a shop user
8:  */
9: public interface UserType {
10:     public String getName();
11:     public MailAddressType getMailAddress();
12:     public PersonalAddressType getPersonalAddress();
13: }
14: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\codereview\E3DDDOutsideSolutionRulesTest.java ---
1: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\codereview\E3DDDRulesTest.java ---
1: package thkoeln.archilab.ecommerce.codereview;
2: 
3: import com.tngtech.archunit.junit.AnalyzeClasses;
4: import com.tngtech.archunit.junit.ArchTag;
5: import com.tngtech.archunit.junit.ArchTest;
6: import com.tngtech.archunit.lang.ArchRule;
7: import org.springframework.data.repository.CrudRepository;
8: import org.springframework.stereotype.Service;
9: 
10: import javax.persistence.Entity;
11: import javax.persistence.Id;
12: 
13: import java.util.UUID;
14: 
15: import static com.tngtech.archunit.core.domain.JavaMember.Predicates.declaredIn;
16: import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.*;
17: 
18: @ArchTag("layerRules")
19: @AnalyzeClasses(packages = "thkoeln.archilab.ecommerce.solution")
20: @SuppressWarnings("PMD")
21: public class E3DDDRulesTest {
22: 
23:     @ArchTest
24:     static final ArchRule domainClassesMayOnlyCallOtherDomainClasses =
25:             noClasses().that().resideInAPackage("..domain..")
26:                     .should().dependOnClassesThat().resideInAPackage("..application..");
27: 
28:     @ArchTest
29:     static final ArchRule entitiesMustResideInADomainPackage =
30:             classes().that().areAnnotatedWith( Entity.class ).should().resideInAPackage("..domain..")
31:                     .as("Entities must reside in a package '..domain..'");
32: 
33:     @ArchTest
34:     static final ArchRule entitiesMustNotAccessRepositories =
35:             noClasses().that().areAnnotatedWith( Entity.class )
36:                     .should().dependOnClassesThat().areAssignableTo( CrudRepository.class );
37: 
38:     @ArchTest
39:     static final ArchRule repositoriesMustResideInADomainPackage =
40:             classes().that().areAssignableTo( CrudRepository.class ).should().resideInAPackage("..domain..")
41:                     .as("Repositories must reside in a package '..domain..'");
42: 
43:     @ArchTest
44:     static final ArchRule repositoryNamesMustHaveProperSuffix =
45:             classes().that().areAssignableTo( CrudRepository.class )
46:                     .should().haveSimpleNameEndingWith("Repository");
47: 
48:     @ArchTest
49:     static final ArchRule servicesMustResideInAnApplicationPackage =
50:             classes().that().areAnnotatedWith( Service.class ).should().resideInAPackage("..application..")
51:                     .as("Application Services must reside in a package '..application..'");
52: 
53:     @ArchTest
54:     static final ArchRule serviceNamesMustHaveProperSuffix =
55:             classes().that().areAnnotatedWith( Service.class )
56:                     .should().haveSimpleNameEndingWith("Service");
57: 
58:     @ArchTest
59:     static final ArchRule noClassesOnTopLevel =
60:             classes().should().resideInAPackage( "..solution.*.." );
61: 
62:     @ArchTest
63:     static final ArchRule noNonIdFieldsOfTypeIUUID =
64:             fields()
65:                     .that().areDeclaredInClassesThat().areAnnotatedWith( Entity.class )
66:                     .and().areNotAnnotatedWith( Id.class )
67:                     .and().areDeclaredInClassesThat().doNotHaveSimpleName( "Good" )
68:                     .should().notHaveRawType( UUID.class );
69: }
70: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\codereview\E3NoCycleTest.java ---
1: package thkoeln.archilab.ecommerce.codereview;
2: 
3: import com.tngtech.archunit.core.domain.JavaClass;
4: import com.tngtech.archunit.core.domain.JavaClasses;
5: import com.tngtech.archunit.core.importer.ClassFileImporter;
6: import com.tngtech.archunit.lang.ArchRule;
7: import com.tngtech.archunit.library.dependencies.SliceAssignment;
8: import com.tngtech.archunit.library.dependencies.SliceIdentifier;
9: import org.junit.jupiter.api.Test;
10: 
11: import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
12: 
13: public class E3NoCycleTest {
14:     private JavaClasses importedClasses = new ClassFileImporter().importPackages("thkoeln.archilab.ecommerce.solution");
15: 
16:     private SliceAssignment inAllClasses() {
17:         return new SliceAssignment() {
18:             @Override
19:             public String getDescription() {
20:                 return "every class in it's own slice";
21:             }
22: 
23:             @Override
24:             public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
25:                 return SliceIdentifier.of("In-All-Classes", javaClass.getPackageName(), javaClass.getName());
26:             }
27:         };
28:     }
29: 
30:     @Test
31:     public void testNoCyclicDependenciesBetweenClasses() {
32:         slices().assignedFrom(inAllClasses())
33:                 .namingSlices("$1[$2.$3]")
34:                 .should().beFreeOfCycles()
35:                 .check(importedClasses);
36:     }
37: 
38:     @Test
39:     public void testNoCyclicDependenciesBetweenPackages() {
40:         ArchRule rule = slices().matching("..solution.(*)..").should().beFreeOfCycles();
41:         rule.check(importedClasses);
42:     }
43: }
44: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\codereview\E3PackageStructureTest.java ---
1: package thkoeln.archilab.ecommerce.codereview;
2: 
3: import com.tngtech.archunit.core.domain.JavaClasses;
4: import com.tngtech.archunit.core.importer.ClassFileImporter;
5: import org.junit.jupiter.api.BeforeEach;
6: import org.junit.jupiter.api.Test;
7: 
8: import static org.assertj.core.api.Assertions.assertThat;
9: import static org.junit.jupiter.api.Assertions.assertTrue;
10: 
11: public class E3PackageStructureTest {
12: 
13:     private static final String[] REQUIRED_PACKAGES = {"user", "shoppingbasket", "good", "order"};
14:     private static final String BASE_PACKAGE = "thkoeln.archilab.ecommerce.solution";
15:     private JavaClasses importedClasses;
16: 
17: 
18:     @BeforeEach
19:     public void setUp() {
20:         importedClasses = new ClassFileImporter().importPackages( "thkoeln.archilab.ecommerce.solution" );
21:     }
22: 
23:     @Test
24:     void testRequiredPackagesAreThere() {
25:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
26:             String packageName = BASE_PACKAGE + "." + requiredPackage;
27:             assertThat( importedClasses.containPackage( packageName ) )
28:                     .as( "Expected package %s not found!", packageName )
29:                     .isTrue();
30:         }
31:     }
32: 
33:     @Test
34:     void testRequiredDomainPackagesAreThere() {
35:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
36:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".domain";
37:             assertThat( importedClasses.containPackage( packageName ) )
38:                     .as( "Expected domain sub-package %s not found!", packageName )
39:                     .isTrue();
40:         }
41:     }
42: 
43:     @Test
44:     void testRequiredApplicationPackagesAreThere() {
45:         for ( String requiredPackage : REQUIRED_PACKAGES ) {
46:             String packageName = BASE_PACKAGE + "." + requiredPackage + ".application";
47:             assertThat( importedClasses.containPackage( packageName ) )
48:                     .as( "Expected application sub-package %s not found!", packageName )
49:                     .isTrue();
50:         }
51:     }
52: 
53: }
54: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\codereview\E3RequiredClassesTest.java ---
1: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\E1OrdertRESTTest.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import org.springframework.test.context.ActiveProfiles;
9: import org.springframework.test.web.servlet.MockMvc;
10: import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
13: 
14: import javax.transaction.Transactional;
15: import java.util.UUID;
16: 
17: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
18: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
19: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
20: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
21: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.instantiateMailAddress;
22: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.GOOD_DATA;
23: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.USER_EMAIL;
24: 
25: @SpringBootTest
26: @Transactional
27: @AutoConfigureMockMvc
28: @ActiveProfiles("test")
29: public class E1OrdertRESTTest {
30: 
31:     @Autowired
32:     private InitialMasterDataCreator initialMasterDataCreator;
33:     @Autowired
34:     private MockMvc mockMvc;
35: 
36:     private RESTHelper restHelper;
37:     private MailAddressType nonExistingMailAddress;
38: 
39: 
40:     @BeforeEach
41:     public void setUp() {
42:         initialMasterDataCreator.deleteAll();
43: 
44:         initialMasterDataCreator.addAllGoods();
45:         initialMasterDataCreator.inventoryUpAllGoods();
46:         initialMasterDataCreator.registerAllUsers();
47: 
48:         restHelper = new RESTHelper( mockMvc );
49:         nonExistingMailAddress = instantiateMailAddress( "harry@sally.de" );
50:     }
51: 
52: 
53:     @Test
54:     public void testGetNoOrders() throws Exception {
55:         // given
56:         // when
57:         // then
58:         mockMvc.perform( get( "/orders" ) )
59:                 .andExpect( status().isOk() )
60:                 .andExpect( jsonPath( "$.length()" ).value( 0 ) );
61:         mockMvc.perform( get( "/orders?mailAddress=" + nonExistingMailAddress ) )
62:                 .andExpect( status().isOk() )
63:                 .andExpect( jsonPath( "$.length()" ).value( 0 ) );
64:         mockMvc.perform( get( "/orders?mailAddress=invalidEmailString" ) )
65:                 .andExpect( status().isOk() )
66:                 .andExpect( jsonPath( "$.length()" ).value( 0 ) );
67:         mockMvc.perform( get( "/orders?mailAddress=" + USER_EMAIL[3].toString() ) )
68:                 .andExpect( status().isOk() )
69:                 .andExpect( jsonPath( "$.length()" ).value( 0 ) );
70:     }
71: 
72: 
73:     @Test void testMakeThreeOrders() throws Exception {
74:         // given
75:         String mailAddressString = USER_EMAIL[6].toString();
76: 
77:         UUID goodId2 = (UUID) GOOD_DATA[2][0];
78:         UUID goodId4 = (UUID) GOOD_DATA[4][0];
79:         UUID goodId6 = (UUID) GOOD_DATA[6][0];
80:         Float goodMoneyAmount2 = ((MoneyType) GOOD_DATA[2][5]).getAmount() * 2;
81:         Float goodMoneyAmount4 = ((MoneyType) GOOD_DATA[4][5]).getAmount() * 4;
82:         Float goodMoneyAmount6 = ((MoneyType) GOOD_DATA[6][5]).getAmount() * 6;
83: 
84:         String uriAllOrders = "/orders?mailAddress=" + mailAddressString;
85:         String uriLatestOrder = uriAllOrders + "&filter=latest";
86: 
87:         // when
88:         restHelper.makeOrderForUser( mailAddressString, goodId2, 2 );
89:         restHelper.makeOrderForUser( mailAddressString, goodId4, 4 );
90:         restHelper.makeOrderForUser( mailAddressString, goodId6, 6 );
91: 
92:         // then get all orders ...
93:         mockMvc.perform( get( uriAllOrders ) )
94:                 .andExpect( status().isOk() )
95:                 .andExpect( jsonPath( "$.length()" ).value( 3 ) )
96: 
97:                 .andExpect( jsonPath( "$[0].mailAddress.mailAddressString" ).value( mailAddressString ) )
98:                 .andExpect( jsonPath( "$[0].price.amount" ).value( goodMoneyAmount2 ) )
99: 
100:                 .andExpect( jsonPath( "$[1].mailAddress.mailAddressString" ).value( mailAddressString ) )
101:                 .andExpect( jsonPath( "$[1].price.amount" ).value( goodMoneyAmount4 ) )
102: 
103:                 .andExpect( jsonPath( "$[2].mailAddress.mailAddressString" ).value( mailAddressString ) )
104:                 .andExpect( jsonPath( "$[2].price.amount" ).value( goodMoneyAmount6 ) );
105: 
106:         // ... and the latest order
107:         mockMvc.perform( get( uriLatestOrder ) )
108:                 .andExpect( status().isOk() )
109:                 .andExpect( jsonPath( "$.length()" ).value( 1 ) )
110:                 .andExpect( jsonPath( "$[0].price.amount" ).value( goodMoneyAmount6 ) );
111:     }
112: 
113: 
114:     @Test
115:     public void testIfMoneySumInOrderIsCorrect() throws Exception {
116:         // given
117:         String mailAddressString = USER_EMAIL[3].toString();
118:         UUID goodId3 = (UUID) GOOD_DATA[3][0];
119:         UUID goodId4 = (UUID) GOOD_DATA[4][0];
120:         Integer quantity3 = 14;
121:         Integer quantity4 = 5;
122:         Float goodMoneyAmount =
123:                 ((MoneyType) GOOD_DATA[3][5]).getAmount() * quantity3 +
124:                 ((MoneyType) GOOD_DATA[4][5]).getAmount() * quantity4;
125: 
126:         // when
127:         UUID shoppingBasketId = restHelper.getShoppingBasketId( mailAddressString );
128:         restHelper.addGoodToShoppingBasket( shoppingBasketId, goodId3, quantity3 );
129:         restHelper.addGoodToShoppingBasket( shoppingBasketId, goodId4, quantity4 );
130:         mockMvc.perform( put( "/shoppingBaskets/" + shoppingBasketId.toString() + "/checkout" ) )
131:                 .andExpect( status().isOk() );
132: 
133:         // then
134:         mockMvc.perform( get(
135:                 "/orders?mailAddress=" + mailAddressString + "&filter=latest") )
136:                 .andExpect( status().isOk() )
137:                 .andExpect( jsonPath( "$.length()" ).value( 1 ) )
138:                 .andExpect( jsonPath( "$[0].price.amount" ).value( goodMoneyAmount ) );
139:     }
140: 
141: 
142: 
143: }
144: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\E2ShoppingBasketRESTTest.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import org.springframework.test.context.ActiveProfiles;
9: import org.springframework.test.web.servlet.MockMvc;
10: import org.springframework.test.web.servlet.ResultMatcher;
11: import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
13: 
14: import javax.transaction.Transactional;
15: import java.util.UUID;
16: 
17: import static org.springframework.http.MediaType.APPLICATION_JSON;
18: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
19: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
20: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
21: import static thkoeln.archilab.ecommerce.e1e2resttests.RESTHelper.CONFLICT;
22: import static thkoeln.archilab.ecommerce.e1e2resttests.RESTHelper.CREATED;
23: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.instantiateMailAddress;
24: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.GOOD_DATA;
25: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.USER_EMAIL;
26: 
27: @SpringBootTest
28: @Transactional
29: @AutoConfigureMockMvc
30: @ActiveProfiles("test")
31: public class E2ShoppingBasketRESTTest {
32: 
33:     @Autowired
34:     private InitialMasterDataCreator initialMasterDataCreator;
35:     @Autowired
36:     private MockMvc mockMvc;
37: 
38:     private RESTHelper restHelper;
39:     private MailAddressType nonExistingMailAddress;
40: 
41: 
42:     @BeforeEach
43:     public void setUp() {
44:         initialMasterDataCreator.deleteAll();
45: 
46:         initialMasterDataCreator.addAllGoods();
47:         initialMasterDataCreator.inventoryUpAllGoods();
48:         initialMasterDataCreator.registerAllUsers();
49: 
50:         restHelper = new RESTHelper( mockMvc );
51:         nonExistingMailAddress = instantiateMailAddress( "harry@sally.de" );
52:     }
53: 
54: 
55:     @Test
56:     public void testEmptyShoppingBasket() throws Exception {
57:         // given
58:         String validUri = "/shoppingBaskets?mailAddress=" + USER_EMAIL[4].toString();
59:         String invalidUri1 = "/shoppingBaskets?mailAddress=" + nonExistingMailAddress.toString();
60:         String invalidUri2 = "/shoppingBaskets?mailAddress=justaninvalidemailaddress";
61: 
62:         // when
63:         // then
64:         mockMvc.perform( get( validUri ) )
65:                 .andExpect( status().isOk() )
66:                 .andExpect( jsonPath( "$.totalQuantity" ).value( 0 ) );
67:         mockMvc.perform( get( invalidUri1 ) )
68:                 .andExpect( status().isNotFound() );
69:         mockMvc.perform( get( invalidUri2 ) )
70:                 .andExpect( status().isNotFound() );
71:     }
72: 
73: 
74:     @Test
75:     public void testInvalidUris() throws Exception {
76:         // given
77:         UUID goodId = (UUID) GOOD_DATA[3][0];
78:         String userEmailString = USER_EMAIL[4].toString();
79:         UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
80: 
81:         String invalidPostUri = "/shoppingBaskets/" + UUID.randomUUID() + "/shoppingBasketPositions";
82:         String invalidPatchGetDeleteUri1 =
83:                 "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions/" + UUID.randomUUID();
84:         String invalidPatchGetDeleteUri2 =
85:                 "/shoppingBaskets/" + UUID.randomUUID().toString() + "/shoppingBasketPositions/" + goodId;
86:         String invalidCheckoutUri1 = "/shoppingBaskets/" + shoppingBasketId + "/chekkout";
87:         String invalidCheckoutUri2 = "/shoppingBaskets/" + UUID.randomUUID() + "/checkout";
88: 
89:         // when
90:         // then
91:         mockMvc.perform( post( invalidPostUri )
92:                 .contentType( APPLICATION_JSON ).content( "[]" ) ).andExpect( status().is4xxClientError() );
93: 
94:         mockMvc.perform( delete( invalidPatchGetDeleteUri1 ) ).andExpect( status().isNotFound() );
95:         mockMvc.perform( get( invalidPatchGetDeleteUri1 ) ).andExpect( status().isNotFound() );
96: 
97:         mockMvc.perform( delete( invalidPatchGetDeleteUri2 ) ).andExpect( status().isNotFound() );
98:         mockMvc.perform( get( invalidPatchGetDeleteUri2 ) ).andExpect( status().isNotFound() );
99: 
100:         mockMvc.perform( put( invalidCheckoutUri1 ) ).andExpect( status().isNotFound() );
101:         mockMvc.perform( put( invalidCheckoutUri2 ) ).andExpect( status().isNotFound() );
102:     }
103: 
104: 
105:     @Test
106:     public void testQueryNonExistingGood() throws Exception {
107:         // given
108:         UUID goodId = (UUID) GOOD_DATA[3][0];
109:         String userEmailString = USER_EMAIL[7].toString();
110:         UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
111:         String invalidUri = "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions/" + goodId;
112: 
113:         // when
114:         // then
115:         mockMvc.perform( get( invalidUri ) ).andExpect( status().isNotFound() );
116:     }
117: 
118: 
119:     @Test
120:     public void testDeleteFromShoppingBasket() throws Exception {
121:         // given
122:         UUID goodId1 = (UUID) GOOD_DATA[1][0];
123:         String userEmailString9 = USER_EMAIL[9].toString();
124:         String userEmailString7 = USER_EMAIL[7].toString();
125: 
126:         UUID shoppingBasketId9 = restHelper.getShoppingBasketId( userEmailString9 );
127:         UUID shoppingBasketId7 = restHelper.getShoppingBasketId( userEmailString7 );
128: 
129:         String baseUri9 = "/shoppingBaskets/" + shoppingBasketId9 + "/shoppingBasketPositions/";
130:         String checkoutUri9 = "/shoppingBaskets/" + shoppingBasketId9 + "/checkout";
131:         String checkoutUri7 = "/shoppingBaskets/" + shoppingBasketId7 + "/checkout";
132: 
133:         // when
134:         restHelper.addMultipleGoodsToShoppingBasket( userEmailString9,
135:                 new Integer[]{1, 4, 6}, new Integer[]{1, 4, 6}, new String[]{"c1", "c4", "c6"} );
136:         restHelper.checkMultipleShoppingBasketPositions(
137:                 userEmailString9, new Integer[]{1, 4, 6}, new Integer[]{1, 4, 6},
138:                 new String[]{"c1", "c4", "c6"} );
139:         mockMvc.perform( delete( baseUri9 + goodId1 ) )
140:                 .andExpect( status().isOk() );
141:         restHelper.checkMultipleShoppingBasketPositions(
142:                 userEmailString9, new Integer[]{1, 4, 6}, new Integer[]{null, 4, 6},
143:                 new String[]{null, "c4", "c6"}, new Boolean[]{false, true, true} );
144:         // ... and another customer can still buy 10 of the "Nr. 1" good
145:         restHelper.addGoodToShoppingBasket( shoppingBasketId7, goodId1, 10,
146:                 "still10", null );
147: 
148:         // then
149:         mockMvc.perform( put( checkoutUri9 ) ).andExpect( status().isOk() );
150:         restHelper.checkMultipleOrderPositionsInLatestOrder( userEmailString9,
151:                 new Integer[]{4, 6}, new Integer[]{4, 6}, new String[]{"c4", "c6"} );
152:         mockMvc.perform( put( checkoutUri7 ) ).andExpect( status().isOk() );
153:         restHelper.checkMultipleOrderPositionsInLatestOrder( userEmailString7,
154:                 new Integer[]{1}, new Integer[]{10}, new String[]{"still10"} );
155:     }
156: 
157: 
158:     @Test
159:     public void testAddToAndRemoveFromShoppingBasket() throws Exception {
160:         // given
161:         String userEmailString = USER_EMAIL[2].toString();
162:         UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
163:         String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
164: 
165:         // when
166:         restHelper.addMultipleGoodsToShoppingBasket( userEmailString,
167:                 new Integer[]{2, 4, 2, 4, 6, 2}, new Integer[]{2, 3, 4, -1, 3, -6},
168:                 new String[]{null, "c4a", "c2a", "c4b", "c6", null} );
169:         restHelper.checkMultipleShoppingBasketPositions(
170:                 userEmailString, new Integer[]{2, 4, 6}, new Integer[]{null, 2, 3},
171:                 new String[]{null, "c4b", "c6"}, new Boolean[]{false, true, true} );
172: 
173:         // then
174:         mockMvc.perform( put( checkoutUri ) ).andExpect( status().isOk() );
175:         restHelper.checkMultipleOrderPositionsInLatestOrder( userEmailString,
176:                 new Integer[]{4, 6}, new Integer[]{2, 3}, new String[]{"c4b", "c6"} );
177:     }
178: 
179: 
180:     @Test
181:     public void testRemoveMoreThanThereIsInShoppingBasket() throws Exception {
182:         // given
183:         String userEmailString = USER_EMAIL[2].toString();
184: 
185:         // when
186:         // then
187:         restHelper.addMultipleGoodsToShoppingBasket( userEmailString,
188:                 new Integer[]{2, 4, 2}, new Integer[]{2, 3, -3}, new String[]{null, null, null},
189:                 new ResultMatcher[]{CREATED, CREATED, CONFLICT} );
190:     }
191: 
192: 
193:     @Test
194:     public void testAddMoreThanIsInInventory() throws Exception {
195:         // given
196:         String userEmailString = USER_EMAIL[7].toString();
197: 
198:         // when
199:         // then
200:         restHelper.addMultipleGoodsToShoppingBasket( userEmailString,
201:                 new Integer[]{1, 1, 1, 1}, new Integer[]{2, 3, 4, 2}, new String[]{null, null, null, null},
202:                 new ResultMatcher[]{CREATED, CREATED, CREATED, CONFLICT} );
203:     }
204: 
205: 
206:     @Test
207:     public void testSuccessfulCheckoutJustWithinPaymentLimit() throws Exception {
208:         // given
209:         String userEmailString = USER_EMAIL[5].toString();
210:         UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
211:         String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
212: 
213:         // when
214:         restHelper.addMultipleGoodsToShoppingBasket( userEmailString,
215:                 new Integer[]{11, 13, 10, 6}, new Integer[]{1, 1, 1, 17}, new String[]{"350€", "100€", "35€", "8.50€"} );
216: 
217:         // then
218:         mockMvc.perform( put( checkoutUri ) ).andExpect( status().isOk() );
219:         restHelper.checkMultipleOrderPositionsInLatestOrder( userEmailString,
220:                 new Integer[]{11, 13, 10, 6}, new Integer[]{1, 1, 1, 17}, new String[]{"350€", "100€", "35€", "8.50€"} );
221:     }
222: 
223: 
224: 
225:     @Test
226:     public void testUnsuccessfulCheckoutAbovePaymentLimit() throws Exception {
227:         // given
228:         String userEmailString = USER_EMAIL[1].toString();
229:         UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
230:         String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
231: 
232:         // when
233:         restHelper.addMultipleGoodsToShoppingBasket( userEmailString,
234:                 new Integer[]{13, 10}, new Integer[]{4, 3}, new String[]{"400€", "105€"} );
235: 
236:         // then
237:         mockMvc.perform( put( checkoutUri ) ).andExpect( status().isConflict() );
238:     }
239: 
240: 
241:     @Test
242:     public void testUnsuccessfulCheckoutAboveDeliveryLimit() throws Exception {
243:         // given
244:         String userEmailString = USER_EMAIL[8].toString();
245:         UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
246:         String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
247: 
248:         // when
249:         restHelper.addMultipleGoodsToShoppingBasket( userEmailString,
250:                 new Integer[]{13, 6}, new Integer[]{3, 18}, new String[]{"300€", "9€"} );
251: 
252:         // then
253:         mockMvc.perform( put( checkoutUri ) ).andExpect( status().isConflict() );
254:     }
255: 
256: 
257:     @Test
258:     public void testNoCheckoutForEmptyShoppingBasket() throws Exception {
259:         // given
260:         String userEmailString = USER_EMAIL[9].toString();
261:         UUID shoppingBasketId = restHelper.getShoppingBasketId( userEmailString );
262:         String checkoutUri = "/shoppingBaskets/" + shoppingBasketId + "/checkout";
263: 
264:         // when
265:         // then
266:         mockMvc.perform( put( checkoutUri ) ).andExpect( status().isConflict() );
267:     }
268: }
269: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\RESTHelper.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests;
2: 
3: import com.fasterxml.jackson.databind.ObjectMapper;
4: import org.springframework.test.web.servlet.MockMvc;
5: import org.springframework.test.web.servlet.MvcResult;
6: import org.springframework.test.web.servlet.ResultActions;
7: import org.springframework.test.web.servlet.ResultMatcher;
8: import thkoeln.archilab.ecommerce.e1e2resttests.testdtos.IdDTO;
9: import thkoeln.archilab.ecommerce.e1e2resttests.testdtos.QuantityAndCommentDTO;
10: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
11: 
12: import java.util.HashMap;
13: import java.util.Map;
14: import java.util.UUID;
15: 
16: import static org.springframework.http.MediaType.APPLICATION_JSON;
17: import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
18: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
19: import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
20: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.GOOD_DATA;
21: 
22: public class RESTHelper {
23:     private MockMvc mockMvc;
24: 
25:     public static final ResultMatcher NOT_FOUND = status().isNotFound();
26:     public static final ResultMatcher OK = status().isOk();
27:     public static final ResultMatcher CREATED = status().isCreated();
28:     public static final ResultMatcher UNPROCESSABLE_ENTITY = status().isUnprocessableEntity();
29:     public static final ResultMatcher CONFLICT = status().isConflict();
30: 
31:     public RESTHelper( MockMvc mockMvc ) {
32:         this.mockMvc = mockMvc;
33:     }
34: 
35:     public void makeOrderForUser( String mailAddressString, UUID goodId, Integer quantity ) throws Exception {
36:         UUID shoppingBasketId = getShoppingBasketId( mailAddressString );
37:         addGoodToShoppingBasket( shoppingBasketId, goodId, quantity );
38:         mockMvc.perform( put( "/shoppingBaskets/" + shoppingBasketId.toString() + "/checkout" ) )
39:                 .andExpect( OK );
40:     }
41: 
42:     public UUID getShoppingBasketId( String mailAddressString ) throws Exception {
43:         // get the shopping basket and extract its id ...
44:         MvcResult shoppingBasket = mockMvc.perform( get( "/shoppingBaskets?mailAddress=" + mailAddressString ) )
45:                 .andExpect( OK )
46:                 .andExpect( jsonPath( "$.id" ).isNotEmpty() )
47:                 .andReturn();
48:         ObjectMapper objectMapper = new ObjectMapper();
49:         IdDTO idDTO = objectMapper.readValue( shoppingBasket.getResponse().getContentAsString(), IdDTO.class );
50:         return idDTO.getId();
51:     }
52: 
53:     public void addGoodToShoppingBasket( UUID shoppingBasketId, UUID goodId, Integer quantity,
54:                                                  String comment, ResultMatcher expectedStatus )
55:                                                 throws Exception {
56:         ResultMatcher status = expectedStatus == null ? CREATED : expectedStatus;
57:         ObjectMapper objectMapper = new ObjectMapper();
58:         QuantityAndCommentDTO dto = new QuantityAndCommentDTO( goodId, quantity, comment );
59:         String quantityJson = objectMapper.writeValueAsString( dto );
60:         mockMvc.perform( post( "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions" )
61:                 .contentType( APPLICATION_JSON ).content( quantityJson ) )
62:                 .andExpect( status );
63:     }
64: 
65: 
66:     public void addGoodToShoppingBasket( UUID shoppingBasketId, UUID goodId, Integer quantity )
67:             throws Exception {
68:         addGoodToShoppingBasket( shoppingBasketId, goodId, quantity, null, null );
69:     }
70: 
71: 
72: 
73:     public void addMultipleGoodsToShoppingBasket(
74:             String userEmailString, Integer[] goodIndices, Integer[] quantities, String[] comments,
75:             ResultMatcher[] expectedAddStatuses ) throws Exception {
76:         UUID shoppingBasketId = getShoppingBasketId( userEmailString );
77:         String shoppingBasketUri = "shoppingBaskets?mailAddress=" + userEmailString;
78:         String baseUri = "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions/";
79: 
80:         // add all the goods to the shopping basket ...
81:         Map<Integer, Integer> quantityMap = new HashMap<>();
82:         Map<Integer, String> commentMap = new HashMap<>();
83:         for ( int i = 0; i < goodIndices.length; i++ ) {
84:             UUID goodId = (UUID) GOOD_DATA[goodIndices[i]][0];
85:             addGoodToShoppingBasket( shoppingBasketId, goodId, quantities[i], comments[i], expectedAddStatuses[i] );
86:             if ( expectedAddStatuses[i] != null || expectedAddStatuses[i] == CREATED || expectedAddStatuses[i] == OK ) {
87:                 quantityMap.put( goodIndices[i],
88:                         quantities[i] + quantityMap.getOrDefault( goodIndices[i], 0 ) );
89:                 commentMap.put( goodIndices[i], comments[i] );
90:             }
91:         }
92:     }
93: 
94: 
95:     public void addMultipleGoodsToShoppingBasket(
96:             String userEmailString, Integer[] goodIndices, Integer[] quantities,
97:             String[] comments ) throws Exception {
98:         ResultMatcher[] expectedAddStatuses = new ResultMatcher[goodIndices.length];
99:         for ( int i = 0; i < goodIndices.length; i++ ) {
100:             expectedAddStatuses[i] = CREATED;
101:         }
102:         addMultipleGoodsToShoppingBasket( userEmailString, goodIndices, quantities,
103:                 comments, expectedAddStatuses );
104:     }
105: 
106: 
107:     public void checkMultipleShoppingBasketPositions( String userEmailString,
108:                                                          Integer[] goodIndices, Integer[] expectedQuantities,
109:                                                          String[] expectedComments, Boolean[] expectedToBeFound ) throws Exception {
110:         UUID shoppingBasketId = getShoppingBasketId( userEmailString );
111:         String shoppingBasketUri = "/shoppingBaskets?mailAddress=" + userEmailString;
112:         String baseUri = "/shoppingBaskets/" + shoppingBasketId + "/shoppingBasketPositions/";
113: 
114:         // check that the shopping basket contains all the goods ...
115:         int totalQuantity = 0;
116:         for ( int i = 0; i < goodIndices.length; i++ ) {
117:             if ( expectedQuantities[i] != null ) {
118:                 totalQuantity += expectedQuantities[i];
119:             }
120:         }
121:         mockMvc.perform( get( shoppingBasketUri ) )
122:                 .andExpect( OK )
123:                 .andExpect( jsonPath( "$.totalQuantity" ).value( totalQuantity ) );
124: 
125:         // check that each good has the correct quantity and comment ...
126:         for ( int i = 0; i < goodIndices.length; i++ ) {
127:             UUID goodId = (UUID) GOOD_DATA[goodIndices[i]][0];
128:             if ( expectedToBeFound[i] ) {
129:                 mockMvc.perform( get( baseUri + goodId ) )
130:                         .andExpect( OK )
131:                         .andExpect( jsonPath( "$.quantity" ).value( expectedQuantities[i] ) )
132:                         .andExpect( jsonPath( "$.comment" ).value( expectedComments[i] ) );
133:             } else {
134:                 mockMvc.perform( get( baseUri + goodId ) )
135:                         .andExpect( NOT_FOUND );
136:             }
137:         }
138:     }
139: 
140: 
141:     public void checkMultipleShoppingBasketPositions( String userEmailString,
142:                                                          Integer[] goodIndices, Integer[] expectedQuantities,
143:                                                          String[] expectedComments ) throws Exception {
144:         Boolean[] expectedToBeFound = new Boolean[goodIndices.length];
145:         for ( int i = 0; i < goodIndices.length; i++ ) {
146:             expectedToBeFound[i] = true;
147:         }
148:         checkMultipleShoppingBasketPositions( userEmailString, goodIndices, expectedQuantities,
149:                 expectedComments, expectedToBeFound );
150:     }
151: 
152: 
153: 
154:     public void checkMultipleOrderPositionsInLatestOrder(
155:             String userEmailString, Integer[] goodIndices, Integer[] expectedQuantities,
156:             String[] expectedComments ) throws Exception {
157:         String latestOrderUri = "/orders?mailAddress=" + userEmailString + "&filter=latest";
158: 
159:         // Calculate the total price of the order ...
160:         float totalPrice = 0f;
161:         for ( int i = 0; i < goodIndices.length; i++ ) {
162:             totalPrice += expectedQuantities[i] * ((MoneyType) GOOD_DATA[goodIndices[i]][5]).getAmount();
163:         }
164: 
165:         // ... and check that the order has the correct total price (and other data)
166:         ResultActions resultActions = mockMvc.perform( get( latestOrderUri ) ).andExpect( OK )
167:                 .andExpect( jsonPath( "$.length()" ).value( 1 ) )
168:                 .andExpect( jsonPath( "$[0].price.amount" ).value( totalPrice ) )
169:                 .andExpect( jsonPath( "$[0].mailAddress.mailAddressString" ).value( userEmailString ) );
170: 
171:         // Now check that all the expected parts are there
172:         for ( int i = 0; i < goodIndices.length; i++ ) {
173:             UUID goodId = (UUID) GOOD_DATA[goodIndices[i]][0];
174:             resultActions.andExpect(
175:                     jsonPath( "$[0].orderPositions.length()" ).value( goodIndices.length ) );
176:             resultActions.andExpect(
177:                     jsonPath( "$[0].orderPositions[?(@.goodId == '" + goodId + "')].quantity" )
178:                             .value( expectedQuantities[i] ) );
179:             if ( expectedComments[i] != null ) {
180:                 resultActions.andExpect(
181:                         jsonPath( "$[0].orderPositions[?(@.goodId == '" + goodId + "')].comment" )
182:                                 .value( expectedComments[i] ) );
183:             }
184:         }
185:     }
186: 
187: }
188: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\testdtos\CommentDTO.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests.testdtos;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import lombok.*;
5: 
6: import java.util.UUID;
7: 
8: /**
9:  * A DTO containing just a comment, used in testing.
10:  */
11: 
12: @AllArgsConstructor
13: @NoArgsConstructor
14: @Setter
15: @Getter
16: @ToString
17: @JsonIgnoreProperties(ignoreUnknown = true)
18: public class CommentDTO {
19:     private UUID goodId;
20:     private String comment;
21: }
22: 
23: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\testdtos\IdDTO.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests.testdtos;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import lombok.*;
5: 
6: import java.util.UUID;
7: 
8: /**
9:  * A DTO containing just the id of an entity, used in testing.
10:  */
11: 
12: @AllArgsConstructor
13: @NoArgsConstructor
14: @Setter
15: @Getter
16: @ToString
17: @JsonIgnoreProperties(ignoreUnknown = true)
18: public class IdDTO {
19:     private UUID id;
20: }
21: 
22: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\e1e2resttests\testdtos\QuantityAndCommentDTO.java ---
1: package thkoeln.archilab.ecommerce.e1e2resttests.testdtos;
2: 
3: import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
4: import lombok.*;
5: 
6: import java.util.UUID;
7: 
8: /**
9:  * A DTO containing just a quantity, used in testing.
10:  */
11: 
12: 
13: @NoArgsConstructor
14: @Setter
15: @Getter
16: @ToString
17: @JsonIgnoreProperties(ignoreUnknown = true)
18: public class QuantityAndCommentDTO {
19:     private UUID goodId;
20:     private Integer quantity;
21:     private String comment;
22: 
23:     public QuantityAndCommentDTO( UUID goodId, Integer quantity, String comment ) {
24:         this.goodId = goodId;
25:         this.quantity = quantity;
26:         this.comment = comment;
27:     }
28: }
29: 
30: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionMailAddressTest.java ---
1: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionMoneyTest.java ---
1: package thkoeln.archilab.ecommerce.regression.domainprimitives;
2: 
3: import org.junit.jupiter.api.Test;
4: import thkoeln.archilab.ecommerce.ShopException;
5: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
6: 
7: import static org.junit.jupiter.api.Assertions.*;
8: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.*;
9: 
10: class RegressionMoneyTest {
11: 
12:     @Test
13:     public void testGetAmount() {
14:         // given
15:         Float inputAmount = 10.0f;
16: 
17:         // when
18:         MoneyType instance = instantiateMoney( inputAmount, "EUR" );
19: 
20:         // then
21:         assertEquals( inputAmount, instance.getAmount() );
22:     }
23: 
24:     @Test
25:     public void testGetCurrency() {
26:         // given
27:         String inputCurrency = "EUR";
28: 
29:         // when
30:         MoneyType instance = instantiateMoney( 10.0f, inputCurrency );
31: 
32:         // then
33:         assertEquals( inputCurrency, instance.getCurrency() );
34:     }
35: 
36:     @Test
37:     public void testAddTo() {
38:         // given
39:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
40:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
41:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
42: 
43:         // when
44:         MoneyType result12 = instance1.add( instance2 );
45:         MoneyType result13 = instance1.add( instance3 );
46: 
47:         // then
48:         assertEquals( 30.0f, result12.getAmount() );
49:         assertEquals( "EUR", result12.getCurrency() );
50:         assertEquals( 10.0f, result13.getAmount() );
51:         assertEquals( "EUR", result12.getCurrency() );
52:     }
53: 
54:     @Test
55:     public void testInvalidAddTo() {
56:         // given
57:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
58:         MoneyType instance2 = instantiateMoney( 20.0f, "CHF" );
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class, () -> instance1.add( instance2 ) );
63:     }
64: 
65:     @Test
66:     public void testSubtractFrom() {
67:         // given
68:         MoneyType instance1 = instantiateMoney( 30.0f, "EUR" );
69:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
70:         MoneyType instance3 = instantiateMoney( 0.0f, "EUR" );
71:         MoneyType instance4 = instantiateMoney( 30.0f, "EUR" );
72: 
73:         // when
74:         MoneyType result12 = instance1.subtract( instance2 );
75:         MoneyType result13 = instance1.subtract( instance3 );
76:         MoneyType result14 = instance1.subtract( instance4 );
77: 
78:         // then
79:         assertEquals( 10.0f, result12.getAmount() );
80:         assertEquals( "EUR", result12.getCurrency() );
81:         assertEquals( 30.0f, result13.getAmount() );
82:         assertEquals( "EUR", result13.getCurrency() );
83:         assertEquals( 0.0f, result14.getAmount() );
84:         assertEquals( "EUR", result14.getCurrency() );
85:     }
86: 
87:     @Test
88:     public void testInvalidSubtractFrom() {
89:         // given
90:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
91:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
92:         MoneyType instance3 = instantiateMoney( 5.0f, "CHF" );
93: 
94:         // when
95:         // then
96:         assertThrows( ShopException.class, () -> instance1.subtract( instance2 ) );
97:         assertThrows( ShopException.class, () -> instance1.subtract( instance3 ) );
98:     }
99: 
100:     @Test
101:     public void testMultiplyBy() {
102:         // given
103:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
104: 
105:         // when
106:         MoneyType result = instance.multiplyBy( 3 );
107: 
108:         // then
109:         assertEquals( 30.0f, result.getAmount() );
110:         assertEquals( "EUR", result.getCurrency() );
111:     }
112: 
113:     @Test
114:     public void testFactoryMethodValid() {
115:         // given
116:         // when
117:         // then
118:         assertDoesNotThrow( () -> instantiateMoney( 10.0f, "EUR" ) );
119:     }
120: 
121:     @Test
122:     public void testFactoryMethodInvalid() {
123:         // given
124:         // when
125:         // then
126:         assertThrows( ShopException.class, () -> instantiateMoney( -10.0f, "EUR" ) );
127:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, "USD" ) );
128:         assertThrows( ShopException.class, () -> instantiateMoney( null, "EUR" ) );
129:         assertThrows( ShopException.class, () -> instantiateMoney( 10.0f, null ) );
130:     }
131: 
132:     @Test
133:     public void testLargerThan() {
134:         // given
135:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
136:         MoneyType instance2 = instantiateMoney( 20.0f, "EUR" );
137:         MoneyType instance3 = instantiateMoney( 10.0f, "EUR" );
138:         MoneyType instance4 = instantiateMoney( 10.0f, "CHF" );
139: 
140:         // when
141:         // then
142:         assertTrue( instance2.largerThan( instance1 ) );
143:         assertFalse( instance1.largerThan( instance2 ) );
144:         assertFalse( instance1.largerThan( instance3 ) );
145:         assertThrows( ShopException.class, () -> instance1.largerThan( instance4 ) );
146:     }
147: 
148: 
149:     @Test
150:     public void testValueObjectEquality() {
151:         // given
152:         // when
153:         MoneyType instance1 = instantiateMoney( 10.0f, "EUR" );
154:         MoneyType instance2 = instantiateMoney( 10.0f, "EUR" );
155:         MoneyType instance3 = instantiateMoney( 20.0f, "EUR" );
156: 
157:         // then
158:         assertEquals( instance1, instance2 );
159:         assertNotEquals( instance1, instance3 );
160:     }
161: 
162:     @Test
163:     public void testImmutability() {
164:         // given
165:         // when
166:         MoneyType instance = instantiateMoney( 10.0f, "EUR" );
167: 
168:         // then
169:         try {
170:             instance.getClass().getMethod( "setAmount", Float.class );
171:             fail( "setAmount method should not exist" );
172:         } catch (NoSuchMethodException e) {
173:             // Success: the object is immutable
174:         }
175: 
176:         try {
177:             instance.getClass().getMethod( "setCurrency", String.class );
178:             fail( "setCurrency method should not exist" );
179:         } catch (NoSuchMethodException e) {
180:             // Success: the object is immutable
181:         }
182:     }
183: }
184: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionPersonalAddressTest.java ---
1: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\regression\domainprimitives\RegressionZipCodeTest.java ---
1: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\regression\RegressionGoodCatalogTest.java ---
1: package thkoeln.archilab.ecommerce.regression;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.ShopException;
8: import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
9: import thkoeln.archilab.ecommerce.usecases.InventoryManagementUseCases;
10: import thkoeln.archilab.ecommerce.usecases.GoodCatalogUseCases;
11: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MoneyType;
12: 
13: import javax.transaction.Transactional;
14: import java.util.UUID;
15: 
16: import static org.junit.jupiter.api.Assertions.*;
17: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.GOOD_DATA;
18: 
19: @SpringBootTest
20: @Transactional
21: public class RegressionGoodCatalogTest {
22: 
23:     @Autowired
24:     private GoodCatalogUseCases goodCatalogUseCases;
25:     @Autowired
26:     private InventoryManagementUseCases inventoryManagementUseCases;
27:     @Autowired
28:     private InitialMasterDataCreator initialMasterDataCreator;
29: 
30:     @BeforeEach
31:     public void setUp() {
32:         initialMasterDataCreator.deleteAll();
33:     }
34: 
35: 
36: 
37:     @Test
38:     public void testAddGoodToCatalog() {
39:         // given
40:         initialMasterDataCreator.addAllGoods();
41: 
42:         // when
43:         MoneyType sellingPrice = goodCatalogUseCases.getSellingPrice( (UUID) GOOD_DATA[4][0] );
44: 
45:         // then
46:         assertEquals( GOOD_DATA[4][5], sellingPrice );
47:     }
48: 
49:     @Test
50:     public void testRemoveGoodFromCatalog() {
51:         // given
52:         initialMasterDataCreator.addAllGoods();
53:         UUID goodId = (UUID) GOOD_DATA[4][0];
54: 
55:         // when
56:         assertDoesNotThrow( () -> goodCatalogUseCases.getSellingPrice( goodId ) );
57:         goodCatalogUseCases.removeGoodFromCatalog( goodId );
58: 
59:         // then
60:         assertThrows( ShopException.class, () -> goodCatalogUseCases.getSellingPrice( goodId ) );
61:     }
62: 
63: 
64: 
65: 
66:     @Test
67:     public void testRemoveGoodThatIsInInventory() {
68:         // given
69:         initialMasterDataCreator.addAllGoods();
70:         UUID goodId = (UUID) GOOD_DATA[4][0];
71:         inventoryManagementUseCases.addToInventory( goodId, 3 );
72: 
73:         // when
74:         // then
75:         assertThrows( ShopException.class, () -> goodCatalogUseCases.removeGoodFromCatalog( goodId ) );
76:     }
77: 
78: 
79:     @Test
80:     public void testClearGoodCatalog() {
81:         // given
82:         initialMasterDataCreator.addAllGoods();
83: 
84:         // when
85:         goodCatalogUseCases.deleteGoodCatalog();
86: 
87:         // then
88:         assertThrows( ShopException.class, () -> goodCatalogUseCases.getSellingPrice( (UUID) GOOD_DATA[4][0] ) );
89:     }
90: 
91: }
92: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\regression\RegressionInventoryManagementTest.java ---
1: package thkoeln.archilab.ecommerce.regression;
2: 
3: import org.junit.jupiter.api.BeforeEach;
4: import org.junit.jupiter.api.Test;
5: import org.springframework.beans.factory.annotation.Autowired;
6: import org.springframework.boot.test.context.SpringBootTest;
7: import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
8: import thkoeln.archilab.ecommerce.usecases.InventoryManagementUseCases;
9: 
10: import javax.transaction.Transactional;
11: import java.util.UUID;
12: 
13: import static org.junit.jupiter.api.Assertions.assertEquals;
14: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.GOOD_INVENTORY;
15: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.GOOD_DATA;
16: 
17: @SpringBootTest
18: @Transactional
19: public class RegressionInventoryManagementTest {
20: 
21:     @Autowired
22:     private InventoryManagementUseCases inventoryManagementUseCases;
23:     @Autowired
24:     private InitialMasterDataCreator initialMasterDataCreator;
25: 
26: 
27:     @BeforeEach
28:     public void setUp() {
29:         initialMasterDataCreator.deleteAll();
30:         initialMasterDataCreator.addAllGoods();
31:     }
32: 
33: 
34: 
35:     @Test
36:     public void testAddToInventory() {
37:         // given
38:         initialMasterDataCreator.inventoryUpAllGoods();
39:         UUID goodId8 = (UUID) GOOD_DATA[8][0];
40: 
41:         // when
42:         int inventory8before = inventoryManagementUseCases.getAvailableInventory( goodId8 );
43:         assertEquals( GOOD_INVENTORY.get( goodId8 ), inventory8before );
44:         inventoryManagementUseCases.addToInventory( goodId8, 22 );
45:         int inventory8after = inventoryManagementUseCases.getAvailableInventory( goodId8 );
46:         inventoryManagementUseCases.addToInventory( goodId8, 1 );
47:         int inventory8after2 = inventoryManagementUseCases.getAvailableInventory( goodId8 );
48: 
49:         // then
50:         assertEquals( inventory8before + 22, inventory8after );
51:         assertEquals( inventory8after + 1, inventory8after2 );
52:     }
53: 
54: 
55:     @Test
56:     public void testRemoveFromInventory() {
57:         // given
58:         initialMasterDataCreator.inventoryUpAllGoods();
59:         UUID goodId6 = (UUID) GOOD_DATA[6][0];
60:         int inventory6before = GOOD_INVENTORY.get( goodId6 );
61:         UUID goodId9 = (UUID) GOOD_DATA[9][0];
62:         int inventory9before = GOOD_INVENTORY.get( goodId9 );
63:         UUID goodId1 = (UUID) GOOD_DATA[1][0];
64:         int inventory1before = GOOD_INVENTORY.get( goodId1 );
65: 
66:         // when
67:         inventoryManagementUseCases.removeFromInventory( goodId6, 1 );
68:         int inventory6after = inventoryManagementUseCases.getAvailableInventory( goodId6 );
69:         inventoryManagementUseCases.removeFromInventory( goodId1, 3 );
70:         int inventory1after = inventoryManagementUseCases.getAvailableInventory( goodId1 );
71:         inventoryManagementUseCases.removeFromInventory( goodId9, inventory9before );
72:         int inventory9after = inventoryManagementUseCases.getAvailableInventory( goodId9 );
73: 
74:         // then
75:         assertEquals( inventory6before - 1, inventory6after );
76:         assertEquals( inventory1before - 3, inventory1after );
77:         assertEquals( 0, inventory9after );
78:     }
79: 
80: }
81: 

--- FILE: C:\workspace\Masterarbeit\Repositories\Rest\ST2M4_group_a8d84254-2915-489d-8562-5d38d308efdd\src\test\java\thkoeln\archilab\ecommerce\regression\RegressionUserRegistrationTest.java ---
1: package thkoeln.archilab.ecommerce.regression;
2: 
3: import org.junit.jupiter.api.Assertions;
4: import org.junit.jupiter.api.BeforeEach;
5: import org.junit.jupiter.api.Test;
6: import org.springframework.beans.factory.annotation.Autowired;
7: import org.springframework.boot.test.context.SpringBootTest;
8: import thkoeln.archilab.ecommerce.ShopException;
9: import thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator;
10: import thkoeln.archilab.ecommerce.usecases.UserRegistrationUseCases;
11: import thkoeln.archilab.ecommerce.usecases.UserType;
12: import thkoeln.archilab.ecommerce.usecases.domainprimitivetypes.MailAddressType;
13: 
14: import javax.transaction.Transactional;
15: 
16: import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
17: import static org.junit.jupiter.api.Assertions.assertThrows;
18: import static thkoeln.archilab.ecommerce.masterdata.FactoryMethodInvoker.instantiateMailAddress;
19: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.USER_ADDRESS;
20: import static thkoeln.archilab.ecommerce.masterdata.InitialMasterDataCreator.USER_EMAIL;
21: 
22: @SpringBootTest
23: @Transactional
24: public class RegressionUserRegistrationTest {
25: 
26:     @Autowired
27:     private UserRegistrationUseCases userRegistrationUseCases;
28:     @Autowired
29:     private InitialMasterDataCreator initialMasterDataCreator;
30: 
31:     private MailAddressType nonExistingMailAddress;
32: 
33:     @BeforeEach
34:     public void setUp() {
35:         initialMasterDataCreator.deleteAll();
36:         nonExistingMailAddress = instantiateMailAddress( "this@nononono.de" );
37:     }
38: 
39: 
40:     @Test
41:     public void testAllUsersRegistered() {
42:         // given
43:         initialMasterDataCreator.registerAllUsers();
44: 
45:         // when
46:         UserType user3 = userRegistrationUseCases.getUserData( USER_EMAIL[3] );
47: 
48:         // then
49:         Assertions.assertEquals( initialMasterDataCreator.USER_NAME[3], user3.getName() );
50:         Assertions.assertEquals( USER_EMAIL[3], user3.getMailAddress() );
51:         Assertions.assertEquals( USER_ADDRESS[3], user3.getPersonalAddress() );
52:     }
53: 
54: 
55:     @Test
56:     public void testRegisterUserWithDuplicateMailAddress() {
57:         // given
58:         initialMasterDataCreator.registerAllUsers();
59: 
60:         // when
61:         // then
62:         assertThrows( ShopException.class, () ->
63:                 userRegistrationUseCases.register( "Gandalf The Grey", USER_EMAIL[5],
64:                         USER_ADDRESS[5] ) );
65:     }
66: 
67:     @Test
68:     public void testRegisterUserWithDuplicateNameOrPersonalAddress() {
69:         // given
70:         initialMasterDataCreator.registerAllUsers();
71:         MailAddressType newMailAddress = instantiateMailAddress( "some@this.de" );
72: 
73:         // when
74:         // then
75:         assertDoesNotThrow(() ->
76:                 userRegistrationUseCases.register( initialMasterDataCreator.USER_NAME[2], newMailAddress,
77:                         USER_ADDRESS[2] ) );
78:     }
79: 
80: 
81:     @Test
82:     public void testDeleteUsersNoMoreUsers() {
83:         // given
84:         initialMasterDataCreator.registerAllUsers();
85: 
86:         // when
87:         userRegistrationUseCases.deleteAllUsers();
88: 
89:         // then
90:         assertThrows( ShopException.class, () -> userRegistrationUseCases.getUserData( USER_EMAIL[0] ) );
91:     }
92: 
93: }
94: 

[RESPONSE]:

Generated by gemini-3-pro-preview
-----------------------------------